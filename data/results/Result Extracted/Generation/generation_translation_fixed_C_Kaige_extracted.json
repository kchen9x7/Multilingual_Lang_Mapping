[
  {
    "task_id": "C/1",
    "prompt": {
      "en": "#include <assert.h>\n#include <string.h>\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "sq": "#include <assert.h>\n#include <string.h>\n// Kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "hy": "#include <assert.h>\n#include <string.h>\n// Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "bn": "#include <assert.h>\n#include <string.h>\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nchar *hello_mmcodeeval()",
      "bg": "#include <assert.h>\n#include <string.h>\n// Връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "zh": "#include <assert.h>\n#include <string.h>\n// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "fr": "#include <assert.h>\n#include <string.h>\n// Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "de": "#include <assert.h>\n#include <string.h>\n// Gibt \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück\nchar *hello_mmcodeeval()",
      "ha": "#include <assert.h>\n#include <string.h>\n// Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "hi": "#include <assert.h>\n#include <string.h>\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nchar *hello_mmcodeeval()",
      "hu": "#include <assert.h>\n#include <string.h>\n// Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "sq": "0.9328045338781835",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.9328045338781835",
      "zh": "0.999999801369619",
      "fr": "0.9978188397858558",
      "de": "0.9978188397858558",
      "ha": "0.9163474109183",
      "hi": "0.9355251742072184",
      "hu": "0.9355251742072184"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "Write a C function `char *hello_mmcodeeval()` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Shkruani një funksion në C `char *hello_mmcodeeval()` për të zgjidhur problemin e mëposhtëm: Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Գրեք C ֆունկցիա `char *hello_mmcodeeval()` հետևյալ խնդիրը լուծելու համար: Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "একটি C ফাংশন `char *hello_mmcodeeval()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" রিটার্ন করুন",
      "bg": "Напишете C функция `char *hello_mmcodeeval()` за решаване на следния проблем:  \nВърнете \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "编写一个 C 函数 `char *hello_mmcodeeval()` 来解决以下问题：  \n返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Écrivez une fonction C `char *hello_mmcodeeval()` pour résoudre le problème suivant :  \nRetourner \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Schreiben Sie eine C-Funktion `char *hello_mmcodeeval()`, um das folgende Problem zu lösen:  \nGeben Sie \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück.",
      "ha": "Rubuta wani aikin C `char *hello_mmcodeeval()` don warware matsalar mai zuwa: Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "एक C फ़ंक्शन `char *hello_mmcodeeval()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं।",
      "hu": "Írj egy C függvényt `char *hello_mmcodeeval()` a következő probléma megoldására:  \nAdja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget"
    },
    "instruction_bertscore": {
      "sq": "0.9891494181752072",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.9934769782868142",
      "ha": "1",
      "hi": "0.9934769782868142",
      "hu": "0.9802189962438785"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(strcmp(hello_mmcodeeval(), \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\") == 0);\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "char *hello_mmcodeeval()",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "রিটার্ন \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation",
      "bg": "Върнете \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Komawa \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "रिटर्न \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hu": "Visszatér \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "sq": "0.9361431133226179",
      "hy": "0.999999801369619",
      "bn": "0.8909985989513896",
      "bg": "0.9625917417093185",
      "zh": "0.8731603989521705",
      "fr": "0.9993989444669884",
      "de": "0.999999801369619",
      "ha": "0.8514866462951676",
      "hi": "0.9520081191166365",
      "hu": "0.9625917417093185"
    }
  },
  {
    "task_id": "C/2",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its three sides.\n​    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n​    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n​    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n​    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthe \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n​    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n​    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնում է \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটার:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন।\nঅন্যথায়, \"-1\" রিটার্ন করুন\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете лицето на триъгълник, дадени неговите три страни.\n​    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n​    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната точка.\nВ противен случай връща \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定三边的三角形面积。\n​    参数:\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n​    返回:\n- str: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné ses trois côtés.\n    Paramètres :\n- a (float) : Longueur du côté 'a'.\n- b (float) : Longueur du côté 'b'.\n- c (float) : Longueur du côté 'c'.\n    Renvoie :\n- str : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks anhand seiner drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabe:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika idan aka ba da gefensa uku.\n​    Sigogi:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n​    Mayarwa:\n- str: Idan gefen da aka bayar sun samar da alwatika, mayar da yankin da aka ƙididdige tare da wurare guda 2 bayan alamar kashi.\nIn ba haka ba, mayar da \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nतीन भुजाओं के दिए गए लंबाई के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\nअन्यथा, \"-1\" लौटाएं\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét a három oldalának ismeretében.\n​    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n​    Visszatér:\n- str: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegyre kerekítve.\nEgyébként térjen vissza \"-1\"-gyel.\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "sq": "0.8342500511869016",
      "hy": "0.9841149325374969",
      "bn": "0.9875011832733797",
      "bg": "0.9868806619630267",
      "zh": "0.982316533067607",
      "fr": "0.9751723941529252",
      "de": "0.9826122937049679",
      "ha": "0.9875011832733797",
      "hi": "0.975575812456807",
      "hu": "0.975228606550758"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "en": "Write a C function `double calculate_triangle_area(double a, double b, double c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n",
      "sq": "Shkruani një funksion në C `double calculate_triangle_area(double a, double b, double c)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthen \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hy": "Գրեք C ֆունկցիա `double calculate_triangle_area(double a, double b, double c)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\n    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում վերադարձնում է \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "bn": "একটি C ফাংশন `double calculate_triangle_area(double a, double b, double c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর তিনটি বাহু দেওয়া হলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন।\nঅন্যথায়, \"-1\" রিটার্ন করুন\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "bg": "Напишете C функция `double calculate_triangle_area(double a, double b, double c)`, за да решите следния проблем:\nИзчислете лицето на триъгълник, дадени неговите три страни.\n    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n    Връща:\n- str: Ако предоставените страни образуват триъгълник, върнете изчисленото лице с 2 знака след десетичната запетая.\nВ противен случай върнете \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "zh": "编写一个 C 函数 `double calculate_triangle_area(double a, double b, double c)` 来解决以下问题：\n计算给定三边的三角形面积。\n    参数：\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回：\n- str: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "fr": "Écrire une fonction C `double calculate_triangle_area(double a, double b, double c)` pour résoudre le problème suivant :\nCalculer l'aire d'un triangle donné par ses trois côtés.\n    Paramètres :\n- a (float) : Longueur du côté 'a'.\n- b (float) : Longueur du côté 'b'.\n- c (float) : Longueur du côté 'c'.\n    Renvoie :\n- str : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"",
      "de": "Schreiben Sie eine C-Funktion `double calculate_triangle_area(double a, double b, double c)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabe:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "ha": "Rubuta aikin C `double calculate_triangle_area(double a, double b, double c)` don warware matsalar mai zuwa:\nƘididdige yankin wani alwatika idan aka ba da gefen sa uku.\n    Sigogi:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n    Komawa:\n- str: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare 2 na adadi mai lamba.\nIn ba haka ba, dawo da \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hi": "C फ़ंक्शन `double calculate_triangle_area(double a, double b, double c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइसके तीन भुजाओं के दिए गए लंबाई के आधार पर त्रिभुज का क्षेत्रफल ज्ञात करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न्स:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, \"-1\" लौटाएँ\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hu": "Írj egy C függvényt `double calculate_triangle_area(double a, double b, double c)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n    Visszatérési érték:\n- str: Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEgyébként térj vissza \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6"
    },
    "instruction_bertscore": {
      "sq": "0.9902835976509163",
      "hy": "0.9945450138456389",
      "bn": "0.9940418830904775",
      "bg": "0.9983571281184604",
      "zh": "0.9857490646822709",
      "fr": "0.9493325678840966",
      "de": "0.985857516870316",
      "ha": "0.996766098766371",
      "hi": "0.931953402695449",
      "hu": "0.966261239368557"
    },
    "level": "easy",
    "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = calculate_triangle_area(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculate_triangle_area(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n    Parameters:\n- a (float): Length of side 'a'.\n- b (float): Length of side 'b'.\n- c (float): Length of side 'c'.\n    Returns:\n- str: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n    Parametrat:\n- a (float): Gjatësia e anës 'a'.\n- b (float): Gjatësia e anës 'b'.\n- c (float): Gjatësia e anës 'c'.\n    Kthen:\n- str: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\nPërndryshe, kthen \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hy": "Եռանկյան մակերեսը հաշվարկել, եթե տրված են նրա երեք կողմերը:\n    Պարամետրեր:\n- a (float): 'a' կողմի երկարությունը:\n- b (float): 'b' կողմի երկարությունը:\n- c (float): 'c' կողմի երկարությունը:\n    Վերադարձնում է:\n- str: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը 2 տասնորդական թվանշաններով:\nՀակառակ դեպքում, վերադարձնում է \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "bn": "ত্রিভুজের তিনটি বাহুর দৈর্ঘ্য দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- a (float): বাহু 'a' এর দৈর্ঘ্য।\n- b (float): বাহু 'b' এর দৈর্ঘ্য।\n- c (float): বাহু 'c' এর দৈর্ঘ্য।\n    রিটার্নস:\n- str: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে ২ দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন।\nঅন্যথায়, \"-1\" ফেরত দিন\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "bg": "Изчисляване на лицето на триъгълник, дадени неговите три страни.\n    Параметри:\n- a (float): Дължина на страна 'a'.\n- b (float): Дължина на страна 'b'.\n- c (float): Дължина на страна 'c'.\n    Връща:\n- str: Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната запетая.\nВ противен случай връща \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "zh": "计算给定三边的三角形面积。\n    参数:\n- a (float): 边 'a' 的长度。\n- b (float): 边 'b' 的长度。\n- c (float): 边 'c' 的长度。\n    返回:\n- str: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "fr": "Calculer l'aire d'un triangle donné par ses trois côtés.\n    Paramètres:\n- a (float): Longueur du côté 'a'.\n- b (float): Longueur du côté 'b'.\n- c (float): Longueur du côté 'c'.\n    Renvoie:\n- str: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "de": "Berechnen Sie die Fläche eines Dreiecks anhand seiner drei Seiten.\n    Parameter:\n- a (float): Länge der Seite 'a'.\n- b (float): Länge der Seite 'b'.\n- c (float): Länge der Seite 'c'.\n    Rückgabewerte:\n- str: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie \"-1\" zurück.\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "ha": "Ƙididdige yanki na alwatika idan aka ba da gefensa uku.\n    Parameters:\n- a (float): Tsawon gefen 'a'.\n- b (float): Tsawon gefen 'b'.\n- c (float): Tsawon gefen 'c'.\n    Returns:\n- str: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka lissafa tare da wurare biyu na goma.\nIn ba haka ba, dawo da \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर क्षेत्रफल की गणना करें।\n    पैरामीटर्स:\n- a (float): भुजा 'a' की लंबाई।\n- b (float): भुजा 'b' की लंबाई।\n- c (float): भुजा 'c' की लंबाई।\n    रिटर्न:\n- str: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, \"-1\" लौटाएँ\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "hu": "Számítsa ki egy háromszög területét a három oldalának megadásával.\n    Paraméterek:\n- a (float): Az 'a' oldal hossza.\n- b (float): A 'b' oldal hossza.\n- c (float): A 'c' oldal hossza.\n    Visszatérési érték:\n- str: Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal.\nEllenkező esetben adja vissza \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9928961830526682",
      "hy": "0.9786819943554306",
      "bn": "0.9815172444143226",
      "bg": "0.9956720426276309",
      "zh": "0.9770252183472187",
      "fr": "0.9792892074302543",
      "de": "0.9842255696597333",
      "ha": "0.9946475071222529",
      "hi": "0.9785282544405096",
      "hu": "0.9515401459389183"
    }
  },
  {
    "task_id": "C/3",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit vlerën e funksionit për një input të dhënë.\n    Parametrat:\n- x (int): Vlera e inputit për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվարկել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n    Պարամետրեր:\n- x (int): Ֆունկցիայի մուտքային արժեքը։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ \nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটার:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নস:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в дефинирания домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n\n    Дефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定输入的函数值。\n    参数:\n- x (int): 函数的输入值。\n    返回:\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算的函数值，保留到小数点后5位。\n\n    函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou chaîne: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabewerte:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n    Komawa:\n- double ko string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige wanda aka zagaye zuwa wurare 5 na goma.\n\n    Ma'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési érték:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n\n    Függvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "sq": "0.986950579857151",
      "hy": "0.9451815901812295",
      "bn": "0.9864414901905585",
      "bg": "0.9874473544401192",
      "zh": "0.9653672040235189",
      "fr": "0.980865140873385",
      "de": "0.9742416121873957",
      "ha": "0.9831013217030758",
      "hi": "0.9876646560769714",
      "hu": "0.9751763667605459"
    },
    "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}",
    "instruction": {
      "en": "Write a C function `const char* calculate_function_value(int x)` to solve the following problem:\nCalculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define\n",
      "sq": "Shkruani një funksion në C `const char* calculate_function_value(int x)` për të zgjidhur problemin në vijim:\nLlogaritni vlerën e funksionit për një hyrje të dhënë.\n    Parametrat:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hy": "Գրեք C ֆունկցիա `const char* calculate_function_value(int x)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n    Պարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական նշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "bn": "একটি C ফাংশন `const char* calculate_function_value(int x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটার:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নস:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\n    ফাংশন সংজ্ঞা:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "bg": "Напишете C функция `const char* calculate_function_value(int x)`, за да решите следния проблем:\nИзчислете стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или низ: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\n    Дефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "zh": "编写一个 C 函数 `const char* calculate_function_value(int x)` 来解决以下问题：\n计算给定输入的函数值。\n参数：\n- x (int): 函数的输入值。\n返回：\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，四舍五入到小数点后 5 位。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "fr": "Écrire une fonction C `const char* calculate_function_value(int x)` pour résoudre le problème suivant :\nCalculer la valeur de la fonction pour une entrée donnée.\n    Paramètres :\n- x (int) : Valeur d'entrée pour la fonction.\n    Renvoie :\n- double ou chaîne de caractères : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction :\n- Pour 0 <= x < 10 : y = cos(x + 3.0)\n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "de": "Schreiben Sie eine C-Funktion `const char* calculate_function_value(int x)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabe:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "ha": "Rubuta wani aikin C `const char* calculate_function_value(int x)` don warware matsalar mai zuwa:\nƘididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Ƙimar shigarwa don aikin.\n    Mayarwa:\n- double ko string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na decimal.\n\n    Ma'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hi": "C फ़ंक्शन `const char* calculate_function_value(int x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hu": "Írj egy C függvényt `const char* calculate_function_value(int x)` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési érték:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n\n    Függvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define"
    },
    "instruction_bertscore": {
      "sq": "0.9803649895739392",
      "hy": "0.9549500336901443",
      "bn": "0.9507331107007736",
      "bg": "0.9873992858879088",
      "zh": "0.9803874348069962",
      "fr": "0.9782547404058246",
      "de": "0.9768114920572251",
      "ha": "0.9833055137347797",
      "hi": "0.9772242459890156",
      "hu": "0.9639519625586453"
    },
    "level": "middle",
    "test": "int main() {\n    const char* result = calculate_function_value(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(calculate_function_value(40), \"Not define\") == 0);\n    assert(strcmp(calculate_function_value(5), \"-0.14550\") == 0);\n    assert(strcmp(calculate_function_value(15), \"0.76266\") == 0);\n    assert(strcmp(calculate_function_value(25), \"0.31314\") == 0);\n    assert(strcmp(calculate_function_value(-1), \"Not define\") == 0);\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "const char* calculate_function_value(int x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\n    Parameters:\n- x (int): Input value for the function.\n    Returns:\n- double or string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\n    Function Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define\n",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n    Parametra:\n- x (int): Vlera e hyrjes për funksionin.\n    Kthen:\n- double ose string: Nëse x nuk është në domenin e përcaktuar, kthen \"Jo e përcaktuar\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n\n    Përkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Jo e përcaktuar",
      "hy": "Հաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n    Պարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\n    Վերադարձնում է:\n- double կամ string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\n    Ֆունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\n    রিটার্নসমূহ:\n- double বা string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\n    ফাংশনের সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "bg": "Изчислява стойността на функцията за даден вход.\n    Параметри:\n- x (int): Входна стойност за функцията.\n    Връща:\n- double или string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\n    Определения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "zh": "计算给定输入的函数值。\n    参数：\n- x (int): 函数的输入值。\n    返回：\n- double 或 string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留到小数点后五位。\n\n    函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n    Paramètres:\n- x (int): Valeur d'entrée pour la fonction.\n    Renvoie:\n- double ou string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\n    Définitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n    Parameter:\n- x (int): Eingabewert für die Funktion.\n    Rückgabewerte:\n- double oder string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\n    Funktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "ha": "Ƙididdige ƙimar aikin don wani shigarwa da aka bayar.\n    Sigogi:\n- x (int): Darajar shigarwa don aikin.\n    Returns:\n- double ko string: Idan x ba ya cikin kewayon da aka ayyana, yana dawowa da \"Not define\".\nIn ba haka ba, yana dawowa da darajar aikin da aka lissafa an zagaye zuwa wurare 5 na decimal.\n\n    Function Definitions:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n    पैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\n    रिटर्न्स:\n- double या string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\n    फ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\n    Paraméterek:\n- x (int): A függvény bemeneti értéke.\n    Visszatérési érték:\n- double vagy string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n\n    Függvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define"
    },
    "docstring_bertscore": {
      "sq": "0.9727524802207771",
      "hy": "0.9504008020733022",
      "bn": "0.978934850830488",
      "bg": "0.9854672081715824",
      "zh": "0.9763317996870259",
      "fr": "0.9906828447167965",
      "de": "0.9692315580865527",
      "ha": "0.975000380242949",
      "hi": "0.9911833932770044",
      "hu": "0.9700959975048166"
    }
  },
  {
    "task_id": "C/4",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nGjej maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrja e shembullit: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը C-ում հասկացություն չէ; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ զանգ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nতিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটার:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nTuple[int, int]: একটি টুপল C তে ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n找到三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Appel d'exemple : \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nKomawa:\nTuple[int, int]: Ba a da ma'anar tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nतीन भिन्न पूर्णांकों में से अधिकतम और न्यूनतम खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में एक ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatér:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "sq": "0.9976128600807227",
      "hy": "0.9929384913238287",
      "bn": "0.9771497595961275",
      "bg": "0.9929384913238287",
      "zh": "0.9799810370473988",
      "fr": "1",
      "de": "0.9842843642525196",
      "ha": "0.9622977687453869",
      "hi": "0.9758211209773852",
      "hu": "0.9976128600807227"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}",
    "instruction": {
      "en": "Write a C function `void find_max_min(int a, int b, int c, int *max, int *min)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sq": "Shkruani një funksion në C `void find_max_min(int a, int b, int c, int *max, int *min)` për të zgjidhur problemin e mëposhtëm:\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrje shembull:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hy": "Գրեք C ֆունկցիա `void find_max_min(int a, int b, int c, int *max, int *min)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը C-ում հասկացություն չէ; փոխարենը, մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bn": "একটি C ফাংশন `void find_max_min(int a, int b, int c, int *max, int *min)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্ন করে:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; বরং আমরা রেফারেন্সের মাধ্যমে রিটার্ন করব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bg": "Напишете C функция `void find_max_min(int a, int b, int c, int *max, int *min)`, за да решите следния проблем:\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "zh": "编写一个 C 函数 `void find_max_min(int a, int b, int c, int *max, int *min)` 来解决以下问题：\n找到三个不同整数中的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组在 C 中不是一个概念，我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "fr": "Écrire une fonction C `void find_max_min(int a, int b, int c, int *max, int *min)` pour résoudre le problème suivant :\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRetourne :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "de": "Schreiben Sie eine C-Funktion `void find_max_min(int a, int b, int c, int *max, int *min)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabe:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir per Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "ha": "Rubuta aikin C `void find_max_min(int a, int b, int c, int *max, int *min)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga lambobi guda uku masu bambanci.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a amfani da ra'ayin tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hi": "C फ़ंक्शन `void find_max_min(int a, int b, int c, int *max, int *min)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: C में ट्यूपल एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hu": "Írj egy C függvényt `void find_max_min(int a, int b, int c, int *max, int *min)` a következő probléma megoldására:\nTaláld meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia alapján térünk vissza.\n\n>>> Példa hívás:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "instruction_bertscore": {
      "sq": "0.9931132860591394",
      "hy": "0.9924897852930709",
      "bn": "0.9952962339467128",
      "bg": "0.9910699753294335",
      "zh": "0.9796844818885138",
      "fr": "0.999999801369619",
      "de": "0.9949647198407656",
      "ha": "0.9561912749412312",
      "hi": "0.9660288418227462",
      "hu": "0.9859933800509438"
    },
    "level": "middle",
    "test": "int main() {\n    int max, min;\n\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Shembull thirrje:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bn": "তিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\nপ্যারামিটারসমূহ:  \na (int): প্রথম পূর্ণসংখ্যা।  \nb (int): দ্বিতীয় পূর্ণসংখ্যা।  \nc (int): তৃতীয় পূর্ণসংখ্যা।  \n\nরিটার্নস:  \nTuple[int, int]: একটি টিউপল C তে ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।  \n\n>>> উদাহরণ কল:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:  \na (int): Първото цяло число.  \nb (int): Второто цяло число.  \nc (int): Третото цяло число.  \n\nВръща:  \nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);",
      "zh": "找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组在 C 中不是一个概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous renverrons par référence.\n\n>>> Appel d'exemple : \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\nSigogi:  \na (int): Na farko cikakken lamba.  \nb (int): Na biyu cikakken lamba.  \nc (int): Na uku cikakken lamba.  \n\nDawowa:  \nTuple[int, int]: Tuple ba wani abu bane a cikin C; maimakon haka, za mu dawo ta hanyar tunani.  \n\n>>> Misali kira:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatér:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "docstring_bertscore": {
      "sq": "0.9965237697015085",
      "hy": "0.9898650834380759",
      "bn": "0.9706074707359814",
      "bg": "0.9898650834380759",
      "zh": "0.971328697649519",
      "fr": "1",
      "de": "0.9805677911929759",
      "ha": "0.9828824310231754",
      "hi": "0.9661823831072861",
      "hu": "0.9794363925426012"
    }
  },
  {
    "task_id": "C/5",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n    \n    Վերադարձնում է:\n    double: Հեռավորությունը A և B կետերի միջև։\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটার:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n    \n    Renvoie :\n    double : La distance entre les points A et B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabe:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-da'irar maki A.\n- ya (double): y-da'irar maki A.\n- xb (double): x-da'irar maki B.\n- yb (double): y-da'irar maki B.\n    \n    Komawa:\n    double: Nisan tsakanin maki A da B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदु A और B के बीच की दूरी।\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki két pont, A (xa, ya) és B (xb, yb) közötti távolságot.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatér:\n    double: Az A és B pontok közötti távolság.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "sq": "0.9970292840212422",
      "hy": "1",
      "bn": "0.9970292840212422",
      "bg": "0.9990426015634118",
      "zh": "0.9970292840212422",
      "fr": "0.9988721766964839",
      "de": "1",
      "ha": "0.9970292840212422",
      "hi": "0.9970292840212422",
      "hu": "0.9733640631639836"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "en": "Write a C function `double calculate_distance(double xa, double ya, double xb, double yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n",
      "sq": "Shkruani një funksion në C `double calculate_distance(double xa, double ya, double xb, double yb)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hy": "Գրեք C ֆունկցիա `double calculate_distance(double xa, double ya, double xb, double yb)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք հեռավորությունը A (xa, ya) և B (xb, yb) կետերի միջև:\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n    \n    Վերադարձնում է:\n    double: A և B կետերի միջև հեռավորությունը։\n    >>> calculate_distance(0,0,3,4)\n    5",
      "bn": "একটি C ফাংশন `double calculate_distance(double xa, double ya, double xb, double yb)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-অক্ষাংশ।\n- ya (double): বিন্দু A এর y-অক্ষাংশ।\n- xb (double): বিন্দু B এর x-অক্ষাংশ।\n- yb (double): বিন্দু B এর y-অক্ষাংশ।\n    \n    রিটার্নস:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> calculate_distance(0,0,3,4)\n    5",
      "bg": "Напишете C функция `double calculate_distance(double xa, double ya, double xb, double yb)`, за да решите следния проблем:  \nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).  \n    Параметри:  \n- xa (double): x-координата на точка A.  \n- ya (double): y-координата на точка A.  \n- xb (double): x-координата на точка B.  \n- yb (double): y-координата на точка B.  \n   \n    Връща:  \n    double: Разстоянието между точките A и B.  \n    >>> calculate_distance(0,0,3,4)  \n    5  ",
      "zh": "编写一个 C 函数 `double calculate_distance(double xa, double ya, double xb, double yb)` 来解决以下问题：\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n返回：\ndouble: 点 A 和 B 之间的距离。",
      "fr": "Écrire une fonction C `double calculate_distance(double xa, double ya, double xb, double yb)` pour résoudre le problème suivant :\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n    \n    Renvoie :\n    double : La distance entre les points A et B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "de": "Schreiben Sie eine C-Funktion `double calculate_distance(double xa, double ya, double xb, double yb)`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    \n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabewert:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "ha": "Rubuta aikin C `double calculate_distance(double xa, double ya, double xb, double yb)` don warware matsalar mai zuwa:\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-ƙoordinat na maki A.\n- ya (double): y-ƙoordinat na maki A.\n- xb (double): x-ƙoordinat na maki B.\n- yb (double): y-ƙoordinat na maki B.\n    \n    Mayar da:\n    double: Nisan tsakanin maki A da B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hi": "C फ़ंक्शन `double calculate_distance(double xa, double ya, double xb, double yb)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदुओं A और B के बीच की दूरी।\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hu": "Írj egy C függvényt `double calculate_distance(double xa, double ya, double xb, double yb)` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatérési érték:\n    double: A távolság A és B pontok között.\n    >>> calculate_distance(0,0,3,4)\n    5"
    },
    "instruction_bertscore": {
      "sq": "0.9951297816874056",
      "hy": "0.9909867491997799",
      "bn": "0.9974420379530327",
      "bg": "0.9983328952119742",
      "zh": "0.9442939110083846",
      "fr": "1",
      "de": "0.9942146915219778",
      "ha": "0.9978404904973887",
      "hi": "0.9838467815230998",
      "hu": "0.9718403695110649"
    },
    "level": "easy",
    "test": "int main() {\n    assert(fabs(calculate_distance(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n    \n    Returns:\n    double: The distance between points A and B.\n    >>> calculate_distance(0,0,3,4)\n    5\n",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n    Parametra:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n    \n    Kthen:\n    double: Distanca midis pikave A dhe B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hy": "Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև:\n    Պարամետրեր:\n- xa (double): A կետի x-կոորդինատը:\n- ya (double): A կետի y-կոորդինատը:\n- xb (double): B կետի x-կոորդինատը:\n- yb (double): B կետի y-կոորդինատը:\n    \n    Վերադարձնում է:\n    double: Հեռավորությունը A և B կետերի միջև:\n    >>> calculate_distance(0,0,3,4)\n    5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n    Parameters:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n    \n    Returns:\n    double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n    >>> calculate_distance(0,0,3,4)\n    5",
      "bg": "Изчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n    Параметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n    \n    Връща:\n    double: Разстоянието между точките A и B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n    参数:\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n    \n    返回:\n    double: 点 A 和 B 之间的距离。\n    >>> calculate_distance(0,0,3,4)\n    5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n    Paramètres:\n- xa (double): coordonnée x du point A.\n- ya (double): coordonnée y du point A.\n- xb (double): coordonnée x du point B.\n- yb (double): coordonnée y du point B.\n    \n    Renvoie:\n    double: La distance entre les points A et B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n    Parameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n    \n    Rückgabewert:\n    double: Die Entfernung zwischen den Punkten A und B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "ha": "Ƙididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n    Sigogi:\n- xa (double): x-hadin gwiwar aya A.\n- ya (double): y-hadin gwiwar aya A.\n- xb (double): x-hadin gwiwar aya B.\n- yb (double): y-hadin gwiwar aya B.\n    \n    Yana dawowa:\n    double: Nisan tsakanin maki A da B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n    पैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n    \n    रिटर्न करता है:\n    double: बिंदु A और B के बीच की दूरी।\n    >>> calculate_distance(0,0,3,4)\n    5",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n    Paraméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n    \n    Visszatérési érték:\n    double: A távolság A és B pontok között.\n    >>> calculate_distance(0,0,3,4)\n    5"
    },
    "docstring_bertscore": {
      "sq": "0.9636885786733931",
      "hy": "0.968384399511439",
      "bn": "0.9968675988910798",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.99424965046904",
      "ha": "0.9968675988910798",
      "hi": "0.9968675988910798",
      "hu": "0.9607202462592077"
    }
  },
  {
    "task_id": "C/6",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n​    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n​    Returns:\n​    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjej faktorialin e N dhe merr modulo 10007 të rezultatit.\n​    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n​    Kthen:\n​    int: Rezultati pasi të merret modulo 10007 i daljes.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n​    Պարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքագրված արժեքը (N <= 10000)։\n​    Վերադարձնում է:\n​    int: Արդյունքը 10007 մոդուլից հետո։\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n​    প্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n​    রিটার্নস:\n​    int: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете факториела на N и вземете модуло 10007 от резултата.\n​    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n​    Връща:\n​    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到N的阶乘并对结果取模10007。\n​    参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n​    返回：\n​    int: 对输出取模10007后的结果。\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver la factorielle de N et prendre le modulo 10007 du résultat.\n​    Paramètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n​    Renvoie :\n​    int : Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n​    Parameter:\n- N (int): Eine Ganzzahl, die den Eingabewert darstellt (N <= 10000).\n​    Rückgabe:\n​    int: Das Ergebnis nach dem Nehmen des Modulo 10007 des Ausgabewertes.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n​    Sigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n​    Mayar da:\n​    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN का फैक्टरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n​    Paraméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n​    Visszatér:\n​    int: Az eredmény, miután az output 10007-es modulóját vettük.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9686803587791809",
      "hy": "0.9554630959643574",
      "bn": "0.9673743640238766",
      "bg": "0.9686803587791809",
      "zh": "0.963186838330899",
      "fr": "0.9834018494695816",
      "de": "0.9763222654287361",
      "ha": "0.9686803587791809",
      "hi": "0.9640812709366992",
      "hu": "0.9670140485126792"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "Write a C function `int process_request(int n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n",
      "sq": "Shkruani një funksion në C `int process_request(int n)` për të zgjidhur problemin e mëposhtëm:  \nGjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.  \n    Parametrat:  \n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).  \n    Kthen:  \n    int: Rezultati pasi të merret modulo 10007 e daljes.  \n    >>> process_request(1)  \n    1  ",
      "hy": "Գրեք C ֆունկցիա `int process_request(int n)`՝ հետևյալ խնդիրը լուծելու համար:\nԳտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլով։\n    Պարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n    Վերադարձնում է:\n    int: Արդյունքը՝ 10007 մոդուլով վերցնելուց հետո։\n    >>> process_request(1)\n    1",
      "bn": "একটি C ফাংশন `int process_request(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের 10007 এর মডুলো নেওয়ার পর ফলাফল।\n    >>> process_request(1)\n    1",
      "bg": "Напишете C функция `int process_request(int n)`, за да решите следния проблем:  \nНамерете факториела на N и вземете модуло 10007 от резултата.  \nПараметри:  \n- N (int): Цяло число, представляващо входната стойност (N <= 10000).  \nВръща:  \nint: Резултатът след вземане на модуло 10007 от изхода.  \n>>> process_request(1)  \n1  ",
      "zh": "编写一个 C 函数 `int process_request(int n)` 来解决以下问题：  \n求 N 的阶乘并对结果取模 10007。  \n参数：  \n- N (int): 表示输入值的整数 (N <= 10000)。  \n返回：  \nint: 对输出取模 10007 后的结果。  \n>>> process_request(1)  \n1  ",
      "fr": "Écrire une fonction C `int process_request(int n)` pour résoudre le problème suivant :  \nTrouver la factorielle de N et prendre le modulo 10007 du résultat.  \n    Paramètres :  \n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).  \n    Renvoie :  \n    int : Le résultat après avoir pris le modulo 10007 de la sortie.  \n    >>> process_request(1)  \n    1  ",
      "de": "Schreiben Sie eine C-Funktion `int process_request(int n)`, um das folgende Problem zu lösen:\nFinden Sie die Fakultät von N und nehmen Sie das Modulo 10007 des Ergebnisses.\n    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n    Rückgabewert:\n    int: Das Ergebnis nach dem Nehmen des Modulo 10007 des Outputs.\n    >>> process_request(1)\n    1",
      "ha": "Rubuta wani aikin C `int process_request(int n)` don magance matsalar mai zuwa:\nNemo factorial na N kuma dauki modulo 10007 na sakamakon.\n    Sigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n    Mayarwa:\n    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> process_request(1)\n    1",
      "hi": "एक C फ़ंक्शन `int process_request(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nN का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न करता है:\n    int: आउटपुट का 10007 से माड्यूलो लेने के बाद का परिणाम।\n    >>> process_request(1)\n    1",
      "hu": "Írj egy C függvényt `int process_request(int n)` a következő probléma megoldására:  \nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.  \nParaméterek:  \n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).  \nVisszatér:  \nint: Az eredmény, miután az output 10007-es modulóját vettük.  \n>>> process_request(1)  \n1  "
    },
    "instruction_bertscore": {
      "sq": "0.9859957636155162",
      "hy": "0.9654112999681087",
      "bn": "0.9719746436486445",
      "bg": "0.9880541702541807",
      "zh": "0.9777420753923736",
      "fr": "1",
      "de": "0.9912189481152096",
      "ha": "0.9880541702541807",
      "hi": "0.9719746436486445",
      "hu": "0.9674335558774249"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "en": "Find the factorial of N and take the modulo 10007 of the result.\n    Parameters:\n- N (int): An integer representing the input value (N <= 10000).\n    Returns:\n    int: The result after taking the modulo 10007 of the output.\n    >>> process_request(1)\n    1\n",
      "sq": "Gjej faktorielin e N dhe merre modulo 10007 të rezultatit.\n    Parametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n    Kthen:\n    int: Rezultati pas marrjes së modulo 10007 të daljes.\n    >>> process_request(1)\n    1",
      "hy": "Գտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n    Պարամետրեր:\n- N (int): Թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):\n    Վերադարձնում է:\n    int: Արդյունքը 10007 մոդուլով վերցնելուց հետո:\n    >>> process_request(1)\n    1",
      "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n    প্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n    রিটার্নস:\n    int: আউটপুটের মডুলো 10007 নেওয়ার পর ফলাফল।\n    >>> process_request(1)\n    1",
      "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n    Параметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n    Връща:\n    int: Резултатът след вземане на модуло 10007 от изхода.\n    >>> process_request(1)\n    1",
      "zh": "计算N的阶乘，并对结果取模10007。\n    参数:\n- N (int): 表示输入值的整数 (N <= 10000)。\n    返回:\n    int: 对输出取模10007后的结果。\n    >>> process_request(1)\n    1",
      "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n    Paramètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n    Renvoie:\n    int: Le résultat après avoir pris le modulo 10007 de la sortie.\n    >>> process_request(1)\n    1",
      "de": "Finde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n    Parameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n    Rückgabewert:\n    int: Das Ergebnis nach der Modulo-Operation mit 10007.\n    >>> process_request(1)\n    1",
      "ha": "Nemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n    Sigogi:\n- N (int): Lamba mai nuna darajar shigarwa (N <= 10000).\n    Komawa:\n    int: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n    >>> process_request(1)\n    1",
      "hi": "N का फैक्टरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n    पैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n    रिटर्न्स:\n    int: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n    >>> process_request(1)\n    1",
      "hu": "Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n    Paraméterek:\n- N (int): Egy egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n    Visszatérési érték:\n    int: Az eredmény, miután az outputot 10007-tel vettük modulo.\n    >>> process_request(1)\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9845402001832926",
      "hy": "0.9421927988377975",
      "bn": "0.991984072342956",
      "bg": "0.9845402001832926",
      "zh": "0.9626761596212583",
      "fr": "1",
      "de": "0.9466653591275601",
      "ha": "0.9829505612438704",
      "hi": "0.9829406297248187",
      "hu": "0.9707471078938489"
    }
  },
  {
    "task_id": "C/7",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n​    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել եռանկյան մակերեսը, տրված նրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчисляване на лицето на триъгълник, дадени неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculez l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n    Renvoie :\n    float : L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechnet die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige yanki na alwatika la'akari da tushenta da tsayinta.\n​    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsayin alwatika.\n​    Mayar da:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wurin goma ɗaya.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nत्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n​    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​    Visszatér:\n​    float: A kiszámított háromszög területe, egy tizedesjegyre kerekítve.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "sq": "0.9795349132115945",
      "hy": "0.9780992128174743",
      "bn": "0.9692041470939698",
      "bg": "0.97822891845629",
      "zh": "0.9795349132115945",
      "fr": "0.9795349132115945",
      "de": "0.9776596437842441",
      "ha": "0.9749771404883679",
      "hi": "0.9764726286271795",
      "hu": "0.9744722220597772"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "en": "Write a C function `float calculate_triangle_area(int base, int height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "sq": "Shkruani një funksion në C `float calculate_triangle_area(int base, int height)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hy": "Գրեք C ֆունկցիա `float calculate_triangle_area(int base, int height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը, տրված են նրա հիմքը և բարձրությունը։\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n    Վերադարձնում է:\n    float: Հաշվարկված եռանկյան մակերեսը, կլորացված մինչև մեկ տասնորդական։\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bn": "একটি C ফাংশন `float calculate_triangle_area(int base, int height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে তার ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bg": "Напишете C функция `float calculate_triangle_area(int base, int height)`, за да решите следния проблем:\nИзчислете площта на триъгълник, дадени неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n    Връща:\n    float: Изчислената площ на триъгълника, закръглена до едно десетично място.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "zh": "编写一个 C 函数 `float calculate_triangle_area(int base, int height)` 来解决以下问题：\n计算给定底和高的三角形面积。\n    参数：\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回：\n    float: 计算出的三角形面积，四舍五入到小数点后一位。",
      "fr": "Écrire une fonction C `float calculate_triangle_area(int base, int height)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné sa base et sa hauteur.  \n    Paramètres :  \n- base (int) : La longueur de la base du triangle.  \n- height (int) : La hauteur du triangle.  \n    Renvoie :  \n    float : L'aire calculée du triangle, arrondie à une décimale.  \n    >>> calculate_triangle_area(1,2)  \n    1.0  ",
      "de": "Schreiben Sie eine C-Funktion `float calculate_triangle_area(int base, int height)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewert:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "ha": "Rubuta aikin C `float calculate_triangle_area(int base, int height)` don magance matsalar mai zuwa:  \nƘididdige yanki na alwatika da aka ba da tushenta da tsayinta.  \n    Sigogi:  \n- base (int): Tsawon tushe na alwatika.  \n- height (int): Tsayin alwatika.  \n    Mayarwa:  \n    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.  \n    >>> calculate_triangle_area(1,2)  \n    1.0  ",
      "hi": "C फ़ंक्शन `float calculate_triangle_area(int base, int height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nत्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया हुआ।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hu": "Írj egy C függvényt `float calculate_triangle_area(int base, int height)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatérési érték:\n    float: A kiszámított háromszög területe, egy tizedesjegyre kerekítve.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "instruction_bertscore": {
      "sq": "0.9863447571949946",
      "hy": "0.9915234484893362",
      "bn": "0.9833440480287005",
      "bg": "0.9887203765521718",
      "zh": "0.9523757839519321",
      "fr": "0.9912032563151079",
      "de": "0.9874676147389848",
      "ha": "0.9912032563151079",
      "hi": "0.9678522687206464",
      "hu": "0.977567677917825"
    },
    "level": "easy",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n    Returns:\n    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա հիմքը և բարձրությունը։\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে এর ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bg": "Изчисляване на лицето на триъгълник, дадени са основата и височината му.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n    Връща:\n    float: Изчисленото лице на триъгълника, закръглено до първия знак след десетичната запетая.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "de": "Berechnen Sie die Fläche eines Dreiecks anhand seiner Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewerte:\n    float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "ha": "Ƙididdige yanki na alwatika la'akari da tushenta da tsayinta.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsawo na alwatika.\n    Returns:\n    float: An lissafa yankin alwatika, an zagaye zuwa wuri daya na goma.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hi": "त्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hu": "Számítsa ki a háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9881099853912516",
      "hy": "0.9864204353701689",
      "bn": "0.9881099853912516",
      "bg": "0.9736149333352306",
      "zh": "0.9881099853912516",
      "fr": "0.9881099853912516",
      "de": "0.9886514518099527",
      "ha": "0.9770095265471168",
      "hi": "0.9652428614049912",
      "hu": "0.9738910295648692"
    }
  },
  {
    "task_id": "C/8",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացմամբ։\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ այն բիթերի քանակը, որոնք պետք է փոխել\n​         x-ը y-ի վերածելու համար երկբայականում։\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n​    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n​    রিটার্ন:\n​    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се трансформира x в y в двоична форма.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算两个整数在二进制表示下的汉明距离。\n​    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n​    返回:\n​    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制的 y。\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n         pour transformer x en y en binaire.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n​    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n​    Rückgabe:\n​    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgeklappt werden müssen,\n​         um x in y in binärer Form zu transformieren.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Komawa:\n​    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa\n​         don sauya x zuwa y a cikin binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदो पूर्णांकों के द्विआधारी प्रतिनिधित्व के बीच हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात् उन बिट्स की संख्या जिन्हें x को y में बदलने के लिए फ्लिप करना आवश्यक है\n         द्विआधारी में।\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n​    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n​    Visszatér:\n​    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n​         ahhoz, hogy x-et y-ra alakítsuk binárisan.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "sq": "0.9680050154836622",
      "hy": "0.9721017670925068",
      "bn": "0.9594416624964862",
      "bg": "0.9729602475993396",
      "zh": "0.9727902199931737",
      "fr": "0.9749564829287403",
      "de": "0.9726541581821648",
      "ha": "0.9660594309014255",
      "hi": "0.9620689465464346",
      "hu": "0.9668982470005358"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "en": "Write a C function `int hamming_distance(int x, int y)` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "sq": "Shkruani një funksion në C `int hamming_distance(int x, int y)` për të zgjidhur problemin në vijim:\nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> hamming_distance(1,2)\n    2",
      "hy": "Գրեք C ֆունկցիա `int hamming_distance(int x, int y)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացման մեջ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն՝ x-ը y-ի վերածելու համար երկբայն։\n    >>> hamming_distance(1,2)\n    2",
      "bn": "একটি C ফাংশন `int hamming_distance(int x, int y)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> hamming_distance(1,2)\n    2",
      "bg": "Напишете C функция `int hamming_distance(int x, int y)` за решаване на следния проблем:\nИзчислете разстоянието на Хаминг между две цели числа в двоично представяне.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се трансформира x в y в двоичен вид.\n    >>> hamming_distance(1,2)\n    2",
      "zh": "编写一个 C 函数 `int hamming_distance(int x, int y)` 来解决以下问题：  \n计算两个整数在二进制表示中的汉明距离。  \n参数：  \n- x (int): 第一个正整数 (x <= 1,000,000,000)。  \n- y (int): 第二个正整数 (y <= 1,000,000,000)。  \n返回：  \nint: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。  \n>>> hamming_distance(1,2)  \n2  ",
      "fr": "Écrivez une fonction C `int hamming_distance(int x, int y)` pour résoudre le problème suivant :\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie :\n    int : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> hamming_distance(1,2)\n    2",
      "de": "Schreiben Sie eine C-Funktion `int hamming_distance(int x, int y)`, um das folgende Problem zu lösen:\nBerechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n    Rückgabewert:\n    int: Der Hamming-Abstand zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binärer Form zu transformieren.\n    >>> hamming_distance(1,2)\n    2",
      "ha": "Rubuta aikin C `int hamming_distance(int x, int y)` don warware matsalar mai zuwa:  \nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.  \n   Sigogi:  \n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).  \n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).  \n   Dawowa:  \n   int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.  \n    >>> hamming_distance(1,2)  \n    2  ",
      "hi": "C फ़ंक्शन `int hamming_distance(int x, int y)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के द्विआधारी अभ्यावेदन में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को y में परिवर्तित करने के लिए द्विआधारी में जितने बिट्स को फ्लिप करने की आवश्यकता होती है।\n    >>> hamming_distance(1,2)\n    2",
      "hu": "Írj egy C függvényt `int hamming_distance(int x, int y)` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-ből y-t kapjunk binárisan.\n    >>> hamming_distance(1,2)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9823429509082846",
      "hy": "0.9900245836340469",
      "bn": "0.9709944027182373",
      "bg": "0.9967879481082849",
      "zh": "0.9931067312565652",
      "fr": "0.9960335499211144",
      "de": "0.9908522764318193",
      "ha": "0.9846937414678325",
      "hi": "0.9674782477131577",
      "hu": "0.9769825128152961"
    },
    "level": "middle",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> hamming_distance(1,2)\n    2",
      "hy": "Հաշվարկել Հեմմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացմամբ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխել՝ x-ը y-ի վերածելու համար երկբայականում։\n    >>> hamming_distance(1,2)\n    2",
      "bn": "দুটি পূর্ণসংখ্যার মধ্যে বাইনারি উপস্থাপনায় হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> hamming_distance(1,2)\n    2",
      "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат променени, за да се преобразува x в y в двоична форма.\n    >>> hamming_distance(1,2)\n    2",
      "zh": "计算两个整数在二进制表示下的汉明距离。\n    参数：\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回：\n    int: x 和 y 之间的汉明距离，即将 x 转换为 y 所需翻转的位数。\n    >>> hamming_distance(1,2)\n    2",
      "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> hamming_distance(1,2)\n    2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binär zu transformieren.\n    >>> hamming_distance(1,2)\n    2",
      "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Parameters:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Returns:\n    int: Hamming distance tsakanin x da y, wato, yawan bits da ake buƙatar juyawa don canza x zuwa y a binary.\n    >>> hamming_distance(1,2)\n    2",
      "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जिन बिट्स को उलटना आवश्यक है उनकी संख्या।\n    >>> hamming_distance(1,2)\n    2",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám között a bináris ábrázolásban.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz azoknak a biteknek a száma, amelyeket meg kell változtatni ahhoz, hogy x-ből y-t alakítsunk binárisan.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9839339802603742",
      "hy": "0.9846911592728791",
      "bn": "0.9782269321524797",
      "bg": "0.977533910753049",
      "zh": "0.9879560468459495",
      "fr": "0.9946975619782736",
      "de": "0.9941390133468035",
      "ha": "0.9680286524990054",
      "hi": "0.9859649759064558",
      "hu": "0.9834479317179817"
    }
  },
  {
    "task_id": "C/9",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë numrash të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën hyrëse.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nՀաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը։\n- ... (int): Ամբողջ թվերի հաջորդականություն։\n    Վերադարձնում է:\n    int: Մուտքային ցուցակում գտնվող կենտ թվերի քանակը։\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nএকটি প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    Parameters:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    Returns:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nБройте броя на нечетните числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в списъка с входни данни.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/*\n计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 一系列整数。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de nombres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Renvoie:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "de": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nZählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabe:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nƘirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su da ma'aurata a cikin jerin shigarwa.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों की एक अनुक्रम।\n    रिटर्न करता है:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nSzámolja meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatér:\n    int: A páratlan számok száma a bemeneti listában.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9807970106526901",
      "hy": "0.9888437260187944",
      "bn": "0.9926780868942919",
      "bg": "0.9855021671186446",
      "zh": "0.9782549390362056",
      "fr": "0.9926780868942919",
      "de": "0.9836682128105494",
      "ha": "0.9721263972597551",
      "hi": "0.995963830657371",
      "hu": "0.9894495486809509"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `int count_odd_numbers(int count, ...)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n",
      "sq": "Shkruani një funksion C `int count_odd_numbers(int count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë e numrave të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e hyrjes.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hy": "Գրեք C ֆունկցիա `int count_odd_numbers(int count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցանկում կենտ թվերի քանակը:\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "bn": "একটি C ফাংশন `int count_odd_numbers(int count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    প্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    রিটার্নস:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "bg": "Напишете C функция `int count_odd_numbers(int count, ...)`, за да решите следния проблем:  \nБройте броя на нечетните цели числа в даден списък от числа.  \n    Параметри:  \n- count (int): Броят на числата за оценка.  \n- ... (int): Последователност от цели числа.  \n    Връща:  \n    int: Броят на нечетните числа в списъка с входни данни.  \n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)  \n    3  ",
      "zh": "编写一个 C 函数 `int count_odd_numbers(int count, ...)` 来解决以下问题：\n计算给定数字列表中奇数的数量。\n    参数：\n- count (int): 需要评估的数字数量。\n- ... (int): 一系列整数。\n    返回：\n    int: 输入列表中奇数的数量。\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "fr": "Écrire une fonction C `int count_odd_numbers(int count, ...)` pour résoudre le problème suivant :\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres :\n- count (int) : Le nombre de nombres à évaluer.\n- ... (int) : Une séquence d'entiers.\n    Renvoie :\n    int : Le nombre de nombres impairs dans la liste d'entrée.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "de": "Schreiben Sie eine C-Funktion `int count_odd_numbers(int count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von ganzen Zahlen.\n    Rückgabewert:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "ha": "Rubuta wani aikin C `int count_odd_numbers(int count, ...)` don warware matsalar mai zuwa:\nƘididdige yawan lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Yawan lambobin da za a tantance.\n- ... (int): Jeri na lambobi.\n    Mayar da:\n    int: Yawan lambobin da ba su daidai ba a cikin jerin shigarwa.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hi": "एक C फ़ंक्शन `int count_odd_numbers(int count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- ... (int): पूर्णांकों का अनुक्रम।\n    रिटर्न करता है:\n    int: इनपुट सूची में विषम संख्याओं की गिनती।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hu": "Írj egy C függvényt `int count_odd_numbers(int count, ...)` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatérési érték:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9849908925178608",
      "hy": "0.9853877560191685",
      "bn": "0.9893097128927023",
      "bg": "0.991915147600737",
      "zh": "0.9774923970034127",
      "fr": "0.991915147600737",
      "de": "0.9809892848615319",
      "ha": "0.9751888804745511",
      "hi": "0.9927877308646232",
      "hu": "0.973617515530184"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\n    Parameters:\n- count (int): The count of numbers to evaluate.\n- ... (int): A sequence of integers.\n    Returns:\n    int: The count of odd numbers in the input list.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n    Parametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- ... (int): Një sekuencë e numrave të plotë.\n    Kthen:\n    int: Numri i numrave tek në listën e dhënë.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hy": "Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը:\n    Պարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\n    Վերադարձնում է:\n    int: Մուտքային ցանկում կենտ թվերի քանակը:\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n    প্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\n    রিটার্নস:\n    int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n    Параметри:\n- count (int): Броят на числата за оценка.\n- ... (int): Последователност от цели числа.\n    Връща:\n    int: Броят на нечетните числа в списъка на входа.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "zh": "计算给定数字列表中奇数的数量。\n    参数:\n- count (int): 要评估的数字数量。\n- ... (int): 整数序列。\n    返回:\n    int: 输入列表中奇数的数量。\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n    Paramètres:\n- count (int): Le nombre de chiffres à évaluer.\n- ... (int): Une séquence d'entiers.\n    Retourne:\n    int: Le nombre de nombres impairs dans la liste d'entrée.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n    Parameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\n    Rückgabewert:\n    int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "ha": "Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n    Sigogi:\n- count (int): Adadin lambobin da za a tantance.\n- ... (int): Jerin lambobi.\n    Komawa:\n    int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hi": "दिए गए नंबरों की सूची में विषम पूर्णांकों की संख्या गिनें।\n    पैरामीटर्स:\n- count (int): मूल्यांकन के लिए संख्याओं की गणना।\n- ... (int): पूर्णांकों का अनुक्रम।\n    रिटर्न:\n    int: इनपुट सूची में विषम संख्याओं की गणना।\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n    Paraméterek:\n- count (int): Az értékelendő számok száma.\n- ... (int): Egész számok sorozata.\n    Visszatér:\n    int: A bemeneti listában található páratlan számok száma.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.969995490532013",
      "hy": "0.966756424908477",
      "bn": "0.985607242590212",
      "bg": "0.9893273909966144",
      "zh": "0.9717597255763648",
      "fr": "0.9834596509104628",
      "de": "0.9759730732188768",
      "ha": "0.9630436258261729",
      "hi": "0.9750331542558197",
      "hu": "0.9711910467954619"
    }
  },
  {
    "task_id": "C/10",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nLlogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë e numrave të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën e hyrjes.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Deklarim i rregulluar",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվել զույգ թվերի գումարը տրված ցուցակում։\n    Պարամետրեր:\n- numbers (list): ամբողջ թվերի ցուցակ։\n- size (int): ցուցակի չափը։\n    Վերադարձնում է:\n    int: մուտքային ցուցակում զույգ թվերի գումարը։\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকার জোড় সংখ্যাগুলির যোগফল।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nИзчисляване на сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算给定列表中偶数的和。\n    参数:\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回:\n    int: 输入列表中偶数的和。\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCalculer la somme des nombres pairs dans une liste donnée.\n    Paramètres :\n- numbers (list) : Une liste d'entiers.\n- size (int) : La taille de la liste.\n    Renvoie :\n    int : La somme des nombres pairs dans la liste d'entrée.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBerechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabe:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Feste Deklaration",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nƘididdige jimillar lambobin da suke ma'aurata a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobi masu cikakken lamba.\n- size (int): Girman jerin.\n    Komawa:\n    int: Jimillar lambobin da suke ma'aurata a cikin jerin shigarwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न करता है:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nSzámítsa ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatér:\n    int: A bemeneti listában lévő páros számok összege.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Rögzített deklaráció"
    },
    "prompt_bertscore": {
      "sq": "0.9955417410976719",
      "hy": "0.9796477352680223",
      "bn": "1",
      "bg": "0.9871128608784564",
      "zh": "0.9823463276247623",
      "fr": "1",
      "de": "0.9931317586845756",
      "ha": "0.9688138383952364",
      "hi": "0.9959940224752883",
      "hu": "0.9956408576578083"
    },
    "canonical_solution": "int calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `int calculate_even_sum(int *numbers, int size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n",
      "sq": "Shkruani një funksion në C `int calculate_even_sum(int *numbers, int size)` për të zgjidhur problemin në vijim:\nLlogaritni shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë me numra të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën e dhënë si hyrje.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hy": "Գրեք C ֆունկցիա `int calculate_even_sum(int *numbers, int size)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք զույգ թվերի գումարը տրված ցուցակում:\n    Պարամետրեր:\n- numbers (ցուցակ): ամբողջ թվերի ցուցակ:\n- size (int): ցուցակի չափը:\n    Վերադարձնում է:\n    int: զույգ թվերի գումարը մուտքային ցուցակում:\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "bn": "একটি C ফাংশন `int calculate_even_sum(int *numbers, int size)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত তালিকায় জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n- size (int): তালিকার আকার।\n    রিটার্নস:\n    int: ইনপুট তালিকায় জোড় সংখ্যাগুলোর যোগফল।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "bg": "Напишете C функция `int calculate_even_sum(int *numbers, int size)`, за да решите следния проблем:\nИзчислете сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "zh": "编写一个 C 函数 `int calculate_even_sum(int *numbers, int size)` 来解决以下问题：\n计算给定列表中偶数的和。\n    参数：\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回：\n    int: 输入列表中偶数的和。\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "fr": "Écrire une fonction C `int calculate_even_sum(int *numbers, int size)` pour résoudre le problème suivant :\nCalculer la somme des nombres pairs dans une liste donnée.\n    Paramètres :\n- numbers (list) : Une liste d'entiers.\n- size (int) : La taille de la liste.\n    Renvoie :\n    int : La somme des nombres pairs dans la liste d'entrée.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "de": "Schreiben Sie eine C-Funktion `int calculate_even_sum(int *numbers, int size)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabewert:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "ha": "Rubuta wani aikin C `int calculate_even_sum(int *numbers, int size)` don warware matsalar mai zuwa:\nƘididdige jimillar lambobi masu lamba biyu a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobi masu lamba.\n- size (int): Girman jerin.\n    Mayar da:\n    int: Jimillar lambobi masu lamba biyu a cikin jerin shigarwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hi": "C फ़ंक्शन `int calculate_even_sum(int *numbers, int size)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न्स:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hu": "Írj egy C függvényt `int calculate_even_sum(int *numbers, int size)` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatérési érték:\n    int: A bemeneti listában található páros számok összege.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6"
    },
    "instruction_bertscore": {
      "sq": "0.9899584397171622",
      "hy": "0.9589067508803593",
      "bn": "0.9961084335747644",
      "bg": "0.9934888961096764",
      "zh": "0.9832435410558968",
      "fr": "1",
      "de": "0.9872818953327172",
      "ha": "0.9728263707225221",
      "hi": "0.9796183379716291",
      "hu": "0.9867779700560316"
    },
    "level": "easy",
    "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6);\n    assert(calculate_even_sum(sample2, 4) == 4);\n    assert(calculate_even_sum(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(int *numbers, int size)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\n    Parameters:\n- numbers (list): A list of integers.\n- size (int): The size of the list.\n    Returns:\n    int: The sum of even numbers in the input list.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n",
      "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\n    Parametrat:\n- numbers (listë): Një listë me numra të plotë.\n- size (int): Madhësia e listës.\n    Kthen:\n    int: Shuma e numrave çift në listën hyrëse.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hy": "Հաշվել տրված ցուցակի զույգ թվերի գումարը։\n    Պարամետրեր:\n- numbers (list): Թվերի ցուցակ։\n- size (int): Ցուցակի չափը։\n    Վերադարձնում է:\n    int: Մուտքային ցուցակի զույգ թվերի գումարը։\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "bn": "সমস্যার বিবরণ: প্রদত্ত তালিকায় সম সংখ্যাগুলির যোগফল গণনা করুন।\n\n    Args:\n    - numbers (list): পূর্ণসংখ্যার একটি তালিকা।\n    - size (int): তালিকার আকার।\n\n    Returns:\n    int: ইনপুট তালিকায় সম সংখ্যাগুলির যোগফল।\n\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "bg": "Изчислява сумата на четните числа в даден списък.\n    Параметри:\n- numbers (list): Списък от цели числа.\n- size (int): Размерът на списъка.\n    Връща:\n    int: Сумата на четните числа в входния списък.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "zh": "计算给定列表中偶数的和。\n    参数:\n- numbers (list): 整数列表。\n- size (int): 列表的大小。\n    返回:\n    int: 输入列表中偶数的和。\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "fr": "Calculer la somme des nombres pairs dans une liste donnée.\n    Paramètres:\n- numbers (list): Une liste d'entiers.\n- size (int): La taille de la liste.\n    Renvoie:\n    int: La somme des nombres pairs dans la liste d'entrée.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "de": "Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n    Parameter:\n- numbers (list): Eine Liste von ganzen Zahlen.\n- size (int): Die Größe der Liste.\n    Rückgabewert:\n    int: Die Summe der geraden Zahlen in der Eingabeliste.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "ha": "Ƙididdige jimillar lambobin da suka dace a cikin jerin da aka bayar.\n    Sigogi:\n- numbers (list): Jerin lambobin cikakke.\n- size (int): Girman jerin.\n    Mayarwa:\n    int: Jimillar lambobin da suka dace a cikin jerin shigarwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hi": "दिए गए सूची में सम संख्या का योग गणना करें।\n    पैरामीटर्स:\n- numbers (list): पूर्णांकों की एक सूची।\n- size (int): सूची का आकार।\n    रिटर्न्स:\n    int: इनपुट सूची में सम संख्याओं का योग।\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "hu": "Számítsa ki a páros számok összegét egy adott listában.\n    Paraméterek:\n- numbers (list): Egész számok listája.\n- size (int): A lista mérete.\n    Visszatér:\n    int: A bemeneti listában található páros számok összege.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9651999572426876",
      "bn": "0.9528634215373728",
      "bg": "0.9936197935307783",
      "zh": "0.9794056048335408",
      "fr": "1",
      "de": "0.9805781199727897",
      "ha": "0.9741186599815351",
      "hi": "0.9944018013409127",
      "hu": "0.9896801585533324"
    }
  },
  {
    "task_id": "C/11",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nDetermine if two closed intervals intersect.\n​    Args:\n​    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n​    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 if the intervals intersect, 0 otherwise.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n​    Argumentet:\n​    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n​    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n​    Kthen:\n​    int: 1 nëse intervalet ndërpriten, 0 përndryshe.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈրոշել՝ արդյոք երկու փակ միջակայքեր հատվում են:\n​    Արգումենտներ:\n​    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n​    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n​    Վերադարձնում է:\n​    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nনির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n​    আর্গুমেন্ট:\n​    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n​    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n​    রিটার্ন:\n​    int: 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nОпределете дали два затворени интервала се пресичат.\n​    Аргументи:\n​    a, b: Представляват първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n​    c, d: Представляват втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n​    Връща:\n​    int: 1 ако интервалите се пресичат, 0 в противен случай.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n确定两个闭区间是否相交。\n​    参数:\n​    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n​    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n​    返回:\n​    int: 如果区间相交返回 1，否则返回 0。\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nDéterminer si deux intervalles fermés se croisent.\n​    Args:\n​    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n​    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n​    Retourne:\n​    int: 1 si les intervalles se croisent, 0 sinon.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nBestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n​    Argumente:\n​    a, b: Repräsentieren das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n​    c, d: Repräsentieren das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n​    Rückgabewert:\n​    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nKayyade idan tsaka-tsakin rufe guda biyu suna haduwa.\n​    Args:\n​    a, b: Wakiltar tsaka-tsakin rufe na farko [a, b] inda 0 <= a <= b <= 1000.\n​    c, d: Wakiltar tsaka-tsakin rufe na biyu [c, d] inda 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 idan tsaka-tsakin suna haduwa, 0 in ba haka ba.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nनिर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n​    तर्क:\n​    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n​    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n​    वापसी:\n​    int: 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\n​    Args:\n​    a, b: Az első zárt intervallumot [a, b] képviseli, ahol 0 <= a <= b <= 1000.\n​    c, d: A második zárt intervallumot [c, d] képviseli, ahol 0 <= c <= d <= 1000.\n​    Visszatérési érték:\n​    int: 1, ha az intervallumok metszik egymást, különben 0.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9556188221830887",
      "hy": "0.9501835004364501",
      "bn": "0.9595306489071899",
      "bg": "0.9513913717835232",
      "zh": "0.9358121951078138",
      "fr": "0.999999801369619",
      "de": "0.9422702646864012",
      "ha": "0.9894155828857939",
      "hi": "0.9483572927132152",
      "hu": "0.976833937290282"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "Write a C function `int are_intervals_intersecting(int a, int b, int c, int d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Shkruani një funksion në C `int are_intervals_intersecting(int a, int b, int c, int d)` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni nëse dy intervale të mbyllura ndërpriten.  \n    Argumentet:  \n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.  \n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.  \n    Kthen:  \n    int: 1 nëse intervalet ndërpriten, 0 përndryshe.  ",
      "hy": "Գրեք C ֆունկցիա `int are_intervals_intersecting(int a, int b, int c, int d)՝ հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n    Արգումենտներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n    Վերադարձնում է:\n    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում.",
      "bn": "C ফাংশন `int are_intervals_intersecting(int a, int b, int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা নির্ধারণ করুন।\n    Args:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n    Returns:\n    int: যদি ইন্টারভালগুলি অতিক্রম করে তবে 1, অন্যথায় 0।",
      "bg": "Напишете C функция `int are_intervals_intersecting(int a, int b, int c, int d)` за решаване на следния проблем:\nОпределете дали два затворени интервала се пресичат.\n    Args:\n    a, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ако интервалите се пресичат, 0 в противен случай.",
      "zh": "编写一个 C 函数 `int are_intervals_intersecting(int a, int b, int c, int d)` 来解决以下问题：\n确定两个闭区间是否相交。\n    参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回:\n    int: 如果区间相交返回 1，否则返回 0。",
      "fr": "Écrire une fonction C `int are_intervals_intersecting(int a, int b, int c, int d)` pour résoudre le problème suivant :\nDéterminer si deux intervalles fermés s'intersectent.\n    Args:\n    a, b : Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d : Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n    Returns:\n    int : 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Schreiben Sie eine C-Funktion `int are_intervals_intersecting(int a, int b, int c, int d)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob zwei abgeschlossene Intervalle sich überschneiden.\n    Args:\n    a, b: Repräsentieren das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentieren das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Rubuta wani aikin C `int are_intervals_intersecting(int a, int b, int c, int d)` don warware matsalar mai zuwa:\nGano idan wasu tazara biyu masu rufewa suna haduwa.\n    Args:\n    a, b: Wakiltar tazara ta farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar tazara ta biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 idan tazarorin suna haduwa, 0 in ba haka ba.",
      "hi": "C फ़ंक्शन `int are_intervals_intersecting(int a, int b, int c, int d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि दो बंद अंतराल परस्पर संबंधित हैं या नहीं।\n    तर्क:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n    वापसी:\n    int: 1 यदि अंतराल परस्पर संबंधित हैं, अन्यथा 0।",
      "hu": "Írj egy C függvényt `int are_intervals_intersecting(int a, int b, int c, int d)` a következő probléma megoldására:\nHatározd meg, hogy két zárt intervallum metszi-e egymást.\n    Args:\n    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, ha az intervallumok metszik egymást, 0 különben."
    },
    "instruction_bertscore": {
      "sq": "0.9797107010988103",
      "hy": "0.9750027638075214",
      "bn": "0.9816836966736299",
      "bg": "0.9943797533686178",
      "zh": "0.9548773349706855",
      "fr": "1",
      "de": "0.9828069514783822",
      "ha": "0.9903888717528648",
      "hi": "0.9519777286683382",
      "hu": "0.9844863713500321"
    },
    "level": "easy",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n    Argumentet:\n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n    Kthen:\n    int: 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Սահմանել, արդյոք երկու փակ միջակայքերը հատվում են:\n    Արձանագրումներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n    Վերադարձնում է:\n    int: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:",
      "bn": "নির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n    আর্গুমেন্ট:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n    Returns:\n    int: 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।",
      "bg": "Определете дали два затворени интервала се пресичат.\n    Аргументи:\n    a, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n    Връща:\n    int: 1 ако интервалите се пресичат, 0 в противен случай.",
      "zh": "确定两个闭区间是否相交。\n    参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n    返回:\n    int: 如果区间相交则返回 1，否则返回 0。",
      "fr": "Déterminer si deux intervalles fermés s'intersectent.\n    Args:\n    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n    Args:\n    a, b: Repräsentiert das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentiert das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Kayyade idan tsaka-tsakin rufe guda biyu suna haduwa.\n    Args:\n    a, b: Wakiltar farkon rufaffen tazara [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar na biyu rufaffen tazara [c, d] inda 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 idan tazarar sun haɗu, 0 in ba haka ba.",
      "hi": "दो बंद अंतरालों के प्रतिच्छेदन का निर्धारण करें।\n    Args:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n    Returns:\n    int: 1 यदि अंतराल प्रतिच्छेदित होते हैं, अन्यथा 0।",
      "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\n    Args:\n    a, b: Az első zárt intervallumot [a, b] jelöli, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] jelöli, ahol 0 <= c <= d <= 1000.\n    Returns:\n    int: 1, ha az intervallumok metszik egymást, 0 különben."
    },
    "docstring_bertscore": {
      "sq": "0.9720678012973499",
      "hy": "0.9581352704804197",
      "bn": "0.976458128609364",
      "bg": "0.9606558900157525",
      "zh": "0.9414677979470202",
      "fr": "1",
      "de": "0.9720968013329809",
      "ha": "0.9874467585489761",
      "hi": "0.9744382562646202",
      "hu": "0.9701971003687633"
    }
  },
  {
    "task_id": "C/12",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nՁեզ տրվում են երեք թվանշան a, b, c։ Դրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতোমাকে তিনটি অঙ্ক দেওয়া হয়েছে a, b, c। এর মধ্যে দুটি সমান, কিন্তু তৃতীয়টি অন্য দুইটির থেকে ভিন্ন। যে মানটি ঠিক একবার ঘটে তা খুঁজে বের করো।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nAn ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku ya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nHárom számjegyet kap, a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Keresse meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "sq": "0.9905910774807584",
      "hy": "0.9945519659089751",
      "bn": "0.9858581127614591",
      "bg": "0.9960977075341886",
      "zh": "0.9748498184141245",
      "fr": "0.9877607931813922",
      "de": "0.9858781744299436",
      "ha": "0.9761699159264824",
      "hi": "0.9733851179843732",
      "hu": "0.9860561472513508"
    },
    "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}",
    "instruction": {
      "en": "Write a C function `int extraNumber(int a, int b, int c)` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n",
      "sq": "Shkruani një funksion në C `int extraNumber(int a, int b, int c)` për të zgjidhur problemin e mëposhtëm:\nJu jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hy": "Գրեք C ֆունկցիա `int extraNumber(int a, int b, int c)`՝ հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված են երեք թվանշան a, b, c։ Դրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ:\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "bn": "একটি C ফাংশন `int extraNumber(int a, int b, int c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে তিনটি সংখ্যা a, b, c দেওয়া হয়েছে। এর মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে ভিন্ন। সেই মানটি খুঁজে বের করুন যা ঠিক একবার ঘটে।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "bg": "Напишете C функция `int extraNumber(int a, int b, int c)`, за да решите следния проблем:  \nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.  \n    >>> extraNumber(0,0,1)  \n    1  \n    >>> extraNumber(4,3,4)  \n    3  ",
      "zh": "编写一个 C 函数 `int extraNumber(int a, int b, int c)` 来解决以下问题：\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。",
      "fr": "Écrire une fonction C `int extraNumber(int a, int b, int c)` pour résoudre le problème suivant :  \nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.  \n    >>> extraNumber(0,0,1)  \n    1  \n    >>> extraNumber(4,3,4)  \n    3  ",
      "de": "Schreiben Sie eine C-Funktion `int extraNumber(int a, int b, int c)`, um das folgende Problem zu lösen:\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "ha": "Rubuta wani aikin C `int extraNumber(int a, int b, int c)` don warware matsalar mai zuwa:\nAn ba ku lambobi guda uku a, b, c. Biyu daga cikinsu suna daidai, amma na ukun ya bambanta da sauran biyun. Nemo darajar da ta bayyana sau daya kawai.",
      "hi": "C फ़ंक्शन `int extraNumber(int a, int b, int c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको तीन अंक a, b, c दिए गए हैं। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।",
      "hu": "Írj egy C függvényt `int extraNumber(int a, int b, int c)` a következő probléma megoldására:\nHárom számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik eltér a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9051500204482202",
      "hy": "0.986034297909437",
      "bn": "0.9768889579058286",
      "bg": "0.9925557305795745",
      "zh": "0.8890160691182803",
      "fr": "0.9856829207653863",
      "de": "0.9060508092262134",
      "ha": "0.8931964441175406",
      "hi": "0.8758717036532966",
      "hu": "0.9789785495143157"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "en": "You are given three digits a, b, c. Two of them are equal, but the third one is different from the other two. Find the value that occurs exactly once.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n",
      "sq": "Ju janë dhënë tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hy": "Ձեզ տրված են երեք թվանշան՝ a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "bn": "তোমাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুইটির থেকে ভিন্ন। যে মানটি ঠিক একবার ঘটে সেটি খুঁজে বের করো।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "bg": "Дадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "zh": "你有三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "fr": "Vous avez trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "de": "Du hast drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte unterscheidet sich von den anderen beiden. Finde den Wert, der genau einmal vorkommt.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "ha": "An ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku ya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hi": "आपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "hu": "Három számjegyet kap, a, b, c. Kettő közülük egyenlő, de a harmadik eltér a másik kettőtől. Találja meg azt az értéket, amely pontosan egyszer fordul elő.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9793992486613476",
      "hy": "0.9692202361548338",
      "bn": "0.9639666612068419",
      "bg": "0.9598041629418749",
      "zh": "0.9597054436425005",
      "fr": "0.9623063098517713",
      "de": "0.9681130704109453",
      "ha": "0.9603607252695346",
      "hi": "0.9488882317217215",
      "hu": "0.9747473251375105"
    }
  },
  {
    "task_id": "C/13",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLlogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n    Kthen:\n    int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաների միավորների հիման վրա:\n    Պարամետրեր:\n- subject_scores (ցանկ): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nবিভিন্ন বিষয়ে প্রাপ্ত স্কোরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n    প্যারামিটার:\n- subject_scores (list): প্রতিটি বিষয়ে প্রাপ্ত স্কোরের একটি তালিকা।\n    রিটার্নস:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзчислете общия резултат за ученик на базата на резултатите в различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算学生在不同科目中的总分。\n    参数：\n- subject_scores (list): 包含每个科目分数的列表。\n    返回：\n    int: 通过将所有科目的分数相加获得的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcule le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBerechne die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (Liste): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabe:\n    int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki na kowane fanni.\n    Abin da ya dawo:\n    int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nविभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n    पैरामीटर्स:\n- subject_scores (सूची): प्रत्येक विषय के लिए अंक वाली एक सूची।\n    रिटर्न करता है:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatérési érték:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "sq": "0.9933059575287433",
      "hy": "0.9840138296735501",
      "bn": "0.9772899926451382",
      "bg": "0.991568140325069",
      "zh": "0.9698034149535522",
      "fr": "0.9836104113696683",
      "de": "0.9955246588849029",
      "ha": "0.9933059575287433",
      "hi": "0.9677279261021187",
      "hu": "0.9804823801291308"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "Write a C function `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n",
      "sq": "Shkruani një funksion në C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n    Kthen:\n    int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hy": "Գրեք C ֆունկցիա `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ուսանողի ընդհանուր միավորը տարբեր առարկաների գնահատականների հիման վրա։\n    Պարամետրեր:\n- subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի գնահատականները։\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների գնահատականների գումարով։\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "bn": "একটি C ফাংশন `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n    প্যারামিটারসমূহ:\n- subject_scores (list): প্রতিটি বিষয়ের স্কোর ধারণকারী একটি তালিকা।\n    রিটার্নস:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "bg": "Напишете C функция `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` за решаване на следния проблем:\nИзчислете общия резултат за ученик въз основа на резултатите в различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез събиране на резултатите от всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "zh": "编写一个 C 函数 `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` 来解决以下问题：\n计算学生在不同科目中的总分。\n    参数：\n- subject_scores (list): 包含每个科目分数的列表。\n    返回：\n    int: 通过将所有科目的分数相加得到的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "fr": "Écrire une fonction C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` pour résoudre le problème suivant :\nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres :\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie :\n    int : Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "de": "Schreiben Sie eine C-Funktion `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgabe:\n    int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "ha": "Rubuta aikin C `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` don warware matsalar mai zuwa:\nƘididdige jimlar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki na kowanne fanni.\n    Yana dawowa:\n    int: Jimlar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hi": "C फ़ंक्शन `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में अंकों के आधार पर छात्र के कुल अंक की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंक वाली सूची।\n    रिटर्न करता है:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hu": "Írj egy C függvényt `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatér:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámainak összegzésével kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"
    },
    "instruction_bertscore": {
      "sq": "0.9882019512576707",
      "hy": "0.9782674527502108",
      "bn": "0.9725232607610629",
      "bg": "0.9952155900120127",
      "zh": "0.9665353492943851",
      "fr": "0.9865644423964192",
      "de": "0.9942975203908694",
      "ha": "0.9951311721000728",
      "hi": "0.9564196998794214",
      "hu": "0.9871589431268566"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n    Parameters:\n- subject_scores (list): A list containing the scores for each subject.\n    Returns:\n    int: The total score obtained by summing up the scores in all subjects.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n",
      "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n    Parametrat:\n- subject_scores (list): Një listë që përmban rezultatet për secilën lëndë.\n    Kthen:\n    int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա:\n    Պարամետրեր:\n- subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n    Վերադարձնում է:\n    int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "bn": "একজন ছাত্রের মোট স্কোর বিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে গণনা করুন।\n    প্যারামিটারসমূহ:\n- subject_scores (list): প্রতিটি বিষয়ের স্কোর সম্বলিত একটি তালিকা।\n    রিটার্নস:\n    int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "bg": "Изчислете общия резултат за ученик въз основа на резултатите по различни предмети.\n    Параметри:\n- subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n    Връща:\n    int: Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "zh": "计算学生在不同科目中的总分。\n    参数:\n- subject_scores (list): 包含每个科目分数的列表。\n    返回:\n    int: 通过将所有科目的分数相加获得的总分。\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n    Paramètres:\n- subject_scores (list): Une liste contenant les scores pour chaque matière.\n    Renvoie:\n    int: Le score total obtenu en additionnant les scores de toutes les matières.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n    Parameter:\n- subject_scores (list): Eine Liste, die die Punktzahlen für jedes Fach enthält.\n    Rückgaben:\n    int: Die Gesamtpunktzahl, die durch Summieren der Punktzahlen in allen Fächern erhalten wird.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "ha": "Kalkaleta jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n    Sigogi:\n- subject_scores (list): Jerin da ke ɗauke da maki na kowanne fanni.\n    Dawowa:\n    int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hi": "छात्र के लिए विभिन्न विषयों में प्राप्त अंकों के आधार पर कुल अंक की गणना करें।\n    पैरामीटर्स:\n- subject_scores (list): प्रत्येक विषय के लिए अंकों की सूची।\n    रिटर्न्स:\n    int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n    Paraméterek:\n- subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n    Visszatérési érték:\n    int: Az összpontszám, amelyet az összes tantárgy pontszámának összegzésével kapunk.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"
    },
    "docstring_bertscore": {
      "sq": "0.9888329999782186",
      "hy": "0.977846753603179",
      "bn": "0.9596537997434315",
      "bg": "0.9815357170397588",
      "zh": "0.9550970201721101",
      "fr": "0.9761568063213341",
      "de": "0.9926202854534107",
      "ha": "0.9888329999782186",
      "hi": "0.9348343377419791",
      "hu": "0.9770762663551446"
    }
  },
  {
    "task_id": "C/14",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë përfaqëson secila shifër.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու համար օրինաչափությունը և հասկանալու իրական արժեքները,\nորոնք ներկայացնում է յուրաքանչյուր թվանշան։\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕգտագործման օրինակ:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করার জন্য এবং প্রতিটি সংখ্যা আসলে কোন মানটি উপস্থাপন করে তা বোঝার জন্য।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডান দিকের সাথে মিলে যায়।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, \nкоито всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n解码一系列数字以揭示模式并理解每个数字实际代表的值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawo:\nint: Sakamakon kowanne kirtani na bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि \nप्रत्येक अंक का वास्तविक मूल्य क्या है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाएँ हाथ की ओर संबंधित है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDekódolja a számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek \nmilyen tényleges értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy karakterlánc, amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "sq": "0.9842301381584971",
      "hy": "0.9430661766232079",
      "bn": "0.9758096004152851",
      "bg": "0.9881334237762137",
      "zh": "0.98174129948413",
      "fr": "0.982493115476347",
      "de": "0.9786974875251514",
      "ha": "0.9602363826510067",
      "hi": "0.9778652262286152",
      "hu": "0.9834036371430109"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `int decode_numbers(const char* data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n",
      "sq": "Shkruani një funksion C `int decode_numbers(const char* data_str)` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\nKthen:\nint: Rezultati i secilës varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);",
      "hy": "Գրեք C ֆունկցիա `int decode_numbers(const char* data_str)` հետևյալ խնդիրը լուծելու համար:\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);",
      "bn": "একটি C ফাংশন `int decode_numbers(const char* data_str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্ক আসলে কী মান প্রকাশ করে তা বুঝতে।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্ন:\nint: প্রতিটি ডেটা স্ট্রিং এর সমীকরণের ডান দিকের মানের সাথে সম্পর্কিত ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);",
      "bg": "Напишете C функция `int decode_numbers(const char* data_str)`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);",
      "zh": "编写一个 C 函数 `int decode_numbers(const char* data_str)` 来解决以下问题：\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 表示一系列数字的字符串。长度不超过 100。\n\n返回：\nint: 每个数据字符串对应于等式右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);",
      "fr": "Écrire une fonction C `int decode_numbers(const char* data_str)` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);",
      "de": "Schreiben Sie eine C-Funktion `int decode_numbers(const char* data_str)`, um das folgende Problem zu lösen:\nDekodieren Sie eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);",
      "ha": "Rubuta aikin C `int decode_numbers(const char* data_str)` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowane lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowane kirtani na bayanai da ya dace da gefen dama na daidaitawar.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);",
      "hi": "C फ़ंक्शन `int decode_numbers(const char* data_str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: संख्याओं की एक श्रृंखला का प्रतिनिधित्व करने वाला एक स्ट्रिंग। लंबाई 100 से अधिक नहीं है।\n\nवापसी मान:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);",
      "hu": "Írj egy C függvényt `int decode_numbers(const char* data_str)` a következő probléma megoldására:\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatkarakterláncoknak megfelelő eredmény az egyenlet jobb oldalán.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "instruction_bertscore": {
      "sq": "0.9874195461867743",
      "hy": "0.9801782770157664",
      "bn": "0.972290267324109",
      "bg": "0.9904713033609943",
      "zh": "0.9771753829152809",
      "fr": "0.9847753785544379",
      "de": "0.9780755758021311",
      "ha": "0.9696586134057777",
      "hi": "0.9742426053393008",
      "hu": "0.9759444704440078"
    },
    "level": "easy",
    "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A string representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n",
      "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson çdo shifër.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i çdo vargu të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);",
      "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու համար օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին:\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);",
      "bn": "সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্নটি প্রকাশ করুন এবং প্রতিটি অঙ্ক কী মান উপস্থাপন করে তা বুঝুন।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডান দিকের সাথে সম্পর্কিত।\n\nব্যবহারের উদাহরণ:\nassert(decode_numbers(\"0000\") == 4);",
      "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);",
      "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个表示一系列数字的字符串。长度不超过100。\n\n返回：\nint: 每个数据字符串对应于等式右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);",
      "fr": "Décoder une série de nombres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres:\n- data_str: Une chaîne représentant une série de nombres. La longueur ne dépasse pas 100.\n\nRenvoie:\nint: Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation:\nassert(decode_numbers(\"0000\") == 4);",
      "de": "Dekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer repräsentiert.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein String, der eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);",
      "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wani igiyar rubutu da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowane igiyar rubutu na bayanan da ya dace da gefen dama na daidaitawar.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);",
      "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक वास्तव में क्या दर्शाता है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप होता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);",
      "hu": "Dekódoljon egy számsorozatot, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "sq": "0.9771561157683206",
      "hy": "0.9718590407668822",
      "bn": "0.9701824017205667",
      "bg": "0.9881681840928949",
      "zh": "0.9730398983821347",
      "fr": "0.9867156001163867",
      "de": "0.9811537508170288",
      "ha": "0.9695537365645913",
      "hi": "0.9760727856701563",
      "hu": "0.9710015534119546"
    }
  },
  {
    "task_id": "C/15",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\nduke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՀաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով,\nհաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ։\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը։\n- m (int): Գույների քանակը։\n    Վերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003։\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nএই শর্ত বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা প্রদান করে। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nБрои броя на различните методи за оцветяване на n квадрата с m цвята,\nкато се взема предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n考虑到相邻方块和第一个/最后一个方块必须具有不同颜色的要求。\n    参数:\n- n (int): 方块的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的计数。结果取模 1000003。\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\nen considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\n    Argumente:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n    Rückgabe:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nYana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m,\nla'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'i na farko/na ƙarshe\ndole ne su sami launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Adadin hanyoyin canza launi daban-daban da suka cika ƙa'idodin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nn वर्गों के लिए m रंगों की विभिन्न रंगाई विधियों की संख्या गिनता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\nरंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    लौटाता है:\n    int: निर्दिष्ट शर्तों को संतोषजनक बनाने वाली विभिन्न रंगाई विधियों की संख्या। परिणाम 1000003 के मापांक में है।\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nMegszámolja az n négyzet m színnel való különböző színezési módszereit,\nfigyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\nkülönböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: Az adott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9745363796728514",
      "hy": "0.9688682631196399",
      "bn": "0.9633489207218234",
      "bg": "0.9752023873404615",
      "zh": "0.9148131898551864",
      "fr": "0.9968149618401055",
      "de": "0.9784422474855216",
      "ha": "0.92891912499476",
      "hi": "0.9764626971081278",
      "hu": "0.9730563847037605"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "Write a C function `int count_coloring_methods(int n, int m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n",
      "sq": "Shkruani një funksion në C `int count_coloring_methods(int n, int m)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "hy": "Գրեք C ֆունկցիա `int count_coloring_methods(int n, int m)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տարբեր ներկման մեթոդների քանակը n քառակուսիների համար m գույներով՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը:\n- m (int): Գույների քանակը:\n    Վերադարձնում է:\n    int: Տարբեր ներկման մեթոդների քանակը, որը բավարարում է նշված պայմանները: Արդյունքը մոդուլո 1000003:\n    >>> count_coloring_methods(1,1)\n    1",
      "bn": "একটি C ফাংশন `int count_coloring_methods(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, এই শর্ত বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n    আর্গুমেন্টসমূহ:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    রিটার্নস:\n    int: নির্দিষ্ট শর্তাবলী পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1",
      "bg": "Напишете C функция `int count_coloring_methods(int n, int m)` за решаване на следния проблем:\nБрои броя на различните методи за оцветяване на n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е по модул 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "zh": "编写一个 C 函数 `int count_coloring_methods(int n, int m)` 来解决以下问题：\n计算使用 m 种颜色为 n 个方块着色的不同方法数，要求相邻的方块以及第一个和最后一个方块必须使用不同的颜色。\n    参数:\n- n (int): 方块的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的数量。结果对 1000003 取模。\n    >>> count_coloring_methods(1,1)\n    1",
      "fr": "Écrire une fonction C `int count_coloring_methods(int n, int m)` pour résoudre le problème suivant :\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n    Args:\n- n (int) : Le nombre de carrés.\n- m (int) : Le nombre de couleurs.\n    Returns:\n    int : Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "de": "Schreiben Sie eine C-Funktion `int count_coloring_methods(int n, int m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n    Argumente:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n    Rückgabewert:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "ha": "Rubuta aikin C `int count_coloring_methods(int n, int m)` don warware matsalar mai zuwa:\nYana ƙididdige yawan hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n   Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n   Returns:\n   int: Yawan hanyoyin launuka daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamako yana daidai da 1000003.\n   >>> count_coloring_methods(1,1)\n   1",
      "hi": "C फ़ंक्शन `int count_coloring_methods(int n, int m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn वर्गों के लिए m रंगों के विभिन्न रंगाई तरीकों की संख्या गिनें, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्ग और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    रिटर्न करता है:\n    int: निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगाई तरीकों की गिनती। परिणाम 1000003 के मापांक में है।\n    >>> count_coloring_methods(1,1)\n    1",
      "hu": "Írj egy C függvényt `int count_coloring_methods(int n, int m)` a következő probléma megoldására:\nMegszámolja az n négyzet m színnel történő különböző színezési módszereit, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1"
    },
    "instruction_bertscore": {
      "sq": "0.9683234199844613",
      "hy": "0.9759081210842784",
      "bn": "0.9304885036353168",
      "bg": "0.973218467094685",
      "zh": "0.925850285607771",
      "fr": "0.9810566205607028",
      "de": "0.9694865994958015",
      "ha": "0.9666054658188905",
      "hi": "0.9603998554545985",
      "hu": "0.9755567439402277"
    },
    "level": "hard",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n    Args:\n- n (int): The number of squares.\n- m (int): The number of colors.\n    Returns:\n    int: The count of different coloring methods satisfying the specified conditions. Result is modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n",
      "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n    Argumentet:\n- n (int): Numri i katrorëve.\n- m (int): Numri i ngjyrave.\n    Kthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "hy": "Հաշվում է n քառակուսիների համար m գույներով տարբեր ներկման մեթոդների քանակը՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n    Արգումենտներ:\n- n (int): Քառակուսիների քանակը:\n- m (int): Գույների քանակը:\n    Վերադարձնում է:\n    int: Տարբեր ներկման մեթոդների քանակը, որը բավարարում է նշված պայմանները: Արդյունքը՝ մոդուլո 1000003:\n    >>> count_coloring_methods(1,1)\n    1",
      "bn": "nটি বর্গক্ষেত্র এবং mটি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n    Args:\n- n (int): বর্গক্ষেত্রের সংখ্যা।\n- m (int): রঙের সংখ্যা।\n    Returns:\n    int: নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফল 1000003 দ্বারা মডুলো।\n    >>> count_coloring_methods(1,1)\n    1",
      "bg": "Брои броя на различните методи за оцветяване на n квадрата с m цвята, като се взема предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n    Аргументи:\n- n (int): Броят на квадратите.\n- m (int): Броят на цветовете.\n    Връща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n    参数:\n- n (int): 方块的数量。\n- m (int): 颜色的数量。\n    返回:\n    int: 满足指定条件的不同着色方法的计数。结果取模 1000003。\n    >>> count_coloring_methods(1,1)\n    1",
      "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n    Args:\n- n (int): Le nombre de carrés.\n- m (int): Le nombre de couleurs.\n    Returns:\n    int: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n    \nArgs:\n- n (int): Die Anzahl der Quadrate.\n- m (int): Die Anzahl der Farben.\n\nReturns:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\n    >>> count_coloring_methods(1,1)\n    1",
      "ha": "Yana ƙididdige yawan hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n    Args:\n- n (int): Yawan murabba'ai.\n- m (int): Yawan launuka.\n    Returns:\n    int: Yawan hanyoyin zana launuka daban-daban da suka cika ka'idodin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "hi": "विभिन्न रंगाई विधियों की संख्या की गणना करता है n वर्गों के लिए m रंगों के साथ, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n    तर्क:\n- n (int): वर्गों की संख्या।\n- m (int): रंगों की संख्या।\n    वापसी:\n    int: निर्दिष्ट शर्तों को पूरा करने वाली विभिन्न रंगाई विधियों की संख्या। परिणाम 1000003 के मापांक में है।\n    >>> count_coloring_methods(1,1)\n    1",
      "hu": "Számolja meg a különböző színezési módszerek számát n négyzetre m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n    Args:\n- n (int): A négyzetek száma.\n- m (int): A színek száma.\n    Returns:\n    int: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek. Az eredmény modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9683260021794147",
      "hy": "0.93646211371456",
      "bn": "0.916250677922736",
      "bg": "0.9589740865795301",
      "zh": "0.9242570713214903",
      "fr": "0.9866401205715934",
      "de": "0.9789894741852726",
      "ha": "0.9748055238391538",
      "hi": "0.9591439155553149",
      "hu": "0.9753362642172789"
    }
  },
  {
    "task_id": "C/16",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n​    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n​    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը առանց հաջորդական գլուխների n նետումների դեպքում:\n​    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը:\n​    Վերադարձնում է:\n​    unsigned long long: Վավեր հաջորդականությունների քանակը:\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকোনো পরপরের হেড ছাড়াই n বার টস করার বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\n    রিটার্নস:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n​    Параметри:\n- n (int): Броят на хвърлянията на монета.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算在n次投掷中没有连续正面的有效硬币投掷序列的数量。\n    参数:\n- n (int): 硬币投掷的次数。\n    返回:\n    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n​    Paramètres :\n- n (int) : Le nombre de lancers de pièces.\n​    Renvoie :\n​    unsigned long long : Le nombre de séquences valides.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n​    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabe:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa tsabar kudi n.\n​    Sigogi:\n- n (int): Adadin jefa tsabar kudi.\n​    Yana dawowa:\n​    unsigned long long: Adadin sahihan jerin.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nn उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n​    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n​    रिटर्न्स:\n​    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobásban.\n​    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatér:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9705389432545244",
      "hy": "0.9688760097045003",
      "bn": "0.9631135437202971",
      "bg": "0.9756586413256986",
      "zh": "0.9756689701055125",
      "fr": "0.9761736899037221",
      "de": "0.9721460616674776",
      "ha": "0.9506238639912044",
      "hi": "0.9723198632508832",
      "hu": "0.9773281296782969"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "Write a C function `unsigned long long count_valid_coin_toss_sequences(int n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n",
      "sq": "Shkruani një funksion në C `unsigned long long count_valid_coin_toss_sequences(int n)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hy": "Գրեք C ֆունկցիա `unsigned long long count_valid_coin_toss_sequences(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետումների հաջորդականությունների քանակը առանց հաջորդական գլուխների n նետումների դեպքում։\n    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n​    Վերադարձնում է:\n​    unsigned long long: Վավեր հաջորդականությունների քանակը։\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "bn": "একটি C ফাংশন `unsigned long long count_valid_coin_toss_sequences(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn বার টস করার সময় কোনো পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\n​    রিটার্নস:\n​    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "bg": "Напишете C функция `unsigned long long count_valid_coin_toss_sequences(int n)`, за да решите следния проблем:\nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n    Параметри:\n- n (int): Броят на хвърлянията на монетата.\n​    Връща:\n​    unsigned long long: Броят на валидните последователности.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "zh": "编写一个 C 函数 `unsigned long long count_valid_coin_toss_sequences(int n)` 来解决以下问题：\n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n    参数：\n- n (int): 投掷硬币的次数。\n    返回：\n    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "fr": "Écrire une fonction C `unsigned long long count_valid_coin_toss_sequences(int n)` pour résoudre le problème suivant :  \nCompter le nombre de séquences de lancers de pièces valides sans têtes consécutives dans n lancers.  \n    Paramètres :  \n- n (int) : Le nombre de lancers de pièces.  \n​    Renvoie :  \n​    unsigned long long : Le compte des séquences valides.  \n    >>> count_valid_coin_toss_sequences(1)  \n    2  ",
      "de": "Schreiben Sie eine C-Funktion `unsigned long long count_valid_coin_toss_sequences(int n)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabewert:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "ha": "Rubuta wani aikin C `unsigned long long count_valid_coin_toss_sequences(int n)` don warware matsalar mai zuwa:\nƘirga adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n​    Mayarwa:\n​    unsigned long long: Adadin sahihan jerin.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hi": "एक C फ़ंक्शन `unsigned long long count_valid_coin_toss_sequences(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn उछालों में बिना लगातार हेड्स के मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\n    पैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n    रिटर्न करता है:\n    unsigned long long: मान्य अनुक्रमों की संख्या।\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hu": "Írj egy C függvényt `unsigned long long count_valid_coin_toss_sequences(int n)` a következő probléma megoldására:\nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatérési érték:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9774814723324557",
      "hy": "0.969813942363747",
      "bn": "0.9595501146845312",
      "bg": "0.9802362770870287",
      "zh": "0.9727351993776271",
      "fr": "0.9840992407373951",
      "de": "0.9702797306072738",
      "ha": "0.9668773908105273",
      "hi": "0.9724598976695128",
      "hu": "0.9728464323910067"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n    Parameters:\n- n (int): The number of coin tosses.\n​    Returns:\n​    unsigned long long: The count of valid sequences.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n    Parametrat:\n- n (int): Numri i hedhjeve të monedhës.\n​    Kthen:\n​    unsigned long long: Numri i sekuencave të vlefshme.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hy": "Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը, որտեղ n նետումների դեպքում երկու հաջորդական գլխիկներ չկան:\n    Պարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը.\n    Վերադարձնում է:\n    unsigned long long: Վավեր հաջորդականությունների քանակը.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n    প্যারামিটার:\n    - n (int): কয়েন টসের সংখ্যা।\n    রিটার্ন:\n    unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "bg": "Бройте броя на валидните поредици от хвърляния на монета без последователни ези в n хвърляния.\n    Параметри:\n- n (int): Броят на хвърлянията на монетата.\n    Връща:\n    unsigned long long: Броят на валидните поредици.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n    参数:\n- n (int): 硬币投掷的次数。\n    返回:\n    unsigned long long: 有效序列的数量。\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n    Paramètres:\n- n (int): Le nombre de lancers de pièce.\n    Renvoie:\n    unsigned long long: Le compte des séquences valides.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n    Parameter:\n- n (int): Die Anzahl der Münzwürfe.\n​    Rückgabewert:\n​    unsigned long long: Die Anzahl der gültigen Sequenzen.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "ha": "Kirga adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa tsabar kudi n.\n    Sigogi:\n- n (int): Yawan jefa tsabar kudi.\n    Mayarwa:\n    unsigned long long: Adadin sahihan jerin.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hi": "n उछालों में कोई लगातार हेड्स न होने वाली वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n    पैरामीटर्स:\n    - n (int): सिक्का उछालों की संख्या।\n    रिटर्न्स:\n    unsigned long long: वैध अनुक्रमों की गिनती।\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, amelyekben nincs egymást követő fej n dobás esetén.\n    Paraméterek:\n- n (int): A pénzfeldobások száma.\n​    Visszatér:\n​    unsigned long long: Az érvényes sorozatok száma.\n    >>> count_valid_coin_toss_sequences(1)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.961029513762479",
      "hy": "0.9417093324903586",
      "bn": "0.958917079660173",
      "bg": "0.9674341517685681",
      "zh": "0.9611814660039708",
      "fr": "0.9775718491558266",
      "de": "0.9584715517155118",
      "ha": "0.9422438468457235",
      "hi": "0.950405171941685",
      "hu": "0.9613576511519487"
    }
  },
  {
    "task_id": "C/17",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n​    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n​    Returns:\n​    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n​    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n​    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n​    Kthen:\n​    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n​    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԳտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n​    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n​    Վերադարձնում է:\n​    int: Տրված թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n​    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n    \n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n​    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n​    Връща:\n​    int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n​    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n找到一个非负整数的二进制表示中最长连续1的序列长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n​    Paramètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n​    Renvoie :\n​    int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n​    \n    Exemples :\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFinde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabe:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n​    Sigogi:\n- n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n​    Mayar da:\n​    int: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n​    \n    Misalai:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न करता है:\n    int: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTalálja meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n​    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n​    Visszatérési érték:\n​    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n​    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "sq": "0.9634408865882427",
      "hy": "0.9655860947034194",
      "bn": "0.9766941015020335",
      "bg": "0.9743359616183873",
      "zh": "0.9604745404778676",
      "fr": "0.9811843398957082",
      "de": "0.9784994530352595",
      "ha": "0.9437417185491076",
      "hi": "0.973953002243752",
      "hu": "0.9794719473808063"
    },
    "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}",
    "instruction": {
      "en": "Write a C function `int find_longest_consecutive_ones_length(unsigned long long n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n",
      "sq": "Shkruani një funksion në C `int find_longest_consecutive_ones_length(unsigned long long n)` për të zgjidhur problemin në vijim:\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n    Parametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n    Kthen:\n    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hy": "Գրեք C ֆունկցիա `int find_longest_consecutive_ones_length(unsigned long long n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ։\n    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n    Վերադարձնում է:\n    int: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը։\n    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "bn": "একটি C ফাংশন `int find_longest_consecutive_ones_length(unsigned long long n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1-এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজুন।\n    প্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1-এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n\n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "bg": "Напишете C функция `int find_longest_consecutive_ones_length(unsigned long long n)`, за да решите следния проблем:  \nНамерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n    Връща:\n    int: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "zh": "编写一个 C 函数 `int find_longest_consecutive_ones_length(unsigned long long n)` 来解决以下问题：\n找到一个非负整数的二进制表示中最长连续 1 序列的长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续 1 序列的长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "fr": "Écrire une fonction C `int find_longest_consecutive_ones_length(unsigned long long n)` pour résoudre le problème suivant :  \nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.  \n    Paramètres :  \n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).  \n    Renvoie :  \n    int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.  \n    \n    Exemples :  \n    >>> find_longest_consecutive_ones_length(7)  \n    3  ",
      "de": "Schreiben Sie eine C-Funktion `int find_longest_consecutive_ones_length(unsigned long long n)`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabewert:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "ha": "Rubuta wani aikin C `int find_longest_consecutive_ones_length(unsigned long long n)` don warware matsalar mai zuwa:\nNemo tsawon jerin lambobi 1s mafi tsawo a cikin wakilcin binary na lamba mara kyau.\n    Sigogi:\n- n (unsigned long long): Wata lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n    Mayar da:\n    int: Tsawon jerin lambobi 1s mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n    \n    Misalai:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hi": "C फ़ंक्शन `int find_longest_consecutive_ones_length(unsigned long long n)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न करता है:\n    int: दिए गए पूर्णांक के बाइनरी रूप में 1s के सबसे लंबे अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hu": "Írj egy C függvényt `int find_longest_consecutive_ones_length(unsigned long long n)` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n    Paraméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n    Visszatérési érték:\n    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9742479683595888",
      "hy": "0.9920547847586044",
      "bn": "0.9982742992495689",
      "bg": "0.9816354294910383",
      "zh": "0.9946121509144287",
      "fr": "1",
      "de": "0.9947815826294514",
      "ha": "0.9801117358381197",
      "hi": "0.9599620740947976",
      "hu": "0.9947815826294514"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n    Returns:\n    int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n    \n    Examples:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n    Parametra:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n    Kthen:\n    int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n    \n    Shembuj:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ։\n    Պարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n    Վերադարձնում է:\n    int: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n    \n    Օրինակներ:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n    প্যারামিটার:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n    রিটার্নস:\n    int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1s এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n\n    উদাহরণ:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "bg": "Намерете дължината на най-дългата последователна поредица от 1 в двоичното представяне на неотрицателно цяло число.\n    Параметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n    Връща:\n    int: Дължината на най-дългата последователна поредица от 1 в двоичното представяне на даденото число.\n    \n    Примери:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "zh": "找出非负整数的二进制表示中最长连续1的序列长度。\n    参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n    返回：\n    int: 给定整数的二进制表示中最长连续1的序列长度。\n    \n    示例：\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n    Paramètres:\n- n (unsigned long long): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n    Renvoie:\n    int: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n    \n    Exemples:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n    Parameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n    Rückgabewert:\n    int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n    \n    Beispiele:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n",
      "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n    Sigogi:\n- n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n    Dawowa:\n    int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n    \n    Misalai:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n    पैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n    रिटर्न्स:\n    int: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में सबसे लंबे लगातार 1s के अनुक्रम की लंबाई।\n    \n    उदाहरण:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "hu": "Találja meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n    Paraméterek:\n- n (unsigned long long): Egy nemnegatív egész szám (0 ≤ n ≤ 2^64 - 1).\n    Visszatérési érték:\n    int: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n    \n    Példák:\n    >>> find_longest_consecutive_ones_length(7)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9670877403840432",
      "hy": "0.9899157341852398",
      "bn": "0.9978671069684474",
      "bg": "0.9889507877941722",
      "zh": "0.9937028210300509",
      "fr": "1",
      "de": "0.9936922936198561",
      "ha": "0.9744535508039599",
      "hi": "0.9978671069684474",
      "hu": "0.9936922936198561"
    }
  },
  {
    "task_id": "C/18",
    "prompt": {
      "en": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCreates an ID by combining two words in a specific manner.\n​Parameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\n​Returns:\n​char*: A divine ID formed by reversing every other character of the second \n        word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "sq": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\n​Parametrat:\n- word1 (char*): Fjala e parë që do të përdoret në ID.\n- word2 (char*): Fjala e dytë që do të përdoret në ID.\n​Kthen:\n​char*: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë \n        dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "hy": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով:\n​Պարամետրեր:\n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ի մեջ:\n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ի մեջ:\n​Վերադարձնում է:\n​char*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի ամեն երկրորդ \n        նիշը շրջելով և այն առաջին բառի հետ համադրելով:\nօր.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "bn": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nদুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\n​প্যারামিটারসমূহ:\n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\n​ফেরত দেয়:\n​char*: দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে \n        একত্রিত করে গঠিত একটি অনন্য আইডি।\nউদাহরণ:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "bg": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на втората \n        дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "zh": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\n通过以特定方式组合两个单词来创建ID。\n参数:\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回:\nchar*: 一个神圣的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "fr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'ID.\n- word2 (char*): Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nchar*: Un ID divin formé en inversant chaque autre caractère du deuxième \n        mot et en le combinant avec le premier mot.\nex. :\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "de": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des \n        zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "ha": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\n​Sigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n​Yana dawowa:\n​char*: Wani ID mai ban mamaki da aka kafa ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu \n        da haɗa shi da kalma ta farko.\ne.g.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "hi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nदो शब्दों को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।\nवापसी:\nchar*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और पहले शब्द के \n        साथ मिलाकर बनाई जाती है।\nउदाहरण:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "hu": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.\n- word2 (char*): A második szó, amelyet az azonosítóban használunk.\nVisszatérési érték:\nchar*: Egy isteni azonosító, amely a második szó minden második karakterének \n       megfordításával és az első szóval való kombinálásával jön létre.\npl.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)"
    },
    "prompt_bertscore": {
      "sq": "0.9790953441783642",
      "hy": "0.9730522134657588",
      "bn": "0.9471331336748973",
      "bg": "0.9657918757781716",
      "zh": "0.9489468276841269",
      "fr": "0.9609397328302514",
      "de": "0.9702384154880186",
      "ha": "0.9577336398499672",
      "hi": "0.931332484124334",
      "hu": "0.9439814654190167"
    },
    "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}",
    "instruction": {
      "en": "Write a C function `char* create_id(const char* word1, const char* word2)` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n",
      "sq": "Shkruani një funksion në C `char* create_id(const char* word1, const char* word2)` për të zgjidhur problemin e mëposhtëm:\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (char*): Fjala e parë që do të përdoret në ID.\n- word2 (char*): Fjala e dytë që do të përdoret në ID.\nKthen:\nchar*: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar me fjalën e parë.\np.sh.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "hy": "Գրեք C ֆունկցիա `char* create_id(const char* word1, const char* word2)` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով:\nՊարամետրեր:\n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում:\n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում:\nՎերադարձնում է:\nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի ամեն երկրորդ նիշը շրջելով և այն առաջին բառի հետ համադրելով:\nօր.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "bn": "একটি C ফাংশন `char* create_id(const char* word1, const char* word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন করে:\nchar*: একটি অনন্য আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে একত্রিত করে গঠিত হয়।\nযেমন:\n    >>> create_id(fish,cat)\n    ftiasch",
      "bg": "Напишете C функция `char* create_id(const char* word1, const char* word2)` за решаване на следния проблем:\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще бъде използвана в ID.\n- word2 (char*): Втората дума, която ще бъде използвана в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "zh": "编写一个 C 函数 `char* create_id(const char* word1, const char* word2)` 来解决以下问题：\n通过以特定方式组合两个单词来创建一个 ID。\n参数：\n- word1 (char*): 用于 ID 的第一个单词。\n- word2 (char*): 用于 ID 的第二个单词。\n返回：\nchar*: 一个神奇的 ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> create_id(fish,cat)\n    ftiasch",
      "fr": "Écrire une fonction C `char* create_id(const char* word1, const char* word2)` pour résoudre le problème suivant :\nCrée un identifiant en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*): Le premier mot à utiliser dans l'identifiant.\n- word2 (char*): Le deuxième mot à utiliser dans l'identifiant.\nRenvoie :\nchar*: Un identifiant divin formé en inversant chaque autre caractère du deuxième mot et en le combinant avec le premier mot.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "de": "Schreiben Sie eine C-Funktion `char* create_id(const char* word1, const char* word2)`, um das folgende Problem zu lösen:\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "ha": "Rubuta aikin C `char* create_id(const char* word1, const char* word2)` don warware matsalar mai zuwa:\nƘirƙiri ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\nSigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nDawowa:\nchar*: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu da haɗa shi da kalma ta farko.\nmisali:\n    >>> create_id(fish,cat)\n    ftiasch",
      "hi": "C में एक फ़ंक्शन `char* create_id(const char* word1, const char* word2)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nविशिष्ट तरीके से दो शब्दों को मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (char*): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (char*): आईडी में उपयोग के लिए दूसरा शब्द।\nरिटर्न करता है:\nchar*: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और पहले शब्द के साथ मिलाकर बनाई जाती है।\nउदाहरण:\n    >>> create_id(fish,cat)\n    ftiasch",
      "hu": "Írj egy C függvényt `char* create_id(const char* word1, const char* word2)` a következő probléma megoldására:\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használnak.\n- word2 (char*): A második szó, amelyet az azonosítóban használnak.\nVisszatérési érték:\nchar*: Egy isteni azonosító, amelyet a második szó minden második karakterének megfordításával és az első szóval való kombinálásával hoz létre.\npélda:\n    >>> create_id(fish,cat)\n    ftiasch"
    },
    "instruction_bertscore": {
      "sq": "0.9929071077236252",
      "hy": "0.9895603844335683",
      "bn": "0.9651354023688512",
      "bg": "0.9933927590052555",
      "zh": "0.951606488486184",
      "fr": "0.9674573915231491",
      "de": "0.9831319107817552",
      "ha": "0.9577795234679862",
      "hi": "0.9659124444194598",
      "hu": "0.9363012231059217"
    },
    "level": "hard",
    "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "char* create_id(const char* word1, const char* word2)",
    "docstring": {
      "en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (char*): The first word to be used in the ID.\n- word2 (char*): The second word to be used in the ID.\nReturns:\nchar*: A divine ID formed by reversing every other character of the second word and combining it with the first word.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch\n",
      "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.  \nParametrat:  \n- word1 (char*): Fjala e parë që do të përdoret në ID.  \n- word2 (char*): Fjala e dytë që do të përdoret në ID.  \nKthen:  \nchar*: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.  \np.sh.:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համակցելով։  \nՊարամետրեր:  \n- word1 (char*): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (char*): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nchar*: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ նիշը շրջելով և համակցելով այն առաջին բառի հետ։  \nօր.՝  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "bn": "দুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:  \n- word1 (char*): আইডিতে ব্যবহৃত প্রথম শব্দ।  \n- word2 (char*): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।  \nরিটার্নস:  \nchar*: একটি ঐশ্বরিক আইডি যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে প্রথম শব্দের সাথে মিলিয়ে গঠিত হয়।  \nউদাহরণ:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (char*): Първата дума, която ще се използва в ID.\n- word2 (char*): Втората дума, която ще се използва в ID.\nВръща:\nchar*: Божествено ID, образувано чрез обръщане на всеки втори символ на втората дума и комбинирането му с първата дума.\nнапр.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "zh": "通过以特定方式组合两个单词来创建一个ID。\n参数：\n- word1 (char*): 用于ID的第一个单词。\n- word2 (char*): 用于ID的第二个单词。\n返回：\nchar*: 一个神奇的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> create_id(fish,cat)\n    ftiasch",
      "fr": "Crée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (char*) : Le premier mot à utiliser dans l'ID.\n- word2 (char*) : Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nchar* : Un ID divin formé en inversant tous les autres caractères du deuxième mot et en le combinant avec le premier mot.\nex. :\n    >>> create_id(fish,cat)\n    ftiasch",
      "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (char*): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (char*): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nchar*: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "ha": "Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\n\nSigogi:\n- word1 (char*): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (char*): Kalma ta biyu da za a yi amfani da ita a cikin ID.\n\nMayar da:\nchar*: Wani ID mai ban mamaki wanda aka ƙirƙira ta hanyar juyar da kowanne na biyu daga cikin haruffan kalma ta biyu sannan a haɗa shi da kalma ta farko.\n\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "hi": "दो शब्दों को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:  \n- word1 (char*): ID में उपयोग के लिए पहला शब्द।  \n- word2 (char*): ID में उपयोग के लिए दूसरा शब्द।  \nरिटर्न्स:  \nchar*: एक दिव्य ID जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और इसे पहले शब्द के साथ मिलाकर बनाई जाती है।  \nउदाहरण:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "hu": "Létrehoz egy azonosítót két szó speciális módon történő kombinálásával.\nParaméterek:\n- word1 (char*): Az első szó, amelyet az azonosítóban használunk.\n- word2 (char*): A második szó, amelyet az azonosítóban használunk.\nVisszatér:\nchar*: Egy isteni azonosító, amelyet úgy alakítunk ki, hogy a második szó minden második karakterét megfordítjuk, és kombináljuk az első szóval.\npélda:\n    >>> create_id(fish,cat)\n    ftiasch"
    },
    "docstring_bertscore": {
      "sq": "0.990474878707853",
      "hy": "0.9721023629836499",
      "bn": "0.9553576232320279",
      "bg": "0.9821153204916186",
      "zh": "0.938272431007312",
      "fr": "0.9742281053214853",
      "de": "0.9781858156636055",
      "ha": "0.960192088076036",
      "hi": "0.9606924380058629",
      "hu": "0.9409736055590053"
    }
  },
  {
    "task_id": "C/19",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՀաշվել տարբեր տեղափոխման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է:\n​    Պարամետրեր:\n- n (int): Երկբայական տողի երկարությունը:\n- m (int): '1'-երի քանակը երկբայական տողի մեջ:\n​    Վերադարձնում է:\n​    int: Տարբեր տեղափոխման սխեմաների ընդհանուր քանակը:\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n    প্যারামিটার:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n    রিটার্নস:\n    int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nБрой на различните схеми на пермутация за двоичен низ с дължина n,\nкъдето броят на '1'-ците е m, а броят на '0'-ците е n - m.\n    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутация.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n计算长度为 n 的二进制字符串的不同排列方案数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n    参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n    返回:\n    int: 不同排列方案的总数量。\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n​    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n​    Renvoie:\n​    int: Le nombre total de différents schémas de permutation.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n    Rückgabe:\n    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nƘirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n​    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n​    Komawa:\n​    int: Jimlar adadin tsarin juyawa daban-daban.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nएक बाइनरी स्ट्रिंग की विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें जिसकी लंबाई n है,\nजहां '1' की संख्या m है और '0' की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n    रिटर्न करता है:\n    int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m, és a '0'-k száma n - m.\n​    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n​    Visszatér:\n​    int: A különböző permutációs sémák teljes száma.\n*/\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9833498083097505",
      "hy": "0.9769125949211719",
      "bn": "0.9833498083097505",
      "bg": "0.9727930008185083",
      "zh": "0.9644878673266775",
      "fr": "0.9774044037446142",
      "de": "0.9852387832333923",
      "ha": "0.9714073552804089",
      "hi": "0.9814634155810622",
      "hu": "0.9818557105836061"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "en": "Write a C function `int count_permutations_of_binary_string(int n, int m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n",
      "sq": "Shkruani një funksion në C `int count_permutations_of_binary_string(int n, int m)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n​    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n​    Kthen:\n​    int: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Գրեք C ֆունկցիա `int count_permutations_of_binary_string(int n, int m)`՝ լուծելու համար հետևյալ խնդիրը:\nՀաշվեք տարբեր պերմուտացիոն սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n​    Պարամետրեր:\n- n (int): Երկբանական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբանական տողի մեջ։\n​    Վերադարձնում է:\n​    int: Տարբեր պերմուտացիոն սխեմաների ընդհանուր քանակը։",
      "bn": "একটি C ফাংশন `int count_permutations_of_binary_string(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n    প্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n    রিটার্নস:\n    int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Напишете C функция `int count_permutations_of_binary_string(int n, int m)`, за да решите следния проблем:\nПребройте броя на различните схеми на пермутации за двоична низ с дължина n,\nкъдето броят на '1'-ците е m и броят на '0'-ците е n - m.\n​    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n​    Връща:\n​    int: Общият брой на различните схеми на пермутации.",
      "zh": "编写一个 C 函数 `int count_permutations_of_binary_string(int n, int m)` 来解决以下问题：\n计算长度为 n 的二进制字符串的不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n​    参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n​    返回：\n​    int: 不同排列方案的总数。",
      "fr": "Écrivez une fonction C `int count_permutations_of_binary_string(int n, int m)` pour résoudre le problème suivant :  \nComptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,  \noù le nombre de '1' est m et le nombre de '0' est n - m.  \n​    Paramètres :  \n- n (int) : Longueur de la chaîne binaire.  \n- m (int) : Nombre de '1' dans la chaîne binaire.  \n​    Renvoie :  \n​    int : Le nombre total de différents schémas de permutation.  ",
      "de": "Schreiben Sie eine C-Funktion `int count_permutations_of_binary_string(int n, int m)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m.\n​    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n​    Rückgabewert:\n​    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Rubuta wani aikin C `int count_permutations_of_binary_string(int n, int m)` don warware matsalar mai zuwa:\nƘididdige yawan tsarin permutation daban-daban na igiyar binary mai tsawon n,\ninda adadin '1's ya zama m kuma adadin '0's ya zama n - m.\n​    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n​    Mayar da:\n​    int: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "C फ़ंक्शन `int count_permutations_of_binary_string(int n, int m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक बाइनरी स्ट्रिंग की विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें जिसकी लंबाई n है,\nजहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n    पैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n    रिटर्न्स:\n    int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Írj egy C függvényt `int count_permutations_of_binary_string(int n, int m)` a következő probléma megoldására:\nSzámold meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m és a '0'-k száma n - m.\n​    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n​    Visszatérési érték:\n​    int: A különböző permutációs sémák teljes száma."
    },
    "instruction_bertscore": {
      "sq": "0.9814062100313241",
      "hy": "0.9799017835253658",
      "bn": "0.9842307340496402",
      "bg": "0.9651354023688512",
      "zh": "0.9609315889846288",
      "fr": "0.989313288239561",
      "de": "0.9809163875116921",
      "ha": "0.9669202949728307",
      "hi": "0.958620723131669",
      "hu": "0.9787213231708756"
    },
    "level": "hard",
    "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n​    Parameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n​    Returns:\n​    int: The total number of different permutation schemes.\n",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n    Parametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n    Kthen:\n    int: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր վերադասավորման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է:\n​    Պարամետրեր:\n- n (int): Երկբայական տողի երկարությունը:\n- m (int): '1'-երի քանակը երկբայական տողի մեջ:\n​    Վերադարձնում է:\n​    int: Տարբեր վերադասավորման սխեմաների ընդհանուր քանակը:",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\n    প্যারামিটারসমূহ:\n    - n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n    - m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\n    রিটার্নস:\n    int: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоичен низ с дължина n, където броят на '1' е m и броят на '0' е n - m.\n    Параметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1' в двоичния низ.\n    Връща:\n    int: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。  \n参数:  \n- n (int): 二进制字符串的长度。  \n- m (int): 二进制字符串中 '1' 的数量。  \n返回:  \nint: 不同排列方案的总数量。",
      "fr": "Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n​    Paramètres:\n- n (int): Longueur de la chaîne binaire.\n- m (int): Nombre de '1' dans la chaîne binaire.\n​    Renvoie:\n​    int: Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m.\n​    Parameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n​    Rückgabewert:\n​    int: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n    Sigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Yawan '1's a cikin igiyar binary.\n    Komawa:\n    int: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nParameters:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nReturns:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n    Paraméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n    Visszatér:\n    int: A különböző permutációs sémák teljes száma."
    },
    "docstring_bertscore": {
      "sq": "0.9790013920081347",
      "hy": "0.9410316056302676",
      "bn": "0.9482442720264064",
      "bg": "0.9828051638049529",
      "zh": "0.9434207318533552",
      "fr": "0.9679571455618329",
      "de": "0.9770415060384635",
      "ha": "0.9790013920081347",
      "hi": "0.9790013920081347",
      "hu": "0.9704928610061243"
    }
  },
  {
    "task_id": "C/20",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Answer a series of questions by providing choices A, B, C, or D for each question.\n​    Question 1:\n​    Constants like 1e6 belong to which data type?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2:\n​    Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n​        A. int\n​        B. long long\n​        C. double\n​        D. None of the above\n​    Question 3:\n​    Which statement about left values in expressions is incorrect?\n​        A. Variable name expressions are left values.\n​        B. Increment operation requires the operand to be a left value.\n​        C. Pointer dereference expressions are left values.\n​        D. Prefix increment operation expressions are left values.\n​    Question 4:\n​    Which statement about functions is incorrect?\n​        A. Formal parameters of a function are local variables.\n​        B. Local variables are allocated space in the stack.\n​        C. The function type is the same as the return value type.\n​        D. A function can call itself from within its body.\n​    Question 5:\n​    Which statement about pointers is incorrect?\n​        A. Subtracting two pointers equals the difference in their address values.\n​        B. Pointer dereference involves resolving based on the pointer's type.\n​        C. int *p[4], p is an array of int pointers.\n​        D. Function names can be assigned to function pointers.\n\t>>> answer_questions()\n\tAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nconst char* answer_questions()",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Përgjigju një serie pyetjesh duke ofruar zgjedhjet A, B, C, ose D për secilën pyetje.\n​    Pyetja 1:\n​    Konstantet si 1e6 i përkasin cilit lloj të dhënash?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pyetja 2:\n​    Duke dhënë 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Asnjë nga të mësipërmet\n​    Pyetja 3:\n​    Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n​        A. Shprehjet e emrave të variablave janë vlera të majta.\n​        B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n​        C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n​        D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n​    Pyetja 4:\n​    Cila deklaratë për funksionet është e pasaktë?\n​        A. Parametrat formalë të një funksioni janë variabla lokale.\n​        B. Variablat lokale alokohen hapësirë në stack.\n​        C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n​        D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n​    Pyetja 5:\n​    Cila deklaratë për treguesit është e pasaktë?\n​        A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n​        B. Dereferencimi i treguesve përfshin zgjidhjen bazuar në llojin e treguesit.\n​        C. int *p[4], p është një varg treguesish int.\n​        D. Emrat e funksioneve mund të caktohen tek treguesit e funksioneve.\n\t>>> answer_questions()\n\tAAAAA\nDuhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n*/\nconst char* answer_questions()",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\n​    Հարց 1:\n​    1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Հարց 2:\n​    Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Վերը նշվածներից ոչ մեկը\n​    Հարց 3:\n​    Որ արտահայտությունը ձախ արժեքների մասին սխալ է?\n​        A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n​        B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n​        C. Ցուցիչի ապահավաքման արտահայտությունները ձախ արժեքներ են:\n​        D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n​    Հարց 4:\n​    Որ արտահայտությունը ֆունկցիաների մասին սխալ է?\n​        A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n​        B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n​        C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n​        D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n​    Հարց 5:\n​    Որ արտահայտությունը ցուցիչների մասին սխալ է?\n​        A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n​        B. Ցուցիչի ապահավաքումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n​        C. int *p[4], p-ն int ցուցիչների զանգված է:\n​        D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\t>>> answer_questions()\n\tAAAAA\nԴուք պետք է վերադարձնեք միայն \"AAAAA\" նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:\n*/\nconst char* answer_questions()",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলোর উত্তর দিন।\n​    প্রশ্ন ১:\n​    1e6 এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    প্রশ্ন ২:\n​    21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n​        A. int\n​        B. long long\n​        C. double\n​        D. উপরোক্ত কোনোটিই নয়\n​    প্রশ্ন ৩:\n​    এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n​        A. ভেরিয়েবল নামের এক্সপ্রেশনগুলি বাম মান।\n​        B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n​        C. পয়েন্টার ডিরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n​        D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n​    প্রশ্ন ৪:\n​    ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n​        A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n​        B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n​        C. ফাংশন টাইপ এবং রিটার্ন ভ্যালু টাইপ একই।\n​        D. একটি ফাংশন তার শরীরের ভিতরে নিজেকে কল করতে পারে।\n​    প্রশ্ন ৫:\n​    পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n​        A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n​        B. পয়েন্টার ডিরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n​        C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n​        D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\t>>> answer_questions()\n\tAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের বিকল্পগুলোর জন্য দাঁড়ায়।\n*/\nconst char* answer_questions()",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n​    Въпрос 1:\n​    Константи като 1e6 принадлежат към кой тип данни?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Въпрос 2:\n​    Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Нито едно от горепосочените\n​    Въпрос 3:\n​    Кое твърдение за левите стойности в изразите е неправилно?\n​        A. Изразите с имена на променливи са леви стойности.\n​        B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n​        C. Изразите за дереференция на указатели са леви стойности.\n​        D. Изразите за префикс инкрементиране са леви стойности.\n​    Въпрос 4:\n​    Кое твърдение за функциите е неправилно?\n​        A. Формалните параметри на функцията са локални променливи.\n​        B. Локалните променливи се разпределят в стека.\n​        C. Типът на функцията е същият като типа на връщаната стойност.\n​        D. Функцията може да извика сама себе си в тялото си.\n​    Въпрос 5:\n​    Кое твърдение за указателите е неправилно?\n​        A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n​        B. Дереференцията на указател включва разрешаване на базата на типа на указателя.\n​        C. int *p[4], p е масив от указатели към int.\n​        D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\t>>> answer_questions()\n\tAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n*/\nconst char* answer_questions()",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n​    问题 1：\n​    像 1e6 这样的常量属于哪种数据类型？\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    问题 2：\n​    给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n​        A. int\n​        B. long long\n​        C. double\n​        D. 以上都不是\n​    问题 3：\n​    关于表达式中的左值，哪个说法不正确？\n​        A. 变量名表达式是左值。\n​        B. 增量操作要求操作数是左值。\n​        C. 指针解引用表达式是左值。\n​        D. 前缀增量操作表达式是左值。\n​    问题 4：\n​    关于函数，哪个说法不正确？\n​        A. 函数的形式参数是局部变量。\n​        B. 局部变量在栈中分配空间。\n​        C. 函数类型与返回值类型相同。\n​        D. 函数可以在其内部调用自身。\n​    问题 5：\n​    关于指针，哪个说法不正确？\n​        A. 两个指针相减等于它们地址值的差。\n​        B. 指针解引用涉及根据指针的类型进行解析。\n​        C. int *p[4], p 是一个 int 指针数组。\n​        D. 函数名可以赋值给函数指针。\n\t>>> answer_questions()\n\tAAAAA\n你应该只返回类似 \"AAAAA\" 的字符串，代表问题的选择。\n*/\nconst char* answer_questions()",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n​    Question 1 :\n​    Les constantes comme 1e6 appartiennent à quel type de données ?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Question 2 :\n​    Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Aucun des précédents\n​    Question 3 :\n​    Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n​        A. Les expressions de nom de variable sont des valeurs à gauche.\n​        B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n​        C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n​        D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n​    Question 4 :\n​    Quelle affirmation concernant les fonctions est incorrecte ?\n​        A. Les paramètres formels d'une fonction sont des variables locales.\n​        B. Les variables locales sont allouées dans la pile.\n​        C. Le type de la fonction est le même que le type de la valeur de retour.\n​        D. Une fonction peut s'appeler elle-même depuis son corps.\n​    Question 5 :\n​    Quelle affirmation concernant les pointeurs est incorrecte ?\n​        A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n​        B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n​        C. int *p[4], p est un tableau de pointeurs int.\n​        D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\t>>> answer_questions()\n\tAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n*/\nconst char* answer_questions()",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n​    Frage 1:\n​    Konstanten wie 1e6 gehören zu welchem Datentyp?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Frage 2:\n​    Gegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Keine der oben genannten\n​    Frage 3:\n​    Welche Aussage über linke Werte in Ausdrücken ist falsch?\n​        A. Variablennamen-Ausdrücke sind linke Werte.\n​        B. Der Inkrement-Operator erfordert, dass der Operand ein linker Wert ist.\n​        C. Pointer-Dereferenz-Ausdrücke sind linke Werte.\n​        D. Präfix-Inkrement-Operator-Ausdrücke sind linke Werte.\n​    Frage 4:\n​    Welche Aussage über Funktionen ist falsch?\n​        A. Formale Parameter einer Funktion sind lokale Variablen.\n​        B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n​        C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n​        D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n​    Frage 5:\n​    Welche Aussage über Zeiger ist falsch?\n​        A. Das Subtrahieren von zwei Zeigern ergibt die Differenz ihrer Adresswerte.\n​        B. Die Dereferenzierung eines Zeigers erfolgt basierend auf dem Typ des Zeigers.\n​        C. int *p[4], p ist ein Array von int-Zeigern.\n​        D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\t>>> answer_questions()\n\tAAAAA\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n*/\nconst char* answer_questions()",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n​    Tambaya ta 1:\n​    Kwatankwacin kamar 1e6 suna cikin wane irin bayanai?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Tambaya ta 2:\n​    An ba da 21! = 51,090,942,171,709,440,000, wane irin bayanai za a iya amfani da shi don adana wannan ƙima?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Babu ɗaya daga cikin waɗanda ke sama\n​    Tambaya ta 3:\n​    Wane bayani game da ƙimar hagu a cikin maganganu ba daidai bane?\n​        A. Maganganun sunayen canji ƙimar hagu ne.\n​        B. Aiki na ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n​        C. Maganganun cire alamar mai nuna hanya ƙimar hagu ne.\n​        D. Maganganun aiki na ƙara na farko ƙimar hagu ne.\n​    Tambaya ta 4:\n​    Wane bayani game da ayyuka ba daidai bane?\n​        A. Sigogin tsari na aiki canje-canje na gida ne.\n​        B. Canje-canje na gida ana ware musu sarari a cikin faifai.\n​        C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n​        D. Aiki na iya kiran kansa daga cikin jikinsa.\n​    Tambaya ta 5:\n​    Wane bayani game da masu nuna hanya ba daidai bane?\n​        A. Cire masu nuna hanya biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n​        B. Cire alamar mai nuna hanya yana buƙatar warwarewa bisa nau'in mai nuna hanya.\n​        C. int *p[4], p tsari ne na masu nuna hanya na int.\n​        D. Ana iya ba da sunayen ayyuka ga masu nuna hanya na aiki.\n\t>>> answer_questions()\n\tAAAAA\nAna tsammanin ku dawo da kirtani kamar \"AAAAA\", wanda ke nufin zaɓuɓɓukan tambayar.\n*/\nconst char* answer_questions()",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n​    प्रश्न 1:\n​    1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    प्रश्न 2:\n​    दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n​        A. int\n​        B. long long\n​        C. double\n​        D. उपरोक्त में से कोई नहीं\n​    प्रश्न 3:\n​    अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n​        A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n​        B. वृद्धि संचालन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n​        C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n​        D. उपसर्ग वृद्धि संचालन अभिव्यक्तियाँ बाएँ मान हैं।\n​    प्रश्न 4:\n​    कार्यों के बारे में कौन सा कथन गलत है?\n​        A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n​        B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n​        C. फ़ंक्शन प्रकार उसी प्रकार का होता है जैसे रिटर्न मान प्रकार।\n​        D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n​    प्रश्न 5:\n​    पॉइंटर्स के बारे में कौन सा कथन गलत है?\n​        A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n​        B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n​        C. int *p[4], p int पॉइंटर्स की एक सरणी है।\n​        D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\t>>> answer_questions()\n\tAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n*/\nconst char* answer_questions()",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésnél.\n​    1. kérdés:\n​    Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    2. kérdés:\n​    Tekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Egyik sem a fentiek közül\n​    3. kérdés:\n​    Melyik állítás helytelen a balértékekről a kifejezésekben?\n​        A. A változónév kifejezések balértékek.\n​        B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n​        C. A pointer dereferencia kifejezések balértékek.\n​        D. A prefix inkrementáló művelet kifejezések balértékek.\n​    4. kérdés:\n​    Melyik állítás helytelen a függvényekről?\n​        A. A függvény formális paraméterei lokális változók.\n​        B. A lokális változók helyet foglalnak a veremben.\n​        C. A függvény típusa megegyezik a visszatérési érték típusával.\n​        D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n​    5. kérdés:\n​    Melyik állítás helytelen a pointerekről?\n​        A. Két pointer kivonása egyenlő a címértékeik különbségével.\n​        B. A pointer dereferencia a pointer típusán alapuló feloldást igényel.\n​        C. int *p[4], p egy int pointerek tömbje.\n​        D. A függvénynevek hozzárendelhetők függvény pointerekhez.\n\t>>> answer_questions()\n\tAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választási lehetőségeit jelölik.\n*/\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "sq": "0.9501030551321309",
      "hy": "0.8919591754740743",
      "bn": "0.888643438523459",
      "bg": "0.8968909692047895",
      "zh": "0.9007291040575267",
      "fr": "0.962093775344064",
      "de": "0.9011380840120775",
      "ha": "0.8872792450665113",
      "hi": "0.9073967286881058",
      "hu": "0.8958930501704703"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "Write a C function `const char* answer_questions()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Shkruani një funksion C `const char* answer_questions()` për të zgjidhur problemin e mëposhtëm:\nPërgjigjuni një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë rreth treguesve është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund t'u caktohen treguesve të funksioneve.\n\n>>> answer_questions()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.",
      "hy": "Գրեք C ֆունկցիա `const char* answer_questions()` հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ տրամադրելով A, B, C կամ D ընտրանքները յուրաքանչյուր հարցի համար:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nԵթե 21! = 51,090,942,171,709,440,000, ապա որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունն է սխալ ձախ արժեքների մասին արտահայտություններում?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են։\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք։\n    C. Ցուցիչի դերեֆերենսի արտահայտությունները ձախ արժեքներ են։\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են։\n\nՀարց 4:\nՈր հայտարարությունն է սխալ ֆունկցիաների մասին?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են։\n    B. Տեղական փոփոխականները հատկացվում են կույտում։\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը։\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից։\n\nՀարց 5:\nՈր հայտարարությունն է սխալ ցուցիչների մասին?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը։\n    B. Ցուցիչի դերեֆերենսը ներառում է լուծում ցուցիչի տիպի հիման վրա։\n    C. int *p[4], p-ն int ցուցիչների զանգված է։\n    D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին։\n\n>>> answer_questions()\nAAAAA\nԴուք պետք է միայն վերադարձնեք տողեր, որոնք նման են \"AAAAA\"-ին, որոնք ներկայացնում են հարցերի ընտրանքները։",
      "bn": "C ফাংশন `const char* answer_questions()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন 2:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\n\nপ্রশ্ন 3:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের ধরনটি রিটার্ন মানের ধরন হিসাবে একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\n>>> answer_questions()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।",
      "bg": "Напишете C функция `const char* answer_questions()`, за да решите следния проблем:\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстантите като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията на инкрементиране изисква операндът да е лява стойност.\n    C. Изразите за разименуване на указател са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи се заделят в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\n>>> answer_questions()\nAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.",
      "zh": "编写一个 C 函数 `const char* answer_questions()` 来解决以下问题：\n通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n\n问题 1：\n像 1e6 这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题 3：\n关于表达式中的左值，哪个说法不正确？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题 4：\n关于函数，哪个说法不正确？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其内部调用自身。\n\n问题 5：\n关于指针，哪个说法不正确？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4], p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n>>> answer_questions()\nAAAAA\n你应该只返回类似 \"AAAAA\" 的字符串，代表问题的选择。",
      "fr": "Écrire une fonction C `const char* answer_questions()` pour résoudre le problème suivant :  \nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1 :  \nLes constantes comme 1e6 appartiennent à quel type de données ?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n\nQuestion 2 :  \nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Aucun des précédents  \n\nQuestion 3 :  \nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?  \n    A. Les expressions de noms de variables sont des valeurs à gauche.  \n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.  \n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.  \n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.  \n\nQuestion 4 :  \nQuelle affirmation concernant les fonctions est incorrecte ?  \n    A. Les paramètres formels d'une fonction sont des variables locales.  \n    B. Les variables locales sont allouées dans la pile.  \n    C. Le type de la fonction est le même que le type de la valeur de retour.  \n    D. Une fonction peut s'appeler elle-même à l'intérieur de son corps.  \n\nQuestion 5 :  \nQuelle affirmation concernant les pointeurs est incorrecte ?  \n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.  \n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.  \n    C. int *p[4], p est un tableau de pointeurs int.  \n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.  \n\n>>> answer_questions()  \nAAAAA  \nVous êtes censé uniquement retourner des chaînes similaires à \"AAAAA\", qui représentent les choix des questions.",
      "de": "Schreiben Sie eine C-Funktion `const char* answer_questions()`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngesichts 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Pointer-Dereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperator-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren zweier Zeiger entspricht der Differenz ihrer Adresswerte.\n    B. Die Dereferenzierung eines Zeigers erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\n>>> answer_questions()\nAAAAA\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Rubuta aikin C `const char* answer_questions()` don warware matsalar mai zuwa:\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 yana cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunayen canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar operand ya zama ƙimar hagu.\n    C. Maganganun cirewa mai nuna alama ƙimar hagu ne.\n    D. Maganganun aiki na ƙaruwa na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki canje-canje na gida ne.\n    B. Canje-canje na gida ana ware su a cikin faifai.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Rage masu nuna alama biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsari ne na masu nuna alama int.\n    D. Ana iya ba da sunayen ayyuka ga masu nuna alama na aiki.\n\n>>> answer_questions()\nAAAAA\nAna buƙatar ka dawo da igiyoyi kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.",
      "hi": "C फ़ंक्शन `const char* answer_questions()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1:\n1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nदिया गया है 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nफंक्शन्स के बारे में कौन सा कथन गलत है?\n    A. एक फंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फंक्शन प्रकार और रिटर्न मान प्रकार समान होते हैं।\n    D. एक फंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की array है।\n    D. फंक्शन नामों को फंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\n>>> answer_questions()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्नों के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Írj egy C függvényt `const char* answer_questions()` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nTekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferencia kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása megegyezik a címértékeik különbségével.\n    B. A pointer dereferencia a pointer típusának megfelelő feloldást igényel.\n    C. int *p[4], p egy int pointerekből álló tömb.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\n>>> answer_questions()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint az \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "instruction_bertscore": {
      "sq": "0.9532900795958357",
      "hy": "0.9462474408058626",
      "bn": "0.9456473784247563",
      "bg": "0.9332077535516844",
      "zh": "0.9462843860567351",
      "fr": "0.961501459547818",
      "de": "0.9371863200838132",
      "ha": "0.9348208308760687",
      "hi": "0.9419967506517161",
      "hu": "0.9465447904862719"
    },
    "level": "easy",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\n>>> answer_questions()\nAAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\n\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë rreth treguesve është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\n>>> answer_questions()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Պատասխանեք հարցերի շարքին՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nՏրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈր արտահայտությունը ձախ արժեքների մասին սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր արտահայտությունը ֆունկցիաների մասին սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր արտահայտությունը ցուցիչների մասին սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են նշանակվել ֆունկցիայի ցուցիչներին:\n\n>>> answer_questions()\nAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "প্রশ্নগুলোর উত্তর A, B, C, অথবা D দিয়ে দিন প্রতিটি প্রশ্নের জন্য।\n\nপ্রশ্ন ১:\nযেমন 1e6 ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ পায়।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নাম ফাংশন পয়েন্টারদের সাথে অ্যাসাইন করা যেতে পারে।\n\n>>> answer_questions()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফিরিয়ে দিতে হবে, যা প্রশ্নের বিকল্পগুলোর জন্য দাঁড়ায়।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изрази с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изрази с разименуване на указатели са леви стойности.\n    D. Изрази с префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си в рамките на своето тяло.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\n>>> answer_questions()\nAAAAA\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпросите.",
      "zh": "回答一系列问题，为每个问题提供选择 A、B、C 或 D。\n\n问题 1：\n常数如 1e6 属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题 3：\n关于表达式中的左值，哪个说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题 4：\n关于函数，哪个说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题 5：\n关于指针，哪个说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4], p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n>>> answer_questions()\nAAAAA\n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs de gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs de gauche.\n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur de gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs de gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs de gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\n>>> answer_questions()\nAAAAA\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperator-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapelspeicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\n>>> answer_questions()\nAAAAA\nDu sollst nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 na cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunan canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cire alamar mai nuna ƙimar hagu ne.\n    D. Maganganun aiki na ƙaruwa na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogi na yau da kullun na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin tsari.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Rage masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire alamar mai nuna yana da alaƙa da nau'in mai nuna.\n    C. int *p[4], p jerin masu nuna int ne.\n    D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka.\n\n>>> answer_questions()\nAAAAA\nDole ne ka mayar da igiyoyi makamantan \"AAAAA\", waɗanda ke wakiltar zaɓuɓɓukan tambayoyin.",
      "hi": "प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nकार्य के बारे में कौन सा कथन गलत है?\n    A. एक कार्य के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. कार्य प्रकार वही होता है जो वापसी मूल्य प्रकार होता है।\n    D. एक कार्य अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने का मतलब उनके पते के मूल्यों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p int पॉइंटर्स की एक सरणी है।\n    D. कार्य नामों को कार्य पॉइंटर्स को सौंपा जा सकता है।\n\n>>> answer_questions()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszoljon egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nKérdés 2:\nAdott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\nKérdés 3:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A mutató dereferálási kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\nKérdés 4:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. Egy függvény formális paraméterei lokális változók.\n    B. A lokális változók számára a veremben van hely fenntartva.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\n\nKérdés 5:\nMelyik állítás helytelen a mutatókkal kapcsolatban?\n    A. Két mutató kivonása egyenlő a címértékeik különbségével.\n    B. A mutató dereferálása a mutató típusának megfelelően történik.\n    C. int *p[4], p egy int mutatók tömbje.\n    D. A függvénynevek hozzárendelhetők függvénymutatókhoz.\n\n>>> answer_questions()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnia, mint például \"AAAAA\", amelyek a kérdés választási lehetőségeit jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9713857045688761",
      "hy": "0.9165943084819264",
      "bn": "0.9288039193737598",
      "bg": "0.925269291743244",
      "zh": "0.9438454036080078",
      "fr": "0.9580540306545765",
      "de": "0.9388140960563941",
      "ha": "0.9153338000838789",
      "hi": "0.9445312743137213",
      "hu": "0.9308138601994519"
    }
  },
  {
    "task_id": "C/21",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nThe task is to determine if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetyra është të përcaktohet nëse është e mundur të mblidhen katrorët prej druri nga n kovë,\nku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nInput: gjatësia e listës, vargu i numrave\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԽնդիրը հետևյալն է՝ որոշել, արդյոք հնարավոր է n դույլերից հավաքել փայտե քառակուսիներ,\nորտեղ յուրաքանչյուր դույլում կա $a_i$ քառակուսի կողքի երկարությունը 1, մեկ մեծ քառակուսի մեջ:\nՄուտքագրում՝ ցուցակի երկարություն, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nকাজটি হল nটি বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা তা নির্ধারণ করা,\nযেখানে প্রতিটি বালতিতে $a_i$ সংখ্যা 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nЗадачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n任务是确定是否可以从 n 个桶中组装木制正方形，\n其中每个桶包含 $a_i$ 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表长度，数字数组\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDie Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern,\nwobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Array von Zahlen\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAikin shi ne a tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowace guga tana dauke da $a_i$ murabba'ai tare da tsayin gefe 1, zuwa murabba'i mafi girma.\nShigarwa: tsawon jerin, jeri na lambobi\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nकार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nA feladat annak meghatározása, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani,\nahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])"
    },
    "prompt_bertscore": {
      "sq": "0.9941835065521554",
      "hy": "0.9714967389518746",
      "bn": "0.9785185215518389",
      "bg": "0.9821264437929567",
      "zh": "0.9797937285980829",
      "fr": "0.9939161500592824",
      "de": "0.9937645950785527",
      "ha": "0.9708593340591336",
      "hi": "0.9847088373767912",
      "hu": "0.985840434657547"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}",
    "instruction": {
      "en": "Write a C function `int Is_Square(int length, int squares[])` to solve the following problem:\nThe task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n",
      "sq": "Shkruani një funksion në C `int Is_Square(int length, int squares[])` për të zgjidhur problemin e mëposhtëm:  \nDetyra është të përcaktohet nëse është e mundur të montohet katrorët prej druri nga k kovë, ku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.  \nHyrja: gjatësia e listës, vargu i numrave  \n    >>> Is_Square(1, (int[]){9})  \n    1  ",
      "hy": "Գրեք C ֆունկցիա `int Is_Square(int length, int squares[])` հետևյալ խնդիրը լուծելու համար:\nԽնդիրը որոշելն է, թե արդյոք հնարավոր է n դույլերից, որտեղ յուրաքանչյուր դույլում կա $a_i$ քառակուսի 1 կողմի երկարությամբ, հավաքել մեկ մեծ քառակուսի:\nՄուտքագրում: ցուցակի երկարություն, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1",
      "bn": "একটি C ফাংশন `int Is_Square(int length, int squares[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nকাজটি হল n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা তা নির্ধারণ করা, যেখানে প্রতিটি বালতিতে $a_i$ বর্গক্ষেত্র রয়েছে যাদের পার্শ্ব দৈর্ঘ্য 1, একটি একক বড় বর্গক্ষেত্রে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1",
      "bg": "Напишете C функция `int Is_Square(int length, int squares[])`, за да решите следния проблем:\nЗадачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1",
      "zh": "编写一个 C 函数 `int Is_Square(int length, int squares[])` 来解决以下问题：  \n任务是确定是否可以将 n 个桶中的木块组装成一个更大的正方形，其中每个桶包含 $a_i$ 个边长为 1 的正方形。  \n输入：列表长度，数字数组  \n    >>> Is_Square(1, (int[]){9})  \n    1  ",
      "fr": "Écrire une fonction C `int Is_Square(int length, int squares[])` pour résoudre le problème suivant :  \nLa tâche consiste à déterminer s'il est possible d'assembler les carrés en bois provenant de n seaux, où chaque seau contient $a_i$ carrés avec une longueur de côté de 1, en un seul carré plus grand.  \nEntrée : longueur de la liste, tableau de nombres  \n    >>> Is_Square(1, (int[]){9})  \n    1  ",
      "de": "Schreiben Sie eine C-Funktion `int Is_Square(int length, int squares[])`, um das folgende Problem zu lösen:  \nDie Aufgabe besteht darin, festzustellen, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.  \nEingabe: Länge der Liste, Array von Zahlen  \n    >>> Is_Square(1, (int[]){9})  \n    1  ",
      "ha": "Rubuta aikin C `int Is_Square(int length, int squares[])` don warware matsalar mai zuwa:  \nAikin shi ne a tantance ko yana yiwuwa a tara katakon murabba'i daga kwanduna n, inda kowanne kwando ke dauke da $a_i$ murabba'i da tsawon gefe 1, cikin murabba'i guda mafi girma.  \nShigarwa: tsawon jerin, jerin lambobi  \n    >>> Is_Square(1, (int[]){9})  \n    1  ",
      "hi": "C फ़ंक्शन `int Is_Square(int length, int squares[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकार्य यह निर्धारित करना है कि क्या यह संभव है कि n बाल्टियों से लकड़ी के वर्गों को, जहाँ प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में इकट्ठा किया जा सके।\nइनपुट: सूची की लंबाई, संख्याओं की array\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hu": "Írj egy C függvényt `int Is_Square(int length, int squares[])` a következő probléma megoldására:\nA feladat annak meghatározása, hogy lehetséges-e az n vödörből származó fa négyzetekből, ahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetet összeállítani.\nBemenet: lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1"
    },
    "instruction_bertscore": {
      "sq": "0.9825803142136214",
      "hy": "0.9067781936815632",
      "bn": "0.9772413282017846",
      "bg": "0.943670410242316",
      "zh": "0.958586558706131",
      "fr": "0.9968125782755332",
      "de": "0.9952988161416663",
      "ha": "0.9632857562606544",
      "hi": "0.9702878744528962",
      "hu": "0.9642997643558375"
    },
    "level": "easy",
    "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "int Is_Square(int length, int squares[])",
    "docstring": {
      "en": "The task is to determine if it is possible to assemble the wooden squares from n buckets, where each bucket contains $a_i$ squares with a side length of 1, into a single larger square.\nInput: length of list, array of numbers\n    >>> Is_Square(1, (int[]){9})\n    1\n",
      "sq": "Detyra është të përcaktohet nëse është e mundur të montohen katrorët prej druri nga n kovë, ku secila kovë përmban $a_i$ katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nInput: gjatësia e listës, vargu i numrave\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hy": "Առաջադրանքը որոշելն է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է $a_i$ կողմի երկարությամբ 1 քառակուսի, մեկ մեծ քառակուսու մեջ:\nՄուտքագրում: ցուցակի երկարություն, թվերի զանգված\n    >>> Is_Square(1, (int[]){9})\n    1",
      "bn": "কাজটি হল নির্ধারণ করা সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে $a_i$ সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\nInput: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n    >>> Is_Square(1, (int[]){9})\n    1",
      "bg": "Задачата е да се определи дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа $a_i$ квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\n    >>> Is_Square(1, (int[]){9})\n    1",
      "zh": "任务是确定是否可以从 n 个桶中组装木方块，其中每个桶包含 $a_i$ 个边长为 1 的方块，组装成一个更大的方块。\n输入：列表长度，数字数组\n    >>> Is_Square(1, (int[]){9})\n    1",
      "fr": "La tâche consiste à déterminer s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient $a_i$ carrés avec un côté de longueur 1, en un seul carré plus grand.\nEntrée : longueur de la liste, tableau de nombres\n    >>> Is_Square(1, (int[]){9})\n    1",
      "de": "Die Aufgabe besteht darin, zu bestimmen, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer $a_i$ Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nEingabe: Länge der Liste, Array von Zahlen\n    >>> Is_Square(1, (int[]){9})\n    1",
      "ha": "Aikin shine a tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n, inda kowanne guga yana dauke da $a_i$ murabba'ai masu tsawon gefe 1, cikin babban murabba'i guda.\nShigarwa: tsawon jerin, jerin lambobi\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hi": "कार्य यह निर्धारित करना है कि क्या n बाल्टियों से लकड़ी के वर्गों को एकत्र करना संभव है, जहाँ प्रत्येक बाल्टी में $a_i$ वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\n\nइनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n    >>> Is_Square(1, (int[]){9})\n    1",
      "hu": "A feladat annak meghatározása, hogy lehetséges-e az n vödörből származó fa négyzeteket, ahol minden vödör $a_i$ darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté összeállítani.\nBemenet: lista hossza, számok tömbje\n    >>> Is_Square(1, (int[]){9})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9844261863445786",
      "hy": "0.9416225310138464",
      "bn": "0.9989476562412771",
      "bg": "0.9840332954508916",
      "zh": "0.9493623624412518",
      "fr": "0.981889875009144",
      "de": "0.9934644645728091",
      "ha": "0.9490803073001822",
      "hi": "0.9335170210549557",
      "hu": "0.9800016946070265"
    }
  },
  {
    "task_id": "C/22",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me a më të vogël.\n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, արտածել խումբը ամենափոքր a-ով:\n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չեն գոյություն ունենում,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    প্যারামিটার:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্নস:\n    Optional[int]: a এর একটি সম্ভাব্য মান। যদি বৈধ মান বিদ্যমান না থাকে, তাহলে -1 ফেরত দেয়।\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个组合，输出 a 最小的组合。\n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的一个可能值。如果不存在有效值，则返回 -1。\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donné des entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il existe plusieurs groupes, afficher le groupe avec le plus petit a.\n    Paramètres:\n    - c (int): La somme de a et b.\n    - d (int): Le produit de a et b.\n\n    Renvoie:\n    Optional[int]: Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabewert:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar da ke da ƙaramin a.\n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Returns:\n    Optional[int]: Yiwuwar ƙimar a. Yana dawowa -1 idan ƙimomi masu inganci ba su wanzu,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं, तो -1 लौटाता है।\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdott két egész szám, c és d, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értékét (a <= b). Ha több csoport is van, adja vissza a legkisebb a értékkel rendelkező csoportot.\n    Paraméterek:\n    - c (int): Az a és b összege.\n    - d (int): Az a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: Egy lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9746893250662484",
      "hy": "0.9499584522147375",
      "bn": "0.9756467235028365",
      "bg": "0.9665476643780093",
      "zh": "0.9494678351735814",
      "fr": "0.9962623721200665",
      "de": "0.9844613439220218",
      "ha": "0.9828856091092719",
      "hi": "0.976412840882488",
      "hu": "0.9693431883606943"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a C function `int find_integers(int c, int d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n",
      "sq": "Shkruani një funksion në C `int find_integers(int c, int d)` për të zgjidhur problemin në vijim:\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka disa grupe, jepni grupin me vlerën më të vogël të a.\n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\n    >>> find_integers(7,11)\n    -1",
      "hy": "Գրեք C ֆունկցիա `int find_integers(int c, int d)` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, արտածել այն խումբը, որտեղ a-ն ամենափոքրն է:\n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեքը: Վերադարձնում է -1, եթե վավեր արժեքներ չկան,\n\n    >>> find_integers(7,11)\n    -1",
      "bn": "একটি C ফাংশন `int find_integers(int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তবে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    প্যারামিটারসমূহ:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্নস:\n    Optional[int]: a এর একটি সম্ভাব্য মান। যদি বৈধ মান বিদ্যমান না থাকে তবে -1 ফেরত দেয়,\n\n    >>> find_integers(7,11)\n    -1",
      "bg": "Напишете C функция `int find_integers(int c, int d)`, за да решите следния проблем:\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности,\n\n    >>> find_integers(7,11)\n    -1",
      "zh": "编写一个 C 函数 `int find_integers(int c, int d)` 来解决以下问题：  \n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回可能的 a 的值 (a <= b)。如果有多个组合，输出 a 最小的组合。  \n参数:  \n- c (int): a 和 b 的和。  \n- d (int): a 和 b 的积。  \n\n返回:  \nOptional[int]: a 的可能值。如果不存在有效值，则返回 -1。  \n\n    >>> find_integers(7,11)\n    -1  ",
      "fr": "Écrire une fonction C `int find_integers(int c, int d)` pour résoudre le problème suivant :  \nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.  \n    Paramètres :  \n    - c (int) : La somme de a et b.  \n    - d (int) : Le produit de a et b.  \n\n    Renvoie :  \n    Optional[int] : Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,  \n\n    >>> find_integers(7,11)  \n    -1  ",
      "de": "Schreiben Sie eine C-Funktion `int find_integers(int c, int d)`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    Parameter:\n    - c (int): Die Summe von a und b.\n    - d (int): Das Produkt von a und b.\n\n    Rückgabewert:\n    Optional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren,\n\n    >>> find_integers(7,11)\n    -1",
      "ha": "Rubuta aikin C `int find_integers(int c, int d)` don warware matsalar mai zuwa:\nAn ba da lambobin c da d, inda a + b = c da a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar tare da mafi ƙarancin a.\n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Returns:\n    Optional[int]: Iwuwar ƙimar a. Yana dawowa -1 idan ƙimomin da suka dace ba su wanzu,\n\n    >>> find_integers(7,11)\n    -1",
      "hi": "C फ़ंक्शन `int find_integers(int c, int d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं तो -1 लौटाता है,\n\n    >>> find_integers(7,11)\n    -1",
      "hu": "Írj egy C függvényt `int find_integers(int c, int d)` a következő probléma megoldására:\nAdott c és d egész számok, ahol a + b = c és a * b = d, találd meg és add vissza a lehetséges a értéket (a <= b). Ha több csoport van, add vissza azt a csoportot, amelyikben a legkisebb a.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\nOpcionális[int]: a lehetséges a érték. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> find_integers(7,11)\n    -1"
    },
    "instruction_bertscore": {
      "sq": "0.9711278823342928",
      "hy": "0.9723840208639575",
      "bn": "0.9897985422604292",
      "bg": "0.9829692324996877",
      "zh": "0.9682374130294731",
      "fr": "0.9831603149262432",
      "de": "0.9871768198611497",
      "ha": "0.9777341301771322",
      "hi": "0.9687411396757776",
      "hu": "0.9635292771078031"
    },
    "level": "easy",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n    Parameters:\n    - c (int): The sum of a and b.\n    - d (int): The product of a and b.\n\n    Returns:\n    Optional[int]: A possible value of a. Returns -1 if valid values do not exist,\n\n    >>> find_integers(7,11)\n    -1\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n    \n    Parametrat:\n    - c (int): Shuma e a dhe b.\n    - d (int): Produkti i a dhe b.\n\n    Kthen:\n    Optional[int]: Një vlerë e mundshme e a. Kthen -1 nëse vlerat e vlefshme nuk ekzistojnë,\n\n    >>> find_integers(7,11)\n    -1",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n    \n    Պարամետրեր:\n    - c (int): a-ի և b-ի գումարը:\n    - d (int): a-ի և b-ի արտադրյալը:\n\n    Վերադարձնում է:\n    Optional[int]: a-ի հնարավոր արժեք: Վերադարձնում է -1, եթե վավեր արժեքներ չկան,\n\n    >>> find_integers(7,11)\n    -1",
      "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n    \n    প্যারামিটারসমূহ:\n    - c (int): a এবং b এর যোগফল।\n    - d (int): a এবং b এর গুণফল।\n\n    রিটার্নস:\n    Optional[int]: a এর একটি সম্ভাব্য মান। যদি বৈধ মান বিদ্যমান না থাকে, তাহলে -1 ফেরত দেয়,\n\n    >>> find_integers(7,11)\n    -1",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има няколко групи, изведете групата с най-малката a.\n    Параметри:\n    - c (int): Сумата на a и b.\n    - d (int): Произведението на a и b.\n\n    Връща:\n    Optional[int]: Възможна стойност на a. Връща -1, ако не съществуват валидни стойности.\n\n    >>> find_integers(7,11)\n    -1",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找出并返回可能的 a 的值（a <= b）。如果有多个组合，输出 a 最小的组合。\n    参数:\n    - c (int): a 和 b 的和。\n    - d (int): a 和 b 的积。\n\n    返回:\n    Optional[int]: a 的一个可能值。如果不存在有效值，则返回 -1。\n\n    >>> find_integers(7,11)\n    -1",
      "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, sortir le groupe avec le plus petit a.\n    Paramètres:\n    - c (int): La somme de a et b.\n    - d (int): Le produit de a et b.\n\n    Renvoie:\n    Optional[int]: Une valeur possible de a. Renvoie -1 si des valeurs valides n'existent pas,\n\n    >>> find_integers(7,11)\n    -1",
      "de": "Gegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n    \nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabe:\nOptional[int]: Ein möglicher Wert von a. Gibt -1 zurück, wenn keine gültigen Werte existieren.\n\n>>> find_integers(7,11)\n-1",
      "ha": "An ba da lambobin c da d, inda a + b = c da a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai rukuni da yawa, fitar da rukuni tare da ƙaramin a.\n    \n    Sigogi:\n    - c (int): Jimillar a da b.\n    - d (int): Samfurin a da b.\n\n    Komawa:\n    Optional[int]: Iwuwar ƙimar a. Yana dawowa -1 idan ba a sami ingantattun ƙima ba,\n\n    >>> find_integers(7,11)\n    -1",
      "hi": "दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n\n    पैरामीटर्स:\n    - c (int): a और b का योग।\n    - d (int): a और b का गुणनफल।\n\n    रिटर्न्स:\n    Optional[int]: a का एक संभावित मान। यदि मान्य मान मौजूद नहीं हैं, तो -1 लौटाता है।\n\n    >>> find_integers(7,11)\n    -1",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értékét (a <= b). Ha több csoport van, adja vissza azt a csoportot, amelyikben a legkisebb a.\n    Paraméterek:\n    - c (int): a és b összege.\n    - d (int): a és b szorzata.\n\n    Visszatérési érték:\n    Optional[int]: a lehetséges a értéke. -1-et ad vissza, ha nem léteznek érvényes értékek.\n\n    >>> find_integers(7,11)\n    -1"
    },
    "docstring_bertscore": {
      "sq": "0.9671507062148312",
      "hy": "0.9663903491162297",
      "bn": "0.9900756316419729",
      "bg": "0.9866953398175211",
      "zh": "0.9600963482323772",
      "fr": "1",
      "de": "0.9835685003592699",
      "ha": "0.9722972193874452",
      "hi": "0.9722860960861073",
      "hu": "0.9774927942641748"
    }
  },
  {
    "task_id": "C/23",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n    \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n    \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n    \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar i argumenteve të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n    \nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n    \nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nՀաշվել սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողեր տրված կողերի հավաքածուից։\n    \nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը։\n- Կողերի երկարությունները ներկայացնող ամբողջ թվային կամայական քանակի արգումենտներ։\n    \nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել։\n    \nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ তৈরি করা যেতে পারে তা গণনা করুন।\n    \nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য প্রতিনিধিত্বকারী একটি স্বেচ্ছামূলক সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n    \nফেরত দেয়:\nint: গঠিত পৃথক তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n    \nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n    \nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n    \nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n    \nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n    \n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n    \n返回：\nint: 可以形成的不同锐角三角形的数量。\n    \n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n    \nArguments:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n    \nRenvoie:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n    \nExemples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Yawan gefuna da aka gabatar.\n- Adadin hujjoji na lamba masu zaman kansu waɗanda ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi masu bambanci waɗanda za a iya samarwa.\n\nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्रकोण त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले कई पूर्णांक तर्क।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्रकोण त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nSzámolja meg a hegyesszögű háromszögek számát, amelyek úgy képezhetők, hogy bármely 3 élt kiválasztunk a megadott élek halmazából.\n    \nArgok:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n    \nVisszatér:\nint: Az elkülöníthető hegyesszögű háromszögek száma, amelyek képezhetők.\n    \nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9707175119670747",
      "hy": "0.9463586738192422",
      "bn": "0.969517585835243",
      "bg": "0.975751600344023",
      "zh": "0.9605637255189523",
      "fr": "0.9718651983086943",
      "de": "0.9724257332439747",
      "ha": "0.9511496386098037",
      "hi": "0.9794723446415684",
      "hu": "0.9695938599015603"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "en": "Write a C function `int count_acute_triangles(int edges_count, ...)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "sq": "Shkruani një funksion në C `int count_acute_triangles(int edges_count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hy": "Գրեք C ֆունկցիա `int count_acute_triangles(int edges_count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել տրված կողերից ցանկացած 3-ը ընտրելով:\n\nԱրգումենտներ:\n- edges_count: Անցկացվող կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bn": "একটি C ফাংশন `int count_acute_triangles(int edges_count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges_count: পাস করা প্রান্তগুলির সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী একটি নির্বিচারে সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bg": "Напишете C функция `int count_acute_triangles(int edges_count, ...)`, за да решите следния проблем:  \nПребройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "zh": "编写一个 C 函数 `int count_acute_triangles(int edges_count, ...)` 来解决以下问题：  \n计算可以通过从给定的边集中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "fr": "Écrire une fonction C `int count_acute_triangles(int edges_count, ...)` pour résoudre le problème suivant :  \nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArgs:  \n- edges_count: Le nombre de côtés passés.  \n- Un nombre arbitraire d'arguments entiers représentant les longueurs des côtés.\n\nRetourne :  \nint : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :  \n>>> count_acute_triangles(4, 1, 1, 1, 1)  \n4  ",
      "de": "Schreiben Sie eine C-Funktion `int count_acute_triangles(int edges_count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie 3 Kanten aus einer gegebenen Menge von Kanten auswählen.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "ha": "Rubuta aikin C `int count_acute_triangles(int edges_count, ...)` don warware matsalar mai zuwa:\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Yawan gefuna da aka gabatar.\n- Yawan hujjojin lamba masu zaman kansu waɗanda ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hi": "एक C फ़ंक्शन `int count_acute_triangles(int edges_count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्रकोण त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: विशिष्ट तीव्रकोण त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hu": "Írj egy C függvényt `int count_acute_triangles(int edges_count, ...)` a következő probléma megoldására:\nSzámold meg a hegyesszögű háromszögek számát, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész számú argumentum, amelyek az élek hosszát képviselik.\n\nVisszatér:\nint: Azoknak a különböző hegyesszögű háromszögeknek a száma, amelyek kialakíthatók.\n\nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9767908344975974",
      "hy": "0.9405105981408131",
      "bn": "0.9721041506570792",
      "bg": "0.9541275052822787",
      "zh": "0.9464013793511648",
      "fr": "0.962293200246623",
      "de": "0.9581273252651783",
      "ha": "0.9636415032730878",
      "hi": "0.9893085211104161",
      "hu": "0.962686289770691"
    },
    "level": "hard",
    "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "sq": "Numëroni numrin e trekëndëshave këndakut që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgs:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nReturns:\nint: Numri i trekëndëshave të ndryshëm këndakut që mund të formohen.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hy": "Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել՝ ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n\nԱրգումենտներ:\n- edges_count: Փոխանցված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակով արգումենտներ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել:\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bn": "প্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলো তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গস:\n- edges_count: প্রেরিত প্রান্তগুলির সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী যেকোনো সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bg": "Бройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgs:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nReturns:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "ha": "Count adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Adadin gefuna da aka bayar.\n- Yawan hujjojin lamba masu zaman kansu da ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: A képezhető különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9366297577561534",
      "hy": "0.9035075458274427",
      "bn": "0.9484816353317431",
      "bg": "0.9407402148612893",
      "zh": "0.9346269676241786",
      "fr": "0.9632996603873268",
      "de": "0.9469674759371142",
      "ha": "0.942668518600376",
      "hi": "0.9855001808148341",
      "hu": "0.9713036702215087"
    }
  },
  {
    "task_id": "C/24",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nԿարդում է ամբողջ թիվ և սիմվոլ, այնուհետև վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 包含整数和字符并用逗号分隔的字符串。\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "fr": "/*\nLit un entier et un caractère, puis les retourne sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRetourne :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/",
      "de": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLiest eine Ganzzahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (char): Das Eingabezeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nKaranta lamba mai cikakken adadi da wata alama, sannan ya mayar da su a matsayin jeren rubutu da aka raba da alamar koma.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Harafin da aka shigar.\nMayarwa:\n- char*: Jeren rubutu da ke dauke da lambar da harafin da aka raba da alamar koma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\nरिटर्न्स:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "sq": "0.9776526917209079",
      "hy": "0.9951069391935866",
      "bn": "0.9892036442692297",
      "bg": "1",
      "zh": "0.9964220709464185",
      "fr": "0.8442942401978942",
      "de": "0.981820950266925",
      "ha": "0.9829821434744549",
      "hi": "0.9842221929432557",
      "hu": "0.9791364606672385"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "en": "Write a C function `char* process_integer_and_char(int integer_value, char char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n",
      "sq": "Shkruani një funksion në C `char* process_integer_and_char(int integer_value, char char_value)` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hy": "Գրեք C ֆունկցիա `char* process_integer_and_char(int integer_value, char char_value)` հետևյալ խնդիրը լուծելու համար:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n",
      "bn": "একটি C ফাংশন `char* process_integer_and_char(int integer_value, char char_value)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি ফরম্যাট করা স্ট্রিং হিসেবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n>>> process_integer_and_char(234,H)\n\t234,H",
      "bg": "Напишете C функция `char* process_integer_and_char(int integer_value, char char_value)`, за да решите следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.",
      "zh": "编写一个 C 函数 `char* process_integer_and_char(int integer_value, char char_value)` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为一个用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。",
      "fr": "Écrire une fonction C `char* process_integer_and_char(int integer_value, char char_value)` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "de": "Schreiben Sie eine C-Funktion `char* process_integer_and_char(int integer_value, char char_value)`, um das folgende Problem zu lösen:\nLiest eine Ganzzahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (char): Das Eingabezeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.",
      "ha": "Rubuta aikin C `char* process_integer_and_char(int integer_value, char char_value)` don warware matsalar mai zuwa:\nKaranta lamba da harafi, sannan ya mayar da su a matsayin jeren haruffa da aka tsara wanda aka raba da alamar rubutu.\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Harafin shigarwa.\nMayarwa:\n- char*: Jeren haruffa da ke dauke da lamba da harafi da aka raba da alamar rubutu.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hi": "C फ़ंक्शन `char* process_integer_and_char(int integer_value, char char_value)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक और एक अक्षर पढ़ता है, फिर उन्हें एक फॉर्मेटेड स्ट्रिंग के रूप में लौटाता है जो अल्पविराम द्वारा अलग होता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट अक्षर।\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम से अलग होते हैं।\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hu": "Írj egy C függvényt `char* process_integer_and_char(int integer_value, char char_value)` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva."
    },
    "instruction_bertscore": {
      "sq": "0.973958563894421",
      "hy": "0.9459568445584087",
      "bn": "0.9894791446077251",
      "bg": "0.946027358343676",
      "zh": "0.9363230724478355",
      "fr": "0.9971583937689149",
      "de": "0.9370099363054541",
      "ha": "0.9871233882886513",
      "hi": "0.9644419837086584",
      "hu": "0.9340849053143344"
    },
    "level": "middle",
    "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n>>> process_integer_and_char(234,H)\n\t234,H\n",
      "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, այնուհետև վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։  \nՊարամետրեր:  \n- integer_value (int): Մուտքային ամբողջ թիվը։  \n- char_value (char): Մուտքային սիմվոլը։  \nՎերադարձնում է:  \n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։  \n>>> process_integer_and_char(234,H)  \n\t234,H",
      "bn": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \nপ্যারামিটারসমূহ:  \n- integer_value (int): ইনপুট পূর্ণসংখ্যা।  \n- char_value (char): ইনপুট অক্ষর।  \nরিটার্নস:  \n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।  \n>>> process_integer_and_char(234,H)  \n\t234,H  ",
      "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n返回：\n- char*: 包含整数和字符并用逗号分隔的字符串。\n>>> process_integer_and_char(234,H)\n\t234,H",
      "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "de": "Liest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\nRückgabewert:\n- char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "ha": "Karanta wata lamba kuma wata alama, sannan ya mayar da su a matsayin jeren rubutu da aka tsara wanda aka raba da alama.\nSigogi:\n- integer_value (int): Lambar da aka shigar.\n- char_value (char): Alamar da aka shigar.\nDawowa:\n- char*: Jeren rubutu wanda ke dauke da lambar da alama da aka raba da alama.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "hi": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \nपैरामीटर्स:  \n- integer_value (int): इनपुट पूर्णांक।  \n- char_value (char): इनपुट वर्ण।  \nरिटर्न्स:  \n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।  \n>>> process_integer_and_char(234,H)  \n\t234,H  ",
      "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n>>> process_integer_and_char(234,H)\n\t234,H"
    },
    "docstring_bertscore": {
      "sq": "0.9727089801673305",
      "hy": "0.9879556495851874",
      "bn": "0.9753454012148066",
      "bg": "0.9879556495851874",
      "zh": "0.9915073594284723",
      "fr": "0.9958883511125778",
      "de": "0.9854842903843514",
      "ha": "0.9292025705484969",
      "hi": "0.9729548845790517",
      "hu": "0.9827864925491355"
    }
  },
  {
    "task_id": "C/25",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n​\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti hyrës që do të përpunohet.\n​\n​    Kthen:\n​    str: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի:\n​\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫টি অবস্থান দ্বারা স্থানান্তরিত হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয় এবং সমস্ত অক্ষর বড় হাতের অক্ষরে থাকে।\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n​\n​    রিটার্নস:\n​    str: রূপান্তরিত টেক্সট যা অক্ষরগুলি ৫টি অবস্থান দ্বারা স্থানান্তরিত।\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nИзместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст за обработка.\n​\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n将所有字符在字母表中向后移动5个位置。仅替换字母，且所有字母均为大写。\n    参数：\n    text (str): 要处理的输入文本。\n​\n    返回：\n    str: 字符被移动5个位置后的转换文本。\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres:\n​    text (str): Le texte d'entrée à traiter.\n​\n​    Renvoie:\n​    str: Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n​\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigar da za a sarrafa.\n​\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n​    पैरामीटर्स:\n​    text (str): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n​\n​    रिटर्न्स:\n​    str: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nMinden karaktert 5 pozícióval eltol az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n​    Paraméterek:\n​    text (str): A feldolgozandó bemeneti szöveg.\n​\n​    Visszatér:\n​    str: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolva.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)"
    },
    "prompt_bertscore": {
      "sq": "0.9665162807778058",
      "hy": "0.9581138183992679",
      "bn": "0.9597827108607231",
      "bg": "0.9688291329345761",
      "zh": "0.9535800799521467",
      "fr": "0.968544495598553",
      "de": "0.9711870741878412",
      "ha": "0.950604398213863",
      "hi": "0.958711497215802",
      "hu": "0.9612903154527779"
    },
    "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "en": "Write a C function `char* shift_characters(char* text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n",
      "sq": "Shkruani një funksion në C `char* shift_characters(char* text)` për të zgjidhur problemin e mëposhtëm:\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen dhe të gjitha shkronjat janë me shkronja të mëdha.\n​    Parametrat:\n​    text (str): Teksti hyrës që do të përpunohet.\n\n​    Kthen:\n​    str: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hy": "Գրեք C ֆունկցիա `char* shift_characters(char* text)`՝ լուծելու հետևյալ խնդիրը:\nՏեղաշարժում է բոլոր տառերը 5 դիրքով այբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n​    Պարամետրեր:\n​    text (str): Մուտքային տեքստը, որը պետք է մշակվի:\n\n​    Վերադարձնում է:\n​    str: Փոխակերպված տեքստը՝ տառերը տեղաշարժված 5 դիրքով:\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "bn": "একটি C ফাংশন `char* shift_characters(char* text)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসব অক্ষর বর্ণানুক্রমিক ক্রমে ৫ অবস্থান সরানো হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n​    প্যারামিটার:\n​    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n​    রিটার্নস:\n​    str: ৫ অবস্থান সরানো অক্ষরসহ রূপান্তরিত টেক্সট।\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "bg": "Напишете C функция `char* shift_characters(char* text)`, за да решите следния проблем:  \nПремества всички знаци с 5 позиции в азбучен ред. Само букви се заменят и всички букви са с главни букви.\n\n​    Параметри:  \n​    text (str): Входният текст, който ще бъде обработен.\n\n​    Връща:  \n​    str: Преобразуваният текст със знаци, преместени с 5 позиции.  \n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "zh": "编写一个 C 函数 `char* shift_characters(char* text)` 来解决以下问题：\n将所有字符在字母表中移动 5 个位置。只有字母被替换，并且所有字母都是大写。\n​    参数：\n​    text (str): 要处理的输入文本。\n\n​    返回：\n​    str: 字符移动了 5 个位置后的转换文本。\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "fr": "Écrire une fonction C `char* shift_characters(char* text)` pour résoudre le problème suivant :  \nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.  \n​    Paramètres :  \n​    text (str) : Le texte d'entrée à traiter.\n\n​    Renvoie :  \n​    str : Le texte transformé avec les caractères décalés de 5 positions.  \n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "de": "Schreiben Sie eine C-Funktion `char* shift_characters(char* text)`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der zu verarbeitende Eingabetext.\n\n​    Rückgabe:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "ha": "Rubuta aikin C `char* shift_characters(char* text)` don warware matsalar mai zuwa:\nCanza duk haruffa da matsayi 5 a cikin tsari na haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigar da za a sarrafa.\n\n​    Returns:\n​    str: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hi": "C फ़ंक्शन `char* shift_characters(char* text)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी अक्षरों को वर्णमाला क्रम में 5 स्थानों से शिफ्ट करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n​    पैरामीटर्स:\n​    text (str): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\n​    रिटर्न्स:\n​    str: परिवर्तित टेक्स्ट जिसमें अक्षरों को 5 स्थानों से शिफ्ट किया गया है।\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hu": "Írj egy C függvényt `char* shift_characters(char* text)` a következő probléma megoldására:  \nEltolja az összes karaktert 5 pozícióval az ábécé sorrendjében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.  \n​    Paraméterek:  \n​    text (str): A feldolgozandó bemeneti szöveg.  \n\n​    Visszatér:  \n​    str: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.  \n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"
    },
    "instruction_bertscore": {
      "sq": "0.9663861778782279",
      "hy": "0.9688658795550675",
      "bn": "0.9594964844816518",
      "bg": "0.9928765186449459",
      "zh": "0.9622449330640316",
      "fr": "0.9950576788590899",
      "de": "0.9970612635125888",
      "ha": "0.9775045134566558",
      "hi": "0.9375931151041726",
      "hu": "0.9824083003036451"
    },
    "level": "easy",
    "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}",
    "entry_point": "shift_characters",
    "signature": "char* shift_characters(char* text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n​    Parameters:\n​    text (str): The input text to be processed.\n\n​    Returns:\n​    str: The transformed text with characters shifted by 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n    Parametrat:\n    text (str): Teksti hyrës që do të përpunohet.\n\n    Kthen:\n    str: Teksti i transformuar me karakteret e zhvendosura me 5 pozicione.\n    >>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hy": "Տեղաշարժում է բոլոր տառերը 5 դիրքով այբբենական կարգով։ Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n\nՓոփոխականներ:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի։\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը՝ տառերը 5 դիրքով տեղաշարժված։\n    >>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে সরিয়ে দেয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n    প্যারামিটারসমূহ:\n    text (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\n    রিটার্ন:\n    str: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫টি অবস্থানে সরানো হয়েছে।\n    >>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n    'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "bg": "Изместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n​    Параметри:\n​    text (str): Входният текст, който ще бъде обработен.\n\n​    Връща:\n​    str: Преобразуваният текст със символи, изместени с 5 позиции.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "zh": "将所有字符在字母表中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数:\ntext (str): 要处理的输入文本。\n\n返回:\nstr: 字符移动5个位置后的转换文本。\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n​    Paramètres:\n​    text (str): Le texte d'entrée à traiter.\n\n​    Renvoie:\n​    str: Le texte transformé avec les caractères décalés de 5 positions.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n​    Parameter:\n​    text (str): Der Eingabetext, der verarbeitet werden soll.\n\n​    Rückgabewert:\n​    str: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai, kuma duk haruffa suna cikin manyan baki.\n​    Sigogi:\n​    text (str): Rubutun shigarwa da za a sarrafa.\n\n​    Komawa:\n​    str: Rubutun da aka canza tare da haruffa da aka motsa da matsayi 5.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hi": "सभी अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nParameters:\ntext (str): संसाधित करने के लिए इनपुट पाठ।\n\nReturns:\nstr: परिवर्तित पाठ जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "hu": "Az összes karaktert 5 pozícióval eltolja ábécé sorrendben. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"
    },
    "docstring_bertscore": {
      "sq": "0.9613566580000436",
      "hy": "0.9669256579931187",
      "bn": "0.9351590984149711",
      "bg": "0.9616260007967269",
      "zh": "0.9383928010182191",
      "fr": "0.9657636702640646",
      "de": "0.9733016932243386",
      "ha": "0.9699754288635284",
      "hi": "0.930586825673929",
      "hu": "0.9669256579931187"
    }
  },
  {
    "task_id": "C/26",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n​    Returns:\n​    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa të përcaktohet klasa.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n​    Kthen:\n​    int: Klasa së cilës i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nԴասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգման ենթակա ամբողջ թիվը:\n    Վերադարձնում է:\n    int: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটার:\n- x (char*): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n​    রিটার্নস:\n​    int: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което да бъде класифицирано.\n    Връща:\n    int: Класът, към който принадлежи цялото число x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n根据以下方法对整数 x 进行分类：\n如果 x 是一位数，x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n参数：\n- x (char*): 要分类的整数。\n    返回：\n    int: 整数 x 所属的类。\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\nParamètres :\n- x (char*): L'entier à classer.\n    Renvoie :\n    int : La classe à laquelle appartient l'entier x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKlassifiziere die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n​    Rückgabe:\n​    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai ɗigo guda, x na cikin ajin sa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\nSigogi:\n- x (char*): Lambar da za a rarraba.\n​    Komawa:\n​    int: Aji da lambar x ke ciki.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वह पूर्णांक जिसे वर्गीकृत किया जाना है।\n    रिटर्न करता है:\n    int: वह श्रेणी जिसमें पूर्णांक x आता है।\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nOsztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n​    Visszatérési érték:\n​    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)"
    },
    "prompt_bertscore": {
      "sq": "0.9793464129799924",
      "hy": "0.9748144622063003",
      "bn": "0.9515465021111115",
      "bg": "0.988237307465495",
      "zh": "0.974590804397255",
      "fr": "0.9768406907232372",
      "de": "0.988237307465495",
      "ha": "0.9550304789944634",
      "hi": "0.9616563912450252",
      "hu": "0.9758235045419575"
    },
    "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "Write a C function `int classify_integer(char *x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n",
      "sq": "Shkruani një funksion C `int classify_integer(char *x)` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa të përcaktohet klasa.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n\n    Kthen:\n    int: Klasa së cilës i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6",
      "hy": "Գրեք C ֆունկցիա `int classify_integer(char *x)`՝ հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x՝ հիմնվելով հետևյալ մեթոդի վրա:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգվող ամբողջ թիվը:\n\n    Վերադարձնում է:\n    int: Դասը, որին պատկանում է ամբողջ թիվը x:\n\t>>> classify_integer(24)\n\t6",
      "bn": "একটি C ফাংশন `int classify_integer(char *x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীর অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটার:\n- x (char*): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n\n    রিটার্ন:\n    int: যে শ্রেণীর অন্তর্গত পূর্ণসংখ্যা x।\n\t>>> classify_integer(24)\n\t6",
      "bg": "Напишете C функция `int classify_integer(char *x)`, за да решите следния проблем:\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\nПараметри:\n- x (char*): Цялото число, което трябва да бъде класифицирано.\n\n    Връща:\n    int: Класът, към който принадлежи цялото число x.\n\t>>> classify_integer(24)\n\t6",
      "zh": "编写一个 C 函数 `int classify_integer(char *x)` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n参数：\n- x (char*): 要分类的整数。\n\n    返回:\n    int: 整数 x 所属的类别。\n\t>>> classify_integer(24)\n\t6",
      "fr": "Écrire une fonction C `int classify_integer(char *x)` pour résoudre le problème suivant :\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\nParamètres :\n- x (char*): L'entier à classer.\n\n    Renvoie :\n    int: La classe à laquelle appartient l'entier x.\n\t>>> classify_integer(24)\n\t6",
      "de": "Schreiben Sie eine C-Funktion `int classify_integer(char *x)`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n\n    Rückgabe:\n    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6\n",
      "ha": "Rubuta wani aikin C `int classify_integer(char *x)` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai lamba daya, to x tana cikin ajin nata.  \nIn ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba da maimaitawa har sai an tantance ajin.  \nSigogi:  \n- x (char*): Lambar da za a rarraba.  \n\n    Komawa:  \n    int: Ajin da lambar x take ciki.  \n\t>>> classify_integer(24)  \n\t6  ",
      "hi": "C फ़ंक्शन `int classify_integer(char *x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक अंक संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि वर्ग निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वर्गीकृत किए जाने वाला पूर्णांक।\n\n    रिटर्न्स:\n    int: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\t>>> classify_integer(24)\n\t6",
      "hu": "Írj egy C függvényt `int classify_integer(char *x)` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n\n    Visszatérési érték:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6"
    },
    "instruction_bertscore": {
      "sq": "0.9887795684057202",
      "hy": "0.987559779235785",
      "bn": "0.9626604678211566",
      "bg": "0.9985637037147367",
      "zh": "0.9639362707585436",
      "fr": "0.9848562211195191",
      "de": "0.9975788942855658",
      "ha": "0.9655910604629453",
      "hi": "0.9619994259130724",
      "hu": "0.9907239612056707"
    },
    "level": "easy",
    "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(char *x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\nParameters:\n- x (char*): The integer to be classified.\n\n    Returns:\n    int: The class to which the integer x belongs.\n\t>>> classify_integer(24)\n\t6\n",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\nParametrat:\n- x (char*): Numri i plotë që do të klasifikohet.\n\n    Kthen:\n    int: Klasa së cilës i përket numri i plotë x.\n\t>>> classify_integer(24)\n\t6",
      "hy": "Դասակարգեք ամբողջ թիվ x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\nՊարամետրեր:\n- x (char*): Դասակարգման ենթակա ամբողջ թիվը:\n\n    Վերադարձնում է:\n    int: Դասը, որին պատկանում է ամբողջ թիվ x-ը:\n\t>>> classify_integer(24)\n\t6",
      "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীর অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\nপ্যারামিটারসমূহ:\n- x (char*): শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\n    রিটার্নস:\n    int: যে শ্রেণীর অন্তর্ভুক্ত ইন্টিজার x।\n\t>>> classify_integer(24)\n\t6",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:  \nАко x е едноцифрено число, x принадлежи към своя собствен клас.  \nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.  \nПараметри:  \n- x (char*): Цялото число, което трябва да бъде класифицирано.\n\n    Връща:  \n    int: Класът, към който принадлежи цялото число x.  \n\t>>> classify_integer(24)\n\t6",
      "zh": "将整数 x 根据以下方法分类：  \n如果 x 是一位数，x 属于它自己的类。  \n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。  \n参数：  \n- x (char*): 要分类的整数。\n\n返回：  \nint: 整数 x 所属的类。  \n\t>>> classify_integer(24)  \n\t6  ",
      "fr": "Classifiez l'entier x selon la méthode suivante :  \nSi x est un nombre à un chiffre, x appartient à sa propre classe.  \nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.  \nParamètres :  \n- x (char*) : L'entier à classifier.\n\n    Retourne :\n    int : La classe à laquelle appartient l'entier x.\n\t>>> classify_integer(24)\n\t6",
      "de": "Klassifizieren Sie die ganze Zahl x anhand der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\nParameter:\n- x (char*): Die zu klassifizierende ganze Zahl.\n\n    Rückgabewert:\n    int: Die Klasse, zu der die ganze Zahl x gehört.\n\t>>> classify_integer(24)\n\t6",
      "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗaya, x yana cikin ajinsa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba har sai an tantance ajin.\nParameters:\n- x (char*): Lambar da za a tantance.\n\n    Returns:\n    int: Aji wanda lambar x take ciki.\n\t>>> classify_integer(24)\n\t6",
      "hi": "पूर्णांक x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक दोहराएं जब तक कि श्रेणी निर्धारित न हो जाए।\nपैरामीटर्स:\n- x (char*): वह पूर्णांक जिसे वर्गीकृत किया जाना है।\n\n    रिटर्न्स:\n    int: वह श्रेणी जिसमें पूर्णांक x आता है।\n\t>>> classify_integer(24)\n\t6",
      "hu": "Osztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadja x számjegyeit, kap egy új x-et, és iterál, amíg az osztály meg nem határozódik.\nParaméterek:\n- x (char*): Az osztályozandó egész szám.\n\n    Visszatér:\n    int: Az osztály, amelyhez az x egész szám tartozik.\n\t>>> classify_integer(24)\n\t6"
    },
    "docstring_bertscore": {
      "sq": "0.986233126920853",
      "hy": "0.9814024360540845",
      "bn": "0.9645712920867122",
      "bg": "0.9982055731377308",
      "zh": "0.9651103749408408",
      "fr": "0.9818499503025561",
      "de": "0.9886234449262268",
      "ha": "0.9678415426800706",
      "hi": "0.9485884984767399",
      "hu": "0.9851644954708852"
    }
  },
  {
    "task_id": "C/27",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nTransformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՓոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n    রিটার্নস:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুটটি ছোট হাতের হয়, এটি বড় হাতের সংস্করণ রিটার্ন করে,\nএবং যদি ইনপুটটি বড় হাতের হয়, এটি ছোট হাতের সংস্করণ রিটার্ন করে।\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nПреобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nа ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n转换给定字母的大小写。\n    参数:\n- letter (char): 要转换的输入字母。\n    返回:\n- char: 大小写反转后的字母。如果输入为小写，则返回大写版本，\n如果输入为大写，则返回小写版本。\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nVerändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der umgewandelt werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nCanza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Yana Mayarwa:\n- char: Harafin tare da yanayinsa da aka juyar. Idan shigarwar tana cikin ƙananan baƙaƙe, yana mayar da babba,\nkuma idan shigarwar tana cikin babba, yana mayar da ƙananan baƙaƙe.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): इनपुट अक्षर जिसे बदला जाना है।\n    रिटर्न करता है:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nÁtalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű az esetének megfordításával. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9748458458065038",
      "bn": "0.9610843357476447",
      "bg": "0.9839111377665551",
      "zh": "0.9651258681105616",
      "fr": "0.9875148887696711",
      "de": "0.9622316248285022",
      "ha": "0.9607134928262526",
      "hi": "0.9682628377182456",
      "hu": "1"
    },
    "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "Write a C function `char transform_letter_case(char letter)` to solve the following problem:\nTransforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n",
      "sq": "Shkruani një funksion në C `char transform_letter_case(char letter)` për të zgjidhur problemin në vijim:  \nTransformon rastin e një shkronje të dhënë.  \n    Parametrat:  \n- letter (char): Shkronja hyrëse që do të transformohet.  \n    Kthen:  \n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, ajo kthen versionin me shkronja të mëdha,  \ndhe nëse hyrja është me shkronja të mëdha, ajo kthen versionin me shkronja të vogla.  \n    >>> transform_letter_case('b')  \n    'Z'  ",
      "hy": "Գրեք C ֆունկցիա `char transform_letter_case(char letter)`՝ հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը:\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի:\n    Վերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված: Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը:\n    >>> transform_letter_case('b')\n    'Z'",
      "bn": "একটি C ফাংশন `char transform_letter_case(char letter)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটারসমূহ:\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n    রিটার্ন করে:\n- char: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ রিটার্ন করে,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ রিটার্ন করে।\n    >>> transform_letter_case('b')\n    'Z'",
      "bg": "Напишете C функция `char transform_letter_case(char letter)`, за да решите следния проблем:\nПреобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'",
      "zh": "编写一个C函数 `char transform_letter_case(char letter)` 来解决以下问题：\n将给定字母的大小写转换。\n    参数：\n- letter (char): 要转换的输入字母。\n    返回：\n- char: 大小写已反转的字母。如果输入是小写字母，则返回大写版本；如果输入是大写字母，则返回小写版本。\n    >>> transform_letter_case('b')\n    'Z'",
      "fr": "Écrire une fonction C `char transform_letter_case(char letter)` pour résoudre le problème suivant :\nTransforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'",
      "de": "Schreiben Sie eine C-Funktion `char transform_letter_case(char letter)`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n    Rückgabewert:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'",
      "ha": "Rubuta aikin C `char transform_letter_case(char letter)` don warware matsalar mai zuwa:\nCanza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigarwa da za a canza.\n    Mayarwa:\n- char: Harafin tare da yanayin sa da aka juya. Idan shigarwar tana cikin ƙananan haruffa, yana mayar da sigar manyan haruffa,\nkuma idan shigarwar tana cikin manyan haruffa, yana mayar da sigar ƙananan haruffa.\n    >>> transform_letter_case('b')\n    'Z'",
      "hi": "C फ़ंक्शन `char transform_letter_case(char letter)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): परिवर्तित किया जाने वाला इनपुट अक्षर।\n    रिटर्न्स:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'",
      "hu": "Írj egy C függvényt `char transform_letter_case(char letter)` a következő probléma megoldására:  \nÁtalakítja egy adott betű kis- és nagybetűs formáját.  \nParaméterek:  \n- letter (char): Az átalakítandó bemeneti betű.  \nVisszatérési érték:  \n- char: A betű, amelynek kis- és nagybetűs formája meg van fordítva. Ha a bemenet kisbetűs, akkor a nagybetűs verziót adja vissza, és ha a bemenet nagybetűs, akkor a kisbetűs verziót adja vissza.  \n    >>> transform_letter_case('b')  \n    'Z'  "
    },
    "instruction_bertscore": {
      "sq": "0.9953439052381612",
      "hy": "0.9898193984504379",
      "bn": "0.9611099590667982",
      "bg": "0.9912517221280804",
      "zh": "0.9627963310017844",
      "fr": "0.9877164986064215",
      "de": "0.9709880465460442",
      "ha": "0.9696697367071156",
      "hi": "0.9595232995830916",
      "hu": "0.9724388428491231"
    },
    "level": "easy",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n    Parameters:\n- letter (char): The input letter to be transformed.\n    Returns:\n- char: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\nand if the input is uppercase, it returns the lowercase version.\n    >>> transform_letter_case('b')\n    'Z'\n",
      "sq": "Transformon rastin e një shkronje të dhënë.\n    Parametrat:\n- letter (char): Shkronja hyrëse që do të transformohet.\n    Kthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\ndhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n    >>> transform_letter_case('b')\n    'Z'",
      "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n    Պարամետրեր:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n    Վերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n    >>> transform_letter_case('b')\n    'Z'",
      "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n    প্যারামিটার:\n- letter (char): পরিবর্তিত হওয়ার জন্য ইনপুট অক্ষর।\n    Returns:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n    >>> transform_letter_case('b')\n    'Z'",
      "bg": "Преобразува регистъра на дадена буква.\n    Параметри:\n- letter (char): Входната буква, която ще бъде преобразувана.\n    Връща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\nи ако входът е с главни букви, връща версията с малки букви.\n    >>> transform_letter_case('b')\n    'Z'",
      "zh": "将给定字母的大小写转换。\n    参数:\n- letter (char): 要转换的输入字母。\n    返回:\n- char: 大小写反转后的字母。如果输入是小写字母，则返回大写版本；如果输入是大写字母，则返回小写版本。\n    >>> transform_letter_case('b')\n    'Z'",
      "fr": "Transforme la casse d'une lettre donnée.\n    Paramètres :\n- letter (char) : La lettre d'entrée à transformer.\n    Renvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\net si l'entrée est en majuscule, elle renvoie la version minuscule.\n    >>> transform_letter_case('b')\n    'Z'",
      "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n    Parameter:\n- letter (char): Der Eingabebuchstabe, der umgewandelt werden soll.\n    Rückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n    >>> transform_letter_case('b')\n    'Z'",
      "ha": "Canza yanayin harafin da aka bayar.\n    Sigogi:\n- letter (char): Harafin shigar da za a canza.\n    Returns:\n- char: Harafin tare da canza yanayin rubutu. Idan shigar harafi ne a ƙananan rubutu, zai dawo da babba,\nkuma idan shigar harafi ne a babba, zai dawo da ƙananan rubutu.\n    >>> transform_letter_case('b')\n    'Z'",
      "hi": "दिए गए अक्षर का केस बदलता है।\n    पैरामीटर्स:\n- letter (char): परिवर्तित होने वाला इनपुट अक्षर।\n    रिटर्न्स:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n    >>> transform_letter_case('b')\n    'Z'",
      "hu": "Átalakítja egy adott betű esetét.\n    Paraméterek:\n- letter (char): Az átalakítandó bemeneti betű.\n    Visszatér:\n- char: A betű az ellentétes esettel. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n    >>> transform_letter_case('b')\n    'Z'"
    },
    "docstring_bertscore": {
      "sq": "0.9913603729465065",
      "hy": "0.975051428250875",
      "bn": "0.973378165921037",
      "bg": "0.9801490783497543",
      "zh": "0.9702916484301359",
      "fr": "0.9743935644288874",
      "de": "0.9620043916725983",
      "ha": "0.9504067609847333",
      "hi": "1",
      "hu": "0.98427482999423"
    }
  },
  {
    "task_id": "C/28",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nDisplay the ASCII information for a given character.\n​    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n​    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nShfaq informacionin ASCII për një karakter të dhënë.\n​    Parametrat:\n- character (char): Karakteri i dhënë për të cilin do të shfaqet informacioni ASCII.\n​    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՑուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար։\n​    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n​    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি প্রদত্ত চরিত্রের জন্য ASCII তথ্য প্রদর্শন করুন।\n​    প্যারামিটার:\n- character (char): ইনপুট চরিত্র যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n​    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nПоказва ASCII информацията за даден символ.\n​    Параметри:\n- character (char): Входният символ, за който ще се покаже ASCII информацията.\n​    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n显示给定字符的ASCII信息。\n    参数:\n- character (char): 要显示ASCII信息的输入字符。\n    返回:\n- int: 对应的ASCII代码\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nAfficher les informations ASCII pour un caractère donné.\n​    Paramètres :\n- character (char) : Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n​    Renvoie :\n- int : code ASCII correspondant\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nZeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n​    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n​    Rückgabe:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nNuna bayanin ASCII don wata alama da aka bayar.\n​    Sigogi:\n- character (char): Alamar shigarwa wanda za a nuna bayanin ASCII.\n​    Komawa:\n- int: lambar ASCII mai dacewa\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n    पैरामीटर्स:\n- character (char): इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nMegjeleníti a megadott karakter ASCII információit.\n​    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n​    Visszatér:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{"
    },
    "prompt_bertscore": {
      "sq": "0.961564425378606",
      "hy": "0.9665961301909818",
      "bn": "0.9549061363759356",
      "bg": "0.9732834192292834",
      "zh": "0.9560099254033464",
      "fr": "0.9696496750386312",
      "de": "0.9638047774462986",
      "ha": "0.9428143133000557",
      "hi": "0.9613983703800608",
      "hu": "0.9551895819296723"
    },
    "canonical_solution": "return character;\n}",
    "instruction": {
      "en": "Write a C function `int display_ascii_info(char character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n",
      "sq": "Shkruani një funksion në C `int display_ascii_info(char character)` për të zgjidhur problemin e mëposhtëm:\nShfaq informacionin ASCII për një karakter të dhënë.\n\n    Parametrat:\n- character (char): Karakteri i hyrjes për të cilin do të shfaqet informacioni ASCII.\n\n    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65",
      "hy": "Գրեք C ֆունկցիա `int display_ascii_info(char character)` հետևյալ խնդիրը լուծելու համար:\nՑուցադրել տրված սիմվոլի ASCII տեղեկատվությունը:\n\n    Պարամետրեր:\n- character (char): Մուտքային սիմվոլ, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\n    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65",
      "bn": "একটি C ফাংশন `int display_ascii_info(char character)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\n    প্যারামিটারসমূহ:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\n    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65",
      "bg": "Напишете C функция `int display_ascii_info(char character)`, за да решите следния проблем:  \nПоказване на ASCII информацията за даден символ.\n\n    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информацията.\n\n    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65",
      "zh": "编写一个 C 函数 `int display_ascii_info(char character)` 来解决以下问题：  \n显示给定字符的 ASCII 信息。\n\n    参数:\n- character (char): 要显示 ASCII 信息的输入字符。\n\n    返回:\n- int: 对应的 ASCII 代码\n    >>> display_ascii_info('A')\n    65",
      "fr": "Écrire une fonction C `int display_ascii_info(char character)` pour résoudre le problème suivant :  \nAfficher les informations ASCII pour un caractère donné.\n\n    Paramètres :\n- character (char) : Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\n    Renvoie :\n- int : code ASCII correspondant\n    >>> display_ascii_info('A')\n    65",
      "de": "Schreiben Sie eine C-Funktion `int display_ascii_info(char character)`, um das folgende Problem zu lösen:\nZeigen Sie die ASCII-Informationen für ein gegebenes Zeichen an.\n\n    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\n    Rückgabewert:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65",
      "ha": "Rubuta aikin C `int display_ascii_info(char character)` don warware matsalar mai zuwa: Nuna bayanin ASCII don wata alama da aka bayar.\n\n   Sigogi:\n- character (char): Alamar shigarwa wadda za a nuna bayanin ASCII nata.\n\n   Komawa:\n- int: lambar ASCII da ta dace\n    >>> display_ascii_info('A')\n    65",
      "hi": "एक C फ़ंक्शन `int display_ascii_info(char character)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करें।\n\n    पैरामीटर्स:\n- character (char): इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\n    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65",
      "hu": "Írj egy C függvényt `int display_ascii_info(char character)` a következő probléma megoldására:\nJelenítsd meg egy adott karakter ASCII információját.\n\n    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n\n    Visszatérési érték:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65"
    },
    "instruction_bertscore": {
      "sq": "0.9808156819085074",
      "hy": "0.9728122679654686",
      "bn": "0.9756981687715245",
      "bg": "0.9873929297157157",
      "zh": "0.9729773298121086",
      "fr": "0.9871994637245877",
      "de": "0.9841695558922815",
      "ha": "0.9770560060562791",
      "hi": "0.9788397068779723",
      "hu": "0.9707510805014696"
    },
    "level": "easy",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "en": "Display the ASCII information for a given character.\n\n    Parameters:\n- character (char): The input character for which ASCII information is to be displayed.\n\n    Returns:\n- int: corresponding ASCII code\n    >>> display_ascii_info('A')\n    65\n",
      "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n    Parametrat:\n- character (char): Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n\n    Kthen:\n- int: kodi përkatës ASCII\n    >>> display_ascii_info('A')\n    65",
      "hy": "ASCII տեղեկատվությունը ցուցադրել տրված սիմվոլի համար։\n\n    Պարամետրեր:\n- character (char): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\n    Վերադարձնում է:\n- int: համապատասխան ASCII կոդը\n    >>> display_ascii_info('A')\n    65",
      "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\n    প্যারামিটারসমূহ:\n- character (char): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\n    রিটার্নস:\n- int: সংশ্লিষ্ট ASCII কোড\n    >>> display_ascii_info('A')\n    65",
      "bg": "Показва ASCII информацията за даден символ.\n\n    Параметри:\n- character (char): Входният символ, за който трябва да се покаже ASCII информация.\n\n    Връща:\n- int: съответстващ ASCII код\n    >>> display_ascii_info('A')\n    65",
      "zh": "显示给定字符的ASCII信息。\n\n    参数:\n- character (char): 要显示其ASCII信息的输入字符。\n\n    返回:\n- int: 对应的ASCII码\n    >>> display_ascii_info('A')\n    65",
      "fr": "Afficher les informations ASCII pour un caractère donné.\n\n    Paramètres:\n- character (char): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\n    Renvoie:\n- int: code ASCII correspondant\n    >>> display_ascii_info('A')\n    65",
      "de": "Zeige die ASCII-Informationen für ein gegebenes Zeichen an.\n\n    Parameter:\n- character (char): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\n    Rückgabewerte:\n- int: entsprechender ASCII-Code\n    >>> display_ascii_info('A')\n    65",
      "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n    Sigogi:\n- character (char): Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n\n    Komawa:\n- int: lambar ASCII da ta dace\n    >>> display_ascii_info('A')\n    65",
      "hi": "दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n\n    पैरामीटर्स:\n- character (char): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\n    रिटर्न्स:\n- int: संबंधित ASCII कोड\n    >>> display_ascii_info('A')\n    65",
      "hu": "Jelenítse meg a megadott karakter ASCII információját.\n\n    Paraméterek:\n- character (char): Az a bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n\n    Visszatér:\n- int: a megfelelő ASCII kód\n    >>> display_ascii_info('A')\n    65"
    },
    "docstring_bertscore": {
      "sq": "0.9730559874429985",
      "hy": "0.9597392108072764",
      "bn": "0.9728015419248928",
      "bg": "0.9755491959857484",
      "zh": "0.9688134411344743",
      "fr": "0.9807765517234435",
      "de": "0.9659450198019495",
      "ha": "0.9418279148278365",
      "hi": "0.97804081548545",
      "hu": "0.958478503778848"
    }
  },
  {
    "task_id": "C/29",
    "prompt": {
      "en": "#include <assert.h> // Used for testing the function with assertions\n#include <math.h> // Not needed for this function\n#include <stdbool.h> // Not needed for this function\n#include <stdio.h> // Needed for input/output functions\n#include <string.h> // Not needed for this function\n/*\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n​​    char: The grade corresponding to the input score.\n​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n​​         Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "sq": "#include <assert.h> // Përdoret për të testuar funksionin me pohime\n#include <math.h> // Nuk nevojitet për këtë funksion\n#include <stdbool.h> // Nuk nevojitet për këtë funksion\n#include <stdio.h> // Nevojitet për funksionet e hyrje/dalje\n#include <string.h> // Nuk nevojitet për këtë funksion\n/*\nVlerëson notën për një numër të plotë hyrës.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n​​    char: Nota që korrespondon me notën hyrëse.\n​​         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n​​         Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "hy": "#include <assert.h> // Օգտագործվում է ֆունկցիան ստուգելու համար հաստատումներով\n#include <math.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdbool.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n#include <stdio.h> // Անհրաժեշտ է մուտք/ելքի ֆունկցիաների համար\n#include <string.h> // Անհրաժեշտ չէ այս ֆունկցիայի համար\n/*\nԳնահատել մուտքագրված ամբողջ թվի գնահատականը:\n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը:\n    Վերադարձնում է:\n​​    char: Մուտքագրված գնահատականին համապատասխանող նշանը:\n​​         Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A':\n​​         Հակառակ դեպքում, վերադարձնում է 'B':\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "bn": "#include <assert.h> // ফাংশনটি পরীক্ষার জন্য assertions ব্যবহার করা হয়\n#include <math.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdbool.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n#include <stdio.h> // ইনপুট/আউটপুট ফাংশনের জন্য প্রয়োজন\n#include <string.h> // এই ফাংশনের জন্য প্রয়োজন নেই\n/*\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    প্যারামিটার:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    রিটার্নস:\n​​    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n​​         যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তবে 'A' রিটার্ন করে।\n​​         অন্যথায়, 'B' রিটার্ন করে।\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "bg": "#include <assert.h> // Използва се за тестване на функцията с твърдения\n#include <math.h> // Не е необходимо за тази функция\n#include <stdbool.h> // Не е необходимо за тази функция\n#include <stdio.h> // Необходимо за входно/изходни функции\n#include <string.h> // Не е необходимо за тази функция\n/*\nОценете оценката за входно цяло число.\n    Параметри:\n- score (int): Цялото число, което трябва да бъде оценено.\n    Връща:\n​​    char: Оценката, съответстваща на входното число.\n​​         Ако числото е между 90 и 100 (включително), връща 'A'.\n​​         В противен случай връща 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "zh": "#include <assert.h> // 用于使用断言测试函数\n#include <math.h> // 这个函数不需要\n#include <stdbool.h> // 这个函数不需要\n#include <stdio.h> // 需要用于输入/输出函数\n#include <string.h> // 这个函数不需要\n/*\n评估输入整数的等级。\n    参数:\n- score (int): 要评估的整数分数。\n    返回:\n​​    char: 与输入分数对应的等级。\n​​         如果分数在90到100之间（包括90和100），返回 'A'。\n​​         否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "fr": "#include <assert.h> // Utilisé pour tester la fonction avec des assertions\n#include <math.h> // Pas nécessaire pour cette fonction\n#include <stdbool.h> // Pas nécessaire pour cette fonction\n#include <stdio.h> // Nécessaire pour les fonctions d'entrée/sortie\n#include <string.h> // Pas nécessaire pour cette fonction\n/*\nÉvaluer la note pour un entier en entrée.\n    Paramètres:\n- score (int): Le score entier à évaluer.\n    Renvoie:\n​​    char: La note correspondant au score en entrée.\n​​         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n​​         Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "de": "#include <assert.h> // Wird verwendet, um die Funktion mit Assertions zu testen\n#include <math.h> // Nicht benötigt für diese Funktion\n#include <stdbool.h> // Nicht benötigt für diese Funktion\n#include <stdio.h> // Benötigt für Ein-/Ausgabefunktionen\n#include <string.h> // Nicht benötigt für diese Funktion\n/*\nBewertet die Note für eine Eingabe als Ganzzahl.\n    Parameter:\n- score (int): Die zu bewertende Ganzzahl.\n    Rückgabewert:\n​​    char: Die Note, die der Eingabewertung entspricht.\n​​         Wenn die Bewertung zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n​​         Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "ha": "#include <assert.h> // Ana amfani da wannan don gwada aikin tare da tabbaci\n#include <math.h> // Ba a bukata don wannan aikin\n#include <stdbool.h> // Ba a bukata don wannan aikin\n#include <stdio.h> // Ana bukata don ayyukan shigarwa/fitarwa\n#include <string.h> // Ba a bukata don wannan aikin\n/*\nKimanta darajar don wani cikakken lamba.\n    Sigogi:\n- score (int): Cikakken maki da za a kimanta.\n    Komawa:\n​​    char: Darajar da ta dace da maki da aka shigar.\n​​         Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n​​         In ba haka ba, yana dawowa 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "hi": "#include <assert.h> // assert के साथ फ़ंक्शन का परीक्षण करने के लिए उपयोग किया जाता है\n#include <math.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdbool.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n#include <stdio.h> // इनपुट/आउटपुट फ़ंक्शन के लिए आवश्यक है\n#include <string.h> // इस फ़ंक्शन के लिए आवश्यक नहीं है\n/*\nएक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    लौटाता है:\n​​    char: इनपुट स्कोर के अनुरूप ग्रेड।\n​​         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n​​         अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "hu": "#include <assert.h> // Használva a függvény tesztelésére állításokkal\n#include <math.h> // Nem szükséges ehhez a függvényhez\n#include <stdbool.h> // Nem szükséges ehhez a függvényhez\n#include <stdio.h> // Szükséges a bemeneti/kimeneti függvényekhez\n#include <string.h> // Nem szükséges ehhez a függvényhez\n/*\nÉrtékeli a bemeneti egész szám osztályzatát.\n    Paraméterek:\n- score (int): Az értékelendő egész szám pontszám.\n    Visszatér:\n​​    char: A bemeneti pontszámnak megfelelő osztályzat.\n​​         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n​​         Egyébként 'B'-t ad vissza.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "sq": "0.9623960907839991",
      "hy": "0.9393172268115555",
      "bn": "0.9558108977615495",
      "bg": "0.9545172180898692",
      "zh": "0.9461940092333643",
      "fr": "0.9858541401538383",
      "de": "0.9682785295183474",
      "ha": "0.9688619069474468",
      "hi": "0.9473464627041287",
      "hu": "0.9635181538064652"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "en": "Write a C function `char evaluate_integer_grade(int score)` to solve the following problem:\nEvaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n",
      "sq": "Shkruani një funksion në C `char evaluate_integer_grade(int score)` për të zgjidhur problemin e mëposhtëm:\nVlerësoni notën për një numër të plotë të dhënë.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n    char: Nota që korrespondon me notën e dhënë.\n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "hy": "Գրեք C ֆունկցիա `char evaluate_integer_grade(int score)` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվի գնահատականը:\n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը:\n    Վերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը:\n    Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A':\n    Հակառակ դեպքում, վերադարձնում է 'B':\n>>> evaluate_integer_grade(90)\nA",
      "bn": "একটি C ফাংশন `char evaluate_integer_grade(int score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা গ্রেড মূল্যায়ন করুন।\n    প্যারামিটারসমূহ:\n- score (int): মূল্যায়নের জন্য পূর্ণসংখ্যা স্কোর।\n    রিটার্নস:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তাহলে 'A' রিটার্ন করে।\n    অন্যথায়, 'B' রিটার্ন করে।\n>>> evaluate_integer_grade(90)\nA",
      "bg": "Напишете C функция `char evaluate_integer_grade(int score)` за решаване на следния проблем:  \nОценете оценката за входящо цяло число.  \nПараметри:  \n- score (int): Целочислената оценка, която трябва да бъде оценена.  \nВръща:  \nchar: Оценката, съответстваща на входната оценка.  \nАко оценката е между 90 и 100 (включително), връща 'A'.  \nВ противен случай връща 'B'.  \n>>> evaluate_integer_grade(90)  \nA  ",
      "zh": "编写一个C函数 `char evaluate_integer_grade(int score)` 来解决以下问题：\n评估输入整数的等级。\n    参数：\n- score (int): 要评估的整数分数。\n    返回：\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA",
      "fr": "Écrire une fonction C `char evaluate_integer_grade(int score)` pour résoudre le problème suivant :\nÉvaluer la note pour un entier en entrée.\n    Paramètres :\n- score (int) : Le score entier à évaluer.\n    Renvoie :\n    char : La note correspondant au score en entrée.\n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "de": "Schreiben Sie eine C-Funktion `char evaluate_integer_grade(int score)`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine eingegebene Ganzzahl.\n    Parameter:\n- score (int): Die zu bewertende Ganzzahl.\n    Rückgabe:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n    Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA",
      "ha": "Rubuta aikin C `char evaluate_integer_grade(int score)` don warware matsalar mai zuwa: Kimanta darajar don shigarwar lamba. Ma'auni: - score (int): Lambar da za a kimanta. Komawa: char: Darajar da ta dace da shigarwar lamba. Idan lambar tana tsakanin 90 da 100 (ciki har da), ya dawo 'A'. In ba haka ba, ya dawo 'B'. >>> evaluate_integer_grade(90) A",
      "hi": "C फ़ंक्शन `char evaluate_integer_grade(int score)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    पैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    रिटर्न करता है:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA",
      "hu": "Írj egy C függvényt `char evaluate_integer_grade(int score)` a következő probléma megoldására:  \nÉrtékeld ki egy egész szám osztályzatát.  \nParaméterek:  \n- score (int): Az értékelendő egész szám.  \nVisszatérési érték:  \nchar: Az osztályzat, amely megfelel a bemeneti pontszámnak.  \nHa a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.  \nEgyébként 'B'-t ad vissza.  \n>>> evaluate_integer_grade(90)  \nA  "
    },
    "instruction_bertscore": {
      "sq": "0.942918594250099",
      "hy": "0.9737881390274931",
      "bn": "0.929868975476869",
      "bg": "0.9840551447928054",
      "zh": "0.9733571111006474",
      "fr": "0.9911194342943112",
      "de": "0.9315495871308052",
      "ha": "0.9709153478265855",
      "hi": "0.9602558484283482",
      "hu": "0.9714190744728899"
    },
    "level": "easy",
    "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n    Parameters:\n- score (int): The integer score to be evaluated.\n    Returns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n>>> evaluate_integer_grade(90)\nA\n",
      "sq": "Vlerësoni notën për një numër të plotë të dhënë si hyrje.\n    Parametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n    Kthen:\n    char: Nota që korrespondon me notën e dhënë si hyrje.\n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "hy": "Մուտքային ամբողջ թիվի գնահատականի գնահատում։  \n    Պարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը։\n    Վերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n    Հակառակ դեպքում, վերադարձնում է 'B'։\n>>> evaluate_integer_grade(90)\nA",
      "bn": "ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n    Parameters:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n    Returns:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তাহলে 'A' ফেরত দেয়।\n    অন্যথায়, 'B' ফেরত দেয়।\n>>> evaluate_integer_grade(90)\nA",
      "bg": "Оценете оценката за входящо цяло число.\n    Параметри:\n- score (int): Целочислената оценка, която ще бъде оценена.\n    Връща:\n    char: Оценката, съответстваща на входящата оценка.\n    Ако оценката е между 90 и 100 (включително), връща 'A'.\n    В противен случай, връща 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "zh": "评估输入整数的等级。\n    参数：\n- score (int): 要评估的整数分数。\n    返回：\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n>>> evaluate_integer_grade(90)\nA",
      "fr": "Évaluer la note pour un entier en entrée.\n    Paramètres:\n- score (int): Le score entier à évaluer.\n    Renvoie:\n    char: La note correspondant au score d'entrée.\n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n    Parameter:\n- score (int): Die zu bewertende ganze Zahl.\n    Rückgabe:\n    char: Die Note, die dem eingegebenen Punktestand entspricht.\n    Wenn der Punktestand zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n>>> evaluate_integer_grade(90)\nA",
      "ha": "Duba darajar don wani lamba mai shigarwa.\n    Sigogi:\n- score (int): Lambar da za a duba.\n    Dawowa:\n    char: Darajar da ta dace da lambar da aka shigar.\n    Idan lambar tana tsakanin 90 da 100 (ciki har), yana dawowa 'A'.\n    In ba haka ba, yana dawowa 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n    Parameters:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n    Returns:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n>>> evaluate_integer_grade(90)\nA",
      "hu": "Értékeli a jegyet egy bemeneti egész számhoz.\n    Paraméterek:\n- score (int): Az értékelendő egész szám pontszám.\n    Visszatér:\n    char: A bemeneti pontszámnak megfelelő jegy.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Egyébként 'B'-t ad vissza.\n>>> evaluate_integer_grade(90)\nA"
    },
    "docstring_bertscore": {
      "sq": "0.9721023629836499",
      "hy": "0.9670569526749827",
      "bn": "0.9651149434396047",
      "bg": "0.968475570856334",
      "zh": "0.9632215986475801",
      "fr": "0.9900380904999573",
      "de": "0.9603152389122777",
      "ha": "0.9384271640741381",
      "hi": "0.9687417355669207",
      "hu": "0.9967643110929417"
    }
  },
  {
    "task_id": "C/30",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nChecks if a three-character string has exactly two characters that are the same.\n​\nArgs:\n    s (char array): The three-character string to be checked.\n​\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողում կա՞ն երկու նույնական նիշեր:\n​\nԱրգումենտներ:\n    s (char array): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n​\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքում կա երկու նույնական նիշ, հակառակ դեպքում՝ 'No':\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা।\n\nআর্গুমেন্ট:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\n    str: 'Yes' ফেরত দেয় যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nПроверява дали низ от три знака има точно два еднакви знака.\n​\nАргументи:\n    s (масив от знаци): Низът от три знака, който трябва да бъде проверен.\n​\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n检查一个三字符字符串是否恰好有两个相同的字符。\n\n参数:\n    s (char array): 要检查的三字符字符串。\n\n返回:\n    str: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n    s (char array): La chaîne de trois caractères à vérifier.\n\nReturns:\n    str: Retourne 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPrüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgumente:\n    s (char array): Der zu überprüfende dreistellige String.\n\nRückgabewerte:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke iri ɗaya.\n​\nArgs:\n    s (char array): Kirtani mai haruffa uku da za a duba.\n​\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nजांचता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEllenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgumentumok:\n    s (karakter tömb): Az ellenőrizendő három karakterből álló karakterlánc.\n\nVisszatér:\n    str: 'Yes'-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'-t.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "sq": "0.9609850205571273",
      "hy": "0.9351489682655383",
      "bn": "0.9570708102684538",
      "bg": "0.956849734654362",
      "zh": "0.9523092427742854",
      "fr": "0.960152163369448",
      "de": "0.9475375451306843",
      "ha": "0.9699881412079147",
      "hi": "0.9495135201612194",
      "hu": "0.9567450564435566"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "Write a C function `const char* check_two_equal_digits(const char s[4])` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n",
      "sq": "Shkruani një funksion në C `const char* check_two_equal_digits(const char s[4])` për të zgjidhur problemin në vijim:\nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n    s (varg karakteresh): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n    str: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "hy": "Գրեք C ֆունկցիա `const char* check_two_equal_digits(const char s[4])` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n\nԱրձագանքներ:\n    s (char զանգված): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքում կա հենց երկու նույն նիշ, հակառակ դեպքում՝ 'No':\n    >>> check_two_equal_digits(112)\n    Yes",
      "bn": "একটি C ফাংশন `const char* check_two_equal_digits(const char s[4])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nআর্গুমেন্টসমূহ:\n    s (char array): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nরিটার্নস:\n    str: 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n    >>> check_two_equal_digits(112)\n    Yes",
      "bg": "Напишете C функция `const char* check_two_equal_digits(const char s[4])`, за да решите следния проблем:  \nПроверява дали низ с три знака има точно два еднакви знака.\n\nАргументи:\n    s (char array): Низът с три знака, който трябва да бъде проверен.\n\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "zh": "编写一个 C 函数 `const char* check_two_equal_digits(const char s[4])` 来解决以下问题：\n检查一个三字符字符串是否有且仅有两个字符相同。\n\n参数:\n    s (char array): 要检查的三字符字符串。\n\n返回:\n    str: 如果输入有且仅有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n    >>> check_two_equal_digits(112)\n    Yes",
      "fr": "Écrire une fonction C `const char* check_two_equal_digits(const char s[4])` pour résoudre le problème suivant :  \nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs :  \n    s (tableau de char) : La chaîne de trois caractères à vérifier.\n\nRenvoie :  \n    str : Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.  \n    >>> check_two_equal_digits(112)  \n    Yes  ",
      "de": "Schreiben Sie eine C-Funktion `const char* check_two_equal_digits(const char s[4])`, um das folgende Problem zu lösen:\nÜberprüft, ob ein drei Zeichen langer String genau zwei gleiche Zeichen hat.\n\nArgumente:\n    s (char array): Der drei Zeichen lange String, der überprüft werden soll.\n\nRückgabewerte:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, ansonsten 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "ha": "Rubuta aikin C `const char* check_two_equal_digits(const char s[4])` don warware matsalar mai zuwa:\nDuba idan wani kirtani mai haruffa uku yana da daidai haruffa biyu da suke iri ɗaya.\n\nArgs:\n    s (char array): Kirtani mai haruffa uku da za a duba.\n\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu iri ɗaya, in ba haka ba 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "hi": "C फ़ंक्शन `const char* check_two_equal_digits(const char s[4])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करता है कि क्या तीन-अक्षर की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षर की स्ट्रिंग जिसे जाँचना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n    >>> check_two_equal_digits(112)\n    Yes",
      "hu": "Írj egy C függvényt `const char* check_two_equal_digits(const char s[4])` a következő probléma megoldására:\nEllenőrzi, hogy egy három karakterből álló stringben pontosan két azonos karakter van-e.\n\nArgs:\n    s (char array): Az ellenőrizendő három karakterből álló string.\n\nReturns:\n    str: 'Yes'-t ad vissza, ha a bemenetnek pontosan két egyenlő karaktere van, különben 'No'-t.\n    >>> check_two_equal_digits(112)\n    Yes"
    },
    "instruction_bertscore": {
      "sq": "0.9559143841900687",
      "hy": "0.9371894981699097",
      "bn": "0.9625045429720441",
      "bg": "0.955626568767949",
      "zh": "0.9568080222743446",
      "fr": "0.9602749169449275",
      "de": "0.9607482531429337",
      "ha": "0.9693884760875703",
      "hi": "0.9540790394693063",
      "hu": "0.9725762950727992"
    },
    "level": "easy",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n    s (char array): The three-character string to be checked.\n\nReturns:\n    str: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n    >>> check_two_equal_digits(112)\n    Yes\n",
      "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgs:\n    s (char array): Vargu me tre karaktere që do të kontrollohet.\n\nReturns:\n    str: Kthen 'Yes' nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "hy": "Երեք նիշից բաղկացած տողում ստուգում է, արդյոք կա՞ն երկու նույնական նիշեր։\n\nԱրձ.:\n    s (char array): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել։\n\nՎերադարձնում է:\n    str: Վերադարձնում է 'Yes', եթե մուտքագրումը ունի երկու նույնական նիշ, հակառակ դեպքում՝ 'No'։\n    >>> check_two_equal_digits(112)\n    Yes",
      "bn": "তিন-অক্ষরের একটি স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা তা পরীক্ষা করে।\n\nArgs:\n    s (char array): যে তিন-অক্ষরের স্ট্রিংটি পরীক্ষা করা হবে।\n\nReturns:\n    str: যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে 'Yes' ফেরত দেয়, অন্যথায় 'No'।\n    >>> check_two_equal_digits(112)\n    Yes",
      "bg": "Проверява дали низ с три знака има точно два еднакви знака.\n\nАргументи:\n    s (char array): Тристепенният низ, който трябва да бъде проверен.\n\nВръща:\n    str: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n    s (char array): 要检查的三字符字符串。\n\n返回：\n    str: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n    >>> check_two_equal_digits(112)\n    Yes",
      "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n    s (char array): La chaîne de trois caractères à vérifier.\n\nReturns:\n    str: Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgs:\n    s (char array): Der dreistellige String, der überprüft werden soll.\n\nReturns:\n    str: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "ha": "Duba idan wani igiyar haruffa mai haruffa uku yana daidai da haruffa biyu waɗanda suke daidai.\n\nArgs:\n    s (char array): Igiyar haruffa mai haruffa uku da za a duba.\n\nReturns:\n    str: Ya dawo da 'Yes' idan shigarwar tana daidai da haruffa biyu masu daidai, in ba haka ba 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "hi": "तीन-अक्षरों की स्ट्रिंग में जांच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n    s (char array): तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nरिटर्न्स:\n    str: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n    >>> check_two_equal_digits(112)\n    Yes",
      "hu": "Ellenőrzi, hogy egy három karakteres karakterláncban pontosan két azonos karakter van-e.\n\nArgs:\n    s (char array): A három karakteres karakterlánc, amelyet ellenőrizni kell.\n\nReturns:\n    str: 'Yes' értéket ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'.\n    >>> check_two_equal_digits(112)\n    Yes"
    },
    "docstring_bertscore": {
      "sq": "0.9792907964733025",
      "hy": "0.9315283336800344",
      "bn": "0.9484111215464758",
      "bg": "0.9435579854466503",
      "zh": "0.9294039817548663",
      "fr": "0.9649431281600095",
      "de": "0.947490469730379",
      "ha": "0.920452703633529",
      "hi": "0.9389269181128219",
      "hu": "0.9589589906705714"
    }
  },
  {
    "task_id": "C/31",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni njërin nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՈւնենալով տող, որը բաղկացած է փոքրատառ անգլերեն տառերից, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որը անհրաժեշտ է դարձնելու համար տողը բաղկացած նույն տառից:\nՕրինակ՝\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\n给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n例如：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "de": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi ɗaya kawai?\nAlal misali:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षर होते हैं, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "sq": "0.996510064205217",
      "hy": "0.9648444088606352",
      "bn": "0.9800525439845713",
      "bg": "1",
      "zh": "0.9900744398596867",
      "fr": "0.9887064724254994",
      "de": "0.9636119073463136",
      "ha": "0.9758107921975713",
      "hi": "0.9646561072594141",
      "hu": "0.988135211449643"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "en": "Write a C function `int minRoundsToSameChar(const char* s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n",
      "sq": "Shkruani një funksion në C `int minRoundsToSameChar(const char* s)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg që përbëhet nga shkronjat e vogla të anglishtes, në çdo raund mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: sa është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?  \nPër shembull:  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "hy": "Գրեք C ֆունկցիա `int minRoundsToSameChar(const char* s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "bn": "একটি C ফাংশন `int minRoundsToSameChar(const char* s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং দেওয়া আছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে তৈরি করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "bg": "Напишете C функция `int minRoundsToSameChar(const char* s)`, за да решите следния проблем:  \nДаден е низ, състоящ се от малки букви на английската азбука, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да направите низа съставен от един и същ символ?  \nНапример:  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "zh": "编写一个 C 函数 `int minRoundsToSameChar(const char* s)` 来解决以下问题：  \n给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：需要多少轮才能使字符串由相同的字符组成？  \n例如：  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "fr": "Écrire une fonction C `int minRoundsToSameChar(const char* s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?  \nPar exemple :  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "de": "Schreiben Sie eine C-Funktion `int minRoundsToSameChar(const char* s)`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu komponieren?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "ha": "Rubuta aikin C `int minRoundsToSameChar(const char* s)` don warware matsalar mai zuwa:  \nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi ɗaya?  \nMisali:  \n    >>> minRoundsToSameChar(\"aab\")  \n    1  \n    >>> minRoundsToSameChar(\"abc\")  \n    2  \n    >>> minRoundsToSameChar(\"aaa\")  \n    0  ",
      "hi": "C फ़ंक्शन `int minRoundsToSameChar(const char* s)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश होता है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hu": "Írj egy C függvényt `int minRoundsToSameChar(const char* s)` a következő probléma megoldására:\nAdott egy kisbetűs angol betűkből álló string, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a string ugyanabból a karakterből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0"
    },
    "instruction_bertscore": {
      "sq": "0.9921161615463443",
      "hy": "0.972791014514698",
      "bn": "0.8773044245917013",
      "bg": "0.9980639496760529",
      "zh": "0.979327741724175",
      "fr": "0.9888248561325962",
      "de": "0.9692029553116837",
      "ha": "0.9832812808282935",
      "hi": "0.9641672778916872",
      "hu": "0.984759090863193"
    },
    "level": "middle",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\nFor example:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në secilën raund ju mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\nPër shembull:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից:\nՕրինակ՝\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "bn": "একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "bg": "Даден е низ, състоящ се от малки латински букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\nНапример:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？\n例如：\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\nPar exemple :\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "de": "Angenommen, ein String besteht aus Kleinbuchstaben des englischen Alphabets. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen bestehen zu lassen?\nZum Beispiel:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "ha": "An ba da wata igiyar rubutu da ta ƙunshi ƙananan haruffan Ingilishi, a kowane zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar rubutu ta ƙunshi harafi ɗaya?\nMisali:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का उपयोग किया गया है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\nPéldául:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9944657603236059",
      "hy": "0.9527047158629259",
      "bn": "0.9691401881112767",
      "bg": "0.9938466294259202",
      "zh": "0.9833202123829763",
      "fr": "0.9839439117794259",
      "de": "0.9340217408531654",
      "ha": "0.9511109056855019",
      "hi": "0.9493929515199312",
      "hu": "0.9840966585424417"
    }
  },
  {
    "task_id": "C/32",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjejmë vitin Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը կայանում է գտնել Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন n-তম ঘটনা ঘটে, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন কেবলমাত্র ঘটনা i এর ঘটনার পরের বছরেই শুরু হতে পারে।\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща след случването на събитие i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个长度为 n 的事件序列，每个事件以 a_i 年为周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生的下一年开始。\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement la survenue de l'événement i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten von Ereignis i beginnen kann.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce gano shekarar Y_n lokacin da abin n-th ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a shekarar da ke biye da faruwar abin i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nn घटनाओं के अनुक्रम को दिया गया है, प्रत्येक a_i वर्षों की आवधिकता के साथ घटित होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना घटित होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है।\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy n eseményből álló sorozat, amelyek mindegyike a_i évenkénti periodicitással fordul elő, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődhet meg. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "sq": "0.9940567803690551",
      "hy": "0.9554799795467454",
      "bn": "0.9587033533701795",
      "bg": "0.9893625485740576",
      "zh": "0.9571895912363126",
      "fr": "0.9897842408729947",
      "de": "0.9896022954439667",
      "ha": "0.9734929742812752",
      "hi": "0.9903475566336096",
      "hu": "0.9626455705425789"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "en": "Write a C function `int apocalypseYear(int n, int signs[])` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n",
      "sq": "Shkruani një funksion në C `int apocalypseYear(int n, int signs[])` për të zgjidhur problemin në vijim:  \nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, nën kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.  \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hy": "Գրեք C ֆունկցիա `int apocalypseYear(int n, int signs[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "bn": "C ফাংশন `int apocalypseYear(int n, int signs[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: n ঘটনাগুলির একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছরগুলির একটি পর্যায়ক্রমিকতার সাথে সংঘটিত হয়, সমস্যাটি হল Y_n বছর খুঁজে বের করা যখন n-তম ঘটনা ঘটে, এই শর্তের অধীনে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i এর সংঘটনের পরের বছরেই শুরু হতে পারে।",
      "bg": "Напишете C функция `int apocalypseYear(int n, int signs[])`, за да решите следния проблем:\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че обратното броене за събитие i+1 може да започне само в годината, непосредствено следваща след настъпването на събитие i.",
      "zh": "编写一个 C 函数 `int apocalypseYear(int n, int signs[])` 来解决以下问题：  \n给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。",
      "fr": "Écrire une fonction C `int apocalypseYear(int n, int signs[])` pour résoudre le problème suivant :\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, à condition que le compte à rebours pour l'événement i+1 ne puisse commencer que l'année suivant immédiatement la survenue de l'événement i.",
      "de": "Schreiben Sie eine C-Funktion `int apocalypseYear(int n, int signs[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten. Das Problem besteht darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i beginnen kann.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "ha": "Rubuta aikin C `int apocalypseYear(int n, int signs[])` don warware matsalar mai zuwa:\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na shekaru a_i, matsalar ita ce nemo shekarar Y_n lokacin da abin n-th ya faru, a ƙarƙashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i.",
      "hi": "C फ़ंक्शन `int apocalypseYear(int n, int signs[])` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nदिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब n-वीं घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद के वर्ष में ही शुरू हो सकती है।",
      "hu": "Írj egy C függvényt `int apocalypseYear(int n, int signs[])`, hogy megoldja a következő problémát:  \nAdott egy n eseményből álló sorozat, ahol minden esemény a_i évenként ismétlődik, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődhet meg.  \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})  \n    36  "
    },
    "instruction_bertscore": {
      "sq": "0.990195604392118",
      "hy": "0.965691964696511",
      "bn": "0.8993953010488774",
      "bg": "0.9102260198355667",
      "zh": "0.8786664331144575",
      "fr": "0.8984035395563702",
      "de": "0.9791173921506591",
      "ha": "0.8810074907853347",
      "hi": "0.8778397334685903",
      "hu": "0.943607643041909"
    },
    "level": "easy",
    "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the n-th event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n",
      "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո տարում:\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "bn": "একটি n ঘটনাবলীর ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, সমস্যাটি হল n-তম ঘটনা যে বছর Y_n এ ঘটে তা খুঁজে বের করা, এই শর্তের অধীনে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরবর্তী বছরেই শুরু হতে পারে। \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "bg": "Като се даде последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща настъпването на събитие i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "zh": "给定一个长度为 n 的事件序列，每个事件以 a_i 年的周期发生，问题是找出第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le n-ième événement se produit, sous la condition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année suivant immédiatement la survenue de l'événement i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "de": "Angenommen, es gibt eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten des Ereignisses i beginnen kann. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce gano shekarar Y_n lokacin da abin n-th ya faru, a karkashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a shekarar da ke biye da faruwar abin i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hi": "दिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, समस्या यह है कि nवीं घटना के घटित होने वाले वर्ष Y_n को खोजना है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है। \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "hu": "Adott egy n eseményből álló sorozat, amelyek mindegyike a_i évek periodicitással következik be, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36"
    },
    "docstring_bertscore": {
      "sq": "0.9912461604774114",
      "hy": "0.9396235148591112",
      "bn": "0.9282364323751432",
      "bg": "0.9767115809755645",
      "zh": "0.9445982127521301",
      "fr": "0.9858410305486901",
      "de": "0.9660643966609515",
      "ha": "0.9562760901139332",
      "hi": "0.9659325060879442",
      "hu": "0.9657861154971216"
    }
  },
  {
    "task_id": "C/33",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y. Përndryshe, ndani x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Atëherë rezultati është mbetja e x' e ndarë me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të thjeshtë p, do të ketë disa kërkesa. Për secilën kërkesë, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth., prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nԱյս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշված է \"⊕\" սիմվոլով: Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի բաժանումից y-ի մնացորդն է: Հակառակ դեպքում, բազմիցս բաժանեք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x': Ապա արդյունքը x'-ի բաժանումից y-ի մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, և լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হবে x কে y দ্বারা ভাগ করলে যে অবশিষ্টাংশ থাকে তা। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হবে x' কে y দ্বারা ভাগ করলে যে অবশিষ্টাংশ থাকে তা। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হবে, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nТози проблем въвежда нова операция модуло, означена със символа \"⊕\". При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от делението на x на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като отбелязвате крайната стойност като x'. Тогава резултатът е остатъкът от делението на x' на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n, и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n这个问题引入了一种新的模运算，用符号“⊕”表示。计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，记最终值为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de la division de x par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de la division de x' par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nWannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne saura na x raba da y. In ba haka ba, raba x da y akai-akai har sai x ba shi ne sau na y ba, yana nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne saura na x' raba da y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lambar farko p, za a sami tambayoyi da yawa. Ga kowace tambaya, ana ba da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobin da suka fi n ƙasa ko daidai da n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nयह समस्या एक नया माड्यूलो ऑपरेशन प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने का शेषफल होता है। अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से विभाजित करने का शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nदिए गए एक अभाज्य संख्या p के लिए, कई प्रश्न होंगे। प्रत्येक प्रश्न के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, अर्थात् n से कम या उसके बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y osztásakor. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként. Ekkor az eredmény x' maradéka y osztásakor. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes pozitív egész szám szorzata, amelyek kisebbek vagy egyenlők n-nél.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "sq": "0.9878259439463717",
      "hy": "0.9763582175277035",
      "bn": "0.9547253827291938",
      "bg": "0.9804273595135842",
      "zh": "0.9728692748848257",
      "fr": "0.9756792988853262",
      "de": "0.9839913844404932",
      "ha": "0.9780302880752552",
      "hi": "0.9827342527589233",
      "hu": "0.972558021077744"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "sq": "Shkruani një funksion në C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` për të zgjidhur problemin e mëposhtëm:\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x pjesëtuar me y. Përndryshe, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'. Pastaj rezultati është mbetja e x' pjesëtuar me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë prim p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth, prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "hy": "Գրեք C ֆունկցիա `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)`՝ հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներմուծում է նոր մոդուլո գործողություն, որը նշվում է \"⊕\" նշանով: Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է: Հակառակ դեպքում, բաժանեք x-ը y-ով կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x': Ապա արդյունքը x'-ի y-ով բաժանման մնացորդն է: Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n    >>> newModuloFactorial(3, 7)\n    6",
      "bn": "একটি C ফাংশন `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন প্রবর্তন করে, যা \"⊕\" প্রতীকে চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হল x কে y দ্বারা ভাগ করার পরে যে ভাগশেষ থাকে। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হল x' কে y দ্বারা ভাগ করার পরে যে ভাগশেষ থাকে। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হয়েছে, এবং বেশ কয়েকটি অনুসন্ধান থাকবে। প্রতিটি অনুসন্ধানের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n    >>> newModuloFactorial(3, 7)\n    6",
      "bg": "Напишете C функция `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)`, за да решите следния проблем:\nТози проблем въвежда нова операция за модул, обозначена със символа \"⊕\". Когато изчислявате x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай разделяйте x на y многократно, докато x вече не е кратно на y, като крайната стойност се обозначава като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n, и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "zh": "编写一个 C 函数 `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` 来解决以下问题：\n此问题引入了一种新的模运算，用符号“⊕”表示。当计算 x ⊕ y 时，如果 x 不是 y 的倍数，则结果是 x 除以 y 的余数。否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，将会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6",
      "fr": "Écrire une fonction C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` pour résoudre le problème suivant :\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "de": "Schreiben Sie eine C-Funktion `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)`, um das folgende Problem zu lösen:\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben ist eine Primzahl p, es wird mehrere Abfragen geben. Für jede Abfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "ha": "Rubuta aikin C `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da sabon aiki na modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba sau biyu na y ba ne, sakamakon shine saura na x raba da y. In ba haka ba, a raba x da y akai-akai har sai x ba sau biyu na y ba ne, sannan a nuna ƙimar ƙarshe a matsayin x'. Sannan sakamakon shine saura na x' raba da y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lambar farko p, za a sami tambayoyi da dama. Ga kowace tambaya, an ba da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobi masu kyau da suka fi ko daidai da n.",
      "hi": "C फ़ंक्शन `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nयह समस्या एक नए मोड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से भाग देने पर शेषफल होता है। अन्यथा, x को y से बार-बार भाग दें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से भाग देने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान निकालने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> newModuloFactorial(3, 7)\n    6",
      "hu": "Írj egy C függvényt `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` a következő probléma megoldására:\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük az utolsó értéket x'-ként. Ekkor az eredmény x' maradéka y-nal osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, és több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n, és ki kell számítanod n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "instruction_bertscore": {
      "sq": "0.9895395282435597",
      "hy": "0.9744295165278547",
      "bn": "0.9534557373336188",
      "bg": "0.9918567502687127",
      "zh": "0.9641803874968355",
      "fr": "0.9920849765765217",
      "de": "0.9843723575113181",
      "ha": "0.9594509981243948",
      "hi": "0.966824753759553",
      "hu": "0.973566268891877"
    },
    "level": "easy",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\". When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y. Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'. Then the result is the remainder of x' divided by y. For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given, and you need to compute the value of n! ⊕ p, where n! is the factorial of n, i.e., the product of all positive integers less than or equal to n.\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\". Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y. Përndryshe, ndaj x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke shënuar vlerën përfundimtare si x'. Pastaj rezultati është mbetja e x' e ndarë me y. Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të thjeshtë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n, dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n, dmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "hy": "Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" սիմվոլով։ Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է։ Հակառակ դեպքում, բաժանեք x-ը y-ի վրա բազմիցս, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x'։ Ապա արդյունքը x'-ի y-ով բաժանման մնացորդն է։ Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4։ Տրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ։ Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է, այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը։\n    >>> newModuloFactorial(3, 7)\n    6",
      "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত। যখন x ⊕ y গণনা করা হয়, যদি x y-এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দ্বারা ভাগ করার পরে অবশিষ্টাংশ। অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y-এর গুণিতক থাকে না, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' কে y দ্বারা ভাগ করার পরে অবশিষ্টাংশ। উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bg": "Този проблем въвежда нова операция за модуло, обозначена със символа \"⊕\". При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като отбелязвате крайната стойност като x'. Тогава резултатът е остатъкът от x', разделен на y. Например, 4⊕5=4, 20⊕5=4, 100⊕5=4. Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n, и трябва да изчислите стойността на n! ⊕ p, където n! е факториалът на n, т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "zh": "这个问题引入了一种新的取模运算，用符号“⊕”表示。当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。否则，重复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。然后结果是 x' 除以 y 的余数。例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，即小于或等于 n 的所有正整数的乘积。\n    >>> newModuloFactorial(3, 7)\n    6",
      "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\". Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y. Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'. Ensuite, le résultat est le reste de x' divisé par y. Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné, et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n, c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "de": "Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" bezeichnet wird. Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y. Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird. Dann ist das Ergebnis der Rest von x' geteilt durch y. Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben, und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist, d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "ha": "Wannan matsala ta gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\". Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne saura na x da aka raba da y. In ba haka ba, a raba x da y akai-akai har sai x ba shi ne sau na y ba, ana nuna ƙimar ƙarshe da x'. Sannan sakamakon shi ne saura na x' da aka raba da y. Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4. Idan aka ba da lambar firam p, za a sami tambayoyi da yawa. Ga kowace tambaya, ana ba da cikakken lamba n, kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, wato, samfurin duk lambobi masu kyau waɗanda suka fi ƙarami ko daidai da n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "hi": "यह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। जब x ⊕ y की गणना की जाती है, यदि x y का गुणज नहीं है, तो परिणाम x को y से भाग देने पर शेषफल होता है। अन्यथा, x को y से बार-बार भाग दें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' को y से भाग देने पर शेषफल होता है। उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, और आपको n! ⊕ p का मान निकालना है, जहाँ n! n का फैक्टोरियल है, यानी n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n    >>> newModuloFactorial(3, 7)\n    6",
      "hu": "Ez a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl. Amikor az x ⊕ y értéket számítjuk ki, ha x nem osztható y-nal, az eredmény x maradéka y-val osztva. Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-vel. Ekkor az eredmény x' maradéka y-val osztva. Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy n egész szám, és ki kell számítanod az n! ⊕ p értékét, ahol n! az n faktoriálisa, azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nél.\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9916547431712002",
      "hy": "0.9870014292346959",
      "bn": "0.975268332626965",
      "bg": "0.9932495465005293",
      "zh": "0.9759333471426699",
      "fr": "0.9918825722182473",
      "de": "0.9822201973328051",
      "ha": "0.9803157292394425",
      "hi": "0.9680236867394796",
      "hu": "0.9653280738384551"
    }
  },
  {
    "task_id": "C/34",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë që të gjitha elementet në varg të jenë të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար:\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতোমাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। তুমি সর্বাধিক একটি অপারেশন করতে পারো যেখানে তুমি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন কর এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন কর, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের কর।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个包含 n 个整数的数组 a。你可以最多执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein Array a mit n Ganzzahlen. Sie können höchstens eine Operation ausführen, bei der Sie drei Ganzzahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da aiki daya kawai inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin tsari su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "sq": "0.9933754781621055",
      "hy": "0.957573345132472",
      "bn": "0.9959525087256521",
      "bg": "0.9956928988176394",
      "zh": "0.9852304407573889",
      "fr": "0.9987156559562285",
      "de": "0.9879512797168047",
      "ha": "0.9731995972084867",
      "hi": "0.995656152197148",
      "hu": "0.9723689249549988"
    },
    "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "Write a C function `int makeEqualAgain(int n, int a[])` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n",
      "sq": "Shkruani një funksion në C `int makeEqualAgain(int n, int a[])` për të zgjidhur problemin e mëposhtëm:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni në maksimum një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hy": "Գրեք C ֆունկցիա `int makeEqualAgain(int n, int a[])`՝ լուծելու հետևյալ խնդիրը:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար:\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "bn": "C ফাংশন `int makeEqualAgain(int n, int a[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।",
      "bg": "Напишете C функция `int makeEqualAgain(int n, int a[])`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "zh": "编写一个 C 函数 `int makeEqualAgain(int n, int a[])` 来解决以下问题：  \n给定一个包含 n 个整数的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最小代价。  \n    >>> makeEqualAgain(3, (int[]){1, 2, 1})  \n    1  ",
      "fr": "Écrivez une fonction C `int makeEqualAgain(int n, int a[])` pour résoudre le problème suivant :  \nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).  \nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.  \n    >>> makeEqualAgain(3, (int[]){1, 2, 1})  \n    1  ",
      "de": "Schreiben Sie eine C-Funktion `int makeEqualAgain(int n, int a[])`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu einem Kostenaufwand von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "ha": "Rubuta aikin C `int makeEqualAgain(int n, int a[])` don magance matsalar mai zuwa:\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da mafi yawan aiki daya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hi": "C फ़ंक्शन `int makeEqualAgain(int n, int a[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।",
      "hu": "Írj egy C függvényt `int makeEqualAgain(int n, int a[])` a következő probléma megoldására:\nAdott egy n egész számot tartalmazó tömb a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"
    },
    "instruction_bertscore": {
      "sq": "0.9924870044677364",
      "hy": "0.9651312311308495",
      "bn": "0.9469289416431934",
      "bg": "0.9986501079304869",
      "zh": "0.9852550709246372",
      "fr": "0.9987345258424267",
      "de": "0.9912755577738046",
      "ha": "0.9911893521884355",
      "hi": "0.9383542667242983",
      "hu": "0.979338467764751"
    },
    "level": "middle",
    "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni më së shumti një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hy": "Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সব উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সব উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "bg": "Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "zh": "你有一个包含 n 个整数的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "fr": "Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1).\nFinde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "ha": "An a ba ka wani tsari a na n lambobi. Za ka iya aiwatar da akalla daya aiki inda ka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ka maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1). Nemo mafi ƙarancin farashi don sanya dukkan abubuwa a cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hi": "आपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत का पता लगाएं।\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "hu": "Meg van adva egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9952344598982109",
      "hy": "0.9507007339486649",
      "bn": "0.9961175705722921",
      "bg": "0.9854370163536651",
      "zh": "0.9847461798884257",
      "fr": "0.9919121681450215",
      "de": "0.9884001843779435",
      "ha": "0.9381355746747789",
      "hi": "0.9964165092957495",
      "hu": "0.978650412124846"
    }
  },
  {
    "task_id": "C/35",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, ku secili grumbull përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է դրական քանակությամբ քարեր, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են դրական քանակությամբ քարեր ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ։ Խաղացողը, որը կարող է միայն քարեր տեղափոխել վերջին կույտում, պարտվում է։ Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են լավագույն հնարավոր ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը։\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nধরা যাক একটি N সংখ্যক পাথরের স্তূপের ক্রম আছে যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরায়। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খুঁজে বের করুন কে গেমটি জিতবে।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни. Определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Предполагайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, tare da kowanne tarin yana dauke da adadin duwatsu masu kyau, tantance wanda zai ci nasara a wani wasa da Charlie da Dan suka buga. Charlie ne zai fara, kuma suna jujjuya daukar adadin duwatsu daga tarin da ba komai a hagu zuwa tarin dama kusa da shi. Dan wasan da zai iya motsa duwatsu kawai a cikin tarin karshe zai yi rashin nasara. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci nasara a wasan.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदी गई N पत्थरों के ढेरों की अनुक्रमणिका, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या ले जाते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सर्वोत्तम संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy N halomból álló kőhalom sorozat, amelyeket 1-től N-ig számoztak meg, és mindegyik halom pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék nyertesét. Charlie kezd, és felváltva mozgatnak pozitív számú követ a bal szélső nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, ki nyeri meg a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])"
    },
    "prompt_bertscore": {
      "sq": "0.9877300054723318",
      "hy": "0.9862549762627668",
      "bn": "0.9529025517224367",
      "bg": "0.9821143273397135",
      "zh": "0.9442492191726517",
      "fr": "0.9859915923775145",
      "de": "0.9792290224248007",
      "ha": "0.9367761483469761",
      "hi": "0.9574631052709976",
      "hu": "0.9394667954884747"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "Write a C function `const char* gameWinner(int n, int piles[])` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n",
      "sq": "Shkruani një funksion në C `const char* gameWinner(int n, int piles[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin ngjitur në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hy": "Գրեք C ֆունկցիա `const char* gameWinner(int n, int piles[])`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից մինչև N, և յուրաքանչյուր կույտ պարունակում է դրական քանակությամբ քարեր, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են դրական քանակությամբ քարեր ձախից աջ հարևան կույտ: Խաղացողը, որը կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "bn": "C ফাংশন `const char* gameWinner(int n, int piles[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি পাইল একটি পজিটিভ সংখ্যক পাথর ধারণ করে, 1 থেকে N পর্যন্ত নম্বরযুক্ত পাথরের N পাইলের একটি ক্রম দেওয়া হয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না হওয়া পাইল থেকে ডানপাশের সংলগ্ন পাইলে একটি পজিটিভ সংখ্যক পাথর সরায়। যে খেলোয়াড় শুধুমাত্র শেষ পাইলে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।",
      "bg": "Напишете C функция `const char* gameWinner(int n, int piles[])`, за да решите следния проблем:  \nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв, и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.",
      "zh": "编写一个 C 函数 `const char* gameWinner(int n, int piles[])` 来解决以下问题：  \n给定一个编号从 1 到 N 的石堆序列，每堆包含正数的石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。  \n    >>> gameWinner(3, 1, 2, 2)  \n    \"Dan\"",
      "fr": "Écrire une fonction C `const char* gameWinner(int n, int piles[])` pour résoudre le problème suivant :\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "de": "Schreiben Sie eine C-Funktion `const char* gameWinner(int n, int piles[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "ha": "Rubuta aikin C `const char* gameWinner(int n, int piles[])` don warware matsalar mai zuwa:  \nAn ba da jerin N na tarkon duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin yana dauke da adadi mai kyau na duwatsu, tantance wanda zai ci nasara a wasan da Charlie da Dan suka buga. Charlie yana farawa, kuma suna juyawa suna motsa adadi mai kyau na duwatsu daga tarkon da ba komai a hagu zuwa tarkon da ke makwabta a dama. Dan wasan da kawai zai iya motsa duwatsu a cikin tarkon karshe ya rasa. Ana tsammanin duk 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci nasara a wasan.",
      "hi": "C फ़ंक्शन `const char* gameWinner(int n, int piles[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पत्थरों के N ढेरों की एक श्रृंखला, जिन्हें 1 से N तक क्रमांकित किया गया है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, उस खेल के विजेता का निर्धारण करें जो चार्ली और डैन द्वारा खेला जाता है। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में पत्थरों की एक सकारात्मक संख्या को स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। मान लीजिए कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, पता लगाएं कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hu": "Írj egy C függvényt `const char* gameWinner(int n, int piles[])` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, és mindegyik halom pozitív számú követ tartalmaz. Határozd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud követ mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki, ki fogja megnyerni a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""
    },
    "instruction_bertscore": {
      "sq": "0.9876122176563782",
      "hy": "0.932988862871784",
      "bn": "0.9405370159814906",
      "bg": "0.9612990551895434",
      "zh": "0.9605230062908401",
      "fr": "0.9844180424989561",
      "de": "0.9719567669143514",
      "ha": "0.9299194275936518",
      "hi": "0.9776451437664285",
      "hu": "0.9690883455818265"
    },
    "level": "middle",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, int piles[])",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can only move stones in the last pile loses. Assuming both players use the best possible strategy, find out who will win the game.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari dhe ata marrin radhën duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinjë në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni se kush do të fitojë lojën.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hy": "Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ: Պետք է որոշել, թե ով կհաղթի խաղում, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է խաղում, և նրանք հերթով տեղափոխում են քարերի դրական քանակ ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: Այն խաղացողը, որը կարող է միայն տեղափոխել քարեր վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը:\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "bn": "একটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যেগুলি 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না থাকা স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। যে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খুঁজে বের করুন কে গেমটি জিতবে।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват положителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, който може да премести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват възможно най-добрата стратегия, разберете кой ще спечели играта.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "zh": "给定一个编号为1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流从最左边的非空堆中移动正数的石头到相邻的右边堆。只能在最后一堆移动石头的玩家输掉比赛。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, die von 1 bis N nummeriert sind, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie wechseln sich ab, indem sie eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin dauke da adadin duwatsu masu kyau, tantance wanda zai ci wasa da Charlie da Dan suka buga. Charlie yana farawa, kuma suna juyawa suna motsa adadin duwatsu masu kyau daga tarin da ba komai a hagu zuwa tarin da ke kusa a dama. Dan wasan da zai iya motsa duwatsu kawai a cikin tarin karshe zai rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru mai yiwuwa, gano wanda zai ci wasan.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hi": "दी गई N पत्थरों के ढेरों की अनुक्रमणिका, जो 1 से N तक क्रमांकित हैं, और प्रत्येक ढेर में सकारात्मक संख्या में पत्थर हैं, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन होगा। चार्ली पहले जाता है, और वे बारी-बारी से बाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में सकारात्मक संख्या में पत्थर ले जाते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, पता करें कि खेल कौन जीतेगा।\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "hu": "Adott egy N kövekből álló sorozat, amelyeket 1-től N-ig számoznak, és minden halom pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, ki nyeri meg a játékot.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.9871527855850445",
      "hy": "0.9489339167093596",
      "bn": "0.9488250672605525",
      "bg": "0.9889621097258913",
      "zh": "0.9619301039100913",
      "fr": "0.9801288180508888",
      "de": "0.9593677719947412",
      "ha": "0.8973442437343112",
      "hi": "0.930393359682801",
      "hu": "0.959343737718636"
    }
  },
  {
    "task_id": "C/36",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից։ Յուրաքանչյուր քայլում խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այդ դիրքում դուռը բացելու համար։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար։\nԽնդիրը կայանում է որոշել բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը։\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nবৃত্তাকারে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i নির্বাচন করতে পারে এবং i ধাপ ডানদিকে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে পারে। এটি নিশ্চিত করা হয়েছে যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nসমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 个门按圆形排列，玩家从门 1 前面开始。每一回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben sind n Türen, die in einem Kreis angeordnet sind. Der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kostenbetrag C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne a tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk ƙofofin.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} है जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1. ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)"
    },
    "prompt_bertscore": {
      "sq": "0.997489311983719",
      "hy": "0.9756598331079848",
      "bn": "0.9665826233250715",
      "bg": "0.9838513500218636",
      "zh": "0.9982393403025067",
      "fr": "0.997489311983719",
      "de": "0.9806492296492002",
      "ha": "0.9819788614198477",
      "hi": "0.9724142126818748",
      "hu": "0.9693497431632685"
    },
    "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}",
    "instruction": {
      "en": "Write a C function `long long minTotalCost(int n, int *C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "sq": "Shkruani një funksion në C `long long minTotalCost(int n, int *C)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hy": "Գրեք C ֆունկցիա `long long minTotalCost(int n, int *C)`՝ լուծելու հետևյալ խնդիրը:\nՏրված են n դռներ, որոնք դասավորված են շրջանաձև: Խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այնուհետև այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշելու բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bn": "একটি C ফাংশন `long long minTotalCost(int n, int *C)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn টি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে পারে। এটা নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bg": "Напишете C функция `long long minTotalCost(int n, int *C)`, за да решите следния проблем:  \nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "zh": "编写一个 C 函数 `long long minTotalCost(int n, int *C)` 来解决以下问题：  \n给定 n 扇门排列成一个圆圈，玩家从门 1 前面开始。每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    >>> minTotalCost(3, (1, 1, 1))  \n    3  ",
      "fr": "Écrire une fonction C `long long minTotalCost(int n, int *C)` pour résoudre le problème suivant :  \nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "de": "Schreiben Sie eine C-Funktion `long long minTotalCost(int n, int *C)`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "ha": "Rubuta aikin C `long long minTotalCost(int n, int *C)` don warware matsalar mai zuwa:\nAn ba da ƙofofi n waɗanda aka shirya a cikin madauwari, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowanne juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne ƙayyade mafi ƙarancin jimillar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hi": "C फ़ंक्शन `long long minTotalCost(int n, int *C)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और उस स्थिति पर दरवाजा खोलने के लिए i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hu": "Írj egy C függvényt `long long minTotalCost(int n, int *C)` a következő probléma megoldására:\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy i számot, és kifizethet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.991687517184071",
      "hy": "0.9679760154480311",
      "bn": "0.9711149713595255",
      "bg": "0.988186259457569",
      "zh": "0.9923050590387085",
      "fr": "0.9962488652541561",
      "de": "0.9795426597964548",
      "ha": "0.9900494124316762",
      "hi": "0.950524747431068",
      "hu": "0.9792161114500334"
    },
    "level": "easy",
    "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, int *C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "sq": "Duke pasur parasysh n dyer të vendosura në një rreth, lojtari fillon përpara derës 1. Çdo herë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n. Detyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hy": "Տրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը որոշելու մեջ:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডান দিকে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে হয়। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n। \nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. На всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "zh": "给定 n 个按圆形排列的门，玩家从门 1 前开始。每一回合，玩家可以选择一个数字 i，并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. Bei jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i bezahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "ha": "An ba da ƙofofi n da aka shirya a cikin madauwari, mai kunnawa yana farawa a gaban ƙofa ta 1. Kowanne juyi, mai kunnawa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne ƙayyade mafi ƙarancin jimlar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह सुनिश्चित किया गया है कि C_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy i számot, és kifizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén. A feladat az, hogy meghatározzuk az összes ajtó kinyitásához szükséges minimális összköltséget.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9857995167990538",
      "hy": "0.9744603042369151",
      "bn": "0.9523336743111527",
      "bg": "0.9931810190190723",
      "zh": "0.9932900670982604",
      "fr": "0.9895613775854735",
      "de": "0.9854433725258582",
      "ha": "0.9856628590969018",
      "hi": "0.9488397659087491",
      "hu": "0.9794884337024323"
    }
  },
  {
    "task_id": "C/37",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվարկեք ձեռքսեղմումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի դասարանում արդեն գտնվող յուրաքանչյուր ուսանողի հետ, ում ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nশ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্ররা শ্রেণীকক্ষে প্রবেশ করার ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадена е последователност от студентски ID-та, влизащи в класната стая, където ID-тата варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък ID номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n例子:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der stattfindenden Händeschütteln. Jeder Student wird jedem Studenten, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da jerin lambobin ID na ɗalibai masu shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da kowane ɗalibi da ke cikin aji wanda ke da ƙaramin lamba ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nछात्र आईडी की एक अनुक्रम को देखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें जो होती है। प्रत्येक छात्र हर उस छात्र से हाथ मिलाएगा जो पहले से ही कक्षा में है और जिसका आईडी नंबर छोटा है। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nEgy osztályterembe belépő diákok azonosítóinak sorozata alapján, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások összes számát. Minden diák kezet fog minden már a teremben lévő diákkal, akinek kisebb az azonosító száma. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek a terembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])"
    },
    "prompt_bertscore": {
      "sq": "0.9758270798888162",
      "hy": "0.9798654341656365",
      "bn": "0.9622471179982229",
      "bg": "0.9919330243350301",
      "zh": "0.989119623618052",
      "fr": "0.9973476885220411",
      "de": "0.9848427142536087",
      "ha": "0.9620494807690932",
      "hi": "0.9864742642034293",
      "hu": "0.97264363077197"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `long long countHandshakes(int n, int order[])` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n",
      "sq": "Shkruani një funksion C `long long countHandshakes(int n, int order[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër më të vogël ID-je. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hy": "Գրեք C ֆունկցիա `long long countHandshakes(int n, int order[])`՝ լուծելու համար հետևյալ խնդիրը:\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասասենյակ, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք ընդհանուր ձեռքսեղմումների քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի դասասենյակում արդեն եղած յուրաքանչյուր ուսանողի հետ, որի ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասասենյակ մտնելու կարգը։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "bn": "একটি C ফাংশন `long long countHandshakes(int n, int order[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র তার চেয়ে ছোট আইডি নম্বরের সাথে ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে। ক্রমটি শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "bg": "Напишете C функция `long long countHandshakes(int n, int order[])`, за да решите следния проблем:  \nДадена е последователност от ID на ученици, които влизат в класната стая, където ID-тата варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък номер на ID. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "zh": "编写一个 C 函数 `long long countHandshakes(int n, int order[])` 来解决以下问题：  \n给定一个进入教室的学生 ID 序列，其中 ID 范围从 0 到 N-1，计算发生的握手总数。每个学生将与教室中所有 ID 小于自己的学生握手。该序列表示学生进入教室的顺序。  \n\n示例:  \n    >>> countHandshakes(3, (2, 1, 0))  \n    0  ",
      "fr": "Écrire une fonction C `long long countHandshakes(int n, int order[])` pour résoudre le problème suivant :\nÉtant donné une séquence d'identifiants d'étudiants entrant dans une salle de classe, où les identifiants vont de 0 à N-1, calculer le nombre total de poignées de main qui ont lieu. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un identifiant plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "de": "Schreiben Sie eine C-Funktion `long long countHandshakes(int n, int order[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von Schüler-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Schüler wird mit jedem Schüler, der sich bereits im Klassenzimmer befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler das Klassenzimmer betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "ha": "Rubuta aikin C `long long countHandshakes(int n, int order[])` don warware matsalar mai zuwa:\nAn ba da jerin lambobin ID ɗalibai masu shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, ƙididdige jimillar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da kowane ɗalibi da ke cikin aji wanda ke da ƙaramin lamba na ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hi": "C फ़ंक्शन `long long countHandshakes(int n, int order[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nछात्र आईडी के अनुक्रम को देखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनकी आईडी संख्या छोटी है। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hu": "Írj egy C függvényt `long long countHandshakes(int n, int order[])`, hogy megoldja a következő problémát:\nEgy osztályterembe belépő diákok azonosítóinak sorozata adott, ahol az azonosítók 0-tól N-1-ig terjednek. Számold ki a kézfogások összesített számát. Minden diák kezet fog minden már az osztályteremben lévő diákkal, akinek az azonosítója kisebb. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0"
    },
    "instruction_bertscore": {
      "sq": "0.9966222903705018",
      "hy": "0.974311927342282",
      "bn": "0.959878649334763",
      "bg": "0.9946834592212201",
      "zh": "0.9657165948637594",
      "fr": "0.9894265075567509",
      "de": "0.9755579357225139",
      "ha": "0.9659060882472666",
      "hi": "0.9655535193209297",
      "hu": "0.9647542306676453"
    },
    "level": "middle",
    "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, int order[])",
    "docstring": {
      "en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n",
      "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hy": "Տրված է ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջունումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ողջունում է յուրաքանչյուր ուսանողի, ով արդեն դասարանում է ավելի փոքր ID-ով։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "bn": "একটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "bg": "Дадена е последователност от идентификатори на ученици, влизащи в класната стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък идентификационен номер. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n示例：\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "de": "Gegeben ist eine Sequenz von Schüler-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Schüler wird mit jedem Schüler, der sich bereits im Klassenzimmer befindet und eine kleinere ID-Nummer hat, die Hand schütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler das Klassenzimmer betreten.\n\nBeispiele:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "ha": "An ba da jerin lambobin dalibai masu shiga aji, inda lambobin ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai gaisa hannu da kowanne dalibi da ke cikin aji wanda ke da karamin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hi": "छात्र आईडी के अनुक्रम को ध्यान में रखते हुए जो एक कक्षा में प्रवेश कर रहे हैं, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनका आईडी नंबर उससे छोटा है। अनुक्रम यह दर्शाता है कि छात्र किस क्रम में कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "hu": "Adott egy diákazonosítókból álló sorozat, akik belépnek egy tanterembe, ahol az azonosítók 0-tól N-1-ig terjednek. Számítsd ki a kézfogások teljes számát, amelyek előfordulnak. Minden diák kezet fog minden már a tanteremben lévő diákkal, akinek kisebb azonosító száma van. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek a tanterembe.\n\nPéldák:\n    >>> countHandshakes(3, (2, 1, 0))\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9954616930541149",
      "hy": "0.9504182815468333",
      "bn": "0.9405390022853011",
      "bg": "0.975046263860968",
      "zh": "0.9849857281279538",
      "fr": "0.9964894066455894",
      "de": "1",
      "ha": "0.9178188647810064",
      "hi": "0.951088460452445",
      "hu": "0.9540283887221424"
    }
  },
  {
    "task_id": "C/38",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e çdo numri nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n յուրաքանչյուր թվի քանակը,\nգտնել մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար\nայս թվերից կառուցված հաջորդականության։ Մոդը ամենամեծ թիվն է հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ։\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Առավելագույն արժեքին հասնող հաջորդականությունը (3,2,3,1,2,2) է։\n*/\nlong long maxModeSum(int n, const int* counts)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে,\nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সর্বাধিক ঘন ঘন উপাদান) \nসর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সর্বাধিক ঘন ঘন উপাদানগুলির মধ্যে \nবৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n*/\nlong long maxModeSum(int n, const int* counts)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, конструирана от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是序列中最频繁元素中最大的数字。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    达到其最大值的序列是 (3,2,3,1,2,2)。\n*/\nlong long maxModeSum(int n, const int* counts)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\ntrouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une\nséquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\nles éléments les plus fréquents dans une séquence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer \nSequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter \nden häufigsten Elementen in einer Sequenz.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lambobin n masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkanin farkon jerin\nda aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nabin da aka fi samu a cikin jerin.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nइन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें।\nमोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n*/\nlong long maxModeSum(int n, const int* counts)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát képviselik,\nkeresse meg a módusz (leggyakoribb elem) maximális összegét az ezekből a számokból\nfelépített sorozat összes prefixére. A módusz a legnagyobb szám a sorozat\nleggyakoribb elemei között.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "sq": "0.9943326779683126",
      "hy": "0.9767364097731939",
      "bn": "0.9714609854832883",
      "bg": "0.9903412004614165",
      "zh": "0.9478440318086211",
      "fr": "0.9702626483945048",
      "de": "0.999999801369619",
      "ha": "0.9279001511400511",
      "hi": "0.9453450629848212",
      "hu": "0.9716337939147887"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `long long maxModeSum(int n, const int* counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "sq": "Shkruani një funksion në C `long long maxModeSum(int n, const int* counts)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,  \ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e  \nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.  \n    >>> maxModeSum(3, (int[]){1, 2, 3})  \n    17  \n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Գրեք C ֆունկցիա `long long maxModeSum(int n, const int* counts)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտեք մոդի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար \nայդ թվերից կառուցված հաջորդականության: Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի \nմեջ ամենամեծ թիվն է:\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է:",
      "bn": "একটি C ফাংশন `long long maxModeSum(int n, const int* counts)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনার প্রতিনিধিত্বকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, \nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Напишете C функция `long long maxModeSum(int n, const int* counts)`, за да решите следния проблем:  \nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,  \nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на  \nпоследователност, конструирана от тези числа. Модата е най-голямото число сред  \nнай-често срещаните елементи в последователност.  \n    >>> maxModeSum(3, (int[]){1, 2, 3})  \n    17  \n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).  ",
      "zh": "编写一个 C 函数 `long long maxModeSum(int n, const int* counts)` 来解决以下问题：  \n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，  \n找到从这些数字构建的序列的所有前缀的众数（最频繁元素）的最大和。众数是在序列中最频繁元素中最大的数字。  \n    >>> maxModeSum(3, (int[]){1, 2, 3})  \n    17  \n    一个达到其最大值的序列是 (3,2,3,1,2,2)。  ",
      "fr": "Écrire une fonction C `long long maxModeSum(int n, const int* counts)` pour résoudre le problème suivant :  \nÉtant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,  \ntrouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.  \n    >>> maxModeSum(3, (int[]){1, 2, 3})  \n    17  \n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).  ",
      "de": "Schreiben Sie eine C-Funktion `long long maxModeSum(int n, const int* counts)`, um das folgende Problem zu lösen:  \nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen.  \nFinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.  \n    >>> maxModeSum(3, (int[]){1, 2, 3})  \n    17  \n    Eine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).  ",
      "ha": "Rubuta aikin C `long long maxModeSum(int n, const int* counts)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jumlar yanayin (mafi yawan abu) don dukkan farkon\nwani jere da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nmafi yawan abubuwa a cikin jere.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Jere wanda ya kai darajarsa mafi girma shine (3,2,3,1,2,2).",
      "hi": "C फ़ंक्शन `long long maxModeSum(int n, const int* counts)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, \nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें \nजो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Írj egy C függvényt `long long maxModeSum(int n, const int* counts)` a következő probléma megoldására:  \nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulásainak számát képviselik,  \ntaláld meg a módusz (a leggyakrabban előforduló elem) maximális összegét az  \nezekből a számokból felépített sorozat minden prefixére. A módusz a sorozatban  \nleggyakrabban előforduló elemek közül a legnagyobb szám.  \n    >>> maxModeSum(3, (int[]){1, 2, 3})  \n    17  \n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).  "
    },
    "instruction_bertscore": {
      "sq": "0.9887809588183875",
      "hy": "0.9767000604134645",
      "bn": "0.9795976804120015",
      "bg": "0.985504749313598",
      "zh": "0.9847662415569103",
      "fr": "1",
      "de": "0.9917562432959091",
      "ha": "0.9793197965089336",
      "hi": "0.9496611025343283",
      "hu": "0.9520259958509296"
    },
    "level": "easy",
    "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n, \nfind the maximum sum of the mode (most frequent element) for all prefixes of \na sequence constructed from these numbers. The mode is the largest number among \nthe most frequent elements in a sequence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    A sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, \ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e \nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementet më të shpeshta në një sekuencë.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտնել բոլոր նախածանցների համար ռեժիմի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը \nայդ թվերից կառուցված հաջորդականության։ Ռեժիմը հաջորդականության ամենահաճախ հանդիպող տարրերի \nմեջ ամենամեծ թիվն է։\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Հաջորդականությունը, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։",
      "bn": "n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, \nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমে সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, \nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на \nпоследователност, съставена от тези числа. Модата е най-голямото число сред \nнай-често срещаните елементи в последователност.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀中众数（出现频率最高的元素）的最大和。众数是序列中出现频率最高的元素中最大的数字。\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    达到最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Gegeben sind n positive ganze Zahlen, die die Anzahl jedes einzelnen Wertes von 1 bis n darstellen. \nFinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Eine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).",
      "ha": "An bayar da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, \nnemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkan farkon jerin \nda aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin \nabin da aka fi samu a cikin jerin.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Wani jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, \nउन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें। \nमोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या होता है।\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelölik, \nkeresse meg az összes prefixum móduszának (leggyakoribb elemének) maximális összegét \negy ezekből a számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat \nleggyakoribb elemei között.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "sq": "0.9930397928181565",
      "hy": "0.968828537043433",
      "bn": "0.9779371304265498",
      "bg": "0.9760876829487339",
      "zh": "0.9465062561923512",
      "fr": "0.9999996027392379",
      "de": "0.9751936476036959",
      "ha": "0.9470868527961162",
      "hi": "0.9708724436642819",
      "hu": "0.9374216970853395"
    }
  },
  {
    "task_id": "C/39",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L deri në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՈւնենալով ամբողջ թվերի զանգված A, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপ-অ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপ-অ্যারে (L, R) জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপ-অ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপ-অ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n子数组的异或和是从L到R的所有元素的异或结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemples de cas :\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani tsari A na lambobin cikakke, aikin shi ne a ƙididdige jumlar XOR na dukkan ƙananan tsaruka.\nAna ayyana ƙaramin tsari ta hanyar ma'aurata na alamomin (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\nJumlar XOR na ƙaramin tsari shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jumlar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n\nMisalan lokuta:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-समुच्चयों के XOR का योग गणना करना है।\nएक उप-समुच्चय को (L, R) युग्म द्वारा परिभाषित किया जाता है जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक उप-समुच्चय का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-समुच्चयों के XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9931216285351429",
      "hy": "0.9715664582156178",
      "bn": "0.9660572459672342",
      "bg": "0.9931216285351429",
      "zh": "0.970337929308917",
      "fr": "0.9931216285351429",
      "de": "0.9931216285351429",
      "ha": "0.9804666883290291",
      "hi": "0.9662074105352966",
      "hu": "0.9659191978524149"
    },
    "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `long long sumOfXorSubarrays(int A[], int n)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "sq": "Shkruani një funksion në C `long long sumOfXorSubarrays(int A[], int n)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg A me numra të plotë, detyra është të llogaritet shuma e XOR të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hy": "Գրեք C ֆունկցիա `long long sumOfXorSubarrays(int A[], int n)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի A զանգված, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը արդյունքն է, որը ստացվում է L-ից R բոլոր տարրերի XOR-ով:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bn": "একটি C ফাংশন `long long sumOfXorSubarrays(int A[], int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bg": "Напишете C функция `long long sumOfXorSubarrays(int A[], int n)`, за да решите следния проблем:\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се дефинира от двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "zh": "编写一个C函数 `long long sumOfXorSubarrays(int A[], int n)` 来解决以下问题：  \n给定一个整数数组A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "fr": "Écrire une fonction C `long long sumOfXorSubarrays(int A[], int n)` pour résoudre le problème suivant :  \nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "de": "Schreiben Sie eine C-Funktion `long long sumOfXorSubarrays(int A[], int n)`, um das folgende Problem zu lösen:\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XOR aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "ha": "Rubuta aikin C `long long sumOfXorSubarrays(int A[], int n)` don warware matsalar mai zuwa:  \nAn ba da jerin A na lambobi, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.  \nAna ayyana ƙaramar jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.  \nJimillar XOR na ƙaramar jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.  \nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.  \n\nMisalan lokuta:  \n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)  \n    39  ",
      "hi": "C फ़ंक्शन `long long sumOfXorSubarrays(int A[], int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी subarrays के XOR का योग गणना करें।\nएक subarray को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक subarray का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित subarrays के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hu": "Írj egy C függvényt `long long sumOfXorSubarrays(int A[], int n)` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "instruction_bertscore": {
      "sq": "0.9924329770040949",
      "hy": "0.9840152200862173",
      "bn": "0.9774824654843609",
      "bg": "0.9881711635486103",
      "zh": "0.9613753292558608",
      "fr": "0.9917882227872556",
      "de": "0.9936672661918456",
      "ha": "0.9741766600527972",
      "hi": "0.9804313321212049",
      "hu": "0.9849505705505106"
    },
    "level": "middle",
    "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(int A[], int n)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve. Një nënvarg përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut. Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bn": "ইন্টিজারগুলির একটি অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত সাবঅ্যারের XOR এর যোগফল গণনা করা। একটি সাবঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেটি 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার। একটি সাবঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল। চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য সাবঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви. Подмасив се определя от двойка индекси (L, R) такива, че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "zh": "给定一个整数数组A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素的异或结果。  \n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XOR aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "ha": "An ba da jerin A na lambobin cikakkun lamba, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.\n\nMisalan lokuta:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hi": "दिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-ऐरे के XOR का योग गणना करना है।\nएक उप-ऐरे को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, और n array का आकार है।\nएक उप-ऐरे का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-ऐरे के XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hu": "Egy egész számokat tartalmazó A tömb esetén a feladat az összes részarray XOR összegének kiszámítása.  \nEgy részarray-t egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.  \nEgy részarray XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.  \nA végső eredmény az összes lehetséges részarray XOR összegeinek az összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "sq": "0.9923926550367448",
      "hy": "0.9757549770605005",
      "bn": "0.9621994467067746",
      "bg": "0.9876823341808835",
      "zh": "0.9711823070586963",
      "fr": "0.9907644818034018",
      "de": "0.9924031824469397",
      "ha": "0.9500033426808514",
      "hi": "0.9700580591020389",
      "hu": "0.964256860193534"
    }
  },
  {
    "task_id": "C/40",
    "prompt": {
      "en": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "sq": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "hy": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nՏրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "bn": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "bg": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.\nРазличните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "zh": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\n给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，a 和 b 是正整数且 b >= k。\n同一个数字的不同合法表示只计数一次。\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "fr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nÉtant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nDifférentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "de": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "ha": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nAn ba lambobi masu kyau guda biyu n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nDaban-daban bayyanar doka na lamba ɗaya ana ƙidaya su sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "hi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nदो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "hu": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nKét pozitív egész szám, n és k adott. Találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "sq": "0.9920033394899165",
      "hy": "0.9827177664372975",
      "bn": "0.9829928695150308",
      "bg": "0.9920033394899165",
      "zh": "0.978524679093651",
      "fr": "0.999999801369619",
      "de": "0.9863290653948927",
      "ha": "0.9920033394899165",
      "hi": "0.9824162455188865",
      "hu": "0.9401665703208606"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "en": "Write a C function `int countPowerNumbers(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Shkruani një funksion në C `int countPowerNumbers(int n, int k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.  \nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "hy": "Գրեք C ֆունկցիա `int countPowerNumbers(int n, int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n և k դրական ամբողջ թվերը, գտնել այն դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:",
      "bn": "একটি C ফাংশন `int countPowerNumbers(int n, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Напишете C функция `int countPowerNumbers(int n, int k)`, за да решите следния проблем:  \nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b, като a и b са положителни цели числа и b >= k.  \nРазличните легални представяния на едно и също число се броят само веднъж.",
      "zh": "编写一个 C 函数 `int countPowerNumbers(int n, int k)` 来解决以下问题：  \n给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，使得 x 可以表示为 x = a^b，其中 a 和 b 为正整数且 b >= k。  \n同一个数字的不同合法表示只计算一次。  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "fr": "Écrire une fonction C `int countPowerNumbers(int n, int k)` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.  \nDifférentes représentations légales du même nombre sont comptées une seule fois.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "de": "Schreiben Sie eine C-Funktion `int countPowerNumbers(int n, int k)`, um das folgende Problem zu lösen:\nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.",
      "ha": "Rubuta aikin C `int countPowerNumbers(int n, int k)` don warware matsalar mai zuwa:\nAn ba da lambobi biyu masu kyau n da k, nemo adadin lambobin da suka dace x, inda 1 <= x <= n, wanda za a iya bayyana shi a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nAna ƙidaya wakilci daban-daban na doka na lamba ɗaya sau ɗaya kawai.",
      "hi": "C फ़ंक्शन `int countPowerNumbers(int n, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो धनात्मक पूर्णांक n और k, ऐसे धनात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।",
      "hu": "Írj egy C függvényt `int countPowerNumbers(int n, int k)` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző legális ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "instruction_bertscore": {
      "sq": "0.9877748959384457",
      "hy": "0.9494553214595761",
      "bn": "0.9251109833295592",
      "bg": "0.9579451812057693",
      "zh": "0.9605029446223556",
      "fr": "0.9999996027392379",
      "de": "0.944449835857497",
      "ha": "0.9571548309196315",
      "hi": "0.9522971263210422",
      "hu": "0.9698842575186334"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hy": "Երկու դրական ամբողջ թիվ n և k ունենալով, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n শর্তে কতগুলি ধনাত্মক পূর্ণসংখ্যা x পাওয়া যাবে তা খুঁজে বের করুন, যা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে কেবল একবারই গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n相同数字的不同合法表示仅计数一次。\n    >>> countPowerNumbers(99, 1)\n    99",
      "fr": "Étant donnés deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nLes différentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene gültige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "An ba lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Két pozitív egész szám, n és k esetén találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok, és b >= k. Ugyanazon szám különböző jogszerű ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "sq": "0.989410418495887",
      "hy": "0.9774334037802453",
      "bn": "0.9084202710415786",
      "bg": "0.9963376530344787",
      "zh": "0.9583978598441478",
      "fr": "1",
      "de": "0.9806667091227312",
      "ha": "0.9902889606712043",
      "hi": "0.9564385697656197",
      "hu": "0.9559350417496962"
    }
  },
  {
    "task_id": "C/41",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nԵրեք ամբողջ թիվ n, m և k տրված են, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')' նշաններից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվել 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত কতগুলি ক্রম আছে তা খুঁজে বের করুন, যাতে দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредба да е с дължина 2 * k. Резултатът трябва да се изчисли по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 取模计算。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné trois entiers n, m et k, trouvez le nombre de séquences composées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba lambobi guda uku n, m, da k, nemo adadin jerin lambobi masu kunshe da n '(' da m ')', ta yadda mafi tsawon jerin lambobi masu daidaituwa zai kasance mai tsawon 2 * k. Ya kamata a lissafta sakamakon daidai da 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k की लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott három egész szám: n, m és k. Találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "0.9922812233929842",
      "hy": "0.9710426699008289",
      "bn": "0.9689983660192177",
      "bg": "0.9754778876789568",
      "zh": "0.984007672131738",
      "fr": "0.9958482277756088",
      "de": "0.9820505669874013",
      "ha": "0.9804096814096721",
      "hi": "0.9813416551574877",
      "hu": "0.9628527420299983"
    },
    "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "Write a C function `long long countBalancedSubsequences(long long n, long long m, long long k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Shkruani një funksion në C `long long countBalancedSubsequences(long long n, long long m, long long k)` për të zgjidhur problemin në vijim:  \nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar të jetë me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Գրեք C ֆունկցիա `long long countBalancedSubsequences(long long n, long long m, long long k)` հետևյալ խնդիրը լուծելու համար:\nԵրեք ամբողջ n, m և k թվերի դեպքում, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկել 1,000,000,007 (10^9 + 7) մոդուլով: \n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "একটি C ফাংশন `long long countBalancedSubsequences(long long n, long long m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n টি '(' এবং m টি ')' নিয়ে গঠিত এমন ক্রমের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Напишете C функция `long long countBalancedSubsequences(long long n, long long m, long long k)`, за да решите следния проблем:  \nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "编写一个 C 函数 `long long countBalancedSubsequences(long long n, long long m, long long k)` 来解决以下问题：  \n给定三个整数 n、m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。  \n\n例如：  \n    >>> countBalancedSubsequences(2, 2, 2)  \n    2  ",
      "fr": "Écrire une fonction C `long long countBalancedSubsequences(long long n, long long m, long long k)` pour résoudre le problème suivant :\nÉtant donné trois entiers n, m et k, trouver le nombre de séquences composées de n '(' et m ')', de sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Schreiben Sie eine C-Funktion `long long countBalancedSubsequences(long long n, long long m, long long k)`, um das folgende Problem zu lösen:\nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "Rubuta wani aikin C `long long countBalancedSubsequences(long long n, long long m, long long k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku n, m, da k, gano yawan jerin da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin da aka daidaita shine tsawon 2 * k. Sakamakon ya kamata a lasafta shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "C फ़ंक्शन `long long countBalancedSubsequences(long long n, long long m, long long k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k के लिए, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Írj egy C függvényt `long long countBalancedSubsequences(long long n, long long m, long long k)` a következő probléma megoldására:\nAdott három egész szám: n, m és k. Találd meg azon sorozatok számát, amelyek n darab '(' és m darab ')' karakterből állnak, úgy hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9952342612678299",
      "hy": "0.9878809645619183",
      "bn": "0.9766206082610506",
      "bg": "0.9901006590699832",
      "zh": "0.9842827752094714",
      "fr": "0.9956523782199084",
      "de": "0.9828377391874425",
      "ha": "0.9837252197299065",
      "hi": "0.9638699282112779",
      "hu": "0.9670887335359484"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য হয় 2 * k। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "给定三个整数 n、m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Étant donné trois entiers n, m, et k, trouvez le nombre de séquences composées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin lambobi masu daidaito zai kasance mai tsawon 2 * k. Ya kamata a lissafa sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जिनमें n '(' और m ')' शामिल हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg az n '(' és m ')' karakterekből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9996007529341199",
      "hy": "0.9691904415976785",
      "bn": "0.9591834430011408",
      "bg": "0.9849038924109674",
      "zh": "0.9732657411253713",
      "fr": "0.9942174723473123",
      "de": "0.9841463161377004",
      "ha": "0.983706151213327",
      "hi": "0.9577292699815844",
      "hu": "0.944558685306304"
    }
  },
  {
    "task_id": "C/42",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m),\nju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\nNë çdo operacion, një vijë zgjidhet në mënyrë të rastësishme që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության դեկարտյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0)-ում և վերևի աջ անկյունը (n,m)-ում,\nպետք է հաշվարկել սպասվող գործողությունների քանակը, որպեսզի թղթի մնացած տարածքը լինի k-ից փոքր:\nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այդ գծի երկայնքով ներքևի կամ աջ հատվածը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nএকটি আয়তাকার কাগজ যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ রয়েছে,\nআপনাকে কাগজটি কাটার জন্য প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়।\nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ করে না)। এই লাইনের সাথে কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m),\nтрябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k.\nПри всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，\n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应对 10^9+7 取模。\n\n例如:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m),\nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k.\nÀ chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m) platziert ist. \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAna ba da takarda mai kusurwa huɗu mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m),\ndole ne ku lissafa yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k.\nA kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nदिए गए एक आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \nजिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, \nआपको यह गणना करने की आवश्यकता है कि कागज को काटने के लिए अपेक्षित ऑपरेशनों की संख्या कितनी है ताकि शेष क्षेत्रफल k से कम हो। \nप्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, \nऔर कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां भाग फिर त्याग दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-féle koordinátarendszerben helyezkedik el, bal alsó sarka a (0,0) pontban, jobb felső sarka pedig az (n,m) pontban van. \nKi kell számítani a várható műveletek számát ahhoz, hogy a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobhatjuk.\nAz eredménynek 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "0.9595809023935916",
      "hy": "0.939155541681393",
      "bn": "0.9542017930447858",
      "bg": "0.9525096608287497",
      "zh": "0.9454936385098353",
      "fr": "0.9654561904342226",
      "de": "0.9568413921783585",
      "ha": "0.9491591635614531",
      "hi": "0.9236649541556252",
      "hu": "0.9433482317642775"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `long long expectedCuts(int n, int m, long long k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n",
      "sq": "Shkruani një funksion në C `long long expectedCuts(int n, int m, long long k)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m),\nduhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\nNë secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hy": "Գրեք C ֆունկցիա `long long expectedCuts(int n, int m, long long k)` հետևյալ խնդիրը լուծելու համար:\nՈւնենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \nպետք է հաշվարկել գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած տարածքը լինի փոքր քան k: \nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "bn": "একটি C ফাংশন `long long expectedCuts(int n, int m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি আয়তাকার কাগজের টুকরো, আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত,\nআপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়।\nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "bg": "Напишете C функция `long long expectedCuts(int n, int m, long long k)`, за да решите следния проблем:\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m),\nтрябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k.\nПри всяка операция се избира на случаен принцип линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "zh": "编写一个 C 函数 `long long expectedCuts(int n, int m, long long k)` 来解决以下问题：  \n给定一个大小为 n x m 的矩形纸张，放置在平面笛卡尔坐标系中，其左下角在 (0,0)，右上角在 (n,m)，  \n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。  \n在每次操作中，随机选择一条平行于坐标轴的线，该线通过具有整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。  \n答案应对 10^9+7 取模。  \n\n例如：  \n    >>> expectedCuts(3, 3, 4)  \n    3  ",
      "fr": "Écrire une fonction C `long long expectedCuts(int n, int m, long long k)` pour résoudre le problème suivant :\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. \nÀ chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3",
      "de": "Schreiben Sie eine C-Funktion `long long expectedCuts(int n, int m, long long k)`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "ha": "Rubuta aikin C `long long expectedCuts(int n, int m, long long k)` don warware matsalar mai zuwa:\nAn ba da takarda murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \ndole ne ka ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya kasance ƙasa da k. \nA kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hi": "C फ़ंक्शन `long long expectedCuts(int n, int m, long long k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया एक आयताकार कागज़ जिसका आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, \nआपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करने की आवश्यकता है ताकि कागज़ को इस प्रकार काटा जा सके कि शेष क्षेत्रफल k से कम हो। \nप्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से होकर गुजरती है, और कागज़ को काटती है (सिर्फ किनारे को छूने तक नहीं)। इस रेखा के साथ कागज़ का निचला या दायां भाग तब हटा दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hu": "Írj egy C függvényt `long long expectedCuts(int n, int m, long long k)` a következő probléma megoldására:\nAdott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, és a felső-jobb sarka az (n,m) pontban van. \nKi kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobja.\nA válasznak modulo 10^9+7 kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9643168465686065",
      "hy": "0.9518408723358052",
      "bn": "0.952802243380014",
      "bg": "0.9571355637726712",
      "zh": "0.9638580103884159",
      "fr": "0.9699178260530282",
      "de": "0.9516045021823736",
      "ha": "0.9428945599739937",
      "hi": "0.9553854314853727",
      "hu": "0.9427920666973798"
    },
    "level": "hard",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), \nyou need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. \nIn each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n",
      "sq": "Duke pasur një letër drejtkëndëshe me përmasa n x m të vendosur në një sistem koordinativ Kartezian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm duke prekur skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, \nպետք է հաշվարկել սպասվող գործողությունների քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր։ \nՅուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է մի գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով)։ Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է։\nՊատասխանը պետք է լինի 10^9+7 մոդուլով։\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "bn": "একটি আয়তাকার কাগজের আকার n x m একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ, \nআপনাকে এমনভাবে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। \nপ্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তখন বাতিল করা হয়।\nউত্তরটি 10^9+7 দ্বারা মডুলো হতে হবে।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m), \nтрябва да изчислите очаквания брой операции за изрязване на хартията така, че оставащата площ да е по-малка от k. \nПри всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)。你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触及边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. \nDans chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3",
      "de": "Gegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). \nSie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "ha": "An ba takardar murabba'i mai girman n x m da aka sanya a tsarin daidaitawar Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \nkana buƙatar lissafin yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. \nA kowane aiki, ana zaɓar wata layi da ba a san ta ba wadda ke daidai da ginshiƙai, ta wuce ta wuraren da ke da daidaitawa na lamba, kuma ta yanke (ba kawai ta taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hi": "एक n x m आकार के आयताकार कागज को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर स्थिति (0,0) और ऊपरी-दाईं कोने पर स्थिति (n,m) है। \nआपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। \nप्रत्येक ऑपरेशन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज का निचला या दायां हिस्सा फिर त्याग दिया जाता है।\nउत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "hu": "Adott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. \nKi kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. \nMinden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután el lesz dobva.\nA válasz legyen 10^9+7 modulo.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.950957165770581",
      "hy": "0.923282590672133",
      "bn": "0.9572561324139593",
      "bg": "0.9479294428724662",
      "zh": "0.9272691024195032",
      "fr": "0.9732329671125005",
      "de": "0.999999801369619",
      "ha": "0.9283315763276588",
      "hi": "0.9383665818079224",
      "hu": "0.9431410602768581"
    }
  },
  {
    "task_id": "C/43",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sq": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke e ndarë p në saktësisht k segmente të pandashme dhe duke renditur secilin segment (kjo është, zgjidhni $ k-1 $ pika ndarjeje $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hy": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nՏրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը սորտավորելով (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bn": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা ঠিক k টি non-empty contiguous segment এ p কে ভাগ করে এবং প্রতিটি segment কে sort করে পাওয়া যেতে পারে (অর্থাৎ, $ k-1 $ টি breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bg": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегменти и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "zh": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个排列 p 满足 f(p) = q，其中 f(p) 是通过将 p 精确地分成 k 个非空连续段并对每个段进行排序后得到的字典序最小的排列（即选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "fr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et divisez-le en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "de": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und Sortieren jedes Segments erhalten werden kann (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "ha": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n irin cewa f(p) = q, inda f(p) shine permutation mafi ƙarami a cikin tsari na lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa kuma a tsara kowane sashe (wato, zaɓi $ k-1 $ wuraren karya $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma a raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स चुनें $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hu": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nAdott egy q permutáció n elemre és egy egész szám k, keresse meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kaphatunk meg, hogy p-t pontosan k nem üres szomszédos szegmensre osztjuk, és minden szegmenst sorba rendezünk (vagyis válasszuk ki a $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredménynek 998244353-mal vett maradéka legyen.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "sq": "0.9728790077734963",
      "hy": "0.9895945488591064",
      "bn": "0.9855198452225566",
      "bg": "0.9927418472466042",
      "zh": "0.953655758127321",
      "fr": "0.9940089104472257",
      "de": "0.9877874096524509",
      "ha": "0.9625708855193098",
      "hi": "0.9882724650429381",
      "hu": "0.9615020554389611"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a C function `int countPermutations(int n, int k, int qq[])` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n",
      "sq": "Shkruani një funksion në C `int countPermutations(int n, int k, int qq[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni leksikografikisht më i vogël që mund të merret duke ndarë p në saktësisht k segmente të pandara jo-bosh dhe duke renditur secilin segment (domethënë, zgjidhni $ k-1 $ pika ndarëse $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni atë në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hy": "Գրեք C ֆունկցիա `int countPermutations(int n, int k, int qq[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերի q փոխատեղումը և ամբողջ թիվ k, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն բաժանելով ճիշտ k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bn": "C ফাংশন `int countPermutations(int n, int k, int qq[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলো permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি নয় এমন সংলগ্ন segment এ ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যায় (অর্থাৎ, $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ বেছে নিন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 মডুলোতে হওয়া উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bg": "Напишете C функция `int countPermutations(int n, int k, int qq[])`, за да решите следния проблем:  \nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "zh": "编写一个C函数 `int countPermutations(int n, int k, int qq[])` 来解决以下问题：\n给定一个由n个元素组成的排列q和一个整数k，找出n个元素的排列p的数量，使得f(p) = q，其中f(p)是通过将p分成恰好k个非空连续段并对每个段进行排序可以获得的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其划分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对998244353取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "fr": "Écrire une fonction C `int countPermutations(int n, int k, int qq[])` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et le diviser en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "de": "Schreiben Sie eine C-Funktion `int countPermutations(int n, int k, int qq[])`, um das folgende Problem zu lösen:\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem man p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "ha": "Rubuta aikin C `int countPermutations(int n, int k, int qq[])` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo adadin permutations p na abubuwa n irin wanda f(p) = q, inda f(p) shine mafi ƙarancin permutation na lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba da ba komai ba kuma a tsara kowane sashi (wato, zaɓi $ k-1 $ wuraren tsayawa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma a raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hi": "C फ़ंक्शन `int countPermutations(int n, int k, int qq[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें ताकि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जिसे p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ चुनें, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 से मापांकित होना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hu": "Írj egy C függvényt `int countPermutations(int n, int k, int qq[])` a következő probléma megoldására:\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) az a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válasszunk $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredményt 998244353-mal vett maradékként kell megadni.\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9831579313616708",
      "hy": "0.9866393260500693",
      "bn": "0.9826706910369922",
      "bg": "0.9915141128614275",
      "zh": "0.9820348751872995",
      "fr": "0.9909505984704315",
      "de": "0.9973615926487136",
      "ha": "0.9719319381167221",
      "hi": "0.9726277403414872",
      "hu": "0.9669032127600617"
    },
    "level": "hard",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n",
      "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandryshuara dhe duke renditur secilin segment (kjo është, zgjidhni $ k-1 $ pika ndarjeje $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, dhe ndajeni në $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Rezultati duhet të jetë modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն այն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն, ընտրել $ k-1 $ կոտրման կետեր $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, և բաժանել այն $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $): Արդյունքը պետք է լինի 998244353 մոդուլով:\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bn": "একটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলো permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি না থাকা সংলগ্ন অংশে ভাগ করে এবং প্রতিটি অংশকে সাজিয়ে পাওয়া যায় (অর্থাৎ, $ k-1 $ ব্রেকপয়েন্ট $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ নির্বাচন করুন, এবং এটিকে $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете $ k-1 $ точки на прекъсване $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, и го разделете на $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Резултатът трябва да бъде модуло 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "zh": "给定一个 n 元素的排列 q 和一个整数 k，找出 n 元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 精确地分成 k 个非空连续段并对每个段进行排序后可以得到的字典序最小的排列（即，选择 $ k-1 $ 个断点 $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $，并将其分为 $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $）。结果应对 998244353 取模。\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez $ k-1 $ points de rupture $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, et divisez-le en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Le résultat doit être modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (das heißt, wähle $ k-1 $ Trennpunkte $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, und teile es in $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Das Ergebnis sollte modulo 998244353 sein.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "ha": "An ba da permutation q na abubuwa n da kuma integer k, nemo yawan permutations p na abubuwa n irin cewa f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za'a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba da ba komai kuma a tsara kowane sashe (wato, zaɓi $ k-1 $ wuraren tsagewa $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, kuma raba shi zuwa $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Sakamakon ya zama modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hi": "दी गई क्रमचय q के n तत्वों और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या ज्ञात करें ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली निरंतर खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, $ k-1 $ ब्रेकपॉइंट्स $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ चुनें, और इसे $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hu": "Adott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet előállítani, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk $ k-1 $ töréspontot $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, és osszuk fel $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ részekre). Az eredményt 998244353-mal modulozva kell megadni.\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9712665263402551",
      "hy": "0.9866881891238038",
      "bn": "0.9658103484036078",
      "bg": "0.9904224402872598",
      "zh": "0.985885921014804",
      "fr": "0.9905922692630446",
      "de": "0.9979527166626734",
      "ha": "0.9712510331705344",
      "hi": "0.9901626317488661",
      "hu": "0.9706293200778953"
    }
  },
  {
    "task_id": "C/44",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends, \nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \nof the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDuke pasur një varg prej n të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës,\ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i treshes të kenë përbashkët më të madhin pjesëtues (GCD) 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nՏրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\nգտնել եռյակի (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nকিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\nতিনটি (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের \nসর্বাধিক সাধারণ গুণক (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\nнамерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД)\nна максималната и минималната стойност на тройката да е 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\ntrouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\ndes valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "de": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nGegeben ein Array von n verschiedenen ganzen Zahlen, die die Größen von Kiras Freunden darstellen,\nfinde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\nnemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ke raba su (GCD)\nna mafi girma da ƙananan ƙimomin triplet ɗin ya zama 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nकिरा के दोस्तों की ऊंचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक सरणी दी गई है,\nऐसे ट्रिपलेट (a, b, c) को चुनने के तरीकों की संख्या खोजें ताकि ट्रिपलेट के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nAdott egy n különböző egész számot tartalmazó tömb, amely Kira barátainak magasságát reprezentálja,\ntaláljuk meg, hányféleképpen lehet kiválasztani egy hármas (a, b, c) úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9937312251745389",
      "hy": "0.9686622834145068",
      "bn": "0.9870320183133753",
      "bg": "0.9982409293455551",
      "zh": "0.9966077903526862",
      "fr": "1",
      "de": "0.9966077903526862",
      "ha": "0.965754136005775",
      "hi": "0.9894461719644733",
      "hu": "0.9860086745902835"
    },
    "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a C function `int countTriplets(int heights[], int n)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n",
      "sq": "Shkruani një funksion në C `int countTriplets(int heights[], int n)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg me n numra të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i vlerave të treshes të kenë përbashkët vetëm 1 si pjesëtues më të madh të përbashkët (GCD).  \n    >>> countTriplets([1, 5, 7])  \n    1",
      "hy": "Գրեք C ֆունկցիա `int countTriplets(int heights[], int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել եղանակների քանակը, որով հնարավոր է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների մեծագույն ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1",
      "bn": "একটি C ফাংশন `int countTriplets(int heights[], int n)` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করার জন্য:\nকিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি পৃথক পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে, ট্রিপলেট (a, b, c) বেছে নেওয়ার কতগুলি উপায় আছে তা খুঁজে বের করুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1",
      "bg": "Напишете C функция `int countTriplets(int heights[], int n)`, за да решите следния проблем:  \nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.  \n    >>> countTriplets([1, 5, 7])  \n    1",
      "zh": "编写一个 C 函数 `int countTriplets(int heights[], int n)` 来解决以下问题：  \n给定一个包含 n 个不同整数的数组，表示 Kira 朋友的身高，找出选择三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。  \n    >>> countTriplets([1, 5, 7])  \n    1  ",
      "fr": "Écrire une fonction C `int countTriplets(int heights[], int n)` pour résoudre le problème suivant :\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "de": "Schreiben Sie eine C-Funktion `int countTriplets(int heights[], int n)`, um das folgende Problem zu lösen:\nGegeben ist ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen. Finden Sie die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so auszuwählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1",
      "ha": "Rubuta wani aikin C `int countTriplets(int heights[], int n)` don warware matsalar mai zuwa:\nAn ba da wani tsari na lambobi daban-daban n waɗanda ke wakiltar tsayin abokan Kira, nemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kowa da kowa (GCD) na mafi girma da ƙananan ƙimar triplet ɗin ya zama 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "hi": "C फ़ंक्शन `int countTriplets(int heights[], int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिरा के दोस्तों की ऊँचाईयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1",
      "hu": "Írj egy C függvényt `int countTriplets(int heights[], int n)` a következő probléma megoldására:  \nAdott egy n különböző egész számot tartalmazó tömb, amely Kira barátainak magasságát jelképezi. Találd meg, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.  \n    >>> countTriplets([1, 5, 7])  \n    1  "
    },
    "instruction_bertscore": {
      "sq": "0.9491661156247894",
      "hy": "0.9896865147255255",
      "bn": "0.9503306855487968",
      "bg": "0.9956666796073429",
      "zh": "0.9959817073916643",
      "fr": "0.964365312381579",
      "de": "0.985294399740082",
      "ha": "0.9332578084077051",
      "hi": "0.9705965460650244",
      "hu": "0.9739488310057502"
    },
    "level": "hard",
    "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(int heights[], int n)",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n    >>> countTriplets([1, 5, 7])\n    1\n",
      "sq": "Duke pasur një varg prej n të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të tresheve të jetë 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "hy": "Տրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n    >>> countTriplets([1, 5, 7])\n    1",
      "bn": "একটি n সংখ্যক ভিন্ন পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভিসর (GCD) 1 হয়।\n    >>> countTriplets([1, 5, 7])\n    1",
      "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойности на тройката да е 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n    >>> countTriplets([1, 5, 7])\n    1",
      "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Größen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n    >>> countTriplets([1, 5, 7])\n    1",
      "ha": "An ba da wani tsararren lambobi na n masu bambanta da ke wakiltar tsayin abokan Kira, gano yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman mai raba kowa da kowa (GCD) na mafi girma da mafi ƙanƙanta na triplet ɗin zai zama 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "hi": "दिए गए n भिन्न पूर्णांकों के एक array में, जो कि किरा के दोस्तों की ऊँचाई का प्रतिनिधित्व करते हैं, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मान का महत्तम समापवर्तक (GCD) 1 हो।\n    >>> countTriplets([1, 5, 7])\n    1",
      "hu": "Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik, meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n    >>> countTriplets([1, 5, 7])\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9996881503017753",
      "hy": "0.9715865198841024",
      "bn": "0.979879934183452",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.9946872331984599",
      "ha": "0.9405685982120753",
      "hi": "0.9938617253348788",
      "hu": "0.9497969657149562"
    }
  },
  {
    "task_id": "C/45",
    "prompt": {
      "en": "#include <stdio.h>\n#include <assert.h>\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "sq": "#include <stdio.h>\n#include <assert.h>\n/*\nJu jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "hy": "#include <stdio.h>\n#include <assert.h>\n/*\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր կապված պիքսելները ընտրված գույնով։ Երկու պիքսելներ կապված են, եթե նրանք հարևան են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը։\n\nՆշում. Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "bn": "#include <stdio.h>\n#include <assert.h>\n/*\nআপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলিকে নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে পরিণত করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, ঐ রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "bg": "#include <stdio.h>\n#include <assert.h>\n/*\nДадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "zh": "#include <stdio.h>\n#include <assert.h>\n/*\n给定一个1x n像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有20个像素。\n\n例子：\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "fr": "#include <stdio.h>\n#include <assert.h>\n/*\nVous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "de": "#include <stdio.h>\n#include <assert.h>\n/*\nSie haben ein 1 mal n Pixelbild, wobei jedes Pixel eine Farbe hat, die durch eine Ganzzahl dargestellt wird. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "ha": "#include <stdio.h>\n#include <assert.h>\n/*\nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke ɗaukar launi kuma ku canza duk pixels da aka haɗa na launi ɗaya zuwa launi da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "hi": "#include <stdio.h>\n#include <assert.h>\n/*\nआपको 1 बाई n पिक्सेल की छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बदलने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "hu": "#include <stdio.h>\n#include <assert.h>\n/*\nEgy 1 x n pixel méretű képet kap, ahol minden pixel színét egy egész szám képviseli. Végrehajthat egy műveletet, ahol kiválaszt egy színt, és az összes összekapcsolt, azonos színű pixelt a választott színre változtatja. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Határozza meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "sq": "0.984821460802838",
      "hy": "0.9703687170179774",
      "bn": "0.9832417533824676",
      "bg": "0.9832208971924589",
      "zh": "0.9495198763334125",
      "fr": "0.9879677660384306",
      "de": "0.9895826310362442",
      "ha": "0.9897723230501325",
      "hi": "0.9687981465951346",
      "hu": "0.9514894951917544"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "en": "Write a C function `int minOperations(int n, int* pixels)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "sq": "Shkruani një funksion në C `int minOperations(int n, int* pixels)` për të zgjidhur problemin e mëposhtëm:\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hy": "Գրեք C ֆունկցիա `int minOperations(int n, int* pixels)` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է 1 ըստ n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով։ Երկու պիքսել միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "bn": "একটি C ফাংশন `int minOperations(int n, int* pixels)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বাছাই করেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলিকে নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "bg": "Напишете C функция `int minOperations(int n, int* pixels)`, за да решите следния проблем:\nДадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен чрез цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "zh": "编写一个C函数 `int minOperations(int n, int* pixels)` 来解决以下问题：  \n给定一个1乘n的像素图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素相邻且颜色相同，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有20个该颜色的像素。\n\n示例:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "fr": "Écrire une fonction C `int minOperations(int n, int* pixels)` pour résoudre le problème suivant :  \nVous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "de": "Schreiben Sie eine C-Funktion `int minOperations(int n, int* pixels)`, um das folgende Problem zu lösen:\nSie haben ein 1x n Pixel-Bild, bei dem jedes Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "ha": "Rubuta aikin C `int minOperations(int n, int* pixels)` don warware matsalar mai zuwa:\nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke zaɓar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowane launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hi": "C फ़ंक्शन `int minOperations(int n, int* pixels)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको 1 बाय n पिक्सल की छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े हुए हैं यदि वे आसन्न हैं और उनका रंग समान है। सभी पिक्सल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशन्स की संख्या खोजें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hu": "Írj egy C függvényt `int minOperations(int n, int* pixels)` a következő probléma megoldására:\nAdott egy 1 x n pixel kép, ahol minden pixel színét egy egész szám képviseli. Végrehajthatsz egy műveletet, ahol kiválasztasz egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatod a választott színre. Két pixel akkor kapcsolódik egymáshoz, ha szomszédosak és azonos színűek. Találd meg a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.973588714124934",
      "hy": "0.9847493579745223",
      "bn": "0.983341267203366",
      "bg": "0.9833726508035695",
      "zh": "0.9620671588730053",
      "fr": "0.9862954968604979",
      "de": "0.9860027156788524",
      "ha": "0.9799238314976607",
      "hi": "0.9743661534363046",
      "hu": "0.9689532769227228"
    },
    "level": "hard",
    "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "sq": "Ju jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të nevojshme për t'i bërë të gjithë piksela të së njëjtës ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n",
      "hy": "Ձեզ տրված է 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացած պիքսելները ընտրված գույնով: Երկու պիքսել միացած են, եթե նրանք հարևան են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "bn": "আপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "bg": "Дадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен чрез цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "zh": "你有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素相邻并且具有相同的颜色，则它们是连接的。找出使所有像素颜色相同所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "de": "Du hast ein 1 mal n Pixel-Bild, wobei jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "ha": "An ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke zaɓar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa da juna kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hi": "आपको एक 1 बाय n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल्स को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े होते हैं यदि वे आसन्न हैं और उनका रंग समान है। सभी पिक्सल्स को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "hu": "Egy 1 x n pixeles képet kap, ahol minden pixel színe egy egész számmal van reprezentálva. Végrehajthat egy műveletet, amely során kiválaszt egy színt, és megváltoztatja az összes összekapcsolt azonos színű pixelt a kiválasztott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Keresse meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9835796236606079",
      "hy": "0.967342980423673",
      "bn": "0.9779512331836032",
      "bg": "0.9779770551331378",
      "zh": "0.9551574038079447",
      "fr": "0.9798062423120881",
      "de": "0.983517849612106",
      "ha": "0.9848315909522708",
      "hi": "0.958797702801171",
      "hu": "0.9553802670954659"
    }
  },
  {
    "task_id": "C/46",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\nՕրինակ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, এমন একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়ের গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\nНапример:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则它只应被计算一次。\n例如：\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\nPar exemple :\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine ganze Zahl n, schreibe eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da wani lamba n, rubuta wata aiki don lissafin jimillar duk lambobi daga 1 zuwa n waɗanda suke ninki na 3 ko 5. Idan lamba tana ninki na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.\nMisali:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों की गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9920259833533545",
      "hy": "0.9877639712674888",
      "bn": "0.9913705030959393",
      "bg": "0.9920259833533545",
      "zh": "0.9893142813914662",
      "fr": "0.9926709362005747",
      "de": "0.9970741744873561",
      "ha": "0.9834179385304455",
      "hi": "0.9845062343881357",
      "hu": "0.9913705030959393"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a C function `int sumOfMultiples(int n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n",
      "sq": "Shkruani një funksion në C `int sumOfMultiples(int n)` për të zgjidhur problemin në vijim:  \nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve, 3 dhe 5, ai duhet të numërohet vetëm një herë.  \nPër shembull:  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)",
      "hy": "Գրեք C ֆունկցիա `int sumOfMultiples(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի: Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ:\nՕրինակ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি C ফাংশন `int sumOfMultiples(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করবে যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়ের গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "bg": "Напишете C функция `int sumOfMultiples(int n)`, за да решите следния проблем:  \nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.  \nНапример:  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)",
      "zh": "编写一个 C 函数 `int sumOfMultiples(int n)` 来解决以下问题：  \n给定一个整数 n，编写一个函数计算从 1 到 n 的所有 3 或 5 的倍数的和。如果一个数字同时是 3 和 5 的倍数，它应该只被计算一次。  \n例如：  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ",
      "fr": "Écrire une fonction C `int sumOfMultiples(int n)` pour résoudre le problème suivant :  \nÉtant donné un entier n, écrire une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ",
      "de": "Schreiben Sie eine C-Funktion `int sumOfMultiples(int n)`, um das folgende Problem zu lösen:  \nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.  \nZum Beispiel:  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ",
      "ha": "Rubuta aikin C `int sumOfMultiples(int n)` don warware matsalar mai zuwa:  \nAn ba da lamba n, rubuta aiki don lissafin jimillar duk lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.  \nMisali:  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ",
      "hi": "C फ़ंक्शन `int sumOfMultiples(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hu": "Írj egy C függvényt `int sumOfMultiples(int n)` a következő probléma megoldására:\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind 3-nak, mind 5-nek többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "sq": "0.9890655961544105",
      "hy": "0.9874368270299243",
      "bn": "0.9890622194379328",
      "bg": "0.9914644552661688",
      "zh": "0.9693429897303133",
      "fr": "0.9927779979759525",
      "de": "0.9972704213038186",
      "ha": "0.9827932459820907",
      "hi": "0.9729334324978999",
      "hu": "0.9914348593393946"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n",
      "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve, 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hy": "Տրված ամբողջ թիվ n-ի դեպքում, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են կամ 3-ի, կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\nՕրինակ՝\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ অথবা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়, তবে তা কেবল একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да се брои само веднъж.\nНапример:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n例如：\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    >>> sumOfMultiples(10)  \n    33 // (3 + 5 + 6 + 9 + 10)  ",
      "de": "Geben Sie eine ganze Zahl n an, und schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "ha": "An ba da wani lamba n, rubuta wani aiki don lissafin jimillar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.\nMisali:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hi": "दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám 3-nak és 5-nek is többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "sq": "0.9825318484006488",
      "hy": "0.991090036997918",
      "bn": "0.9908419476520054",
      "bg": "0.9900519946266297",
      "zh": "0.9851692626000301",
      "fr": "0.9900519946266297",
      "de": "1",
      "ha": "0.970730422941842",
      "hi": "0.9794900227454806",
      "hu": "0.9877226561482335"
    }
  },
  {
    "task_id": "C/47",
    "prompt": {
      "en": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "sq": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "hy": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nՍահմանել, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "bn": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিক থেকে এবং পিছনের দিক থেকে একইভাবে পড়া যায় (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "bg": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервалите, пунктуацията и главните букви).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "zh": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n确定给定的字符串是否是回文。回文是指正读和反读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "fr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "de": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "ha": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGano idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "hi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nनिर्धारित करें कि कोई दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ता है (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को अनदेखा करते हुए)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "hu": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHatározza meg, hogy egy adott sztring palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9974827571811449",
      "bn": "0.9992021017593828",
      "bg": "0.9992021017593828",
      "zh": "0.9898126450174827",
      "fr": "1",
      "de": "0.9952644530857472",
      "ha": "1",
      "hi": "0.9723127125571659",
      "hu": "0.9992021017593828"
    },
    "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "en": "Write a C function `bool isPalindrome(const char* str)` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n",
      "sq": "Shkruani një funksion në C `bool isPalindrome(const char* str)` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni nëse një varg i dhënë është palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  ",
      "hy": "Գրեք C ֆունկցիա `bool isPalindrome(const char* str)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք՝ արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "bn": "একটি C ফাংশন `bool isPalindrome(const char* str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।",
      "bg": "Напишете C функция `bool isPalindrome(const char* str)` за решаване на следния проблем:  \nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  ",
      "zh": "编写一个 C 函数 `bool isPalindrome(const char* str)` 来解决以下问题：  \n确定给定的字符串是否是回文。回文是指正着读和反着读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  ",
      "fr": "Écrire une fonction C `bool isPalindrome(const char* str)` pour résoudre le problème suivant :  \nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  ",
      "de": "Schreiben Sie eine C-Funktion `bool isPalindrome(const char* str)`, um das folgende Problem zu lösen: Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).",
      "ha": "Rubuta aikin C `bool isPalindrome(const char* str)` don warware matsalar mai zuwa: Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan haruffa ba).",
      "hi": "C फ़ंक्शन `bool isPalindrome(const char* str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:  \nयह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को अनदेखा करते हुए)।  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  ",
      "hu": "Írj egy C függvényt `bool isPalindrome(const char* str)` a következő probléma megoldására:  \nHatározd meg, hogy egy adott string palindróm-e. Egy palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és visszafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).  \n    >>> isPalindrome(\"racecar\")  \n    true  \n    >>> isPalindrome(\"hello\")  \n    false  "
    },
    "instruction_bertscore": {
      "sq": "0.9939316432290032",
      "hy": "0.9302092293195817",
      "bn": "0.9327479242195886",
      "bg": "0.9992042866935742",
      "zh": "0.9876878958315525",
      "fr": "1",
      "de": "0.9183303380121712",
      "ha": "0.9339329530728427",
      "hi": "0.9673413913806247",
      "hu": "1"
    },
    "level": "middle",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "hy": "Սահմանել՝ արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনে এবং পিছনে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "zh": "确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation et la capitalisation).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "ha": "Kayyade idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutun alama, da babba ko ƙaramin ba).\n\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से एक जैसा पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों को नजरअंदाज करते हुए)।\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "hu": "Határozza meg, hogy egy adott sztring palindróm-e. A palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9956925015568774",
      "bn": "0.9989989028795841",
      "bg": "1",
      "zh": "0.9989989028795841",
      "fr": "1",
      "de": "0.9924345660471432",
      "ha": "1",
      "hi": "0.9628652557440035",
      "hu": "0.9989989028795841"
    }
  },
  {
    "task_id": "C/48",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nint addDigits(int num)",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n*/\nint addDigits(int num)",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ը արդյունքն է:\n*/\nint addDigits(int num)",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া আছে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক আছে, 2 হল ফলাফল।\n*/\nint addDigits(int num)",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът има само една цифра.\nНапример:\n    >>> addDigits(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.\n*/\nint addDigits(int num)",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定一个非负整数 num，反复将所有位上的数字相加，直到结果只有一位数字。\n例如：\n    >>> addDigits(38)\n    2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。\n*/\nint addDigits(int num)",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n*/\nint addDigits(int num)",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    >>> addDigits(38)\n    2\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n*/\nint addDigits(int num)",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lamba mai kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    >>> addDigits(38)\n    2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n*/\nint addDigits(int num)",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसके सभी अंकों को तब तक जोड़ते रहें जब तक परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n*/\nint addDigits(int num)",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    >>> addDigits(38)\n    2\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9814838745103087",
      "bn": "1",
      "bg": "1",
      "zh": "0.9632686740478854",
      "fr": "1",
      "de": "1",
      "ha": "0.9912789344902821",
      "hi": "0.9836856922840805",
      "hu": "0.9685623723328461"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "Write a C function `int addDigits(int num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Shkruani një funksion në C `int addDigits(int num)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Գրեք C ֆունկցիա `int addDigits(int num)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, կրկնվող կերպով գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է:",
      "bn": "একটি C ফাংশন `int addDigits(int num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক রয়েছে, তাই 2 হল ফলাফল।",
      "bg": "Напишете C функция `int addDigits(int num)`, за да решите следния проблем:  \nДадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.  \nНапример:  \n    >>> addDigits(38)  \n    2  \n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.",
      "zh": "编写一个 C 函数 `int addDigits(int num)` 来解决以下问题：  \n给定一个非负整数 num，重复将所有位上的数字相加，直到结果只有一位数字。  \n例如：  \n    >>> addDigits(38)  \n    2  \n    因为 3 + 8 = 11，并且 1 + 1 = 2。由于 2 只有一位数字，2 是结果。",
      "fr": "Écrire une fonction C `int addDigits(int num)` pour résoudre le problème suivant :\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Comme 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Schreiben Sie eine C-Funktion `int addDigits(int num)`, um das folgende Problem zu lösen:  \nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.  \nZum Beispiel:  \n    >>> addDigits(38)  \n    2  \n    Weil 3 + 8 = 11 und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.  ",
      "ha": "Rubuta aikin C `int addDigits(int num)` don warware matsalar mai zuwa:\nAn ba da lamba mai kyau wadda ba ta da alamar ƙari num, a ci gaba da ƙara duk lambobinta har sai sakamakon yana da lamba guda ɗaya kawai.\nAlal misali:\n    >>> addDigits(38)\n    2\n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba guda ɗaya kawai, 2 shine sakamakon.",
      "hi": "एक C फ़ंक्शन `int addDigits(int num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसकी सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम केवल एक अंक का न हो जाए।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Írj egy C függvényt `int addDigits(int num)` a következő probléma megoldására:  \nAdott egy nem negatív egész szám num, add össze ismételten az összes számjegyét, amíg az eredmény csak egy számjegyből áll.  \nPéldául:  \n    >>> addDigits(38)  \n    2  \n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény."
    },
    "instruction_bertscore": {
      "sq": "0.9943400272924109",
      "hy": "0.983990391288588",
      "bn": "1",
      "bg": "0.9540242174841407",
      "zh": "0.9673419872717678",
      "fr": "1",
      "de": "0.9967647083537038",
      "ha": "1",
      "hi": "0.9635578798826722",
      "hu": "0.9727943912311755"
    },
    "level": "easy",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    >>> addDigits(38)\n    2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    >>> addDigits(38)\n    2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, կրկնվող կերպով գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\nՕրինակ:\n    >>> addDigits(38)\n    2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ը արդյունքն է։",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, ফলাফলটি শুধুমাত্র এক অঙ্ক না হওয়া পর্যন্ত এর সমস্ত অঙ্ক বারবার যোগ করুন। \nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর মাত্র একটি অঙ্ক আছে, তাই 2 হল ফলাফল।",
      "bg": "Като се даде неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    >>> addDigits(38)\n    2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.",
      "zh": "给定一个非负整数 num，重复相加它的所有数字，直到结果只有一位数字。\n\n例如：\n    >>> addDigits(38)\n    2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，2 是结果。",
      "fr": "Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait plus qu'un seul chiffre.\nPar exemple :\n    >>> addDigits(38)\n    2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Angenommen, eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.  \nZum Beispiel:  \n    >>> addDigits(38)  \n    2  \n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara dukkan lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n    >>> addDigits(38)\n    2\n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.",
      "hi": "गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Adott egy nem negatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    >>> addDigits(38)\n    2\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény."
    },
    "docstring_bertscore": {
      "sq": "0.9926026073494987",
      "hy": "0.989102541405283",
      "bn": "0.9773805680988901",
      "bg": "0.9405717762981718",
      "zh": "0.9629500709167054",
      "fr": "0.999999801369619",
      "de": "0.982367382445152",
      "ha": "0.9382996433695138",
      "hi": "0.97704468412456",
      "hu": "0.9519103929691674"
    }
  },
  {
    "task_id": "C/49",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "sq": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse ju dhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "hy": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "bn": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nতুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালা করে ১ থেকে ৩টি পাথর সরিয়ে নাও। যে শেষ পাথরটি সরাবে সে গেমটি জিতে যাবে। পাথরের সংখ্যা n দেওয়া আছে, যদি তুমি ও তোমার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলে, তাহলে তুমি গেমটি জিততে পারবে কিনা তা নির্ধারণ করো।\nনোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "bg": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "zh": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式玩游戏，你是否能赢。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "fr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "de": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nDu spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "ha": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 daga cikin tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance ko za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne ka fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "hi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "hu": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott n kövek száma, határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);"
    },
    "prompt_bertscore": {
      "sq": "0.9960323581388281",
      "hy": "0.9800823385417265",
      "bn": "0.9707471078938489",
      "bg": "0.9888647808391842",
      "zh": "0.9781401306759675",
      "fr": "0.9827757665085597",
      "de": "0.9782676513805918",
      "ha": "0.9783860350876886",
      "hi": "0.990509639024534",
      "hu": "0.9790121180487106"
    },
    "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}",
    "instruction": {
      "en": "Write a C function `bool canWinNim(int n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Shkruani një funksion në C `bool canWinNim(int n)` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Գրեք C ֆունկցիա `bool canWinNim(int n)`՝ հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim անունով խաղ: Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հանում եք 1-ից 3 քարեր կույտից: Նա, ով կհանի վերջին քարը, հաղթում է խաղը: Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով:\nՆշում: Դուք միշտ առաջինն եք խաղում:\n\nԱհա որոշ դեպքեր:\n    >>> canWinNim(1)\n    true",
      "bn": "একটি C ফাংশন `bool canWinNim(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে পাইল থেকে 1 থেকে 3 পাথর সরান। যে শেষ পাথরটি সরায় সে গেমটি জেতে। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলে।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> canWinNim(1)\n    true",
      "bg": "Напишете C функция `bool canWinNim(int n)`, за да решите следния проблем:  \nИграете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.  \nЗабележка: Винаги вие правите първия ход.  \n\nЕто някои случаи:  \n    >>> canWinNim(1)  \n    true  ",
      "zh": "编写一个 C 函数 `bool canWinNim(int n)` 来解决以下问题：  \n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，如果你和你的对手都采取最优策略，确定你是否能赢得游戏。  \n注意：你总是先走。  \n\n以下是一些情况：  \n    >>> canWinNim(1)  \n    true  ",
      "fr": "Écrivez une fonction C `bool canWinNim(int n)` pour résoudre le problème suivant :  \nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :  \n    >>> canWinNim(1)  \n    true  ",
      "de": "Schreiben Sie eine C-Funktion `bool canWinNim(int n)`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben die Anzahl der Steine n, bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen.\nHinweis: Sie sind immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Rubuta aikin C `bool canWinNim(int n)` don warware matsalar mai zuwa:\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna yin juyi don cire 1 zuwa 3 daga cikin duwatsun. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da yawan duwatsu n, tantance idan zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kake fara juyi na farko.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "C फ़ंक्शन `bool canWinNim(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर यह निर्धारित करें कि यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम रूप से खेलते हैं तो क्या आप खेल जीत सकते हैं।\nनोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Írj egy C függvényt `bool canWinNim(int n)` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszotok.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "instruction_bertscore": {
      "sq": "0.9942965272389642",
      "hy": "0.981564915705771",
      "bn": "0.9814292511555242",
      "bg": "0.9882079101691018",
      "zh": "0.9811098535028201",
      "fr": "0.9904603786900374",
      "de": "0.9769350401542288",
      "ha": "0.963004495641109",
      "hi": "0.9675531313668079",
      "hu": "0.9922830110664136"
    },
    "level": "easy",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë e merrni lëvizjen e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հանում եք 1-ից 3 քար կույտից։ Նա, ով կհանի վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true",
      "bn": "আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি একটি স্তূপের n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে স্তূপ থেকে 1 থেকে 3 পাথর সরান। যে শেষ পাথরটি সরায় সে গেমটি জিতে। পাথরের সংখ্যা n দেওয়া আছে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে:\n    >>> canWinNim(1)\n    true",
      "bg": "Вие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. \nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :  \n    >>> canWinNim(1)  \n    true  ",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Kana wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna canza juna don cire 1 zuwa 3 daga cikin duwatsun. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance idan za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne kake fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम रूप से खेलते हैं। \nनोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "A Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezded, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott n kő száma esetén határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "sq": "0.9905438034500721",
      "hy": "0.9722781508708658",
      "bn": "0.9896332817834081",
      "bg": "0.9831736231617726",
      "zh": "0.9624505155084027",
      "fr": "0.9780644525007932",
      "de": "0.971761115989032",
      "ha": "0.9469221882102382",
      "hi": "0.9867195727240073",
      "hu": "0.9670633088471758"
    }
  },
  {
    "task_id": "C/50",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdio.h>\n/*\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "sq": "#include <assert.h>\n#include <stdio.h>\n/*\nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni produktin e a dhe b nëse shuma është tek.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "hy": "#include <assert.h>\n#include <stdio.h>\n/*\nՏրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "bn": "#include <assert.h>\n#include <stdio.h>\n/*\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া আছে, যদি যোগফলটি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "bg": "#include <assert.h>\n#include <stdio.h>\n/*\nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "zh": "#include <assert.h>\n#include <stdio.h>\n/*\n给定两个整数 a 和 b，如果它们的和是偶数则返回和，如果和是奇数则返回 a 和 b 的乘积。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "fr": "#include <assert.h>\n#include <stdio.h>\n/*\nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "de": "#include <assert.h>\n#include <stdio.h>\n/*\nGegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "ha": "#include <assert.h>\n#include <stdio.h>\n/*\nAn ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma dawo da samfurin a da b idan jumlar tana da lamba mai wargi.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "hi": "#include <assert.h>\n#include <stdio.h>\n/*\nदो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "hu": "#include <assert.h>\n#include <stdio.h>\n/*\nAdott két egész szám, a és b, add vissza az összegüket, ha az összeg páros, vagy add vissza a szorzatukat, ha az összeg páratlan.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);"
    },
    "prompt_bertscore": {
      "sq": "0.9945603083849786",
      "hy": "0.999999801369619",
      "bn": "0.9608157874724855",
      "bg": "0.999999801369619",
      "zh": "0.9910028382606437",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9689787016114954",
      "hi": "0.9890371920099225",
      "hu": "0.966454705359685"
    },
    "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "en": "Write a C function `int evenSumOrOddProduct(int a, int b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n",
      "sq": "Shkruani një funksion në C `int evenSumOrOddProduct(int a, int b)` për të zgjidhur problemin në vijim:  \nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose kthejeni prodhimin e a dhe b nëse shuma është tek.  \n    >>> evenSumOrOddProduct(2, 3)  \n    6  \n    >>> evenSumOrOddProduct(5, 5)  \n    10  ",
      "hy": "Գրեք C ֆունկցիա `int evenSumOrOddProduct(int a, int b)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։",
      "bn": "একটি C ফাংশন `int evenSumOrOddProduct(int a, int b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া দুটি পূর্ণসংখ্যা a এবং b, যদি যোগফল জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফল বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।",
      "bg": "Напишете C функция `int evenSumOrOddProduct(int a, int b)` за решаване на следния проблем:  \nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.",
      "zh": "编写一个C函数 `int evenSumOrOddProduct(int a, int b)` 来解决以下问题：  \n给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。",
      "fr": "Écrire une fonction C `int evenSumOrOddProduct(int a, int b)` pour résoudre le problème suivant :  \nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.  \n    >>> evenSumOrOddProduct(2, 3)  \n    6  \n    >>> evenSumOrOddProduct(5, 5)  \n    10  ",
      "de": "Schreiben Sie eine C-Funktion `int evenSumOrOddProduct(int a, int b)`, um das folgende Problem zu lösen:  \nGegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist, oder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.  \n    >>> evenSumOrOddProduct(2, 3)  \n    6  \n    >>> evenSumOrOddProduct(5, 5)  \n    10  ",
      "ha": "Rubuta wani aikin C `int evenSumOrOddProduct(int a, int b)` don warware matsalar mai zuwa:  \nAn ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai lamba, ko dawo da samfurin a da b idan jumlar tana da lamba mara lamba.  \n    >>> evenSumOrOddProduct(2, 3)  \n    6  \n    >>> evenSumOrOddProduct(5, 5)  \n    10  ",
      "hi": "C फ़ंक्शन `int evenSumOrOddProduct(int a, int b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hu": "Írj egy C függvényt `int evenSumOrOddProduct(int a, int b)` a következő probléma megoldására:  \nKét egész szám, a és b adott, add vissza az összegüket, ha az összeg páros, vagy add vissza a és b szorzatát, ha az összeg páratlan.  \n    >>> evenSumOrOddProduct(2, 3)  \n    6  \n    >>> evenSumOrOddProduct(5, 5)  \n    10  "
    },
    "instruction_bertscore": {
      "sq": "0.9945746097724131",
      "hy": "0.9209463001304007",
      "bn": "0.9209463001304007",
      "bg": "0.9209463001304007",
      "zh": "0.8866380661965307",
      "fr": "1",
      "de": "1",
      "ha": "0.9727634048917341",
      "hi": "1",
      "hu": "0.9778688015754738"
    },
    "level": "easy",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even, or return the product of a and b if the sum is odd.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n",
      "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose ktheni produktin e a dhe b nëse shuma është tek.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է:\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।",
      "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "fr": "Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou retourner le produit de a et b si la somme est impaire.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "ha": "An ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma dawo da samfurin a da b idan jumlar tana da lamba mara ma'ana.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योगफल सम है तो योगफल लौटाएं, या यदि योगफल विषम है तो a और b का गुणनफल लौटाएं।\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "hu": "Két egész szám, a és b esetén térj vissza az összeggel, ha az összeg páros, vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10"
    },
    "docstring_bertscore": {
      "sq": "0.9996492187470923",
      "hy": "0.9817744707577628",
      "bn": "0.8544867595703185",
      "bg": "1",
      "zh": "0.9493939446718364",
      "fr": "1",
      "de": "1",
      "ha": "0.9367225181440967",
      "hi": "0.935152543612397",
      "hu": "0.9788577822426465"
    }
  }
]