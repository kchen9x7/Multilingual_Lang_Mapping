[
  {
    "task_id": "JavaScript/1",
    "prompt": {
      "en": "// return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "sq": "// kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "hy": "// վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "bn": "// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nfunction hello_mmcodeeval()",
      "bg": "// връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "fr": "// renvoie \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "de": "// Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "ha": "// dawo da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval()",
      "hi": "// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nfunction hello_mmcodeeval()",
      "hu": "// adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" értéket\nfunction hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "sq": "0.9918720448080524",
      "hy": "1",
      "bn": "0.8748388256719152",
      "bg": "0.8789049882020804",
      "zh": "0.9948397813310946",
      "fr": "0.9918720448080524",
      "de": "0.9948397813310946",
      "ha": "1",
      "hi": "0.9948397813310946",
      "hu": "0.9699245794859834"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "Write a JavaScript function `function hello_mmcodeeval()` to solve the following problem:\nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Shkruani një funksion JavaScript `function hello_mmcodeeval()` për të zgjidhur problemin në vijim: kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Գրեք JavaScript ֆունկցիա `function hello_mmcodeeval()` հետևյալ խնդիրը լուծելու համար:  \nվերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function hello_mmcodeeval()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" রিটার্ন করুন",
      "bg": "Напишете JavaScript функция `function hello_mmcodeeval()` за решаване на следния проблем:  \nвръща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "编写一个 JavaScript 函数 `function hello_mmcodeeval()` 来解决以下问题：  \n返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Écrire une fonction JavaScript `function hello_mmcodeeval()` pour résoudre le problème suivant :  \nretourner \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Schreiben Sie eine JavaScript-Funktion `function hello_mmcodeeval()`, um das folgende Problem zu lösen:  \nreturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Rubuta wani aikin JavaScript `function hello_mmcodeeval()` don warware matsalar mai zuwa:  \nmayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "एक JavaScript फ़ंक्शन `function hello_mmcodeeval()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:  \n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं",
      "hu": "Írj egy JavaScript függvényt `function hello_mmcodeeval()` a következő probléma megoldására:  \nvisszatér \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.9974088666793999",
      "bg": "0.9963173927356131",
      "zh": "0.9974088666793999",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.999999801369619",
      "hi": "0.9974088666793999",
      "hu": "0.9963173927356131"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(hello_mmcodeeval() === \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n})();",
    "entry_point": "hello_mmcodeeval",
    "signature": "function hello_mmcodeeval()",
    "docstring": {
      "en": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "রিটার্ন \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation",
      "bg": "Върнете \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Komawa \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "रिटर्न \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hu": "Visszatér \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "sq": "0.9556513975655785",
      "hy": "1",
      "bn": "0.9107418629351144",
      "bg": "0.9416533187229068",
      "zh": "0.9165684865323918",
      "fr": "0.9359446815719641",
      "de": "0.9556513975655785",
      "ha": "0.89914820485487",
      "hi": "1",
      "hu": "0.9556513975655785"
    }
  },
  {
    "task_id": "JavaScript/2",
    "prompt": {
      "en": "/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param {number} a - Length of side 'a'.\n * @param {number} b - Length of side 'b'.\n * @param {number} c - Length of side 'c'.\n * @returns {string|number} If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\n * Example:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "sq": "/**\n * Llogarit sipërfaqen e një trekëndëshi duke dhënë tre anët e tij.\n * \n * @param {number} a - Gjatësia e anës 'a'.\n * @param {number} b - Gjatësia e anës 'b'.\n * @param {number} c - Gjatësia e anës 'c'.\n * @returns {string|number} Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore. Përndryshe, kthen -1.\n * Shembull:\n *  calculate_triangle_area(3, 5, 4) // kthen 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "hy": "/**\n * Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n * \n * @param {number} a - 'a' կողմի երկարությունը։\n * @param {number} b - 'b' կողմի երկարությունը։\n * @param {number} c - 'c' կողմի երկարությունը։\n * @returns {string|number} Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով։ Հակառակ դեպքում վերադարձնել -1։\n * Օրինակ:\n *  calculate_triangle_area(3, 5, 4) // վերադարձնում է 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "bn": "/**\n * একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n * \n * @param {number} a - 'a' বাহুর দৈর্ঘ্য।\n * @param {number} b - 'b' বাহুর দৈর্ঘ্য।\n * @param {number} c - 'c' বাহুর দৈর্ঘ্য।\n * @returns {string|number} যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন। অন্যথায়, -1 ফেরত দিন।\n * Example:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "bg": "/**\n * Изчислява площта на триъгълник, като се дадат неговите три страни.\n * \n * @param {number} a - Дължина на страната 'a'.\n * @param {number} b - Дължина на страната 'b'.\n * @param {number} c - Дължина на страната 'c'.\n * @returns {string|number} Ако дадените страни образуват триъгълник, връща изчислената площ с 2 десетични знака. В противен случай връща -1.\n * Пример:\n *  calculate_triangle_area(3, 5, 4) // връща 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "zh": "/**\n * 计算给定三边的三角形面积。\n * \n * @param {number} a - 边 'a' 的长度。\n * @param {number} b - 边 'b' 的长度。\n * @param {number} c - 边 'c' 的长度。\n * @returns {string|number} 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。否则，返回 -1。\n * 示例:\n *  calculate_triangle_area(3, 5, 4) // 返回 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "fr": "/**\n * Calculer l'aire d'un triangle donné ses trois côtés.\n * \n * @param {number} a - Longueur du côté 'a'.\n * @param {number} b - Longueur du côté 'b'.\n * @param {number} c - Longueur du côté 'c'.\n * @returns {string|number} Si les côtés fournis forment un triangle, retourne l'aire calculée avec 2 décimales. Sinon, retourne -1.\n * Exemple:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "de": "/**\n * Berechnet die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n * \n * @param {number} a - Länge der Seite 'a'.\n * @param {number} b - Länge der Seite 'b'.\n * @param {number} c - Länge der Seite 'c'.\n * @returns {string|number} Wenn die angegebenen Seiten ein Dreieck bilden, wird die berechnete Fläche mit 2 Dezimalstellen zurückgegeben. Andernfalls wird -1 zurückgegeben.\n * Beispiel:\n *  calculate_triangle_area(3, 5, 4) // gibt 6 zurück\n */\nfunction calculate_triangle_area(a, b, c)",
      "ha": "/**\n * Lissafin yankin wani alwatika idan aka ba da tsawon sassa uku.\n * \n * @param {number} a - Tsawon gefen 'a'.\n * @param {number} b - Tsawon gefen 'b'.\n * @param {number} c - Tsawon gefen 'c'.\n * @returns {string|number} Idan sassan da aka bayar sun kafa alwatika, dawo da yankin da aka lissafa tare da wuraren goma biyu. In ba haka ba, dawo da -1.\n * Misali:\n *  calculate_triangle_area(3, 5, 4) // ya dawo da 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "hi": "/**\n * दिए गए तीन भुजाओं के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n * \n * @param {number} a - भुजा 'a' की लंबाई।\n * @param {number} b - भुजा 'b' की लंबाई।\n * @param {number} c - भुजा 'c' की लंबाई।\n * @returns {string|number} यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\n * Example:\n *  calculate_triangle_area(3, 5, 4) // returns 6\n */\nfunction calculate_triangle_area(a, b, c)",
      "hu": "/**\n * Számítsa ki egy háromszög területét a három oldalának megadásával.\n * \n * @param {number} a - Az 'a' oldal hossza.\n * @param {number} b - A 'b' oldal hossza.\n * @param {number} c - A 'c' oldal hossza.\n * @returns {string|number} Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal. Ellenkező esetben adja vissza -1-et.\n * Példa:\n *  calculate_triangle_area(3, 5, 4) // visszaadja 6\n */\nfunction calculate_triangle_area(a, b, c)"
    },
    "prompt_bertscore": {
      "sq": "0.9951472611609367",
      "hy": "0.9969234140281507",
      "bn": "0.9969234140281507",
      "bg": "0.993811273218096",
      "zh": "0.9872461418641308",
      "fr": "0.9814977786369812",
      "de": "0.9801288180508888",
      "ha": "0.9824228003214607",
      "hi": "0.9846071386217013",
      "hu": "0.9653036423015878"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        let s = (a + b + c) / 2.0;\n        return Number(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculate_triangle_area(a, b, c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\nExample:\n calculate_triangle_area(3, 5, 4) // returns 6\n",
      "sq": "Shkruani një funksion JavaScript `function calculate_triangle_area(a, b, c)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\nParametrat:\n- a (numër): Gjatësia e anës 'a'.\n- b (numër): Gjatësia e anës 'b'.\n- c (numër): Gjatësia e anës 'c'.\n\nKthen:\n- string|numër: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore. Përndryshe, kthen -1.\nShembull:\n calculate_triangle_area(3, 5, 4) // kthen 6",
      "hy": "Գրեք JavaScript ֆունկցիա `function calculate_triangle_area(a, b, c)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\nՊարամետրեր:\n- a (number): 'a' կողմի երկարությունը։\n- b (number): 'b' կողմի երկարությունը։\n- c (number): 'c' կողմի երկարությունը։\n\nՎերադարձնում է:\n- string|number: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով։ Հակառակ դեպքում վերադարձնում է -1։\nՕրինակ:\n calculate_triangle_area(3, 5, 4) // վերադարձնում է 6",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function calculate_triangle_area(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর তিনটি বাহু দেওয়া থাকলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- a (number): 'a' বাহুর দৈর্ঘ্য।\n- b (number): 'b' বাহুর দৈর্ঘ্য।\n- c (number): 'c' বাহুর দৈর্ঘ্য।\n\nফেরত দেয়:\n- string|number: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল ফেরত দিন। অন্যথায়, -1 ফেরত দিন।\nউদাহরণ:\n calculate_triangle_area(3, 5, 4) // 6 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function calculate_triangle_area(a, b, c)`, за да решите следния проблем:\nИзчислете лицето на триъгълник, дадени неговите три страни.\n\nПараметри:\n- a (number): Дължина на страна 'a'.\n- b (number): Дължина на страна 'b'.\n- c (number): Дължина на страна 'c'.\n\nВръща:\n- string|number: Ако предоставените страни образуват триъгълник, върнете изчисленото лице с 2 десетични знака. В противен случай върнете -1.\nПример:\n calculate_triangle_area(3, 5, 4) // връща 6",
      "zh": "编写一个 JavaScript 函数 `function calculate_triangle_area(a, b, c)` 来解决以下问题：\n计算给定三边的三角形面积。\n\n参数：\n- a (number): 边 'a' 的长度。\n- b (number): 边 'b' 的长度。\n- c (number): 边 'c' 的长度。\n\n返回：\n- string|number: 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。否则，返回 -1。\n示例：\n calculate_triangle_area(3, 5, 4) // 返回 6",
      "fr": "Écrire une fonction JavaScript `function calculate_triangle_area(a, b, c)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné ses trois côtés.\n\nParamètres :\n- a (number): Longueur du côté 'a'.\n- b (number): Longueur du côté 'b'.\n- c (number): Longueur du côté 'c'.\n\nRenvoie :\n- string|number: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales. Sinon, renvoie -1.\nExemple :\n calculate_triangle_area(3, 5, 4) // returns 6",
      "de": "Schreiben Sie eine JavaScript-Funktion `function calculate_triangle_area(a, b, c)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n\nParameter:\n- a (number): Länge der Seite 'a'.\n- b (number): Länge der Seite 'b'.\n- c (number): Länge der Seite 'c'.\n\nRückgabewerte:\n- string|number: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück. Andernfalls geben Sie -1 zurück.\nBeispiel:\n calculate_triangle_area(3, 5, 4) // gibt 6 zurück",
      "ha": "Rubuta wani aikin JavaScript `function calculate_triangle_area(a, b, c)` don warware matsalar mai zuwa:\nƘididdige yanki na wani alwatika idan aka ba shi gefensa uku.\n\nSigogi:\n- a (number): Tsawon gefen 'a'.\n- b (number): Tsawon gefen 'b'.\n- c (number): Tsawon gefen 'c'.\n\nDawowa:\n- string|number: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare biyu na adadi. In ba haka ba, dawo da -1.\nMisali:\n calculate_triangle_area(3, 5, 4) // returns 6",
      "hi": "`function calculate_triangle_area(a, b, c)` निम्नलिखित समस्या को हल करने के लिए:\nइसके तीन भुजाओं के दिए गए लंबाई के आधार पर एक त्रिभुज का क्षेत्रफल गणना करें।\n\nपैरामीटर्स:\n- a (number): भुजा 'a' की लंबाई।\n- b (number): भुजा 'b' की लंबाई।\n- c (number): भुजा 'c' की लंबाई।\n\nवापसी मान:\n- string|number: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\nउदाहरण:\n calculate_triangle_area(3, 5, 4) // 6 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function calculate_triangle_area(a, b, c)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n\nParaméterek:\n- a (szám): Az 'a' oldal hossza.\n- b (szám): A 'b' oldal hossza.\n- c (szám): A 'c' oldal hossza.\n\nVisszatérési érték:\n- string|szám: Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel 2 tizedesjegyre kerekítve. Ellenkező esetben térj vissza -1 értékkel.\nPélda:\n calculate_triangle_area(3, 5, 4) // visszatérési érték 6"
    },
    "instruction_bertscore": {
      "sq": "0.9950350349956519",
      "hy": "0.9950350349956519",
      "bn": "0.996931160613011",
      "bg": "0.9951971173865765",
      "zh": "0.9849849336064297",
      "fr": "0.9847175771135568",
      "de": "0.9866218465765382",
      "ha": "0.990548570579217",
      "hi": "0.963647859445281",
      "hu": "0.9710154575386271"
    },
    "level": "easy",
    "test": "const testCalculateTriangleArea = () => {\n    // Triangle with sides 3, 5, 4 should return area 6\n    console.assert(Math.abs(calculate_triangle_area(3, 5, 4) - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should return -1\n    console.assert(calculate_triangle_area(1, 1, 4) === -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    console.assert(Math.abs(calculate_triangle_area(7, 24, 25) - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area within precision range\n    console.assert(Math.abs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-6);\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestCalculateTriangleArea();",
    "entry_point": "calculate_triangle_area",
    "signature": "function calculate_triangle_area(a, b, c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\nParameters:\n- a (number): Length of side 'a'.\n- b (number): Length of side 'b'.\n- c (number): Length of side 'c'.\n\nReturns:\n- string|number: If the provided sides form a triangle, return the calculated area with 2 decimal places. Otherwise, return -1.\nExample:\n calculate_triangle_area(3, 5, 4) // returns 6\n",
      "sq": "Llogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\nParametrat:\n- a (numër): Gjatësia e anës 'a'.\n- b (numër): Gjatësia e anës 'b'.\n- c (numër): Gjatësia e anës 'c'.\n\nKthen:\n- string|numër: Nëse anët e dhëna formojnë një trekëndësh, kthejeni sipërfaqen e llogaritur me 2 shifra dhjetore. Përndryshe, kthe -1.\nShembull:\n calculate_triangle_area(3, 5, 4) // kthen 6",
      "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\nՊարամետրեր:\n- a (թիվ): 'a' կողմի երկարությունը։\n- b (թիվ): 'b' կողմի երկարությունը։\n- c (թիվ): 'c' կողմի երկարությունը։\n\nՎերադարձնում է:\n- string|number: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշաններով։ Հակառակ դեպքում վերադարձնում է -1։\nՕրինակ:\n calculate_triangle_area(3, 5, 4) // վերադարձնում է 6",
      "bn": "ত্রিভুজের তিন বাহুর দৈর্ঘ্য প্রদান করে তার ক্ষেত্রফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- a (number): 'a' বাহুর দৈর্ঘ্য।\n- b (number): 'b' বাহুর দৈর্ঘ্য।\n- c (number): 'c' বাহুর দৈর্ঘ্য।\n\nফেরত দেয়:\n- string|number: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে গণনা করা ক্ষেত্রফল ২ দশমিক স্থান সহ ফেরত দিন। অন্যথায়, -1 ফেরত দিন।\nউদাহরণ:\n calculate_triangle_area(3, 5, 4) // 6 ফেরত দেয়",
      "bg": "Изчислете лицето на триъгълник, дадени неговите три страни.\n\nПараметри:\n- a (number): Дължина на страна 'a'.\n- b (number): Дължина на страна 'b'.\n- c (number): Дължина на страна 'c'.\n\nВръща:\n- string|number: Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната запетая. В противен случай връща -1.\nПример:\n calculate_triangle_area(3, 5, 4) // връща 6",
      "zh": "计算给定三边的三角形面积。\n\n参数:\n- a (number): 边 'a' 的长度。\n- b (number): 边 'b' 的长度。\n- c (number): 边 'c' 的长度。\n\n返回:\n- string|number: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。否则，返回 -1。\n示例:\n calculate_triangle_area(3, 5, 4) // 返回 6",
      "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\nParamètres:\n- a (nombre): Longueur du côté 'a'.\n- b (nombre): Longueur du côté 'b'.\n- c (nombre): Longueur du côté 'c'.\n\nRenvoie:\n- string|nombre: Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales. Sinon, renvoie -1.\nExemple:\n calculate_triangle_area(3, 5, 4) // renvoie 6",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\nParameter:\n- a (number): Länge der Seite 'a'.\n- b (number): Länge der Seite 'b'.\n- c (number): Länge der Seite 'c'.\n\nRückgabewerte:\n- string|number: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück. Andernfalls wird -1 zurückgegeben.\nBeispiel:\n calculate_triangle_area(3, 5, 4) // gibt 6 zurück",
      "ha": "Lissafin yankin wani alwatika idan aka ba da tsawon sassa uku.\n\nSigogi:\n- a (namba): Tsawon gefen 'a'.\n- b (namba): Tsawon gefen 'b'.\n- c (namba): Tsawon gefen 'c'.\n\nDawowa:\n- string|namba: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka lissafa tare da wurare biyu na adadi mai lamba. In ba haka ba, dawo da -1.\nMisali:\n calculate_triangle_area(3, 5, 4) // returns 6",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\nपैरामीटर्स:\n- a (संख्या): भुजा 'a' की लंबाई।\n- b (संख्या): भुजा 'b' की लंबाई।\n- c (संख्या): भुजा 'c' की लंबाई।\n\nरिटर्न्स:\n- string|number: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\nउदाहरण:\n calculate_triangle_area(3, 5, 4) // 6 लौटाता है",
      "hu": "Számítsa ki egy háromszög területét a három oldalának megadásával.\n\nParaméterek:\n- a (szám): Az 'a' oldal hossza.\n- b (szám): A 'b' oldal hossza.\n- c (szám): A 'c' oldal hossza.\n\nVisszatérési érték:\n- string|szám: Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal. Ellenkező esetben adja vissza a -1 értéket.\nPélda:\n calculate_triangle_area(3, 5, 4) // visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9959467484446021",
      "hy": "0.9808774559570093",
      "bn": "0.9826565882799387",
      "bg": "0.9974644831860896",
      "zh": "0.9813136482737619",
      "fr": "0.9807580790980073",
      "de": "0.9824972867143488",
      "ha": "0.9948395827007136",
      "hi": "0.9886099380603164",
      "hu": "0.9535345935948897"
    }
  },
  {
    "task_id": "JavaScript/3",
    "prompt": {
      "en": "\n/**\n * Calculate the value of the function for a given input.\n * \n * Parameters:\n * - x (number): Input value for the function.\n * \n * Returns:\n * - string: If x is not in the defined domain, returns \"Not define\".\n * Otherwise, returns the calculated function value as a string rounded to 5 decimal places.\n * \n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Examples:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "sq": "/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * \n * Parametrat:\n * - x (numër): Vlera hyrëse për funksionin.\n * \n * Kthen:\n * - string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n * Përndryshe, kthen vlerën e llogaritur të funksionit si një string i rrumbullakosur në 5 shifra dhjetore.\n * \n * Përkufizimet e Funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Shembuj:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "hy": "/**\n * Հաշվարկել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n * \n * Պարամետրեր:\n * - x (թիվ): Ֆունկցիայի մուտքային արժեքը։\n * \n * Վերադարձնում է:\n * - string: Եթե x-ը սահմանված դաշտում չէ, վերադարձնում է \"Not define\"։\n * Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը որպես տող, կլորացված մինչև 5 տասնորդական։\n * \n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Օրինակներ:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "bn": "/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * \n * প্যারামিটার:\n * - x (সংখ্যা): ফাংশনের জন্য ইনপুট মান।\n * \n * রিটার্নস:\n * - string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\n * অন্যথায়, গণনা করা ফাংশনের মান একটি স্ট্রিং হিসেবে 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n * \n * ফাংশন সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * \n * উদাহরণ:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "bg": "/**\n * Изчислява стойността на функцията за даден вход.\n * \n * Параметри:\n * - x (number): Входна стойност за функцията.\n * \n * Връща:\n * - string: Ако x не е в определения домейн, връща \"Not define\".\n * В противен случай, връща изчислената стойност на функцията като низ, закръглена до 5 десетични знака.\n * \n * Определения на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Примери:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "zh": "/**\n * 计算给定输入的函数值。\n * \n * 参数:\n * - x (number): 函数的输入值。\n * \n * 返回:\n * - string: 如果 x 不在定义域中，返回 \"Not define\"。\n * 否则，返回计算后的函数值，结果为保留5位小数的字符串。\n * \n * 函数定义:\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * 示例:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "fr": "/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * \n * Paramètres:\n * - x (nombre): Valeur d'entrée pour la fonction.\n * \n * Renvoie:\n * - string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n * Sinon, renvoie la valeur calculée de la fonction sous forme de chaîne arrondie à 5 décimales.\n * \n * Définitions de la fonction:\n * - Pour 0 <= x < 10: y = cos(x + 3.0)\n * - Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Exemples:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "de": "/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * \n * Parameter:\n * - x (number): Eingabewert für die Funktion.\n * \n * Rückgabewerte:\n * - string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n * Andernfalls wird der berechnete Funktionswert als String auf 5 Dezimalstellen gerundet zurückgegeben.\n * \n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Beispiele:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "ha": "/**\n * Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n * \n * Sigogi:\n * - x (lamba): Ƙimar shigarwa don aikin.\n * \n * Mayarwa:\n * - string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\n * In ba haka ba, yana mayar da ƙimar aikin da aka lissafa a matsayin kirtani da aka zagaye zuwa wurare 5 na goma.\n * \n * Ƙayyadaddun Ayyuka:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Misalai:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {",
      "hi": "/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * \n * पैरामीटर्स:\n * - x (संख्या): फ़ंक्शन के लिए इनपुट मान।\n * \n * रिटर्न करता है:\n * - स्ट्रिंग: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n * अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके स्ट्रिंग के रूप में लौटाता है।\n * \n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * \n * उदाहरण:\n * calculateFunctionValue(40); // \"Not define\"\n */",
      "hu": "/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * \n * Paraméterek:\n * - x (szám): A függvény bemeneti értéke.\n * \n * Visszatér:\n * - string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n * Ellenkező esetben visszaadja a számított függvényértéket sztringként, 5 tizedesjegyre kerekítve.\n * \n * Függvénydefiníciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Példák:\n * calculateFunctionValue(40); // \"Not define\"\n */\nconst calculateFunctionValue = (x) => {"
    },
    "prompt_bertscore": {
      "sq": "0.9868931756770318",
      "hy": "0.9465886878004807",
      "bn": "0.976816457816751",
      "bg": "0.9856539207297552",
      "zh": "0.9672315487799125",
      "fr": "0.9786746450313323",
      "de": "0.9683671186682888",
      "ha": "0.9798694067732572",
      "hi": "0.9689403659479555",
      "hu": "0.9754377643419878"
    },
    "canonical_solution": "if (0 <= x && x < 10) {\n        return Math.cos(x + 3.0).toFixed(5);\n    } else if (10 <= x && x < 20) {\n        return Math.pow(Math.cos(x + 7.5), 2).toFixed(5);\n    } else if (20 <= x && x < 30) {\n        return Math.pow(Math.cos(x + 4.0), 4).toFixed(5);\n    } else {\n        return \"Not define\";\n    }\n};",
    "instruction": {
      "en": "Write a JavaScript function `const calculateFunctionValue = (x)` to solve the following problem:\nCalculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value as a string rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExamples:\ncalculateFunctionValue(40); // \"Not define\"\n",
      "sq": "Shkruani një funksion JavaScript `const calculateFunctionValue = (x)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni vlerën e funksionit për një hyrje të dhënë.\n\nParametrat:\n- x (numër): Vlera e hyrjes për funksionin.\n\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".  \nPërndryshe, kthen vlerën e llogaritur të funksionit si një string i rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembuj:\ncalculateFunctionValue(40); // \"Not define\"",
      "hy": "Գրեք JavaScript ֆունկցիա `const calculateFunctionValue = (x)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n\nՊարամետրեր:\n- x (number): Մուտքային արժեք ֆունկցիայի համար։\n\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը որպես տող, կլորացված մինչև 5 տասնորդական թվանշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nՕրինակներ:\ncalculateFunctionValue(40); // \"Not define\"",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const calculateFunctionValue = (x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x (number): ফাংশনের জন্য ইনপুট মান।\n\nরিটার্নস:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান একটি স্ট্রিং হিসাবে ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে।\n\nফাংশনের সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\nউদাহরণসমূহ:\ncalculateFunctionValue(40); // \"Not define\"",
      "bg": "Напишете JavaScript функция `const calculateFunctionValue = (x)`, за да решите следния проблем:\nИзчислете стойността на функцията за даден вход.\n\nПараметри:\n- x (number): Входна стойност за функцията.\n\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай връща изчислената стойност на функцията като низ, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПримери:\ncalculateFunctionValue(40); // \"Not define\"",
      "zh": "编写一个 JavaScript 函数 `const calculateFunctionValue = (x)` 来解决以下问题：  \n计算给定输入的函数值。\n\n参数：\n- x (number): 函数的输入值。\n\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。  \n否则，返回计算后的函数值，结果为字符串并四舍五入到小数点后 5 位。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例：\ncalculateFunctionValue(40); // \"Not define\"",
      "fr": "Écrire une fonction JavaScript `const calculateFunctionValue = (x)` pour résoudre le problème suivant :\nCalculer la valeur de la fonction pour une entrée donnée.\n\nParamètres :\n- x (number) : Valeur d'entrée pour la fonction.\n\nRenvoie :\n- string : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction sous forme de chaîne arrondie à 5 décimales.\n\nDéfinitions de la fonction :\n- Pour 0 <= x < 10 : y = cos(x + 3.0)\n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n\nExemples :\ncalculateFunctionValue(40); // \"Not define\"",
      "de": "Schreiben Sie eine JavaScript-Funktion `const calculateFunctionValue = (x)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe.\n\nParameter:\n- x (number): Eingabewert für die Funktion.\n\nGibt zurück:\n- string: Wenn x nicht im definierten Bereich liegt, gibt \"Not define\" zurück.\nAndernfalls gibt den berechneten Funktionswert als String gerundet auf 5 Dezimalstellen zurück.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiele:\ncalculateFunctionValue(40); // \"Not define\"",
      "ha": "Rubuta wani aikin JavaScript `const calculateFunctionValue = (x)` don warware matsalar mai zuwa:\nLissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi:\n- x (number): Ƙimar shigarwa don aikin.\n\nMayarwa:\n- string: Idan x ba ya cikin kewayon da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka lissafa a matsayin kirtani mai zagaye zuwa wurare 5 na goma.\n\nMa'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMisalai:\ncalculateFunctionValue(40); // \"Not define\"",
      "hi": "`const calculateFunctionValue = (x)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स:\n- x (number): फ़ंक्शन के लिए इनपुट मान।\n\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को एक स्ट्रिंग के रूप में 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\nउदाहरण:\ncalculateFunctionValue(40); // \"Not define\"",
      "hu": "Írj egy JavaScript függvényt `const calculateFunctionValue = (x)` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre.\n\nParaméterek:\n- x (szám): A függvény bemeneti értéke.\n\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, akkor \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza stringként, 5 tizedesjegyre kerekítve.\n\nFüggvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\nPéldák:\ncalculateFunctionValue(40); // \"Not define\""
    },
    "instruction_bertscore": {
      "sq": "0.9876729985529749",
      "hy": "0.9560514391529827",
      "bn": "0.9792768923466301",
      "bg": "0.9865803328269019",
      "zh": "0.979936345211666",
      "fr": "0.9890369933795414",
      "de": "0.9909952903061644",
      "ha": "0.9758274771495783",
      "hi": "0.9783687542445386",
      "hu": "0.963397187904415"
    },
    "level": "easy",
    "test": "const testCalculateFunctionValue = () => {\n    console.assert(calculateFunctionValue(40) === \"Not define\", \"Test case 40 failed\");\n    console.assert(calculateFunctionValue(5) === \"-0.14550\", \"Test case 5 failed\");\n    console.assert(calculateFunctionValue(15) === \"0.76266\", \"Test case 15 failed\");\n    console.assert(calculateFunctionValue(25) === \"0.31314\", \"Test case 25 failed\");\n    console.assert(calculateFunctionValue(-1) === \"Not define\", \"Test case -1 failed\");\n}\n\ntestCalculateFunctionValue();",
    "entry_point": "calculateFunctionValue",
    "signature": "const calculateFunctionValue = (x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value as a string rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExamples:\ncalculateFunctionValue(40); // \"Not define\"\n",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat:\n- x (numër): Vlera e hyrjes për funksionin.\n\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit si një string i rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembuj:\ncalculateFunctionValue(40); // \"Not define\"",
      "hy": "Հաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n\nՊարամետրեր:\n- x (թիվ): Մուտքային արժեք ֆունկցիայի համար։\n\nՎերադարձնում է:\n- string: Եթե x-ն սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը որպես տող՝ կլորացված մինչև 5 տասնորդական նշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nՕրինակներ:\ncalculateFunctionValue(40); // \"Not define\"",
      "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x (সংখ্যা): ফাংশনের জন্য ইনপুট মান।\n\nরিটার্নস:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান একটি স্ট্রিং হিসাবে রিটার্ন করে যা 5 দশমিক স্থান পর্যন্ত রাউন্ড করা হয়।\n\nফাংশন সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\nউদাহরণসমূহ:\ncalculateFunctionValue(40); // \"Not define\"",
      "bg": "Изчислява стойността на функцията за даден вход.\n\nПараметри:\n- x (number): Входна стойност за функцията.\n\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията като низ, закръглена до 5 десетични знака.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПримери:\ncalculateFunctionValue(40); // \"Not define\"",
      "zh": "计算给定输入的函数值。\n\n参数：\n- x (number): 函数的输入值。\n\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n  否则，返回计算后的函数值，结果为保留 5 位小数的字符串。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例：\ncalculateFunctionValue(40); // \"Not define\"",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n\nParamètres:\n- x (nombre): Valeur d'entrée pour la fonction.\n\nRenvoie:\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction sous forme de chaîne arrondie à 5 décimales.\n\nDéfinitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExemples:\ncalculateFunctionValue(40); // \"Not define\"",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n\nParameter:\n- x (number): Eingabewert für die Funktion.\n\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert als String auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiele:\ncalculateFunctionValue(40); // \"Not define\"",
      "ha": "Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi:\n- x (namba): Darajar shigarwa don aikin.\n\nDawowa:\n- string: Idan x ba ya cikin kewayon da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa da darajar aikin da aka lissafa a matsayin string da aka zagaye zuwa wurare 5 na decimal.\n\nMa'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMisalai:\ncalculateFunctionValue(40); // \"Not define\"",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स:\n- x (संख्या): फ़ंक्शन के लिए इनपुट मान।\n\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना की गई फ़ंक्शन का मान एक स्ट्रिंग के रूप में लौटाता है, जो 5 दशमलव स्थानों तक गोल है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\nउदाहरण:\ncalculateFunctionValue(40); // \"Not define\"",
      "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\n\nParaméterek:\n- x (szám): A függvény bemeneti értéke.\n\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve, stringként.\n\nFüggvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\nPéldák:\ncalculateFunctionValue(40); // \"Not define\""
    },
    "docstring_bertscore": {
      "sq": "0.9867483741292574",
      "hy": "0.9508542752332049",
      "bn": "0.9789757686889812",
      "bg": "0.985368290241827",
      "zh": "0.967325699580523",
      "fr": "0.9776052190598405",
      "de": "0.969574791384981",
      "ha": "0.9746354962329878",
      "hi": "0.9761456830199962",
      "hu": "0.9555336097496248"
    }
  },
  {
    "task_id": "JavaScript/4",
    "prompt": {
      "en": "/**\n * Find the maximum and minimum of three distinct integers.\n *\n * Parameters:\n * a (number): The first integer.\n * b (number): The second integer.\n * c (number): The third integer.\n *\n * Returns:\n * Object: An object with properties 'max' and 'min'.\n *\n * Example call:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "sq": "/**\n * Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n *\n * Parametrat:\n * a (numër): Numri i parë i plotë.\n * b (numër): Numri i dytë i plotë.\n * c (numër): Numri i tretë i plotë.\n *\n * Kthen:\n * Objekt: Një objekt me pronat 'max' dhe 'min'.\n *\n * Shembull thirrjeje:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "hy": "/**\n * Գտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\n *\n * Պարամետրեր:\n * a (number): Առաջին ամբողջ թիվը։\n * b (number): Երկրորդ ամբողջ թիվը։\n * c (number): Երրորդ ամբողջ թիվը։\n *\n * Վերադարձնում է:\n * Object: Օբյեկտ՝ 'max' և 'min' հատկություններով։\n *\n * Օրինակ կանչ:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "bn": "/**\n * তিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n *\n * প্যারামিটার:\n * a (number): প্রথম পূর্ণসংখ্যা।\n * b (number): দ্বিতীয় পূর্ণসংখ্যা।\n * c (number): তৃতীয় পূর্ণসংখ্যা।\n *\n * রিটার্নস:\n * অবজেক্ট: 'max' এবং 'min' প্রপার্টি সহ একটি অবজেক্ট।\n *\n * উদাহরণ কল:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "bg": "/**\n * Намерете максимума и минимума на три различни цели числа.\n *\n * Параметри:\n * a (number): Първото цяло число.\n * b (number): Второто цяло число.\n * c (number): Третото цяло число.\n *\n * Връща:\n * Object: Обект със свойства 'max' и 'min'.\n *\n * Пример за извикване:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "zh": "/**\n * 找到三个不同整数的最大值和最小值。\n *\n * 参数:\n * a (number): 第一个整数。\n * b (number): 第二个整数。\n * c (number): 第三个整数。\n *\n * 返回:\n * Object: 一个包含 'max' 和 'min' 属性的对象。\n *\n * 示例调用:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "fr": "/**\n * Trouver le maximum et le minimum de trois entiers distincts.\n *\n * Paramètres :\n * a (nombre) : Le premier entier.\n * b (nombre) : Le deuxième entier.\n * c (nombre) : Le troisième entier.\n *\n * Renvoie :\n * Objet : Un objet avec les propriétés 'max' et 'min'.\n *\n * Exemple d'appel :\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "de": "/**\n * Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n *\n * Parameter:\n * a (number): Die erste ganze Zahl.\n * b (number): Die zweite ganze Zahl.\n * c (number): Die dritte ganze Zahl.\n *\n * Rückgabe:\n * Objekt: Ein Objekt mit den Eigenschaften 'max' und 'min'.\n *\n * Beispielaufruf:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "ha": "/**\n * Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\n *\n * Sigogi:\n * a (lamba): Lamba ta farko.\n * b (lamba): Lamba ta biyu.\n * c (lamba): Lamba ta uku.\n *\n * Komawa:\n * Abu: Abu tare da dukiyoyi 'max' da 'min'.\n *\n * Misali kira:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "hi": "/**\n * तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n *\n * पैरामीटर्स:\n * a (number): पहला पूर्णांक।\n * b (number): दूसरा पूर्णांक।\n * c (number): तीसरा पूर्णांक।\n *\n * रिटर्न:\n * Object: एक ऑब्जेक्ट जिसमें 'max' और 'min' गुण होते हैं।\n *\n * उदाहरण कॉल:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)",
      "hu": "/**\n * Három különböző egész szám maximumának és minimumának meghatározása.\n *\n * Paraméterek:\n * a (szám): Az első egész szám.\n * b (szám): A második egész szám.\n * c (szám): A harmadik egész szám.\n *\n * Visszatérési érték:\n * Objektum: Egy objektum 'max' és 'min' tulajdonságokkal.\n *\n * Példa hívás:\n * const result = findMaxMin(1, 2, 3);\n * console.assert(result.max === 3 && result.min === 1);\n */\nfunction findMaxMin(a, b, c)"
    },
    "prompt_bertscore": {
      "sq": "0.9965946807475379",
      "hy": "0.9900786110976884",
      "bn": "0.9718963832785168",
      "bg": "0.9965946807475379",
      "zh": "0.9884343488034816",
      "fr": "0.9923145932969981",
      "de": "0.9930503202283514",
      "ha": "0.9594138542431413",
      "hi": "0.9760237239660408",
      "hu": "0.9653441628993189"
    },
    "canonical_solution": "{\n    let max, min;\n    \n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = (b < c) ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = (a < c) ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return { max, min };\n}",
    "instruction": {
      "en": "Write a JavaScript function `function findMaxMin(a, b, c)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n\nExample call:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "sq": "Shkruani një funksion JavaScript `function findMaxMin(a, b, c)` për të zgjidhur problemin e mëposhtëm:\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\n- a (numër): Numri i parë i plotë.\n- b (numër): Numri i dytë i plotë.\n- c (numër): Numri i tretë i plotë.\n\nKthen:\n- Objekt: Një objekt me pronat 'max' dhe 'min'.\n\nShembull thirrjeje:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "hy": "Գրեք JavaScript ֆունկցիա `function findMaxMin(a, b, c)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\n\nՊարամետրեր:\n- a (number): Առաջին ամբողջ թիվը։\n- b (number): Երկրորդ ամբողջ թիվը։\n- c (number): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\n- Object: Օբյեկտ, որը պարունակում է 'max' և 'min' հատկությունները։\n\nՕրինակ կանչ:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "bn": "একটি JavaScript ফাংশন `function findMaxMin(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nতিনটি পৃথক পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\n\nপ্যারামিটারসমূহ:\n- a (number): প্রথম পূর্ণসংখ্যা।\n- b (number): দ্বিতীয় পূর্ণসংখ্যা।\n- c (number): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\n- Object: একটি অবজেক্ট যার প্রপার্টি 'max' এবং 'min'।\n\nউদাহরণ কল:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "bg": "Напишете JavaScript функция `function findMaxMin(a, b, c)` за решаване на следния проблем:\nНамерете максимума и минимума на три различни цели числа.\n\nПараметри:\n- a (number): Първото цяло число.\n- b (number): Второто цяло число.\n- c (number): Третото цяло число.\n\nВръща:\n- Обект: Обект със свойства 'max' и 'min'.\n\nПримерно извикване:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "zh": "编写一个 JavaScript 函数 `function findMaxMin(a, b, c)` 来解决以下问题：\n找出三个不同整数的最大值和最小值。\n\n参数：\n- a (number): 第一个整数。\n- b (number): 第二个整数。\n- c (number): 第三个整数。\n\n返回：\n- Object: 一个包含 'max' 和 'min' 属性的对象。\n\n示例调用：\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "fr": "Écrire une fonction JavaScript `function findMaxMin(a, b, c)` pour résoudre le problème suivant :  \nTrouver le maximum et le minimum de trois entiers distincts.\n\nParamètres :\n- a (number): Le premier entier.\n- b (number): Le deuxième entier.\n- c (number): Le troisième entier.\n\nRenvoie :\n- Object: Un objet avec les propriétés 'max' et 'min'.\n\nExemple d'appel :\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "de": "Schreiben Sie eine JavaScript-Funktion `function findMaxMin(a, b, c)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\n- a (number): Die erste ganze Zahl.\n- b (number): Die zweite ganze Zahl.\n- c (number): Die dritte ganze Zahl.\n\nRückgabewert:\n- Objekt: Ein Objekt mit den Eigenschaften 'max' und 'min'.\n\nBeispielaufruf:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "ha": "Rubuta wani aikin JavaScript `function findMaxMin(a, b, c)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu banbanci.\n\nSigogi:\n- a (number): Lamba ta farko.\n- b (number): Lamba ta biyu.\n- c (number): Lamba ta uku.\n\nKomawa:\n- Object: Wani abu tare da kaddarorin 'max' da 'min'.\n\nMisalin kira:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function findMaxMin(a, b, c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n\nपैरामीटर्स:\n- a (number): पहला पूर्णांक।\n- b (number): दूसरा पूर्णांक।\n- c (number): तीसरा पूर्णांक।\n\nवापसी मान:\n- Object: एक ऑब्जेक्ट जिसमें 'max' और 'min' गुण होते हैं।\n\nउदाहरण कॉल:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "hu": "Írj egy JavaScript függvényt `function findMaxMin(a, b, c)` a következő probléma megoldására:\nTaláld meg három különböző egész szám maximumát és minimumát.\n\nParaméterek:\n- a (number): Az első egész szám.\n- b (number): A második egész szám.\n- c (number): A harmadik egész szám.\n\nVisszatérési érték:\n- Object: Egy objektum 'max' és 'min' tulajdonságokkal.\n\nPélda hívás:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);"
    },
    "instruction_bertscore": {
      "sq": "0.9930862723273186",
      "hy": "0.9839540419288586",
      "bn": "0.9871120663569323",
      "bg": "0.9968489276352626",
      "zh": "0.9775599313329646",
      "fr": "0.9962280090641474",
      "de": "0.9878233617514183",
      "ha": "0.9618063571827066",
      "hi": "0.9750496405774456",
      "hu": "0.983654705944639"
    },
    "level": "middle",
    "test": "function testFindMaxMin() {\n    let result = findMaxMin(1, 2, 3);\n    console.assert(result.max === 3 && result.min === 1);\n\n    // Additional tests\n    result = findMaxMin(5, 3, 4);\n    console.assert(result.max === 5 && result.min === 3);\n\n    result = findMaxMin(10, -2, 7);\n    console.assert(result.max === 10 && result.min === -2);\n\n    result = findMaxMin(-1, -3, -2);\n    console.assert(result.max === -1 && result.min === -3);\n}\n\ntestFindMaxMin();",
    "entry_point": "findMaxMin",
    "signature": "function findMaxMin(a, b, c)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\n\nParameters:\n- a (number): The first integer.\n- b (number): The second integer.\n- c (number): The third integer.\n\nReturns:\n- Object: An object with properties 'max' and 'min'.\n\nExample call:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\n- a (numër): Numri i parë i plotë.\n- b (numër): Numri i dytë i plotë.\n- c (numër): Numri i tretë i plotë.\n\nKthen:\n- Objekt: Një objekt me pronat 'max' dhe 'min'.\n\nShembull thirrjeje:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "hy": "Գտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\n\nՊարամետրեր՝\n- a (number): Առաջին ամբողջ թիվը։\n- b (number): Երկրորդ ամբողջ թիվը։\n- c (number): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է՝\n- Object: Օբյեկտ, որը պարունակում է 'max' և 'min' հատկությունները։\n\nՕրինակ կանչ՝\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- a (number): প্রথম পূর্ণসংখ্যা।\n- b (number): দ্বিতীয় পূর্ণসংখ্যা।\n- c (number): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\n- অবজেক্ট: একটি অবজেক্ট যার প্রপার্টি 'max' এবং 'min'।\n\nউদাহরণ কল:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "bg": "Намерете максимума и минимума на три различни цели числа.\n\nПараметри:\n- a (number): Първото цяло число.\n- b (number): Второто цяло число.\n- c (number): Третото цяло число.\n\nВръща:\n- Object: Обект със свойства 'max' и 'min'.\n\nПример за извикване:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "zh": "找出三个不同整数的最大值和最小值。\n\n参数：\n- a (number): 第一个整数。\n- b (number): 第二个整数。\n- c (number): 第三个整数。\n\n返回：\n- Object: 一个包含属性 'max' 和 'min' 的对象。\n\n示例调用：\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.\n\nParamètres:\n- a (nombre): Le premier entier.\n- b (nombre): Le deuxième entier.\n- c (nombre): Le troisième entier.\n\nRenvoie:\n- Objet: Un objet avec les propriétés 'max' et 'min'.\n\nExemple d'appel:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\n- a (number): Die erste ganze Zahl.\n- b (number): Die zweite ganze Zahl.\n- c (number): Die dritte ganze Zahl.\n\nRückgabewert:\n- Objekt: Ein Objekt mit den Eigenschaften 'max' und 'min'.\n\nBeispielaufruf:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\n\nSigogi:\n- a (number): Lamba na farko.\n- b (number): Lamba na biyu.\n- c (number): Lamba na uku.\n\nDawowa:\n- Abu: Abu tare da kaddarorin 'max' da 'min'.\n\nMisalin kira:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n\nपैरामीटर्स:\n- a (संख्या): पहला पूर्णांक।\n- b (संख्या): दूसरा पूर्णांक।\n- c (संख्या): तीसरा पूर्णांक।\n\nवापसी:\n- वस्तु: एक वस्तु जिसमें 'max' और 'min' गुण होते हैं।\n\nउदाहरण कॉल:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);",
      "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\n\nParaméterek:\n- a (szám): Az első egész szám.\n- b (szám): A második egész szám.\n- c (szám): A harmadik egész szám.\n\nVisszatérési érték:\n- Objektum: Egy objektum 'max' és 'min' tulajdonságokkal.\n\nPélda hívás:\nconst result = findMaxMin(1, 2, 3);\nconsole.assert(result.max === 3 && result.min === 1);"
    },
    "docstring_bertscore": {
      "sq": "0.9959741594371849",
      "hy": "0.9787632341812739",
      "bn": "0.980096044038018",
      "bg": "0.9959741594371849",
      "zh": "0.9752746887991581",
      "fr": "0.9971788526981615",
      "de": "0.9768136769914164",
      "ha": "0.978951734412876",
      "hi": "0.9770409101473204",
      "hu": "0.9655960262224712"
    }
  },
  {
    "task_id": "JavaScript/5",
    "prompt": {
      "en": "/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n *\n * Parameters:\n * - xa (number): x-coordinate of point A.\n * - ya (number): y-coordinate of point A.\n * - xb (number): x-coordinate of point B.\n * - yb (number): y-coordinate of point B.\n *\n * Returns:\n * number: The distance between points A and B.\n * Example usage:\n * console.log(calculateDistance(0,0,3,4)); // Expected output: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "sq": "/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n *\n * Parametrat:\n * - xa (numër): koordinata x e pikës A.\n * - ya (numër): koordinata y e pikës A.\n * - xb (numër): koordinata x e pikës B.\n * - yb (numër): koordinata y e pikës B.\n *\n * Kthen:\n * numër: Distanca midis pikave A dhe B.\n * Shembull përdorimi:\n * console.log(calculateDistance(0,0,3,4)); // Rezultati i pritur: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "hy": "/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n *\n * Պարամետրեր:\n * - xa (թիվ): A կետի x-կոորդինատը։\n * - ya (թիվ): A կետի y-կոորդինատը։\n * - xb (թիվ): B կետի x-կոորդինատը։\n * - yb (թիվ): B կետի y-կոորդինատը։\n *\n * Վերադարձնում է:\n * թիվ: Հեռավորությունը A և B կետերի միջև։\n * Օգտագործման օրինակ:\n * console.log(calculateDistance(0,0,3,4)); // Սպասվող արդյունք: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "bn": "/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব নির্ণয় করুন।\n *\n * প্যারামিটারসমূহ:\n * - xa (number): বিন্দু A এর x-সমন্বয়।\n * - ya (number): বিন্দু A এর y-সমন্বয়।\n * - xb (number): বিন্দু B এর x-সমন্বয়।\n * - yb (number): বিন্দু B এর y-সমন্বয়।\n *\n * রিটার্ন করে:\n * number: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n * উদাহরণ ব্যবহার:\n * console.log(calculateDistance(0,0,3,4)); // প্রত্যাশিত আউটপুট: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "bg": "/**\n * Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n *\n * Параметри:\n * - xa (number): x-координата на точка A.\n * - ya (number): y-координата на точка A.\n * - xb (number): x-координата на точка B.\n * - yb (number): y-координата на точка B.\n *\n * Връща:\n * number: Разстоянието между точките A и B.\n * Пример за използване:\n * console.log(calculateDistance(0,0,3,4)); // Очакван резултат: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "zh": "/**\n * 计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n *\n * 参数:\n * - xa (number): 点 A 的 x 坐标。\n * - ya (number): 点 A 的 y 坐标。\n * - xb (number): 点 B 的 x 坐标。\n * - yb (number): 点 B 的 y 坐标。\n *\n * 返回:\n * number: 点 A 和 B 之间的距离。\n * 示例用法:\n * console.log(calculateDistance(0,0,3,4)); // 预期输出: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "fr": "/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n *\n * Paramètres :\n * - xa (nombre) : coordonnée x du point A.\n * - ya (nombre) : coordonnée y du point A.\n * - xb (nombre) : coordonnée x du point B.\n * - yb (nombre) : coordonnée y du point B.\n *\n * Renvoie :\n * nombre : La distance entre les points A et B.\n * Exemple d'utilisation :\n * console.log(calculateDistance(0,0,3,4)); // Résultat attendu : 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "de": "/**\n * Berechnet die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n *\n * Parameter:\n * - xa (number): x-Koordinate des Punktes A.\n * - ya (number): y-Koordinate des Punktes A.\n * - xb (number): x-Koordinate des Punktes B.\n * - yb (number): y-Koordinate des Punktes B.\n *\n * Rückgabewert:\n * number: Die Entfernung zwischen den Punkten A und B.\n * Beispielverwendung:\n * console.log(calculateDistance(0,0,3,4)); // Erwartete Ausgabe: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "ha": "/**\n * Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n *\n * Sigogi:\n * - xa (lamba): x-daftarin maki A.\n * - ya (lamba): y-daftarin maki A.\n * - xb (lamba): x-daftarin maki B.\n * - yb (lamba): y-daftarin maki B.\n *\n * Komawa:\n * lamba: Nisan tsakanin maki A da B.\n * Misalin amfani:\n * console.log(calculateDistance(0,0,3,4)); // Fitar da ake tsammani: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "hi": "/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n *\n * पैरामीटर्स:\n * - xa (number): बिंदु A का x-निर्देशांक।\n * - ya (number): बिंदु A का y-निर्देशांक।\n * - xb (number): बिंदु B का x-निर्देशांक।\n * - yb (number): बिंदु B का y-निर्देशांक।\n *\n * रिटर्न करता है:\n * number: बिंदुओं A और B के बीच की दूरी।\n * उदाहरण उपयोग:\n * console.log(calculateDistance(0,0,3,4)); // अपेक्षित आउटपुट: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)",
      "hu": "/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n *\n * Paraméterek:\n * - xa (szám): A pont x-koordinátája.\n * - ya (szám): A pont y-koordinátája.\n * - xb (szám): B pont x-koordinátája.\n * - yb (szám): B pont y-koordinátája.\n *\n * Visszatér:\n * szám: A és B pontok közötti távolság.\n * Példa használat:\n * console.log(calculateDistance(0,0,3,4)); // Várt kimenet: 5\n */\nfunction calculateDistance(xa, ya, xb, yb)"
    },
    "prompt_bertscore": {
      "sq": "0.9719585545877807",
      "hy": "0.973281035664711",
      "bn": "0.9967456398371244",
      "bg": "0.9922269972989617",
      "zh": "0.9755627028516587",
      "fr": "0.9934728070488126",
      "de": "0.9943118217783039",
      "ha": "1",
      "hi": "0.9967456398371244",
      "hu": "0.9705675460293933"
    },
    "canonical_solution": "{\n    return Math.sqrt(Math.pow(xa - xb, 2) + Math.pow(ya - yb, 2));\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculateDistance(xa, ya, xb, yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\nExample usage:\nconsole.log(calculateDistance(0,0,3,4)); // Expected output: 5\n",
      "sq": "Shkruani një funksion JavaScript `function calculateDistance(xa, ya, xb, yb)` për të zgjidhur problemin e mëposhtëm:\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (number): koordinata x e pikës A.\n- ya (number): koordinata y e pikës A.\n- xb (number): koordinata x e pikës B.\n- yb (number): koordinata y e pikës B.\n\nKthen:\nnumber: Distanca midis pikave A dhe B.\nShembull përdorimi:\nconsole.log(calculateDistance(0,0,3,4)); // Rezultati i pritur: 5",
      "hy": "Գրեք JavaScript ֆունկցիա `function calculateDistance(xa, ya, xb, yb)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք հեռավորությունը երկու կետերի միջև՝ A (xa, ya) և B (xb, yb):\n\nՊարամետրեր:\n- xa (number): A կետի x-կոորդինատը։\n- ya (number): A կետի y-կոորդինատը։\n- xb (number): B կետի x-կոորդինատը։\n- yb (number): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nnumber: Հեռավորությունը A և B կետերի միջև։\nՕրինակ օգտագործում:\nconsole.log(calculateDistance(0,0,3,4)); // Սպասվող արդյունք: 5",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function calculateDistance(xa, ya, xb, yb)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (number): বিন্দু A এর x-সমন্বয়।\n- ya (number): বিন্দু A এর y-সমন্বয়।\n- xb (number): বিন্দু B এর x-সমন্বয়।\n- yb (number): বিন্দু B এর y-সমন্বয়।\n\nফেরত দিবে:\nnumber: বিন্দু A এবং B এর মধ্যে দূরত্ব।\nউদাহরণ ব্যবহার:\nconsole.log(calculateDistance(0,0,3,4)); // প্রত্যাশিত আউটপুট: 5",
      "bg": "Напишете JavaScript функция `function calculateDistance(xa, ya, xb, yb)` за решаване на следния проблем:\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (number): x-координата на точка A.\n- ya (number): y-координата на точка A.\n- xb (number): x-координата на точка B.\n- yb (number): y-координата на точка B.\n\nВръща:\nnumber: Разстоянието между точките A и B.\nПример за използване:\nconsole.log(calculateDistance(0,0,3,4)); // Очакван резултат: 5",
      "zh": "编写一个 JavaScript 函数 `function calculateDistance(xa, ya, xb, yb)` 来解决以下问题：  \n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (number): 点 A 的 x 坐标。\n- ya (number): 点 A 的 y 坐标。\n- xb (number): 点 B 的 x 坐标。\n- yb (number): 点 B 的 y 坐标。\n\n返回：\nnumber: 点 A 和 B 之间的距离。\n示例用法：\nconsole.log(calculateDistance(0,0,3,4)); // 预期输出: 5",
      "fr": "Écrire une fonction JavaScript `function calculateDistance(xa, ya, xb, yb)` pour résoudre le problème suivant :  \nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (number): coordonnée x du point A.\n- ya (number): coordonnée y du point A.\n- xb (number): coordonnée x du point B.\n- yb (number): coordonnée y du point B.\n\nRenvoie :\nnumber: La distance entre les points A et B.  \nExemple d'utilisation :\nconsole.log(calculateDistance(0,0,3,4)); // Expected output: 5",
      "de": "Schreiben Sie eine JavaScript-Funktion `function calculateDistance(xa, ya, xb, yb)`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (number): x-Koordinate des Punktes A.\n- ya (number): y-Koordinate des Punktes A.\n- xb (number): x-Koordinate des Punktes B.\n- yb (number): y-Koordinate des Punktes B.\n\nRückgabewert:\nnumber: Die Entfernung zwischen den Punkten A und B.\nBeispielverwendung:\nconsole.log(calculateDistance(0,0,3,4)); // Erwartete Ausgabe: 5",
      "ha": "Rubuta wani aikin JavaScript `function calculateDistance(xa, ya, xb, yb)` don warware matsalar mai zuwa:\nLissafa nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (number): x-aji na maki A.\n- ya (number): y-aji na maki A.\n- xb (number): x-aji na maki B.\n- yb (number): y-aji na maki B.\n\nDawowa:\nnumber: Nisan tsakanin maki A da B.\nMisalin amfani:\nconsole.log(calculateDistance(0,0,3,4)); // Ana tsammanin fitarwa: 5",
      "hi": "JavaScript फ़ंक्शन `function calculateDistance(xa, ya, xb, yb)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (number): बिंदु A का x-निर्देशांक।\n- ya (number): बिंदु A का y-निर्देशांक।\n- xb (number): बिंदु B का x-निर्देशांक।\n- yb (number): बिंदु B का y-निर्देशांक।\n\nवापसी:\nnumber: बिंदुओं A और B के बीच की दूरी।\nउदाहरण उपयोग:\nconsole.log(calculateDistance(0,0,3,4)); // Expected output: 5",
      "hu": "Írj egy JavaScript függvényt `function calculateDistance(xa, ya, xb, yb)` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (number): A pont x-koordinátája.\n- ya (number): A pont y-koordinátája.\n- xb (number): B pont x-koordinátája.\n- yb (number): B pont y-koordinátája.\n\nVisszatérési érték:\nnumber: Az A és B pontok közötti távolság.\nPélda használat:\nconsole.log(calculateDistance(0,0,3,4)); // Várt kimenet: 5"
    },
    "instruction_bertscore": {
      "sq": "0.9950838980693865",
      "hy": "0.994506082290956",
      "bn": "0.9971518389663407",
      "bg": "0.9950737679199537",
      "zh": "0.9778884659831962",
      "fr": "0.9965746190790533",
      "de": "0.9946383701247252",
      "ha": "1",
      "hi": "0.9825630333704714",
      "hu": "0.9706607036780988"
    },
    "level": "easy",
    "test": "const testCalculateDistance = () => {\n    console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6);\n    console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6);\n    console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    // console.log(\"All test cases passed!\");\n}\n\ntestCalculateDistance();",
    "entry_point": "calculateDistance",
    "signature": "function calculateDistance(xa, ya, xb, yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (number): x-coordinate of point A.\n- ya (number): y-coordinate of point A.\n- xb (number): x-coordinate of point B.\n- yb (number): y-coordinate of point B.\n\nReturns:\nnumber: The distance between points A and B.\nExample usage:\nconsole.log(calculateDistance(0,0,3,4)); // Expected output: 5\n",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (numër): koordinata x e pikës A.\n- ya (numër): koordinata y e pikës A.\n- xb (numër): koordinata x e pikës B.\n- yb (numër): koordinata y e pikës B.\n\nKthen:\nnumër: Distanca midis pikave A dhe B.\nShembull përdorimi:\nconsole.log(calculateDistance(0,0,3,4)); // Rezultati i pritur: 5",
      "hy": "Հաշվել երկու կետերի A (xa, ya) և B (xb, yb) միջև հեռավորությունը։\n\nՊարամետրեր:\n- xa (թիվ): A կետի x-կոորդինատը։\n- ya (թիվ): A կետի y-կոորդինատը։\n- xb (թիվ): B կետի x-կոորդինատը։\n- yb (թիվ): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nթիվ: A և B կետերի միջև հեռավորությունը։\nՕրինակ օգտագործում:\nconsole.log(calculateDistance(0,0,3,4)); // Սպասվող արդյունք: 5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব নির্ণয় করুন।\n\nপ্যারামিটারসমূহ:\n- xa (number): বিন্দু A এর x-অক্ষাংশ।\n- ya (number): বিন্দু A এর y-অক্ষাংশ।\n- xb (number): বিন্দু B এর x-অক্ষাংশ।\n- yb (number): বিন্দু B এর y-অক্ষাংশ।\n\nরিটার্নস:\nnumber: বিন্দু A এবং B এর মধ্যবর্তী দূরত্ব।\nউদাহরণ ব্যবহার:\nconsole.log(calculateDistance(0,0,3,4)); // প্রত্যাশিত আউটপুট: 5",
      "bg": "Изчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (number): x-координата на точка A.\n- ya (number): y-координата на точка A.\n- xb (number): x-координата на точка B.\n- yb (number): y-координата на точка B.\n\nВръща:\nnumber: Разстоянието между точките A и B.\nПример за използване:\nconsole.log(calculateDistance(0,0,3,4)); // Очакван резултат: 5",
      "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (number): 点 A 的 x 坐标。\n- ya (number): 点 A 的 y 坐标。\n- xb (number): 点 B 的 x 坐标。\n- yb (number): 点 B 的 y 坐标。\n\n返回：\nnumber: 点 A 和 B 之间的距离。\n示例用法：\nconsole.log(calculateDistance(0,0,3,4)); // 预期输出: 5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres:\n- xa (nombre): coordonnée x du point A.\n- ya (nombre): coordonnée y du point A.\n- xb (nombre): coordonnée x du point B.\n- yb (nombre): coordonnée y du point B.\n\nRenvoie:\nnombre: La distance entre les points A et B.\nExemple d'utilisation:\nconsole.log(calculateDistance(0,0,3,4)); // Résultat attendu: 5",
      "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (number): x-Koordinate des Punktes A.\n- ya (number): y-Koordinate des Punktes A.\n- xb (number): x-Koordinate des Punktes B.\n- yb (number): y-Koordinate des Punktes B.\n\nRückgabewert:\nnumber: Die Entfernung zwischen den Punkten A und B.\nBeispielverwendung:\nconsole.log(calculateDistance(0,0,3,4)); // Erwartete Ausgabe: 5",
      "ha": "Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (number): x-da'irar maki A.\n- ya (number): y-da'irar maki A.\n- xb (number): x-da'irar maki B.\n- yb (number): y-da'irar maki B.\n\nDawowa:\nnumber: Nisan tsakanin maki A da B.\nMisalin amfani:\nconsole.log(calculateDistance(0,0,3,4)); // Fitar da ake tsammani: 5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (संख्या): बिंदु A का x-निर्देशांक।\n- ya (संख्या): बिंदु A का y-निर्देशांक।\n- xb (संख्या): बिंदु B का x-निर्देशांक।\n- yb (संख्या): बिंदु B का y-निर्देशांक।\n\nवापसी:\nसंख्या: बिंदु A और B के बीच की दूरी।\nउदाहरण उपयोग:\nconsole.log(calculateDistance(0,0,3,4)); // अपेक्षित आउटपुट: 5",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (szám): A pont x-koordinátája.\n- ya (szám): A pont y-koordinátája.\n- xb (szám): B pont x-koordinátája.\n- yb (szám): B pont y-koordinátája.\n\nVisszatérési érték:\nszám: Az A és B pontok közötti távolság.\nPélda használat:\nconsole.log(calculateDistance(0,0,3,4)); // Várt kimenet: 5"
    },
    "docstring_bertscore": {
      "sq": "0.9593046075335722",
      "hy": "0.9967935097589538",
      "bn": "0.9970843046367889",
      "bg": "0.9913907633948048",
      "zh": "0.9714313895565141",
      "fr": "0.9913907633948048",
      "de": "0.9936285332675439",
      "ha": "0.999999801369619",
      "hi": "0.9960762554530368",
      "hu": "0.9607268010617819"
    }
  },
  {
    "task_id": "JavaScript/6",
    "prompt": {
      "en": "/**\n * Find the factorial of N and take the modulo 10007 of the result.\n * \n * Parameters:\n * - N (number): A non-negative integer representing the input value (N <= 10000).\n * \n * Returns:\n * - number: The result after taking the modulo 10007 of the factorial of N.\n * \n * Examples:\n * processRequest(1) returns 1\n */\nfunction processRequest(n)",
      "sq": "/**\n * Gjeni faktorialin e N dhe merrni modulo 10007 të rezultatit.\n * \n * Parametrat:\n * - N (numër): Një numër i plotë jo-negativ që përfaqëson vlerën hyrëse (N <= 10000).\n * \n * Kthen:\n * - numër: Rezultati pas marrjes së modulo 10007 të faktorialit të N.\n * \n * Shembuj:\n * processRequest(1) kthen 1\n */\nfunction processRequest(n)",
      "hy": "/**\n * Գտնել N-ի ֆակտորիալը և վերցնել արդյունքի 10007 մոդուլը։\n * \n * Պարամետրեր:\n * - N (թիվ): Ոչ բացասական ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n * \n * Վերադարձնում է:\n * - թիվ: Արդյունքը N-ի ֆակտորիալի 10007 մոդուլը վերցնելուց հետո։\n * \n * Օրինակներ:\n * processRequest(1) վերադարձնում է 1\n */\nfunction processRequest(n)",
      "bn": "/**\n * N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n * \n * প্যারামিটার:\n * - N (সংখ্যা): একটি অ-ঋণাত্মক পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n * \n * রিটার্নস:\n * - সংখ্যা: N এর ফ্যাক্টোরিয়ালের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n * \n * উদাহরণ:\n * processRequest(1) 1 রিটার্ন করে\n */\nfunction processRequest(n)",
      "bg": "/**\n * Намерете факториела на N и вземете модуло 10007 от резултата.\n * \n * Параметри:\n * - N (number): Ненегативно цяло число, представляващо входната стойност (N <= 10000).\n * \n * Връща:\n * - number: Резултатът след вземане на модуло 10007 от факториела на N.\n * \n * Примери:\n * processRequest(1) връща 1\n */\nfunction processRequest(n)",
      "zh": "/**\n * 找出N的阶乘并对结果取模10007。\n * \n * 参数:\n * - N (number): 一个非负整数，表示输入值 (N <= 10000)。\n * \n * 返回:\n * - number: N的阶乘对10007取模后的结果。\n * \n * 示例:\n * processRequest(1) 返回 1\n */\nfunction processRequest(n)",
      "fr": "/**\n * Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n * \n * Paramètres:\n * - N (nombre): Un entier non négatif représentant la valeur d'entrée (N <= 10000).\n * \n * Renvoie:\n * - nombre: Le résultat après avoir pris le modulo 10007 de la factorielle de N.\n * \n * Exemples:\n * processRequest(1) returns 1\n */\nfunction processRequest(n)",
      "de": "/**\n * Finde die Fakultät von N und berechne das Modulo 10007 des Ergebnisses.\n * \n * Parameter:\n * - N (number): Eine nicht-negative ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n * \n * Rückgabewerte:\n * - number: Das Ergebnis nach der Berechnung des Modulo 10007 der Fakultät von N.\n * \n * Beispiele:\n * processRequest(1) gibt 1 zurück\n */\nfunction processRequest(n)",
      "ha": "/**\n * Nemo factorial na N kuma ka ɗauki modulo 10007 na sakamakon.\n * \n * Sigogi:\n * - N (lamba): Lamba maras kyau mai wakiltar ƙimar shigarwa (N <= 10000).\n * \n * Komawa:\n * - lamba: Sakamakon bayan ɗaukar modulo 10007 na factorial na N.\n * \n * Misalai:\n * processRequest(1) returns 1\n */\nfunction processRequest(n)",
      "hi": "/**\n * N का फैक्टोरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n * \n * पैरामीटर्स:\n * - N (संख्या): इनपुट मान का प्रतिनिधित्व करने वाला एक गैर-ऋणात्मक पूर्णांक (N <= 10000)।\n * \n * रिटर्न्स:\n * - संख्या: N के फैक्टोरियल का 10007 से माड्यूलो लेने के बाद का परिणाम।\n * \n * उदाहरण:\n * processRequest(1) 1 लौटाता है\n */\nfunction processRequest(n)",
      "hu": "/**\n * Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n * \n * Paraméterek:\n * - N (szám): Egy nem negatív egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n * \n * Visszatér:\n * - szám: Az N faktoriálisának 10007-es modulójának eredménye.\n * \n * Példák:\n * processRequest(1) visszaadja 1\n */\nfunction processRequest(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9902851866939647",
      "hy": "0.9693908596521427",
      "bn": "0.9719519997852065",
      "bg": "0.9830407394368602",
      "zh": "0.9492449718860602",
      "fr": "1",
      "de": "0.9747205100360709",
      "ha": "1",
      "hi": "0.9719519997852065",
      "hu": "0.9603390745580018"
    },
    "canonical_solution": "{\n    // An array to store the precomputed factorial modulo results\n    const MOD = 10007;\n    let factorials = new Array(10001);\n    factorials[0] = factorials[1] = 1; // factorial(0) = factorial(1) = 1\n\n    // Precompute the factorials modulo 10007 for integers up to 10000\n    for (let i = 2; i <= 10000; i++) {\n        factorials[i] = (factorials[i - 1] * i) % MOD;\n    }\n\n    return factorials[n];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function processRequest(n)` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n\nExamples:\nprocessRequest(1) returns 1\n",
      "sq": "Shkruani një funksion JavaScript `function processRequest(n)` për të zgjidhur problemin në vijim:  \nGjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (numër): Një numër i plotë jo-negativ që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\n- numër: Rezultati pasi të merret modulo 10007 i faktorielit të N.\n\nShembuj:\nprocessRequest(1) kthen 1",
      "hy": "Գրեք JavaScript ֆունկցիա `function processRequest(n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլո:\n\nՊարամետրեր:\n- N (number): Ոչ բացասական ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):\n\nՎերադարձնում է:\n- number: Արդյունքը, երբ վերցվում է N-ի ֆակտորիալի 10007 մոդուլոն:\n\nՕրինակներ:\nprocessRequest(1) վերադարձնում է 1",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function processRequest(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল খুঁজুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটারসমূহ:\n- N (সংখ্যা): একটি অ-ঋণাত্মক পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\n- সংখ্যা: N এর ফ্যাক্টোরিয়ালের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n\nউদাহরণসমূহ:\nprocessRequest(1) 1 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function processRequest(n)`, за да решите следния проблем:  \nНамерете факториела на N и вземете модул 10007 от резултата.\n\nПараметри:\n- N (number): Ненегативно цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\n- number: Резултатът след вземане на модул 10007 от факториела на N.\n\nПримери:  \nprocessRequest(1) връща 1",
      "zh": "编写一个 JavaScript 函数 `function processRequest(n)` 来解决以下问题：  \n求 N 的阶乘并取结果的 10007 模。\n\n参数：\n- N (number): 表示输入值的非负整数 (N <= 10000)。\n\n返回：\n- number: N 的阶乘取 10007 模后的结果。\n\n示例：\nprocessRequest(1) 返回 1",
      "fr": "Écrire une fonction JavaScript `function processRequest(n)` pour résoudre le problème suivant :  \nTrouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres :  \n- N (number) : Un entier non négatif représentant la valeur d'entrée (N <= 10000).\n\nRenvoie :  \n- number : Le résultat après avoir pris le modulo 10007 de la factorielle de N.\n\nExemples :  \nprocessRequest(1) renvoie 1",
      "de": "Schreiben Sie eine JavaScript-Funktion `function processRequest(n)`, um das folgende Problem zu lösen:  \nFinden Sie die Fakultät von N und nehmen Sie das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (number): Eine nicht-negative ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewerte:\n- number: Das Ergebnis nach der Modulo-Operation 10007 der Fakultät von N.\n\nBeispiele:\nprocessRequest(1) gibt 1 zurück",
      "ha": "Rubuta aikin JavaScript `function processRequest(n)` don warware matsalar mai zuwa:  \nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (number): Lamba mai kyau wanda ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\n- number: Sakamakon bayan ɗaukar modulo 10007 na factorial na N.\n\nMisalai:\nprocessRequest(1) returns 1",
      "hi": "JavaScript फ़ंक्शन `function processRequest(n)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nN का फैक्टोरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n\nपैरामीटर्स:\n- N (संख्या): एक गैर-ऋणात्मक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी मान:\n- संख्या: N के फैक्टोरियल का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\nprocessRequest(1) 1 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function processRequest(n)` a következő probléma megoldására:  \nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (szám): Egy nem negatív egész szám, amely a bemeneti értéket jelképezi (N <= 10000).\n\nVisszatérési érték:\n- szám: Az eredmény, miután a faktoriális 10007-es modulóját vettük.\n\nPéldák:\nprocessRequest(1) visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9896769804672358",
      "hy": "0.9504701240762834",
      "bn": "0.9776304451182319",
      "bg": "0.9857353591859795",
      "zh": "0.9626805294896411",
      "fr": "1",
      "de": "0.9734333851669648",
      "ha": "0.9670905212093777",
      "hi": "0.9568974059458103",
      "hu": "0.9648652650506438"
    },
    "level": "middle",
    "test": "const testProcessRequest = () => {\n    console.assert(processRequest(0) === 1, \"Expected factorial of 0 modulo 10007 is 1\");\n    console.assert(processRequest(1) === 1, \"Expected factorial of 1 modulo 10007 is 1\");\n    console.assert(processRequest(2) === 2, \"Expected factorial of 2 modulo 10007 is 2\");\n    console.assert(processRequest(3) === 6, \"Expected factorial of 3 modulo 10007 is 6\");\n    console.assert(processRequest(4) === 24, \"Expected factorial of 4 modulo 10007 is 24\");\n    console.assert(processRequest(10) === 6266, \"Expected factorial of 10 modulo 10007 is 6266\");\n    console.assert(processRequest(10000) === 6991, \"Expected factorial of 10000 modulo 10007 is 6991\");\n\n    // console.log(\"All tests passed.\");\n}\n\ntestProcessRequest();",
    "entry_point": "processRequest",
    "signature": "function processRequest(n)",
    "docstring": {
      "en": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (number): A non-negative integer representing the input value (N <= 10000).\n\nReturns:\n- number: The result after taking the modulo 10007 of the factorial of N.\n\nExamples:\nprocessRequest(1) returns 1\n",
      "sq": "Gjeni faktorialin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (numër): Një numër i plotë jo-negativ që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\n- numër: Rezultati pasi të merret modulo 10007 i faktorialit të N.\n\nShembuj:\nprocessRequest(1) kthen 1",
      "hy": "Գտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլով։\n\nՊարամետրեր:\n- N (number): Ոչ բացասական ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\n- number: Արդյունքը N-ի ֆակտորիալը 10007 մոդուլով վերցնելուց հետո։\n\nՕրինակներ:\nprocessRequest(1) վերադարձնում է 1",
      "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটার:\n- N (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nরিটার্নস:\n- number: N এর ফ্যাক্টোরিয়াল থেকে 10007 এর মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\nprocessRequest(1) returns 1",
      "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:\n- N (number): Ненегативно цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\n- number: Резултатът след вземане на модуло 10007 от факториела на N.\n\nПримери:\nprocessRequest(1) връща 1",
      "zh": "计算N的阶乘，并对结果取模10007。\n\n参数：\n- N (number): 一个非负整数，表示输入值 (N <= 10000)。\n\n返回：\n- number: 对N的阶乘取模10007后的结果。\n\n示例：\nprocessRequest(1) 返回 1",
      "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres:\n- N (nombre): Un entier non négatif représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\n- nombre: Le résultat après avoir pris le modulo 10007 de la factorielle de N.\n\nExemples:\nprocessRequest(1) renvoie 1",
      "de": "Finde die Fakultät von N und berechne das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (number): Eine nicht-negative ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\n- number: Das Ergebnis nach der Berechnung des Modulo 10007 der Fakultät von N.\n\nBeispiele:\nprocessRequest(1) gibt 1 zurück",
      "ha": "Nemo factorial na N kuma ka ɗauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (number): Lamba mara kyau wadda ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\n- number: Sakamakon bayan ɗaukar modulo 10007 na factorial na N.\n\nMisalai:\nprocessRequest(1) returns 1",
      "hi": "N का फैक्टरियल खोजें और परिणाम का 10007 से माड्यूलो लें।\n\nपैरामीटर्स:\n- N (number): एक गैर-ऋणात्मक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nरिटर्न्स:\n- number: N के फैक्टरियल का 10007 से माड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\nprocessRequest(1) returns 1",
      "hu": "Találd meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (szám): Egy nem negatív egész szám, amely az input értéket képviseli (N <= 10000).\n\nVisszatér:\n- szám: Az N faktoriálisa 10007-es maradékának eredménye.\n\nPéldák:\nprocessRequest(1) returns 1"
    },
    "docstring_bertscore": {
      "sq": "0.9855532151265705",
      "hy": "0.9638876063151901",
      "bn": "0.9969738661449334",
      "bg": "0.9801691400182388",
      "zh": "0.9372272379423063",
      "fr": "1",
      "de": "0.9712011769448947",
      "ha": "1",
      "hi": "0.9595014502411777",
      "hu": "0.963386461863839"
    }
  },
  {
    "task_id": "JavaScript/7",
    "prompt": {
      "en": "// No direct imports are needed in JavaScript as we are not using any specific external libraries for this code\n/**\n * Calculate the area of a triangle given its base and height.\n * Parameters:\n * - base (number): The base length of the triangle.\n * - height (number): The height of the triangle.\n * Returns:\n * float: The calculated area of the triangle, rounded to one decimal place.\n * Examples:\n * calculate_triangle_area(1,2) returns 1.0\n */\nconst calculate_triangle_area = (base, height) =>",
      "sq": "// Nuk ka nevojë për importe direkte në JavaScript pasi nuk po përdorim ndonjë bibliotekë specifike të jashtme për këtë kod\n/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n * Parametrat:\n * - base (numër): Gjatësia e bazës së trekëndëshit.\n * - height (numër): Lartësia e trekëndëshit.\n * Kthen:\n * float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n * Shembuj:\n * calculate_triangle_area(1,2) kthen 1.0\n */",
      "hy": "// JavaScript-ում ուղղակի ներմուծումներ անհրաժեշտ չեն, քանի որ այս կոդի համար հատուկ արտաքին գրադարաններ չենք օգտագործում\n/**\n * Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա հիմքը և բարձրությունը։\n * Պարամետրեր:\n * - base (number): Եռանկյան հիմքի երկարությունը։\n * - height (number): Եռանկյան բարձրությունը։\n * Վերադարձնում է:\n * float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n * Օրինակներ:\n * calculate_triangle_area(1,2) վերադարձնում է 1.0\n */\nconst calculate_triangle_area = (base, height) =>",
      "bn": "// এই কোডের জন্য আমরা কোনো নির্দিষ্ট বাহ্যিক লাইব্রেরি ব্যবহার করছি না বলে জাভাস্ক্রিপ্টে সরাসরি কোনো ইমপোর্টের প্রয়োজন নেই\n/**\n * একটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n * প্যারামিটারসমূহ:\n * - base (number): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n * - height (number): ত্রিভুজের উচ্চতা।\n * রিটার্নস:\n * float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n * উদাহরণ:\n * calculate_triangle_area(1,2) 1.0 রিটার্ন করে\n */",
      "bg": "// Не са необходими директни импорти в JavaScript, тъй като не използваме никакви специфични външни библиотеки за този код\n/**\n * Изчислява площта на триъгълник, дадени неговата основа и височина.\n * Параметри:\n * - base (number): Дължината на основата на триъгълника.\n * - height (number): Височината на триъгълника.\n * Връща:\n * float: Изчислената площ на триъгълника, закръглена до едно десетично място.\n * Примери:\n * calculate_triangle_area(1,2) връща 1.0\n */",
      "zh": "// 在JavaScript中不需要直接导入，因为我们没有使用任何特定的外部库\n/**\n * 计算给定底边和高的三角形面积。\n * 参数：\n * - base (number): 三角形的底边长度。\n * - height (number): 三角形的高度。\n * 返回：\n * float: 计算出的三角形面积，四舍五入到小数点后一位。\n * 示例：\n * calculate_triangle_area(1,2) 返回 1.0\n */",
      "fr": "// Aucune importation directe n'est nécessaire en JavaScript car nous n'utilisons pas de bibliothèques externes spécifiques pour ce code\n/**\n * Calculer l'aire d'un triangle donné sa base et sa hauteur.\n * Paramètres :\n * - base (number): La longueur de la base du triangle.\n * - height (number): La hauteur du triangle.\n * Retourne :\n * float: L'aire calculée du triangle, arrondie à une décimale.\n * Exemples :\n * calculate_triangle_area(1,2) returns 1.0\n */",
      "de": "// Keine direkten Importe in JavaScript erforderlich, da wir keine spezifischen externen Bibliotheken für diesen Code verwenden\n/**\n * Berechnet die Fläche eines Dreiecks anhand seiner Basis und Höhe.\n * Parameter:\n * - base (number): Die Basislänge des Dreiecks.\n * - height (number): Die Höhe des Dreiecks.\n * Rückgabewert:\n * float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n * Beispiele:\n * calculate_triangle_area(1,2) gibt 1.0 zurück\n */",
      "ha": "// Babu buƙatar shigo da kai tsaye a JavaScript saboda ba ma amfani da kowane takamaiman ɗakunan karatu na waje don wannan lambar\n/**\n * Lissafa yanki na alwatika la'akari da ginshiƙi da tsayinsa.\n * Sigogi:\n * - base (number): Tsawon ginshiƙin alwatika.\n * - height (number): Tsayin alwatika.\n * Returns:\n * float: An lissafa yanki na alwatika, an zagaye zuwa wuri ɗaya na ɗigon goma.\n * Misalai:\n * calculate_triangle_area(1,2) returns 1.0\n */",
      "hi": "// इस कोड के लिए किसी विशेष बाहरी लाइब्रेरी का उपयोग नहीं कर रहे हैं इसलिए JavaScript में सीधे आयात की आवश्यकता नहीं है\n/**\n * दिए गए आधार और ऊंचाई के साथ त्रिभुज का क्षेत्रफल गणना करें।\n * पैरामीटर:\n * - base (number): त्रिभुज की आधार लंबाई।\n * - height (number): त्रिभुज की ऊंचाई।\n * रिटर्न करता है:\n * float: त्रिभुज के क्षेत्रफल की गणना, एक दशमलव स्थान तक गोल की गई।\n * उदाहरण:\n * calculate_triangle_area(1,2) 1.0 लौटाता है\n */",
      "hu": "// Nincs szükség közvetlen importokra a JavaScriptben, mivel nem használunk semmilyen speciális külső könyvtárat ehhez a kódhoz\n/**\n * Számítsa ki egy háromszög területét az alapja és a magassága alapján.\n * Paraméterek:\n * - base (number): A háromszög alapjának hossza.\n * - height (number): A háromszög magassága.\n * Visszatér:\n * float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n * Példák:\n * calculate_triangle_area(1,2) visszaadja 1.0\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9567665085247083",
      "hy": "0.9587581753553451",
      "bn": "0.9308224013058364",
      "bg": "0.9577425782171137",
      "zh": "0.9455158851125112",
      "fr": "0.9610330891093377",
      "de": "0.9540029640333699",
      "ha": "0.9550545132705686",
      "hi": "0.9347421732451788",
      "hu": "0.9506357818140665"
    },
    "canonical_solution": "{\n    return (base * height) / 2.0; // The formula for the area of a triangle is (base * height) / 2\n};",
    "instruction": {
      "en": "Write a JavaScript function `const calculate_triangle_area = (base, height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExamples:\ncalculate_triangle_area(1,2) returns 1.0",
      "sq": "Shkruani një funksion JavaScript `const calculate_triangle_area = (base, height)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.  \nParametrat:  \n- base (number): Gjatësia e bazës së trekëndëshit.  \n- height (number): Lartësia e trekëndëshit.  \nKthen:  \nfloat: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.  \nShembuj:  \ncalculate_triangle_area(1,2) kthen 1.0  ",
      "hy": "Գրեք JavaScript ֆունկցիա `const calculate_triangle_area = (base, height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով դրա հիմքը և բարձրությունը:\nՊարամետրեր:\n- base (number): Եռանկյան հիմքի երկարությունը:\n- height (number): Եռանկյան բարձրությունը:\nՎերադարձնում է:\nfloat: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\nՕրինակներ:\ncalculate_triangle_area(1,2) returns 1.0",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const calculate_triangle_area = (base, height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর ভিত্তি এবং উচ্চতা দেওয়া একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- base (number): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (number): ত্রিভুজের উচ্চতা।\nফেরত দেয়:\nfloat: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে গোলাকার।\nউদাহরণসমূহ:\ncalculate_triangle_area(1,2) ফেরত দেয় 1.0",
      "bg": "Напишете JavaScript функция `const calculate_triangle_area = (base, height)`, за да решите следния проблем:  \nИзчислете площта на триъгълник, като се даде неговата основа и височина.  \nПараметри:  \n- base (number): Дължината на основата на триъгълника.  \n- height (number): Височината на триъгълника.  \nВръща:  \nfloat: Изчислената площ на триъгълника, закръглена до един десетичен знак.  \nПримери:  \ncalculate_triangle_area(1,2) връща 1.0",
      "zh": "编写一个 JavaScript 函数 `const calculate_triangle_area = (base, height)` 来解决以下问题：  \n计算给定底边和高的三角形的面积。  \n参数：  \n- base (number): 三角形的底边长度。  \n- height (number): 三角形的高度。  \n返回：  \nfloat: 计算出的三角形面积，四舍五入到小数点后一位。  \n示例：  \ncalculate_triangle_area(1,2) 返回 1.0",
      "fr": "Écrire une fonction JavaScript `const calculate_triangle_area = (base, height)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné sa base et sa hauteur.  \nParamètres :  \n- base (number): La longueur de la base du triangle.  \n- height (number): La hauteur du triangle.  \nRenvoie :  \nfloat: L'aire calculée du triangle, arrondie à une décimale.  \nExemples :  \ncalculate_triangle_area(1,2) returns 1.0  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `const calculate_triangle_area = (base, height)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\nParameter:\n- base (number): Die Basislänge des Dreiecks.\n- height (number): Die Höhe des Dreiecks.\nRückgabewert:\nfloat: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\nBeispiele:\ncalculate_triangle_area(1,2) returns 1.0",
      "ha": "Rubuta aikin JavaScript `const calculate_triangle_area = (base, height)` don warware matsalar mai zuwa:\nƘididdige yanki na alwatika idan aka ba da tushe da tsawo.\nSigogi:\n- base (number): Tsawon tushe na alwatika.\n- height (number): Tsawon alwatika.\nYa dawo:\nfloat: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.\nMisalai:\ncalculate_triangle_area(1,2) returns 1.0",
      "hi": "JavaScript फ़ंक्शन `const calculate_triangle_area = (base, height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nत्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\nपैरामीटर्स:\n- base (number): त्रिभुज की आधार लंबाई।\n- height (number): त्रिभुज की ऊँचाई।\nवापसी:\nfloat: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\nउदाहरण:\ncalculate_triangle_area(1,2) 1.0 लौटाता है।",
      "hu": "Írj egy JavaScript függvényt `const calculate_triangle_area = (base, height)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét az alapja és magassága alapján.\nParaméterek:\n- base (number): A háromszög alapjának hossza.\n- height (number): A háromszög magassága.\nVisszatérési érték:\nfloat: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\nPéldák:\ncalculate_triangle_area(1,2) visszaadja 1.0"
    },
    "instruction_bertscore": {
      "sq": "0.9895276104206976",
      "hy": "0.9915480786565845",
      "bn": "0.9895276104206976",
      "bg": "0.9873351282748345",
      "zh": "0.9853420710315304",
      "fr": "0.9895276104206976",
      "de": "0.9887382532864649",
      "ha": "0.9874547037642175",
      "hi": "0.9749987911999007",
      "hu": "0.9777146643997907"
    },
    "level": "easy",
    "test": "const testCalculateTriangleArea = () => {\n    const epsilon = 1e-6;\n    console.assert(Math.abs(calculate_triangle_area(1, 2) - 1.0) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(3, 4) - 6.0) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(5, 8) - 20.0) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(7, 3) - 10.5) < epsilon);\n    console.assert(Math.abs(calculate_triangle_area(10, 10) - 50.0) < epsilon);\n    \n    // console.log(\"All tests passed.\");\n};\n\ntestCalculateTriangleArea();",
    "entry_point": "calculate_triangle_area",
    "signature": "const calculate_triangle_area = (base, height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\nParameters:\n- base (number): The base length of the triangle.\n- height (number): The height of the triangle.\nReturns:\nfloat: The calculated area of the triangle, rounded to one decimal place.\nExamples:\ncalculate_triangle_area(1,2) returns 1.0",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\nParametrat:\n- base (numër): Gjatësia e bazës së trekëndëshit.\n- height (numër): Lartësia e trekëndëshit.\nKthen:\nfloat: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\nShembuj:\ncalculate_triangle_area(1,2) kthen 1.0",
      "hy": "Եռանկյան մակերեսը հաշվարկել՝ հաշվի առնելով նրա հիմքը և բարձրությունը:\nՊարամետրեր:\n- base (number): Եռանկյան հիմքի երկարությունը:\n- height (number): Եռանկյան բարձրությունը:\nՎերադարձնում է:\nfloat: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\nՕրինակներ:\ncalculate_triangle_area(1,2) վերադարձնում է 1.0",
      "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে এর ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- base (number): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (number): ত্রিভুজের উচ্চতা।\nফেরত দেয়:\nfloat: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\nউদাহরণসমূহ:\ncalculate_triangle_area(1,2) 1.0 ফেরত দেয়",
      "bg": "Изчислява площта на триъгълник, дадени неговата основа и височина.\nПараметри:\n- base (number): Дължината на основата на триъгълника.\n- height (number): Височината на триъгълника.\nВръща:\nfloat: Изчислената площ на триъгълника, закръглена до едно десетично място.\nПримери:\ncalculate_triangle_area(1,2) връща 1.0",
      "zh": "计算给定底边和高的三角形面积。\n参数：\n- base (number): 三角形的底边长度。\n- height (number): 三角形的高度。\n返回：\nfloat: 计算出的三角形面积，四舍五入到小数点后一位。\n示例：\ncalculate_triangle_area(1,2) 返回 1.0",
      "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\nParamètres:\n- base (nombre): La longueur de la base du triangle.\n- height (nombre): La hauteur du triangle.\nRenvoie:\nfloat: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\nExemples:\ncalculate_triangle_area(1,2) renvoie 1.0",
      "de": "Berechne die Fläche eines Dreiecks anhand seiner Basis und Höhe.\nParameter:\n- base (number): Die Basislänge des Dreiecks.\n- height (number): Die Höhe des Dreiecks.\nRückgabewert:\nfloat: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\nBeispiele:\ncalculate_triangle_area(1,2) gibt 1.0 zurück",
      "ha": "Babu buƙatar shigo da kai tsaye a JavaScript saboda ba ma amfani da kowane takamaiman ɗakunan karatu na waje don wannan lambar\nSigogi:\n- base (number): Tsawon tushe na alwatika.\n- height (number): Tsawon tsawo na alwatika.\nDawowa:\nfloat: An lissafa yankin alwatika, an zagaye zuwa wurin goma daya.\nMisalai:\ncalculate_triangle_area(1,2) returns 1.0",
      "hi": "त्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\nपैरामीटर्स:\n- base (संख्या): त्रिभुज की आधार लंबाई।\n- height (संख्या): त्रिभुज की ऊँचाई।\nवापसी:\nfloat: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\nउदाहरण:\ncalculate_triangle_area(1,2) 1.0 लौटाता है।",
      "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\nParaméterek:\n- base (szám): A háromszög alapjának hossza.\n- height (szám): A háromszög magassága.\nVisszatérési érték:\nfloat: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\nPéldák:\ncalculate_triangle_area(1,2) visszaadja 1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9874167653614399",
      "hy": "0.9874167653614399",
      "bn": "0.9891764319070279",
      "bg": "0.986950977117913",
      "zh": "0.9822362863936689",
      "fr": "0.9891764319070279",
      "de": "0.9815432649942382",
      "ha": "0.9765411561086366",
      "hi": "0.9718701640682201",
      "hu": "0.969654640798157"
    }
  },
  {
    "task_id": "JavaScript/8",
    "prompt": {
      "en": "/**\n * Calculate the Hamming distance between two integers in their binary representation.\n *\n * Parameters:\n * - x: The first positive integer (x <= 1,000,000,000).\n * - y: The second positive integer (y <= 1,000,000,000).\n *\n * Returns:\n * The Hamming distance between x and y, i.e., the number of bits that need to be\n * flipped to transform x into y.\n * \n * Examples:\n * hammingDistance(1, 2) // returns 2\n */\nfunction hammingDistance(x, y)",
      "sq": "/**\n * Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin e tyre binar.\n *\n * Parametrat:\n * - x: Numri i parë pozitiv (x <= 1,000,000,000).\n * - y: Numri i dytë pozitiv (y <= 1,000,000,000).\n *\n * Kthen:\n * Distanca Hamming midis x dhe y, dmth, numri i bitëve që duhet të ndryshohen\n * për të transformuar x në y.\n * \n * Shembuj:\n * hammingDistance(1, 2) // kthen 2\n */\nfunction hammingDistance(x, y)",
      "hy": "/**\n * Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև իրենց բինար ներկայացման մեջ։\n *\n * Պարամետրեր:\n * - x: Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n * - y: Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n *\n * Վերադարձնում է:\n * Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է\n * փոխվեն x-ը y-ի վերածելու համար։\n * \n * Օրինակներ:\n * hammingDistance(1, 2) // վերադարձնում է 2\n */\nfunction hammingDistance(x, y)",
      "bn": "/**\n * দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n *\n * প্যারামিটার:\n * - x: প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n * - y: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n *\n * রিটার্ন:\n * x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট\n * উল্টাতে হবে।\n * \n * উদাহরণ:\n * hammingDistance(1, 2) // 2 রিটার্ন করে\n */\nfunction hammingDistance(x, y)",
      "bg": "/**\n * Изчислява разстоянието на Хаминг между две цели числа в тяхното двоично представяне.\n *\n * Параметри:\n * - x: Първото положително цяло число (x <= 1,000,000,000).\n * - y: Второто положително цяло число (y <= 1,000,000,000).\n *\n * Връща:\n * Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат\n * обърнати, за да се трансформира x в y.\n * \n * Примери:\n * hammingDistance(1, 2) // връща 2\n */\nfunction hammingDistance(x, y)",
      "zh": "/**\n * 计算两个整数在其二进制表示中的汉明距离。\n *\n * 参数:\n * - x: 第一个正整数 (x <= 1,000,000,000)。\n * - y: 第二个正整数 (y <= 1,000,000,000)。\n *\n * 返回:\n * x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为 y。\n * \n * 示例:\n * hammingDistance(1, 2) // 返回 2\n */\nfunction hammingDistance(x, y)",
      "fr": "/**\n * Calculer la distance de Hamming entre deux entiers dans leur représentation binaire.\n *\n * Paramètres :\n * - x : Le premier entier positif (x <= 1,000,000,000).\n * - y : Le deuxième entier positif (y <= 1,000,000,000).\n *\n * Renvoie :\n * La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être\n * inversés pour transformer x en y.\n * \n * Exemples :\n * hammingDistance(1, 2) // returns 2\n */\nfunction hammingDistance(x, y)",
      "de": "/**\n * Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in ihrer Binärdarstellung.\n *\n * Parameter:\n * - x: Die erste positive ganze Zahl (x <= 1,000,000,000).\n * - y: Die zweite positive ganze Zahl (y <= 1,000,000,000).\n *\n * Rückgabewert:\n * Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekippt werden müssen,\n * um x in y zu transformieren.\n * \n * Beispiele:\n * hammingDistance(1, 2) // gibt 2 zurück\n */\nfunction hammingDistance(x, y)",
      "ha": "/**\n * Lissafa tazara ta Hamming tsakanin lambobi biyu a cikin wakilarsu ta binary.\n *\n * Sigogi:\n * - x: Lamba ta farko mai kyau (x <= 1,000,000,000).\n * - y: Lamba ta biyu mai kyau (y <= 1,000,000,000).\n *\n * Komawa:\n * Tazara ta Hamming tsakanin x da y, wato, adadin bits da ake bukata\n * a juya don canza x zuwa y.\n * \n * Misalai:\n * hammingDistance(1, 2) // yana dawowa 2\n */\nfunction hammingDistance(x, y)",
      "hi": "/**\n * दो पूर्णांकों के द्विआधारी रूप में हैमिंग दूरी की गणना करें।\n *\n * पैरामीटर:\n * - x: पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n * - y: दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n *\n * रिटर्न करता है:\n * x और y के बीच की हैमिंग दूरी, अर्थात्, x को y में बदलने के लिए जिन बिट्स को पलटना आवश्यक है उनकी संख्या।\n * \n * उदाहरण:\n * hammingDistance(1, 2) // 2 लौटाता है\n */\nfunction hammingDistance(x, y)",
      "hu": "/**\n * Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n *\n * Paraméterek:\n * - x: Az első pozitív egész szám (x <= 1,000,000,000).\n * - y: A második pozitív egész szám (y <= 1,000,000,000).\n *\n * Visszatér:\n * A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell\n * fordítani ahhoz, hogy x-ből y-t kapjunk.\n * \n * Példák:\n * hammingDistance(1, 2) // visszaadja 2\n */\nfunction hammingDistance(x, y)"
    },
    "prompt_bertscore": {
      "sq": "0.984121487340071",
      "hy": "0.9908925983991693",
      "bn": "0.9743192766663803",
      "bg": "0.9985889297731282",
      "zh": "0.9901374056904747",
      "fr": "0.9909412628425229",
      "de": "0.992450655108007",
      "ha": "0.9716312117198352",
      "hi": "0.9685635641151323",
      "hu": "0.9879367796989892"
    },
    "canonical_solution": "{\n    let distance = 0;\n    let xorResult = x ^ y; // XOR x and y to get a number where set bits are the differences\n\n    // Count the number of bits set in xorResult\n    while (xorResult) {\n        distance += xorResult & 1; // Increment distance if the last bit is set\n        xorResult >>= 1; // Shift right by one bit to check the next bit\n    }\n\n    return distance;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function hammingDistance(x, y)` to solve the following problem:\nCalculate the Hamming distance between two integers in their binary representation.\n\nParameters:\n- x: The first positive integer (x <= 1,000,000,000).\n- y: The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- The Hamming distance between x and y, i.e., the number of bits that need to be\nflipped to transform x into y.\n\nExamples:\n- hammingDistance(1, 2) // returns 2\n",
      "sq": "Shkruani një funksion JavaScript `function hammingDistance(x, y)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin e tyre binar.\n\nParametrat:\n- x: Numri i parë pozitiv (x <= 1,000,000,000).\n- y: Numri i dytë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të\nndryshohen për të transformuar x në y.\n\nShembuj:\n- hammingDistance(1, 2) // kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `function hammingDistance(x, y)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև նրանց բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- x: Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n- y: Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\n\nՎերադարձնում է:\n- Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ այն բիթերի քանակը, որոնք պետք է\nփոխվեն x-ը y դարձնելու համար:\n\nՕրինակներ:\n- hammingDistance(1, 2) // վերադարձնում է 2",
      "bn": "একটি JavaScript ফাংশন `function hammingDistance(x, y)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনায় হ্যামিং দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x: প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nরিটার্নস:\n- x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nউদাহরণসমূহ:\n- hammingDistance(1, 2) // 2 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function hammingDistance(x, y)`, за да решите следния проблем:  \nИзчислете разстоянието на Хаминг между две цели числа в тяхното двоично представяне.\n\nПараметри:\n- x: Първото положително цяло число (x <= 1,000,000,000).\n- y: Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат променени, за да се трансформира x в y.\n\nПримери:\n- hammingDistance(1, 2) // връща 2",
      "zh": "编写一个 JavaScript 函数 `function hammingDistance(x, y)` 来解决以下问题：  \n计算两个整数在其二进制表示中的汉明距离。\n\n参数：\n- x: 第一个正整数 (x <= 1,000,000,000)。\n- y: 第二个正整数 (y <= 1,000,000,000)。\n\n返回：\n- x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为 y。\n\n示例：\n- hammingDistance(1, 2) // returns 2",
      "fr": "Écrire une fonction JavaScript `function hammingDistance(x, y)` pour résoudre le problème suivant :  \nCalculer la distance de Hamming entre deux entiers dans leur représentation binaire.\n\nParamètres :\n- x : Le premier entier positif (x <= 1,000,000,000).\n- y : Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie :\n- La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être\ninversés pour transformer x en y.\n\nExemples :\n- hammingDistance(1, 2) // renvoie 2",
      "de": "Schreiben Sie eine JavaScript-Funktion `function hammingDistance(x, y)`, um das folgende Problem zu lösen:\nBerechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen in ihrer Binärdarstellung.\n\nParameter:\n- x: Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y: Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nRückgabewert:\n- Der Hamming-Abstand zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen, um x in y zu transformieren.\n\nBeispiele:\n- hammingDistance(1, 2) // gibt 2 zurück",
      "ha": "Rubuta aikin JavaScript `function hammingDistance(x, y)` don warware matsalar mai zuwa:  \nLissafa nisan Hamming tsakanin lambobi biyu a cikin wakilarsu ta binary.\n\nSigogi:\n- x: Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y: Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nDawowa:\n- Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar\na jujjuya don canza x zuwa y.\n\nMisalai:\n- hammingDistance(1, 2) // returns 2",
      "hi": "एक JavaScript फ़ंक्शन `function hammingDistance(x, y)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के बीच उनके बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n\nपैरामीटर्स:\n- x: पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y: दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी:\n- x और y के बीच की हैमिंग दूरी, अर्थात्, x को y में बदलने के लिए जितने बिट्स को फ्लिप करने की आवश्यकता है।\n\nउदाहरण:\n- hammingDistance(1, 2) // 2 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function hammingDistance(x, y)` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n\nParaméterek:\n- x: Az első pozitív egész szám (x <= 1,000,000,000).\n- y: A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell\nváltoztatni ahhoz, hogy x-ből y-t kapjunk.\n\nPéldák:\n- hammingDistance(1, 2) // returns 2"
    },
    "instruction_bertscore": {
      "sq": "0.9857955441914331",
      "hy": "0.9854050368623185",
      "bn": "0.9780511442652638",
      "bg": "0.9928939981184769",
      "zh": "0.9951468639001746",
      "fr": "0.9958992757835348",
      "de": "0.9955133369531839",
      "ha": "0.9670303362039241",
      "hi": "0.9875764641877919",
      "hu": "0.9753785724884394"
    },
    "level": "middle",
    "test": "const testHammingDistance = () => {\n    console.assert(hammingDistance(1, 2) === 2, \"01 and 10 have 2 different bits\");\n    console.assert(hammingDistance(4, 7) === 2, \"100 and 111 have 2 different bits\");\n    console.assert(hammingDistance(25, 30) === 3, \"11001 and 11110 have 3 different bits\");\n    console.assert(hammingDistance(0, 0) === 0, \"Same numbers have 0 different bits\");\n    console.assert(hammingDistance(0xFFFFFFF, 0x0000000) === 28,\n                   \"Max unsigned int and 0 have 28 different bits\");\n}\n\n// Run the test function\ntestHammingDistance();",
    "entry_point": "hammingDistance",
    "signature": "function hammingDistance(x, y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in their binary representation.\n\nParameters:\n- x: The first positive integer (x <= 1,000,000,000).\n- y: The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- The Hamming distance between x and y, i.e., the number of bits that need to be\nflipped to transform x into y.\n\nExamples:\n- hammingDistance(1, 2) // returns 2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin e tyre binar.\n\nParametrat:\n- x: Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y: Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen për të transformuar x në y.\n\nShembuj:\n- hammingDistance(1, 2) // kthen 2",
      "hy": "Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև իրենց երկբայնային ներկայացման մեջ։\n\nՊարամետրեր՝\n- x: Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y: Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n\nՎերադարձնում է՝\n- Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է\nփոխվեն x-ը y-ի վերածելու համար։\n\nՕրինակներ՝\n- hammingDistance(1, 2) // վերադարձնում է 2",
      "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x: প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nরিটার্নস:\n- x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nউদাহরণসমূহ:\n- hammingDistance(1, 2) // 2 রিটার্ন করে",
      "bg": "Изчислете разстоянието на Хаминг между две цели числа в тяхното двоично представяне.\n\nПараметри:\n- x: Първото положително цяло число (x <= 1,000,000,000).\n- y: Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат\nпроменени, за да се трансформира x в y.\n\nПримери:\n- hammingDistance(1, 2) // връща 2",
      "zh": "计算两个整数在其二进制表示中的汉明距离。\n\n参数:\n- x: 第一个正整数 (x <= 1,000,000,000)。\n- y: 第二个正整数 (y <= 1,000,000,000)。\n\n返回:\n- x 和 y 之间的汉明距离，即将 x 转换为 y 所需翻转的位数。\n\n示例:\n- hammingDistance(1, 2) // 返回 2",
      "fr": "Calculer la distance de Hamming entre deux entiers dans leur représentation binaire.\n\nParamètres:\n- x: Le premier entier positif (x <= 1,000,000,000).\n- y: Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie:\n- La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être\n  inversés pour transformer x en y.\n\nExemples:\n- hammingDistance(1, 2) // renvoie 2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in ihrer Binärdarstellung.\n\nParameter:\n- x: Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y: Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nRückgabewert:\n- Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y zu transformieren.\n\nBeispiele:\n- hammingDistance(1, 2) // gibt 2 zurück",
      "ha": "Lissafa tazara ta Hamming tsakanin lambobi biyu a cikin wakilarsu ta binary.\n\nParameters:\n- x: Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y: Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nReturns:\n- Hamming distance tsakanin x da y, wato, adadin bits da ake bukata a\njuya don canza x zuwa y.\n\nExamples:\n- hammingDistance(1, 2) // returns 2",
      "hi": "दो पूर्णांकों के द्विआधारी रूपांतरण में हैमिंग दूरी की गणना करें।\n\nपैरामीटर्स:\n- x: पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y: दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी:\n- x और y के बीच हैमिंग दूरी, अर्थात् x को y में बदलने के लिए जितने बिट्स को पलटना आवश्यक है।\n\nउदाहरण:\n- hammingDistance(1, 2) // 2 लौटाता है",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n\nParaméterek:\n- x: Az első pozitív egész szám (x <= 1,000,000,000).\n- y: A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- A Hamming-távolság x és y között, azaz hány bitet kell megváltoztatni ahhoz, hogy x-ből y-t kapjunk.\n\nPéldák:\n- hammingDistance(1, 2) // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9913057495917219",
      "hy": "0.9873827995662828",
      "bn": "0.9787566793786997",
      "bg": "0.9913057495917219",
      "zh": "0.9828043692834287",
      "fr": "0.9943513492241298",
      "de": "0.994409349295392",
      "ha": "0.9625430772659649",
      "hi": "0.9615197335428732",
      "hu": "0.9574907148939615"
    }
  },
  {
    "task_id": "JavaScript/9",
    "prompt": {
      "en": "/**\n * Count the number of odd integers in a given list of numbers.\n *\n * @param {number} count - The count of numbers to evaluate.\n * @param {...number} nums - A sequence of integers.\n * @returns {number} The count of odd numbers in the input list.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "sq": "/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n *\n * @param {number} count - Numri i numrave për t'u vlerësuar.\n * @param {...number} nums - Një sekuencë e numrave të plotë.\n * @returns {number} Numri i numrave tek në listën e dhënë.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "hy": "/**\n * Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը:\n *\n * @param {number} count - Գնահատման ենթակա թվերի քանակը:\n * @param {...number} nums - Ամբողջ թվերի հաջորդականություն:\n * @returns {number} Մուտքային ցուցակում գտնվող կենտ թվերի քանակը:\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "bn": "/**\n * প্রদত্ত সংখ্যার তালিকায় কতগুলি বিজোড় পূর্ণসংখ্যা আছে তা গণনা করুন।\n *\n * @param {number} count - মূল্যায়নের জন্য সংখ্যার সংখ্যা।\n * @param {...number} nums - পূর্ণসংখ্যার একটি ক্রম।\n * @returns {number} ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // 3 প্রদান করে\n */\nfunction countOddNumbers(count, ...nums)",
      "bg": "/**\n * Пребройте броя на нечетните цели числа в даден списък от числа.\n *\n * @param {number} count - Броят на числата за оценка.\n * @param {...number} nums - Последователност от цели числа.\n * @returns {number} Броят на нечетните числа в входния списък.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "zh": "/**\n * 计算给定数字列表中奇数的数量。\n *\n * @param {number} count - 要评估的数字数量。\n * @param {...number} nums - 一系列整数。\n * @returns {number} 输入列表中奇数的数量。\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "fr": "/**\n * Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n *\n * @param {number} count - Le nombre de nombres à évaluer.\n * @param {...number} nums - Une séquence d'entiers.\n * @returns {number} Le nombre de nombres impairs dans la liste d'entrée.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "de": "/**\n * Zählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n *\n * @param {number} count - Die Anzahl der zu bewertenden Zahlen.\n * @param {...number} nums - Eine Sequenz von Ganzzahlen.\n * @returns {number} Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "ha": "/**\n * Ƙirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n *\n * @param {number} count - Adadin lambobin da za a tantance.\n * @param {...number} nums - Jeri na lambobi.\n * @returns {number} Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "hi": "/**\n * दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n *\n * @param {number} count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n * @param {...number} nums - पूर्णांकों का अनुक्रम।\n * @returns {number} इनपुट सूची में विषम संख्याओं की गिनती।\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)",
      "hu": "/**\n * Számolja meg a páratlan egész számok számát egy adott számok listájában.\n *\n * @param {number} count - Az értékelendő számok száma.\n * @param {...number} nums - Egész számok sorozata.\n * @returns {number} A bemeneti listában található páratlan számok száma.\n * @example\n * countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3\n */\nfunction countOddNumbers(count, ...nums)"
    },
    "prompt_bertscore": {
      "sq": "0.9712037591398481",
      "hy": "0.97569538794619",
      "bn": "0.9836135894557648",
      "bg": "0.9922496411623997",
      "zh": "0.9772192802294897",
      "fr": "0.9922496411623997",
      "de": "0.9819852175920408",
      "ha": "0.9770377320612238",
      "hi": "0.9740394064595022",
      "hu": "0.9828619720939288"
    },
    "canonical_solution": "{\n    let ans = 0;\n    for (let i = 0; i < count; i++) {\n        if (nums[i] % 2 !== 0) {\n            ans++;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countOddNumbers(count, ...nums)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n@param {number} count - The count of numbers to evaluate.\n@param {...number} nums - A sequence of integers.\n\nReturns:\n@returns {number} The count of odd numbers in the input list.\n\nExample:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "sq": "Shkruani një funksion JavaScript `function countOddNumbers(count, ...nums)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n@param {number} count - Numri i numrave për t'u vlerësuar.\n@param {...number} nums - Një sekuencë e numrave të plotë.\n\nKthen:\n@returns {number} Numri i numrave tek në listën e hyrjes.\n\nShembull:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // kthen 3",
      "hy": "Գրեք JavaScript ֆունկցիա `function countOddNumbers(count, ...nums)` հետևյալ խնդիրը լուծելու համար:\nՀաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր:\n@param {number} count - Գնահատվող թվերի քանակը։\n@param {...number} nums - Ամբողջ թվերի հաջորդականություն։\n\nՎերադարձնում է:\n@returns {number} Մուտքային ցանկում կենտ թվերի քանակը։\n\nՕրինակ:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // վերադարձնում է 3",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function countOddNumbers(count, ...nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n@param {number} count - মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n@param {...number} nums - পূর্ণসংখ্যার একটি ক্রম।\n\nফেরত দেয়:\n@returns {number} ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণ:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // 3 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function countOddNumbers(count, ...nums)` за решаване на следния проблем:\nПребройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n@param {number} count - Броят на числата за оценка.\n@param {...number} nums - Последователност от цели числа.\n\nВръща:\n@returns {number} Броят на нечетните числа в списъка с входни данни.\n\nПример:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // връща 3",
      "zh": "编写一个 JavaScript 函数 `function countOddNumbers(count, ...nums)` 来解决以下问题：\n统计给定数字列表中奇数的数量。\n\n参数：\n@param {number} count - 要评估的数字数量。\n@param {...number} nums - 一系列整数。\n\n返回：\n@returns {number} 输入列表中奇数的数量。\n\n示例：\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "fr": "Écrire une fonction JavaScript `function countOddNumbers(count, ...nums)` pour résoudre le problème suivant :  \nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres :  \n@param {number} count - Le nombre de nombres à évaluer.  \n@param {...number} nums - Une séquence d'entiers.\n\nRenvoie :  \n@returns {number} Le nombre de nombres impairs dans la liste d'entrée.\n\nExemple :  \n@example  \n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "de": "Schreiben Sie eine JavaScript-Funktion `function countOddNumbers(count, ...nums)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n@param {number} count - Die Anzahl der zu bewertenden Zahlen.\n@param {...number} nums - Eine Sequenz von ganzen Zahlen.\n\nRückgabe:\n@returns {number} Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiel:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // gibt 3 zurück",
      "ha": "Rubuta aikin JavaScript `function countOddNumbers(count, ...nums)` don magance matsalar mai zuwa:\nƘididdige yawan lambobin tsaka-tsaki a cikin jerin lambobi da aka bayar.\n\nSigogi:\n@param {number} count - Yawan lambobin da za a tantance.\n@param {...number} nums - Jeri na lambobi tsaka-tsaki.\n\nDawowa:\n@returns {number} Yawan lambobin tsaka-tsaki a cikin jerin shigarwa.\n\nMisali:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "hi": "`function countOddNumbers(count, ...nums)` निम्नलिखित समस्या को हल करने के लिए:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n@param {number} count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n@param {...number} nums - पूर्णांकों का अनुक्रम।\n\nवापसी:\n@returns {number} इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "hu": "Írj egy JavaScript függvényt `function countOddNumbers(count, ...nums)` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n@param {number} count - Az értékelendő számok száma.\n@param {...number} nums - Egész számok sorozata.\n\nVisszatér:\n@returns {number} A páratlan számok száma a bemeneti listában.\n\nPélda:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3"
    },
    "instruction_bertscore": {
      "sq": "0.9905416185158807",
      "hy": "0.9909470231235729",
      "bn": "0.9909470231235729",
      "bg": "0.9931704916088775",
      "zh": "0.9877522520750077",
      "fr": "0.9931704916088775",
      "de": "0.9880909168746722",
      "ha": "0.972945548951143",
      "hi": "0.9651792996830599",
      "hu": "0.9890505002454518"
    },
    "level": "easy",
    "test": "const testCountOddNumbers = () => {\n    console.assert(countOddNumbers(5, 1, 4, 3, 2, 5) === 3, \"Test 1 failed\");\n    console.assert(countOddNumbers(4, 2, 2, 0, 0) === 0, \"Test 2 failed\");\n    console.assert(countOddNumbers(6, 7, 7, 8, 1, 9, 10) === 4, \"Test 3 failed\"); // Additional Test Sample\n    // console.log(\"All tests passed!\");\n}\n\ntestCountOddNumbers();",
    "entry_point": "countOddNumbers",
    "signature": "function countOddNumbers(count, ...nums)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n@param {number} count - The count of numbers to evaluate.\n@param {...number} nums - A sequence of integers.\n\nReturns:\n@returns {number} The count of odd numbers in the input list.\n\nExample:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n@param {number} count - Numri i numrave për të vlerësuar.\n@param {...number} nums - Një sekuencë e numrave të plotë.\n\nKthen:\n@returns {number} Numri i numrave tek në listën e dhënë si hyrje.\n\nShembull:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // kthen 3",
      "hy": "Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր՝\n@param {number} count - Թվերի քանակը, որոնք պետք է գնահատել։\n@param {...number} nums - Ամբողջ թվերի հաջորդականություն։\n\nՎերադարձնում է՝\n@returns {number} Կենտ թվերի քանակը մուտքագրված ցանկում։\n\nՕրինակ՝\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // վերադարձնում է 3",
      "bn": "অদ্ভুত পূর্ণসংখ্যার সংখ্যা নির্ণয় করুন একটি প্রদত্ত সংখ্যার তালিকায়।\n\nপ্যারামিটারসমূহ:\n@param {number} count - মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n@param {...number} nums - পূর্ণসংখ্যার একটি ক্রম।\n\nফেরত দেয়:\n@returns {number} ইনপুট তালিকায় অদ্ভুত সংখ্যার সংখ্যা।\n\nউদাহরণ:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // 3 ফেরত দেয়",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n@param {number} count - Броят на числата за оценка.\n@param {...number} nums - Последователност от цели числа.\n\nВръща:\n@returns {number} Броят на нечетните числа в входния списък.\n\nПример:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // връща 3",
      "zh": "计算给定数字列表中奇数的数量。\n\n参数：\n@param {number} count - 要评估的数字数量。\n@param {...number} nums - 整数序列。\n\n返回：\n@returns {number} 输入列表中奇数的数量。\n\n示例：\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres:\n@param {number} count - Le nombre de nombres à évaluer.\n@param {...number} nums - Une séquence d'entiers.\n\nRenvoie:\n@returns {number} Le nombre de nombres impairs dans la liste d'entrée.\n\nExemple:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // renvoie 3",
      "de": "Zähle die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n@param {number} count - Die Anzahl der zu bewertenden Zahlen.\n@param {...number} nums - Eine Folge von ganzen Zahlen.\n\nRückgabewerte:\n@returns {number} Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiel:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // gibt 3 zurück",
      "ha": "Ƙirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n\nParameters:\n@param {number} count - Adadin lambobin da za a tantance.\n@param {...number} nums - Jeri na lambobi masu cikakken lamba.\n\nReturns:\n@returns {number} Yawan lambobin da ba su daidai ba a cikin jerin shigarwa.\n\nExample:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // returns 3",
      "hi": "दी गई संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n@param {number} count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n@param {...number} nums - पूर्णांकों का अनुक्रम।\n\nवापसी:\n@returns {number} इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // 3 लौटाता है",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n@param {number} count - Az értékelendő számok száma.\n@param {...number} nums - Egész számok sorozata.\n\nVisszatérési érték:\n@returns {number} A bemeneti listában található páratlan számok száma.\n\nPélda:\n@example\n countOddNumbers(5, 1, 4, 3, 2, 5) // visszaadja a 3-at"
    },
    "docstring_bertscore": {
      "sq": "0.9822058959453706",
      "hy": "0.976765608439206",
      "bn": "0.9774520750360626",
      "bg": "0.991141085005844",
      "zh": "0.9760388198749994",
      "fr": "0.991141085005844",
      "de": "0.9781965417041814",
      "ha": "0.9748226060519227",
      "hi": "0.9760815254069218",
      "hu": "0.9683267967009388"
    }
  },
  {
    "task_id": "JavaScript/10",
    "prompt": {
      "en": "/**\n * Calculate the sum of even numbers in a given list.\n * Parameters:\n * - numbers (Array): An array of integers.\n * - size (Number): The size of the array.\n * Returns:\n *   Number: The sum of even numbers in the input array.\n * Example usage:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n */\nfunction calculateEvenSum(numbers, size)",
      "sq": "/**\n * Llogarit shumën e numrave çift në një listë të dhënë.\n * Parametrat:\n * - numbers (Array): Një varg me numra të plotë.\n * - size (Number): Madhësia e vargut.\n * Kthen:\n *   Number: Shuma e numrave çift në vargun e dhënë.\n * Shembull përdorimi:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // kthen 6\n */\nfunction calculateEvenSum(numbers, size)",
      "hy": "/**\n * Հաշվել տրված ցուցակի զույգ թվերի գումարը:\n * Պարամետրեր:\n * - numbers (Array): Ամբողջ թվերի զանգված:\n * - size (Number): Զանգվածի չափը:\n * Վերադարձնում է:\n *   Number: Մուտքային զանգվածի զույգ թվերի գումարը:\n * Օրինակ օգտագործում:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // վերադարձնում է 6\n */\nfunction calculateEvenSum(numbers, size)",
      "bn": "/**\n * প্রদত্ত তালিকায় জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n * প্যারামিটারসমূহ:\n * - numbers (Array): পূর্ণসংখ্যার একটি অ্যারে।\n * - size (Number): অ্যারের আকার।\n * রিটার্নস:\n *   Number: ইনপুট অ্যারেতে জোড় সংখ্যাগুলির যোগফল।\n * উদাহরণ ব্যবহার:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 রিটার্ন করে\n */\nfunction calculateEvenSum(numbers, size)",
      "bg": "/**\n * Изчислява сумата на четните числа в даден списък.\n * Параметри:\n * - numbers (Array): Масив от цели числа.\n * - size (Number): Размерът на масива.\n * Връща:\n *   Number: Сумата на четните числа в входния масив.\n * Пример за използване:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // връща 6\n */\nfunction calculateEvenSum(numbers, size)",
      "zh": "/**\n * 计算给定列表中偶数的和。\n * 参数:\n * - numbers (Array): 整数数组。\n * - size (Number): 数组的大小。\n * 返回:\n *   Number: 输入数组中偶数的和。\n * 示例用法:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // 返回 6\n */\nfunction calculateEvenSum(numbers, size)",
      "fr": "/**\n * Calculer la somme des nombres pairs dans une liste donnée.\n * Paramètres :\n * - numbers (Array) : Un tableau d'entiers.\n * - size (Number) : La taille du tableau.\n * Renvoie :\n *   Number : La somme des nombres pairs dans le tableau d'entrée.\n * Exemple d'utilisation :\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // renvoie 6\n */\nfunction calculateEvenSum(numbers, size)",
      "de": "/**\n * Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n * Parameter:\n * - numbers (Array): Ein Array von ganzen Zahlen.\n * - size (Number): Die Größe des Arrays.\n * Rückgabe:\n *   Number: Die Summe der geraden Zahlen im Eingabearray.\n * Beispielverwendung:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // gibt 6 zurück\n */\nfunction calculateEvenSum(numbers, size)",
      "ha": "/**\n * Lissafa jimillar lambobin da ke daidai a cikin jerin da aka bayar.\n * Sigogi:\n * - numbers (Array): Wani jeri na lambobi.\n * - size (Number): Girman jerin.\n * Komawa:\n *   Number: Jimillar lambobin da ke daidai a cikin jerin shigarwa.\n * Misalin amfani:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // yana dawowa 6\n */\nfunction calculateEvenSum(numbers, size)",
      "hi": "/**\n * दिए गए सूची में सम संख्याओं का योग गणना करें।\n * पैरामीटर्स:\n * - numbers (Array): पूर्णांकों की एक array।\n * - size (Number): array का आकार।\n * रिटर्न करता है:\n *   Number: इनपुट array में सम संख्याओं का योग।\n * उदाहरण उपयोग:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 लौटाता है\n */\nfunction calculateEvenSum(numbers, size)",
      "hu": "/**\n * Számítsa ki a páros számok összegét egy adott listában.\n * Paraméterek:\n * - numbers (Array): Egész számokat tartalmazó tömb.\n * - size (Number): A tömb mérete.\n * Visszatér:\n *   Number: A bemeneti tömbben található páros számok összege.\n * Példa használat:\n *   calculateEvenSum([1, 4, 3, 2, 5], 5)  // visszaadja: 6\n */\nfunction calculateEvenSum(numbers, size)"
    },
    "prompt_bertscore": {
      "sq": "0.9924240386369483",
      "hy": "0.9796391941616378",
      "bn": "0.9953518504534026",
      "bg": "0.9858328867030677",
      "zh": "0.9774477051676799",
      "fr": "0.9942776573527659",
      "de": "0.9904935499636702",
      "ha": "0.9780817333439432",
      "hi": "0.9953518504534026",
      "hu": "0.9857564140063692"
    },
    "canonical_solution": "{\n    let ans = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculateEvenSum(numbers, size)` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n",
      "sq": "Shkruani një funksion JavaScript `function calculateEvenSum(numbers, size)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers (Array): Një varg me numra të plotë.\n- size (Number): Madhësia e vargut.\nKthen:\n  Number: Shuma e numrave çift në vargun hyrës.\nShembull përdorimi:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // kthen 6",
      "hy": "Գրեք JavaScript ֆունկցիա `function calculateEvenSum(numbers, size)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված ցուցակի զույգ թվերի գումարը։\nՊարամետրեր:\n- numbers (Array): Թվերի զանգված։\n- size (Number): Զանգվածի չափը։\nՎերադարձնում է:\n  Number: Մուտքային զանգվածի զույգ թվերի գումարը։\nՕրինակ օգտագործում:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // վերադարձնում է 6",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function calculateEvenSum(numbers, size)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত তালিকায় জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- numbers (Array): পূর্ণসংখ্যার একটি অ্যারে।\n- size (Number): অ্যারের আকার।\nফেরত দেয়:\n  Number: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\nউদাহরণ ব্যবহার:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function calculateEvenSum(numbers, size)` за решаване на следния проблем:  \nИзчислете сумата на четните числа в даден списък.  \nПараметри:  \n- numbers (Array): Масив от цели числа.  \n- size (Number): Размерът на масива.  \nВръща:  \n  Number: Сумата на четните числа в входния масив.  \nПример за използване:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // връща 6  ",
      "zh": "编写一个 JavaScript 函数 `function calculateEvenSum(numbers, size)` 来解决以下问题：\n计算给定列表中偶数的和。\n参数：\n- numbers (Array): 一个整数数组。\n- size (Number): 数组的大小。\n返回：\n  Number: 输入数组中偶数的和。\n示例用法：\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 返回 6",
      "fr": "Écrire une fonction JavaScript `function calculateEvenSum(numbers, size)` pour résoudre le problème suivant :  \nCalculer la somme des nombres pairs dans une liste donnée.  \nParamètres :  \n- numbers (Array) : Un tableau d'entiers.  \n- size (Number) : La taille du tableau.  \nRenvoie :  \n  Number : La somme des nombres pairs dans le tableau d'entrée.  \nExemple d'utilisation :  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // renvoie 6  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function calculateEvenSum(numbers, size)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers (Array): Ein Array von ganzen Zahlen.\n- size (Number): Die Größe des Arrays.\nRückgabe:\n  Number: Die Summe der geraden Zahlen im Eingabearray.\nBeispielverwendung:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // gibt 6 zurück",
      "ha": "Rubuta aikin JavaScript `function calculateEvenSum(numbers, size)` don warware matsalar mai zuwa:\nLissafa jimillar lambobin da suke lamba biyu-biyu a cikin jerin da aka bayar.\nSigogi:\n- numbers (Array): Jeri na lambobi masu cikakken lamba.\n- size (Number): Girman jerin.\nYa dawo:\n  Number: Jimillar lambobin da suke lamba biyu-biyu a cikin jerin shigarwa.\nMisalin amfani:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // ya dawo 6",
      "hi": "`function calculateEvenSum(numbers, size)` को हल करने के लिए एक जावास्क्रिप्ट फ़ंक्शन लिखें:\nदिए गए सूची में सम संख्याओं का योग गणना करें।\nपैरामीटर्स:\n- numbers (Array): पूर्णांकों की एक सरणी।\n- size (Number): सरणी का आकार।\nरिटर्न करता है:\n  Number: इनपुट सरणी में सम संख्याओं का योग।\nउदाहरण उपयोग:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6",
      "hu": "Írj egy JavaScript függvényt `function calculateEvenSum(numbers, size)` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott listában.\nParaméterek:\n- numbers (Array): Egész számok tömbje.\n- size (Number): A tömb mérete.\nVisszatérési érték:\n  Number: A bemeneti tömbben lévő páros számok összege.\nPélda használat:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // visszaadja: 6"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9740773448622798",
      "bn": "0.9967235918648295",
      "bg": "0.9852465298182527",
      "zh": "0.9990898755940981",
      "fr": "0.9970533182973474",
      "de": "0.9877236493001388",
      "ha": "0.9655920536148505",
      "hi": "0.9742042696757611",
      "hu": "0.9915284142488621"
    },
    "level": "easy",
    "test": "const testCalculateEvenSum = () => {\n    console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6);\n    console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4);\n    console.assert(calculateEvenSum([7, 11, 19], 3) === 0); // Should return 0 because there are no even numbers\n    console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20));\n\n    // console.log(\"All tests passed successfully.\");\n}\n\ntestCalculateEvenSum();",
    "entry_point": "calculateEvenSum",
    "signature": "function calculateEvenSum(numbers, size)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers (Array): An array of integers.\n- size (Number): The size of the array.\nReturns:\n  Number: The sum of even numbers in the input array.\nExample usage:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // returns 6\n",
      "sq": "Llogarit shumën e numrave çift në një listë të dhënë.  \nParametrat:  \n- numbers (Array): Një varg me numra të plotë.  \n- size (Number): Madhësia e vargut.  \nKthen:  \n  Number: Shuma e numrave çift në vargun hyrës.  \nShembull përdorimi:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // kthen 6  ",
      "hy": "Հաշվարկել տրված ցուցակի զույգ թվերի գումարը։  \nՊարամետրեր:  \n- numbers (Array): Ամբողջ թվերի զանգված։  \n- size (Number): Զանգվածի չափը։  \nՎերադարձնում է:  \n  Number: Մուտքային զանգվածի զույգ թվերի գումարը։  \nՕրինակ օգտագործում:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // վերադարձնում է 6  ",
      "bn": "একটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- numbers (Array): পূর্ণসংখ্যার একটি অ্যারে।\n- size (Number): অ্যারের আকার।\nফেরত দেয়:\n  Number: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\nউদাহরণ ব্যবহার:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 ফেরত দেয়",
      "bg": "Изчислява сумата на четните числа в даден списък.\nПараметри:\n- numbers (Array): Масив от цели числа.\n- size (Number): Размерът на масива.\nВръща:\n  Number: Сумата на четните числа в входния масив.\nПример за използване:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // връща 6",
      "zh": "计算给定列表中偶数的和。\n参数：\n- numbers (Array): 整数数组。\n- size (Number): 数组的大小。\n返回：\n  Number: 输入数组中偶数的和。\n示例用法：\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 返回 6",
      "fr": "Calculer la somme des nombres pairs dans une liste donnée.\nParamètres :\n- numbers (Array) : Un tableau d'entiers.\n- size (Number) : La taille du tableau.\nRenvoie :\n  Number : La somme des nombres pairs dans le tableau d'entrée.\nExemple d'utilisation :\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // renvoie 6",
      "de": "Berechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers (Array): Ein Array von ganzen Zahlen.\n- size (Number): Die Größe des Arrays.\nRückgabewert:\n  Number: Die Summe der geraden Zahlen im Eingabearray.\nBeispielverwendung:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // gibt 6 zurück",
      "ha": "Ƙididdige jimillar lambobin da suka kasance ma'aurata a cikin jerin da aka bayar.\nSigogi:\n- numbers (Array): Jeri na lambobin tsintsiya.\n- size (Number): Girman jerin.\nDawowa:\n  Number: Jimillar lambobin ma'aurata a cikin jerin shigarwa.\nMisalin amfani:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // yana dawowa 6",
      "hi": "दिए गए सूची में सम संख्या का योग गणना करें।\nपैरामीटर्स:\n- numbers (Array): पूर्णांकों की एक श्रृंखला।\n- size (Number): श्रृंखला का आकार।\nरिटर्न:\n  Number: इनपुट श्रृंखला में सम संख्याओं का योग।\nउदाहरण उपयोग:\n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // 6 लौटाता है",
      "hu": "Számítsa ki a páros számok összegét egy adott listában.  \nParaméterek:  \n- numbers (Array): Egész számok tömbje.  \n- size (Number): A tömb mérete.  \nVisszatér:  \n  Number: A bemeneti tömbben található páros számok összege.  \nPélda használat:  \n  calculateEvenSum([1, 4, 3, 2, 5], 5)  // visszaadja: 6  "
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9746642976382379",
      "bn": "0.9987780258958734",
      "bg": "0.9825648210439006",
      "zh": "0.9733777686602749",
      "fr": "0.9890910208431829",
      "de": "0.9815571691209106",
      "ha": "0.9468101606753345",
      "hi": "0.9651876421590634",
      "hu": "0.9863519078887117"
    }
  },
  {
    "task_id": "JavaScript/11",
    "prompt": {
      "en": "// No import is necessary as we're not using any modules or libraries\n/**\n * Determine if two closed intervals intersect.\n * \n * @param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n * @param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n * @param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n * @param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n * @returns {number} 1 if the intervals intersect, 0 otherwise.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "sq": "// Nuk është e nevojshme të importoni pasi nuk po përdorim asnjë modul ose bibliotekë\n/**\n * Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n * \n * @param {number} a - Fillimi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n * @param {number} b - Fundi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n * @param {number} c - Fillimi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n * @param {number} d - Fundi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n * @returns {number} 1 nëse intervalet ndërpriten, 0 përndryshe.\n */",
      "hy": "// Ոչ մի ներմուծում անհրաժեշտ չէ, քանի որ մենք չենք օգտագործում որևէ մոդուլ կամ գրադարան\n/**\n * Որոշել՝ արդյոք երկու փակ միջակայքեր հատվում են։\n * \n * @param {number} a - Առաջին փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= a <= b <= 1000։\n * @param {number} b - Առաջին փակ միջակայքի վերջը, պետք է բավարարի 0 <= a <= b <= 1000։\n * @param {number} c - Երկրորդ փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= c <= d <= 1000։\n * @param {number} d - Երկրորդ փակ միջակայքի վերջը, պետք է բավարարի 0 <= c <= d <= 1000։\n * @returns {number} 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n */",
      "bn": "// কোনো ইম্পোর্ট প্রয়োজন নেই কারণ আমরা কোনো মডিউল বা লাইব্রেরি ব্যবহার করছি না\n/**\n * নির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\n * \n * @param {number} a - প্রথম বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n * @param {number} b - প্রথম বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n * @param {number} c - দ্বিতীয় বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n * @param {number} d - দ্বিতীয় বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n * @returns {number} ইন্টারভালগুলি ছেদ করলে 1, অন্যথায় 0।\n */",
      "bg": "// Няма нужда от импортиране, тъй като не използваме никакви модули или библиотеки\n/**\n * Определя дали два затворени интервала се пресичат.\n * \n * @param {number} a - Начало на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n * @param {number} b - Край на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n * @param {number} c - Начало на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n * @param {number} d - Край на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n * @returns {number} 1 ако интервалите се пресичат, 0 в противен случай.\n */",
      "zh": "// 不需要导入，因为我们不使用任何模块或库\n/**\n * 判断两个闭区间是否相交。\n * \n * @param {number} a - 第一个闭区间的起始，必须满足 0 <= a <= b <= 1000。\n * @param {number} b - 第一个闭区间的结束，必须满足 0 <= a <= b <= 1000。\n * @param {number} c - 第二个闭区间的起始，必须满足 0 <= c <= d <= 1000。\n * @param {number} d - 第二个闭区间的结束，必须满足 0 <= c <= d <= 1000。\n * @returns {number} 如果区间相交返回 1，否则返回 0。\n */",
      "fr": "// Aucun import n'est nécessaire car nous n'utilisons aucun module ou bibliothèque\n/**\n * Déterminer si deux intervalles fermés s'intersectent.\n * \n * @param {number} a - Début du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n * @param {number} b - Fin du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n * @param {number} c - Début du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n * @param {number} d - Fin du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n * @returns {number} 1 si les intervalles s'intersectent, 0 sinon.\n */",
      "de": "// Kein Import ist notwendig, da wir keine Module oder Bibliotheken verwenden\n/**\n * Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n * \n * @param {number} a - Anfang des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n * @param {number} b - Ende des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n * @param {number} c - Anfang des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n * @param {number} d - Ende des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n * @returns {number} 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n */\nfunction areIntervalsIntersecting(a, b, c, d)",
      "ha": "// Babu buƙatar shigo da wani abu domin ba ma amfani da kowanne modules ko libraries\n/**\n * Tantance idan tsaka-tsakin rufe guda biyu suna haɗuwa.\n * \n * @param {number} a - Farko na tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n * @param {number} b - Ƙarshe na tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n * @param {number} c - Farko na tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n * @param {number} d - Ƙarshe na tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n * @returns {number} 1 idan tsaka-tsakin suna haɗuwa, 0 in ba haka ba.\n */",
      "hi": "// किसी आयात की आवश्यकता नहीं है क्योंकि हम कोई मॉड्यूल या लाइब्रेरी उपयोग नहीं कर रहे हैं\n/**\n * निर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n * \n * @param {number} a - पहले बंद अंतराल की शुरुआत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n * @param {number} b - पहले बंद अंतराल का अंत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n * @param {number} c - दूसरे बंद अंतराल की शुरुआत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n * @param {number} d - दूसरे बंद अंतराल का अंत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n * @returns {number} 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n */",
      "hu": "// Nincs szükség importálásra, mivel nem használunk semmilyen modult vagy könyvtárat\n/**\n * Határozza meg, hogy két zárt intervallum metszi-e egymást.\n * \n * @param {number} a - Az első zárt intervallum kezdete, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n * @param {number} b - Az első zárt intervallum vége, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n * @param {number} c - A második zárt intervallum kezdete, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n * @param {number} d - A második zárt intervallum vége, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n * @returns {number} 1, ha az intervallumok metszik egymást, különben 0.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9555606234814455",
      "hy": "0.9642665930822046",
      "bn": "0.9362609011385716",
      "bg": "0.9522514413334042",
      "zh": "0.928081897938698",
      "fr": "0.9649766966944043",
      "de": "0.9605089035337866",
      "ha": "0.9560736857556587",
      "hi": "0.9508971793955084",
      "hu": "0.9196869835146395"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function areIntervalsIntersecting(a, b, c, d)` to solve the following problem:\nDetermine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Shkruani një funksion JavaScript `function areIntervalsIntersecting(a, b, c, d)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n\n@param {number} a - Fillimi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} b - Fundi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} c - Fillimi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@param {number} d - Fundi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@returns {number} 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Գրեք JavaScript ֆունկցիա `function areIntervalsIntersecting(a, b, c, d)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n\n@param {number} a - Առաջին փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= a <= b <= 1000.\n@param {number} b - Առաջին փակ միջակայքի վերջը, պետք է բավարարի 0 <= a <= b <= 1000.\n@param {number} c - Երկրորդ փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= c <= d <= 1000.\n@param {number} d - Երկրորդ փակ միջակայքի վերջը, պետք է բավարարի 0 <= c <= d <= 1000.\n@returns {number} 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում.",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function areIntervalsIntersecting(a, b, c, d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুইটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করুন।\n\n@param {number} a - প্রথম বন্ধ ইন্টারভালের শুরু, 0 <= a <= b <= 1000 শর্তটি পূরণ করতে হবে।\n@param {number} b - প্রথম বন্ধ ইন্টারভালের শেষ, 0 <= a <= b <= 1000 শর্তটি পূরণ করতে হবে।\n@param {number} c - দ্বিতীয় বন্ধ ইন্টারভালের শুরু, 0 <= c <= d <= 1000 শর্তটি পূরণ করতে হবে।\n@param {number} d - দ্বিতীয় বন্ধ ইন্টারভালের শেষ, 0 <= c <= d <= 1000 শর্তটি পূরণ করতে হবে।\n@returns {number} ইন্টারভালগুলি অতিক্রম করলে 1, অন্যথায় 0।",
      "bg": "Напишете JavaScript функция `function areIntervalsIntersecting(a, b, c, d)` за решаване на следния проблем:  \nОпределете дали два затворени интервала се пресичат.\n\n@param {number} a - Начало на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} b - Край на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} c - Начало на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@param {number} d - Край на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@returns {number} 1 ако интервалите се пресичат, 0 в противен случай.",
      "zh": "编写一个 JavaScript 函数 `function areIntervalsIntersecting(a, b, c, d)` 来解决以下问题：\n确定两个闭区间是否相交。\n\n@param {number} a - 第一个闭区间的起始，必须满足 0 <= a <= b <= 1000。\n@param {number} b - 第一个闭区间的结束，必须满足 0 <= a <= b <= 1000。\n@param {number} c - 第二个闭区间的起始，必须满足 0 <= c <= d <= 1000。\n@param {number} d - 第二个闭区间的结束，必须满足 0 <= c <= d <= 1000。\n@returns {number} 如果区间相交返回 1，否则返回 0。",
      "fr": "Écrire une fonction JavaScript `function areIntervalsIntersecting(a, b, c, d)` pour résoudre le problème suivant :\nDéterminer si deux intervalles fermés s'intersectent.\n\n@param {number} a - Début du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} b - Fin du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} c - Début du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@param {number} d - Fin du deuxième intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@returns {number} 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function areIntervalsIntersecting(a, b, c, d)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob zwei geschlossene Intervalle sich überschneiden.\n\n@param {number} a - Anfang des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} b - Ende des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} c - Anfang des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@param {number} d - Ende des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@returns {number} 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Rubuta wani aikin JavaScript `function areIntervalsIntersecting(a, b, c, d)` don warware matsalar mai zuwa:\nGano idan tsaka-tsakin rufe guda biyu suna haɗuwa.\n\n@param {number} a - Farkon tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} b - Ƙarshen tsaka-tsakin rufe na farko, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} c - Farkon tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n@param {number} d - Ƙarshen tsaka-tsakin rufe na biyu, dole ne ya cika 0 <= c <= d <= 1000.\n@returns {number} 1 idan tsaka-tsakin suna haɗuwa, 0 in ba haka ba.",
      "hi": "एक JavaScript फ़ंक्शन `function areIntervalsIntersecting(a, b, c, d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n\n@param {number} a - पहले बंद अंतराल की शुरुआत, इसे 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} b - पहले बंद अंतराल का अंत, इसे 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} c - दूसरे बंद अंतराल की शुरुआत, इसे 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@param {number} d - दूसरे बंद अंतराल का अंत, इसे 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@returns {number} 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।",
      "hu": "Írj egy JavaScript függvényt `function areIntervalsIntersecting(a, b, c, d)` a következő probléma megoldására:\nHatározd meg, hogy két zárt intervallum metszi-e egymást.\n\n@param {number} a - Az első zárt intervallum kezdete, meg kell felelnie a 0 <= a <= b <= 1000 feltételnek.\n@param {number} b - Az első zárt intervallum vége, meg kell felelnie a 0 <= a <= b <= 1000 feltételnek.\n@param {number} c - A második zárt intervallum kezdete, meg kell felelnie a 0 <= c <= d <= 1000 feltételnek.\n@param {number} d - A második zárt intervallum vége, meg kell felelnie a 0 <= c <= d <= 1000 feltételnek.\n@returns {number} 1, ha az intervallumok metszik egymást, 0 különben."
    },
    "instruction_bertscore": {
      "sq": "0.9785073982505009",
      "hy": "0.9777249931796045",
      "bn": "0.9664118011973815",
      "bg": "1",
      "zh": "0.9689574481607246",
      "fr": "1",
      "de": "1",
      "ha": "0.9944343767234024",
      "hi": "0.9693704007228962",
      "hu": "0.9537409705607849"
    },
    "level": "easy",
    "test": "const testAreIntervalsIntersecting = () => {\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === 1);\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === 1);\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === 1);\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === 0);\n    // Additional test cases\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === 1);\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === 1);\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === 0);\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === 1);\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === 0);\n\n    // console.log(\"All tests passed.\");\n}\n\ntestAreIntervalsIntersecting();",
    "entry_point": "areIntervalsIntersecting",
    "signature": "function areIntervalsIntersecting(a, b, c, d)",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\n\n@param {number} a - Start of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} b - End of the first closed interval, must satisfy 0 <= a <= b <= 1000.\n@param {number} c - Start of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@param {number} d - End of the second closed interval, must satisfy 0 <= c <= d <= 1000.\n@returns {number} 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n\n@param {number} a - Fillimi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} b - Fundi i intervalit të parë të mbyllur, duhet të plotësojë 0 <= a <= b <= 1000.\n@param {number} c - Fillimi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@param {number} d - Fundi i intervalit të dytë të mbyllur, duhet të plotësojë 0 <= c <= d <= 1000.\n@returns {number} 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Որոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n\n@param {number} a - Առաջին փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= a <= b <= 1000։\n@param {number} b - Առաջին փակ միջակայքի վերջը, պետք է բավարարի 0 <= a <= b <= 1000։\n@param {number} c - Երկրորդ փակ միջակայքի սկիզբը, պետք է բավարարի 0 <= c <= d <= 1000։\n@param {number} d - Երկրորդ փակ միջակայքի վերջը, պետք է բավարարի 0 <= c <= d <= 1000։\n@returns {number} 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։",
      "bn": "দুইটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করুন।\n\n@param {number} a - প্রথম বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n@param {number} b - প্রথম বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= a <= b <= 1000 শর্ত পূরণ করতে হবে।\n@param {number} c - দ্বিতীয় বন্ধ ইন্টারভালের শুরু, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n@param {number} d - দ্বিতীয় বন্ধ ইন্টারভালের শেষ, অবশ্যই 0 <= c <= d <= 1000 শর্ত পূরণ করতে হবে।\n@returns {number} 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।",
      "bg": "Определете дали два затворени интервала се пресичат.\n\n@param {number} a - Начало на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} b - Край на първия затворен интервал, трябва да удовлетворява 0 <= a <= b <= 1000.\n@param {number} c - Начало на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@param {number} d - Край на втория затворен интервал, трябва да удовлетворява 0 <= c <= d <= 1000.\n@returns {number} 1 ако интервалите се пресичат, 0 в противен случай.",
      "zh": "确定两个闭区间是否相交。\n\n@param {number} a - 第一个闭区间的起始，必须满足 0 <= a <= b <= 1000。\n@param {number} b - 第一个闭区间的结束，必须满足 0 <= a <= b <= 1000。\n@param {number} c - 第二个闭区间的起始，必须满足 0 <= c <= d <= 1000。\n@param {number} d - 第二个闭区间的结束，必须满足 0 <= c <= d <= 1000。\n@returns {number} 如果区间相交返回 1，否则返回 0。",
      "fr": "Déterminer si deux intervalles fermés s'intersectent.\n\n@param {number} a - Début du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} b - Fin du premier intervalle fermé, doit satisfaire 0 <= a <= b <= 1000.\n@param {number} c - Début du second intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@param {number} d - Fin du second intervalle fermé, doit satisfaire 0 <= c <= d <= 1000.\n@returns {number} 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n\n@param {number} a - Anfang des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} b - Ende des ersten geschlossenen Intervalls, muss 0 <= a <= b <= 1000 erfüllen.\n@param {number} c - Anfang des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@param {number} d - Ende des zweiten geschlossenen Intervalls, muss 0 <= c <= d <= 1000 erfüllen.\n@returns {number} 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Gano idan tsaka-tsakin rufe guda biyu suna haɗuwa.\n\n@param {number} a - Farko na farkon rufe tazara, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} b - Ƙarshe na farkon rufe tazara, dole ne ya cika 0 <= a <= b <= 1000.\n@param {number} c - Farko na na biyu rufe tazara, dole ne ya cika 0 <= c <= d <= 1000.\n@param {number} d - Ƙarshe na na biyu rufe tazara, dole ne ya cika 0 <= c <= d <= 1000.\n@returns {number} 1 idan tazarar suna haɗuwa, 0 in ba haka ba.",
      "hi": "निर्धारित करें कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n\n@param {number} a - पहले बंद अंतराल की शुरुआत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} b - पहले बंद अंतराल का अंत, 0 <= a <= b <= 1000 को संतुष्ट करना चाहिए।\n@param {number} c - दूसरे बंद अंतराल की शुरुआत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@param {number} d - दूसरे बंद अंतराल का अंत, 0 <= c <= d <= 1000 को संतुष्ट करना चाहिए।\n@returns {number} 1 अगर अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।",
      "hu": "Határozd meg, hogy két zárt intervallum metszi-e egymást.\n\n@param {number} a - Az első zárt intervallum kezdete, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n@param {number} b - Az első zárt intervallum vége, teljesítenie kell a 0 <= a <= b <= 1000 feltételt.\n@param {number} c - A második zárt intervallum kezdete, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n@param {number} d - A második zárt intervallum vége, teljesítenie kell a 0 <= c <= d <= 1000 feltételt.\n@returns {number} 1, ha az intervallumok metszik egymást, különben 0."
    },
    "docstring_bertscore": {
      "sq": "0.9740131872492056",
      "hy": "0.9740131872492056",
      "bn": "0.9651425530625685",
      "bg": "0.9989192520967892",
      "zh": "0.9605420748074195",
      "fr": "1",
      "de": "0.9958253852817898",
      "ha": "1",
      "hi": "0.9806756474898778",
      "hu": "0.9429746080175508"
    }
  },
  {
    "task_id": "JavaScript/12",
    "prompt": {
      "en": "/**\n * Given three digits a, b, and c, where two of them are equal and the third is different,\n * this function finds and returns the value that occurs exactly once.\n * Examples:\n * extraNumber(0, 0, 1) // returns 1\n * extraNumber(4, 3, 4) // returns 3\n */\nfunction extraNumber(a, b, c)",
      "sq": "/**\n * Duke pasur parasysh tre shifra a, b, dhe c, ku dy prej tyre janë të barabartë dhe i treti është i ndryshëm,\n * kjo funksion gjen dhe kthen vlerën që ndodh saktësisht një herë.\n * Shembuj:\n * extraNumber(0, 0, 1) // kthen 1\n * extraNumber(4, 3, 4) // kthen 3\n */\nfunction extraNumber(a, b, c)",
      "hy": "/**\n * Տրված են երեք թվանշան a, b և c, որտեղ երկուսը հավասար են, իսկ երրորդը՝ տարբեր,\n * այս ֆունկցիան գտնում և վերադարձնում է այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n * Օրինակներ:\n * extraNumber(0, 0, 1) // վերադարձնում է 1\n * extraNumber(4, 3, 4) // վերադարձնում է 3\n */\nfunction extraNumber(a, b, c)",
      "bn": "/**\n * প্রদত্ত তিনটি সংখ্যা a, b, এবং c, যেখানে দুটি সংখ্যা সমান এবং তৃতীয়টি ভিন্ন,\n * এই ফাংশনটি সেই মানটি খুঁজে বের করে এবং ফেরত দেয় যা ঠিক একবার ঘটে।\n * উদাহরণ:\n * extraNumber(0, 0, 1) // 1 ফেরত দেয়\n * extraNumber(4, 3, 4) // 3 ফেরত দেয়\n */\nfunction extraNumber(a, b, c)",
      "bg": "/**\n * Дадени са три цифри a, b и c, където две от тях са равни, а третата е различна,\n * тази функция намира и връща стойността, която се среща точно веднъж.\n * Примери:\n * extraNumber(0, 0, 1) // връща 1\n * extraNumber(4, 3, 4) // връща 3\n */\nfunction extraNumber(a, b, c)",
      "zh": "/**\n * 给定三个数字 a, b 和 c，其中两个相等，第三个不同，\n * 此函数查找并返回只出现一次的值。\n * 示例:\n * extraNumber(0, 0, 1) // 返回 1\n * extraNumber(4, 3, 4) // 返回 3\n */\nfunction extraNumber(a, b, c)",
      "fr": "/**\n * Étant donné trois chiffres a, b et c, où deux d'entre eux sont égaux et le troisième est différent,\n * cette fonction trouve et renvoie la valeur qui apparaît exactement une fois.\n * Exemples :\n * extraNumber(0, 0, 1) // renvoie 1\n * extraNumber(4, 3, 4) // renvoie 3\n */\nfunction extraNumber(a, b, c)",
      "de": "/**\n * Gegeben sind drei Ziffern a, b und c, wobei zwei von ihnen gleich sind und die dritte unterschiedlich ist,\n * diese Funktion findet und gibt den Wert zurück, der genau einmal vorkommt.\n * Beispiele:\n * extraNumber(0, 0, 1) // gibt 1 zurück\n * extraNumber(4, 3, 4) // gibt 3 zurück\n */\nfunction extraNumber(a, b, c)",
      "ha": "/**\n * An ba lambobi guda uku a, b, da c, inda biyu daga cikinsu suke daidai kuma na uku ya bambanta,\n * wannan aikin yana gano kuma ya dawo da ƙimar da ta faru sau ɗaya kawai.\n * Misalai:\n * extraNumber(0, 0, 1) // returns 1\n * extraNumber(4, 3, 4) // returns 3\n */\nfunction extraNumber(a, b, c)",
      "hi": "/**\n * दिए गए तीन अंक a, b, और c, जहाँ इनमें से दो समान हैं और तीसरा अलग है,\n * यह फ़ंक्शन उस मान को ढूंढता और लौटाता है जो केवल एक बार होता है।\n * उदाहरण:\n * extraNumber(0, 0, 1) // 1 लौटाता है\n * extraNumber(4, 3, 4) // 3 लौटाता है\n */\nfunction extraNumber(a, b, c)",
      "hu": "/**\n * Adott három számjegy: a, b és c, ahol kettő közülük egyenlő, és a harmadik eltérő,\n * ez a függvény megkeresi és visszaadja azt az értéket, amely pontosan egyszer fordul elő.\n * Példák:\n * extraNumber(0, 0, 1) // visszaadja 1\n * extraNumber(4, 3, 4) // visszaadja 3\n */\nfunction extraNumber(a, b, c)"
    },
    "prompt_bertscore": {
      "sq": "0.9923497508744413",
      "hy": "0.97901390572214",
      "bn": "0.9800098384526489",
      "bg": "0.9936527661740302",
      "zh": "0.9694871953869446",
      "fr": "0.9877242451912819",
      "de": "0.9894414048353285",
      "ha": "0.9680346114104365",
      "hi": "0.9723637605650919",
      "hu": "0.9882369102047329"
    },
    "canonical_solution": "{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function extraNumber(a, b, c)` to solve the following problem:\nGiven three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\nExamples:\nextraNumber(0, 0, 1) // returns 1\nextraNumber(4, 3, 4) // returns 3\n",
      "sq": "Shkruani një funksion JavaScript `function extraNumber(a, b, c)` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh tre shifra a, b, dhe c, ku dy prej tyre janë të barabarta dhe e treta është e ndryshme,  \nky funksion gjen dhe kthen vlerën që ndodh saktësisht një herë.  \nShembuj:  \nextraNumber(0, 0, 1) // kthen 1  \nextraNumber(4, 3, 4) // kthen 3  ",
      "hy": "Գրեք JavaScript ֆունկցիա `function extraNumber(a, b, c)`՝ լուծելու հետևյալ խնդիրը: \nԵրեք թվանշանների `a`, `b` և `c` տրված են, որտեղ երկուսը հավասար են, իսկ երրորդը՝ տարբեր, \nայս ֆունկցիան գտնում և վերադարձնում է այն արժեքը, որը հանդիպում է միայն մեկ անգամ: \nՕրինակներ:\nextraNumber(0, 0, 1) // վերադարձնում է 1\nextraNumber(4, 3, 4) // վերադարձնում է 3",
      "bn": "একটি JavaScript ফাংশন `function extraNumber(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি সংখ্যা a, b, এবং c দেওয়া হয়েছে, যেখানে দুটি সংখ্যা সমান এবং তৃতীয়টি ভিন্ন,\nএই ফাংশনটি সেই মানটি খুঁজে বের করে এবং ফেরত দেয় যা ঠিক একবার ঘটে।\nউদাহরণ:\nextraNumber(0, 0, 1) // returns 1\nextraNumber(4, 3, 4) // returns 3",
      "bg": "Напишете JavaScript функция `function extraNumber(a, b, c)` за решаване на следния проблем:  \nДадени са три цифри a, b и c, където две от тях са равни, а третата е различна,  \nтази функция намира и връща стойността, която се среща точно веднъж.  \nПримери:  \nextraNumber(0, 0, 1) // връща 1  \nextraNumber(4, 3, 4) // връща 3  ",
      "zh": "编写一个 JavaScript 函数 `function extraNumber(a, b, c)` 来解决以下问题：  \n给定三个数字 a, b 和 c，其中两个是相等的，第三个是不同的，  \n此函数查找并返回只出现一次的值。  \n示例：  \nextraNumber(0, 0, 1) // returns 1  \nextraNumber(4, 3, 4) // returns 3  ",
      "fr": "Écrire une fonction JavaScript `function extraNumber(a, b, c)` pour résoudre le problème suivant :  \nÉtant donné trois chiffres a, b et c, où deux d'entre eux sont égaux et le troisième est différent,  \ncette fonction trouve et renvoie la valeur qui apparaît exactement une fois.  \nExemples :  \nextraNumber(0, 0, 1) // renvoie 1  \nextraNumber(4, 3, 4) // renvoie 3  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function extraNumber(a, b, c)`, um das folgende Problem zu lösen:\nGegeben sind drei Ziffern a, b und c, wobei zwei von ihnen gleich sind und die dritte unterschiedlich ist,\ndiese Funktion findet und gibt den Wert zurück, der genau einmal vorkommt.\nBeispiele:\nextraNumber(0, 0, 1) // gibt 1 zurück\nextraNumber(4, 3, 4) // gibt 3 zurück",
      "ha": "Rubuta aikin JavaScript `function extraNumber(a, b, c)` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku a, b, da c, inda biyu daga cikinsu suke daidai kuma na uku ya bambanta,\nwannan aikin yana nemo kuma yana dawo da ƙimar da ta bayyana sau ɗaya kawai.\nMisalai:\nextraNumber(0, 0, 1) // yana dawowa 1\nextraNumber(4, 3, 4) // yana dawowa 3",
      "hi": "एक JavaScript फ़ंक्शन `function extraNumber(a, b, c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन अंक a, b, और c, जहाँ उनमें से दो समान हैं और तीसरा अलग है,\nयह फ़ंक्शन उस मान को खोजता है और लौटाता है जो केवल एक बार होता है।\nउदाहरण:\nextraNumber(0, 0, 1) // 1 लौटाता है\nextraNumber(4, 3, 4) // 3 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function extraNumber(a, b, c)` a következő probléma megoldására:\nAdott három számjegy, a, b és c, ahol kettő közülük egyenlő, és a harmadik különbözik,\nez a függvény megkeresi és visszaadja azt az értéket, amely pontosan egyszer fordul elő.\nPéldák:\nextraNumber(0, 0, 1) // visszaadja 1\nextraNumber(4, 3, 4) // visszaadja 3"
    },
    "instruction_bertscore": {
      "sq": "0.9928922104450476",
      "hy": "0.9325979582819073",
      "bn": "0.9588364357254728",
      "bg": "0.9893808225691129",
      "zh": "0.9735295222713857",
      "fr": "0.9891001578407105",
      "de": "0.9926572307042832",
      "ha": "0.9624163510828647",
      "hi": "0.9772828419514209",
      "hu": "0.9836763566561718"
    },
    "level": "easy",
    "test": "const testExtraNumber = () => {\n    console.assert(extraNumber(2, 7, 2) === 7, 'Test with 2, 7, 2 failed');\n    console.assert(extraNumber(3, 2, 2) === 3, 'Test with 3, 2, 2 failed');\n    console.assert(extraNumber(5, 5, 1) === 1, 'Test with 5, 5, 1 failed');\n    console.assert(extraNumber(500000000, 3, 500000000) === 3, 'Test with 500000000, 3, 500000000 failed');\n    console.assert(extraNumber(500000000, 500000000, 3) === 3, 'Test with 500000000, 500000000, 3 failed');\n};\n\ntestExtraNumber();",
    "entry_point": "extraNumber",
    "signature": "function extraNumber(a, b, c)",
    "docstring": {
      "en": "Given three digits a, b, and c, where two of them are equal and the third is different,\nthis function finds and returns the value that occurs exactly once.\nExamples:\nextraNumber(0, 0, 1) // returns 1\nextraNumber(4, 3, 4) // returns 3\n",
      "sq": "Duke pasur tre shifra a, b, dhe c, ku dy prej tyre janë të barabartë dhe i treti është i ndryshëm, kjo funksion gjen dhe kthen vlerën që ndodh saktësisht një herë.\nShembuj:\nextraNumber(0, 0, 1) // kthen 1\nextraNumber(4, 3, 4) // kthen 3",
      "hy": "Երեք թվանշանների `a`, `b` և `c` դեպքում, որտեղ երկուսը հավասար են, իսկ երրորդը՝ տարբեր,  \nայս ֆունկցիան գտնում և վերադարձնում է այն արժեքը, որը հանդիպում է միայն մեկ անգամ։  \nՕրինակներ:  \nextraNumber(0, 0, 1) // վերադարձնում է 1  \nextraNumber(4, 3, 4) // վերադարձնում է 3  ",
      "bn": "তিনটি সংখ্যা a, b, এবং c দেওয়া আছে, যেখানে এদের মধ্যে দুটি সমান এবং তৃতীয়টি ভিন্ন,\nএই ফাংশনটি সেই মানটি খুঁজে বের করে এবং ফেরত দেয় যা ঠিক একবার ঘটে।\nউদাহরণ:\nextraNumber(0, 0, 1) // 1 ফেরত দেয়\nextraNumber(4, 3, 4) // 3 ফেরত দেয়",
      "bg": "Дадени са три цифри a, b и c, където две от тях са равни, а третата е различна, тази функция намира и връща стойността, която се среща точно веднъж.\nПримери:\nextraNumber(0, 0, 1) // връща 1\nextraNumber(4, 3, 4) // връща 3",
      "zh": "给定三个数字 a、b 和 c，其中两个相等，第三个不同，  \n此函数查找并返回仅出现一次的值。  \n示例：  \nextraNumber(0, 0, 1) // 返回 1  \nextraNumber(4, 3, 4) // 返回 3  ",
      "fr": "Étant donné trois chiffres a, b et c, où deux d'entre eux sont égaux et le troisième est différent, cette fonction trouve et renvoie la valeur qui apparaît exactement une fois.\nExemples :\nextraNumber(0, 0, 1) // renvoie 1\nextraNumber(4, 3, 4) // renvoie 3",
      "de": "Gegeben drei Ziffern a, b und c, von denen zwei gleich sind und die dritte unterschiedlich ist, \nfindet und gibt diese Funktion den Wert zurück, der genau einmal vorkommt.\nBeispiele:\nextraNumber(0, 0, 1) // gibt 1 zurück\nextraNumber(4, 3, 4) // gibt 3 zurück",
      "ha": "An ba da lambobi uku a, b, da c, inda biyu daga cikinsu suke daidai kuma na uku ya bambanta,\nwannan aikin yana gano kuma yana dawowa da ƙimar da ta bayyana sau ɗaya kawai.\nMisalai:\nextraNumber(0, 0, 1) // yana dawowa 1\nextraNumber(4, 3, 4) // yana dawowa 3",
      "hi": "तीन अंक a, b, और c दिए गए हैं, जहाँ इनमें से दो समान हैं और तीसरा भिन्न है, \nयह फ़ंक्शन उस मान को खोजता और लौटाता है जो केवल एक बार आता है।\nउदाहरण:\nextraNumber(0, 0, 1) // 1 लौटाता है\nextraNumber(4, 3, 4) // 3 लौटाता है",
      "hu": "Három számjegy, a, b és c esetén, ahol kettő közülük egyenlő és a harmadik eltérő, ez a függvény megkeresi és visszaadja azt az értéket, amely pontosan egyszer fordul elő.\nPéldák:\nextraNumber(0, 0, 1) // visszaadja: 1\nextraNumber(4, 3, 4) // visszaadja: 3"
    },
    "docstring_bertscore": {
      "sq": "0.9996003556733578",
      "hy": "0.9388699111934649",
      "bn": "0.9565726452728183",
      "bg": "0.9975187092801122",
      "zh": "0.963585489505636",
      "fr": "0.984906871866683",
      "de": "0.9774268489776712",
      "ha": "0.948122710233213",
      "hi": "0.29660989604887295",
      "hu": "0.9731709944336177"
    }
  },
  {
    "task_id": "JavaScript/13",
    "prompt": {
      "en": "/**\n * Calculate the total score for a student based on the scores in different subjects.\n * @param {number} score1 - The score in the first subject.\n * @param {number} score2 - The score in the second subject.\n * @param {number} score3 - The score in the third subject.\n * @param {number} score4 - The score in the fourth subject.\n * @param {number} score5 - The score in the fifth subject.\n * @returns {number} The total score obtained by summing up the scores in all subjects.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "sq": "/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n * @param {number} score1 - Pikët në lëndën e parë.\n * @param {number} score2 - Pikët në lëndën e dytë.\n * @param {number} score3 - Pikët në lëndën e tretë.\n * @param {number} score4 - Pikët në lëndën e katërt.\n * @param {number} score5 - Pikët në lëndën e pestë.\n * @returns {number} Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "hy": "/**\n * Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n * @param {number} score1 - Առաջին առարկայի միավորը։\n * @param {number} score2 - Երկրորդ առարկայի միավորը։\n * @param {number} score3 - Երրորդ առարկայի միավորը։\n * @param {number} score4 - Չորրորդ առարկայի միավորը։\n * @param {number} score5 - Հինգերորդ առարկայի միավորը։\n * @returns {number} Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարումով։\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "bn": "/**\n * বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n * @param {number} score1 - প্রথম বিষয়ের নম্বর।\n * @param {number} score2 - দ্বিতীয় বিষয়ের নম্বর।\n * @param {number} score3 - তৃতীয় বিষয়ের নম্বর।\n * @param {number} score4 - চতুর্থ বিষয়ের নম্বর।\n * @param {number} score5 - পঞ্চম বিষয়ের নম্বর।\n * @returns {number} সব বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "bg": "/**\n * Изчислява общия резултат за студент въз основа на резултатите в различни предмети.\n * @param {number} score1 - Резултатът в първия предмет.\n * @param {number} score2 - Резултатът във втория предмет.\n * @param {number} score3 - Резултатът в третия предмет.\n * @param {number} score4 - Резултатът в четвъртия предмет.\n * @param {number} score5 - Резултатът в петия предмет.\n * @returns {number} Общият резултат, получен чрез събиране на резултатите във всички предмети.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "zh": "/**\n * 计算学生在不同科目中的总分。\n * @param {number} score1 - 第一科目的分数。\n * @param {number} score2 - 第二科目的分数。\n * @param {number} score3 - 第三科目的分数。\n * @param {number} score4 - 第四科目的分数。\n * @param {number} score5 - 第五科目的分数。\n * @returns {number} 通过将所有科目的分数相加获得的总分。\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "fr": "/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n * @param {number} score1 - Le score dans la première matière.\n * @param {number} score2 - Le score dans la deuxième matière.\n * @param {number} score3 - Le score dans la troisième matière.\n * @param {number} score4 - Le score dans la quatrième matière.\n * @param {number} score5 - Le score dans la cinquième matière.\n * @returns {number} Le score total obtenu en additionnant les scores dans toutes les matières.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "de": "/**\n * Berechne die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n * @param {number} score1 - Die Punktzahl im ersten Fach.\n * @param {number} score2 - Die Punktzahl im zweiten Fach.\n * @param {number} score3 - Die Punktzahl im dritten Fach.\n * @param {number} score4 - Die Punktzahl im vierten Fach.\n * @param {number} score5 - Die Punktzahl im fünften Fach.\n * @returns {number} Die Gesamtpunktzahl, die durch das Addieren der Punkte in allen Fächern erzielt wird.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "ha": "/**\n * Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n * @param {number} score1 - Maki a fanni na farko.\n * @param {number} score2 - Maki a fanni na biyu.\n * @param {number} score3 - Maki a fanni na uku.\n * @param {number} score4 - Maki a fanni na huɗu.\n * @param {number} score5 - Maki a fanni na biyar.\n * @returns {number} Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "hi": "/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n * @param {number} score1 - पहले विषय में अंक।\n * @param {number} score2 - दूसरे विषय में अंक।\n * @param {number} score3 - तीसरे विषय में अंक।\n * @param {number} score4 - चौथे विषय में अंक।\n * @param {number} score5 - पांचवें विषय में अंक।\n * @returns {number} सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)",
      "hu": "/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n * @param {number} score1 - Az első tantárgy pontszáma.\n * @param {number} score2 - A második tantárgy pontszáma.\n * @param {number} score3 - A harmadik tantárgy pontszáma.\n * @param {number} score4 - A negyedik tantárgy pontszáma.\n * @param {number} score5 - Az ötödik tantárgy pontszáma.\n * @returns {number} Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1, score2, score3, score4, score5)"
    },
    "prompt_bertscore": {
      "sq": "0.991989435363244",
      "hy": "0.9596984915791643",
      "bn": "0.937475923179362",
      "bg": "0.9939668008064463",
      "zh": "0.9536887307705727",
      "fr": "0.9876390327578178",
      "de": "0.9907038995371862",
      "ha": "0.9699950932712508",
      "hi": "0.9466599961072721",
      "hu": "0.9759416896186733"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function calculateTotalScore(score1, score2, score3, score4, score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n@param {number} score1 - The score in the first subject.\n@param {number} score2 - The score in the second subject.\n@param {number} score3 - The score in the third subject.\n@param {number} score4 - The score in the fourth subject.\n@param {number} score5 - The score in the fifth subject.\n@returns {number} The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500\n",
      "sq": "Shkruani një funksion JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n@param {number} score1 - Pikët në lëndën e parë.\n@param {number} score2 - Pikët në lëndën e dytë.\n@param {number} score3 - Pikët në lëndën e tretë.\n@param {number} score4 - Pikët në lëndën e katërt.\n@param {number} score5 - Pikët në lëndën e pestë.\n@returns {number} Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hy": "Գրեք JavaScript ֆունկցիա `function calculateTotalScore(score1, score2, score3, score4, score5)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n@param {number} score1 - Առաջին առարկայում ստացված միավորը։\n@param {number} score2 - Երկրորդ առարկայում ստացված միավորը։\n@param {number} score3 - Երրորդ առարկայում ստացված միավորը։\n@param {number} score4 - Չորրորդ առարկայում ստացված միավորը։\n@param {number} score5 - Հինգերորդ առարկայում ստացված միավորը։\n@returns {number} Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաներում ստացված միավորների գումարով։\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bn": "একটি JavaScript ফাংশন `function calculateTotalScore(score1, score2, score3, score4, score5)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন ছাত্রের মোট স্কোর গণনা করুন।\n@param {number} score1 - প্রথম বিষয়ের স্কোর।\n@param {number} score2 - দ্বিতীয় বিষয়ের স্কোর।\n@param {number} score3 - তৃতীয় বিষয়ের স্কোর।\n@param {number} score4 - চতুর্থ বিষয়ের স্কোর।\n@param {number} score5 - পঞ্চম বিষয়ের স্কোর।\n@returns {number} সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bg": "Напишете JavaScript функция `function calculateTotalScore(score1, score2, score3, score4, score5)` за решаване на следния проблем:\nИзчислете общия резултат за ученик въз основа на резултатите в различни предмети.\n@param {number} score1 - Резултатът в първия предмет.\n@param {number} score2 - Резултатът във втория предмет.\n@param {number} score3 - Резултатът в третия предмет.\n@param {number} score4 - Резултатът в четвъртия предмет.\n@param {number} score5 - Резултатът в петия предмет.\n@returns {number} Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "zh": "编写一个 JavaScript 函数 `function calculateTotalScore(score1, score2, score3, score4, score5)` 来解决以下问题：\n计算学生在不同科目中的总分。\n@param {number} score1 - 第一科目的分数。\n@param {number} score2 - 第二科目的分数。\n@param {number} score3 - 第三科目的分数。\n@param {number} score4 - 第四科目的分数。\n@param {number} score5 - 第五科目的分数。\n@returns {number} 通过将所有科目的分数相加获得的总分。\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "fr": "Écrire une fonction JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` pour résoudre le problème suivant :  \nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.  \n@param {number} score1 - Le score dans la première matière.  \n@param {number} score2 - Le score dans la deuxième matière.  \n@param {number} score3 - Le score dans la troisième matière.  \n@param {number} score4 - Le score dans la quatrième matière.  \n@param {number} score5 - Le score dans la cinquième matière.  \n@returns {number} Le score total obtenu en additionnant les scores dans toutes les matières.  \n@example  \ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function calculateTotalScore(score1, score2, score3, score4, score5)`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n@param {number} score1 - Die Punktzahl im ersten Fach.\n@param {number} score2 - Die Punktzahl im zweiten Fach.\n@param {number} score3 - Die Punktzahl im dritten Fach.\n@param {number} score4 - Die Punktzahl im vierten Fach.\n@param {number} score5 - Die Punktzahl im fünften Fach.\n@returns {number} Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erzielt wird.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "ha": "Rubuta wani aikin JavaScript `function calculateTotalScore(score1, score2, score3, score4, score5)` don warware matsalar mai zuwa:  \nƘididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.  \n@param {number} score1 - Maki a fanni na farko.  \n@param {number} score2 - Maki a fanni na biyu.  \n@param {number} score3 - Maki a fanni na uku.  \n@param {number} score4 - Maki a fanni na huɗu.  \n@param {number} score5 - Maki a fanni na biyar.  \n@returns {number} Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.  \n@example  \ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500  ",
      "hi": "JavaScript फ़ंक्शन `function calculateTotalScore(score1, score2, score3, score4, score5)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में प्राप्त अंकों के आधार पर एक छात्र का कुल स्कोर गणना करें।\n@param {number} score1 - पहले विषय में प्राप्त अंक।\n@param {number} score2 - दूसरे विषय में प्राप्त अंक।\n@param {number} score3 - तीसरे विषय में प्राप्त अंक।\n@param {number} score4 - चौथे विषय में प्राप्त अंक।\n@param {number} score5 - पाँचवे विषय में प्राप्त अंक।\n@returns {number} सभी विषयों में प्राप्त अंकों को जोड़कर प्राप्त कुल स्कोर।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hu": "Írj egy JavaScript függvényt `function calculateTotalScore(score1, score2, score3, score4, score5)` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n@param {number} score1 - Az első tantárgy pontszáma.\n@param {number} score2 - A második tantárgy pontszáma.\n@param {number} score3 - A harmadik tantárgy pontszáma.\n@param {number} score4 - A negyedik tantárgy pontszáma.\n@param {number} score5 - Az ötödik tantárgy pontszáma.\n@returns {number} Az összpontszám, amelyet a tantárgyak pontszámainak összeadásával kapunk.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500"
    },
    "instruction_bertscore": {
      "sq": "0.9931923409507912",
      "hy": "0.966238396874738",
      "bn": "0.9570964335876072",
      "bg": "0.9972517500480013",
      "zh": "0.9597924437493938",
      "fr": "0.9931923409507912",
      "de": "0.9948888430352103",
      "ha": "0.9723903770361505",
      "hi": "0.9397061450976217",
      "hu": "0.9711340398761049"
    },
    "level": "easy",
    "test": "function testCalculateTotalScore() {\n    console.assert(calculateTotalScore(100, 100, 100, 100, 100) === 500, 'Test failed: Expected 500 for all 100 scores');\n    console.assert(calculateTotalScore(0, 0, 0, 0, 0) === 0, 'Test failed: Expected 0 for all 0 scores');\n    console.assert(calculateTotalScore(20, 30, 40, 10, 50) === 150, 'Test failed: Expected 150 for mixed scores');\n    console.assert(calculateTotalScore(23, 45, 67, 89, 12) === 236, 'Test failed: Expected 236 for mixed scores');\n    console.assert(calculateTotalScore(5, 5, 5, 5, 5) === 25, 'Test failed: Expected 25 for all 5 scores');\n}\n\ntestCalculateTotalScore(); // Running the test function to validate our code",
    "entry_point": "calculateTotalScore",
    "signature": "function calculateTotalScore(score1, score2, score3, score4, score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n@param {number} score1 - The score in the first subject.\n@param {number} score2 - The score in the second subject.\n@param {number} score3 - The score in the third subject.\n@param {number} score4 - The score in the fourth subject.\n@param {number} score5 - The score in the fifth subject.\n@returns {number} The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500\n",
      "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n@param {number} score1 - Rezultati në lëndën e parë.\n@param {number} score2 - Rezultati në lëndën e dytë.\n@param {number} score3 - Rezultati në lëndën e tretë.\n@param {number} score4 - Rezultati në lëndën e katërt.\n@param {number} score5 - Rezultati në lëndën e pestë.\n@returns {number} Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hy": "Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա:\n@param {number} score1 - Առաջին առարկայի միավորը:\n@param {number} score2 - Երկրորդ առարկայի միավորը:\n@param {number} score3 - Երրորդ առարկայի միավորը:\n@param {number} score4 - Չորրորդ առարկայի միավորը:\n@param {number} score5 - Հինգերորդ առարկայի միավորը:\n@returns {number} Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bn": "বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n@param {number} score1 - প্রথম বিষয়ের স্কোর।\n@param {number} score2 - দ্বিতীয় বিষয়ের স্কোর।\n@param {number} score3 - তৃতীয় বিষয়ের স্কোর।\n@param {number} score4 - চতুর্থ বিষয়ের স্কোর।\n@param {number} score5 - পঞ্চম বিষয়ের স্কোর।\n@returns {number} সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bg": "Изчислява общия резултат за студент въз основа на резултатите в различни предмети.\n@param {number} score1 - Резултатът в първия предмет.\n@param {number} score2 - Резултатът във втория предмет.\n@param {number} score3 - Резултатът в третия предмет.\n@param {number} score4 - Резултатът в четвъртия предмет.\n@param {number} score5 - Резултатът в петия предмет.\n@returns {number} Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "zh": "计算学生在不同科目中的总分。  \n@param {number} score1 - 第一科目的分数。  \n@param {number} score2 - 第二科目的分数。  \n@param {number} score3 - 第三科目的分数。  \n@param {number} score4 - 第四科目的分数。  \n@param {number} score5 - 第五科目的分数。  \n@returns {number} 通过将所有科目的分数相加获得的总分。  \n@example  \ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500  ",
      "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n@param {number} score1 - Le score dans la première matière.\n@param {number} score2 - Le score dans la deuxième matière.\n@param {number} score3 - Le score dans la troisième matière.\n@param {number} score4 - Le score dans la quatrième matière.\n@param {number} score5 - Le score dans la cinquième matière.\n@returns {number} Le score total obtenu en additionnant les scores dans toutes les matières.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n@param {number} score1 - Die Punktzahl im ersten Fach.\n@param {number} score2 - Die Punktzahl im zweiten Fach.\n@param {number} score3 - Die Punktzahl im dritten Fach.\n@param {number} score4 - Die Punktzahl im vierten Fach.\n@param {number} score5 - Die Punktzahl im fünften Fach.\n@returns {number} Die Gesamtpunktzahl, die durch Summieren der Punkte in allen Fächern erzielt wird.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "ha": "Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n@param {number} score1 - Makasudin a fannin farko.\n@param {number} score2 - Makasudin a fannin na biyu.\n@param {number} score3 - Makasudin a fannin na uku.\n@param {number} score4 - Makasudin a fannin na hudu.\n@param {number} score5 - Makasudin a fannin na biyar.\n@returns {number} Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hi": "विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n@param {number} score1 - पहले विषय में प्राप्त अंक।\n@param {number} score2 - दूसरे विषय में प्राप्त अंक।\n@param {number} score3 - तीसरे विषय में प्राप्त अंक।\n@param {number} score4 - चौथे विषय में प्राप्त अंक।\n@param {number} score5 - पांचवें विषय में प्राप्त अंक।\n@returns {number} सभी विषयों में प्राप्त अंकों को जोड़कर प्राप्त कुल अंक।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n@param {number} score1 - Az első tantárgy pontszáma.\n@param {number} score2 - A második tantárgy pontszáma.\n@param {number} score3 - A harmadik tantárgy pontszáma.\n@param {number} score4 - A negyedik tantárgy pontszáma.\n@param {number} score5 - Az ötödik tantárgy pontszáma.\n@returns {number} Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500"
    },
    "docstring_bertscore": {
      "sq": "0.9624326387741096",
      "hy": "0.9696598051880639",
      "bn": "0.9542635670932876",
      "bg": "0.9920098942924905",
      "zh": "0.9506685558269372",
      "fr": "0.9918049077392626",
      "de": "0.9966056054184947",
      "ha": "0.9639648735334126",
      "hi": "0.9401957689868727",
      "hu": "0.9740455640013143"
    }
  },
  {
    "task_id": "JavaScript/14",
    "prompt": {
      "en": "/**\n * Decode a series of numbers to reveal the pattern and understand the actual values\n * each digit represents. The patterns are as follows:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - A string representing a series of numbers.\n *                           The length does not exceed 100 characters.\n * @return {number} The result corresponding to each data string as per the pattern.\n *\n * Example usage:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "sq": "/**\n * Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale\n * që përfaqëson secila shifër. Modelet janë si më poshtë:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Një varg që përfaqëson një seri numrash.\n *                           Gjatësia nuk tejkalon 100 karaktere.\n * @return {number} Rezultati që korrespondon me secilin varg të dhënash sipas modelit.\n *\n * Shembull përdorimi:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "hy": "/**\n * Վերծանել թվերի շարք՝ բացահայտելու համար նախշը և հասկանալու իրական արժեքները,\n * որոնք ներկայացնում է յուրաքանչյուր թվանշան։ Նախշերը հետևյալն են՝\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4։\n *\n * @param {string} dataStr - Թվերի շարքը ներկայացնող տող։\n *                           Երկարությունը չի գերազանցում 100 նիշը։\n * @return {number} Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի նախշին։\n *\n * Օրինակ օգտագործում՝\n * console.assert(decodeNumbers(\"0000\") === 4);\n */",
      "bn": "/**\n * সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্ন উন্মোচন করুন এবং প্রতিটি অঙ্ক প্রকৃতপক্ষে কোন মানগুলি উপস্থাপন করে তা বুঝুন।\n * প্যাটার্নগুলি নিম্নরূপ:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে।\n *                           দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n * @return {number} প্রতিটি ডেটা স্ট্রিংয়ের সাথে প্যাটার্ন অনুযায়ী সংশ্লিষ্ট ফলাফল।\n *\n * উদাহরণ ব্যবহার:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */",
      "bg": "/**\n * Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности,\n * които всяка цифра представлява. Моделите са както следва:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Низ, представляващ серия от числа.\n *                           Дължината не надвишава 100 символа.\n * @return {number} Резултатът, съответстващ на всеки низ от данни според модела.\n *\n * Пример за използване:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */",
      "zh": "/**\n * 解码一系列数字以揭示模式并理解每个数字实际代表的值。模式如下：\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n *\n * @param {string} dataStr - 表示一系列数字的字符串。\n *                           长度不超过100个字符。\n * @return {number} 根据模式对应每个数据字符串的结果。\n *\n * 示例用法:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */",
      "fr": "/**\n * Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles\n * que chaque chiffre représente. Les motifs sont les suivants :\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Une chaîne représentant une série de chiffres.\n *                           La longueur ne dépasse pas 100 caractères.\n * @return {number} Le résultat correspondant à chaque chaîne de données selon le motif.\n *\n * Exemple d'utilisation :\n * console.assert(decodeNumbers(\"0000\") === 4);\n */",
      "de": "/**\n * Dekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen,\n * die jede Ziffer darstellt. Die Muster sind wie folgt:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Ein String, der eine Reihe von Zahlen darstellt.\n *                           Die Länge überschreitet nicht 100 Zeichen.\n * @return {number} Das Ergebnis, das jedem Datenstring gemäß dem Muster entspricht.\n *\n * Beispielverwendung:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "ha": "/**\n * Fassar da jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar\n * kowace lamba ke wakilta. Tsarin suna kamar haka:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Wani kirtani da ke wakiltar jerin lambobi.\n *                           Tsawon ba ya wuce haruffa 100.\n * @return {number} Sakamakon da ya dace da kowanne kirtani na bayanai bisa tsarin.\n *\n * Misalin amfani:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "hi": "/**\n * संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n * पैटर्न इस प्रकार हैं:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है।\n *                           लंबाई 100 वर्णों से अधिक नहीं है।\n * @return {number} पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n *\n * उदाहरण उपयोग:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)",
      "hu": "/**\n * Dekódolja a számok sorozatát, hogy feltárja a mintát és megértse, hogy az egyes számjegyek\n * valójában milyen értékeket képviselnek. A minták a következők:\n * 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n *\n * @param {string} dataStr - Egy karakterlánc, amely számok sorozatát képviseli.\n *                           A hossza nem haladja meg a 100 karaktert.\n * @return {number} Az eredmény, amely megfelel az egyes adatkarakterláncoknak a minta szerint.\n *\n * Példa használat:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr)"
    },
    "prompt_bertscore": {
      "sq": "0.9902393030759455",
      "hy": "0.9655684165995073",
      "bn": "0.9605438624808488",
      "bg": "0.9773964585293728",
      "zh": "0.9665166780385679",
      "fr": "0.9708921080720044",
      "de": "0.9895973296844408",
      "ha": "0.9792131319943179",
      "hi": "0.9755273466438346",
      "hu": "0.9818414091961716"
    },
    "canonical_solution": "{\n    // Mapping values as per the given pattern\n    const a = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans = 0;\n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[dataStr[i] - '0']; // Subtracting '0' to convert char to actual number\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function decodeNumbers(dataStr)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n\nExample usage:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "sq": "Shkruani një funksion JavaScript `function decodeNumbers(dataStr)` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat reale që përfaqëson secila shifër. Modelet janë si më poshtë: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametrat:\n- dataStr (string): Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100 karaktere.\n\nKthen:\n- numër: Rezultati që korrespondon me secilin varg të dhënash sipas modelit.\n\nShembull përdorimi:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hy": "Գրեք JavaScript ֆունկցիա `function decodeNumbers(dataStr)` հետևյալ խնդիրը լուծելու համար:\nՎերծանել թվերի շարք՝ բացահայտելու համար նախշը և հասկանալու համար, թե ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան: Նախշերը հետևյալն են՝ 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4։\n\nՊարամետրեր:\n- dataStr (string): Տող, որը ներկայացնում է թվերի շարք: Երկարությունը չի գերազանցում 100 նիշը:\n\nՎերադարձնում է:\n- number: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողին ըստ նախշի:\n\nՕրինակ օգտագործում:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function decodeNumbers(dataStr)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্ন প্রকাশ করার জন্য এবং প্রতিটি অঙ্ক আসলে কী মান উপস্থাপন করে তা বোঝার জন্য। প্যাটার্নগুলি নিম্নরূপ: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4।\n\nপ্যারামিটারসমূহ:\n- dataStr (string): একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n\nরিটার্নস:\n- number: প্রতিটি ডেটা স্ট্রিং অনুযায়ী প্যাটার্নের ফলাফল।\n\nউদাহরণ ব্যবহার:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "bg": "Напишете функция на JavaScript `function decodeNumbers(dataStr)`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете шаблона и да разберете действителните стойности, които представлява всяка цифра. Шаблоните са както следва: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nПараметри:\n- dataStr (string): Низ, представляващ серия от числа. Дължината не надвишава 100 знака.\n\nВръща:\n- number: Резултатът, съответстващ на всеки низ от данни според шаблона.\n\nПример за използване:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "zh": "编写一个 JavaScript 函数 `function decodeNumbers(dataStr)` 来解决以下问题：\n解码一系列数字以揭示模式并理解每个数字代表的实际值。模式如下：0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n\n参数：\n- dataStr (string): 一个表示一系列数字的字符串。长度不超过 100 个字符。\n\n返回：\n- number: 根据模式对应于每个数据字符串的结果。\n\n示例用法：\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "fr": "Écrire une fonction JavaScript `function decodeNumbers(dataStr)` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente. Les motifs sont les suivants : 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParamètres :\n- dataStr (string) : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100 caractères.\n\nRenvoie :\n- number : Le résultat correspondant à chaque chaîne de données selon le motif.\n\nExemple d'utilisation :\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "de": "Schreiben Sie eine JavaScript-Funktion `function decodeNumbers(dataStr)`, um das folgende Problem zu lösen:\nDekodieren Sie eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt. Die Muster sind wie folgt: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameter:\n- dataStr (string): Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100 Zeichen.\n\nRückgabewert:\n- number: Das Ergebnis, das der jeweiligen Datenzeichenfolge gemäß dem Muster entspricht.\n\nBeispielverwendung:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "ha": "Rubuta wani aikin JavaScript `function decodeNumbers(dataStr)` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar kowace lamba da aka wakilta. Tsarin sune kamar haka: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nSigogi:\n- dataStr (string): Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce haruffa 100 ba.\n\nDawowa:\n- number: Sakamakon da ya dace da kowane kirtani na bayanai bisa tsarin.\n\nMisalin amfani:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hi": "`function decodeNumbers(dataStr)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मान क्या दर्शाता है। पैटर्न निम्नलिखित हैं: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4।\n\nपैरामीटर्स:\n- dataStr (string): संख्याओं की एक श्रृंखला का प्रतिनिधित्व करने वाला एक स्ट्रिंग। लंबाई 100 वर्णों से अधिक नहीं है।\n\nवापसी:\n- number: पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n\nउदाहरण उपयोग:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hu": "Írj egy JavaScript függvényt `function decodeNumbers(dataStr)` a következő probléma megoldására:  \nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában mit képviselnek. A minták a következők: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParaméterek:\n- dataStr (string): Egy számsorozatot reprezentáló karakterlánc. A hossza nem haladja meg a 100 karaktert.\n\nVisszatérési érték:\n- number: Az eredmény, amely megfelel az egyes adatkarakterláncoknak a minta szerint.\n\nPélda használat:\nconsole.assert(decodeNumbers(\"0000\") === 4);"
    },
    "instruction_bertscore": {
      "sq": "0.9881332251458327",
      "hy": "0.9863727640787204",
      "bn": "0.9763377585984568",
      "bg": "0.987463046240221",
      "zh": "0.9882015539969087",
      "fr": "0.9901608440754368",
      "de": "0.9725780827462285",
      "ha": "0.9674524257636232",
      "hi": "0.9706980461897333",
      "hu": "0.9783707405483489"
    },
    "level": "easy",
    "test": "function testDecodeNumbers() {\n    console.assert(decodeNumbers(\"0000\") === 4, \"Test 0000 failed\");\n    console.assert(decodeNumbers(\"8888\") === 8, \"Test 8888 failed\");\n    console.assert(decodeNumbers(\"1234\") === 1, \"Test 1234 failed\");\n    console.assert(decodeNumbers(\"5678\") === 3, \"Test 5678 failed\");\n    console.assert(decodeNumbers(\"9012\") === 2, \"Test 9012 failed\");\n    console.assert(decodeNumbers(\"1357\") === 0, \"Test 1357 failed\");\n    console.assert(decodeNumbers(\"2468\") === 4, \"Test 2468 failed\");\n\n    // Additional test samples\n    console.assert(decodeNumbers(\"9999\") === 4, \"Test 9999 failed\");\n    console.assert(decodeNumbers(\"1111\") === 0, \"Test 1111 failed\");\n    console.assert(decodeNumbers(\"2222\") === 0, \"Test 2222 failed\");\n    console.assert(decodeNumbers(\"3333\") === 0, \"Test 3333 failed\");\n    console.assert(decodeNumbers(\"4444\") === 4, \"Test 4444 failed\");\n    console.assert(decodeNumbers(\"5555\") === 0, \"Test 5555 failed\");\n    console.assert(decodeNumbers(\"6666\") === 4, \"Test 6666 failed\");\n    console.assert(decodeNumbers(\"7777\") === 0, \"Test 7777 failed\");\n    console.assert(decodeNumbers(\"0001\") === 3, \"Test 0001 failed\");\n    console.assert(decodeNumbers(\"2301\") === 1, \"Test 2301 failed\");\n}\n\ntestDecodeNumbers();",
    "entry_point": "decodeNumbers",
    "signature": "function decodeNumbers(dataStr)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents. The patterns are as follows: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameters:\n- dataStr (string): A string representing a series of numbers. The length does not exceed 100 characters.\n\nReturns:\n- number: The result corresponding to each data string as per the pattern.\n\nExample usage:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secili shifër. Modelet janë si më poshtë: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParametrat:\n- dataStr (string): Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100 karaktere.\n\nKthen:\n- number: Rezultati që korrespondon me secilin varg të dhënash sipas modelit.\n\nShembull përdorimi:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hy": "Թվերի շարք վերծանեք՝ բացահայտելու համար օրինաչափությունը և հասկանալու համար, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան: Օրինաչափությունները հետևյալն են՝ 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4։\n\nՊարամետրեր:\n- dataStr (string): Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100 նիշը։\n\nՎերադարձնում է:\n- number: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի՝ ըստ օրինաչափության։\n\nՕրինակ օգտագործում:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "bn": "সংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্ন প্রকাশ করার জন্য এবং প্রতিটি অঙ্ক আসলে কী মান উপস্থাপন করে তা বোঝার জন্য। প্যাটার্নগুলি নিম্নরূপ: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4।\n\nপ্যারামিটারসমূহ:\n- dataStr (string): সংখ্যার একটি সিরিজকে উপস্থাপনকারী একটি স্ট্রিং। দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n\nরিটার্নস:\n- number: প্রতিটি ডেটা স্ট্রিংয়ের জন্য প্যাটার্ন অনুযায়ী ফলাফল।\n\nউদাহরণ ব্যবহার:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява. Моделите са както следва: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nПараметри:\n- dataStr (string): Низ, представляващ серия от числа. Дължината не надвишава 100 символа.\n\nВръща:\n- number: Резултатът, съответстващ на всеки низ от данни според модела.\n\nПример за използване:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。模式如下：0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4。\n\n参数：\n- dataStr (string): 表示一系列数字的字符串。长度不超过100个字符。\n\n返回：\n- number: 根据模式对应每个数据字符串的结果。\n\n示例用法：\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente. Les motifs sont les suivants : 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParamètres :\n- dataStr (string): Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100 caractères.\n\nRenvoie :\n- number: Le résultat correspondant à chaque chaîne de données selon le motif.\n\nExemple d'utilisation :\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt. Die Muster sind wie folgt: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParameter:\n- dataStr (string): Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100 Zeichen.\n\nRückgabewert:\n- number: Das Ergebnis, das der jeweiligen Datenreihe gemäß dem Muster entspricht.\n\nBeispielverwendung:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar kowace lamba da aka wakilta. Tsarin suna kamar haka: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nSigogi:\n- dataStr (string): Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba ya wuce haruffa 100.\n\nDawowa:\n- number: Sakamakon da ya dace da kowanne kirtani na bayanai bisa tsarin.\n\nMisalin amfani:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मान क्या दर्शाता है। पैटर्न इस प्रकार हैं: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nपैरामीटर्स:\n- dataStr (string): एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 वर्णों से अधिक नहीं होती है।\n\nरिटर्न:\n- number: पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n\nउदाहरण उपयोग:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hu": "Dekódoljon egy számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek. A minták a következők: 0000=4, 8888=8, 1234=1, 5678=3, 9012=2, 1357=0, 2468=4.\n\nParaméterek:\n- dataStr (string): Egy számok sorozatát reprezentáló karakterlánc. A hossza nem haladja meg a 100 karaktert.\n\nVisszatérési érték:\n- number: Az eredmény, amely megfelel az egyes adatkarakterláncoknak a minta szerint.\n\nPélda használat:\nconsole.assert(decodeNumbers(\"0000\") === 4);"
    },
    "docstring_bertscore": {
      "sq": "0.9896394393252202",
      "hy": "0.9781973362257055",
      "bn": "0.9771291020364998",
      "bg": "0.9930469435118737",
      "zh": "0.9876761766390714",
      "fr": "0.9789177686177191",
      "de": "0.9772349720295914",
      "ha": "0.9781611854963571",
      "hi": "0.9922490452712566",
      "hu": "0.9821453136791549"
    }
  },
  {
    "task_id": "JavaScript/15",
    "prompt": {
      "en": "// No need to import modules in JavaScript like in C\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * @param {number} n - The number of squares.\n * @param {number} m - The number of colors.\n * @return {number} The count of different coloring methods satisfying the conditions,\n *                  result is modulo 1000003.\n * Example:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "sq": "// Nuk ka nevojë të importohen module në JavaScript si në C\n/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\n * duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * @param {number} n - Numri i katrorëve.\n * @param {number} m - Numri i ngjyrave.\n * @return {number} Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet,\n *                  rezultati është modulo 1000003.\n * Shembull:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "hy": "// JavaScript-ում անհրաժեշտ չէ մոդուլներ ներմուծել ինչպես C-ում\n/**\n * Հաշվում է n քառակուսիների համար տարբեր ներկման մեթոդների քանակը m գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ։\n * @param {number} n - Քառակուսիների քանակը։\n * @param {number} m - Գույների քանակը։\n * @return {number} Տարբեր ներկման մեթոդների քանակը, որոնք բավարարում են պայմաններին,\n *                  արդյունքը մոդուլ 1000003։\n * Օրինակ:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "bn": "// জাভাস্ক্রিপ্টে সি এর মতো মডিউল আমদানি করার প্রয়োজন নেই\n/**\n * n টি বর্গক্ষেত্র এবং m টি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * শর্তটি বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n * @param {number} n - বর্গক্ষেত্রের সংখ্যা।\n * @param {number} m - রঙের সংখ্যা।\n * @return {number} শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা,\n *                  ফলাফল 1000003 দ্বারা মডুলো।\n * উদাহরণ:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "bg": "// Няма нужда от импортиране на модули в JavaScript както в C\n/**\n * Брои броя на различните методи за оцветяване на n квадрата с m цвята,\n * като се взема предвид изискването съседните квадрати и първият/последният квадрат\n * да имат различни цветове.\n * @param {number} n - Броят на квадратите.\n * @param {number} m - Броят на цветовете.\n * @return {number} Броят на различните методи за оцветяване, които удовлетворяват условията,\n *                  резултатът е модуло 1000003.\n * Пример:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */",
      "zh": "// 不需要像在 C 中那样在 JavaScript 中导入模块\n/**\n * 计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n * 考虑到相邻方块和第一个/最后一个方块必须有不同颜色的要求。\n * @param {number} n - 方块的数量。\n * @param {number} m - 颜色的数量。\n * @return {number} 满足条件的不同着色方法的数量，\n *                  结果取模 1000003。\n * 示例:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "fr": "// Pas besoin d'importer des modules en JavaScript comme en C\n/**\n * Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * @param {number} n - Le nombre de carrés.\n * @param {number} m - Le nombre de couleurs.\n * @return {number} Le compte des différentes méthodes de coloration satisfaisant les conditions,\n *                  le résultat est modulo 1000003.\n * Exemple:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "de": "// Kein Bedarf, Module in JavaScript wie in C zu importieren\n/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * @param {number} n - Die Anzahl der Quadrate.\n * @param {number} m - Die Anzahl der Farben.\n * @return {number} Die Anzahl der verschiedenen Färbemethoden, die die Bedingungen erfüllen,\n *                  Ergebnis ist modulo 1000003.\n * Beispiel:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "ha": "// Babu buƙatar shigo da modules a JavaScript kamar yadda ake yi a C\n/**\n * Yana ƙidaya adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m,\n * la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe\n * dole ne su kasance da launuka daban-daban.\n * @param {number} n - Yawan murabba'ai.\n * @param {number} m - Yawan launuka.\n * @return {number} Adadin hanyoyin canza launi daban-daban da suka cika sharuɗɗan,\n *                  sakamakon yana modulo 1000003.\n * Misali:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */\nfunction count_coloring_methods(n, m)",
      "hi": "// JavaScript में C की तरह मॉड्यूल आयात करने की आवश्यकता नहीं है\n/**\n * n वर्गों के लिए m रंगों के विभिन्न रंगाई तरीकों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\n * रंग अलग-अलग होने चाहिए।\n * @param {number} n - वर्गों की संख्या।\n * @param {number} m - रंगों की संख्या।\n * @return {number} विभिन्न रंगाई तरीकों की संख्या जो शर्तों को संतुष्ट करती है,\n *                  परिणाम 1000003 के माड्यूलो में है।\n * उदाहरण:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */",
      "hu": "// Nincs szükség modulok importálására JavaScriptben, mint C-ben\n/**\n * Megszámolja a különböző színezési módszerek számát n négyzetre m színnel,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * @param {number} n - A négyzetek száma.\n * @param {number} m - A színek száma.\n * @return {number} A különböző színezési módszerek száma, amelyek megfelelnek a feltételeknek,\n *                  az eredmény modulo 1000003.\n * Példa:\n * count_coloring_methods(1,1) // 1\n * count_coloring_methods(2,3) // 6\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9827823213111339",
      "hy": "0.973828063734081",
      "bn": "0.9543342795089361",
      "bg": "0.9672690899219281",
      "zh": "0.9347644198478547",
      "fr": "0.9971597841815821",
      "de": "0.9925879087013021",
      "ha": "0.9629198790987881",
      "hi": "0.9706354776197073",
      "hu": "0.9675189669412699"
    },
    "canonical_solution": "{\n    const MOD = 1000003;\n    let f = new Array(1111); // Array to store results\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    // Formula derived from the given gold.c code\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD +\n                (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function count_coloring_methods(n, m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\nExample:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "sq": "Shkruani një funksion JavaScript `function count_coloring_methods(n, m)` për të zgjidhur problemin në vijim:\nNumëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\nduke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\nParametrat:\n- n (numër): Numri i katrorëve.\n- m (numër): Numri i ngjyrave.\nKthen:\n- numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet,\n           rezultati është modulo 1000003.\nShembull:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "hy": "Գրեք JavaScript ֆունկցիա `function count_coloring_methods(n, m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով,\nհաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ:\nՊարամետրեր:\n- n (թիվ): Քառակուսիների քանակը:\n- m (թիվ): Գույների քանակը:\nՎերադարձնում է:\n- թիվ: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են պայմաններին,\n           արդյունքը մոդուլո 1000003:\nՕրինակ:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function count_coloring_methods(n, m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nপ্রতিবেশী বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হওয়ার প্রয়োজনীয়তা বিবেচনা করে।\nপ্যারামিটারসমূহ:\n- n (number): বর্গক্ষেত্রের সংখ্যা।\n- m (number): রঙের সংখ্যা।\nফেরত দেয়:\n- number: বিভিন্ন রঙ করার পদ্ধতির সংখ্যা যা শর্তগুলি পূরণ করে,\n           ফলাফল 1000003 দ্বারা মডুলো।\nউদাহরণ:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "bg": "Напишете JavaScript функция `function count_coloring_methods(n, m)` за решаване на следния проблем:\nБрои броя на различните методи за оцветяване на n квадрата с m цвята,\nкато се взема предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\nПараметри:\n- n (number): Броят на квадратите.\n- m (number): Броят на цветовете.\nВръща:\n- number: Броят на различните методи за оцветяване, които удовлетворяват условията,\n           резултатът е модуло 1000003.\nПример:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "zh": "编写一个 JavaScript 函数 `function count_coloring_methods(n, m)` 来解决以下问题：\n计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n参数：\n- n (number): 方块的数量。\n- m (number): 颜色的数量。\n返回：\n- number: 满足条件的不同着色方法的数量，结果取模 1000003。\n示例：\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "fr": "Écrire une fonction JavaScript `function count_coloring_methods(n, m)` pour résoudre le problème suivant :\nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\nen considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\nParamètres :\n- n (nombre) : Le nombre de carrés.\n- m (nombre) : Le nombre de couleurs.\nRenvoie :\n- nombre : Le compte des différentes méthodes de coloration satisfaisant les conditions,\n           le résultat est modulo 1000003.\nExemple :\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "de": "Schreiben Sie eine JavaScript-Funktion `function count_coloring_methods(n, m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\nParameter:\n- n (number): Die Anzahl der Quadrate.\n- m (number): Die Anzahl der Farben.\nRückgabe:\n- number: Die Anzahl der verschiedenen Färbemethoden, die die Bedingungen erfüllen,\n           das Ergebnis ist modulo 1000003.\nBeispiel:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "ha": "Rubuta wani aikin JavaScript `function count_coloring_methods(n, m)` don warware matsalar mai zuwa:\nYana ƙidaya yawan hanyoyin launi daban-daban don murabba'i n tare da launuka m,\nla'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/karshe\ndole ne su sami launuka daban-daban.\nSigogi:\n- n (namba): Yawan murabba'ai.\n- m (namba): Yawan launuka.\nMayarwa:\n- namba: Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan,\n           sakamakon yana modulo 1000003.\nMisali:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "hi": "JavaScript फ़ंक्शन `function count_coloring_methods(n, m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की गिनती करता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\nपैरामीटर्स:\n- n (संख्या): वर्गों की संख्या।\n- m (संख्या): रंगों की संख्या।\nवापसी:\n- संख्या: विभिन्न रंगने के तरीकों की गिनती जो शर्तों को संतुष्ट करती है,\n           परिणाम 1000003 से मॉड्यूलो है।\nउदाहरण:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "hu": "Írj egy JavaScript függvényt `function count_coloring_methods(n, m)`, hogy megoldja a következő problémát:\nMegszámolja az n négyzet m színnel történő különböző színezési módszereit, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\nParaméterek:\n- n (szám): A négyzetek száma.\n- m (szám): A színek száma.\nVisszatér:\n- szám: A feltételeknek megfelelő különböző színezési módszerek száma, az eredmény modulo 1000003.\nPélda:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6"
    },
    "instruction_bertscore": {
      "sq": "0.986677661713609",
      "hy": "0.9838914733588326",
      "bn": "0.9762688338562377",
      "bg": "0.9844041383722837",
      "zh": "0.947171667968818",
      "fr": "0.9948660005413913",
      "de": "0.9887489793270409",
      "ha": "0.9751179694285216",
      "hi": "0.9663224175259157",
      "hu": "0.9786212134588339"
    },
    "level": "middle",
    "test": "(function testCountColoringMethods() {\n    console.assert(count_coloring_methods(1, 1) === 1, 'Test case 1 failed');\n    console.assert(count_coloring_methods(2, 2) === 2, 'Test case 2 failed');\n    console.assert(count_coloring_methods(3, 3) === 6, 'Test case 3 failed');\n    console.assert(count_coloring_methods(4, 2) === 2, 'Test case 4 failed');\n    // For large numbers like 1000, 10 in JavaScript sometimes it might not be possible \n    // to directly assert the expected result since it is not provided in the original code.\n    console.assert(count_coloring_methods(2, 3) === 6, 'Test case 5 failed');\n    console.assert(count_coloring_methods(1000, 1000) === 67911, 'Test case 6 failed');\n    console.assert(count_coloring_methods(999, 66) === 501817, 'Test case 7 failed');\n    console.assert(count_coloring_methods(5, 3) === 30, 'Test case 8 failed');\n    \n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "count_coloring_methods",
    "signature": "function count_coloring_methods(n, m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\nParameters:\n- n (number): The number of squares.\n- m (number): The number of colors.\nReturns:\n- number: The count of different coloring methods satisfying the conditions,\n           result is modulo 1000003.\nExample:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "sq": "Llogarit numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nParametrat:\n- n (numër): Numri i katrorëve.\n- m (numër): Numri i ngjyrave.\n\nKthen:\n- numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet, rezultati është modulo 1000003.\n\nShembull:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "hy": "Հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։  \nՊարամետրեր:  \n- n (թիվ): Քառակուսիների քանակը։  \n- m (թիվ): Գույների քանակը։  \nՎերադարձնում է:  \n- թիվ: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են պայմաններին, արդյունքը՝ 1000003 մոդուլով։  \nՕրինակ:  \n- count_coloring_methods(1,1) // 1  \n- count_coloring_methods(2,3) // 6  ",
      "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nযেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\nপ্যারামিটারসমূহ:\n- n (number): বর্গক্ষেত্রের সংখ্যা।\n- m (number): রঙের সংখ্যা।\nফেরত দেয়:\n- number: শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা,\n           ফলাফল 1000003 দ্বারা মডুলো।\nউদাহরণ:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "bg": "Брои броя на различните методи за оцветяване на n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\nПараметри:\n- n (number): Броят на квадратите.\n- m (number): Броят на цветовете.\nВръща:\n- number: Броят на различните методи за оцветяване, които удовлетворяват условията,\n           резултатът е модуло 1000003.\nПример:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及首尾方块必须具有不同颜色的要求。\n\n参数：\n- n (number): 方块的数量。\n- m (number): 颜色的数量。\n\n返回：\n- number: 满足条件的不同着色方法的数量，结果取模 1000003。\n\n示例：\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\nParamètres:\n- n (nombre): Le nombre de carrés.\n- m (nombre): Le nombre de couleurs.\n\nRenvoie:\n- nombre: Le compte des différentes méthodes de coloration satisfaisant les conditions, le résultat est modulo 1000003.\n\nExemple:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\nParameter:\n- n (number): Die Anzahl der Quadrate.\n- m (number): Die Anzahl der Farben.\nRückgabewert:\n- number: Die Anzahl der verschiedenen Färbemethoden, die die Bedingungen erfüllen,\n           das Ergebnis ist modulo 1000003.\nBeispiel:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "ha": "Yana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'ai n tare da launuka m, la'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'ai na farko/na ƙarshe dole ne su sami launuka daban-daban. \n\nSigogi:\n- n (number): Yawan murabba'ai.\n- m (number): Yawan launuka.\n\nYana dawowa:\n- number: Adadin hanyoyin canza launi daban-daban da suka cika sharuɗɗan, sakamakon yana modulo 1000003.\n\nMisali:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "hi": "गिनती करता है कि n वर्गों के लिए m रंगों के कितने विभिन्न रंगाई विधियाँ हैं, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nपैरामीटर्स:\n- n (संख्या): वर्गों की संख्या।\n- m (संख्या): रंगों की संख्या।\n\nवापसी:\n- संख्या: विभिन्न रंगाई विधियों की गिनती जो शर्तों को संतुष्ट करती हैं, परिणाम 1000003 से मॉड्यूलो है।\n\nउदाहरण:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6",
      "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\nParaméterek:\n- n (szám): A négyzetek száma.\n- m (szám): A színek száma.\nVisszatér:\n- szám: A feltételeknek megfelelő különböző színezési módszerek száma, az eredmény modulo 1000003.\nPélda:\n- count_coloring_methods(1,1) // 1\n- count_coloring_methods(2,3) // 6"
    },
    "docstring_bertscore": {
      "sq": "0.97346894000517",
      "hy": "0.952130475431354",
      "bn": "0.9544028069903931",
      "bg": "0.9739142693194502",
      "zh": "0.9313757855473996",
      "fr": "0.9887173970964562",
      "de": "0.9737130567434619",
      "ha": "0.9656891838711765",
      "hi": "0.9800793590860111",
      "hu": "0.9761367446528496"
    }
  },
  {
    "task_id": "JavaScript/16",
    "prompt": {
      "en": "/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n *     Number: The count of valid sequences.\n *\n * Examples:\n *     countValidCoinTossSequences(1)\n *     // returns 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "sq": "/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n *\n * Parametrat:\n * - n (int): Numri i hedhjeve të monedhës.\n *\n * Kthen:\n *     Numër: Numri i sekuencave të vlefshme.\n *\n * Shembuj:\n *     countValidCoinTossSequences(1)\n *     // kthen 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "hy": "/**\n * Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկա հաջորդական «գլուխ»։\n *\n * Պարամետրեր:\n * - n (int): Մետաղադրամի նետումների քանակը։\n *\n * Վերադարձնում է:\n *     Number: Վավեր հաջորդականությունների քանակը։\n *\n * Օրինակներ:\n *     countValidCoinTossSequences(1)\n *     // վերադարձնում է 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "bn": "/**\n * n টসের মধ্যে কোনো পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n *\n * প্যারামিটার:\n * - n (int): কয়েন টসের সংখ্যা।\n *\n * রিটার্নস:\n *     সংখ্যা: বৈধ সিকোয়েন্সের সংখ্যা।\n *\n * উদাহরণ:\n *     countValidCoinTossSequences(1)\n *     // রিটার্ন করে 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "bg": "/**\n * Пребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n *\n * Параметри:\n * - n (int): Броят на хвърлянията на монетата.\n *\n * Връща:\n *     Number: Броят на валидните последователности.\n *\n * Примери:\n *     countValidCoinTossSequences(1)\n *     // връща 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "zh": "/**\n * 计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n *\n * 参数:\n * - n (int): 投掷硬币的次数。\n *\n * 返回:\n *     Number: 有效序列的数量。\n *\n * 示例:\n *     countValidCoinTossSequences(1)\n *     // 返回 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "fr": "/**\n * Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n *\n * Paramètres:\n * - n (int): Le nombre de lancers de pièce.\n *\n * Retourne:\n *     Number: Le compte des séquences valides.\n *\n * Exemples:\n *     countValidCoinTossSequences(1)\n *     // returns 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "de": "/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n *\n * Parameter:\n * - n (int): Die Anzahl der Münzwürfe.\n *\n * Rückgabewert:\n *     Number: Die Anzahl der gültigen Sequenzen.\n *\n * Beispiele:\n *     countValidCoinTossSequences(1)\n *     // gibt 2 zurück\n */\nconst countValidCoinTossSequences = (n) =>",
      "ha": "/**\n * Ƙirga adadin jerin jefa tsabar kudi masu inganci ba tare da kai biyu a jere ba a cikin jefa n.\n *\n * Sigogi:\n * - n (int): Yawan jefa tsabar kudi.\n *\n * Komawa:\n *     Number: Adadin jerin masu inganci.\n *\n * Misalai:\n *     countValidCoinTossSequences(1)\n *     // yana dawowa 2\n */\nconst countValidCoinTossSequences = (n) =>",
      "hi": "/**\n * n उछालों में कोई लगातार हेड्स नहीं होने वाले वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n *\n * पैरामीटर्स:\n * - n (int): सिक्का उछालों की संख्या।\n *\n * रिटर्न करता है:\n *     संख्या: वैध अनुक्रमों की गिनती।\n *\n * उदाहरण:\n *     countValidCoinTossSequences(1)\n *     // 2 लौटाता है\n */\nconst countValidCoinTossSequences = (n) =>",
      "hu": "/**\n * Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej az n dobásban.\n *\n * Paraméterek:\n * - n (int): A pénzfeldobások száma.\n *\n * Visszatér:\n *     Szám: Az érvényes sorozatok száma.\n *\n * Példák:\n *     countValidCoinTossSequences(1)\n *     // visszaadja 2\n */\nconst countValidCoinTossSequences = (n) =>"
    },
    "prompt_bertscore": {
      "sq": "0.9799627630523435",
      "hy": "0.9568400017656912",
      "bn": "0.9875168750734814",
      "bg": "0.9912558933660821",
      "zh": "0.9642338190693339",
      "fr": "0.9872171418284997",
      "de": "0.982641095110218",
      "ha": "0.9807340448219021",
      "hi": "0.984263905323273",
      "hu": "0.9845932344950289"
    },
    "canonical_solution": "{\n    const a = Array.from({ length: n + 1 }, () => Array(2).fill(0));\n    a[1][0] = a[1][1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n};",
    "instruction": {
      "en": "Write a JavaScript function `const countValidCoinTossSequences = (n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n    Number: The count of valid sequences.\n\nExamples:\n    countValidCoinTossSequences(1)\n    // returns 2\n",
      "sq": "Shkruani një funksion JavaScript `const countValidCoinTossSequences = (n)` për të zgjidhur problemin në vijim: Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n    Numri: Numri i sekuencave të vlefshme.\n\nShembuj:\n    countValidCoinTossSequences(1)\n    // kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `const countValidCoinTossSequences = (n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետման հաջորդականությունների քանակը առանց հաջորդական գլխիկների n նետումներում:\n\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n\nՎերադարձնում է:\n    Number: Վավեր հաջորդականությունների քանակը։\n\nՕրինակներ:\n    countValidCoinTossSequences(1)\n    // returns 2",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const countValidCoinTossSequences = (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বার টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nরিটার্নস:\n    সংখ্যা: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n    countValidCoinTossSequences(1)\n    // রিটার্ন করে 2",
      "bg": "Напишете функция на JavaScript `const countValidCoinTossSequences = (n)`, за да решите следния проблем:  \nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:  \n- n (int): Броят на хвърлянията на монета.\n\nВръща:  \n    Number: Броят на валидните последователности.\n\nПримери:  \n    countValidCoinTossSequences(1)  \n    // връща 2",
      "zh": "编写一个 JavaScript 函数 `const countValidCoinTossSequences = (n)` 来解决以下问题：  \n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n\n参数：\n- n (int): 投掷硬币的次数。\n\n返回：\n    Number: 有效序列的数量。\n\n示例：\n    countValidCoinTossSequences(1)\n    // 返回 2",
      "fr": "Écrire une fonction JavaScript `const countValidCoinTossSequences = (n)` pour résoudre le problème suivant :  \nCompter le nombre de séquences de lancers de pièce valides sans têtes consécutives dans n lancers.\n\nParamètres :  \n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :  \n    Number : Le compte des séquences valides.\n\nExemples :  \n    countValidCoinTossSequences(1)  \n    // renvoie 2  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `const countValidCoinTossSequences = (n)`, um das folgende Problem zu lösen:  \nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nRückgabewert:\n    Number: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n    countValidCoinTossSequences(1)\n    // gibt 2 zurück",
      "ha": "Rubuta aikin JavaScript `const countValidCoinTossSequences = (n)` don warware matsalar mai zuwa:  \nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n    Number: Adadin sahihan jerin.\n\nMisalai:\n    countValidCoinTossSequences(1)\n    // ya dawo da 2",
      "hi": "JavaScript फ़ंक्शन `const countValidCoinTossSequences = (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn बार सिक्का उछालने पर कोई लगातार हेड्स न होने वाले मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालने की संख्या।\n\nरिटर्न करता है:\n    संख्या: मान्य अनुक्रमों की गिनती।\n\nउदाहरण:\n    countValidCoinTossSequences(1)\n    // returns 2",
      "hu": "Írj egy JavaScript függvényt `const countValidCoinTossSequences = (n)` a következő probléma megoldására:  \nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol nincs két egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n    Szám: Az érvényes sorozatok száma.\n\nPéldák:\n    countValidCoinTossSequences(1)\n    // visszatér 2\n"
    },
    "instruction_bertscore": {
      "sq": "0.991648386999007",
      "hy": "0.991648386999007",
      "bn": "0.9864148737194999",
      "bg": "0.991648386999007",
      "zh": "0.9793742212333372",
      "fr": "0.9955830562169272",
      "de": "0.9757678880352678",
      "ha": "0.9717533694041717",
      "hi": "0.9513256251274006",
      "hu": "0.9804215992325341"
    },
    "level": "easy",
    "test": "const testCountValidCoinTossSequences = () => {\n    console.assert(countValidCoinTossSequences(1) === 2);\n    console.assert(countValidCoinTossSequences(2) === 3);\n    console.assert(countValidCoinTossSequences(3) === 5);\n    console.assert(countValidCoinTossSequences(4) === 8);\n    console.assert(countValidCoinTossSequences(5) === 13);\n    // Additional tests\n    console.assert(countValidCoinTossSequences(40) === 267914296);\n    console.assert(countValidCoinTossSequences(39) === 165580141);\n    console.assert(countValidCoinTossSequences(38) === 102334155);\n    // console.log(\"All tests passed!\");\n};\n\ntestCountValidCoinTossSequences();",
    "entry_point": "countValidCoinTossSequences",
    "signature": "const countValidCoinTossSequences = (n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n    Number: The count of valid sequences.\n\nExamples:\n    countValidCoinTossSequences(1)\n    // returns 2\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n    Numër: Numri i sekuencave të vlefshme.\n\nShembuj:\n    countValidCoinTossSequences(1)\n    // kthen 2",
      "hy": "Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկան հաջորդական գլուխներ:\n\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը:\n\nՎերադարձնում է:\n    Number: Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\n    countValidCoinTossSequences(1)\n    // վերադարձնում է 2",
      "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nফেরত দেয়:\n    সংখ্যা: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n    countValidCoinTossSequences(1)\n    // 2 ফেরত দেয়",
      "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n    Number: Броят на валидните последователности.\n\nПримери:\n    countValidCoinTossSequences(1)\n    // връща 2",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n参数:\n- n (int): 硬币投掷的次数。\n\n返回:\n    Number: 有效序列的数量。\n\n示例:\n    countValidCoinTossSequences(1)\n    // 返回 2",
      "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n\nParamètres:\n- n (int): Le nombre de lancers de pièce.\n\nRenvoie:\n    Number: Le compte des séquences valides.\n\nExemples:\n    countValidCoinTossSequences(1)\n    // renvoie 2",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nRückgabe:\n    Number: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n    countValidCoinTossSequences(1)\n    // gibt 2 zurück",
      "ha": "Ƙirga adadin jerin jefa tsabar kudi masu inganci ba tare da kai biyu a jere ba a cikin jefa n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n    Number: Adadin sahihan jerin.\n\nMisalai:\n    countValidCoinTossSequences(1)\n    // returns 2",
      "hi": "n टॉस में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछाल की संख्या।\n\nवापसी:\n    संख्या: वैध अनुक्रमों की गिनती।\n\nउदाहरण:\n    countValidCoinTossSequences(1)\n    // 2 लौटाता है",
      "hu": "Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol n dobás során nincs egymást követő fej.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n    Number: Az érvényes sorozatok száma.\n\nPéldák:\n    countValidCoinTossSequences(1)\n    // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.98154743623224",
      "hy": "0.9572273310087093",
      "bn": "0.9776681848906286",
      "bg": "0.9797156668583362",
      "zh": "0.9701414838620736",
      "fr": "0.9942824244819107",
      "de": "0.9735974538616996",
      "ha": "0.9790101317449003",
      "hi": "0.9493524309222001",
      "hu": "0.9744857289256875"
    }
  },
  {
    "task_id": "JavaScript/17",
    "prompt": {
      "en": "/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * @param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} The length of the longest consecutive sequence of 1s in \n *                   the binary representation of the given integer.\n * \n * Examples:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "sq": "/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin \n * binar të një numri jo-negativ.\n *\n * @param {number} n - Një numër jo-negativ (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Gjatësia e sekuencës më të gjatë të njëshave radhazi në \n *                   përfaqësimin binar të numrit të dhënë.\n * \n * Shembuj:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "hy": "/**\n * Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի \n * երկբայական ներկայացման մեջ:\n *\n * @param {number} n - Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n * @returns {number} Ամենաերկար հաջորդական 1-երի երկարությունը տրված թվի \n *                   երկբայական ներկայացման մեջ:\n * \n * Օրինակներ:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "bn": "/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক \n * ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n *\n * @param {number} n - একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n * @returns {number} প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর \n *                   দীর্ঘতম ক্রমিক ক্রমের দৈর্ঘ্য।\n * \n * উদাহরণ:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "bg": "/**\n * Намерете дължината на най-дългата последователност от 1 в двоичното \n * представяне на неотрицателно цяло число.\n *\n * @param {number} n - Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Дължината на най-дългата последователност от 1 в \n *                   двоичното представяне на даденото цяло число.\n * \n * Примери:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "zh": "/**\n * 找到非负整数的二进制表示中最长连续1序列的长度。\n *\n * @param {number} n - 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n * @returns {number} 给定整数的二进制表示中最长连续1序列的长度。\n * \n * 例子:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "fr": "/**\n * Trouver la longueur de la plus longue séquence consécutive de 1s dans la \n * représentation binaire d'un entier non négatif.\n *\n * @param {number} n - Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} La longueur de la plus longue séquence consécutive de 1s \n *                   dans la représentation binaire de l'entier donné.\n * \n * Exemples :\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "de": "/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n * Binärdarstellung einer nicht-negativen ganzen Zahl.\n *\n * @param {number} n - Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in \n *                   der Binärdarstellung der gegebenen Zahl.\n * \n * Beispiele:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "ha": "/**\n * Nemo tsawon jerin lambobi 1 mafi tsawo a cikin wakilcin binary \n * na lamba maras kyau.\n *\n * @param {number} n - Lamba maras kyau (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} Tsawon jerin lambobi 1 mafi tsawo a cikin \n *                   wakilcin binary na lambar da aka bayar.\n * \n * Misalai:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "hi": "/**\n * एक गैर-ऋणात्मक पूर्णांक के द्विआधारी \n * प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n *\n * @param {number} n - एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n * @returns {number} दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में \n *                   1s के सबसे लंबे अनुक्रम की लंबाई।\n * \n * उदाहरण:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)",
      "hu": "/**\n * Határozza meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris \n * ábrázolásában.\n *\n * @param {number} n - Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n * @returns {number} A leghosszabb egymást követő 1-es sorozat hossza a \n *                   megadott egész szám bináris ábrázolásában.\n * \n * Példák:\n * findLongestConsecutiveOnesLength(7) === 3\n * findLongestConsecutiveOnesLength(13) === 2\n */\nfunction findLongestConsecutiveOnesLength(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9684151872204994",
      "hy": "0.9733056658319593",
      "bn": "0.9923404152465326",
      "bg": "0.9867195727240073",
      "zh": "0.9870197032297511",
      "fr": "0.996179940511937",
      "de": "0.9951299803177867",
      "ha": "0.967559686169382",
      "hi": "0.984810138871119",
      "hu": "0.9743951534719356"
    },
    "canonical_solution": "{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1)\n            ans++;\n        else {\n            if (ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>>= 1;\n    }\n    if (ans > max)\n        max = ans;\n    return max;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function findLongestConsecutiveOnesLength(n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2\n",
      "sq": "Shkruani një funksion JavaScript `function findLongestConsecutiveOnesLength(n)` për të zgjidhur problemin e mëposhtëm:  \nGjeni gjatësinë e sekuencës më të gjatë të njëshave të njëpasnjëshme në paraqitjen binare të një numri të plotë jo-negativ.\n\nParametrat:  \n@param {number} n - Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:  \n@returns {number} Gjatësia e sekuencës më të gjatë të njëshave të njëpasnjëshme në paraqitjen binare të numrit të dhënë.\n\nShembuj:  \nfindLongestConsecutiveOnesLength(7) === 3  \nfindLongestConsecutiveOnesLength(13) === 2  ",
      "hy": "Գրեք JavaScript ֆունկցիա `function findLongestConsecutiveOnesLength(n)` հետևյալ խնդիրը լուծելու համար:\nԳտեք ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n@param {number} n - Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n@returns {number} Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n\nՕրինակներ:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "bn": "একটি JavaScript ফাংশন `function findLongestConsecutiveOnesLength(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n@param {number} n - একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n@returns {number} প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "bg": "Напишете JavaScript функция `function findLongestConsecutiveOnesLength(n)`, за да решите следния проблем:  \nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n@param {number} n - Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n@returns {number} Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото цяло число.\n\nПримери:\nfindLongestConsecutiveOnesLength(7) === 3  \nfindLongestConsecutiveOnesLength(13) === 2  ",
      "zh": "编写一个 JavaScript 函数 `function findLongestConsecutiveOnesLength(n)` 来解决以下问题：  \n在一个非负整数的二进制表示中，找到最长连续1序列的长度。\n\n参数：  \n@param {number} n - 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：  \n@returns {number} 给定整数的二进制表示中最长连续1序列的长度。\n\n示例：  \nfindLongestConsecutiveOnesLength(7) === 3  \nfindLongestConsecutiveOnesLength(13) === 2  ",
      "fr": "Écrire une fonction JavaScript `function findLongestConsecutiveOnesLength(n)` pour résoudre le problème suivant :  \nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :  \n@param {number} n - Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :  \n@returns {number} La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :  \nfindLongestConsecutiveOnesLength(7) === 3  \nfindLongestConsecutiveOnesLength(13) === 2  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function findLongestConsecutiveOnesLength(n)`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n@param {number} n - Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n@returns {number} Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "ha": "Rubuta aikin JavaScript `function findLongestConsecutiveOnesLength(n)` don warware matsalar mai zuwa:  \nNemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:  \n@param {number} n - Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nMayarwa:  \n@returns {number} Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:  \nfindLongestConsecutiveOnesLength(7) === 3  \nfindLongestConsecutiveOnesLength(13) === 2  ",
      "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function findLongestConsecutiveOnesLength(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n@param {number} n - एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n@returns {number} दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "hu": "Írj egy JavaScript függvényt `function findLongestConsecutiveOnesLength(n)` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n@param {number} n - Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatér:\n@returns {number} A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2"
    },
    "instruction_bertscore": {
      "sq": "0.9754534561420896",
      "hy": "0.9878326973793269",
      "bn": "1",
      "bg": "0.9950330486918416",
      "zh": "0.9845803235202616",
      "fr": "1",
      "de": "0.9843677890125543",
      "ha": "0.969181900491294",
      "hi": "0.9907307146386259",
      "hu": "1"
    },
    "level": "easy",
    "test": "const testFindLongestConsecutiveOnesLength = () => {\n    console.assert(findLongestConsecutiveOnesLength(7) === 3, \"Test with n = 7\");\n    console.assert(findLongestConsecutiveOnesLength(13) === 2, \"Test with n = 13\");\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3, \"Test with n = 12345\");\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4, \"Test with n = 0b11011101111\");\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32, \"Test with n = 0xFFFFFFFF\");\n    console.assert(findLongestConsecutiveOnesLength(0) === 0, \"Test with n = 0\");\n\n    // console.log(\"All tests passed!\");\n}\n\ntestFindLongestConsecutiveOnesLength();",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "function findLongestConsecutiveOnesLength(n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n@param {number} n - A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n@returns {number} The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri jo-negativ.\n\nParametrat:\n@param {number} n - Një numër jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n@returns {number} Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ։\n\nՊարամետրեր:\n@param {number} n - Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n\nՎերադարձնում է:\n@returns {number} Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n\nՕրինակներ:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n@param {number} n - একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n@returns {number} প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "bg": "Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n@param {number} n - Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n@returns {number} Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n\nПримери:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数：\n@param {number} n - 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\n@returns {number} 给定整数的二进制表示中最长连续1序列的长度。\n\n示例：\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres:\n@param {number} n - Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie:\n@returns {number} La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der binären Darstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n@param {number} n - Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n@returns {number} Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der binären Darstellung der gegebenen Zahl.\n\nBeispiele:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n@param {number} n - Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n@returns {number} Tsawon jerin 1s mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n@param {number} n - एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n@returns {number} दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2",
      "hu": "Keresse meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n@param {number} n - Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n@returns {number} A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\nfindLongestConsecutiveOnesLength(7) === 3\nfindLongestConsecutiveOnesLength(13) === 2"
    },
    "docstring_bertscore": {
      "sq": "0.9617338570936288",
      "hy": "0.9912352358064546",
      "bn": "1",
      "bg": "0.9908630024723951",
      "zh": "1",
      "fr": "1",
      "de": "0.98257236899838",
      "ha": "0.9935993346015317",
      "hi": "0.9955717342852082",
      "hu": "0.9945136302454354"
    }
  },
  {
    "task_id": "JavaScript/18",
    "prompt": {
      "en": "/**\n * Creates an ID by combining two strings in a specific manner.\n * Parameters:\n * - word1 (string): The first string to be used in the ID.\n * - word2 (string): The second string to be used in the ID.\n * Returns:\n * string: A divine ID formed by reversing every other character of the second \n *         string and combining it with the first string.\n * Example usage:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n */\nfunction createId(word1, word2)",
      "sq": "/**\n * Krijon një ID duke kombinuar dy vargje në një mënyrë specifike.\n * Parametrat:\n * - word1 (string): Vargu i parë që do të përdoret në ID.\n * - word2 (string): Vargu i dytë që do të përdoret në ID.\n * Kthen:\n * string: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të vargut të dytë\n *         dhe duke e kombinuar atë me vargun e parë.\n * Shembull përdorimi:\n *   createId('fish','cat') // kthen 'ftiasch'\n *   createId('icpc','acm') // kthen 'imccpac'\n */\nfunction createId(word1, word2)",
      "hy": "/**\n * Ստեղծում է ID՝ երկու տողերը հատուկ ձևով համակցելով։\n * Պարամետրեր:\n * - word1 (string): Առաջին տողը, որը օգտագործվելու է ID-ում։\n * - word2 (string): Երկրորդ տողը, որը օգտագործվելու է ID-ում։\n * Վերադարձնում է:\n * string: Աստվածային ID, որը կազմվում է երկրորդ տողի ամեն երկրորդ նիշը շրջելով \n *         և այն առաջին տողի հետ համակցելով։\n * Օրինակ օգտագործում:\n *   createId('fish','cat') // վերադարձնում է 'ftiasch'\n *   createId('icpc','acm') // վերադարձնում է 'imccpac'\n */\nfunction createId(word1, word2)",
      "bn": "/**\n * দুটি স্ট্রিংকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\n * প্যারামিটার:\n * - word1 (string): প্রথম স্ট্রিং যা আইডিতে ব্যবহৃত হবে।\n * - word2 (string): দ্বিতীয় স্ট্রিং যা আইডিতে ব্যবহৃত হবে।\n * রিটার্ন:\n * string: দ্বিতীয় স্ট্রিংয়ের প্রতিটি বিকল্প অক্ষর উল্টে দিয়ে এবং প্রথম স্ট্রিংয়ের সাথে \n *         একত্রিত করে একটি অনন্য আইডি তৈরি করে।\n * উদাহরণ ব্যবহার:\n *   createId('fish','cat') // 'ftiasch' রিটার্ন করে\n *   createId('icpc','acm') // 'imccpac' রিটার্ন করে\n */\nfunction createId(word1, word2)",
      "bg": "/**\n * Създава ID, като комбинира два низа по специфичен начин.\n * Параметри:\n * - word1 (string): Първият низ, който ще се използва в ID.\n * - word2 (string): Вторият низ, който ще се използва в ID.\n * Връща:\n * string: Божествено ID, образувано чрез обръщане на всеки втори символ на втория \n *         низ и комбинирането му с първия низ.\n * Пример за използване:\n *   createId('fish','cat') // връща 'ftiasch'\n *   createId('icpc','acm') // връща 'imccpac'\n */\nfunction createId(word1, word2)",
      "zh": "/**\n * 通过以特定方式组合两个字符串来创建一个ID。\n * 参数：\n * - word1 (string): 用于ID的第一个字符串。\n * - word2 (string): 用于ID的第二个字符串。\n * 返回：\n * string: 一个神圣的ID，通过反转第二个字符串的每隔一个字符并将其与第一个字符串结合而成。\n * 示例用法：\n *   createId('fish','cat') // 返回 'ftiasch'\n *   createId('icpc','acm') // 返回 'imccpac'\n */\nfunction createId(word1, word2)",
      "fr": "/**\n * Crée un ID en combinant deux chaînes d'une manière spécifique.\n * Paramètres:\n * - word1 (string): La première chaîne à utiliser dans l'ID.\n * - word2 (string): La deuxième chaîne à utiliser dans l'ID.\n * Renvoie:\n * string: Un ID divin formé en inversant chaque autre caractère de la deuxième \n *         chaîne et en le combinant avec la première chaîne.\n * Exemple d'utilisation:\n *   createId('fish','cat') // returns 'ftiasch'\n *   createId('icpc','acm') // returns 'imccpac'\n */\nfunction createId(word1, word2)",
      "de": "/**\n * Erstellt eine ID, indem zwei Zeichenfolgen auf eine bestimmte Weise kombiniert werden.\n * Parameter:\n * - word1 (string): Die erste Zeichenfolge, die in der ID verwendet werden soll.\n * - word2 (string): Die zweite Zeichenfolge, die in der ID verwendet werden soll.\n * Rückgabe:\n * string: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe der zweiten \n *         Zeichenfolge umgekehrt und mit der ersten Zeichenfolge kombiniert wird.\n * Beispielverwendung:\n *   createId('fish','cat') // gibt 'ftiasch' zurück\n *   createId('icpc','acm') // gibt 'imccpac' zurück\n */\nfunction createId(word1, word2)",
      "ha": "/**\n * Yana ƙirƙirar ID ta hanyar haɗa kirtani biyu a cikin wata hanya ta musamman.\n * Sigogi:\n * - word1 (string): Kirtani na farko da za a yi amfani da shi a cikin ID.\n * - word2 (string): Kirtani na biyu da za a yi amfani da shi a cikin ID.\n * Yana dawowa:\n * string: Wani ID mai ban mamaki da aka samar ta hanyar juyar da kowanne harafi na biyu na kirtani na biyu \n *         da haɗa shi da kirtani na farko.\n * Misalin amfani:\n *   createId('fish','cat') // yana dawowa 'ftiasch'\n *   createId('icpc','acm') // yana dawowa 'imccpac'\n */\nfunction createId(word1, word2)",
      "hi": "/**\n * दो स्ट्रिंग्स को एक विशिष्ट तरीके से जोड़कर एक आईडी बनाता है।\n * पैरामीटर्स:\n * - word1 (string): आईडी में उपयोग की जाने वाली पहली स्ट्रिंग।\n * - word2 (string): आईडी में उपयोग की जाने वाली दूसरी स्ट्रिंग।\n * रिटर्न करता है:\n * string: एक दिव्य आईडी जो दूसरी स्ट्रिंग के हर दूसरे अक्षर को उलटकर \n *         और इसे पहली स्ट्रिंग के साथ जोड़कर बनती है।\n * उदाहरण उपयोग:\n *   createId('fish','cat') // 'ftiasch' लौटाता है\n *   createId('icpc','acm') // 'imccpac' लौटाता है\n */\nfunction createId(word1, word2)",
      "hu": "/**\n * Létrehoz egy azonosítót két sztring speciális módon történő kombinálásával.\n * Paraméterek:\n * - word1 (string): Az első sztring, amelyet az azonosítóban használunk.\n * - word2 (string): A második sztring, amelyet az azonosítóban használunk.\n * Visszatér:\n * string: Egy isteni azonosító, amelyet a második sztring minden második \n *         karakterének megfordításával és az első sztringgel való kombinálásával hozunk létre.\n * Példa használat:\n *   createId('fish','cat') // visszaadja 'ftiasch'\n *   createId('icpc','acm') // visszaadja 'imccpac'\n */\nfunction createId(word1, word2)"
    },
    "prompt_bertscore": {
      "sq": "0.9967585508118917",
      "hy": "0.9900776179457832",
      "bn": "0.9677382548819324",
      "bg": "0.995035233626033",
      "zh": "0.9627468720369067",
      "fr": "0.9891573633904486",
      "de": "0.9905080499814858",
      "ha": "0.9775237806036162",
      "hi": "0.9771048691300136",
      "hu": "0.9559785418031429"
    },
    "canonical_solution": "{\n    let id = '';\n    for (let i = 0, k = 0, j = word2.length - 1; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            id += word1.charAt(k++); // Take character from word1\n        } else {\n            id += word2.charAt(j--); // Take character from word2 in reverse\n        }\n    }\n    return id;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function createId(word1, word2)` to solve the following problem:\nCreates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\nExample usage:\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'\n",
      "sq": "Shkruani një funksion JavaScript `function createId(word1, word2)` për të zgjidhur problemin e mëposhtëm:\nKrijon një ID duke kombinuar dy vargje në një mënyrë specifike.\nParametrat:\n- word1 (string): Vargu i parë që do të përdoret në ID.\n- word2 (string): Vargu i dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke kthyer mbrapsht çdo karakter tjetër të vargut të dytë dhe duke e kombinuar me vargun e parë.\nShembull përdorimi:\n  createId('fish','cat') // kthen 'ftiasch'\n  createId('icpc','acm') // kthen 'imccpac'",
      "hy": "Գրեք JavaScript ֆունկցիա `function createId(word1, word2)` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է ID՝ երկու տողերը հատուկ ձևով համադրելով:\nՊարամետրեր:\n- word1 (string): Առաջին տողը, որը օգտագործվելու է ID-ում:\n- word2 (string): Երկրորդ տողը, որը օգտագործվելու է ID-ում:\nՎերադարձնում է:\nstring: Աստվածային ID, որը ձևավորվում է երկրորդ տողի յուրաքանչյուր երկրորդ սիմվոլը շրջելով և այն առաջին տողի հետ համադրելով:\nՕրինակ օգտագործում:\n  createId('fish','cat') // վերադարձնում է 'ftiasch'\n  createId('icpc','acm') // վերադարձնում է 'imccpac'",
      "bn": "একটি JavaScript ফাংশন `function createId(word1, word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি স্ট্রিংকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (string): আইডিতে ব্যবহৃত প্রথম স্ট্রিং।\n- word2 (string): আইডিতে ব্যবহৃত দ্বিতীয় স্ট্রিং।\nরিটার্ন করে:\nstring: দ্বিতীয় স্ট্রিংয়ের প্রতিটি বিকল্প অক্ষর উল্টে দিয়ে এবং প্রথম স্ট্রিংয়ের সাথে একত্রিত করে একটি অনন্য আইডি তৈরি করে।\nউদাহরণ ব্যবহার:\n  createId('fish','cat') // 'ftiasch' রিটার্ন করে\n  createId('icpc','acm') // 'imccpac' রিটার্ন করে",
      "bg": "Напишете функция на JavaScript `function createId(word1, word2)` за решаване на следния проблем:\nСъздава ID, като комбинира два низа по специфичен начин.\nПараметри:\n- word1 (string): Първият низ, който ще бъде използван в ID.\n- word2 (string): Вторият низ, който ще бъде използван в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ на втория низ и комбинирането му с първия низ.\nПример за използване:\n  createId('fish','cat') // връща 'ftiasch'\n  createId('icpc','acm') // връща 'imccpac'",
      "zh": "编写一个 JavaScript 函数 `function createId(word1, word2)` 来解决以下问题：\n通过以特定方式组合两个字符串来创建一个 ID。\n参数：\n- word1 (string): 用于 ID 的第一个字符串。\n- word2 (string): 用于 ID 的第二个字符串。\n返回：\nstring: 一个神圣的 ID，通过反转第二个字符串的每隔一个字符并将其与第一个字符串组合而成。\n示例用法：\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'",
      "fr": "Écrire une fonction JavaScript `function createId(word1, word2)` pour résoudre le problème suivant :\nCrée un identifiant en combinant deux chaînes d'une manière spécifique.\nParamètres :\n- word1 (string) : La première chaîne à utiliser dans l'identifiant.\n- word2 (string) : La deuxième chaîne à utiliser dans l'identifiant.\nRenvoie :\nstring : Un identifiant divin formé en inversant chaque autre caractère de la deuxième chaîne et en le combinant avec la première chaîne.\nExemple d'utilisation :\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'",
      "de": "Schreiben Sie eine JavaScript-Funktion `function createId(word1, word2)`, um das folgende Problem zu lösen:\nErstellt eine ID, indem zwei Zeichenfolgen auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Die erste Zeichenfolge, die in der ID verwendet werden soll.\n- word2 (string): Die zweite Zeichenfolge, die in der ID verwendet werden soll.\nGibt zurück:\nstring: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe der zweiten Zeichenfolge umgekehrt und mit der ersten Zeichenfolge kombiniert wird.\nBeispielverwendung:\n  createId('fish','cat') // gibt 'ftiasch' zurück\n  createId('icpc','acm') // gibt 'imccpac' zurück",
      "ha": "Rubuta wani aikin JavaScript `function createId(word1, word2)` don magance matsalar mai zuwa:\nYana ƙirƙirar ID ta hanyar haɗa kirtani biyu a cikin wata hanya ta musamman.\nSigogi:\n- word1 (string): Kirtani na farko da za a yi amfani da shi a cikin ID.\n- word2 (string): Kirtani na biyu da za a yi amfani da shi a cikin ID.\nYana dawowa:\nstring: Wani ID mai ban mamaki da aka kafa ta hanyar juyar da kowanne harafi na biyu na kirtani na biyu da haɗa shi da kirtani na farko.\nMisalin amfani:\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'",
      "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function createId(word1, word2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो स्ट्रिंग्स को एक विशिष्ट तरीके से मिलाकर एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (string): आईडी में उपयोग की जाने वाली पहली स्ट्रिंग।\n- word2 (string): आईडी में उपयोग की जाने वाली दूसरी स्ट्रिंग।\nरिटर्न करता है:\nstring: एक दिव्य आईडी जो दूसरी स्ट्रिंग के हर दूसरे अक्षर को उलटकर और इसे पहली स्ट्रिंग के साथ मिलाकर बनाई जाती है।\nउदाहरण उपयोग:\n  createId('fish','cat') // 'ftiasch' लौटाता है\n  createId('icpc','acm') // 'imccpac' लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function createId(word1, word2)` a következő probléma megoldására:\nLétrehoz egy azonosítót két string speciális módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első string, amelyet az azonosítóban használunk.\n- word2 (string): A második string, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amely a második string minden második karakterének megfordításával és az első stringgel való kombinálásával jön létre.\nPélda használat:\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'"
    },
    "instruction_bertscore": {
      "sq": "0.9969551948891162",
      "hy": "0.9917552501440039",
      "bn": "0.965037477591001",
      "bg": "0.9952279050956369",
      "zh": "0.9656244303669591",
      "fr": "0.9715658623244747",
      "de": "0.9907736188009294",
      "ha": "0.9714881978454901",
      "hi": "0.9884897666797903",
      "hu": "0.9569623580804087"
    },
    "level": "easy",
    "test": "function testCreateId() {\n    // console.log(createId(\"fish\", \"cat\"))\n    console.assert(createId(\"fish\", \"cat\") === \"ftiasch\", 'Test failed: createId(\"fish\", \"cat\") should be \"ftiasch\"');\n    console.assert(createId(\"icpc\", \"acm\") === \"imccpac\", 'Test failed: createId(\"icpc\", \"acm\") should be \"imccpac\"');\n    console.assert(createId(\"oo\", \"w\") === \"owo\", 'Test failed: createId(\"oo\", \"w\") should be \"owo\"');\n    console.assert(createId(\"hello\", \"world\") === \"hdellrloow\", 'Test failed: createId(\"hello\", \"world\") should be \"hdellrloow\"');\n    console.assert(createId(\"abc\", \"def\") === \"afbecd\", 'Test failed: createId(\"abc\", \"def\") should be \"afbecd\"');\n    console.assert(createId(\"buaanb\", \"nbbuaa\") === \"bauaauabnbbn\", 'Test failed: createId(\"buaanb\", \"nbbuaa\") should be \"bauaauabnbbn\"');\n    console.assert(createId(\"xtuisgood\", \"ilovextu\") === \"xuttuxiesvgooloid\", 'Test failed: createId(\"xtuisgood\", \"ilovextu\") should be \"xuttuxiesvgooloid\"');\n}\n\ntestCreateId();",
    "entry_point": "createId",
    "signature": "function createId(word1, word2)",
    "docstring": {
      "en": "Creates an ID by combining two strings in a specific manner.\nParameters:\n- word1 (string): The first string to be used in the ID.\n- word2 (string): The second string to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second string and combining it with the first string.\nExample usage:\n  createId('fish','cat') // returns 'ftiasch'\n  createId('icpc','acm') // returns 'imccpac'\n",
      "sq": "Krijon një ID duke kombinuar dy vargje në një mënyrë specifike.\nParametrat:\n- word1 (string): Vargu i parë që do të përdoret në ID.\n- word2 (string): Vargu i dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të vargut të dytë dhe duke e kombinuar atë me vargun e parë.\nShembull përdorimi:\n  createId('fish','cat') // kthen 'ftiasch'\n  createId('icpc','acm') // kthen 'imccpac'",
      "hy": "Ստեղծում է ID՝ երկու տողերը հատուկ ձևով համադրելով։  \nՊարամետրեր:  \n- word1 (string): Առաջին տողը, որը կօգտագործվի ID-ում։  \n- word2 (string): Երկրորդ տողը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nstring: Աստվածային ID, որը ձևավորվում է երկրորդ տողի յուրաքանչյուր երկրորդ նիշը շրջելով և այն առաջին տողի հետ համադրելով։  \nՕրինակ օգտագործում:  \n  createId('fish','cat') // վերադարձնում է 'ftiasch'  \n  createId('icpc','acm') // վերադարձնում է 'imccpac'  ",
      "bn": "দুটি স্ট্রিংকে একটি নির্দিষ্ট পদ্ধতিতে একত্রিত করে একটি আইডি তৈরি করে।  \nপ্যারামিটারসমূহ:  \n- word1 (string): ID তৈরিতে ব্যবহৃত প্রথম স্ট্রিং।  \n- word2 (string): ID তৈরিতে ব্যবহৃত দ্বিতীয় স্ট্রিং।  \nরিটার্নস:  \nstring: একটি অনন্য ID যা দ্বিতীয় স্ট্রিংয়ের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম স্ট্রিংয়ের সাথে মিলিয়ে তৈরি হয়।  \nব্যবহারের উদাহরণ:  \n  createId('fish','cat') // returns 'ftiasch'  \n  createId('icpc','acm') // returns 'imccpac'  ",
      "bg": "Създава ID, като комбинира два низа по специфичен начин.\nПараметри:\n- word1 (string): Първият низ, който ще се използва в ID.\n- word2 (string): Вторият низ, който ще се използва в ID.\nВръща:\nstring: Божествен ID, образуван чрез обръщане на всеки втори символ от втория низ и комбинирането му с първия низ.\nПример за използване:\n  createId('fish','cat') // връща 'ftiasch'\n  createId('icpc','acm') // връща 'imccpac'",
      "zh": "通过以特定方式组合两个字符串来创建一个ID。\n\n参数:\n- word1 (string): 用于ID的第一个字符串。\n- word2 (string): 用于ID的第二个字符串。\n\n返回:\nstring: 一个神奇的ID，通过反转第二个字符串的每隔一个字符并将其与第一个字符串组合而成。\n\n示例用法:\n  createId('fish','cat') // 返回 'ftiasch'\n  createId('icpc','acm') // 返回 'imccpac'",
      "fr": "Crée un ID en combinant deux chaînes de manière spécifique.\nParamètres :\n- word1 (string): La première chaîne à utiliser dans l'ID.\n- word2 (string): La deuxième chaîne à utiliser dans l'ID.\nRenvoie :\nstring: Un ID divin formé en inversant chaque autre caractère de la deuxième chaîne et en le combinant avec la première chaîne.\nExemple d'utilisation :\n  createId('fish','cat') // renvoie 'ftiasch'\n  createId('icpc','acm') // renvoie 'imccpac'",
      "de": "Erstellt eine ID, indem zwei Zeichenfolgen auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Die erste Zeichenfolge, die in der ID verwendet wird.\n- word2 (string): Die zweite Zeichenfolge, die in der ID verwendet wird.\nRückgabewert:\nstring: Eine göttliche ID, die durch das Umkehren jedes zweiten Zeichens der zweiten Zeichenfolge gebildet und mit der ersten Zeichenfolge kombiniert wird.\nBeispielverwendung:\n  createId('fish','cat') // gibt 'ftiasch' zurück\n  createId('icpc','acm') // gibt 'imccpac' zurück",
      "ha": "Yana ƙirƙirar ID ta hanyar haɗa kirtani biyu a cikin wata hanya ta musamman.  \nSigogi:  \n- word1 (string): Kalmomin farko da za a yi amfani da su a cikin ID.  \n- word2 (string): Kalmomin na biyu da za a yi amfani da su a cikin ID.  \nDawowa:  \nstring: Wani ID mai ban mamaki da aka samar ta hanyar juyar da kowanne harafi na biyu na kalmomin na biyu sannan a haɗa shi da kalmomin farko.  \nMisalin amfani:  \n  createId('fish','cat') // returns 'ftiasch'  \n  createId('icpc','acm') // returns 'imccpac'  ",
      "hi": "दो स्ट्रिंग्स को एक विशिष्ट तरीके से जोड़कर एक आईडी बनाता है।  \nमापदंड:  \n- word1 (string): ID में उपयोग के लिए पहला स्ट्रिंग।  \n- word2 (string): ID में उपयोग के लिए दूसरा स्ट्रिंग।  \nवापसी:  \nstring: एक दिव्य ID जो दूसरे स्ट्रिंग के हर दूसरे अक्षर को उलट कर और पहले स्ट्रिंग के साथ जोड़ कर बनाई जाती है।  \nउदाहरण उपयोग:  \n  createId('fish','cat') // 'ftiasch' लौटाता है  \n  createId('icpc','acm') // 'imccpac' लौटाता है  ",
      "hu": "Létrehoz egy azonosítót két karakterlánc speciális módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első karakterlánc, amelyet az azonosítóban használunk.\n- word2 (string): A második karakterlánc, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amelyet a második karakterlánc minden második karakterének megfordításával és az első karakterlánccal való kombinálásával hozunk létre.\nPélda használat:\n  createId('fish','cat') // visszatér 'ftiasch'\n  createId('icpc','acm') // visszatér 'imccpac'"
    },
    "docstring_bertscore": {
      "sq": "0.9985722448211212",
      "hy": "0.9846272002901859",
      "bn": "0.9394141584375004",
      "bg": "0.9942760683097176",
      "zh": "0.9508888369195049",
      "fr": "0.9797911464031295",
      "de": "0.9664147806530969",
      "ha": "0.957704043923193",
      "hi": "0.9643855726804446",
      "hu": "0.959969820679658"
    }
  },
  {
    "task_id": "JavaScript/19",
    "prompt": {
      "en": "/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n *\n * @param {number} n - Length of the binary string.\n * @param {number} m - Number of '1's in the binary string.\n *\n * @returns {number} The total number of different permutation schemes.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "sq": "/**\n * Numëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\n * ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n *\n * @param {number} n - Gjatësia e vargut binar.\n * @param {number} m - Numri i '1'-ve në vargun binar.\n *\n * @returns {number} Numri total i skemave të ndryshme të permutimit.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "hy": "/**\n * Հաշվել տարբեր տեղաշարժման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\n * որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է:\n *\n * @param {number} n - Երկբայական տողի երկարությունը:\n * @param {number} m - '1'-երի քանակը երկբայական տողի մեջ:\n *\n * @returns {number} Տարբեր տեղաշարժման սխեմաների ընդհանուր քանակը:\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "bn": "/**\n * একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\n * যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n *\n * @param {number} n - বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n * @param {number} m - বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n *\n * @returns {number} বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "bg": "/**\n * Пребройте броя на различните схеми на пермутации за двоична низ с дължина n,\n * където броят на '1'-ците е m, а броят на '0'-ците е n - m.\n *\n * @param {number} n - Дължина на двоичната низ.\n * @param {number} m - Брой на '1'-ците в двоичната низ.\n *\n * @returns {number} Общият брой на различните схеми на пермутации.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "zh": "/**\n * 计算长度为 n 的二进制字符串的不同排列方案数量，\n * 其中 '1' 的数量为 m，'0' 的数量为 n - m。\n *\n * @param {number} n - 二进制字符串的长度。\n * @param {number} m - 二进制字符串中 '1' 的数量。\n *\n * @returns {number} 不同排列方案的总数量。\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "fr": "/**\n * Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\n * où le nombre de '1' est m et le nombre de '0' est n - m.\n *\n * @param {number} n - Longueur de la chaîne binaire.\n * @param {number} m - Nombre de '1' dans la chaîne binaire.\n *\n * @returns {number} Le nombre total de différents schémas de permutation.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "de": "/**\n * Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\n * wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n *\n * @param {number} n - Länge des Binärstrings.\n * @param {number} m - Anzahl der '1's im Binärstring.\n *\n * @returns {number} Die Gesamtanzahl der verschiedenen Permutationsschemata.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "ha": "/**\n * Ƙididdige yawan tsarin permutation daban-daban don igiyar binary mai tsawon n,\n * inda adadin '1's shine m kuma adadin '0's shine n - m.\n *\n * @param {number} n - Tsawon igiyar binary.\n * @param {number} m - Adadin '1's a cikin igiyar binary.\n *\n * @returns {number} Jimillar yawan tsarin permutation daban-daban.\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "hi": "/**\n * एक बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें,\n * जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n *\n * @param {number} n - बाइनरी स्ट्रिंग की लंबाई।\n * @param {number} m - बाइनरी स्ट्रिंग में '1's की संख्या।\n *\n * @returns {number} विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n */\nfunction countPermutationsOfBinaryString(n, m)",
      "hu": "/**\n * Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\n * ahol az '1'-ek száma m, és a '0'-ék száma n - m.\n *\n * @param {number} n - A bináris karakterlánc hossza.\n * @param {number} m - Az '1'-ek száma a bináris karakterláncban.\n *\n * @returns {number} A különböző permutációs sémák összesített száma.\n */\nfunction countPermutationsOfBinaryString(n, m)"
    },
    "prompt_bertscore": {
      "sq": "0.9869628949407752",
      "hy": "0.9832886301523918",
      "bn": "0.9870727375414874",
      "bg": "0.9963896941943099",
      "zh": "0.9716300199375489",
      "fr": "0.9884154789172832",
      "de": "1",
      "ha": "0.9735708373906409",
      "hi": "0.9927736281075697",
      "hu": "0.9880021290943497"
    },
    "canonical_solution": "{\n    let factorial = 1;\n    let i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    // Check for edge cases\n    if ((n + m) % 2 === 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countPermutationsOfBinaryString(n, m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.",
      "sq": "Shkruani një funksion JavaScript `function countPermutationsOfBinaryString(n, m)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n@param {number} n - Gjatësia e vargut binar.\n@param {number} m - Numri i '1'-ve në vargun binar.\n\nKthen:\n@returns {number} Numri total i skemave të ndryshme të permutimit.",
      "hy": "Գրեք JavaScript ֆունկցիա `function countPermutationsOfBinaryString(n, m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տարբեր տեղաբաշխման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n@param {number} n - Երկբայնային տողի երկարությունը։\n@param {number} m - '1'-երի քանակը երկբայնային տողում։\n\nՎերադարձնում է:\n@returns {number} Տարբեր տեղաբաշխման սխեմաների ընդհանուր քանակը։",
      "bn": "একটি JavaScript ফাংশন `function countPermutationsOfBinaryString(n, m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি স্ট্রিংয়ের বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n@param {number} n - বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n@param {number} m - বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n@returns {number} বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Напишете JavaScript функция `function countPermutationsOfBinaryString(n, m)` за решаване на следния проблем:\nПребройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ите е n - m.\n\nПараметри:\n@param {number} n - Дължина на двоичния низ.\n@param {number} m - Брой на '1'-ците в двоичния низ.\n\nВръща:\n@returns {number} Общият брой на различните схеми на пермутации.",
      "zh": "编写一个 JavaScript 函数 `function countPermutationsOfBinaryString(n, m)` 来解决以下问题：\n计算长度为 n 的二进制字符串中，不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n@param {number} n - 二进制字符串的长度。\n@param {number} m - 二进制字符串中 '1' 的数量。\n\n返回：\n@returns {number} 不同排列方案的总数。",
      "fr": "Écrire une fonction JavaScript `function countPermutationsOfBinaryString(n, m)` pour résoudre le problème suivant :\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n@param {number} n - Longueur de la chaîne binaire.\n@param {number} m - Nombre de '1' dans la chaîne binaire.\n\nRetourne :\n@returns {number} Le nombre total de différents schémas de permutation.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function countPermutationsOfBinaryString(n, m)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m und die Anzahl der '0's n - m ist.\n\nParameter:\n@param {number} n - Länge des Binärstrings.\n@param {number} m - Anzahl der '1's im Binärstring.\n\nRückgabe:\n@returns {number} Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Rubuta aikin JavaScript `function countPermutationsOfBinaryString(n, m)` don warware matsalar mai zuwa:  \nƘididdige adadin tsarin permutation daban-daban don igiyar binary mai tsawon n, inda adadin '1's shine m kuma adadin '0's shine n - m.\n\nSigogi:\n@param {number} n - Tsawon igiyar binary.\n@param {number} m - Adadin '1's a cikin igiyar binary.\n\nDawowa:\n@returns {number} Jimillar adadin tsarin permutation daban-daban.",
      "hi": "JavaScript फ़ंक्शन `function countPermutationsOfBinaryString(n, m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n की एक बाइनरी स्ट्रिंग के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n@param {number} n - बाइनरी स्ट्रिंग की लंबाई।\n@param {number} m - बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\n@returns {number} विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Írj egy JavaScript függvényt `function countPermutationsOfBinaryString(n, m)` a következő probléma megoldására:\nSzámold meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m és a '0'-k száma n - m.\n\nParaméterek:\n@param {number} n - A bináris karakterlánc hossza.\n@param {number} m - Az '1'-ek száma a bináris karakterláncban.\n\nVisszatérési érték:\n@returns {number} A különböző permutációs sémák teljes száma."
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.977295355665426",
      "bn": "0.9641907162766493",
      "bg": "1",
      "zh": "0.965987526703491",
      "fr": "0.9889297329737826",
      "de": "0.9877047794139404",
      "ha": "0.986763271407835",
      "hi": "0.9793529677825665",
      "hu": "0.9879874304461531"
    },
    "level": "hard",
    "test": "function testCountPermutationsOfBinaryString() {\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2);\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3);\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0);\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675);\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4);\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1);\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156);\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1);\n    // Add more test cases if necessary\n}\n\ntestCountPermutationsOfBinaryString();",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "function countPermutationsOfBinaryString(n, m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n@param {number} n - Length of the binary string.\n@param {number} m - Number of '1's in the binary string.\n\nReturns:\n@returns {number} The total number of different permutation schemes.",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n@param {number} n - Gjatësia e vargut binar.\n@param {number} m - Numri i '1'-ve në vargun binar.\n\nKthen:\n@returns {number} Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր փոխարկման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n@param {number} n - Երկբայնային տողի երկարությունը։\n@param {number} m - '1'-երի քանակը երկբայնային տողի մեջ։\n\nՎերադարձնում է:\n@returns {number} Տարբեր փոխարկման սխեմաների ընդհանուր քանակը։",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটার:\n@param {number} n - বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n@param {number} m - বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\n@returns {number} বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоична верига с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n@param {number} n - Дължина на двоичната верига.\n@param {number} m - Брой на '1'-ците в двоичната верига.\n\nВръща:\n@returns {number} Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n@param {number} n - 二进制字符串的长度。\n@param {number} m - 二进制字符串中 '1' 的数量。\n\n返回：\n@returns {number} 不同排列方案的总数量。",
      "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres:\n@param {number} n - Longueur de la chaîne binaire.\n@param {number} m - Nombre de '1' dans la chaîne binaire.\n\nRenvoie:\n@returns {number} Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n@param {number} n - Länge des Binärstrings.\n@param {number} m - Anzahl der '1's im Binärstring.\n\nRückgabewert:\n@returns {number} Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙirga yawan tsarin permutation daban-daban don igiyar binary mai tsawon n, inda adadin '1's shi ne m kuma adadin '0's shi ne n - m.\n\nSigogi:\n@param {number} n - Tsawon igiyar binary.\n@param {number} m - Yawan '1's a cikin igiyar binary.\n\nKomawa:\n@returns {number} Jimillar yawan tsarin permutation daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n@param {number} n - बाइनरी स्ट्रिंग की लंबाई।\n@param {number} m - बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\n@returns {number} विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n@param {number} n - A bináris karakterlánc hossza.\n@param {number} m - Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\n@returns {number} A különböző permutációs sémák teljes száma."
    },
    "docstring_bertscore": {
      "sq": "0.9896338776745512",
      "hy": "0.9679196044198173",
      "bn": "0.9672390967343918",
      "bg": "1",
      "zh": "0.9648829431545559",
      "fr": "0.9861777090445442",
      "de": "0.9833404726818419",
      "ha": "0.976048354133289",
      "hi": "0.9809769697779077",
      "hu": "0.9815855732653986"
    }
  },
  {
    "task_id": "JavaScript/20",
    "prompt": {
      "en": "/**\n * Answer a series of questions by providing choices A, B, C, or D for each question.\n * Question 1:\n * Constants like 1e6 belong to which data type?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Question 2:\n * Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *     A. int\n *     B. long long\n *     C. double\n *     D. None of the above\n * Question 3:\n * Which statement about left values in expressions is incorrect?\n *     A. Variable name expressions are left values.\n *     B. Increment operation requires the operand to be a left value.\n *     C. Pointer dereference expressions are left values.\n *     D. Prefix increment operation expressions are left values.\n * Question 4:\n * Which statement about functions is incorrect?\n *     A. Formal parameters of a function are local variables.\n *     B. Local variables are allocated space in the stack.\n *     C. The function type is the same as the return value type.\n *     D. A function can call itself from within its body.\n * Question 5:\n * Which statement about pointers is incorrect?\n *     A. Subtracting two pointers equals the difference in their address values.\n *     B. Pointer dereference involves resolving based on the pointer's type.\n *     C. int *p[4], p is an array of int pointers.\n *     D. Function names can be assigned to function pointers.\n *     >>> answer_questions()\n *     AAAAA\n * You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nfunction answer_questions()",
      "sq": "/**\n * Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n * Pyetja 1:\n * Konstantet si 1e6 i përkasin cilit tip të dhënash?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Pyetja 2:\n * Duke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Asnjë nga të mësipërmet\n * Pyetja 3:\n * Cila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n *     A. Shprehjet e emrave të variablave janë vlera të majta.\n *     B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n *     C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n *     D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n * Pyetja 4:\n * Cila deklaratë rreth funksioneve është e pasaktë?\n *     A. Parametrat formalë të një funksioni janë variabla lokale.\n *     B. Variablat lokale kanë hapësirë të caktuar në stack.\n *     C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n *     D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\n * Pyetja 5:\n * Cila deklaratë rreth treguesve është e pasaktë?\n *     A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n *     B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n *     C. int *p[4], p është një varg i treguesve int.\n *     D. Emrat e funksioneve mund të caktohen në treguesit e funksioneve.\n *     >>> answer_questions()\n *     AAAAA\n * Duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n */\nfunction answer_questions()",
      "hy": "/**\n * Պատասխանեք հարցերի շարքին՝ տրամադրելով A, B, C կամ D ընտրանքներից յուրաքանչյուր հարցի համար:\n * Հարց 1:\n * 1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Հարց 2:\n * Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Վերը նշվածներից ոչ մեկը\n * Հարց 3:\n * Որ արտահայտությունը ձախ արժեքների մասին սխալ է?\n *     A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n *     B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *     C. Ցուցիչի դերեֆերենսի արտահայտությունները ձախ արժեքներ են:\n *     D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n * Հարց 4:\n * Որ արտահայտությունը ֆունկցիաների մասին սխալ է?\n *     A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *     B. Տեղական փոփոխականների համար տարածք է հատկացվում ստեկում:\n *     C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *     D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n * Հարց 5:\n * Որ արտահայտությունը ցուցիչների մասին սխալ է?\n *     A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *     B. Ցուցիչի դերեֆերենսը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *     C. int *p[4], p-ն int ցուցիչների զանգված է:\n *     D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n *     >>> answer_questions()\n *     AAAAA\n * Դուք պետք է վերադարձնեք միայն \"AAAAA\"-ի նման տողեր, որոնք ներկայացնում են հարցերի ընտրանքները:\n */\nfunction answer_questions()",
      "bn": "/**\n * প্রতিটি প্রশ্নের জন্য পছন্দসমূহ A, B, C, বা D প্রদান করে প্রশ্নগুলির উত্তর দিন।\n * প্রশ্ন ১:\n * 1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * প্রশ্ন ২:\n * 21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *     A. int\n *     B. long long\n *     C. double\n *     D. উপরোক্ত কোনোটিই নয়\n * প্রশ্ন ৩:\n * এক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n *     A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *     B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *     C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *     D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n * প্রশ্ন ৪:\n * ফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n *     A. ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *     B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ পায়।\n *     C. ফাংশন টাইপ এবং রিটার্ন ভ্যালু টাইপ একই।\n *     D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n * প্রশ্ন ৫:\n * পয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n *     A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n *     B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n *     C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n *     D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n *     >>> answer_questions()\n *     AAAAA\n * আপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।\n */\nfunction answer_questions()",
      "bg": "/**\n * Отговорете на поредица от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n * Въпрос 1:\n * Константи като 1e6 принадлежат към кой тип данни?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Въпрос 2:\n * Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Нито едно от горните\n * Въпрос 3:\n * Кое твърдение за левите стойности в изразите е неправилно?\n *     A. Изразите с имена на променливи са леви стойности.\n *     B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n *     C. Изразите за дереференция на указател са леви стойности.\n *     D. Изразите за префиксно инкрементиране са леви стойности.\n * Въпрос 4:\n * Кое твърдение за функциите е неправилно?\n *     A. Формалните параметри на функцията са локални променливи.\n *     B. Локалните променливи са разпределени в стека.\n *     C. Типът на функцията е същият като типа на стойността на връщане.\n *     D. Функцията може да извика сама себе си в тялото си.\n * Въпрос 5:\n * Кое твърдение за указателите е неправилно?\n *     A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n *     B. Дереференцията на указател включва разрешаване въз основа на типа на указателя.\n *     C. int *p[4], p е масив от указатели към int.\n *     D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n *     >>> answer_questions()\n *     AAAAA\n * Трябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n */\nfunction answer_questions()",
      "zh": "/**\n * 通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n * 问题 1:\n * 常量如 1e6 属于哪种数据类型？\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * 问题 2:\n * 给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *     A. int\n *     B. long long\n *     C. double\n *     D. 以上都不是\n * 问题 3:\n * 关于表达式中的左值，哪个说法是不正确的？\n *     A. 变量名表达式是左值。\n *     B. 增量操作要求操作数是左值。\n *     C. 指针解引用表达式是左值。\n *     D. 前缀增量操作表达式是左值。\n * 问题 4:\n * 关于函数，哪个说法是不正确的？\n *     A. 函数的形式参数是局部变量。\n *     B. 局部变量在栈中分配空间。\n *     C. 函数类型与返回值类型相同。\n *     D. 函数可以在其主体内调用自身。\n * 问题 5:\n * 关于指针，哪个说法是不正确的？\n *     A. 两个指针相减等于它们地址值的差。\n *     B. 指针解引用涉及基于指针的类型进行解析。\n *     C. int *p[4], p 是一个 int 指针数组。\n *     D. 函数名可以赋值给函数指针。\n *     >>> answer_questions()\n *     AAAAA\n * 你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。\n */",
      "fr": "/**\n * Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n * Question 1 :\n * Les constantes comme 1e6 appartiennent à quel type de données ?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Question 2 :\n * Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Aucun des précédents\n * Question 3 :\n * Quelle affirmation sur les valeurs à gauche dans les expressions est incorrecte ?\n *     A. Les expressions de noms de variables sont des valeurs à gauche.\n *     B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n *     C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *     D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n * Question 4 :\n * Quelle affirmation sur les fonctions est incorrecte ?\n *     A. Les paramètres formels d'une fonction sont des variables locales.\n *     B. Les variables locales sont allouées dans la pile.\n *     C. Le type de la fonction est le même que le type de la valeur de retour.\n *     D. Une fonction peut s'appeler elle-même depuis son corps.\n * Question 5 :\n * Quelle affirmation sur les pointeurs est incorrecte ?\n *     A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *     B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *     C. int *p[4], p est un tableau de pointeurs int.\n *     D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n *     >>> answer_questions()\n *     AAAAA\n * Vous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n */\nfunction answer_questions()",
      "de": "/**\n * Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n * Frage 1:\n * Konstanten wie 1e6 gehören zu welchem Datentyp?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Frage 2:\n * Angenommen 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Keine der oben genannten\n * Frage 3:\n * Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *     A. Variablennamenausdrücke sind linke Werte.\n *     B. Der Inkrementoperator erfordert, dass der Operand ein linker Wert ist.\n *     C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n *     D. Präfix-Inkrement-Ausdrucksoperationen sind linke Werte.\n * Frage 4:\n * Welche Aussage über Funktionen ist falsch?\n *     A. Formale Parameter einer Funktion sind lokale Variablen.\n *     B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n *     C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *     D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n * Frage 5:\n * Welche Aussage über Zeiger ist falsch?\n *     A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n *     B. Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n *     C. int *p[4], p ist ein Array von int-Zeigern.\n *     D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n *     >>> answer_questions()\n *     AAAAA\n * Sie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nfunction answer_questions()",
      "ha": "/**\n * Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n * Tambaya ta 1:\n * Constants kamar 1e6 suna cikin wane nau'in bayanai?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * Tambaya ta 2:\n * An ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Babu ɗaya daga cikin waɗannan\n * Tambaya ta 3:\n * Wane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n *     A. Bayanan sunan canji suna da ƙimar hagu.\n *     B. Aikin ƙara yana buƙatar operand ya zama ƙimar hagu.\n *     C. Bayanan cire adireshin suna da ƙimar hagu.\n *     D. Bayanan aikin ƙara na farko suna da ƙimar hagu.\n * Tambaya ta 4:\n * Wane bayani game da ayyuka ba daidai ba ne?\n *     A. Sigogin tsari na aiki suna da canje-canje na gida.\n *     B. Canje-canje na gida suna samun sarari a cikin tari.\n *     C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n *     D. Aiki na iya kiran kansa daga cikin jikinsa.\n * Tambaya ta 5:\n * Wane bayani game da nuni ba daidai ba ne?\n *     A. Cire nuni biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n *     B. Cire adireshi yana buƙatar warwarewa bisa nau'in nuni.\n *     C. int *p[4], p tsari ne na nuni na int.\n *     D. Ana iya sanya sunayen ayyuka ga nuni na aiki.\n *     >>> answer_questions()\n *     AAAAA\n * Ana buƙatar ka dawo da kirtani irin \"AAAAA\" kawai, wanda ke wakiltar zaɓuɓɓukan tambayar.\n */\nfunction answer_questions()",
      "hi": "/**\n * प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n * प्रश्न 1:\n * 1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * प्रश्न 2:\n * दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n *     A. int\n *     B. long long\n *     C. double\n *     D. उपरोक्त में से कोई नहीं\n * प्रश्न 3:\n * अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *     A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *     B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *     C. पॉइंटर डीरिफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *     D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n * प्रश्न 4:\n * कार्यों के बारे में कौन सा कथन गलत है?\n *     A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n *     B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n *     C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n *     D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n * प्रश्न 5:\n * पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *     A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n *     B. पॉइंटर डीरिफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *     C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n *     D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n *     >>> answer_questions()\n *     AAAAA\n * आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने की आवश्यकता है, जो प्रश्न के विकल्पों के लिए खड़े हैं।\n */\nfunction answer_questions()",
      "hu": "/**\n * Válaszolj egy sor kérdésre úgy, hogy A, B, C vagy D választ adsz minden kérdésre.\n * 1. kérdés:\n * Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *     A. unsigned int\n *     B. int\n *     C. float\n *     D. double\n * 2. kérdés:\n * Tekintettel arra, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *     A. int\n *     B. long long\n *     C. double\n *     D. Egyik sem a fentiek közül\n * 3. kérdés:\n * Melyik állítás helytelen a baloldali értékekről a kifejezésekben?\n *     A. A változó név kifejezések baloldali értékek.\n *     B. Az inkrementálás művelet megköveteli, hogy az operandus baloldali érték legyen.\n *     C. A pointer dereferálás kifejezések baloldali értékek.\n *     D. A prefix inkrementálás művelet kifejezések baloldali értékek.\n * 4. kérdés:\n * Melyik állítás helytelen a függvényekről?\n *     A. A függvény formális paraméterei lokális változók.\n *     B. A lokális változók a veremben kapnak helyet.\n *     C. A függvény típusa megegyezik a visszatérési érték típusával.\n *     D. Egy függvény meghívhatja önmagát a törzsén belül.\n * 5. kérdés:\n * Melyik állítás helytelen a pointerekről?\n *     A. Két pointer kivonása az címértékeik különbségével egyenlő.\n *     B. A pointer dereferálás a pointer típusának megfelelően történik.\n *     C. int *p[4], p egy int pointerek tömbje.\n *     D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n *     >>> answer_questions()\n *     AAAAA\n * Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelentik.\n */\nfunction answer_questions()"
    },
    "prompt_bertscore": {
      "sq": "0.9624606456578354",
      "hy": "0.9418245381113588",
      "bn": "0.9506248571431095",
      "bg": "0.9471754419460577",
      "zh": "0.9502627539584829",
      "fr": "0.9574744272027167",
      "de": "0.9457232552303116",
      "ha": "0.922844213421189",
      "hi": "0.9510892549739691",
      "hu": "0.9249961749693211"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "Write a JavaScript function `function answer_questions()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Shkruani një funksion JavaScript `function answer_questions()` për të zgjidhur problemin e mëposhtëm:\nPërgjigjuni një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n>>> answer_questions()\nAAAAA\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.",
      "hy": "Գրեք JavaScript ֆունկցիա `function answer_questions()` հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ տրամադրելով A, B, C կամ D ընտրանքները յուրաքանչյուր հարցի համար:\nՀարց 1:\nՆման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձի արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n>>> answer_questions()\nAAAAA\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function answer_questions()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রশ্নমালার উত্তর দিন প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে।\nপ্রশ্ন ১:\n১e৬ এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন ২:\n২১! = ৫১,০৯০,৯৪২,১৭১,৭০৯,৪৪০,০০০ দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি বাম মান হতে হবে।\n    C. পয়েন্টার ডিরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডিরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n>>> answer_questions()\nAAAAA\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।",
      "bg": "Напишете JavaScript функция `function answer_questions()`, за да решите следния проблем:  \nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.  \nВъпрос 1:  \nКонстанти като 1e6 принадлежат към кой тип данни?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nВъпрос 2:  \nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Нито едно от горните  \nВъпрос 3:  \nКое твърдение за левите стойности в изразите е неправилно?  \n    A. Изразите с имена на променливи са леви стойности.  \n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.  \n    C. Изразите с дереференция на указатели са леви стойности.  \n    D. Изразите с префикс инкремент операция са леви стойности.  \nВъпрос 4:  \nКое твърдение за функциите е неправилно?  \n    A. Формалните параметри на функцията са локални променливи.  \n    B. Локалните променливи се разпределят в стека.  \n    C. Типът на функцията е същият като типа на връщаната стойност.  \n    D. Функцията може да извика себе си от тялото си.  \nВъпрос 5:  \nКое твърдение за указателите е неправилно?  \n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.  \n    B. Дереференцията на указател включва разрешаване на базата на типа на указателя.  \n    C. int *p[4], p е масив от указатели към int.  \n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.  \n>>> answer_questions()  \nAAAAA  \nТрябва да връщате само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.",
      "zh": "编写一个 JavaScript 函数 `function answer_questions()` 来解决以下问题：  \n通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n\n问题 1：  \n像 1e6 这样的常量属于哪种数据类型？  \nA. unsigned int  \nB. int  \nC. float  \nD. double  \n\n问题 2：  \n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？  \nA. int  \nB. long long  \nC. double  \nD. 以上都不是  \n\n问题 3：  \n关于表达式中的左值，哪个说法不正确？  \nA. 变量名表达式是左值。  \nB. 增量操作要求操作数是左值。  \nC. 指针解引用表达式是左值。  \nD. 前缀增量操作表达式是左值。  \n\n问题 4：  \n关于函数，哪个说法不正确？  \nA. 函数的形式参数是局部变量。  \nB. 局部变量在栈中分配空间。  \nC. 函数类型与返回值类型相同。  \nD. 函数可以在其内部调用自身。  \n\n问题 5：  \n关于指针，哪个说法不正确？  \nA. 两个指针相减等于它们地址值的差。  \nB. 指针解引用涉及根据指针的类型进行解析。  \nC. int *p[4]，p 是一个 int 指针数组。  \nD. 函数名可以赋值给函数指针。  \n\n>>> answer_questions()  \nAAAAA  \n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。",
      "fr": "Écrire une fonction JavaScript `function answer_questions()` pour résoudre le problème suivant :\nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n>>> answer_questions()\nAAAAA\nVous êtes censé uniquement retourner des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function answer_questions()`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operation-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n>>> answer_questions()\nAAAAA\nSie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Rubuta wani aikin JavaScript `function answer_questions()` don warware matsalar mai zuwa:\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\nTambaya ta 1:\nConstant kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanin sunan canji ƙimar hagu ne.\n    B. Aikin ƙara yana buƙatar operand ya zama ƙimar hagu.\n    C. Bayanin cirewa mai nuna alama ƙimar hagu ne.\n    D. Bayanin aikin ƙara na farko ƙimar hagu ne.\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin yau da kullum na aiki canje-canje ne na gida.\n    B. Canje-canje na gida suna samun sarari a cikin stack.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Cirewa masu nuna alama biyu yana daidai da bambancin a cikin ƙimar adireshinsu.\n    B. Cirewa mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsari ne na masu nuna alama na int.\n    D. Ana iya ba da sunayen ayyuka ga masu nuna alama na aiki.\n>>> answer_questions()\nAAAAA\nAna buƙatar ka mayar da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.",
      "hi": "JavaScript फ़ंक्शन `function answer_questions()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nप्रश्न 2:\nदिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\nप्रश्न 4:\nफ़ंक्शन्स के बारे में कौन सा कथन गलत है?\n    A. फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर आता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की array है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n>>> answer_questions()\nAAAAA\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों का प्रतिनिधित्व करते हैं।",
      "hu": "Írj egy JavaScript függvényt `function answer_questions()` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n2. kérdés:\nTekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának alapján történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n>>> answer_questions()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választási lehetőségeit jelölik."
    },
    "instruction_bertscore": {
      "sq": "0.9657183825371887",
      "hy": "0.9443316507807812",
      "bn": "0.9349265022387793",
      "bg": "0.9318914300165662",
      "zh": "0.9442355136763603",
      "fr": "0.9629441120052744",
      "de": "0.9569277963941086",
      "ha": "0.9225504390876385",
      "hi": "0.9538267788853919",
      "hu": "0.9378173688043611"
    },
    "level": "easy",
    "test": "function testAnswerQuestions() {\n    const expected_answers = \"DDDBA\";\n    console.assert(answer_questions() === expected_answers, \"The function should return DDDBA as the correct answer.\");\n}\n\n// Running the tests\ntestAnswerQuestions();",
    "entry_point": "answer_questions",
    "signature": "function answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n    >>> answer_questions()\n    AAAAA\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke dhënë 21! = 51,090,942,171,709,440,000, cili tip i dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\nPyetja 3:\nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i rritjes kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të rritjes prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë rreth funksioneve është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të alokuar në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\nPyetja 5:\nCila deklaratë rreth treguesve është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen në tregues funksionesh.\n>>> answer_questions()\nAAAAA\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՏրված է 21! = 51,090,942,171,709,440,000, ո՞ր տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար:\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր պնդումն է սխալ ձախ արժեքների վերաբերյալ արտահայտություններում:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր պնդումն է սխալ ֆունկցիաների վերաբերյալ:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականների համար տարածք է հատկացվում ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\nՀարց 5:\nՈ՞ր պնդումն է սխալ ցուցիչների վերաբերյալ:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n>>> answer_questions()\nAAAAA\nԴուք պետք է վերադարձնեք միայն \"AAAAA\"-ի նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন 2:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন 3:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ড একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশনের ধরন হল রিটার্ন মানের ধরন।\n    D. একটি ফাংশন তার দেহের মধ্যে থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করার মানে তাদের ঠিকানা মানের পার্থক্য।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা জড়িত।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\n>>> answer_questions()\nAAAAA\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.  \nВъпрос 1:  \nКонстанти като 1e6 принадлежат към кой тип данни?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nВъпрос 2:  \nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Нито едно от горните  \nВъпрос 3:  \nКое твърдение за левите стойности в изразите е неправилно?  \n    A. Изразите с имена на променливи са леви стойности.  \n    B. Операцията за инкремент изисква операндът да бъде лява стойност.  \n    C. Изразите за разименуване на указатели са леви стойности.  \n    D. Изразите за префиксен инкремент са леви стойности.  \nВъпрос 4:  \nКое твърдение за функциите е неправилно?  \n    A. Формалните параметри на функцията са локални променливи.  \n    B. Локалните променливи се разпределят в стека.  \n    C. Типът на функцията е същият като типа на връщаната стойност.  \n    D. Една функция може да извика себе си от тялото си.  \nВъпрос 5:  \nКое твърдение за указателите е неправилно?  \n    A. Изваждането на два указателя е равно на разликата в стойностите на техните адреси.  \n    B. Разименуването на указател включва разрешаване въз основа на типа на указателя.  \n    C. int *p[4], p е масив от указатели към int.  \n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.  \n>>> answer_questions()  \n    AAAAA  \nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.",
      "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1： 常量如1e6属于哪种数据类型？ \n    A. unsigned int \n    B. int \n    C. float \n    D. double \n\n问题2： 给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？ \n    A. int \n    B. long long \n    C. double \n    D. 以上都不是 \n\n问题3： 关于表达式中的左值，哪个说法不正确？ \n    A. 变量名表达式是左值。 \n    B. 增量操作要求操作数是左值。 \n    C. 指针解引用表达式是左值。 \n    D. 前缀增量操作表达式是左值。 \n\n问题4： 关于函数，哪个说法不正确？ \n    A. 函数的形式参数是局部变量。 \n    B. 局部变量在栈中分配空间。 \n    C. 函数类型与返回值类型相同。 \n    D. 函数可以在其主体内调用自身。 \n\n问题5： 关于指针，哪个说法不正确？ \n    A. 两个指针相减等于它们地址值的差。 \n    B. 指针解引用涉及基于指针类型的解析。 \n    C. int *p[4]，p是一个int指针数组。 \n    D. 函数名可以赋值给函数指针。 \n\n>>> answer_questions() \n    AAAAA \n你应该只返回类似于“AAAAA”的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1:\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3:\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération de pré-incrémentation sont des valeurs à gauche.\n\nQuestion 4:\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5:\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\n>>> answer_questions()\n    AAAAA\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Optionen A, B, C oder D angibst.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operation-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n>>> answer_questions()\nAAAAA\nDu sollst nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nDindindin kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn bayar da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunayen masu canji ƙimar hagu ne.\n    B. Aiki na ƙara yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cirewa mai nuna suna ƙimar hagu ne.\n    D. Maganganun aiki na ƙara na farko ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki masu canji na gida ne.\n    B. Ana ware sarari ga masu canji na gida a cikin faifan.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Rage masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire mai nuna yana da alaƙa da warwarewa bisa nau'in mai nuna.\n    C. int *p[4], p tsari ne na masu nuna int.\n    D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka.\n\n>>> answer_questions()\nAAAAA\n\nAna tsammanin ka dawo da kirtani irin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।  \nप्रश्न 1:  \n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nप्रश्न 2:  \nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?  \n    A. int  \n    B. long long  \n    C. double  \n    D. उपरोक्त में से कोई नहीं  \nप्रश्न 3:  \nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?  \n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।  \n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।  \n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।  \n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।  \nप्रश्न 4:  \nफंक्शनों के बारे में कौन सा कथन गलत है?  \n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।  \n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।  \n    C. फ़ंक्शन प्रकार वही होता है जो रिटर्न मान प्रकार होता है।  \n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।  \nप्रश्न 5:  \nपॉइंटर्स के बारे में कौन सा कथन गलत है?  \n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।  \n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।  \n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।  \n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को असाइन किया जा सकता है।  \n>>> answer_questions()  \nAAAAA  \nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने चाहिए, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszolj egy sor kérdésre azáltal, hogy A, B, C vagy D választ adsz minden kérdésre.\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nKérdés 2:\nAdott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\nKérdés 3:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\nKérdés 4:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók helyet kapnak a veremben.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\nKérdés 5:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálása a pointer típusának megfelelően történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n>>> answer_questions()\nAAAAA\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9442593493220846",
      "hy": "0.939906960412848",
      "bn": "0.9356117770533496",
      "bg": "0.9401469059131382",
      "zh": "0.9435031634614847",
      "fr": "0.9502871854953503",
      "de": "0.9483638475157894",
      "ha": "0.9195372162073392",
      "hi": "0.9466170919449687",
      "hu": "0.9298840713858276"
    }
  },
  {
    "task_id": "JavaScript/21",
    "prompt": {
      "en": "/**\n * Determines if it is possible to assemble the wooden squares from n buckets,\n * where each bucket contains a_i squares with a side length of 1, into a single larger square.\n * Input: length of the list, array of numbers\n * @param {number} length - The number of buckets.\n * @param {number[]} squares - An array of numbers, where each number represents the count of squares in a bucket.\n * @returns {boolean} - Returns true if it's possible to form a perfect square, otherwise returns false.\n *\n * Examples:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "sq": "/**\n * Përcakton nëse është e mundur të montohet katrorët prej druri nga n kovë,\n * ku secila kovë përmban a_i katrorë me një gjatësi anësore prej 1, në një katror më të madh.\n * Hyrja: gjatësia e listës, vargu i numrave\n * @param {number} length - Numri i kovëve.\n * @param {number[]} squares - Një varg numrash, ku secili numër përfaqëson numrin e katrorëve në një kovë.\n * @returns {boolean} - Kthen true nëse është e mundur të formohet një katror i përsosur, përndryshe kthen false.\n *\n * Shembuj:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "hy": "/**\n * Որոշում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\n * որտեղ յուրաքանչյուր դույլ պարունակում է a_i կողով 1 երկարությամբ քառակուսիներ, մեկ մեծ քառակուսի մեջ:\n * Մուտքագրում՝ ցուցակի երկարություն, թվերի զանգված\n * @param {number} length - Դույլերի քանակը:\n * @param {number[]} squares - Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է քառակուսիների քանակը դույլում:\n * @returns {boolean} - Վերադարձնում է true, եթե հնարավոր է կազմել կատարյալ քառակուսի, հակառակ դեպքում վերադարձնում է false:\n *\n * Օրինակներ:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "bn": "/**\n * এটি নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা,\n * যেখানে প্রতিটি বালতিতে a_i সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্রে।\n * ইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\n * @param {number} length - বালতির সংখ্যা।\n * @param {number[]} squares - সংখ্যার একটি অ্যারে, যেখানে প্রতিটি সংখ্যা একটি বালতিতে বর্গক্ষেত্রের সংখ্যা উপস্থাপন করে।\n * @returns {boolean} - এটি একটি নিখুঁত বর্গক্ষেত্র গঠন করা সম্ভব হলে true রিটার্ন করে, অন্যথায় false রিটার্ন করে।\n *\n * উদাহরণ:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "bg": "/**\n * Определя дали е възможно да се сглобят дървените квадрати от n кофи,\n * където всяка кофа съдържа a_i квадрати със страна с дължина 1, в един по-голям квадрат.\n * Вход: дължина на списъка, масив от числа\n * @param {number} length - Броят на кофите.\n * @param {number[]} squares - Масив от числа, където всяко число представлява броя на квадратите в една кофа.\n * @returns {boolean} - Връща true, ако е възможно да се образува перфектен квадрат, в противен случай връща false.\n *\n * Примери:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "zh": "/**\n * 确定是否可以从 n 个桶中组装木方块，\n * 其中每个桶包含 a_i 个边长为 1 的方块，组装成一个更大的正方形。\n * 输入：列表的长度，数字数组\n * @param {number} length - 桶的数量。\n * @param {number[]} squares - 数字数组，其中每个数字表示一个桶中的方块数量。\n * @returns {boolean} - 如果可以形成一个完美的正方形，则返回 true，否则返回 false。\n *\n * 示例:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "fr": "/**\n * Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux,\n * où chaque seau contient a_i carrés avec une longueur de côté de 1, en un seul carré plus grand.\n * Entrée : longueur de la liste, tableau de nombres\n * @param {number} length - Le nombre de seaux.\n * @param {number[]} squares - Un tableau de nombres, où chaque nombre représente le nombre de carrés dans un seau.\n * @returns {boolean} - Renvoie true s'il est possible de former un carré parfait, sinon renvoie false.\n *\n * Exemples :\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "de": "/**\n * Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern,\n * wobei jeder Eimer a_i Quadrate mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\n * Eingabe: Länge der Liste, Array von Zahlen\n * @param {number} length - Die Anzahl der Eimer.\n * @param {number[]} squares - Ein Array von Zahlen, wobei jede Zahl die Anzahl der Quadrate in einem Eimer darstellt.\n * @returns {boolean} - Gibt true zurück, wenn es möglich ist, ein perfektes Quadrat zu bilden, andernfalls false.\n *\n * Beispiele:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)",
      "ha": "/**\n * Yana tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\n * inda kowace guga tana dauke da a_i murabba'ai tare da tsawon gefe 1, zuwa murabba'i mafi girma guda daya.\n * Shigarwa: tsawon jerin, jerin lambobi\n * @param {number} length - Yawan guga.\n * @param {number[]} squares - Jerin lambobi, inda kowace lamba ke wakiltar adadin murabba'ai a cikin guga.\n * @returns {boolean} - Yana dawowa gaskiya idan yana yiwuwa a samar da cikakken murabba'i, in ba haka ba yana dawowa karya.\n *\n * Misalai:\n * Is_Square(1, [9]) // true\n */",
      "hi": "/**\n * यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\n * जहाँ प्रत्येक बाल्टी में a_i वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\n * इनपुट: सूची की लंबाई, संख्याओं की श्रृंखला\n * @param {number} length - बाल्टियों की संख्या।\n * @param {number[]} squares - संख्याओं की एक श्रृंखला, जहाँ प्रत्येक संख्या एक बाल्टी में वर्गों की गिनती का प्रतिनिधित्व करती है।\n * @returns {boolean} - यदि एक पूर्ण वर्ग बनाना संभव है तो true लौटाता है, अन्यथा false लौटाता है।\n *\n * उदाहरण:\n * Is_Square(1, [9]) // true\n */",
      "hu": "/**\n * Meghatározza, hogy lehetséges-e a fából készült négyzeteket n vödörből összeállítani,\n * ahol minden vödör a_i darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\n * Bemenet: a lista hossza, számok tömbje\n * @param {number} length - A vödrök száma.\n * @param {number[]} squares - Egy számokat tartalmazó tömb, ahol minden szám egy vödörben lévő négyzetek számát jelenti.\n * @returns {boolean} - Igazat ad vissza, ha lehetséges egy tökéletes négyzetet alkotni, különben hamisat ad vissza.\n *\n * Példák:\n * Is_Square(1, [9]) // true\n */\nfunction Is_Square(length, squares)"
    },
    "prompt_bertscore": {
      "sq": "0.9821880192110775",
      "hy": "0.9679339058072518",
      "bn": "0.9711564851091619",
      "bg": "0.9776228971637526",
      "zh": "0.9453311588581488",
      "fr": "0.9965293313521774",
      "de": "0.9920794149258528",
      "ha": "0.9461570639824918",
      "hi": "0.9502228292518949",
      "hu": "0.9762281146281256"
    },
    "canonical_solution": "{\n    let sum = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Summing the squares\n    }\n    let root = Math.sqrt(sum);\n    return Math.floor(root) === root; // Checking if sum is a perfect square\n}",
    "instruction": {
      "en": "Write a JavaScript function `function Is_Square(length, squares)` to solve the following problem:\nDetermines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of the list, array of numbers\nParameters:\n- length (number): The number of buckets.\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.\nReturns:\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.\n\nExamples:\nIs_Square(1, [9]) // true\n",
      "sq": "Shkruani një funksion JavaScript `function Is_Square(length, squares)` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse është e mundur të montohen katrorët prej druri nga n kovë,\nku secila kovë përmban a_i katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nHyrja: gjatësia e listës, vargu i numrave\nParametrat:\n- length (numër): Numri i koveve.\n- squares (numër[]): Një varg numrash, ku secili numër përfaqëson numrin e katrorëve në një kovë.\nKthen:\n- boolean: Kthen true nëse është e mundur të formohet një katror perfekt, përndryshe kthen false.\n\nShembuj:\nIs_Square(1, [9]) // true",
      "hy": "Գրեք JavaScript ֆունկցիա `function Is_Square(length, squares)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\nորտեղ յուրաքանչյուր դույլ պարունակում է a_i քառակուսի 1 կողմի երկարությամբ, մեկ մեծ քառակուսի մեջ:\nՄուտք: ցուցակի երկարություն, թվերի զանգված\nՊարամետրեր:\n- length (number): Դույլերի քանակը։\n- squares (number[]): Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է քառակուսիների քանակը դույլում։\nՎերադարձնում է:\n- boolean: Վերադարձնում է true, եթե հնարավոր է կազմել կատարյալ քառակուսի, հակառակ դեպքում վերադարձնում է false։\n\nՕրինակներ:\nIs_Square(1, [9]) // true",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function Is_Square(length, squares)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা,\nযেখানে প্রতিটি বালতিতে a_i সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্র তৈরি করতে।\nইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে\nপ্যারামিটারসমূহ:\n- length (number): বালতির সংখ্যা।\n- squares (number[]): সংখ্যার একটি অ্যারে, যেখানে প্রতিটি সংখ্যা একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে।\nরিটার্নস:\n- boolean: যদি একটি নিখুঁত বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে true রিটার্ন করে, অন্যথায় false রিটার্ন করে।\n\nউদাহরণসমূহ:\nIs_Square(1, [9]) // true",
      "bg": "Напишете JavaScript функция `function Is_Square(length, squares)`, за да решите следния проблем:\nОпределя дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа a_i квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\nПараметри:\n- length (number): Броят на кофите.\n- squares (number[]): Масив от числа, където всяко число представлява броя на квадратите в една кофа.\nВръща:\n- boolean: Връща true, ако е възможно да се образува перфектен квадрат, в противен случай връща false.\n\nПримери:\nIs_Square(1, [9]) // true",
      "zh": "编写一个 JavaScript 函数 `function Is_Square(length, squares)` 来解决以下问题：\n确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 a_i 个边长为 1 的正方形，组成一个更大的正方形。\n输入：列表的长度，数字数组\n参数：\n- length (number): 桶的数量。\n- squares (number[]): 一个数字数组，其中每个数字表示一个桶中的正方形数量。\n返回：\n- boolean: 如果可以形成一个完美的正方形，则返回 true，否则返回 false。\n\n示例：\nIs_Square(1, [9]) // true",
      "fr": "Écrire une fonction JavaScript `function Is_Square(length, squares)` pour résoudre le problème suivant :  \nDétermine s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient a_i carrés avec une longueur de côté de 1, en un seul carré plus grand.  \nEntrée : longueur de la liste, tableau de nombres  \nParamètres :  \n- length (number): Le nombre de seaux.  \n- squares (number[]): Un tableau de nombres, où chaque nombre représente le nombre de carrés dans un seau.  \nRenvoie :  \n- boolean: Renvoie true s'il est possible de former un carré parfait, sinon renvoie false.  \n\nExemples :  \nIs_Square(1, [9]) // true  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function Is_Square(length, squares)`, um das folgende Problem zu lösen:\nBestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zusammenzusetzen,\nwobei jeder Eimer a_i Quadrate mit einer Seitenlänge von 1 enthält, um ein einzelnes größeres Quadrat zu bilden.\nEingabe: Länge der Liste, Array von Zahlen\nParameter:\n- length (number): Die Anzahl der Eimer.\n- squares (number[]): Ein Array von Zahlen, wobei jede Zahl die Anzahl der Quadrate in einem Eimer darstellt.\nRückgabewert:\n- boolean: Gibt true zurück, wenn es möglich ist, ein perfektes Quadrat zu bilden, andernfalls false.\n\nBeispiele:\nIs_Square(1, [9]) // true",
      "ha": "Rubuta aikin JavaScript `function Is_Square(length, squares)` don warware matsalar mai zuwa:\nYana tantancewa idan zai yiwu a haɗa murabba'ai na katako daga n kwando,\ninda kowanne kwando ke dauke da a_i murabba'ai tare da tsayin gefe na 1, cikin babban murabba'i guda.\nShigarwa: tsayin jerin, jerin lambobi\nSigogi:\n- length (namba): Yawan kwandunan.\n- squares (namba[]): Jerin lambobi, inda kowanne lamba ke wakiltar adadin murabba'ai a cikin kwando.\nMayarwa:\n- boolean: Yana mayar da gaskiya idan zai yiwu a samar da cikakken murabba'i, in ba haka ba yana mayar da ƙarya.\n\nMisalai:\nIs_Square(1, [9]) // true",
      "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function Is_Square(length, squares)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहां प्रत्येक बाल्टी में a_i वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की array\nपैरामीटर:\n- length (number): बाल्टियों की संख्या।\n- squares (number[]): संख्याओं की एक array, जहां प्रत्येक संख्या एक बाल्टी में वर्गों की गिनती का प्रतिनिधित्व करती है।\nवापसी:\n- boolean: अगर एक पूर्ण वर्ग बनाना संभव है तो true लौटाता है, अन्यथा false लौटाता है।\n\nउदाहरण:\nIs_Square(1, [9]) // true",
      "hu": "Írj egy JavaScript függvényt `function Is_Square(length, squares)`, hogy megoldja a következő problémát:\nMegállapítja, hogy lehetséges-e a fából készült négyzeteket n vödörből összeállítani,\nahol minden vödör a_i darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: a lista hossza, számok tömbje\nParaméterek:\n- length (number): A vödrök száma.\n- squares (number[]): Egy számokat tartalmazó tömb, ahol minden szám egy vödörben lévő négyzetek számát jelenti.\nVisszatérési érték:\n- boolean: Igazat ad vissza, ha lehetséges egy tökéletes négyzetet formálni, különben hamisat.\n\nPéldák:\nIs_Square(1, [9]) // true"
    },
    "instruction_bertscore": {
      "sq": "0.9866758740401796",
      "hy": "0.9644157644983619",
      "bn": "0.9629266325317433",
      "bg": "0.9764207860977294",
      "zh": "0.9643204219154651",
      "fr": "0.9903135908384526",
      "de": "0.9827715952705579",
      "ha": "0.9539141762530473",
      "hi": "0.9745032083992187",
      "hu": "0.9673080214766109"
    },
    "level": "easy",
    "test": "const testIsSquare = () => {\n    console.assert(Is_Square(1, [9]) === true);\n    console.assert(Is_Square(2, [14, 2]) === true);\n    console.assert(Is_Square(2, [7, 7]) === false);\n    console.assert(Is_Square(7, [1, 2, 3, 4, 5, 6, 7]) === false);\n    console.assert(Is_Square(6, [1, 3, 5, 7, 9, 11]) === true);\n    console.assert(Is_Square(4, [2, 2, 2, 2]) === false);\n\n    // Additional test cases\n    console.assert(Is_Square(3, [4, 5, 6]) === false);\n    console.assert(Is_Square(4, [16, 9, 4, 1]) === false);\n    console.assert(Is_Square(5, [1, 1, 1, 1, 1]) === false);\n    console.assert(Is_Square(2, [25, 25]) === false);\n    console.assert(Is_Square(3, [10, 10, 5]) === true);\n\n    // console.log(\"All tests passed!\");\n}\n\ntestIsSquare();",
    "entry_point": "Is_Square",
    "signature": "function Is_Square(length, squares)",
    "docstring": {
      "en": "Determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a_i squares with a side length of 1, into a single larger square.\nInput: length of the list, array of numbers\nParameters:\n- length (number): The number of buckets.\n- squares (number[]): An array of numbers, where each number represents the count of squares in a bucket.\nReturns:\n- boolean: Returns true if it's possible to form a perfect square, otherwise returns false.\n\nExamples:\nIs_Square(1, [9]) // true\n",
      "sq": "Përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë,\nku secila kovë përmban a_i katrorë me një gjatësi anësore prej 1, në një katror më të madh.\nInput: gjatësia e listës, vargu i numrave\nParametrat:\n- length (numër): Numri i kovëve.\n- squares (numër[]): Një varg numrash, ku secili numër përfaqëson numrin e katrorëve në një kovë.\nKthen:\n- boolean: Kthen true nëse është e mundur të formohet një katror i përsosur, përndryshe kthen false.\n\nShembuj:\nIs_Square(1, [9]) // true",
      "hy": "Վճռում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է a_i կողքի երկարությամբ 1 քառակուսի, մեկ մեծ քառակուսի մեջ:\nՄուտք: ցուցակի երկարություն, թվերի զանգված\nՊարամետրեր:\n- length (թիվ): Դույլերի քանակը:\n- squares (թիվ[]): Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է դույլում գտնվող քառակուսիների քանակը:\nՎերադարձնում է:\n- boolean: Վերադարձնում է true, եթե հնարավոր է կազմել կատարյալ քառակուսի, հակառակ դեպքում վերադարձնում է false:\n\nՕրինակներ:\nIs_Square(1, [9]) // true",
      "bn": "নির্ধারণ করে যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা,\nযেখানে প্রতিটি বালতিতে a_i সংখ্যক 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে, একটি বড় বর্গক্ষেত্র তৈরি করতে। ইনপুট: তালিকার দৈর্ঘ্য, সংখ্যার অ্যারে Parameters: - length (number): বালতির সংখ্যা। - squares (number[]): সংখ্যার একটি অ্যারে, যেখানে প্রতিটি সংখ্যা একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে। Returns: - boolean: যদি একটি নিখুঁত বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে সত্য ফেরত দেয়, অন্যথায় মিথ্যা ফেরত দেয়।\n\nউদাহরণ:\nIs_Square(1, [9]) // true",
      "bg": "Определя дали е възможно да се сглобят дървените квадрати от n кофи, където всяка кофа съдържа a_i квадрати със страна с дължина 1, в един по-голям квадрат.\nВход: дължина на списъка, масив от числа\nПараметри:\n- length (number): Броят на кофите.\n- squares (number[]): Масив от числа, където всяко число представлява броя на квадратите в кофа.\nВръща:\n- boolean: Връща true, ако е възможно да се образува перфектен квадрат, в противен случай връща false.\n\nПримери:\nIs_Square(1, [9]) // true",
      "zh": "确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含 a_i 个边长为 1 的正方形，组装成一个更大的正方形。\n输入：列表的长度，数字数组\n参数：\n- length (number): 桶的数量。\n- squares (number[]): 一个数字数组，其中每个数字表示桶中正方形的数量。\n返回：\n- boolean: 如果可以形成一个完美的正方形，则返回 true，否则返回 false。\n\n示例：\nIs_Square(1, [9]) // true",
      "fr": "Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient a_i carrés de côté 1, en un seul grand carré.\nEntrée : longueur de la liste, tableau de nombres\nParamètres :\n- length (nombre) : Le nombre de seaux.\n- squares (nombre[]) : Un tableau de nombres, où chaque nombre représente le nombre de carrés dans un seau.\nRenvoie :\n- booléen : Renvoie vrai s'il est possible de former un carré parfait, sinon renvoie faux.\n\nExemples :\nIs_Square(1, [9]) // true",
      "de": "Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zusammenzusetzen, wobei jeder Eimer a_i Quadrate mit einer Seitenlänge von 1 enthält, um ein einzelnes größeres Quadrat zu bilden.\nEingabe: Länge der Liste, Array von Zahlen\nParameter:\n- length (number): Die Anzahl der Eimer.\n- squares (number[]): Ein Array von Zahlen, wobei jede Zahl die Anzahl der Quadrate in einem Eimer darstellt.\nRückgabewert:\n- boolean: Gibt true zurück, wenn es möglich ist, ein perfektes Quadrat zu bilden, andernfalls false.\n\nBeispiele:\nIs_Square(1, [9]) // true",
      "ha": "Yana tantance ko zai yiwu a tara murabba'ai na katako daga kwandunan n, inda kowanne kwando ya ƙunshi murabba'ai a_i tare da tsawon gefe 1, zuwa murabba'i mafi girma.\nShigarwa: tsawon jerin, jerin lambobi\nSigogi:\n- length (namba): Yawan kwanduna.\n- squares (namba[]): Jerin lambobi, inda kowanne lamba ke wakiltar adadin murabba'ai a cikin kwando.\nMayarwa:\n- boolean: Yana mayar da gaskiya idan zai yiwu a samar da cikakken murabba'i, in ba haka ba yana mayar da ƙarya.\n\nMisalai:\nIs_Square(1, [9]) // true",
      "hi": "यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में a_i वर्ग होते हैं जिनकी भुजा की लंबाई 1 होती है, एक बड़े वर्ग में।\nइनपुट: सूची की लंबाई, संख्याओं की array\nपैरामीटर:\n- length (संख्या): बाल्टियों की संख्या।\n- squares (number[]): संख्याओं की एक array, जहाँ प्रत्येक संख्या एक बाल्टी में वर्गों की गिनती का प्रतिनिधित्व करती है।\nरिटर्न:\n- boolean: यदि एक पूर्ण वर्ग बनाना संभव है तो true लौटाता है, अन्यथा false लौटाता है।\n\nउदाहरण:\nIs_Square(1, [9]) // true",
      "hu": "Meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani, ahol minden vödör a_i darab, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nBemenet: a lista hossza, számok tömbje\nParaméterek:\n- length (szám): A vödrök száma.\n- squares (szám[]): Számok tömbje, ahol minden szám egy vödörben lévő négyzetek számát jelenti.\nVisszatérési érték:\n- boolean: Igazat ad vissza, ha lehetséges tökéletes négyzetet formálni, különben hamisat ad vissza.\n\nPéldák:\nIs_Square(1, [9]) // true"
    },
    "docstring_bertscore": {
      "sq": "0.9850429336776919",
      "hy": "0.9398867001139825",
      "bn": "0.9755952782341485",
      "bg": "0.9847674333391965",
      "zh": "0.9525428321023824",
      "fr": "0.963990099591804",
      "de": "0.9809996136413457",
      "ha": "0.9347689883466186",
      "hi": "0.9550537187490444",
      "hu": "0.956998111548995"
    }
  },
  {
    "task_id": "JavaScript/22",
    "prompt": {
      "en": "/**\n * Given integers c and d, where a + b = c and a * b = d, find and return the\n * possible value of a (a <= b). If there are multiple groups, output the group\n * with the smallest a.\n * \n * Parameters:\n *   - c (int): The sum of a and b.\n *   - d (int): The product of a and b.\n * \n * Returns:\n *   A possible value of a or -1 if valid values do not exist.\n * \n * Examples:\n *   findIntegers(7, 11) // returns -1\n *   findIntegers(5, 6)  // returns 2\n */\nfunction findIntegers(c, d)",
      "sq": "/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni\n * vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin\n * me a më të vogël.\n * \n * Parametrat:\n *   - c (int): Shuma e a dhe b.\n *   - d (int): Produkti i a dhe b.\n * \n * Kthen:\n *   Një vlerë të mundshme të a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n * \n * Shembuj:\n *   findIntegers(7, 11) // kthen -1\n *   findIntegers(5, 6)  // kthen 2\n */",
      "hy": "/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել\n * a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել խումբը\n * ամենափոքր a-ով:\n * \n * Պարամետրեր:\n *   - c (int): a-ի և b-ի գումարը:\n *   - d (int): a-ի և b-ի արտադրյալը:\n * \n * Վերադարձնում է:\n *   a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան:\n * \n * Օրինակներ:\n *   findIntegers(7, 11) // վերադարձնում է -1\n *   findIntegers(5, 6)  // վերադարձնում է 2\n */\nfunction findIntegers(c, d)",
      "bn": "/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। \n * যদি একাধিক গোষ্ঠী থাকে, তবে সবচেয়ে ছোট a সহ গোষ্ঠীটি আউটপুট করুন।\n * \n * প্যারামিটারসমূহ:\n *   - c (int): a এবং b এর যোগফল।\n *   - d (int): a এবং b এর গুণফল।\n * \n * রিটার্নস:\n *   a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n * \n * উদাহরণসমূহ:\n *   findIntegers(7, 11) // -1 ফেরত দেয়\n *   findIntegers(5, 6)  // 2 ফেরত দেয়\n */\nfunction findIntegers(c, d)",
      "bg": "/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете\n * възможната стойност на a (a <= b). Ако има множество групи, изведете групата\n * с най-малката стойност на a.\n * \n * Параметри:\n *   - c (int): Сумата на a и b.\n *   - d (int): Произведението на a и b.\n * \n * Връща:\n *   Възможна стойност на a или -1, ако не съществуват валидни стойности.\n * \n * Примери:\n *   findIntegers(7, 11) // връща -1\n *   findIntegers(5, 6)  // връща 2\n */\nfunction findIntegers(c, d)",
      "zh": "/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个组合，输出 a 最小的组合。\n * \n * 参数:\n *   - c (int): a 和 b 的和。\n *   - d (int): a 和 b 的积。\n * \n * 返回:\n *   a 的一个可能值，或者如果不存在有效值则返回 -1。\n * \n * 示例:\n *   findIntegers(7, 11) // 返回 -1\n *   findIntegers(5, 6)  // 返回 2\n */",
      "fr": "/**\n * Étant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la\n * valeur possible de a (a <= b). S'il y a plusieurs groupes, sortir le groupe\n * avec le plus petit a.\n * \n * Paramètres:\n *   - c (int) : La somme de a et b.\n *   - d (int) : Le produit de a et b.\n * \n * Renvoie:\n *   Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n * \n * Exemples:\n *   findIntegers(7, 11) // returns -1\n *   findIntegers(5, 6)  // returns 2\n */\nfunction findIntegers(c, d)",
      "de": "/**\n * Gegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d. Finde und gib den\n * möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe\n * mit dem kleinsten a aus.\n * \n * Parameter:\n *   - c (int): Die Summe von a und b.\n *   - d (int): Das Produkt von a und b.\n * \n * Rückgabewert:\n *   Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n * \n * Beispiele:\n *   findIntegers(7, 11) // gibt -1 zurück\n *   findIntegers(5, 6)  // gibt 2 zurück\n */\nfunction findIntegers(c, d)",
      "ha": "/**\n * An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da\n * yuwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar\n * tare da mafi ƙarancin a.\n * \n * Sigogi:\n *   - c (int): Jimillar a da b.\n *   - d (int): Samfurin a da b.\n * \n * Dawowa:\n *   Yuwuwar ƙimar a ko -1 idan ba a sami ƙimar da ta dace ba.\n * \n * Misalai:\n *   findIntegers(7, 11) // returns -1\n *   findIntegers(5, 6)  // returns 2\n */\nfunction findIntegers(c, d)",
      "hi": "/**\n * दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएं (a <= b)। \n * यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n * \n * पैरामीटर्स:\n *   - c (int): a और b का योग।\n *   - d (int): a और b का गुणनफल।\n * \n * रिटर्न करता है:\n *   a का एक संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n * \n * उदाहरण:\n *   findIntegers(7, 11) // -1 लौटाता है\n *   findIntegers(5, 6)  // 2 लौटाता है\n */\nfunction findIntegers(c, d)",
      "hu": "/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, találja meg és adja vissza\n * a lehetséges a értéket (a <= b). Ha több csoport is van, adja vissza azt a csoportot,\n * amelyikben a legkisebb az a.\n * \n * Paraméterek:\n *   - c (int): Az a és b összege.\n *   - d (int): Az a és b szorzata.\n * \n * Visszatérési érték:\n *   Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n * \n * Példák:\n *   findIntegers(7, 11) // visszaadja -1\n *   findIntegers(5, 6)  // visszaadja 2\n */\nfunction findIntegers(c, d)"
    },
    "prompt_bertscore": {
      "sq": "0.9671107815082433",
      "hy": "0.9768718756930597",
      "bn": "0.969119133290887",
      "bg": "0.9797875710562708",
      "zh": "0.947415983337491",
      "fr": "0.9874564914376468",
      "de": "0.9630549477578918",
      "ha": "0.9773052871844778",
      "hi": "0.9685979271710514",
      "hu": "0.960613780374973"
    },
    "canonical_solution": "{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a JavaScript function `function findIntegers(c, d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // returns -1\n  findIntegers(5, 6)  // returns 2\n",
      "sq": "Shkruani një funksion JavaScript `function findIntegers(c, d)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n\nParametrat:\n  - c (int): Shuma e a dhe b.\n  - d (int): Produkti i a dhe b.\n\nKthen:\n  Një vlerë të mundshme të a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n\nShembuj:\n  findIntegers(7, 11) // kthen -1\n  findIntegers(5, 6)  // kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `function findIntegers(c, d)` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n\nՊարամետրեր:\n  - c (int): a և b-ի գումարը:\n  - d (int): a և b-ի արտադրյալը:\n\nՎերադարձնում է:\n  a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չկան:\n\nՕրինակներ:\n  findIntegers(7, 11) // վերադարձնում է -1\n  findIntegers(5, 6)  // վերադարձնում է 2",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function findIntegers(c, d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n\nপ্যারামিটারসমূহ:\n  - c (int): a এবং b এর যোগফল।\n  - d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n  a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n\nউদাহরণ:\n  findIntegers(7, 11) // -1 ফেরত দেয়\n  findIntegers(5, 6)  // 2 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function findIntegers(c, d)` за решаване на следния проблем:  \nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малка стойност на a.\n\nПараметри:\n  - c (int): Сумата на a и b.\n  - d (int): Произведението на a и b.\n\nВръща:\n  Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\n  findIntegers(7, 11) // връща -1\n  findIntegers(5, 6)  // връща 2",
      "zh": "编写一个 JavaScript 函数 `function findIntegers(c, d)` 来解决以下问题：\n\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值（a <= b）。如果有多个组合，输出 a 最小的组合。\n\n参数：\n  - c (int): a 和 b 的和。\n  - d (int): a 和 b 的积。\n\n返回：\n  a 的可能值，如果不存在有效值则返回 -1。\n\n示例：\n  findIntegers(7, 11) // 返回 -1\n  findIntegers(5, 6)  // 返回 2",
      "fr": "Écrire une fonction JavaScript `function findIntegers(c, d)` pour résoudre le problème suivant :  \nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.\n\nParamètres :\n  - c (int) : La somme de a et b.\n  - d (int) : Le produit de a et b.\n\nRenvoie :\n  Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n\nExemples :\n  findIntegers(7, 11) // retourne -1\n  findIntegers(5, 6)  // retourne 2",
      "de": "Schreiben Sie eine JavaScript-Funktion `function findIntegers(c, d)`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finden und geben Sie den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, geben Sie die Gruppe mit dem kleinsten a aus.\n\nParameter:\n  - c (int): Die Summe von a und b.\n  - d (int): Das Produkt von a und b.\n\nRückgabe:\n  Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\n  findIntegers(7, 11) // gibt -1 zurück\n  findIntegers(5, 6)  // gibt 2 zurück",
      "ha": "Rubuta wani aikin JavaScript `function findIntegers(c, d)` don warware matsalar mai zuwa:\nAn ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a (a <= b). Idan akwai kungiyoyi da yawa, fitar da ƙungiyar da ke da ƙaramin a.\n\nSigogi:\n  - c (int): Jimillar a da b.\n  - d (int): Samfurin a da b.\n\nDawowa:\n  Wata yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n\nMisalai:\n  findIntegers(7, 11) // returns -1\n  findIntegers(5, 6)  // returns 2",
      "hi": "JavaScript फ़ंक्शन `function findIntegers(c, d)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n\nपैरामीटर्स:\n  - c (int): a और b का योग।\n  - d (int): a और b का गुणनफल।\n\nवापसी मान:\n  a का एक संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n\nउदाहरण:\n  findIntegers(7, 11) // returns -1\n  findIntegers(5, 6)  // returns 2",
      "hu": "Írj egy JavaScript függvényt `function findIntegers(c, d)` a következő probléma megoldására:\nAdottak az egész számok c és d, ahol a + b = c és a * b = d, találd meg és add vissza a lehetséges a értéket (a <= b). Ha több csoport is van, add vissza azt a csoportot, amelyikben a legkisebb az a.\n\nParaméterek:\n  - c (int): Az a és b összege.\n  - d (int): Az a és b szorzata.\n\nVisszatér:\n  Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\n  findIntegers(7, 11) // visszaadja -1\n  findIntegers(5, 6)  // visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.978445028310856",
      "hy": "0.9751638530465407",
      "bn": "0.9871152444430289",
      "bg": "0.9816539021164746",
      "zh": "0.9672285693241969",
      "fr": "0.9826569855407008",
      "de": "0.9877699301789199",
      "ha": "0.9790864058112176",
      "hi": "0.9643961000906394",
      "hu": "0.9744978453789307"
    },
    "level": "easy",
    "test": "const testFindIntegers = () => {\n    console.assert(findIntegers(5, 6) === 2, \"Expected 2\");\n    console.assert(findIntegers(6, 9) === 3, \"Expected 3\");\n    console.assert(findIntegers(7, 12) === 3, \"Expected 3\");\n    console.assert(findIntegers(7, 11) === -1, \"Expected -1\");\n    console.assert(findIntegers(9, 8) === 1, \"Expected 1\");\n    console.assert(findIntegers(10, 25) === 5, \"Expected 5\");\n    console.assert(findIntegers(10000, 8765) === -1, \"Expected -1\");\n    // console.log(\"All tests passed successfully.\");\n}\n\ntestFindIntegers();",
    "entry_point": "findIntegers",
    "signature": "function findIntegers(c, d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple groups, output the group with the smallest a.\n\nParameters:\n  - c (int): The sum of a and b.\n  - d (int): The product of a and b.\n\nReturns:\n  A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // returns -1\n  findIntegers(5, 6)  // returns 2\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a (a <= b). Nëse ka grupe të shumta, jepni grupin me vlerën më të vogël të a.\n\nParametrat:\n  - c (int): Shuma e a dhe b.\n  - d (int): Produkti i a dhe b.\n\nKthen:\n  Një vlerë të mundshme të a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n\nShembuj:\n  findIntegers(7, 11) // kthen -1\n  findIntegers(5, 6)  // kthen 2",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է:\n\nՊարամետրեր:\n  - c (int): a-ի և b-ի գումարը:\n  - d (int): a-ի և b-ի արտադրյալը:\n\nՎերադարձնում է:\n  a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չկան:\n\nՕրինակներ:\n  findIntegers(7, 11) // վերադարձնում է -1\n  findIntegers(5, 6)  // վերադարձնում է 2",
      "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন।\n\nপ্যারামিটারসমূহ:\n  - c (int): a এবং b এর যোগফল।\n  - d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n  a এর একটি সম্ভাব্য মান অথবা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n\nউদাহরণসমূহ:\n  findIntegers(7, 11) // -1 ফেরত দেয়\n  findIntegers(5, 6)  // 2 ফেরত দেয়",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a (a <= b). Ако има множество групи, изведете групата с най-малката a.\n\nПараметри:\n  - c (int): Сумата на a и b.\n  - d (int): Произведението на a и b.\n\nВръща:\n  Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\n  findIntegers(7, 11) // връща -1\n  findIntegers(5, 6)  // връща 2",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找出并返回可能的 a 的值（a <= b）。如果有多个组合，输出 a 最小的组合。\n\n参数：\n  - c (int): a 和 b 的和。\n  - d (int): a 和 b 的积。\n\n返回：\n  a 的可能值，或者如果不存在有效值则返回 -1。\n\n示例：\n  findIntegers(7, 11) // 返回 -1\n  findIntegers(5, 6)  // 返回 2",
      "fr": "Étant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la valeur possible de a (a <= b). S'il y a plusieurs groupes, afficher le groupe avec le plus petit a.\n\nParamètres:\n  - c (int): La somme de a et b.\n  - d (int): Le produit de a et b.\n\nRenvoie:\n  Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n\nExemples:\n  findIntegers(7, 11) // renvoie -1\n  findIntegers(5, 6)  // renvoie 2",
      "de": "Gegeben ganze Zahlen c und d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus.\n\nParameter:\n  - c (int): Die Summe von a und b.\n  - d (int): Das Produkt von a und b.\n\nRückgabe:\n  Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\n  findIntegers(7, 11) // gibt -1 zurück\n  findIntegers(5, 6)  // gibt 2 zurück",
      "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yuwuwar ƙimar a (a <= b). Idan akwai rukuni da yawa, fitar da rukunin da ke da ƙaramin a.\n\nSigogi:\n  - c (int): Jimillar a da b.\n  - d (int): Samfurin a da b.\n\nDawowa:\n  Yuwuwar ƙimar a ko -1 idan ba a samu ƙimar da ta dace ba.\n\nMisalai:\n  findIntegers(7, 11) // ya dawo -1\n  findIntegers(5, 6)  // ya dawo 2",
      "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ (a <= b)। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें।\n\nपैरामीटर्स:\n  - c (int): a और b का योग।\n  - d (int): a और b का गुणनफल।\n\nलौटाता है:\n  a का संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n\nउदाहरण:\n  findIntegers(7, 11) // -1 लौटाता है\n  findIntegers(5, 6)  // 2 लौटाता है",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, keresse meg és adja vissza a lehetséges a értékét (a <= b). Ha több csoport is van, adja vissza azt a csoportot, amelyikben a a legkisebb.\n\nParaméterek:\n  - c (int): a és b összege.\n  - d (int): a és b szorzata.\n\nVisszatérési érték:\n  A lehetséges a értéke vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\n  findIntegers(7, 11) // visszaadja -1\n  findIntegers(5, 6)  // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9693167705200166",
      "hy": "0.9701730660926581",
      "bn": "0.9940130816852274",
      "bg": "0.9930179434762426",
      "zh": "0.9626674198844928",
      "fr": "0.9886298010984199",
      "de": "0.996037721159116",
      "ha": "0.9739482351146072",
      "hi": "0.9727850556032669",
      "hu": "0.977949644140555"
    }
  },
  {
    "task_id": "JavaScript/23",
    "prompt": {
      "en": "/**\n * Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n * \n * @param {number} edges_count - The number of edges.\n * @param {...number} edges - The lengths of the edges.\n * @returns {number} The count of distinct acute-angled triangles that can be formed.\n * \n * Examples:\n * count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "sq": "/**\n * Numëron numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n * \n * @param {number} edges_count - Numri i brinjëve.\n * @param {...number} edges - Gjatësitë e brinjëve.\n * @returns {number} Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n * \n * Shembuj:\n * count_acute_triangles(4, 1, 1, 1, 1) // kthen 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "hy": "/**\n * Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողմերը տրված կողմերի բազմությունից։\n * \n * @param {number} edges_count - Կողմերի քանակը։\n * @param {...number} edges - Կողմերի երկարությունները։\n * @returns {number} Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել։\n * \n * Օրինակներ:\n * count_acute_triangles(4, 1, 1, 1, 1) // վերադարձնում է 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "bn": "/**\n * প্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোন 3টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণযুক্ত ত্রিভুজ তৈরি করা যেতে পারে তা গণনা করুন।\n * \n * @param {number} edges_count - প্রান্তের সংখ্যা।\n * @param {...number} edges - প্রান্তগুলির দৈর্ঘ্য।\n * @returns {number} গঠিত পৃথক তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা।\n * \n * উদাহরণ:\n * count_acute_triangles(4, 1, 1, 1, 1) // 4 প্রদান করে\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "bg": "/**\n * Пребройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n * \n * @param {number} edges_count - Броят на ръбовете.\n * @param {...number} edges - Дължините на ръбовете.\n * @returns {number} Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n * \n * Примери:\n * count_acute_triangles(4, 1, 1, 1, 1) // връща 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "zh": "/**\n * 计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n * \n * @param {number} edges_count - 边的数量。\n * @param {...number} edges - 边的长度。\n * @returns {number} 可以形成的不同锐角三角形的数量。\n * \n * 例子:\n * count_acute_triangles(4, 1, 1, 1, 1) // 返回 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "fr": "/**\n * Compter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n * \n * @param {number} edges_count - Le nombre d'arêtes.\n * @param {...number} edges - Les longueurs des arêtes.\n * @returns {number} Le nombre de triangles aigus distincts qui peuvent être formés.\n * \n * Exemples :\n * count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "de": "/**\n * Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n * \n * @param {number} edges_count - Die Anzahl der Kanten.\n * @param {...number} edges - Die Längen der Kanten.\n * @returns {number} Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n * \n * Beispiele:\n * count_acute_triangles(4, 1, 1, 1, 1) // gibt 4 zurück\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "ha": "/**\n * Ƙirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane gefuna 3 daga cikin wani saiti na gefuna.\n * \n * @param {number} edges_count - Yawan gefuna.\n * @param {...number} edges - Tsawon gefuna.\n * @returns {number} Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n * \n * Misalai:\n * count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "hi": "/**\n * दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n * \n * @param {number} edges_count - किनारों की संख्या।\n * @param {...number} edges - किनारों की लंबाई।\n * @returns {number} बनने वाले विशिष्ट तीव्र कोण त्रिभुजों की संख्या।\n * \n * उदाहरण:\n * count_acute_triangles(4, 1, 1, 1, 1) // 4 लौटाता है\n */\nfunction count_acute_triangles(edges_count, ...edges)",
      "hu": "/**\n * Számolja meg a hegyesszögű háromszögek számát, amelyek bármely 3 él kiválasztásával képezhetők a megadott élek halmazából.\n * \n * @param {number} edges_count - Az élek száma.\n * @param {...number} edges - Az élek hossza.\n * @returns {number} Az alkotható különböző hegyesszögű háromszögek száma.\n * \n * Példák:\n * count_acute_triangles(4, 1, 1, 1, 1) // visszaadja: 4\n */\nfunction count_acute_triangles(edges_count, ...edges)"
    },
    "prompt_bertscore": {
      "sq": "0.9754480931218016",
      "hy": "0.9489225947776406",
      "bn": "0.9578176605011449",
      "bg": "0.9695211611821016",
      "zh": "0.9638031884032503",
      "fr": "0.9692818115729546",
      "de": "0.9695211611821016",
      "ha": "0.9655145877662469",
      "hi": "0.9760443815256683",
      "hu": "0.9849537486366072"
    },
    "canonical_solution": "{\n    // Sort the edges array\n    edges.sort((a, b) => a - b);\n\n    let sum = 0;\n    // Check each combination of three edges for an acute triangle.\n    for (let i = 0; i < edges_count - 2; i++) {\n        for (let j = i + 1; j < edges_count - 1; j++) {\n            for (let k = j + 1; k < edges_count; k++) {\n                const x = edges[i], y = edges[j], z = edges[k];\n                // The sum of any two sides must be greater than the third, and\n                // it needs to meet the acute angle criteria via Pythagoras.\n                if (x + y > z && (x * x + y * y > z * z)) {\n                    sum++;\n                }\n            }\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function count_acute_triangles(edges_count, ...edges)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nParameters:\n- edges_count (number): The number of edges.\n- edges (...number): The lengths of the edges.\n\nReturns:\n- number: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n- count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n",
      "sq": "Shkruani një funksion JavaScript `function count_acute_triangles(edges_count, ...edges)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënde të mprehta që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nParametrat:\n- edges_count (numër): Numri i brinjëve.\n- edges (...numër): Gjatësitë e brinjëve.\n\nKthen:\n- numër: Numri i trekëndëshave të dallueshëm me kënde të mprehta që mund të formohen.\n\nShembuj:\n- count_acute_triangles(4, 1, 1, 1, 1) // kthen 4",
      "hy": "Գրեք JavaScript ֆունկցիա `function count_acute_triangles(edges_count, ...edges)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրված ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n\nՊարամետրեր:\n- edges_count (number): Կողերի քանակը։\n- edges (...number): Կողերի երկարությունները։\n\nՎերադարձնում է:\n- number: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել։\n\nՕրինակներ:\n- count_acute_triangles(4, 1, 1, 1, 1) // վերադարձնում է 4",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function count_acute_triangles(edges_count, ...edges)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলো তীক্ষ্ণকোণী ত্রিভুজ গঠন করা যায় তা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- edges_count (সংখ্যা): প্রান্তের সংখ্যা।\n- edges (...সংখ্যা): প্রান্তগুলোর দৈর্ঘ্য।\n\nফেরত দেয়:\n- সংখ্যা: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণকোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণসমূহ:\n- count_acute_triangles(4, 1, 1, 1, 1) // 4 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function count_acute_triangles(edges_count, ...edges)`, за да решите следния проблем:  \nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nПараметри:\n- edges_count (number): Броят на ръбовете.\n- edges (...number): Дължините на ръбовете.\n\nВръща:\n- number: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n- count_acute_triangles(4, 1, 1, 1, 1) // връща 4",
      "zh": "编写一个 JavaScript 函数 `function count_acute_triangles(edges_count, ...edges)` 来解决以下问题：  \n计算可以通过从给定的一组边中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：\n- edges_count (number): 边的数量。\n- edges (...number): 边的长度。\n\n返回：\n- number: 可以形成的不同锐角三角形的数量。\n\n示例：\n- count_acute_triangles(4, 1, 1, 1, 1) // 返回 4",
      "fr": "Écrire une fonction JavaScript `function count_acute_triangles(edges_count, ...edges)` pour résoudre le problème suivant :  \nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\nParamètres :\n- edges_count (nombre) : Le nombre d'arêtes.\n- edges (...nombre) : Les longueurs des arêtes.\n\nRenvoie :\n- nombre : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :\n- count_acute_triangles(4, 1, 1, 1, 1) // renvoie 4",
      "de": "Schreiben Sie eine JavaScript-Funktion `function count_acute_triangles(edges_count, ...edges)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie beliebige 3 Kanten aus einer gegebenen Menge von Kanten auswählen.\n\nParameter:\n- edges_count (number): Die Anzahl der Kanten.\n- edges (...number): Die Längen der Kanten.\n\nRückgabewert:\n- number: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n- count_acute_triangles(4, 1, 1, 1, 1) // gibt 4 zurück",
      "ha": "Rubuta wani aikin JavaScript `function count_acute_triangles(edges_count, ...edges)` don warware matsalar mai zuwa:\nKirga yawan kusurwoyi masu kaifi da za a iya samarwa ta hanyar zaɓar kowane 3 daga cikin wani saiti na gefuna.\n\nSigogi:\n- edges_count (number): Yawan gefuna.\n- edges (...number): Tsawon gefuna.\n\nDawowa:\n- number: Adadin kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n\nMisalai:\n- count_acute_triangles(4, 1, 1, 1, 1) // returns 4",
      "hi": "`function count_acute_triangles(edges_count, ...edges)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n\nपैरामीटर्स:\n- edges_count (संख्या): किनारों की संख्या।\n- edges (...संख्या): किनारों की लंबाई।\n\nवापसी:\n- संख्या: बनने वाले भिन्न तीव्र कोण त्रिभुजों की संख्या।\n\nउदाहरण:\n- count_acute_triangles(4, 1, 1, 1, 1) // 4 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function count_acute_triangles(edges_count, ...edges)` a következő probléma megoldására:  \nSzámold meg, hány hegyesszögű háromszög alakítható ki a megadott élek halmazából bármely 3 él kiválasztásával.\n\nParaméterek:\n- edges_count (szám): Az élek száma.\n- edges (...szám): Az élek hossza.\n\nVisszatér:\n- szám: Az alakítható különböző hegyesszögű háromszögek száma.\n\nPéldák:\n- count_acute_triangles(4, 1, 1, 1, 1) // visszaadja 4"
    },
    "instruction_bertscore": {
      "sq": "0.977380170838128",
      "hy": "0.9619763847888724",
      "bn": "0.970149826338077",
      "bg": "0.972415603094542",
      "zh": "0.9668112468936426",
      "fr": "0.9733952481338061",
      "de": "0.9714262251666071",
      "ha": "0.9626731801655428",
      "hi": "0.9525990445002153",
      "hu": "0.9601545469340204"
    },
    "level": "hard",
    "test": "(function testAcuteTriangles() {\n    console.assert(count_acute_triangles(4, 1, 1, 1, 1) === 4, \"Test case 1 failed\");\n    console.assert(count_acute_triangles(3, 1, 2, 3) === 0, \"Test case 2 failed\");\n    // Additional tests to ensure correctness\n    console.assert(count_acute_triangles(5, 3, 4, 5, 7, 10) === 0, \"Test case 3 failed\");\n    console.assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) === 4, \"Test case 4 failed\");\n})();",
    "entry_point": "count_acute_triangles",
    "signature": "function count_acute_triangles(edges_count, ...edges)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nParameters:\n- edges_count (number): The number of edges.\n- edges (...number): The lengths of the edges.\n\nReturns:\n- number: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n- count_acute_triangles(4, 1, 1, 1, 1) // returns 4\n",
      "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nParametrat:\n- edges_count (numër): Numri i brinjëve.\n- edges (...numër): Gjatësitë e brinjëve.\n\nKthen:\n- numër: Numri i trekëndëshave të ndryshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n- count_acute_triangles(4, 1, 1, 1, 1) // kthen 4",
      "hy": "Հաշվել սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել տրված եզրերից ցանկացած 3-ը ընտրելով:\n\nՊարամետրեր:\n- edges_count (number): Եզրերի քանակը:\n- edges (...number): Եզրերի երկարությունները:\n\nՎերադարձնում է:\n- number: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n- count_acute_triangles(4, 1, 1, 1, 1) // վերադարձնում է 4",
      "bn": "তিনটি প্রান্ত নির্বাচন করে প্রদত্ত প্রান্তগুলির সেট থেকে কতগুলি তীক্ষ্ণ-কোণযুক্ত ত্রিভুজ গঠন করা যায় তা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- edges_count (number): প্রান্তগুলির সংখ্যা।\n- edges (...number): প্রান্তগুলির দৈর্ঘ্য।\n\nরিটার্নস:\n- number: ভিন্ন তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা যা গঠন করা যেতে পারে।\n\nউদাহরণসমূহ:\n- count_acute_triangles(4, 1, 1, 1, 1) // 4 রিটার্ন করে",
      "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nПараметри:\n- edges_count (number): Броят на ръбовете.\n- edges (...number): Дължините на ръбовете.\n\nВръща:\n- number: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n- count_acute_triangles(4, 1, 1, 1, 1) // връща 4",
      "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count (number): 边的数量。\n- edges (...number): 边的长度。\n\n返回：\n- number: 可以形成的不同锐角三角形的数量。\n\n示例：\n- count_acute_triangles(4, 1, 1, 1, 1) // 返回 4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nParamètres :\n- edges_count (nombre) : Le nombre de côtés.\n- edges (...nombre) : Les longueurs des côtés.\n\nRenvoie :\n- nombre : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :\n- count_acute_triangles(4, 1, 1, 1, 1) // renvoie 4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nParameter:\n- edges_count (number): Die Anzahl der Kanten.\n- edges (...number): Die Längen der Kanten.\n\nRückgabewerte:\n- number: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n- count_acute_triangles(4, 1, 1, 1, 1) // gibt 4 zurück",
      "ha": "Kirga yawan kusurwoyi masu kaifi da za a iya samarwa ta hanyar zaɓar kowane 3 daga cikin wani saiti na gefun.\n\nSigogi:\n- edges_count (number): Yawan gefuna.\n- edges (...number): Tsawon gefuna.\n\nDawowa:\n- number: Yawan daban-daban na triangles masu kusurwa masu kaifi da za a iya samarwa.\n\nMisalai:\n- count_acute_triangles(4, 1, 1, 1, 1) // yana dawowa 4",
      "hi": "तीव्र कोण वाले त्रिभुजों की संख्या गिनें जो किन्हीं 3 किनारों का चयन करके दिए गए किनारों के सेट से बनाए जा सकते हैं।\n\nपैरामीटर्स:\n- edges_count (संख्या): किनारों की संख्या।\n- edges (...संख्या): किनारों की लंबाई।\n\nवापसी:\n- संख्या: विशिष्ट तीव्र कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n- count_acute_triangles(4, 1, 1, 1, 1) // 4 लौटाता है",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek kialakíthatók bármely 3 él kiválasztásával egy adott élsorozatból.\n\nParaméterek:\n- edges_count (szám): Az élek száma.\n- edges (...szám): Az élek hossza.\n\nVisszatér:\n- szám: Az egyedi hegyesszögű háromszögek száma, amelyek kialakíthatók.\n\nPéldák:\n- count_acute_triangles(4, 1, 1, 1, 1) // visszaadja 4"
    },
    "docstring_bertscore": {
      "sq": "0.9648855253495093",
      "hy": "0.9618538298437739",
      "bn": "0.9570586938152106",
      "bg": "0.985584400096393",
      "zh": "0.9577250987435827",
      "fr": "0.9527619214126639",
      "de": "0.962207789182778",
      "ha": "0.9913752702250841",
      "hi": "0.9857842222597141",
      "hu": "0.9794675775124236"
    }
  },
  {
    "task_id": "JavaScript/24",
    "prompt": {
      "en": "\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * Parameters:\n * - integer_value (number): The input integer.\n * - char_value (string): The input character.\n * Returns:\n * - string: A string containing the integer and character separated by a comma.\n * Examples:\n * process_integer_and_char(234, 'H') returns '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "sq": "/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\n * Parametrat:\n * - integer_value (number): Numri i plotë i futur.\n * - char_value (string): Karakteri i futur.\n * Kthen:\n * - string: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n * Shembuj:\n * process_integer_and_char(234, 'H') kthen '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "hy": "/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, բաժանված ստորակետով։\n * Պարամետրեր:\n * - integer_value (number): Մուտքային ամբողջ թիվը։\n * - char_value (string): Մուտքային սիմվոլը։\n * Վերադարձնում է:\n * - string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n * Օրինակներ:\n * process_integer_and_char(234, 'H') վերադարձնում է '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "bn": "/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে কমা দ্বারা পৃথক করা একটি বিন্যাসিত স্ট্রিং হিসাবে ফেরত দেয়।\n * প্যারামিটার:\n * - integer_value (number): ইনপুট পূর্ণসংখ্যা।\n * - char_value (string): ইনপুট অক্ষর।\n * ফেরত দেয়:\n * - string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।\n * উদাহরণ:\n * process_integer_and_char(234, 'H') '234,H' ফেরত দেয়\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "bg": "/**\n * Чете цяло число и символ, след това ги връща като форматиран низ, разделен със запетая.\n * Параметри:\n * - integer_value (number): Входното цяло число.\n * - char_value (string): Входният символ.\n * Връща:\n * - string: Низ, съдържащ цялото число и символа, разделени със запетая.\n * Примери:\n * process_integer_and_char(234, 'H') връща '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "zh": "/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * 参数：\n * - integer_value (number): 输入的整数。\n * - char_value (string): 输入的字符。\n * 返回：\n * - string: 一个包含整数和字符并用逗号分隔的字符串。\n * 示例：\n * process_integer_and_char(234, 'H') 返回 '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "fr": "/**\n * Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n * Paramètres :\n * - integer_value (number): L'entier d'entrée.\n * - char_value (string): Le caractère d'entrée.\n * Renvoie :\n * - string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * Exemples :\n * process_integer_and_char(234, 'H') returns '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "de": "/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\n * Parameter:\n * - integer_value (number): Die Eingabeganzzahl.\n * - char_value (string): Das Eingabezeichen.\n * Rückgabewerte:\n * - string: Eine Zeichenkette, die die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n * Beispiele:\n * process_integer_and_char(234, 'H') gibt '234,H' zurück\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "ha": "/**\n * Karanta lamba mai cikakken adadi da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alamar kwalliya.\n * Sigogi:\n * - integer_value (number): Lambar da aka shigar.\n * - char_value (string): Alamar da aka shigar.\n * Mayarwa:\n * - string: Wani tsari na rubutu da ke dauke da lambar da alamar da aka raba su da alamar kwalliya.\n * Misalai:\n * process_integer_and_char(234, 'H') returns '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "hi": "/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * पैरामीटर:\n * - integer_value (number): इनपुट पूर्णांक।\n * - char_value (string): इनपुट वर्ण।\n * लौटाता है:\n * - string: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।\n * उदाहरण:\n * process_integer_and_char(234, 'H') '234,H' लौटाता है\n */\nfunction process_integer_and_char(integer_value, char_value)",
      "hu": "/**\n * Beolvas egy egész számot és egy karaktert, majd formázott sztringként adja vissza őket vesszővel elválasztva.\n * Paraméterek:\n * - integer_value (number): A bemeneti egész szám.\n * - char_value (string): A bemeneti karakter.\n * Visszatérési érték:\n * - string: Egy sztring, amely az egész számot és a karaktert tartalmazza vesszővel elválasztva.\n * Példák:\n * process_integer_and_char(234, 'H') visszaadja '234,H'\n */\nfunction process_integer_and_char(integer_value, char_value)"
    },
    "prompt_bertscore": {
      "sq": "0.9917862364834453",
      "hy": "0.9843352136300646",
      "bn": "0.9788182547968206",
      "bg": "0.9951909598447644",
      "zh": "0.9934978344768229",
      "fr": "0.9965281395698912",
      "de": "0.9882506157010243",
      "ha": "0.9812149289743876",
      "hi": "0.9456134126295993",
      "hu": "0.9904524334747961"
    },
    "canonical_solution": "{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function process_integer_and_char(integer_value, char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\nExamples:\nprocess_integer_and_char(234, 'H') returns '234,H'\n",
      "sq": "Shkruani një funksion JavaScript `function process_integer_and_char(integer_value, char_value)` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\nParametrat:\n- integer_value (number): Numri i plotë i dhënë.\n- char_value (string): Karakteri i dhënë.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\nShembuj:\nprocess_integer_and_char(234, 'H') kthen '234,H'",
      "hy": "Գրեք JavaScript ֆունկցիա `function process_integer_and_char(integer_value, char_value)` լուծելու համար հետևյալ խնդիրը:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, բաժանված ստորակետով։\nՊարամետրեր:\n- integer_value (number): Մուտքային ամբողջ թիվը։\n- char_value (string): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\nՕրինակներ:\nprocess_integer_and_char(234, 'H') վերադարձնում է '234,H'",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function process_integer_and_char(integer_value, char_value)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি বিন্যাসিত স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটারসমূহ:\n- integer_value (number): ইনপুট পূর্ণসংখ্যা।\n- char_value (string): ইনপুট অক্ষর।\nফেরত দেয়:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\nউদাহরণসমূহ:\nprocess_integer_and_char(234, 'H') returns '234,H'",
      "bg": "Напишете JavaScript функция `function process_integer_and_char(integer_value, char_value)` за решаване на следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (number): Входното цяло число.\n- char_value (string): Входният символ.\nВръща:\n- string: Низ, съдържащ числото и символа, разделени със запетая.\nПримери:\nprocess_integer_and_char(234, 'H') връща '234,H'",
      "zh": "编写一个 JavaScript 函数 `function process_integer_and_char(integer_value, char_value)` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (number): 输入的整数。\n- char_value (string): 输入的字符。\n返回：\n- string: 包含整数和字符并用逗号分隔的字符串。\n示例：\nprocess_integer_and_char(234, 'H') 返回 '234,H'",
      "fr": "Écrire une fonction JavaScript `function process_integer_and_char(integer_value, char_value)` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (number): L'entier d'entrée.\n- char_value (string): Le caractère d'entrée.\nRenvoie :\n- string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\nExemples :\nprocess_integer_and_char(234, 'H') renvoie '234,H'",
      "de": "Schreiben Sie eine JavaScript-Funktion `function process_integer_and_char(integer_value, char_value)`, um das folgende Problem zu lösen:\nLiest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (number): Die Eingabe-Ganzzahl.\n- char_value (string): Das Eingabe-Zeichen.\nGibt zurück:\n- string: Eine Zeichenkette, die die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\nBeispiele:\nprocess_integer_and_char(234, 'H') gibt '234,H' zurück.",
      "ha": "Rubuta wani aikin JavaScript `function process_integer_and_char(integer_value, char_value)` don magance matsalar mai zuwa:\nKaranta wani cikakken lamba da wata alama, sannan ya mayar da su a matsayin jeren haruffa da aka tsara da kwancewa ta hanyar alama.\nSigogi:\n- integer_value (number): Cikakken lambar shigarwa.\n- char_value (string): Alamar shigarwa.\nMayarwa:\n- string: Jeren haruffa da ke dauke da cikakken lamba da alama da aka raba ta hanyar alama.\nMisalai:\nprocess_integer_and_char(234, 'H') returns '234,H'",
      "hi": "एक JavaScript फ़ंक्शन `function process_integer_and_char(integer_value, char_value)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके वापस करता है।\nपैरामीटर्स:\n- integer_value (number): इनपुट पूर्णांक।\n- char_value (string): इनपुट वर्ण।\nवापसी:\n- string: एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम द्वारा अलग करके रखती है।\nउदाहरण:\nprocess_integer_and_char(234, 'H') '234,H' लौटाता है।",
      "hu": "Írj egy JavaScript függvényt `function process_integer_and_char(integer_value, char_value)` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott sztringként vesszővel elválasztva.\nParaméterek:\n- integer_value (number): A bemeneti egész szám.\n- char_value (string): A bemeneti karakter.\nVisszatérési érték:\n- string: Egy sztring, amely az egész számot és a karaktert tartalmazza vesszővel elválasztva.\nPéldák:\nprocess_integer_and_char(234, 'H') visszaadja '234,H'"
    },
    "instruction_bertscore": {
      "sq": "0.9893659252905352",
      "hy": "0.9913506400578358",
      "bn": "0.9896481790619858",
      "bg": "0.9931369230744825",
      "zh": "0.9939014514110859",
      "fr": "1",
      "de": "0.9824629236584297",
      "ha": "0.9578454687544898",
      "hi": "0.9772246432497776",
      "hu": "0.9922017712405703"
    },
    "level": "easy",
    "test": "const testProcessIntegerAndChar = () => {\n    console.assert(process_integer_and_char(234, 'H') === '234,H', 'Test 1 Failed');\n    console.assert(process_integer_and_char(123, 'A') === '123,A', 'Test 2 Failed');\n    console.assert(process_integer_and_char(0, 'Z') === '0,Z', 'Test 3 Failed');\n}\n\ntestProcessIntegerAndChar();",
    "entry_point": "process_integer_and_char",
    "signature": "function process_integer_and_char(integer_value, char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\nParameters:\n- integer_value (number): The input integer.\n- char_value (string): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\nExamples:\nprocess_integer_and_char(234, 'H') returns '234,H'\n",
      "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (number): Numri i plotë i futur.\n- char_value (string): Karakteri i futur.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\nShembuj:\nprocess_integer_and_char(234, 'H') kthen '234,H'",
      "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (number): Մուտքագրված ամբողջ թիվը։\n- char_value (string): Մուտքագրված սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\nՕրինակներ:\nprocess_integer_and_char(234, 'H') վերադարձնում է '234,H'",
      "bn": "একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি বিন্যাসিত স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nপ্যারামিটারসমূহ:  \n- integer_value (number): ইনপুট পূর্ণসংখ্যা।  \n- char_value (string): ইনপুট অক্ষর।  \nReturns:  \n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।  \nExamples:  \nprocess_integer_and_char(234, 'H') returns '234,H'  ",
      "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (number): Входното цяло число.\n- char_value (string): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\nПримери:\nprocess_integer_and_char(234, 'H') връща '234,H'",
      "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n参数：\n- integer_value (number): 输入的整数。\n- char_value (string): 输入的字符。\n返回：\n- string: 一个包含整数和字符并用逗号分隔的字符串。\n示例：\nprocess_integer_and_char(234, 'H') 返回 '234,H'",
      "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (number): L'entier d'entrée.\n- char_value (string): Le caractère d'entrée.\nRenvoie :\n- string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\nExemples :\nprocess_integer_and_char(234, 'H') renvoie '234,H'",
      "de": "Liest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierten String zurück, getrennt durch ein Komma.\nParameter:\n- integer_value (number): Die Eingabe-Ganzzahl.\n- char_value (string): Das Eingabe-Zeichen.\nRückgabewert:\n- string: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\nBeispiele:\nprocess_integer_and_char(234, 'H') gibt '234,H' zurück.",
      "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin kirtani mai tsari wanda aka raba da alamar kwafi.\nSigogi:\n- integer_value (number): Lambar shigarwa.\n- char_value (string): Alamar shigarwa.\nDawowa:\n- string: Wani kirtani da ke dauke da lambar da alamar da aka raba da alamar kwafi.\nMisalai:\nprocess_integer_and_char(234, 'H') yana dawowa '234,H'",
      "hi": "एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके वापस करता है।\nपैरामीटरs:  \n- integer_value (number): इनपुट पूर्णांक।  \n- char_value (string): इनपुट वर्ण।  \nReturns:  \n- string: एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम से अलग करके रखती है।  \nExamples:  \nprocess_integer_and_char(234, 'H') returns '234,H'  ",
      "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\nParaméterek:\n- integer_value (number): A bemeneti egész szám.\n- char_value (string): A bemeneti karakter.\nVisszatérési érték:\n- string: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\nPéldák:\nprocess_integer_and_char(234, 'H') visszaadja '234,H'"
    },
    "docstring_bertscore": {
      "sq": "0.990030741175859",
      "hy": "0.9896505626265582",
      "bn": "0.9778733700742376",
      "bg": "0.9896505626265582",
      "zh": "0.9909106737638436",
      "fr": "1",
      "de": "0.9793364814609405",
      "ha": "0.9780018839307671",
      "hi": "0.983454883781318",
      "hu": "0.972660712984739"
    }
  },
  {
    "task_id": "JavaScript/25",
    "prompt": {
      "en": "\n/**\n * Shifts all characters by 5 positions in alphabetical order.\n * Only letters are replaced, and all letters are in uppercase.\n *\n * @param {string} text The input text to be processed.\n * @returns {string} The transformed text with characters shifted by 5 positions.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "sq": "/**\n * Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik.\n * Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n *\n * @param {string} text Teksti hyrës që do të përpunohet.\n * @returns {string} Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "hy": "/**\n * Տեղափոխում է բոլոր նիշերը 5 դիրքով այբբենական կարգով:\n * Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n *\n * @param {string} text Մուտքային տեքստը, որը պետք է մշակվի:\n * @returns {string} Փոխակերպված տեքստը՝ նիշերը տեղափոխված 5 դիրքով:\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "bn": "/**\n * বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে সরিয়ে দেয়।\n * শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n *\n * @param {string} text প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n * @returns {string} রূপান্তরিত টেক্সট যা অক্ষরগুলি ৫ অবস্থানে সরানো হয়েছে।\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "bg": "/**\n * Премества всички символи с 5 позиции в азбучен ред.\n * Само буквите се заменят, и всички букви са с главни букви.\n *\n * @param {string} text Входният текст, който ще бъде обработен.\n * @returns {string} Преобразуваният текст със символи, преместени с 5 позиции.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "zh": "/**\n * 将所有字符按字母顺序移动5个位置。\n * 只有字母被替换，并且所有字母都是大写。\n *\n * @param {string} text 要处理的输入文本。\n * @returns {string} 字符移动5个位置后的转换文本。\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "fr": "/**\n * Décale tous les caractères de 5 positions dans l'ordre alphabétique.\n * Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n *\n * @param {string} text Le texte d'entrée à traiter.\n * @returns {string} Le texte transformé avec les caractères décalés de 5 positions.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "de": "/**\n * Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\n * Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n *\n * @param {string} text Der Eingabetext, der verarbeitet werden soll.\n * @returns {string} Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "ha": "/**\n * Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa.\n * Sai dai haruffa ne kawai za a maye gurbin, kuma duk haruffa suna cikin manyan baƙaƙe.\n *\n * @param {string} text Rubutun shigar da za a sarrafa.\n * @returns {string} Rubutun da aka sauya tare da haruffa da aka matsar da su wurare 5.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "hi": "/**\n * वर्णमाला क्रम में सभी वर्णों को 5 स्थानों से स्थानांतरित करता है।\n * केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n *\n * @param {string} text वह इनपुट पाठ जिसे संसाधित किया जाना है।\n * @returns {string} परिवर्तित पाठ जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)",
      "hu": "/**\n * Az összes karaktert 5 pozícióval eltolja az ábécé sorrendjében.\n * Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n *\n * @param {string} text A feldolgozandó bemeneti szöveg.\n * @returns {string} Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n *\n * @example\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * // returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text)"
    },
    "prompt_bertscore": {
      "sq": "0.9887573218030443",
      "hy": "0.9813646962816879",
      "bn": "0.9791783716776368",
      "bg": "0.9956744261922033",
      "zh": "0.9699301411366524",
      "fr": "0.9941320612834673",
      "de": "1",
      "ha": "0.954556149644552",
      "hi": "0.9968203248603935",
      "hu": "0.967952577063069"
    },
    "canonical_solution": "{\n    let shiftedText = '';\n    for (let i = 0; i < text.length; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) + 21); // 'V' - 'A' = 21\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            shiftedText += String.fromCharCode(text.charCodeAt(i) - 5); // 'A' - 'F' = -5\n        } else {\n            shiftedText += text[i];\n        }\n    }\n    return shiftedText;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function shiftCharacters(text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n\nExample:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Shkruani një funksion JavaScript `function shiftCharacters(text)` për të zgjidhur problemin e mëposhtëm: \nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. \nVetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\n- text (string): Teksti hyrës që do të përpunohet.\n\nKthen:\n- string: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// kthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Գրեք JavaScript ֆունկցիա `function shiftCharacters(text)` հետևյալ խնդիրը լուծելու համար:\nՏեղաշարժում է բոլոր տառերը 5 դիրքով այբբենական կարգով:\nՄիայն տառերը են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\n- text (string): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\n- string: Փոխակերպված տեքստը, որտեղ տառերը տեղաշարժված են 5 դիրքով:\n\nՕրինակ:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// վերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function shiftCharacters(text)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবর্ণানুক্রমিক ক্রমে সমস্ত অক্ষর ৫ পজিশন সরিয়ে দেয়।\nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটারসমূহ:\n- text (string): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nফেরত দেয়:\n- string: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ পজিশন সরানো হয়েছে।\n\nউদাহরণ:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Напишете JavaScript функция `function shiftCharacters(text)`, за да решите следния проблем:\nПремества всички символи с 5 позиции в азбучен ред.\nСамо буквите се заменят и всички букви са с главни букви.\n\nПараметри:\n- text (string): Входният текст, който ще бъде обработен.\n\nВръща:\n- string: Преобразуваният текст със символи, преместени с 5 позиции.\n\nПример:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// връща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "编写一个 JavaScript 函数 `function shiftCharacters(text)` 来解决以下问题：\n将所有字符在字母表中移动5个位置。\n只有字母被替换，并且所有字母都是大写。\n\n参数：\n- text (string): 要处理的输入文本。\n\n返回：\n- string: 字符移动了5个位置的转换文本。\n\n示例：\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Écrire une fonction JavaScript `function shiftCharacters(text)` pour résoudre le problème suivant :  \nDécale tous les caractères de 5 positions dans l'ordre alphabétique.  \nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :  \n- text (string) : Le texte d'entrée à traiter.\n\nRenvoie :  \n- string : Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :  \n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n// renvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Schreiben Sie eine JavaScript-Funktion `function shiftCharacters(text)`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\n- text (string): Der zu verarbeitende Eingabetext.\n\nRückgabewert:\n- string: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// gibt zurück \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Rubuta wani aikin JavaScript `function shiftCharacters(text)` don warware matsalar mai zuwa:\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsari na haruffa.\nHaruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\n- text (string): Rubutun shigar da za a sarrafa.\n\nDawowa:\n- string: Rubutun da aka canza tare da haruffa da aka matsar da wurare 5.\n\nMisali:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "JavaScript फ़ंक्शन `function shiftCharacters(text)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।\nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में हैं।\n\nपैरामीटर्स:\n- text (string): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\nरिटर्न करता है:\n- string: स्थानांतरित किए गए वर्णों के साथ परिवर्तित टेक्स्ट।\n\nउदाहरण:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Írj egy JavaScript függvényt `function shiftCharacters(text)` a következő probléma megoldására:\nAz összes karaktert 5 pozícióval eltolja ábécé sorrendben.\nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\n- text (string): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\n- string: Az átalakított szöveg, ahol a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// visszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "sq": "0.9898791861951294",
      "hy": "0.9866983192732366",
      "bn": "0.9604177321888916",
      "bg": "0.9935502728974162",
      "zh": "0.964166284739782",
      "fr": "0.9905853171997083",
      "de": "0.9854680026931065",
      "ha": "0.9666161918594663",
      "hi": "0.9486278272921848",
      "hu": "0.9922645384409773"
    },
    "level": "middle",
    "test": "const testShiftCharacters = () => {\n    console.assert(shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\", 'Test 1 failed');\n    console.assert(shiftCharacters(\"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\") === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\", 'Test 2 failed');\n    console.assert(shiftCharacters(\"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\") === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\", 'Test 3 failed');\n};\n\ntestShiftCharacters();",
    "entry_point": "shiftCharacters",
    "signature": "function shiftCharacters(text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\n- text (string): The input text to be processed.\n\nReturns:\n- string: The transformed text with characters shifted by 5 positions.\n\nExample:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\n- text (string): Teksti hyrës që do të përpunohet.\n\nKthen:\n- string: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// kthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Տեղափոխում է բոլոր տառերը այբբենական կարգով 5 դիրքով:\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\n- text (string): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\n- string: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\nՕրինակ:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// վերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে স্থানান্তর করে।\nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n\nপ্যারামিটার:\n- text (string): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nফেরত দেয়:\n- string: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫টি অবস্থানে স্থানান্তরিত হয়।\n\nউদাহরণ:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// ফেরত দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Изместете всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\nПараметри:\n- text (string): Входният текст, който ще бъде обработен.\n\nВръща:\n- string: Преобразуваният текст със символи, изместени с 5 позиции.\n\nПример:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// връща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "将所有字符在字母表中向后移动5个位置。  \n只有字母会被替换，并且所有字母都是大写。\n\n参数:  \n- text (string): 要处理的输入文本。\n\n返回:  \n- string: 字符被移动5个位置后的转换文本。\n\n示例:  \n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n// 返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique.\nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres:\n- text (string): Le texte d'entrée à traiter.\n\nRenvoie:\n- string: Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\n- text (string): Der zu verarbeitende Eingabetext.\n\nRückgabewert:\n- string: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// gibt \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" zurück",
      "ha": "Canza dukkan haruffa da matsayi 5 a cikin tsarin haruffa na alfabeti. \nHaruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\n- text (string): Rubutun shigarwa da za a sarrafa.\n\nDawowa:\n- string: Rubutun da aka canza tare da haruffa da aka matsa da matsayi 5.\n\nMisali:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "सभी वर्णों को वर्णानुक्रम में 5 स्थानों से स्थानांतरित करता है।  \nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\n- text (string): इनपुट पाठ जिसे संसाधित किया जाना है।\n\nवापसी:\n- string: परिवर्तित पाठ जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\nउदाहरण:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Eltolja az összes karaktert 5 pozícióval az ábécé sorrendjében.\nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\n- text (string): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\n- string: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\nPélda:\n- shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n// visszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.9895270145295545",
      "hy": "0.9735416387246287",
      "bn": "0.9489748345678527",
      "bg": "0.9805435582864896",
      "zh": "0.9578768523546933",
      "fr": "0.9866953398175211",
      "de": "0.9853410778796252",
      "ha": "0.9605039377742608",
      "hi": "0.9689981673888367",
      "hu": "0.9744885097510221"
    }
  },
  {
    "task_id": "JavaScript/26",
    "prompt": {
      "en": "\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9\n*/\nfunction classify_integer(x)",
      "sq": "/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa \nklasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\nclassify_integer(\"24\") // kthen 6\nclassify_integer(\"39\") // kthen 3\nclassify_integer(\"123456789\") // kthen 9\nclassify_integer(\"123456789012345678901234567890\") // kthen 9\nclassify_integer(\"12345\") // kthen 6\nclassify_integer(\"999999999\") // kthen 9\n*/\nfunction classify_integer(x)",
      "hy": "/*\nԴասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև \nդասը որոշվի:\n\nՊարամետրեր:\n- x (string): Ամբողջ թիվը, որը պետք է դասակարգվի որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\nclassify_integer(\"24\") // վերադարձնում է 6\nclassify_integer(\"39\") // վերադարձնում է 3\nclassify_integer(\"123456789\") // վերադարձնում է 9\nclassify_integer(\"123456789012345678901234567890\") // վերադարձնում է 9\nclassify_integer(\"12345\") // վերադարձնում է 6\nclassify_integer(\"999999999\") // վերադարձնում է 9\n*/\nfunction classify_integer(x)",
      "bn": "/*\nইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nপ্যারামিটার:\n- x (string): ইন্টিজারটি একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করার জন্য।\n\nরিটার্নস:\nint: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\nউদাহরণ:\nclassify_integer(\"24\") // 6 রিটার্ন করে\nclassify_integer(\"39\") // 3 রিটার্ন করে\nclassify_integer(\"123456789\") // 9 রিটার্ন করে\nclassify_integer(\"123456789012345678901234567890\") // 9 রিটার্ন করে\nclassify_integer(\"12345\") // 6 রিটার্ন করে\nclassify_integer(\"999999999\") // 9 রিটার্ন করে\n*/\nfunction classify_integer(x)",
      "bg": "/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x, и итерайте, докато\nкласът бъде определен.\n\nПараметри:\n- x (string): Цялото число, което трябва да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nПримери:\nclassify_integer(\"24\") // връща 6\nclassify_integer(\"39\") // връща 3\nclassify_integer(\"123456789\") // връща 9\nclassify_integer(\"123456789012345678901234567890\") // връща 9\nclassify_integer(\"12345\") // връща 6\nclassify_integer(\"999999999\") // връща 9\n*/\nfunction classify_integer(x)",
      "zh": "/*\n根据以下方法对整数 x 进行分类：\n如果 x 是一位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类别。\n\n示例：\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9\n*/\nfunction classify_integer(x)",
      "fr": "/*\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que \nla classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\nclassify_integer(\"24\") // renvoie 6\nclassify_integer(\"39\") // renvoie 3\nclassify_integer(\"123456789\") // renvoie 9\nclassify_integer(\"123456789012345678901234567890\") // renvoie 9\nclassify_integer(\"12345\") // renvoie 6\nclassify_integer(\"999999999\") // renvoie 9\n*/\nfunction classify_integer(x)",
      "de": "/*\nKlassifiziere die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis \ndie Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als Zeichenkette zu klassifizierende ganze Zahl.\n\nRückgabe:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\nclassify_integer(\"24\") // gibt 6 zurück\nclassify_integer(\"39\") // gibt 3 zurück\nclassify_integer(\"123456789\") // gibt 9 zurück\nclassify_integer(\"123456789012345678901234567890\") // gibt 9 zurück\nclassify_integer(\"12345\") // gibt 6 zurück\nclassify_integer(\"999999999\") // gibt 9 zurück\n*/\nfunction classify_integer(x)",
      "ha": "/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x tana cikin ajin kanta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \najin ya ƙayyade.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin kirtani.\n\nDawowa:\nint: Ajin da lambar x ta ke ciki.\n\nMisalai:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9\n*/\nfunction classify_integer(x)",
      "hi": "/*\nपूर्णांक x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \nजब तक कि श्रेणी निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nवापसी मान:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nउदाहरण:\nclassify_integer(\"24\") // 6 लौटाता है\nclassify_integer(\"39\") // 3 लौटाता है\nclassify_integer(\"123456789\") // 9 लौटाता है\nclassify_integer(\"123456789012345678901234567890\") // 9 लौटाता है\nclassify_integer(\"12345\") // 6 लौटाता है\nclassify_integer(\"999999999\") // 9 लौटाता है\n*/\nfunction classify_integer(x)",
      "hu": "/*\nOsztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként adja össze x számjegyeit, kapjon egy új x-et, és ismételje, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az egész szám, amelyet karakterláncként kell osztályozni.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9\n*/\nfunction classify_integer(x)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9876422108439145",
      "bn": "0.9615876651331872",
      "bg": "1",
      "zh": "0.9731972136439142",
      "fr": "0.9887313012231287",
      "de": "0.9983767925261829",
      "ha": "0.9749616473186472",
      "hi": "0.972432685307311",
      "hu": "0.9805981816412742"
    },
    "canonical_solution": "{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i], 10);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function classify_integer(x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "sq": "Shkruani një funksion JavaScript `function classify_integer(x)` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri, dhe përsëritni derisa\nklasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë për t'u klasifikuar si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "hy": "Գրեք JavaScript ֆունկցիա `function classify_integer(x)` հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև \nդասը որոշվի:\n\nՊարամետրեր:\n- x (string): Դասակարգվող ամբողջ թիվը որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x:\n\nՕրինակներ:\nclassify_integer(\"24\") // վերադարձնում է 6\nclassify_integer(\"39\") // վերադարձնում է 3\nclassify_integer(\"123456789\") // վերադարձնում է 9\nclassify_integer(\"123456789012345678901234567890\") // վերադարձնում է 9\nclassify_integer(\"12345\") // վերադարձնում է 6\nclassify_integer(\"999999999\") // վերադարձնում է 9",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function classify_integer(x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজের শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nপ্যারামিটারসমূহ:\n- x (string): পূর্ণসংখ্যা যা একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করা হবে।\n\nরিটার্নস:\nint: শ্রেণী যা পূর্ণসংখ্যা x এর অন্তর্ভুক্ত।\n\nউদাহরণসমূহ:\nclassify_integer(\"24\") // 6 রিটার্ন করে\nclassify_integer(\"39\") // 3 রিটার্ন করে\nclassify_integer(\"123456789\") // 9 রিটার্ন করে\nclassify_integer(\"123456789012345678901234567890\") // 9 রিটার্ন করে\nclassify_integer(\"12345\") // 6 রিটার্ন করে\nclassify_integer(\"999999999\") // 9 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function classify_integer(x)`, за да решите следния проблем:\nКласифицирайте целочисленото x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\n\nПараметри:\n- x (string): Целочисленото число, което да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи целочисленото x.\n\nПримери:\nclassify_integer(\"24\") // връща 6\nclassify_integer(\"39\") // връща 3\nclassify_integer(\"123456789\") // връща 9\nclassify_integer(\"123456789012345678901234567890\") // връща 9\nclassify_integer(\"12345\") // връща 6\nclassify_integer(\"999999999\") // връща 9",
      "zh": "编写一个 JavaScript 函数 `function classify_integer(x)` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于其自身的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类。\n\n示例：\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "fr": "Écrire une fonction JavaScript `function classify_integer(x)` pour résoudre le problème suivant :\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "de": "Schreiben Sie eine JavaScript-Funktion `function classify_integer(x)`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis \ndie Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als Zeichenfolge zu klassifizierende ganze Zahl.\n\nRückgabewert:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "ha": "Rubuta aikin JavaScript `function classify_integer(x)` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce guda ɗaya, x tana cikin ajin kanta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \najin ya ƙayyade.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin kirtani.\n\nDawowa:\nint: Aji wanda lambar x take ciki.\n\nMisalai:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "hi": "JavaScript फ़ंक्शन `function classify_integer(x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \nजब तक वर्ग निर्धारित नहीं हो जाता।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nरिटर्न्स:\nint: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\nउदाहरण:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "hu": "Írj egy JavaScript függvényt `function classify_integer(x)` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egy egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg \naz osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám stringként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9"
    },
    "instruction_bertscore": {
      "sq": "0.9927795870190008",
      "hy": "0.9888933836140532",
      "bn": "0.9713404168420001",
      "bg": "0.9990938482017189",
      "zh": "0.9820646697444547",
      "fr": "0.9889944864779999",
      "de": "0.9867444015216368",
      "ha": "0.9784184118397973",
      "hi": "0.9812655797215514",
      "hu": "0.9973766885576723"
    },
    "level": "easy",
    "test": "function testClassifyInteger() {\n    console.assert(classify_integer(\"24\") === 6, \"Test failed: classify_integer('24') should return 6.\");\n    console.assert(classify_integer(\"39\") === 3, \"Test failed: classify_integer('39') should return 3.\");\n    console.assert(classify_integer(\"123456789\") === 9, \"Test failed: classify_integer('123456789') should return 9.\");\n    console.assert(classify_integer(\"123456789012345678901234567890\") === 9, \"Test failed: classify_integer('123456789012345678901234567890') should return 9.\");\n    console.assert(classify_integer(\"12345\") === 6, \"Test failed: classify_integer('12345') should return 6.\");\n    console.assert(classify_integer(\"999999999\") === 9, \"Test failed: classify_integer('999999999') should return 9.\");\n}\n\ntestClassifyInteger();",
    "entry_point": "classify_integer",
    "signature": "function classify_integer(x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until \nthe class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa \nklasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\nclassify_integer(\"24\") // kthen 6\nclassify_integer(\"39\") // kthen 3\nclassify_integer(\"123456789\") // kthen 9\nclassify_integer(\"123456789012345678901234567890\") // kthen 9\nclassify_integer(\"12345\") // kthen 6\nclassify_integer(\"999999999\") // kthen 9",
      "hy": "Դասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև \nդասը որոշվի:\n\nՊարամետրեր:\n- x (string): Որպես տող դասակարգվելիք ամբողջ թիվը:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\nclassify_integer(\"24\") // վերադարձնում է 6\nclassify_integer(\"39\") // վերադարձնում է 3\nclassify_integer(\"123456789\") // վերադարձնում է 9\nclassify_integer(\"123456789012345678901234567890\") // վերադարձնում է 9\nclassify_integer(\"12345\") // վերադարձնում է 6\nclassify_integer(\"999999999\") // վերադարձնում է 9",
      "bn": "ইন্টিজার x কে নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-সংখ্যার সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nপ্যারামিটার:\n- x (string): ইন্টিজারটি একটি স্ট্রিং হিসেবে শ্রেণীবদ্ধ করার জন্য।\n\nরিটার্নস:\nint: শ্রেণী যেখানে ইন্টিজার x অন্তর্ভুক্ত।\n\nউদাহরণ:\nclassify_integer(\"24\") // 6 রিটার্ন করে\nclassify_integer(\"39\") // 3 রিটার্ন করে\nclassify_integer(\"123456789\") // 9 রিটার্ন করে\nclassify_integer(\"123456789012345678901234567890\") // 9 রিটার্ন করে\nclassify_integer(\"12345\") // 6 রিটার্ন করে\nclassify_integer(\"999999999\") // 9 রিটার্ন করে",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи на своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и повтаряйте, докато класът бъде определен.\n\nПараметри:\n- x (string): Цялото число, което трябва да бъде класифицирано, като низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nПримери:\nclassify_integer(\"24\") // връща 6\nclassify_integer(\"39\") // връща 3\nclassify_integer(\"123456789\") // връща 9\nclassify_integer(\"123456789012345678901234567890\") // връща 9\nclassify_integer(\"12345\") // връща 6\nclassify_integer(\"999999999\") // връща 9",
      "zh": "将整数 x 分类，基于以下方法：\n如果 x 是一个个位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类。\n\n示例：\nclassify_integer(\"24\") // 返回 6\nclassify_integer(\"39\") // 返回 3\nclassify_integer(\"123456789\") // 返回 9\nclassify_integer(\"123456789012345678901234567890\") // 返回 9\nclassify_integer(\"12345\") // 返回 6\nclassify_integer(\"999999999\") // 返回 9",
      "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string): L'entier à classer sous forme de chaîne de caractères.\n\nRenvoie :\nint: La classe à laquelle appartient l'entier x.\n\nExemples :\nclassify_integer(\"24\") // renvoie 6\nclassify_integer(\"39\") // renvoie 3\nclassify_integer(\"123456789\") // renvoie 9\nclassify_integer(\"123456789012345678901234567890\") // renvoie 9\nclassify_integer(\"12345\") // renvoie 6\nclassify_integer(\"999999999\") // renvoie 9",
      "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen, bis \ndie Klasse bestimmt ist.\n\nParameter:\n- x (string): Die zu klassifizierende ganze Zahl als Zeichenkette.\n\nRückgabewerte:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\nclassify_integer(\"24\") // gibt 6 zurück\nclassify_integer(\"39\") // gibt 3 zurück\nclassify_integer(\"123456789\") // gibt 9 zurück\nclassify_integer(\"123456789012345678901234567890\") // gibt 9 zurück\nclassify_integer(\"12345\") // gibt 6 zurück\nclassify_integer(\"999999999\") // gibt 9 zurück",
      "ha": "Rarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \nan tantance ajin.\n\nParameters:\n- x (string): Lambar da za a tantance a matsayin kirtani.\n\nReturns:\nint: Aji wanda lambar x take ciki.\n\nExamples:\nclassify_integer(\"24\") // returns 6\nclassify_integer(\"39\") // returns 3\nclassify_integer(\"123456789\") // returns 9\nclassify_integer(\"123456789012345678901234567890\") // returns 9\nclassify_integer(\"12345\") // returns 6\nclassify_integer(\"999999999\") // returns 9",
      "hi": "पूरे संख्या x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल अंक की संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): पूर्णांक को एक स्ट्रिंग के रूप में वर्गीकृत करने के लिए।\n\nवापसी:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nउदाहरण:\nclassify_integer(\"24\") // 6 लौटाता है\nclassify_integer(\"39\") // 3 लौटाता है\nclassify_integer(\"123456789\") // 9 लौटाता है\nclassify_integer(\"123456789012345678901234567890\") // 9 लौटाता है\nclassify_integer(\"12345\") // 6 लौटाता है\nclassify_integer(\"999999999\") // 9 लौटाता है",
      "hu": "Osztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként adja össze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám sztringként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\nclassify_integer(\"24\") // visszaadja 6\nclassify_integer(\"39\") // visszaadja 3\nclassify_integer(\"123456789\") // visszaadja 9\nclassify_integer(\"123456789012345678901234567890\") // visszaadja 9\nclassify_integer(\"12345\") // visszaadja 6\nclassify_integer(\"999999999\") // visszaadja 9"
    },
    "docstring_bertscore": {
      "sq": "0.9912525166496046",
      "hy": "0.9884552049934903",
      "bn": "0.963858606279559",
      "bg": "0.9874551010249796",
      "zh": "0.975005941893618",
      "fr": "0.9826327526342146",
      "de": "0.9895971310540598",
      "ha": "0.9774574380563505",
      "hi": "0.9606997873299612",
      "hu": "0.9860015238965663"
    }
  },
  {
    "task_id": "JavaScript/27",
    "prompt": {
      "en": "\n/**\n * Transforms the case of a given letter.\n * - letter (char): The input letter to be transformed.\n * \n * Returns:\n * - char: The letter with its case reversed. If the input is lowercase,\n * returns uppercase, and if the input is uppercase, returns lowercase.\n * \n * Example:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "sq": "/**\n * Transformon shkronjën e dhënë në rastin tjetër.\n * - letter (char): Shkronja hyrëse që do të transformohet.\n * \n * Kthen:\n * - char: Shkronja me rastin e saj të përmbysur. Nëse hyrja është me shkronja të vogla,\n * kthen me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha, kthen me shkronja të vogla.\n * \n * Shembull:\n * transformLetterCase('b') kthen 'B'\n * transformLetterCase('Z') kthen 'z'\n */\nfunction transformLetterCase(letter)",
      "hy": "/**\n * Փոխակերպում է տրված տառի ռեգիստրը։\n * - letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n * \n * Վերադարձնում է:\n * - char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է,\n * վերադարձնում է մեծատառ, և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ։\n * \n * Օրինակ:\n * transformLetterCase('b') վերադարձնում է 'B'\n * transformLetterCase('Z') վերադարձնում է 'z'\n */\nfunction transformLetterCase(letter)",
      "bn": "/**\n * প্রদত্ত একটি অক্ষরের কেস পরিবর্তন করে।\n * - letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n * \n * রিটার্ন:\n * - char: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়,\n * বড় হাতের রিটার্ন করে, এবং যদি ইনপুট বড় হাতের হয়, ছোট হাতের রিটার্ন করে।\n * \n * উদাহরণ:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "bg": "/**\n * Преобразува регистъра на дадена буква.\n * - letter (char): Входната буква, която ще бъде преобразувана.\n * \n * Връща:\n * - char: Буквата с обърнат регистър. Ако входът е с малки букви,\n * връща с главни букви, и ако входът е с главни букви, връща с малки букви.\n * \n * Пример:\n * transformLetterCase('b') връща 'B'\n * transformLetterCase('Z') връща 'z'\n */\nfunction transformLetterCase(letter)",
      "zh": "/**\n * 转换给定字母的大小写。\n * - letter (char): 要转换的输入字母。\n * \n * 返回:\n * - char: 大小写已转换的字母。如果输入是小写，则返回大写；如果输入是大写，则返回小写。\n * \n * 示例:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "fr": "/**\n * Transforme la casse d'une lettre donnée.\n * - letter (char): La lettre d'entrée à transformer.\n * \n * Renvoie:\n * - char: La lettre avec sa casse inversée. Si l'entrée est en minuscule,\n * renvoie en majuscule, et si l'entrée est en majuscule, renvoie en minuscule.\n * \n * Exemple:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "de": "/**\n * Transformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n * - letter (char): Der Eingabebuchstabe, dessen Groß-/Kleinschreibung transformiert werden soll.\n * \n * Rückgabe:\n * - char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist,\n * wird groß zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird klein zurückgegeben.\n * \n * Beispiel:\n * transformLetterCase('b') gibt 'B' zurück\n * transformLetterCase('Z') gibt 'z' zurück\n */\nfunction transformLetterCase(letter)",
      "ha": "/**\n * Canza yanayin harafin da aka bayar.\n * - letter (char): Harafin da za a canza yanayinsa.\n * \n * Returns:\n * - char: Harafin tare da yanayinsa da aka juya. Idan shigarwar tana cikin ƙananan haruffa,\n * yana dawowa cikin manyan haruffa, kuma idan shigarwar tana cikin manyan haruffa, yana dawowa cikin ƙananan haruffa.\n * \n * Example:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "hi": "/**\n * दिए गए अक्षर के मामले को बदलता है।\n * - letter (char): परिवर्तित किए जाने वाला इनपुट अक्षर।\n * \n * Returns:\n * - char: अक्षर जिसका मामला उलट दिया गया है। यदि इनपुट लोअरकेस है,\n * तो अपरकेस लौटाता है, और यदि इनपुट अपरकेस है, तो लोअरकेस लौटाता है।\n * \n * Example:\n * transformLetterCase('b') returns 'B'\n * transformLetterCase('Z') returns 'z'\n */\nfunction transformLetterCase(letter)",
      "hu": "/**\n * Egy adott betű esetét alakítja át.\n * - letter (char): Az átalakítandó bemeneti betű.\n * \n * Visszatér:\n * - char: A betű megfordított esettel. Ha a bemenet kisbetűs,\n * nagybetűs formában tér vissza, és ha a bemenet nagybetűs, kisbetűs formában tér vissza.\n * \n * Példa:\n * transformLetterCase('b') visszaadja 'B'\n * transformLetterCase('Z') visszaadja 'z'\n */\nfunction transformLetterCase(letter)"
    },
    "prompt_bertscore": {
      "sq": "0.982965259892067",
      "hy": "0.9697039011326537",
      "bn": "0.9508201108076668",
      "bg": "0.9857931606268606",
      "zh": "0.9603237800186621",
      "fr": "0.9790564126236814",
      "de": "0.9726333019921563",
      "ha": "0.954236950622229",
      "hi": "0.9671707678833158",
      "hu": "0.9696816545299778"
    },
    "canonical_solution": "{\n    const charCode = letter.charCodeAt(0);\n    if (charCode >= 'A'.charCodeAt(0) && charCode <= 'Z'.charCodeAt(0)) {\n        // Convert uppercase to lowercase\n        return String.fromCharCode(charCode + ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {\n        // Convert lowercase to uppercase\n        return String.fromCharCode(charCode - ('a'.charCodeAt(0) - 'A'.charCodeAt(0)));\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function transformLetterCase(letter)` to solve the following problem:\nTransforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n\nExample:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "sq": "Shkruani një funksion JavaScript `function transformLetterCase(letter)` për të zgjidhur problemin e mëposhtëm:\nTransformon rastin e një shkronje të dhënë.\n- letter (char): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha, kthen me shkronja të vogla.\n\nShembull:\ntransformLetterCase('b') kthen 'B'\ntransformLetterCase('Z') kthen 'z'",
      "hy": "Գրեք JavaScript ֆունկցիա `function transformLetterCase(letter)` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը։\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ, իսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ։\n\nՕրինակ:\ntransformLetterCase('b') վերադարձնում է 'B'\ntransformLetterCase('Z') վերադարձնում է 'z'",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function transformLetterCase(letter)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nফেরত দেয়:\n- char: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, তাহলে বড় হাতের ফেরত দেয়, এবং যদি ইনপুট বড় হাতের হয়, তাহলে ছোট হাতের ফেরত দেয়।\n\nউদাহরণ:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "bg": "Напишете JavaScript функция `function transformLetterCase(letter)` за решаване на следния проблем:  \nПреобразува регистъра на дадена буква.  \n- letter (char): Входната буква, която ще бъде преобразувана.\n\nВръща:  \n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща с главни букви, и ако входът е с главни букви, връща с малки букви.\n\nПример:  \ntransformLetterCase('b') връща 'B'  \ntransformLetterCase('Z') връща 'z'",
      "zh": "编写一个 JavaScript 函数 `function transformLetterCase(letter)` 来解决以下问题：\n转换给定字母的大小写。\n- letter (char): 要转换的输入字母。\n\n返回：\n- char: 大小写已反转的字母。如果输入是小写，则返回大写；如果输入是大写，则返回小写。\n\n示例：\ntransformLetterCase('b') 返回 'B'\ntransformLetterCase('Z') 返回 'z'",
      "fr": "Écrire une fonction JavaScript `function transformLetterCase(letter)` pour résoudre le problème suivant :  \nTransforme la casse d'une lettre donnée.  \n- letter (char) : La lettre d'entrée à transformer.\n\nRenvoie :  \n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, renvoie en majuscule, et si l'entrée est en majuscule, renvoie en minuscule.\n\nExemple :  \ntransformLetterCase('b') renvoie 'B'  \ntransformLetterCase('Z') renvoie 'z'",
      "de": "Schreiben Sie eine JavaScript-Funktion `function transformLetterCase(letter)`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n- letter (char): Der Eingabebuchstabe, der transformiert werden soll.\n\nRückgabe:\n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird Großbuchstabe zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird Kleinbuchstabe zurückgegeben.\n\nBeispiel:\ntransformLetterCase('b') gibt 'B' zurück\ntransformLetterCase('Z') gibt 'z' zurück",
      "ha": "Rubuta wani aikin JavaScript `function transformLetterCase(letter)` don warware matsalar mai zuwa:\nCanza yanayin harafin da aka bayar.\n- letter (char): Harafin shigarwa da za a canza.\n\nYana dawowa:\n- char: Harafin tare da yanayinsa da aka juya. Idan shigarwar tana cikin ƙananan haruffa, yana dawowa da manyan haruffa, kuma idan shigarwar tana cikin manyan haruffa, yana dawowa da ƙananan haruffa.\n\nMisali:\ntransformLetterCase('b') yana dawowa 'B'\ntransformLetterCase('Z') yana dawowa 'z'",
      "hi": "JavaScript फ़ंक्शन `function transformLetterCase(letter)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के केस को परिवर्तित करता है।\n- letter (char): परिवर्तित किए जाने वाला इनपुट अक्षर।\n\nवापसी:\n- char: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो अपरकेस लौटाता है, और यदि इनपुट अपरकेस है, तो लोअरकेस लौटाता है।\n\nउदाहरण:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "hu": "Írj egy JavaScript függvényt `function transformLetterCase(letter)` a következő probléma megoldására:\nÁtalakítja egy adott betű kis- és nagybetűs formáját.\n- letter (char): Az átalakítandó bemeneti betű.\n\nVisszatérési érték:\n- char: A betű megfordított kis- és nagybetűs formában. Ha a bemenet kisbetűs, nagybetűs formát ad vissza, és ha a bemenet nagybetűs, kisbetűs formát ad vissza.\n\nPélda:\ntransformLetterCase('b') visszaadja 'B'\ntransformLetterCase('Z') visszaadja 'z'"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9828192665620064",
      "bn": "0.9463141806138904",
      "bg": "0.9851637009493611",
      "zh": "0.9699966823142991",
      "fr": "0.990138994733523",
      "de": "0.9685570093125583",
      "ha": "0.9638008048386778",
      "hi": "0.9477337919471468",
      "hu": "0.954077450426258"
    },
    "level": "hard",
    "test": "const testTransformLetterCase = () => {\n    console.assert(transformLetterCase('b') === 'B');\n    console.assert(transformLetterCase('B') === 'b');\n    // Additional test cases\n    console.assert(transformLetterCase('z') === 'Z');\n    console.assert(transformLetterCase('Z') === 'z');\n    console.assert(transformLetterCase('m') === 'M');\n    console.assert(transformLetterCase('M') === 'm');\n    console.assert(transformLetterCase('1') === '1'); // Non-alphabetic, should be unchanged\n    console.assert(transformLetterCase('!') === '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to log a message for passed tests\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestTransformLetterCase();",
    "entry_point": "transformLetterCase",
    "signature": "function transformLetterCase(letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n- letter (char): The input letter to be transformed.\n\nReturns:\n- char: The letter with its case reversed. If the input is lowercase, returns uppercase, and if the input is uppercase, returns lowercase.\n\nExample:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "sq": "Transformon rastin e një shkronje të dhënë.\n- letter (char): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- char: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronjë të vogël, kthen me shkronjë të madhe, dhe nëse hyrja është me shkronjë të madhe, kthen me shkronjë të vogël.\n\nShembull:\ntransformLetterCase('b') kthen 'B'\ntransformLetterCase('Z') kthen 'z'",
      "hy": "Փոխակերպում է տրված տառի ռեգիստրը:\n- letter (char): Մուտքային տառը, որը պետք է փոխակերպվի:\n\nՎերադարձնում է:\n- char: Տառը՝ իր ռեգիստրը փոխված: Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ, և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ:\n\nՕրինակ:\ntransformLetterCase('b') վերադարձնում է 'B'\ntransformLetterCase('Z') վերադարձնում է 'z'",
      "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n- letter (char): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nReturns:\n- char: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, তাহলে বড় হাতের ফেরত দেয়, এবং যদি ইনপুট বড় হাতের হয়, তাহলে ছোট হাতের ফেরত দেয়।\n\nExample:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "bg": "Преобразува регистъра на дадена буква.\n- letter (char): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- char: Буквата с обърнат регистър. Ако входът е с малки букви, връща с главни букви, и ако входът е с главни букви, връща с малки букви.\n\nПример:\ntransformLetterCase('b') връща 'B'\ntransformLetterCase('Z') връща 'z'",
      "zh": "转换给定字母的大小写。\n- letter (char): 要转换的输入字母。\n\nReturns:  \n- char: 大小写已反转的字母。如果输入为小写，则返回大写；如果输入为大写，则返回小写。\n\nExample:  \ntransformLetterCase('b') returns 'B'  \ntransformLetterCase('Z') returns 'z'",
      "fr": "Transforme la casse d'une lettre donnée.\n- letter (char) : La lettre d'entrée à transformer.\n\nRenvoie :\n- char : La lettre avec sa casse inversée. Si l'entrée est en minuscule, renvoie en majuscule, et si l'entrée est en majuscule, renvoie en minuscule.\n\nExemple :\ntransformLetterCase('b') renvoie 'B'\ntransformLetterCase('Z') renvoie 'z'",
      "de": "Transformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens\n- letter (char): Der Eingabebuchstabe, der umgewandelt werden soll.\n\nReturns:  \n- char: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird Großbuchstabe zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird Kleinbuchstabe zurückgegeben.\n\nExample:  \ntransformLetterCase('b') returns 'B'  \ntransformLetterCase('Z') returns 'z'",
      "ha": "Canza yanayin harafin da aka bayar.\n- letter (char): Harafin shigarwa da za a sauya.\n\nReturns:\n- char: Harafin da aka sauya masa hali. Idan shigarwar harafi ƙarami ne, yana mayar da babban harafi, kuma idan shigarwar babban harafi ne, yana mayar da ƙaramin harafi.\n\nExample:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "hi": "दिए गए अक्षर के केस को बदलता है।\n- letter (char): वह इनपुट अक्षर जिसे बदला जाना है।\n\nReturns:\n- char: अक्षर जिसका केस उलटा हो गया है। यदि इनपुट लोअरकेस है, तो अपरकेस लौटाता है, और यदि इनपुट अपरकेस है, तो लोअरकेस लौटाता है।\n\nउदाहरण:\ntransformLetterCase('b') returns 'B'\ntransformLetterCase('Z') returns 'z'",
      "hu": "Átalakítja egy adott betű esetét.\n- letter (char): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- char: A betű az esetének megfordításával. Ha a bemenet kisbetűs, nagybetűt ad vissza, és ha a bemenet nagybetűs, kisbetűt ad vissza.\n\nPélda:\ntransformLetterCase('b') visszaadja 'B'\ntransformLetterCase('Z') visszaadja 'z'"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9538130733891006",
      "bn": "0.9612021235635984",
      "bg": "0.9661301433170739",
      "zh": "0.9838648568877739",
      "fr": "0.965309998473781",
      "de": "0.9490683894773202",
      "ha": "0.9612805825641072",
      "hi": "0.9409442082626123",
      "hu": "0.9910149547138868"
    }
  },
  {
    "task_id": "JavaScript/28",
    "prompt": {
      "en": "\n/**\n * Display the ASCII information for a given character.\n *\n * @param {char} character - The input character for which ASCII information is to be displayed.\n * @returns {number} - The corresponding ASCII code.\n * \n * Examples:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "sq": "/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n *\n * @param {char} character - Karakteri i hyrjes për të cilin informacioni ASCII do të shfaqet.\n * @returns {number} - Kodi përkatës ASCII.\n * \n * Shembuj:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "hy": "/**\n * Ցուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար։\n *\n * @param {char} character - Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n * @returns {number} - Համապատասխան ASCII կոդը։\n * \n * Օրինակներ:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "bn": "/**\n * প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n *\n * @param {char} character - ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n * @returns {number} - সংশ্লিষ্ট ASCII কোড।\n * \n * উদাহরণ:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "bg": "/**\n * Показва ASCII информацията за даден символ.\n *\n * @param {char} character - Входният символ, за който ще се покаже ASCII информацията.\n * @returns {number} - Съответният ASCII код.\n * \n * Примери:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "zh": "/**\n * 显示给定字符的ASCII信息。\n *\n * @param {char} character - 要显示其ASCII信息的输入字符。\n * @returns {number} - 对应的ASCII码。\n * \n * 示例:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "fr": "/**\n * Afficher les informations ASCII pour un caractère donné.\n *\n * @param {char} character - Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n * @returns {number} - Le code ASCII correspondant.\n * \n * Exemples :\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "de": "/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n *\n * @param {char} character - Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n * @returns {number} - Der entsprechende ASCII-Code.\n * \n * Beispiele:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "ha": "/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n *\n * @param {char} character - Alamar shigarwa wanda za a nuna bayanin ASCII.\n * @returns {number} - Lambar ASCII da ta dace.\n * \n * Misalai:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "hi": "/**\n * दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n *\n * @param {char} character - वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n * @returns {number} - संबंधित ASCII कोड।\n * \n * उदाहरण:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)",
      "hu": "/**\n * Megjeleníti az ASCII információt egy adott karakterhez.\n *\n * @param {char} character - Az input karakter, amelyhez az ASCII információt meg kell jeleníteni.\n * @returns {number} - A megfelelő ASCII kód.\n * \n * Példák:\n * display_ascii_info('A');\n * // => 65\n */\nfunction display_ascii_info(character)"
    },
    "prompt_bertscore": {
      "sq": "0.9853075093452304",
      "hy": "0.9865932438016692",
      "bn": "0.966027451410079",
      "bg": "0.9841071859526366",
      "zh": "0.9789229330076259",
      "fr": "0.987457683219933",
      "de": "0.9843707684682699",
      "ha": "0.9660687665293342",
      "hi": "0.9813732373880724",
      "hu": "0.9843707684682699"
    },
    "canonical_solution": "{\n    return character.charCodeAt(0);\n}",
    "instruction": {
      "en": "Write a JavaScript function `function display_ascii_info(character)` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\ndisplay_ascii_info('A');\n// => 65\n",
      "sq": "Shkruani një funksion JavaScript `function display_ascii_info(character)` për të zgjidhur problemin e mëposhtëm:  \nShfaq informacionin ASCII për një karakter të dhënë.\n\nParametrat:  \n@param {char} character - Karakteri i hyrjes për të cilin informacioni ASCII duhet të shfaqet.\n\nKthen:  \n@returns {number} - Kodi përkatës ASCII.\n\nShembuj:  \ndisplay_ascii_info('A');  \n// => 65",
      "hy": "Գրեք JavaScript ֆունկցիա `function display_ascii_info(character)` հետևյալ խնդիրը լուծելու համար: \nՑուցադրել տրված սիմվոլի ASCII տեղեկատվությունը:\n\nՊարամետրեր:\n@param {char} character - Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\nՎերադարձնում է:\n@returns {number} - Համապատասխանող ASCII կոդը:\n\nՕրինակներ:\ndisplay_ascii_info('A');\n// => 65",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function display_ascii_info(character)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\nপ্যারামিটারসমূহ:\n@param {char} character - ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nফেরত দেয়:\n@returns {number} - সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণসমূহ:\ndisplay_ascii_info('A');\n// => 65",
      "bg": "Напишете JavaScript функция `function display_ascii_info(character)`, за да решите следния проблем:  \nПоказване на ASCII информацията за даден символ.\n\nПараметри:  \n@param {char} character - Входният символ, за който трябва да се покаже ASCII информацията.\n\nВръща:  \n@returns {number} - Съответстващият ASCII код.\n\nПримери:  \ndisplay_ascii_info('A');  \n// => 65",
      "zh": "编写一个 JavaScript 函数 `function display_ascii_info(character)` 来解决以下问题：  \n显示给定字符的 ASCII 信息。\n\n参数：  \n@param {char} character - 要显示其 ASCII 信息的输入字符。\n\n返回：  \n@returns {number} - 对应的 ASCII 码。\n\n示例：  \ndisplay_ascii_info('A');  \n// => 65  ",
      "fr": "Écrire une fonction JavaScript `function display_ascii_info(character)` pour résoudre le problème suivant :  \nAfficher les informations ASCII pour un caractère donné.\n\nParamètres :  \n@param {char} character - Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\nRetourne :  \n@returns {number} - Le code ASCII correspondant.\n\nExemples :  \ndisplay_ascii_info('A');  \n// => 65  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function display_ascii_info(character)`, um das folgende Problem zu lösen:  \nZeigen Sie die ASCII-Informationen für ein gegebenes Zeichen an.\n\nParameter:  \n@param {char} character - Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\nRückgabewert:  \n@returns {number} - Der entsprechende ASCII-Code.\n\nBeispiele:  \ndisplay_ascii_info('A');  \n// => 65",
      "ha": "Rubuta wani aikin JavaScript `function display_ascii_info(character)` don warware matsalar mai zuwa: Nuna bayanin ASCII don wata alama da aka bayar.\n\nSigogi:\n@param {char} character - Alamar shigarwa wadda za a nuna bayanin ASCII nata.\n\nKomawa:\n@returns {number} - Lambar ASCII da ta dace.\n\nMisalai:\ndisplay_ascii_info('A');\n// => 65",
      "hi": "JavaScript फ़ंक्शन `function display_ascii_info(character)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करें।\n\nपैरामीटर्स:\n@param {char} character - वह इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n@returns {number} - संबंधित ASCII कोड।\n\nउदाहरण:\ndisplay_ascii_info('A');\n// => 65",
      "hu": "Írj egy JavaScript függvényt `function display_ascii_info(character)` a következő probléma megoldására:  \nJelenítsd meg az ASCII információt egy adott karakterhez.\n\nParaméterek:  \n@param {char} character - Az a bemeneti karakter, amelyhez az ASCII információt meg kell jeleníteni.\n\nVisszatérési érték:  \n@returns {number} - A megfelelő ASCII kód.\n\nPéldák:  \ndisplay_ascii_info('A');  \n// => 65"
    },
    "instruction_bertscore": {
      "sq": "0.9889819727639948",
      "hy": "0.9834107878367282",
      "bn": "0.9729093982217947",
      "bg": "0.9886538353745251",
      "zh": "0.9852336188434854",
      "fr": "0.9943620752647058",
      "de": "0.9783965624978835",
      "ha": "0.973924200838502",
      "hi": "0.9694146952978668",
      "hu": "0.9834491235002679"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(display_ascii_info('A') === 65, \"'A' should return 65\");\n    console.assert(display_ascii_info('B') === 66, \"'B' should return 66\"); // Additional test case\n    console.assert(display_ascii_info('0') === 48, \"'0' should return 48\"); // Additional test case\n    console.assert(display_ascii_info(' ') === 32, \"' ' should return 32\"); // Additional test case\n    // console.log(\"All tests passed.\");\n})();",
    "entry_point": "display_ascii_info",
    "signature": "function display_ascii_info(character)",
    "docstring": {
      "en": "Display the ASCII information for a given character.\n\nParameters:\n@param {char} character - The input character for which ASCII information is to be displayed.\n\nReturns:\n@returns {number} - The corresponding ASCII code.\n\nExamples:\ndisplay_ascii_info('A');\n// => 65\n",
      "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\nParametrat:\n@param {char} character - Karakteri i hyrjes për të cilin do të shfaqet informacioni ASCII.\n\nKthen:\n@returns {number} - Kodi përkatës ASCII.\n\nShembuj:\ndisplay_ascii_info('A');\n// => 65",
      "hy": "ASCII տեղեկատվությունը ցուցադրել տրված սիմվոլի համար։\n\nՊարամետրեր:\n@param {char} character - Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\nՎերադարձնում է:\n@returns {number} - Համապատասխանող ASCII կոդը։\n\nՕրինակներ:\ndisplay_ascii_info('A');\n// => 65",
      "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\nপ্যারামিটার:\n@param {char} character - ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nরিটার্নস:\n@returns {number} - সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\ndisplay_ascii_info('A');\n// => 65",
      "bg": "Показва ASCII информацията за даден символ.\n\nПараметри:\n@param {char} character - Входният символ, за който трябва да се покаже ASCII информация.\n\nВръща:\n@returns {number} - Съответният ASCII код.\n\nПримери:\ndisplay_ascii_info('A');\n// => 65",
      "zh": "显示给定字符的ASCII信息。\n\n参数:\n@param {char} character - 要显示其ASCII信息的输入字符。\n\n返回:\n@returns {number} - 对应的ASCII代码。\n\n示例:\ndisplay_ascii_info('A');\n// => 65",
      "fr": "Afficher les informations ASCII pour un caractère donné.\n\nParamètres:\n@param {char} character - Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\nRenvoie:\n@returns {number} - Le code ASCII correspondant.\n\nExemples:\ndisplay_ascii_info('A');\n// => 65",
      "de": "Zeige die ASCII-Informationen für ein gegebenes Zeichen an.\n\nParameter:\n@param {char} character - Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\nRückgabewerte:\n@returns {number} - Der entsprechende ASCII-Code.\n\nBeispiele:\ndisplay_ascii_info('A');\n// => 65",
      "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\nSigogi:\n@param {char} character - Harafin shigarwa wanda za a nuna bayanin ASCII.\n\nAbin da ya dawo:\n@returns {number} - Lambar ASCII da ta dace.\n\nMisalai:\ndisplay_ascii_info('A');\n// => 65",
      "hi": "दिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करें।\n\nParameters:\n@param {char} character - वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nReturns:\n@returns {number} - संबंधित ASCII कोड।\n\nExamples:\ndisplay_ascii_info('A');\n// => 65",
      "hu": "Adja meg egy adott karakter ASCII információját.\n\nParaméterek:\n@param {char} character - Az a bemeneti karakter, amelynek ASCII információját meg kell jeleníteni.\n\nVisszatérési érték:\n@returns {number} - A megfelelő ASCII kód.\n\nPéldák:\ndisplay_ascii_info('A');\n// => 65"
    },
    "docstring_bertscore": {
      "sq": "0.9884391159326265",
      "hy": "0.9660284445619841",
      "bn": "0.9626410020438151",
      "bg": "0.981309079774998",
      "zh": "0.9796826942150844",
      "fr": "0.9853949067128857",
      "de": "0.9721563904472914",
      "ha": "0.9528201201143072",
      "hi": "0.9831670683591984",
      "hu": "0.9587404972514331"
    }
  },
  {
    "task_id": "JavaScript/29",
    "prompt": {
      "en": "\n/**\n * Evaluate the grade for an input integer.\n * \n * Parameters:\n * - score (int): The integer score to be evaluated.\n * \n * Returns:\n * ​​    char: The grade corresponding to the input score.\n * ​​         If the score is between 90 and 100 (inclusive), returns 'A'.\n * ​​         Otherwise, returns 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "sq": "/**\n * Vlerëson notën për një numër të plotë hyrës.\n * \n * Parametrat:\n * - score (int): Nota e plotë që do të vlerësohet.\n * \n * Kthen:\n * ​​    char: Nota që korrespondon me notën hyrëse.\n * ​​         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n * ​​         Përndryshe, kthen 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "hy": "/**\n * Գնահատել մուտքային ամբողջ թվի գնահատականը։\n * \n * Պարամետրեր:\n * - score (int): Գնահատման ենթակա ամբողջ թիվ։\n * \n * Վերադարձնում է:\n * ​​    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n * ​​         Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n * ​​         Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "bn": "/**\n * একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n * \n * প্যারামিটার:\n * - score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * \n * রিটার্নস:\n * ​​    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n * ​​         যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' রিটার্ন করে।\n * ​​         অন্যথায়, 'B' রিটার্ন করে।\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "bg": "/**\n * Оценете оценката за входно цяло число.\n * \n * Параметри:\n * - score (int): Цялото число, което трябва да бъде оценено.\n * \n * Връща:\n * ​​    char: Оценката, съответстваща на входното число.\n * ​​         Ако числото е между 90 и 100 (включително), връща 'A'.\n * ​​         В противен случай, връща 'B'.\n * \n * @пример\n * evaluate_integer_grade(90) // връща 'A'\n */\nfunction evaluate_integer_grade(score)",
      "zh": "/**\n * 评估输入整数的等级。\n * \n * 参数:\n * - score (int): 要评估的整数分数。\n * \n * 返回:\n * ​​    char: 与输入分数对应的等级。\n * ​​         如果分数在90到100之间（包括90和100），返回 'A'。\n * ​​         否则，返回 'B'。\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "fr": "/**\n * Évaluer la note pour un entier d'entrée.\n * \n * Paramètres:\n * - score (int): Le score entier à évaluer.\n * \n * Renvoie:\n * ​​    char: La note correspondant au score d'entrée.\n * ​​         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n * ​​         Sinon, renvoie 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "de": "/**\n * Bewerte die Note für eine eingegebene ganze Zahl.\n * \n * Parameter:\n * - score (int): Die zu bewertende Ganzzahl.\n * \n * Rückgabe:\n * ​​    char: Die Note, die der Eingabepunktzahl entspricht.\n * ​​         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n * ​​         Andernfalls wird 'B' zurückgegeben.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */",
      "ha": "/**\n * Kimanta darajar don lamba mai shigarwa.\n * \n * Sigogi:\n * - score (int): Lambar da za a kimanta.\n * \n * Komawa:\n * ​​    char: Darajar da ta dace da lambar shigarwa.\n * ​​         Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n * ​​         In ba haka ba, yana dawowa 'B'.\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "hi": "/**\n * इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * \n * पैरामीटर:\n * - score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n * \n * रिटर्न:\n * ​​    char: इनपुट स्कोर के अनुरूप ग्रेड।\n * ​​         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n * ​​         अन्यथा, 'B' लौटाता है।\n * \n * @example\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)",
      "hu": "/**\n * Értékelje az egész szám osztályzatát.\n * \n * Paraméterek:\n * - score (int): Az értékelendő egész szám pontszám.\n * \n * Visszatér:\n * ​​    char: Az input pontszámnak megfelelő osztályzat.\n * ​​         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n * ​​         Egyébként 'B'-t ad vissza.\n * \n * @példa\n * evaluate_integer_grade(90) // returns 'A'\n */\nfunction evaluate_integer_grade(score)"
    },
    "prompt_bertscore": {
      "sq": "0.9419550382716988",
      "hy": "0.9838443979585274",
      "bn": "0.98955879539052",
      "bg": "0.9752677367358219",
      "zh": "0.9702906552782308",
      "fr": "0.9951339529254073",
      "de": "0.9545086769834847",
      "ha": "0.9618673367096843",
      "hi": "0.9340463710204137",
      "hu": "0.9543978412308672"
    },
    "canonical_solution": "{\n    // Return 'A' or 'B' based on the condition\n    return ((90 <= score && score <= 100) ? 'A' : 'B');\n}",
    "instruction": {
      "en": "Write a JavaScript function `function evaluate_integer_grade(score)` to solve the following problem:\nEvaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\n@example\nevaluate_integer_grade(90) // returns 'A'\n",
      "sq": "Shkruani një funksion JavaScript `function evaluate_integer_grade(score)` për të zgjidhur problemin e mëposhtëm:  \nVlerësoni notën për një numër të plotë hyrës.\n\nParametrat:  \n- score (int): Nota e plotë që do të vlerësohet.\n\nKthen:  \n    char: Nota që korrespondon me notën hyrëse.  \n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.  \n    Përndryshe, kthen 'B'.\n\n@example  \nevaluate_integer_grade(90) // returns 'A'",
      "hy": "Գրեք JavaScript ֆունկցիա `function evaluate_integer_grade(score)` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվի գնահատականը:\n\nՊարամետրեր:\n- score (int): Գնահատվող ամբողջ թիվը:\n\nՎերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը:\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A':\n    Հակառակ դեպքում, վերադարձնում է 'B':\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "bn": "একটি JavaScript ফাংশন `function evaluate_integer_grade(score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা গ্রেড মূল্যায়ন করুন।\n\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।\n\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' ফেরত দেয়।\n    অন্যথায়, 'B' ফেরত দেয়।\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "bg": "Напишете JavaScript функция `function evaluate_integer_grade(score)` за решаване на следния проблем:\nОценете оценката за входно цяло число.\n\nПараметри:  \n- score (int): Цялото число, което трябва да бъде оценено.\n\nВръща:  \n    char: Оценката, съответстваща на входното число.  \n    Ако числото е между 90 и 100 (включително), връща 'A'.  \n    В противен случай, връща 'B'.  \n\n@example  \nevaluate_integer_grade(90) // returns 'A'",
      "zh": "编写一个 JavaScript 函数 `function evaluate_integer_grade(score)` 来解决以下问题：\n评估输入整数的等级。\n\n参数：\n- score (int): 要评估的整数分数。\n\n返回：  \n    char: 与输入分数对应的等级。  \n    如果分数在 90 到 100 之间（包括 90 和 100），返回 'A'。  \n    否则，返回 'B'。\n\n@example  \nevaluate_integer_grade(90) // returns 'A'",
      "fr": "Écrire une fonction JavaScript `function evaluate_integer_grade(score)` pour résoudre le problème suivant:\nÉvaluer la note pour un entier en entrée.\n\nParamètres :  \n- score (int) : Le score entier à évaluer.\n\nRenvoie :  \n    char : La note correspondant au score d'entrée.  \n    Si le score est entre 90 et 100 (inclus), renvoie 'A'.  \n    Sinon, renvoie 'B'.\n\n@example  \nevaluate_integer_grade(90) // returns 'A'",
      "de": "Schreiben Sie eine JavaScript-Funktion `function evaluate_integer_grade(score)`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine eingegebene ganze Zahl.\n\nParameter:\n- score (int): Die zu bewertende ganze Zahl.\n\nRückgabewert:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n    Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "ha": "Rubuta aikin JavaScript `function evaluate_integer_grade(score)` don warware matsalar mai zuwa:\nKimanta darajar don wani shigarwar cikakken lamba.\n\nSigogi:\n- score (int): Cikakken lamban da za a kimanta.\n\nDawowa:\n    char: Darajar da ta dace da shigarwar maki.\n    Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n    In ba haka ba, yana dawowa 'B'.\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "hi": "एक JavaScript फ़ंक्शन `function evaluate_integer_grade(score)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिसी इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "hu": "Írj egy JavaScript függvényt `function evaluate_integer_grade(score)` a következő probléma megoldására:\nÉrtékeld ki a jegyet egy bemeneti egész számra.\n\nParaméterek:\n- score (int): Az értékelendő egész szám.\n\nVisszatér:\n    char: A bemeneti pontszámnak megfelelő jegy.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Ellenkező esetben 'B'-t ad vissza.\n\n@example\nevaluate_integer_grade(90) // returns 'A'"
    },
    "instruction_bertscore": {
      "sq": "0.986108188411182",
      "hy": "0.9420348876848748",
      "bn": "0.9651705599462944",
      "bg": "0.9746416537747999",
      "zh": "0.9758244976938627",
      "fr": "0.9913369345615444",
      "de": "0.9575213039726409",
      "ha": "0.9882607458504571",
      "hi": "0.9439788832240632",
      "hu": "0.9971796472196857"
    },
    "level": "easy",
    "test": "function testEvaluateIntegerGrade() {\n    console.assert(evaluate_integer_grade(90) === 'A', 'Score of 90 should yield an A');\n    console.assert(evaluate_integer_grade(89) === 'B', 'Score of 89 should yield a B');\n    console.assert(evaluate_integer_grade(95) === 'A', 'Score of 95 should yield an A');\n    console.assert(evaluate_integer_grade(100) === 'A', 'Score of 100 should yield an A');\n    console.assert(evaluate_integer_grade(101) === 'B', 'Score of 101 should yield a B');\n\n    // console.log(\"All tests passed!\");\n}\n\ntestEvaluateIntegerGrade();",
    "entry_point": "evaluate_integer_grade",
    "signature": "function evaluate_integer_grade(score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n\nParameters:\n- score (int): The integer score to be evaluated.\n\nReturns:\n    char: The grade corresponding to the input score.\n    If the score is between 90 and 100 (inclusive), returns 'A'.\n    Otherwise, returns 'B'.\n\n@example\nevaluate_integer_grade(90) // returns 'A'\n",
      "sq": "Vlerësoni notën për një numër të plotë hyrës.\n\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\n\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n    Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n    Përndryshe, kthen 'B'.\n\n@example\nevaluate_integer_grade(90) // kthen 'A'",
      "hy": "Մուտքագրեք ամբողջ թիվը գնահատելու համար։\n\nՊարամետրեր:\n- score (int): Գնահատման ենթակա ամբողջ թիվը։\n\nՎերադարձնում է:\n    char: Մուտքագրված գնահատականին համապատասխան գնահատականը։\n    Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n    Հակառակ դեպքում, վերադարձնում է 'B'։\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "bn": "একটি পূর্ণসংখ্যা গ্রেড মূল্যায়ন করুন।\n\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n    যদি স্কোর ৯০ এবং ১০০ এর মধ্যে (অন্তর্ভুক্ত) হয়, তাহলে 'A' ফেরত দেয়।\n    অন্যথায়, 'B' ফেরত দেয়।\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "bg": "Оценете оценката за входящо цяло число.\n\nПараметри:\n- score (int): Цялочислената оценка, която ще бъде оценена.\n\nВръща:\n    char: Оценката, съответстваща на входящата оценка.\n    Ако оценката е между 90 и 100 (включително), връща 'A'.\n    В противен случай, връща 'B'.\n\n@пример\nevaluate_integer_grade(90) // връща 'A'",
      "zh": "评估输入整数的等级。\n\n参数：\n- score (int): 要评估的整数分数。\n\n返回：\n    char: 与输入分数对应的等级。\n    如果分数在90到100之间（包括90和100），返回 'A'。\n    否则，返回 'B'。\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "fr": "Évaluer la note pour un entier d'entrée.\n\nParamètres:\n- score (int): Le score entier à évaluer.\n\nRenvoie:\n    char: La note correspondant au score d'entrée.\n    Si le score est compris entre 90 et 100 (inclus), renvoie 'A'.\n    Sinon, renvoie 'B'.\n\n@example\nevaluate_integer_grade(90) // returns 'A'",
      "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n\nParameter:\n- score (int): Die zu bewertende Ganzzahlpunktzahl.\n\nRückgabewerte:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n    Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n    Andernfalls wird 'B' zurückgegeben.\n\n@Beispiel\nevaluate_integer_grade(90) // gibt 'A' zurück",
      "ha": "Kimanta darajar don wani shigarwar cikakken lamba.\n\nSigogi:\n- score (int): Lambar maki da za a tantance.\n\nDawowa:\n    char: Darajar da ta dace da shigarwar maki.\n    Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n    In ba haka ba, yana dawowa 'B'.\n\n@misali\nevaluate_integer_grade(90) // yana dawowa 'A'",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n    यदि स्कोर 90 और 100 के बीच (समावेशी) है, तो 'A' लौटाता है।\n    अन्यथा, 'B' लौटाता है।\n\n@उदाहरण\nevaluate_integer_grade(90) // 'A' लौटाता है",
      "hu": "Értékelje az egész szám osztályzatát.\n\nParaméterek:\n- score (int): Az értékelendő egész szám pontszám.\n\nVisszatér:\n    char: A bemeneti pontszámnak megfelelő osztályzat.\n    Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n    Egyébként 'B'-t ad vissza.\n\n@példa\nevaluate_integer_grade(90) // returns 'A'"
    },
    "docstring_bertscore": {
      "sq": "0.9793483992838027",
      "hy": "0.9480621279669974",
      "bn": "0.9757527921263092",
      "bg": "0.9704660459046845",
      "zh": "0.9654031561224863",
      "fr": "0.9941638421444329",
      "de": "0.9523726058658355",
      "ha": "0.97079338877263",
      "hi": "0.9656035741769505",
      "hu": "0.9797742628207414"
    }
  },
  {
    "task_id": "JavaScript/30",
    "prompt": {
      "en": "// Note: No import statement is required in JavaScript for this function\n/**\n * Checks if a string with exactly three characters has two characters that are the same.\n * \n * @param {string} str - The three-character string to be checked.\n * @return {string} - Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n * \n * Examples:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "sq": "// Shënim: Nuk kërkohet ndonjë deklaratë importi në JavaScript për këtë funksion\n/**\n * Kontrollon nëse një varg me saktësisht tre karaktere ka dy karaktere që janë të njëjta.\n * \n * @param {string} str - Vargu me tre karaktere që do të kontrollohet.\n * @return {string} - Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe 'No'.\n * \n * Shembuj:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */",
      "hy": "// Նշում: JavaScript-ում այս ֆունկցիայի համար ներմուծման հրահանգ անհրաժեշտ չէ\n/**\n * Ստուգում է, արդյոք երեք նիշ ունեցող տողում կա երկու նույն նիշ:\n * \n * @param {string} str - Երեք նիշ ունեցող տողը, որը պետք է ստուգվի:\n * @return {string} - Վերադարձնում է 'Yes', եթե մուտքագրումը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n * \n * Օրինակներ:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */",
      "bn": "// লক্ষ্য করুন: এই ফাংশনের জন্য জাভাস্ক্রিপ্টে কোনো ইম্পোর্ট স্টেটমেন্ট প্রয়োজন নেই\n/**\n * পরীক্ষা করে যে একটি স্ট্রিংয়ের ঠিক তিনটি অক্ষর আছে এবং তার মধ্যে দুটি অক্ষর একই কিনা।\n * \n * @param {string} str - তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n * @return {string} - 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n * \n * উদাহরণ:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */",
      "bg": "// Забележка: Не е необходимо включване на import израз в JavaScript за тази функция\n/**\n * Проверява дали низ с точно три символа има два еднакви символа.\n * \n * @param {string} str - Трисимволният низ, който ще бъде проверен.\n * @return {string} - Връща 'Yes', ако входът има точно два еднакви символа, в противен случай 'No'.\n * \n * Примери:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "zh": "// 注意：在 JavaScript 中，这个函数不需要导入语句\n/**\n * 检查一个正好有三个字符的字符串是否有两个字符相同。\n * \n * @param {string} str - 要检查的三字符字符串。\n * @return {string} - 如果输入有正好两个相等的字符，则返回 'Yes'，否则返回 'No'。\n * \n * 示例:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "fr": "// Remarque : Aucune instruction d'importation n'est requise en JavaScript pour cette fonction\n/**\n * Vérifie si une chaîne de exactement trois caractères a deux caractères identiques.\n * \n * @param {string} str - La chaîne de trois caractères à vérifier.\n * @return {string} - Retourne 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n * \n * Exemples :\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "de": "// Hinweis: Für diese Funktion ist in JavaScript keine Importanweisung erforderlich\n/**\n * Überprüft, ob ein String mit genau drei Zeichen zwei gleiche Zeichen hat.\n * \n * @param {string} str - Der zu überprüfende Drei-Zeichen-String.\n * @return {string} - Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n * \n * Beispiele:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */",
      "ha": "// Lura: Babu buƙatar shigo da bayanin a JavaScript don wannan aikin\n/**\n * Duba idan igiyar da ke da haruffa uku daidai tana da haruffa biyu da suke daidai.\n * \n * @param {string} str - Igiyar haruffa uku da za a duba.\n * @return {string} - Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu, in ba haka ba 'No'.\n * \n * Misalai:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */",
      "hi": "// नोट: इस फ़ंक्शन के लिए JavaScript में कोई इम्पोर्ट स्टेटमेंट आवश्यक नहीं है\n/**\n * जाँच करता है कि क्या तीन वर्णों वाली एक स्ट्रिंग में दो वर्ण समान हैं।\n * \n * @param {string} str - जाँच के लिए तीन-वर्णों वाली स्ट्रिंग।\n * @return {string} - यदि इनपुट में ठीक दो समान वर्ण हैं तो 'Yes' लौटाता है, अन्यथा 'No'।\n * \n * उदाहरण:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */\nfunction checkTwoEqualDigits(str)",
      "hu": "// Megjegyzés: Ehhez a függvényhez nincs szükség import utasításra JavaScriptben\n/**\n * Ellenőrzi, hogy egy pontosan három karakter hosszú stringben van-e két azonos karakter.\n * \n * @param {string} str - Az ellenőrizendő három karakter hosszú string.\n * @return {string} - 'Yes'-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben 'No'-t.\n * \n * Példák:\n * checkTwoEqualDigits('112') // 'Yes'\n * checkTwoEqualDigits('123') // 'No'\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9843328300654922",
      "hy": "0.9494817393002538",
      "bn": "0.9532408192613391",
      "bg": "0.9743605917856356",
      "zh": "0.9670505965027897",
      "fr": "0.9729270763257069",
      "de": "0.964934388423244",
      "ha": "0.9344217824405696",
      "hi": "0.9409452014145174",
      "hu": "0.9456414195133253"
    },
    "canonical_solution": "{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function checkTwoEqualDigits(str)` to solve the following problem:\nChecks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "sq": "Shkruani një funksion JavaScript `function checkTwoEqualDigits(str)` për të zgjidhur problemin e mëposhtëm:  \nKontrollon nëse një varg me saktësisht tre karaktere ka dy karaktere që janë të njëjta.\n\nParametrat:  \n- str (string): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:  \n- string: Kthen 'Yes' nëse inputi ka saktësisht dy karaktere të barabartë, përndryshe 'No'.\n\nShembuj:  \n checkTwoEqualDigits('112') // 'Yes'  \n checkTwoEqualDigits('123') // 'No'",
      "hy": "Գրեք JavaScript ֆունկցիա `function checkTwoEqualDigits(str)` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողում կա երկու նույն նիշ:\n\nՊարամետրեր:\n- str (string): Երեք նիշից բաղկացած ստուգվող տողը:\n\nՎերադարձնում է:\n- string: Վերադարձնում է 'Yes', եթե մուտքագրումը ունի ճիշտ երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n\nՕրինակներ:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function checkTwoEqualDigits(str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করে যে একটি তিনটি অক্ষরের স্ট্রিংয়ে দুটি অক্ষর একই কি না।\n\nপ্যারামিটারসমূহ:\n- str (string): তিনটি অক্ষরের স্ট্রিং যা যাচাই করা হবে।\n\nরিটার্নস:\n- string: যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে 'Yes' রিটার্ন করে, অন্যথায় 'No'।\n\nউদাহরণসমূহ:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "bg": "Напишете JavaScript функция `function checkTwoEqualDigits(str)`, за да решите следния проблем:  \nПроверява дали низ с точно три знака има два знака, които са еднакви.\n\nПараметри:\n- str (string): Тризнаковият низ, който ще бъде проверен.\n\nВръща:\n- string: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\nПримери:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "zh": "编写一个 JavaScript 函数 `function checkTwoEqualDigits(str)` 来解决以下问题：\n检查一个恰好有三个字符的字符串是否有两个字符相同。\n\n参数：\n- str (string): 要检查的三个字符的字符串。\n\n返回：\n- string: 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\n示例：\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "fr": "Écrire une fonction JavaScript `function checkTwoEqualDigits(str)` pour résoudre le problème suivant :  \nVérifie si une chaîne de caractères avec exactement trois caractères a deux caractères qui sont identiques.\n\nParamètres :  \n- str (string) : La chaîne de trois caractères à vérifier.\n\nRenvoie :  \n- string : Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\nExemples :  \n checkTwoEqualDigits('112') // 'Yes'  \n checkTwoEqualDigits('123') // 'No'",
      "de": "Schreiben Sie eine JavaScript-Funktion `function checkTwoEqualDigits(str)`, um das folgende Problem zu lösen:\nÜberprüft, ob ein String mit genau drei Zeichen zwei gleiche Zeichen hat.\n\nParameter:\n- str (string): Der zu überprüfende Drei-Zeichen-String.\n\nRückgabewerte:\n- string: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\nBeispiele:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "ha": "Rubuta wani aikin JavaScript `function checkTwoEqualDigits(str)` don magance matsalar mai zuwa: \n\nDuba idan kirtani da ke daidai haruffa uku yana da haruffa biyu da suke daidai.\n\nSigogi:\n- str (string): Kirtanin haruffa uku da za a duba.\n\nDawowa:\n- string: Ya dawo 'Yes' idan shigarwar tana daidai da haruffa biyu, in ba haka ba 'No'.\n\nMisalai:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "hi": "JavaScript फ़ंक्शन `function checkTwoEqualDigits(str)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nजाँच करता है कि क्या तीन वर्णों वाली एक स्ट्रिंग में दो वर्ण समान हैं।\n\nपैरामीटर्स:\n- str (string): तीन-वर्णों वाली स्ट्रिंग जिसे जाँचना है।\n\nवापसी:\n- string: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान वर्ण हैं, अन्यथा 'No'।\n\nउदाहरण:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "hu": "Írj egy JavaScript függvényt `function checkTwoEqualDigits(str)` a következő probléma megoldására:\nEllenőrzi, hogy egy pontosan három karakterből álló string tartalmaz-e két azonos karaktert.\n\nParaméterek:\n- str (string): Az ellenőrizendő három karakteres string.\n\nVisszatérési érték:\n- string: 'Yes'-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben 'No'-t.\n\nPéldák:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9565420561941389",
      "bn": "0.9591542443351287",
      "bg": "0.9927116554286869",
      "zh": "0.9749455582577834",
      "fr": "0.9879687591903358",
      "de": "0.9740167625960642",
      "ha": "0.9563215764711902",
      "hi": "0.9559711924790446",
      "hu": "0.976133367936372"
    },
    "level": "easy",
    "test": "const testCheckTwoEqualDigits = () => {\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\");\n\n    // Additional test cases to cover more scenarios\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\n    \n    // console.log(\"All tests passed successfully.\");\n};\n\ntestCheckTwoEqualDigits();",
    "entry_point": "checkTwoEqualDigits",
    "signature": "function checkTwoEqualDigits(str)",
    "docstring": {
      "en": "Checks if a string with exactly three characters has two characters that are the same.\n\nParameters:\n- str (string): The three-character string to be checked.\n\nReturns:\n- string: Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "sq": "Kontrollon nëse një varg me saktësisht tre karaktere ka dy karaktere që janë të njëjta.\n\nParametrat:\n- str (string): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n- string: Kthen 'Yes' nëse hyrja ka saktësisht dy karaktere të barabartë, përndryshe 'No'.\n\nShembuj:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողում կա երկու նույն նիշ։\n\nՊարամետրեր:\n- str (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել։\n\nՎերադարձնում է:\n- string: Վերադարձնում է 'Yes', եթե մուտքում կա հենց երկու հավասար նիշ, հակառակ դեպքում՝ 'No'։\n\nՕրինակներ:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "bn": "একটি স্ট্রিং যা ঠিক তিনটি অক্ষর নিয়ে গঠিত, তা যাচাই করে যদি দুটি অক্ষর একই হয়।\n\nপ্যারামিটার:\n- str (string): তিন-অক্ষরের স্ট্রিং যা যাচাই করা হবে।\n\nরিটার্নস:\n- string: 'Yes' রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় 'No'।\n\nউদাহরণ:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "bg": "Проверява дали низ с точно три знака има два еднакви знака.\n\nПараметри:\n- str (string): Тристойностният низ, който ще бъде проверен.\n\nВръща:\n- string: Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\nПримери:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "zh": "检查一个正好有三个字符的字符串是否有两个字符相同。\n\n参数：\n- str (string): 要检查的三个字符的字符串。\n\n返回：\n- string: 如果输入有正好两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\n示例：\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "fr": "Vérifie si une chaîne de caractères avec exactement trois caractères a deux caractères identiques.\n\nParamètres:\n- str (string): La chaîne de trois caractères à vérifier.\n\nRenvoie:\n- string: Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\nExemples:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "de": "Prüft, ob ein String mit genau drei Zeichen zwei gleiche Zeichen hat.\n\nParameter:\n- str (string): Der zu überprüfende Drei-Zeichen-String.\n\nRückgabe:\n- string: Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\nBeispiele:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "ha": "Duba idan wani kirtani mai ainihin haruffa uku yana da haruffa biyu da suke iri ɗaya.\n\nSigogi:\n- str (string): Kirtanin haruffa uku da za a duba.\n\nAbin da ya dawo:\n- string: Yana dawowa 'Yes' idan shigarwar tana da ainihin haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n\nMisalai:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "hi": "तीन वर्णों वाली एक स्ट्रिंग की जाँच करता है कि उसमें दो वर्ण समान हैं या नहीं।\n\nपैरामीटर्स:\n- str (string): तीन वर्णों वाली स्ट्रिंग जिसकी जाँच की जानी है।\n\nवापसी:\n- string: 'Yes' लौटाता है यदि इनपुट में ठीक दो समान वर्ण हैं, अन्यथा 'No'।\n\nउदाहरण:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'",
      "hu": "Ellenőrzi, hogy egy pontosan három karakterből álló stringben van-e két azonos karakter.\n\nParaméterek:\n- str (string): Az ellenőrizendő három karakter hosszú string.\n\nVisszatérési érték:\n- string: 'Yes' értéket ad vissza, ha a bemenetben pontosan két egyenlő karakter van, ellenkező esetben 'No'.\n\nPéldák:\n checkTwoEqualDigits('112') // 'Yes'\n checkTwoEqualDigits('123') // 'No'"
    },
    "docstring_bertscore": {
      "sq": "0.9999996027392379",
      "hy": "0.9433257865312206",
      "bn": "0.9503815349263418",
      "bg": "0.971464759460528",
      "zh": "0.953901463908661",
      "fr": "0.9721961165234985",
      "de": "0.9631703520092731",
      "ha": "0.9587283807981899",
      "hi": "0.9406889682229824",
      "hu": "0.9398167822198582"
    }
  },
  {
    "task_id": "JavaScript/31",
    "prompt": {
      "en": "/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * @param {string} s - The input string.\n * @returns {number} The minimum number of rounds to make all characters in the string the same.\n *\n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)",
      "sq": "/**\n * Duke pasur një varg që përbëhet nga shkronjat e vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër\n * në çdo raund. Kjo funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun\n * të përbërë nga i njëjti karakter.\n * @param {string} s - Vargu hyrës.\n * @returns {number} Numri minimal i raundeve për të bërë të gjithë karakteret në varg të njëjta.\n *\n * Shembuj:\n * minRoundsToSameChar(\"aab\") // kthen 1\n * minRoundsToSameChar(\"abc\") // kthen 2\n * minRoundsToSameChar(\"aaa\") // kthen 0\n */\nfunction minRoundsToSameChar(s)",
      "hy": "/**\n * Տրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում մեկ նիշը փոխել\n * մեկ այլ նիշով։ Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը\n * նույն նիշից կազմված դարձնելու համար։\n * @param {string} s - Մուտքային տողը։\n * @returns {number} Նվազագույն փուլերի քանակը, որպեսզի տողի բոլոր նիշերը դառնան նույնը։\n *\n * Օրինակներ:\n * minRoundsToSameChar(\"aab\") // վերադարձնում է 1\n * minRoundsToSameChar(\"abc\") // վերադարձնում է 2\n * minRoundsToSameChar(\"aaa\") // վերադարձնում է 0\n */\nfunction minRoundsToSameChar(s)",
      "bn": "/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন।\n * এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে প্রয়োজনীয় সর্বনিম্ন রাউন্ডের সংখ্যা গণনা করে।\n * @param {string} s - ইনপুট স্ট্রিং।\n * @returns {number} স্ট্রিংয়ের সমস্ত অক্ষরকে একই করতে প্রয়োজনীয় সর্বনিম্ন রাউন্ডের সংখ্যা।\n *\n * উদাহরণ:\n * minRoundsToSameChar(\"aab\") // 1 প্রদান করে\n * minRoundsToSameChar(\"abc\") // 2 প্রদান করে\n * minRoundsToSameChar(\"aaa\") // 0 প্রদান করে\n */\nfunction minRoundsToSameChar(s)",
      "bg": "/**\n * Даден е низ, състоящ се от малки английски букви, можете да промените един символ на друг\n * във всеки рунд. Тази функция изчислява минималния брой рундове, необходими за да направите низа\n * съставен от един и същ символ.\n * @param {string} s - Входният низ.\n * @returns {number} Минималният брой рундове, за да направите всички символи в низа еднакви.\n *\n * Примери:\n * minRoundsToSameChar(\"aab\") // връща 1\n * minRoundsToSameChar(\"abc\") // връща 2\n * minRoundsToSameChar(\"aaa\") // връща 0\n */\nfunction minRoundsToSameChar(s)",
      "zh": "/**\n * 给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。\n * 该函数计算将字符串变为由相同字符组成所需的最小轮数。\n * @param {string} s - 输入字符串。\n * @returns {number} 将字符串中的所有字符变为相同所需的最小轮数。\n *\n * 示例:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)",
      "fr": "/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre\n * à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour rendre la chaîne\n * composée du même caractère.\n * @param {string} s - La chaîne d'entrée.\n * @returns {number} Le nombre minimum de tours pour que tous les caractères de la chaîne soient identiques.\n *\n * Exemples :\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)",
      "de": "/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die erforderlich sind, um den String aus demselben Zeichen zusammengesetzt zu machen.\n * @param {string} s - Der Eingabestring.\n * @returns {number} Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n *\n * Beispiele:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */",
      "ha": "/**\n * An ba da wata ƙirari mai ƙunshe da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani\n * a kowane zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirarin\n * ta ƙunshi harafi iri ɗaya.\n * @param {string} s - Shigar da ƙirari.\n * @returns {number} Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin ƙirari su zama iri ɗaya.\n *\n * Misalai:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */\nfunction minRoundsToSameChar(s)",
      "hi": "/**\n * एक स्ट्रिंग जिसमें छोटे अंग्रेजी अक्षर होते हैं, आप प्रत्येक राउंड में एक वर्ण को दूसरे में बदल सकते हैं।\n * यह फ़ंक्शन गणना करता है कि स्ट्रिंग को एक ही वर्ण से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है।\n * @param {string} s - इनपुट स्ट्रिंग।\n * @returns {number} स्ट्रिंग के सभी वर्णों को एक जैसा बनाने के लिए न्यूनतम राउंड की संख्या।\n *\n * उदाहरण:\n * minRoundsToSameChar(\"aab\") // returns 1\n * minRoundsToSameChar(\"abc\") // returns 2\n * minRoundsToSameChar(\"aaa\") // returns 0\n */",
      "hu": "/**\n * Adott egy kisbetűs angol betűkből álló string, minden körben megváltoztathatsz egy karaktert egy másikra.\n * Ez a függvény kiszámítja a minimális körök számát, amely szükséges ahhoz, hogy a string azonos karakterekből álljon.\n * @param {string} s - A bemeneti string.\n * @returns {number} A minimális körök száma, hogy a string összes karaktere azonos legyen.\n *\n * Példák:\n * minRoundsToSameChar(\"aab\") // visszaadja 1\n * minRoundsToSameChar(\"abc\") // visszaadja 2\n * minRoundsToSameChar(\"aaa\") // visszaadja 0\n */\nfunction minRoundsToSameChar(s)"
    },
    "prompt_bertscore": {
      "sq": "0.9922430863598255",
      "hy": "0.970190148305427",
      "bn": "0.9731805286919073",
      "bg": "1",
      "zh": "0.9833235890994539",
      "fr": "0.9908121530948502",
      "de": "0.9602729306411172",
      "ha": "0.9817444775702265",
      "hi": "0.9580292018569471",
      "hu": "0.9783886172826421"
    },
    "canonical_solution": "{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function minRoundsToSameChar(s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1\nminRoundsToSameChar(\"abc\") // returns 2\nminRoundsToSameChar(\"aaa\") // returns 0",
      "sq": "Shkruani një funksion JavaScript `function minRoundsToSameChar(s)` për të zgjidhur problemin në vijim:  \nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër në secilën raund. Ky funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter.  \n@param {string} s - Vargu hyrës.  \n@returns {number} Numri minimal i raundeve për të bërë të gjithë karakteret në varg të njëjta.  \n\nShembuj:  \nminRoundsToSameChar(\"aab\") // kthen 1  \nminRoundsToSameChar(\"abc\") // kthen 2  \nminRoundsToSameChar(\"aaa\") // kthen 0  ",
      "hy": "Գրեք JavaScript ֆունկցիա `function minRoundsToSameChar(s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում փոխել մեկ նշանը մյուսով: Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը նույն նշանով կազմված դարձնելու համար:\n@param {string} s - Մուտքային տողը:\n@returns {number} Նվազագույն փուլերի քանակը, որպեսզի տողի բոլոր նշանները դառնան նույնը:\n\nՕրինակներ:\nminRoundsToSameChar(\"aab\") // վերադարձնում է 1\nminRoundsToSameChar(\"abc\") // վերադարձնում է 2\nminRoundsToSameChar(\"aaa\") // վերադարձնում է 0",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function minRoundsToSameChar(s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম রাউন্ডের সংখ্যা গণনা করে।\n@param {string} s - ইনপুট স্ট্রিং।\n@returns {number} স্ট্রিংয়ের সমস্ত অক্ষরকে একই করতে ন্যূনতম রাউন্ডের সংখ্যা।\n\nউদাহরণ:\nminRoundsToSameChar(\"aab\") // 1 রিটার্ন করে\nminRoundsToSameChar(\"abc\") // 2 রিটার্ন করে\nminRoundsToSameChar(\"aaa\") // 0 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function minRoundsToSameChar(s)`, за да решите следния проблем:  \nДаден е низ, състоящ се от малки букви на английската азбука, можете да промените един символ на друг във всеки рунд. Тази функция изчислява минималния брой рундове, необходими, за да направите низа съставен от един и същ символ.  \n@param {string} s - Входният низ.  \n@returns {number} Минималният брой рундове, за да се направят всички символи в низа еднакви.  \n\nПримери:  \nminRoundsToSameChar(\"aab\") // връща 1  \nminRoundsToSameChar(\"abc\") // връща 2  \nminRoundsToSameChar(\"aaa\") // връща 0  ",
      "zh": "编写一个 JavaScript 函数 `function minRoundsToSameChar(s)` 来解决以下问题：  \n给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。此函数计算将字符串变为由相同字符组成所需的最小轮数。  \n@param {string} s - 输入字符串。  \n@returns {number} 将字符串中的所有字符变为相同所需的最小轮数。  \n\n示例：  \nminRoundsToSameChar(\"aab\") // 返回 1  \nminRoundsToSameChar(\"abc\") // 返回 2  \nminRoundsToSameChar(\"aaa\") // 返回 0  ",
      "fr": "Écrire une fonction JavaScript `function minRoundsToSameChar(s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère.\n@param {string} s - La chaîne d'entrée.\n@returns {number} Le nombre minimum de tours pour rendre tous les caractères de la chaîne identiques.\n\nExemples :  \nminRoundsToSameChar(\"aab\") // retourne 1  \nminRoundsToSameChar(\"abc\") // retourne 2  \nminRoundsToSameChar(\"aaa\") // retourne 0  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function minRoundsToSameChar(s)`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu machen.\n@param {string} s - Der Eingabestring.\n@returns {number} Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n\nBeispiele:\nminRoundsToSameChar(\"aab\") // gibt 1 zurück\nminRoundsToSameChar(\"abc\") // gibt 2 zurück\nminRoundsToSameChar(\"aaa\") // gibt 0 zurück",
      "ha": "Rubuta wani aikin JavaScript `function minRoundsToSameChar(s)` don warware matsalar mai zuwa:\nAn ba da wani kirtani mai ƙunshe da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani a kowace zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi iri ɗaya.\n@param {string} s - Kirtanin shigarwa.\n@returns {number} Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin kirtani su zama iri ɗaya.\n\nMisalai:\nminRoundsToSameChar(\"aab\") // returns 1\nminRoundsToSameChar(\"abc\") // returns 2\nminRoundsToSameChar(\"aaa\") // returns 0",
      "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function minRoundsToSameChar(s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक स्ट्रिंग में जो छोटे अक्षरों वाले अंग्रेजी अक्षरों से बनी होती है, आप प्रत्येक राउंड में एक अक्षर को दूसरे में बदल सकते हैं। यह फ़ंक्शन न्यूनतम राउंड की संख्या की गणना करता है जो स्ट्रिंग को एक ही अक्षर से बनी बनाने के लिए आवश्यक है।\n@param {string} s - इनपुट स्ट्रिंग।\n@returns {number} न्यूनतम राउंड की संख्या ताकि स्ट्रिंग के सभी अक्षर समान हो जाएं।\n\nउदाहरण:\nminRoundsToSameChar(\"aab\") // returns 1\nminRoundsToSameChar(\"abc\") // returns 2\nminRoundsToSameChar(\"aaa\") // returns 0",
      "hu": "Írj egy JavaScript függvényt `function minRoundsToSameChar(s)` a következő probléma megoldására:\nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másikra. Ez a függvény kiszámítja a minimális körök számát, amelyek szükségesek ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon.\n@param {string} s - A bemeneti karakterlánc.\n@returns {number} A minimális körök száma, hogy az összes karakter a karakterláncban ugyanaz legyen.\n\nPéldák:\nminRoundsToSameChar(\"aab\") // visszaadja 1\nminRoundsToSameChar(\"abc\") // visszaadja 2\nminRoundsToSameChar(\"aaa\") // visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.9970435854086768",
      "hy": "0.9949494253014259",
      "bn": "0.9794534747553701",
      "bg": "0.9857367495986468",
      "zh": "0.9841236722742625",
      "fr": "0.9893206375636593",
      "de": "0.9824730538078625",
      "ha": "0.983472164624468",
      "hi": "0.9743411260082941",
      "hu": "0.9820273272328202"
    },
    "level": "middle",
    "test": "const testMinRoundsToSameChar = () => {\n    console.assert(minRoundsToSameChar(\"aab\") === 1, \"Expected 1 round for 'aab'\");\n    console.assert(minRoundsToSameChar(\"abc\") === 2, \"Expected 2 rounds for 'abc'\");\n    console.assert(minRoundsToSameChar(\"aaa\") === 0, \"Expected 0 rounds for 'aaa'\");\n    console.assert(minRoundsToSameChar(\"abab\") === 1, \"Expected 1 round for 'abab'\");\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0, \"Expected 0 rounds for 'zzzzz'\");\n};\n\ntestMinRoundsToSameChar();",
    "entry_point": "minRoundsToSameChar",
    "signature": "function minRoundsToSameChar(s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n@param {string} s - The input string.\n@returns {number} The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1\nminRoundsToSameChar(\"abc\") // returns 2\nminRoundsToSameChar(\"aaa\") // returns 0",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër në çdo raund. Kjo funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter.\n@param {string} s - Vargu hyrës.\n@returns {number} Numri minimal i raundeve për t'i bërë të gjithë karakteret në varg të njëjtë.\n\nShembuj:\nminRoundsToSameChar(\"aab\") // kthen 1\nminRoundsToSameChar(\"abc\") // kthen 2\nminRoundsToSameChar(\"aaa\") // kthen 0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում փոխել մեկ նշանը մյուսով: Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը նույն նշանով կազմված դարձնելու համար:\n@param {string} s - Մուտքային տողը:\n@returns {number} Նվազագույն ռաունդների քանակը, որպեսզի տողի բոլոր նիշերը դառնան նույնը:\n\nՕրինակներ:\nminRoundsToSameChar(\"aab\") // վերադարձնում է 1\nminRoundsToSameChar(\"abc\") // վերադարձնում է 2\nminRoundsToSameChar(\"aaa\") // վերադարձնում է 0",
      "bn": "একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম রাউন্ডের সংখ্যা গণনা করে।\n@param {string} s - ইনপুট স্ট্রিং।\n@returns {number} স্ট্রিংয়ের সমস্ত অক্ষর একই করতে ন্যূনতম রাউন্ড সংখ্যা।\n\nউদাহরণ:\nminRoundsToSameChar(\"aab\") // 1 রিটার্ন করে\nminRoundsToSameChar(\"abc\") // 2 রিটার্ন করে\nminRoundsToSameChar(\"aaa\") // 0 রিটার্ন করে",
      "bg": "Даден е низ, състоящ се от малки английски букви, можете да промените един символ на друг във всеки кръг. Тази функция изчислява минималния брой кръгове, необходими, за да направите низа съставен от един и същ символ.\n@param {string} s - Входният низ.\n@returns {number} Минималният брой кръгове, за да направите всички символи в низа еднакви.\n\nПримери:\nminRoundsToSameChar(\"aab\") // връща 1\nminRoundsToSameChar(\"abc\") // връща 2\nminRoundsToSameChar(\"aaa\") // връща 0",
      "zh": "给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。此函数计算使字符串由相同字符组成所需的最小轮数。\n@param {string} s - 输入字符串。\n@returns {number} 使字符串中的所有字符相同所需的最小轮数。\n示例：\nminRoundsToSameChar(\"aab\") // 返回 1\nminRoundsToSameChar(\"abc\") // 返回 2\nminRoundsToSameChar(\"aaa\") // 返回 0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère.\n@param {string} s - La chaîne d'entrée.\n@returns {number} Le nombre minimum de tours pour rendre tous les caractères de la chaîne identiques.\n\nExemples :\nminRoundsToSameChar(\"aab\") // retourne 1\nminRoundsToSameChar(\"abc\") // retourne 2\nminRoundsToSameChar(\"aaa\") // retourne 0",
      "de": "Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu machen.\n\n@param {string} s - Der Eingabestring.\n@returns {number} Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n\nBeispiele:\nminRoundsToSameChar(\"aab\") // gibt 1 zurück\nminRoundsToSameChar(\"abc\") // gibt 2 zurück\nminRoundsToSameChar(\"aaa\") // gibt 0 zurück",
      "ha": "An ba da wani kirtani mai ƙunshe da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani a kowace zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi iri ɗaya.\n@param {string} s - Kirtani mai shigarwa.  \n@returns {number} Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin kirtani iri ɗaya.  \n\nMisalai:  \nminRoundsToSameChar(\"aab\") // returns 1  \nminRoundsToSameChar(\"abc\") // returns 2  \nminRoundsToSameChar(\"aaa\") // returns 0  ",
      "hi": "दिए गए एक स्ट्रिंग में जो छोटे अक्षरों वाले अंग्रेजी अक्षरों से बनी होती है, आप प्रत्येक राउंड में एक अक्षर को दूसरे में बदल सकते हैं। यह फ़ंक्शन न्यूनतम राउंड की संख्या की गणना करता है जो स्ट्रिंग को एक ही अक्षर से बनी बनाने के लिए आवश्यक है।\n@param {string} s - इनपुट स्ट्रिंग।\n\n@returns {number} स्ट्रिंग के सभी अक्षरों को समान बनाने के लिए न्यूनतम राउंड की संख्या।\n\nउदाहरण:\nminRoundsToSameChar(\"aab\") // 1 लौटाता है\nminRoundsToSameChar(\"abc\") // 2 लौटाता है\nminRoundsToSameChar(\"aaa\") // 0 लौटाता है",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, amelyben minden körben megváltoztathat egy karaktert egy másikra. Ez a függvény kiszámítja a minimális körök számát, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon.\n@param {string} s - A bemeneti karakterlánc.\n@returns {number} A minimális körök száma, hogy a karakterlánc összes karaktere ugyanaz legyen.\n\nPéldák:\nminRoundsToSameChar(\"aab\") // visszaadja 1\nminRoundsToSameChar(\"abc\") // visszaadja 2\nminRoundsToSameChar(\"aaa\") // visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9963175913659942",
      "hy": "0.9806357227832898",
      "bn": "0.9865431889456484",
      "bg": "0.9876581012743972",
      "zh": "0.9840805694815778",
      "fr": "0.9718703626986012",
      "de": "1",
      "ha": "0.9876581012743972",
      "hi": "0.983660466225689",
      "hu": "0.9783355829709057"
    }
  },
  {
    "task_id": "JavaScript/32",
    "prompt": {
      "en": "\n/**\n * Calculates the year Y_n when the n-th event occurs, considering that each\n * event has a periodicity of a_i years. The countdown for event i+1 starts\n * the year after event i occurs.\n * @param {number} n - the total number of events\n * @param {number[]} signs - an array representing the periodicities of the events\n * @returns {number} The year when the n-th event occurs\n * \n * Example:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction apocalypseYear(n, signs)",
      "sq": "/**\n * Llogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që çdo\n * ngjarje ka një periodikë prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon\n * vitin pas ngjarjes i.\n * @param {number} n - numri total i ngjarjeve\n * @param {number[]} signs - një varg që përfaqëson periodikët e ngjarjeve\n * @returns {number} Viti kur ndodh ngjarja e n-të\n * \n * Shembull:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // kthen 36\n */",
      "hy": "/**\n * Հաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, հաշվի առնելով, որ \n * յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ i+1 իրադարձության \n * հետհաշվարկը սկսվում է i իրադարձության տեղի ունենալուց հետո։\n * @param {number} n - իրադարձությունների ընդհանուր քանակը\n * @param {number[]} signs - զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\n * @returns {number} Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n * \n * Օրինակ:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // վերադարձնում է 36\n */\nfunction apocalypseYear(n, signs)",
      "bn": "/**\n * গণনা করে Y_n বছর যখন n-তম ঘটনা ঘটে, বিবেচনা করে যে প্রতিটি\n * ঘটনার একটি a_i বছরের পর্যায়কাল রয়েছে। ঘটনা i+1 এর জন্য গণনা শুরু হয়\n * ঘটনা i ঘটার পরের বছর থেকে।\n * @param {number} n - মোট ঘটনার সংখ্যা\n * @param {number[]} signs - ঘটনাগুলির পর্যায়কাল প্রতিনিধিত্বকারী একটি অ্যারে\n * @returns {number} বছর যখন n-তম ঘটনা ঘটে\n * \n * উদাহরণ:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // 36 ফেরত দেয়\n */\nfunction apocalypseYear(n, signs)",
      "bg": "/**\n * Изчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко\n * събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва\n * годината след като се случи събитие i.\n * @param {number} n - общият брой на събитията\n * @param {number[]} signs - масив, представляващ периодичностите на събитията\n * @returns {number} Годината, когато се случва n-тото събитие\n * \n * Пример:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // връща 36\n */\nfunction apocalypseYear(n, signs)",
      "zh": "/**\n * 计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。\n * @param {number} n - 事件的总数\n * @param {number[]} signs - 一个表示事件周期性的数组\n * @returns {number} 第 n 个事件发生的年份\n * \n * 示例:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // 返回 36\n */\nfunction apocalypseYear(n, signs)",
      "fr": "/**\n * Calcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque\n * événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence\n * l'année après que l'événement i se produit.\n * @param {number} n - le nombre total d'événements\n * @param {number[]} signs - un tableau représentant les périodicités des événements\n * @returns {number} L'année où le n-ième événement se produit\n * \n * Exemple:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // returns 36\n */\nfunction apocalypseYear(n, signs)",
      "de": "/**\n * Berechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei jedes\n * Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt\n * im Jahr nach dem Eintreten von Ereignis i.\n * @param {number} n - die Gesamtanzahl der Ereignisse\n * @param {number[]} signs - ein Array, das die Periodizitäten der Ereignisse darstellt\n * @returns {number} Das Jahr, in dem das n-te Ereignis eintritt\n * \n * Beispiel:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // gibt 36 zurück\n */\nfunction apocalypseYear(n, signs)",
      "ha": "/**\n * Yana ƙididdige shekarar Y_n lokacin da taron na n-ya faru, la'akari da cewa kowanne\n * taron yana da tsawon lokaci na a_i shekaru. Kirga don taron i+1 yana farawa\n * shekarar bayan taron i ya faru.\n * @param {number} n - jimillar adadin abubuwan da suka faru\n * @param {number[]} signs - jerin lambobi da ke wakiltar tsawon lokaci na abubuwan da suka faru\n * @returns {number} Shekarar da taron na n-ya faru\n * \n * Misali:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // yana dawowa 36\n */\nfunction apocalypseYear(n, signs)",
      "hi": "/**\n * गणना करता है वर्ष Y_n जब n-वां घटना होती है, यह मानते हुए कि प्रत्येक\n * घटना की आवृत्ति a_i वर्षों की है। घटना i+1 की उलटी गिनती\n * घटना i के होने के अगले वर्ष से शुरू होती है।\n * @param {number} n - कुल घटनाओं की संख्या\n * @param {number[]} signs - घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक array\n * @returns {number} वह वर्ष जब n-वां घटना होती है\n * \n * उदाहरण:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // 36 लौटाता है\n */\nfunction apocalypseYear(n, signs)",
      "hu": "/**\n * Kiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden\n * esemény a_i éves periódussal rendelkezik. Az i+1 esemény visszaszámlálása\n * az i esemény bekövetkezése utáni évben kezdődik.\n * @param {number} n - az események teljes száma\n * @param {number[]} signs - egy tömb, amely az események periódusait reprezentálja\n * @returns {number} Az év, amikor az n-edik esemény bekövetkezik\n * \n * Példa:\n * apocalypseYear(6, [3,2,4,5,9,18])\n * // visszaadja: 36\n */\nfunction apocalypseYear(n, signs)"
    },
    "prompt_bertscore": {
      "sq": "0.9666271165304232",
      "hy": "0.9772369583334019",
      "bn": "0.9708255668943577",
      "bg": "0.9951697063939936",
      "zh": "0.9612190071459864",
      "fr": "1",
      "de": "0.9829924722542688",
      "ha": "0.9593113609665272",
      "hi": "0.9646195592693037",
      "hu": "0.9635980032196412"
    },
    "canonical_solution": "{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function apocalypseYear(n, signs)` to solve the following problem:\nCalculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18])\n// returns 36",
      "sq": "Shkruani një funksion JavaScript `function apocalypseYear(n, signs)` për të zgjidhur problemin në vijim:  \nLlogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që secila ngjarje ka një periodicitet prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon vitin pas ngjarjes i që ndodh.  \nParametrat:  \n- n (numër): Numri total i ngjarjeve  \n- signs (numër[]): Një varg që përfaqëson periodicitetet e ngjarjeve  \nKthen:  \n- numër: Viti kur ndodh ngjarja e n-të  \n\nShembull:  \napocalypseYear(6, [3,2,4,5,9,18])  \n// kthen 36",
      "hy": "Գրեք JavaScript ֆունկցիա `function apocalypseYear(n, signs)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, հաշվի առնելով, որ յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ Իրադարձություն i+1-ի համար հետհաշվարկը սկսվում է իրադարձություն i-ի տեղի ունենալուց հետո։\nՊարամետրեր՝\n- n (թիվ): Իրադարձությունների ընդհանուր քանակը\n- signs (թիվ[]): Զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\nՎերադարձնում է՝\n- թիվ: Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n\nՕրինակ:\napocalypseYear(6, [3,2,4,5,9,18])\n// վերադարձնում է 36",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function apocalypseYear(n, signs)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nহিসাব করে n-তম ঘটনাটি যে বছর Y_n-এ ঘটে, বিবেচনা করে যে প্রতিটি ঘটনার একটি a_i বছর পরপর পুনরাবৃত্তি হয়। ঘটনা i+1 এর জন্য কাউন্টডাউন শুরু হয় ঘটনা i ঘটার পরের বছর থেকে।\nপ্যারামিটারসমূহ:\n- n (সংখ্যা): মোট ঘটনার সংখ্যা\n- signs (number[]): ঘটনাগুলির পুনরাবৃত্তির সময়কাল নির্দেশ করে এমন একটি অ্যারে\nফেরত দেয়:\n- সংখ্যা: যে বছর n-তম ঘটনা ঘটে\n\nউদাহরণ:\napocalypseYear(6, [3,2,4,5,9,18])\n// 36 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function apocalypseYear(n, signs)`, за да решите следния проблем:\nИзчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва годината след като събитие i се случи.\nПараметри:\n- n (number): Общият брой на събитията\n- signs (number[]): Масив, представляващ периодичностите на събитията\nВръща:\n- number: Годината, когато се случва n-тото събитие\n\nПример:\napocalypseYear(6, [3,2,4,5,9,18])\n// връща 36",
      "zh": "编写一个 JavaScript 函数 `function apocalypseYear(n, signs)` 来解决以下问题：  \n计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。  \n参数：  \n- n (number): 事件的总数  \n- signs (number[]): 一个数组，表示事件的周期性  \n返回：  \n- number: 第 n 个事件发生的年份  \n\n示例：  \napocalypseYear(6, [3,2,4,5,9,18])  \n// 返回 36  ",
      "fr": "Écrire une fonction JavaScript `function apocalypseYear(n, signs)` pour résoudre le problème suivant :\nCalcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence l'année après que l'événement i se produit.\nParamètres :\n- n (nombre) : Le nombre total d'événements\n- signs (nombre[]) : Un tableau représentant les périodicités des événements\nRenvoie :\n- nombre : L'année où le n-ième événement se produit\n\nExemple :\napocalypseYear(6, [3,2,4,5,9,18])\n// renvoie 36",
      "de": "Schreiben Sie eine JavaScript-Funktion `function apocalypseYear(n, signs)`, um das folgende Problem zu lösen:\nBerechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei jedes Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt im Jahr nach dem Eintreten von Ereignis i.\nParameter:\n- n (number): Die Gesamtanzahl der Ereignisse\n- signs (number[]): Ein Array, das die Periodizitäten der Ereignisse darstellt\nRückgabewert:\n- number: Das Jahr, in dem das n-te Ereignis eintritt\n\nBeispiel:\napocalypseYear(6, [3,2,4,5,9,18])\n// gibt 36 zurück",
      "ha": "Rubuta wani aikin JavaScript `function apocalypseYear(n, signs)` don warware matsalar mai zuwa:\nLissafa shekarar Y_n lokacin da abin da ya faru na n-th ya faru, la'akari da cewa kowane abin da ya faru yana da maimaituwa na a_i shekaru. Kirga don abin da ya faru na i+1 yana farawa shekara bayan abin da ya faru na i ya faru.\nSigogi:\n- n (lamba): Jimlar adadin abubuwan da suka faru\n- signs (lamba[]): Wani tsari da ke wakiltar maimaituwar abubuwan da suka faru\nMayarwa:\n- lamba: Shekarar da abin da ya faru na n-th ya faru\n\nMisali:\napocalypseYear(6, [3,2,4,5,9,18])\n// yana mayar da 36",
      "hi": "JavaScript फ़ंक्शन `function apocalypseYear(n, signs)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगणना करता है वर्ष Y_n जब n-वीं घटना होती है, यह मानते हुए कि प्रत्येक घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 के लिए उलटी गिनती घटना i के होने के अगले वर्ष से शुरू होती है।\nपैरामीटर्स:\n- n (संख्या): घटनाओं की कुल संख्या\n- signs (संख्या[]): घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक ऐरे\nवापसी करता है:\n- संख्या: वर्ष जब n-वीं घटना होती है\n\nउदाहरण:\napocalypseYear(6, [3,2,4,5,9,18])\n// 36 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function apocalypseYear(n, signs)` a következő probléma megoldására:\nKiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden esemény a_i évenkénti periodicitással rendelkezik. Az i+1-edik esemény visszaszámlálása azután az év után kezdődik, amikor az i-edik esemény bekövetkezik.\nParaméterek:\n- n (szám): Az események teljes száma\n- signs (szám[]): Egy tömb, amely az események periodicitását reprezentálja\nVisszatér:\n- szám: Az év, amikor az n-edik esemény bekövetkezik\n\nPélda:\napocalypseYear(6, [3,2,4,5,9,18])\n// visszaadja 36"
    },
    "instruction_bertscore": {
      "sq": "0.9988801219117253",
      "hy": "0.9809624697600922",
      "bn": "0.9592122444063909",
      "bg": "0.9926216758660781",
      "zh": "0.970992019153665",
      "fr": "0.9988801219117253",
      "de": "0.964905984278756",
      "ha": "0.9620802684781536",
      "hi": "0.9589603810832387",
      "hu": "0.9673896585632162"
    },
    "level": "easy",
    "test": "const testApocalypseYear = () => {\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36);\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5);\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5);\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012);\n    console.assert(apocalypseYear(2, [1, 2]) === 2);\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6);\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13);\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10);\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15);\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14);\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800);\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6);\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998);\n};\n\ntestApocalypseYear();",
    "entry_point": "apocalypseYear",
    "signature": "function apocalypseYear(n, signs)",
    "docstring": {
      "en": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\nParameters:\n- n (number): The total number of events\n- signs (number[]): An array representing the periodicities of the events\nReturns:\n- number: The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18])\n// returns 36",
      "sq": "Llogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh se çdo ngjarje ka një periodicitet prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon vitin pas ngjarjes i.\nParametrat:\n- n (numër): Numri total i ngjarjeve\n- signs (numër[]): Një varg që përfaqëson periodicitetet e ngjarjeve\nKthen:\n- numër: Viti kur ndodh ngjarja e n-të\n\nShembull:\napocalypseYear(6, [3,2,4,5,9,18])\n// kthen 36",
      "hy": "Հաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը՝ հաշվի առնելով, որ յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ Իրադարձություն i+1-ի հետհաշվարկը սկսվում է i իրադարձության տեղի ունենալուց հետո հաջորդ տարում։\nՊարամետրեր՝\n- n (թիվ): Իրադարձությունների ընդհանուր քանակը\n- signs (թիվ[]): Զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\nՎերադարձնում է՝\n- թիվ: Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n\nՕրինակ:\napocalypseYear(6, [3,2,4,5,9,18])\n// վերադարձնում է 36",
      "bn": "n-তম ঘটনা কখন ঘটে তা গণনা করে, বিবেচনা করে যে প্রতিটি ঘটনার একটি a_i বছর পরপর পুনরাবৃত্তি ঘটে। ঘটনা i+1 এর জন্য কাউন্টডাউন শুরু হয় ঘটনা i ঘটার পরের বছর থেকে।\n\nপ্যারামিটারসমূহ:\n- n (number): মোট ঘটনার সংখ্যা\n- signs (number[]): ঘটনাগুলির পুনরাবৃত্তির সময়কাল নির্দেশকারী একটি অ্যারে\n\nরিটার্নস:\n- number: n-তম ঘটনা যখন ঘটে সেই বছর\n\nউদাহরণ:\napocalypseYear(6, [3,2,4,5,9,18])\n// 36 রিটার্ন করে",
      "bg": "Изчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва годината след като събитие i се случи.\nПараметри:\n- n (number): Общият брой на събитията\n- signs (number[]): Масив, представляващ периодичностите на събитията\nВръща:\n- number: Годината, когато се случва n-тото събитие\n\nПример:\napocalypseYear(6, [3,2,4,5,9,18])\n// връща 36",
      "zh": "计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。\n\n参数：\n- n (number): 事件的总数\n- signs (number[]): 一个表示事件周期性的数组\n\n返回：\n- number: 第 n 个事件发生的年份\n\n示例：\napocalypseYear(6, [3,2,4,5,9,18])\n// 返回 36",
      "fr": "Calcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence l'année après que l'événement i se produit.\n\nParamètres:\n- n (nombre) : Le nombre total d'événements\n- signs (nombre[]) : Un tableau représentant les périodicités des événements\n\nRetourne:\n- nombre : L'année où le n-ième événement se produit\n\nExemple:\napocalypseYear(6, [3,2,4,5,9,18])\n// retourne 36",
      "de": "Berechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei berücksichtigt wird, dass jedes Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt im Jahr nach dem Eintreten von Ereignis i.\nParameter:\n- n (number): Die Gesamtanzahl der Ereignisse\n- signs (number[]): Ein Array, das die Periodizitäten der Ereignisse darstellt\nRückgabe:\n- number: Das Jahr, in dem das n-te Ereignis eintritt\n\nBeispiel:\napocalypseYear(6, [3,2,4,5,9,18])\n// gibt 36 zurück",
      "ha": "Lissafa shekarar Y_n lokacin da abin da ya faru na n-th ya faru, la'akari da cewa kowane abin da ya faru yana da maimaituwa na a_i shekaru. Kirga don abin da ya faru na i+1 yana farawa shekara bayan abin da ya faru na i ya faru.\nSigogi:\n- n (number): Jimlar adadin abubuwan da suka faru\n- signs (number[]): Wani tsari da ke wakiltar lokutan abubuwan da suka faru\n\nReturns:\n- number: Shekarar da abin da ya faru na n-th zai faru\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18])\n// returns 36",
      "hi": "nवें घटना के घटित होने का वर्ष Y_n की गणना करता है, यह मानते हुए कि प्रत्येक घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 की उलटी गिनती घटना i के घटित होने के अगले वर्ष से शुरू होती है।\n\nपैरामीटर्स:\n- n (number): घटनाओं की कुल संख्या\n- signs (number[]): घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक ऐरे\n\nवापसी:\n- number: वह वर्ष जब nवीं घटना घटित होती है\n\nउदाहरण:\napocalypseYear(6, [3,2,4,5,9,18])\n// returns 36",
      "hu": "Kiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden eseménynek a_i éves periódusa van. Az i+1. esemény visszaszámlálása az i. esemény bekövetkezése utáni évben kezdődik.\nParaméterek:\n- n (szám): Az események teljes száma\n- signs (szám[]): Egy tömb, amely az események periódusait jelöli\nVisszatérési érték:\n- szám: Az év, amikor az n-edik esemény bekövetkezik\n\nPélda:\napocalypseYear(6, [3,2,4,5,9,18])\n// visszaadja 36"
    },
    "docstring_bertscore": {
      "sq": "0.9930463476207306",
      "hy": "0.9626332554589547",
      "bn": "0.9217579038673093",
      "bg": "0.9933774644659158",
      "zh": "0.9685909751077152",
      "fr": "0.9977948055097506",
      "de": "0.9656842181116506",
      "ha": "0.9640486955542094",
      "hi": "0.9446214525067111",
      "hu": "0.9451871518318985"
    }
  },
  {
    "task_id": "JavaScript/33",
    "prompt": {
      "en": "\n/**\n * This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\n * Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\n * Then the result is the remainder of x' divided by y. \n * For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Given a prime number p, there will be several queries. For each query, an integer n is given,\n * and you need to compute the value of n! ⊕ p, where n! is the factorial of n,\n * i.e. the product of all positive integers less than or equal to n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n, p)",
      "sq": "/**\n * Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".\n * Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y.\n * Përndryshe, ndaj x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.\n * Pastaj rezultati është mbetja e x' e ndarë me y.\n * Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Duke pasur një numër të thjeshtë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n,\n * dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,\n * dmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n * \n * @example\n * newModuloFactorial(3, 7); // kthen 6\n */\nfunction newModuloFactorial(n, p)",
      "hy": "/**\n * Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է \"⊕\" նշանով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ի բաժանման մնացորդն է:\n * Հակառակ դեպքում, բազմիցս բաժանեք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':\n * Ապա արդյունքը x'-ի y-ի բաժանման մնացորդն է: \n * Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\n * Տրված է p պարզ թիվը, լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը,\n * և դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\n * այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n * \n * @example\n * newModuloFactorial(3, 7); // վերադարձնում է 6\n */\nfunction newModuloFactorial(n, p)",
      "bn": "/**\n * এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত।\n * x ⊕ y গণনা করার সময়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হল x কে y দ্বারা ভাগ করার অবশিষ্টাংশ।\n * অন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন।\n * তারপর ফলাফল হল x' কে y দ্বারা ভাগ করার অবশিষ্টাংশ। \n * উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হলে, সেখানে বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হবে,\n * এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\n * অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n, p)",
      "bg": "/**\n * Този проблем въвежда нова операция за модуло, обозначена със символа \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделено на y.\n * В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, обозначавайки крайната стойност като x'.\n * Тогава резултатът е остатъкът от x', разделено на y.\n * Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n,\n * и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,\n * т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n * \n * @example\n * newModuloFactorial(3, 7); // връща 6\n */\nfunction newModuloFactorial(n, p)",
      "zh": "/**\n * 这个问题引入了一种新的模运算，用符号“⊕”表示。\n * 计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n * 否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。\n * 然后结果是 x' 除以 y 的余数。\n * 例如，4⊕5=4，20⊕5=4，100⊕5=4。\n * 给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n * 你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n * 即小于或等于 n 的所有正整数的乘积。\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */",
      "fr": "/**\n * Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\n * Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale par x'.\n * Ensuite, le résultat est le reste de x' divisé par y.\n * Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Étant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\n * et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\n * c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n, p)",
      "de": "/**\n * Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\n * Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\n * Andernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird.\n * Dann ist das Ergebnis der Rest von x' geteilt durch y.\n * Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Gegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\n * und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\n * d.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n * \n * @example\n * newModuloFactorial(3, 7); // gibt 6 zurück\n */\nfunction newModuloFactorial(n, p)",
      "ha": "/**\n * Wannan matsala tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba ya kasu ba tare da saura ba ga y, sakamakon shi ne saura na x raba y.\n * In ba haka ba, a raba x da y akai-akai har sai x ba ya kasu ba tare da saura ba ga y, ana nuni da ƙimar ƙarshe a matsayin x'.\n * Sannan sakamakon shi ne saura na x' raba y.\n * Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * An ba da lamba mai firamare p, za a sami tambayoyi da dama. Don kowace tambaya, ana ba da cikakken lamba n,\n * kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\n * wato samfurin duk lambobi masu kyau da suka fi ko dai dai da n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n, p)",
      "hi": "/**\n * इस समस्या में एक नया मॉड्यूलो ऑपरेशन प्रस्तुत किया गया है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है।\n * जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है।\n * अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए।\n * फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है।\n * उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है,\n * और आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है,\n * अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n, p)",
      "hu": "/**\n * Ez a probléma bevezet egy új modulo műveletet, amelyet a \"⊕\" szimbólum jelöl.\n * Amikor x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-val osztva.\n * Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként.\n * Ekkor az eredmény x' maradéka y-val osztva. \n * Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Adott egy prímszám p, több lekérdezés lesz. Minden lekérdezésnél adott egy egész szám n,\n * és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\n * azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n * \n * @példa\n * newModuloFactorial(3, 7); // visszaadja 6\n */\nfunction newModuloFactorial(n, p)"
    },
    "prompt_bertscore": {
      "sq": "0.990776995517407",
      "hy": "0.9739716734995693",
      "bn": "0.9858948593819505",
      "bg": "0.996874749584797",
      "zh": "0.9549551980800511",
      "fr": "0.9894128020604595",
      "de": "0.9812256550149634",
      "ha": "0.9537546760570763",
      "hi": "0.9626398102615289",
      "hu": "0.9739428720943192"
    },
    "canonical_solution": "{\n    const pj = new Array(p).fill(1);\n    for (let i = 2; i < p; i++) pj[i] = (i * pj[i - 1]) % p;\n    \n    let ans = 1;\n    while (n > 0) {\n        ans = (ans * pj[n % p]) % p;\n        ans = ((n / p) & 1) ? p - ans : ans;\n        n = Math.floor(n / p);\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function newModuloFactorial(n, p)` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y. \nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6\n",
      "sq": "Shkruani një funksion JavaScript `function newModuloFactorial(n, p)` për të zgjidhur problemin në vijim:\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".\nKur llogaritni x ⊕ y, nëse x nuk është një shumëfish i y, rezultati është mbetja e x e ndarë me y.\nPërndryshe, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më një shumëfish i y, duke e shënuar vlerën përfundimtare si x'.\nAtëherë rezultati është mbetja e x' e ndarë me y.\nPër shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n,\ndhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,\nd.m.th. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.",
      "hy": "Գրեք JavaScript ֆունկցիա `function newModuloFactorial(n, p)՝ հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներկայացնում է նոր մնացորդի գործողություն, որը նշվում է \"⊕\" նշանով:\nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ի բաժանման մնացորդն է:\nՀակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':\nԱյնուհետև արդյունքը x'-ի y-ի բաժանման մնացորդն է: \nՕրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է պարզ թիվ p, և լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է ամբողջ թիվ n,\nև դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\nայսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n\n@example\nnewModuloFactorial(3, 7); // վերադարձնում է 6",
      "bn": "একটি JavaScript ফাংশন `function newModuloFactorial(n, p)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" প্রতীকে নির্দেশিত।\nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করার পরে অবশিষ্টাংশ।\nঅন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে নির্দেশিত করুন।\nতারপর ফলাফল হয় x' কে y দিয়ে ভাগ করার পরে অবশিষ্টাংশ। \nউদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, সেখানে বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়,\nএবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\nঅর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "bg": "Напишете функция на JavaScript `function newModuloFactorial(n, p)` за решаване на следния проблем:\nТози проблем въвежда нова операция за модул, обозначена със символа \"⊕\".\nПри изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y.\nВ противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, обозначавайки крайната стойност като x'.\nТогава резултатът е остатъкът от x', разделен на y.\nНапример, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n,\nи трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,\nт.е. произведението на всички положителни цели числа, по-малки или равни на n.\n\n@example\nnewModuloFactorial(3, 7); // връща 6",
      "zh": "编写一个 JavaScript 函数 `function newModuloFactorial(n, p)` 来解决以下问题：\n这个问题引入了一种新的模运算，用符号“⊕”表示。\n计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n否则，重复将 x 除以 y，直到 x 不再是 y 的倍数，最终值记为 x'。\n然后结果是 x' 除以 y 的余数。\n例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n即小于或等于 n 的所有正整数的乘积。\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "fr": "Écrire une fonction JavaScript `function newModuloFactorial(n, p)` pour résoudre le problème suivant :\nCe problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\nSinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant la valeur finale comme x'.\nEnsuite, le résultat est le reste de x' divisé par y.\nPar exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\net vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\nc'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "de": "Schreiben Sie eine JavaScript-Funktion `function newModuloFactorial(n, p)`, um das folgende Problem zu lösen:\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\nAndernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'.\nDann ist das Ergebnis der Rest von x' geteilt durch y.\nZum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\nund Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\nd.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.",
      "ha": "Rubuta aikin JavaScript `function newModuloFactorial(n, p)` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da sabon aiki na modulo, wanda aka nuna da alamar \"⊕\".\nLokacin da ake lissafin x ⊕ y, idan x ba ya rabo da y, sakamakon shi ne saura na x raba da y.\nIn ba haka ba, raba x da y sau da yawa har sai x ba ya rabo da y, ana nuna ƙimar ƙarshe da x'.\nSa'an nan sakamakon shi ne saura na x' raba da y.\nMisali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai lamba p, za a sami tambayoyi da yawa. Ga kowane tambaya, an ba da lamba n,\nkuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\nwato samfurin duk lambobin kirki ƙasa ko daidai da n.",
      "hi": "JavaScript फ़ंक्शन `function newModuloFactorial(n, p)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" प्रतीक द्वारा दर्शाया गया है।\nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने का शेषफल होता है।\nअन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए।\nफिर परिणाम x' को y से विभाजित करने का शेषफल होता है।\nउदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nदिए गए एक अभाज्य संख्या p के लिए, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है,\nऔर आपको n! ⊕ p का मान गणना करना है, जहाँ n! n का फैक्टोरियल है,\nअर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "hu": "Írj egy JavaScript függvényt `function newModuloFactorial(n, p)` a következő probléma megoldására:\nEz a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl.\nAmikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva.\nEgyébként osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és jelöljük a végső értéket x'-ként.\nEzután az eredmény x' maradéka y-nal osztva. \nPéldául, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,\nés ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\nazaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nél.\n\n@example\nnewModuloFactorial(3, 7); // returns 6"
    },
    "instruction_bertscore": {
      "sq": "0.9668414387115599",
      "hy": "0.982379300268014",
      "bn": "0.9547374991824369",
      "bg": "0.9971266129079494",
      "zh": "0.9814199155276155",
      "fr": "0.9891897401425572",
      "de": "0.9627150911759411",
      "ha": "0.9534412373158032",
      "hi": "0.9504492678862747",
      "hu": "0.9537487171456452"
    },
    "level": "easy",
    "test": "(function testNewModuloFactorial() {\n    console.assert(newModuloFactorial(3, 7) === 6, 'Test at n=3, p=7 failed');\n    console.assert(newModuloFactorial(10, 3) === 1, 'Test at n=10, p=3 failed');\n    console.assert(newModuloFactorial(11, 7) === 4, 'Test at n=11, p=7 failed');\n    console.assert(newModuloFactorial(45, 7) === 1, 'Test at n=45, p=7 failed');\n    console.assert(newModuloFactorial(14, 7) === 2, 'Test at n=14, p=7 failed');\n    console.assert(newModuloFactorial(1919, 10007) === 3152, 'Test at n=1919, p=10007 failed');\n    console.assert(newModuloFactorial(810, 10007) === 3679, 'Test at n=810, p=10007 failed');\n    console.assert(newModuloFactorial(1, 2) === 1, 'Test at n=1, p=2 failed');\n    console.assert(newModuloFactorial(5, 11) === 10, 'Test at n=5, p=11 failed');\n    console.assert(newModuloFactorial(6, 13) === 5, 'Test at n=6, p=13 failed');\n    console.assert(newModuloFactorial(8, 17) === 13, 'Test at n=8, p=17 failed');\n    console.assert(newModuloFactorial(15, 19) === 16, 'Test at n=15, p=19 failed');\n    console.assert(newModuloFactorial(21, 23) === 1, 'Test at n=21, p=23 failed');\n    console.assert(newModuloFactorial(30, 29) === 28, 'Test at n=30, p=29 failed');\n    console.assert(newModuloFactorial(100, 101) === 100, 'Test at n=100, p=101 failed');\n})();",
    "entry_point": "newModuloFactorial",
    "signature": "function newModuloFactorial(n, p)",
    "docstring": {
      "en": "This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y. \nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6\n",
      "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".  \nKur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y.  \nPërndryshe, ndaj x me y vazhdimisht derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.  \nPastaj rezultati është mbetja e x' e ndarë me y.  \nPër shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nDuke pasur një numër të plotë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n,  \ndhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,  \ndmth. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n\n@example\nnewModuloFactorial(3, 7); // kthen 6",
      "hy": "Այս խնդիրը ներկայացնում է նոր մոդուլո գործողություն, որը նշվում է \"⊕\" նշանով։ \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ի բաժանումից մնացորդն է։ \nՀակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնվող կերպով, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x'։ \nԱյնուհետև արդյունքը x'-ի y-ի բաժանումից մնացորդն է։ \nՕրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4։ \nՏրված է p պարզ թիվ, և կլինեն մի քանի հարցումներ։ Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը,\nև դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\nայսինքն՝ բոլոր դրական ամբողջ թվերի արտադրյալը, որոնք փոքր կամ հավասար են n-ին։\n\n@example\nnewModuloFactorial(3, 7); // վերադարձնում է 6",
      "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" প্রতীক দ্বারা চিহ্নিত করা হয়। \nযখন x ⊕ y গণনা করা হয়, যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। \nঅন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। \nতারপর ফলাফল হয় x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে তা। \nউদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়,\nএবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\nঅর্থাৎ n এর সমান বা তার চেয়ে ছোট সব ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "bg": "Този проблем въвежда нова операция модуло, обозначена със символа \"⊕\". \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y. \nВ противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като обозначите крайната стойност като x'. \nТогава резултатът е остатъкът от x', разделен на y. \nНапример, 4⊕5=4, 20⊕5=4, 100⊕5=4. \nДадено е просто число p, ще има няколко запитвания. За всяко запитване е дадено цяло число n, \nи трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n, \nт.е. произведението на всички положителни цели числа, по-малки или равни на n.\n\n@пример\nnewModuloFactorial(3, 7); // връща 6",
      "zh": "这个问题引入了一种新的模运算，用符号“⊕”表示。\n当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n否则，重复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。\n然后结果是 x' 除以 y 的余数。\n例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n即小于或等于 n 的所有正整数的乘积。\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\nSinon, divisez x par y à plusieurs reprises jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'.\nEnsuite, le résultat est le reste de x' divisé par y.\nPar exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\net vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\nc'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "de": "Diese Aufgabe führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\nBei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\nAndernfalls wird x wiederholt durch y geteilt, bis x kein Vielfaches von y mehr ist, wobei der Endwert als x' bezeichnet wird.\nDann ist das Ergebnis der Rest von x' geteilt durch y.\nZum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\nund Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\nd.h. das Produkt aller positiven ganzen Zahlen, die kleiner oder gleich n sind.\n\n@example\nnewModuloFactorial(3, 7); // gibt 6 zurück",
      "ha": "Wannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\".\nLokacin da ake lissafin x ⊕ y, idan x ba ya raba y ba tare da saura ba, sakamakon shi ne saura na x raba da y.\nIn ba haka ba, a raba x da y a kai a kai har sai x ya daina raba y ba tare da saura ba, ana nuna ƙimar ƙarshe a matsayin x'.\nSannan sakamakon shi ne saura na x' raba da y.\nMisali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai firam p, za a sami tambayoyi da yawa. Ga kowane tambaya, an ba da cikakken lamba n,\nkuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\nwato samfurin duk lambobin da suka fi ko daidai da n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "hi": "इस समस्या में एक नया माड्यूलो ऑपरेशन प्रस्तुत किया गया है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है। \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। \nअन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। \nतब परिणाम x' को y से विभाजित करने पर शेषफल होता है। \nउदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4। \nएक अभाज्य संख्या p दी गई है, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है, \nऔर आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, \nअर्थात n से कम या उसके बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n@example\nnewModuloFactorial(3, 7); // 6 लौटाता है",
      "hu": "Ez a probléma bevezet egy új modulo műveletet, amelyet a \"⊕\" szimbólum jelöl.\nAmikor az x ⊕ y értéket számítjuk ki, ha x nem osztható maradék nélkül y-nal, az eredmény x osztva y maradéka.\nEgyébként osszuk el x-et y-nal ismételten, amíg x már nem osztható maradék nélkül y-nal, az utolsó értéket x'-ként jelölve.\nEzután az eredmény x' osztva y maradéka. \nPéldául, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,\nés ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\nazaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n\n@example\nnewModuloFactorial(3, 7); // visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9781443019139692",
      "hy": "0.9854860780577808",
      "bn": "0.9705135185657519",
      "bg": "0.9915103388841878",
      "zh": "0.9761170802451271",
      "fr": "0.9880432455832239",
      "de": "0.9762042789824015",
      "ha": "0.9554557466402591",
      "hi": "0.9635255031305635",
      "hu": "0.9460700638755986"
    }
  },
  {
    "task_id": "JavaScript/34",
    "prompt": {
      "en": "\n/**\n * You are given an array a of n integers. You can perform at most one operation where\n * you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n * with x, at a cost of (j - i + 1).\n * Find the minimum cost to make all elements in the array equal.\n */\nfunction makeEqualAgain(n, a)",
      "sq": "/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j]\n * me x, me një kosto prej (j - i + 1).\n * Gjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n */\nfunction makeEqualAgain(n, a)",
      "hy": "/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը\n * x-ով, արժեքով (j - i + 1)։\n * Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար։\n */\nfunction makeEqualAgain(n, a)",
      "bn": "/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে\n * আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে\n * x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\n * অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n */\nfunction makeEqualAgain(n, a)",
      "bg": "/**\n * Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j]\n * с x, на цена (j - i + 1).\n * Намерете минималната цена, за да направите всички елементи в масива равни.\n */\nfunction makeEqualAgain(n, a)",
      "zh": "/**\n * 给定一个由 n 个整数组成的数组 a。你最多可以执行一次操作，\n * 在该操作中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，\n * 其代价为 (j - i + 1)。\n * 找出使数组中所有元素相等的最小代价。\n */\nfunction makeEqualAgain(n, a)",
      "fr": "/**\n * Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où\n * vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j]\n * par x, à un coût de (j - i + 1).\n * Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n */\nfunction makeEqualAgain(n, a)",
      "de": "/**\n * Sie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation ausführen, bei der\n * Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j]\n * mit x ersetzen, zu Kosten von (j - i + 1).\n * Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n */\nfunction makeEqualAgain(n, a)",
      "ha": "/**\n * An ba ku wani jerin lambobi a na n. Kuna iya yin aiki guda ɗaya kawai inda\n * za ku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\n * da x, a kan farashi na (j - i + 1).\n * Nemo mafi ƙarancin farashi don sanya dukkan abubuwa a cikin jerin su zama daidai.\n */\nfunction makeEqualAgain(n, a)",
      "hi": "/**\n * आपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ\n * आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को\n * x से बदल देते हैं, जिसकी लागत (j - i + 1) होती है।\n * सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n */\nfunction makeEqualAgain(n, a)",
      "hu": "/**\n * Adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol\n * kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet\n * kicseréled x-re, (j - i + 1) költséggel.\n * Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n */\nfunction makeEqualAgain(n, a)"
    },
    "prompt_bertscore": {
      "sq": "0.9954316998665786",
      "hy": "0.9503515417388055",
      "bn": "0.9985472173931108",
      "bg": "0.993110505233805",
      "zh": "0.9573653791235285",
      "fr": "0.9916609007130123",
      "de": "0.986273647518584",
      "ha": "0.9525950718925946",
      "hi": "0.9876926629606972",
      "hu": "0.9772184857079655"
    },
    "canonical_solution": "{\n    let j = 0, p = 1, q = 0, c, d;\n    let k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] !== a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] !== a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] !== a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] !== a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function makeEqualAgain(n, a)` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "sq": "Shkruani një funksion JavaScript `function makeEqualAgain(n, a)` për të zgjidhur problemin e mëposhtëm:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\nzgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j]\nme x, me një kosto prej (j - i + 1).\nGjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.",
      "hy": "Գրեք JavaScript ֆունկցիա `function makeEqualAgain(n, a)` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\nընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում զանգվածի բոլոր տարրերը a[i]-ից a[j]\nx-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։",
      "bn": "একটি JavaScript ফাংশন `function makeEqualAgain(n, a)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে\nআপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।",
      "bg": "Напишете JavaScript функция `function makeEqualAgain(n, a)`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\nизбирате три цели числа i, j, x (1 <= i <= j <= n) и замествате всички елементи от a[i] до a[j]\nс x, на цена от (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.",
      "zh": "编写一个 JavaScript 函数 `function makeEqualAgain(n, a)` 来解决以下问题：  \n给定一个包含 n 个整数的数组 a。你最多可以执行一次操作，选择三个整数 i, j, x (1 <= i <= j <= n)，并将 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找到使数组中所有元素相等的最小代价。",
      "fr": "Écrivez une fonction JavaScript `function makeEqualAgain(n, a)` pour résoudre le problème suivant :  \nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).  \nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function makeEqualAgain(n, a)`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der\nSie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j]\ndurch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.",
      "ha": "Rubuta aikin JavaScript `function makeEqualAgain(n, a)` don warware matsalar mai zuwa:\nAn baka wani array a na lambobi n. Zaka iya aiwatar da akalla daya daga cikin ayyuka inda\nzaka zabi lambobi uku i, j, x (1 <= i <= j <= n) kuma ka maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\nda x, a kan kudin (j - i + 1).\nNemo mafi karancin kudi don sanya duk abubuwan cikin array su zama daidai.",
      "hi": "`function makeEqualAgain(n, a)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों के एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ\nआप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।",
      "hu": "Írj egy JavaScript függvényt `function makeEqualAgain(n, a)` a következő probléma megoldására:\nAdott egy n egész számot tartalmazó tömb a. Legfeljebb egy műveletet hajthatsz végre, ahol\nkiválasztasz három egész számot i, j, x (1 <= i <= j <= n) és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen."
    },
    "instruction_bertscore": {
      "sq": "0.9956925015568774",
      "hy": "0.9509931178695482",
      "bn": "0.9985696626261678",
      "bg": "0.9940663146273447",
      "zh": "0.9725308087155422",
      "fr": "0.9985696626261678",
      "de": "0.9877361630141439",
      "ha": "0.9544965605302416",
      "hi": "0.9860694554868802",
      "hu": "0.9799562082497695"
    },
    "level": "middle",
    "test": "function testMakeEqualAgain() {\n    console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4);\n    console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0);\n    console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2);\n    console.assert(makeEqualAgain(3, [1, 2, 3]) === 2);\n    console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6);\n    console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7);\n    \n    console.assert(makeEqualAgain(3, [1, 2, 1]) === 1);\n    console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1);\n    console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0);\n    console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1);\n    console.assert(makeEqualAgain(1, [1]) === 0);\n    console.assert(makeEqualAgain(2, [1, 2]) === 1);\n    console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2);\n    console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2);\n    console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3);\n    console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5);\n\n}\n\ntestMakeEqualAgain();",
    "entry_point": "makeEqualAgain",
    "signature": "function makeEqualAgain(n, a)",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\nzgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j]\nme x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.",
      "hy": "Դուք ունեք n ամբողջ թվերից կազմված զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\nդուք ընտրում եք երեք ամբողջ թվեր՝ i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից մինչև a[j] բոլոր տարրերը\nx-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।",
      "bg": "Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.",
      "zh": "你有一个包含 n 个整数的数组 a。你可以最多执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最小代价。",
      "fr": "Vous disposez d'un tableau `a` de `n` entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers `i`, `j`, `x` (1 <= i <= j <= n) et remplacez tous les éléments de `a[i]` à `a[j]` par `x`, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] mit x ersetzt, zu Kosten von (j - i + 1). Finde die minimalen Kosten, um alle Elemente im Array gleich zu machen.",
      "ha": "An ba ku wani tsari a na n lambobi. Kuna iya aiwatar da akalla aiki guda ɗaya inda\nzaku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\nda x, a kan kuɗin (j - i + 1).\nNemo mafi ƙarancin kuɗi don sanya duk abubuwan cikin tsarin su zama daidai.",
      "hi": "आपको n पूर्णांकों की एक श्रृंखला a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जिसमें आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को श्रृंखला में समान बनाने की न्यूनतम लागत खोजें।",
      "hu": "Önnek adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthat végre, ahol kiválaszt három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től a[j]-ig terjedő összes elemet x-re cseréli, (j - i + 1) költséggel. Találja meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen."
    },
    "docstring_bertscore": {
      "sq": "0.9881421635129792",
      "hy": "0.9262888614890961",
      "bn": "0.9931373203352446",
      "bg": "0.9806563803429175",
      "zh": "0.9804613253087412",
      "fr": "0.9096821698522932",
      "de": "0.9865672232217536",
      "ha": "0.9620294191006087",
      "hi": "0.9657392387271974",
      "hu": "0.9794951871353874"
    }
  },
  {
    "task_id": "JavaScript/35",
    "prompt": {
      "en": "\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n * determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a \n * positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can \n * only move stones in the last pile loses. Assuming both players use the best possible strategy, find out \n * who will win the game.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "sq": "/**\n * Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, ku secili grumbull përmban një numër pozitiv gurësh,\n * përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin radhë duke lëvizur një \n * numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinjë në të djathtë. Lojtari që mund të \n * lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni \n * kush do të fitojë lojën.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "hy": "/**\n * Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է դրական թվով քարեր,\n * որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են \n * դրական թվով քարեր ձախից առաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ։ Խաղացողը, որը կարող է \n * միայն տեղափոխել քարերը վերջին կույտում, պարտվում է։ Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք \n * ով կհաղթի խաղը։\n *\n * @օրինակ\n * gameWinner([3, 1, 2, 2]) // վերադարձնում է \"Dan\"\n */",
      "bn": "/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত N পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যেখানে প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যা পাথর রয়েছে,\n * চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে \n * বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যা পাথর সরিয়ে নেয়। যে খেলোয়াড় \n * শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নিই উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, \n * খেলা কে জিতবে তা খুঁজে বের করুন।\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "bg": "/**\n * Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни,\n * определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват\n * положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може\n * да премества камъни само в последната купчина, губи. При условие, че и двамата играчи използват най-добрата възможна стратегия, установете\n * кой ще спечели играта.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "zh": "/**\n * 给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，\n * 确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流将\n * 左边第一个非空堆中的正数石头移动到相邻的右边堆。只能在最后一堆中移动石头的玩家输掉游戏。\n * 假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */",
      "fr": "/**\n * Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres,\n * déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant \n * un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut \n * déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, \n * découvrez qui gagnera le jeu.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "de": "/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält,\n * bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd \n * eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur \n * Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, \n * finden Sie heraus, wer das Spiel gewinnen wird.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "ha": "/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin yana dauke da adadin duwatsu masu kyau,\n * tantance wanda zai ci nasara a wasan da Charlie da Dan suke yi. Charlie ne zai fara, kuma suna juyawa suna motsa \n * adadin duwatsu masu kyau daga tarin da ke hagu wanda ba komai ba zuwa tarin da ke dama kusa. Dan wasan da zai iya \n * motsa duwatsu a cikin tarin karshe kadai zai yi rashin nasara. Ana tsammanin duka 'yan wasan suna amfani da \n * mafi kyawun dabaru, gano wanda zai ci nasara a wasan.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles)",
      "hi": "/**\n * दिए गए N पत्थरों के ढेरों की एक अनुक्रमिक श्रृंखला, जिन्हें 1 से N तक क्रमांकित किया गया है, के साथ, \n * जहाँ प्रत्येक ढेर में सकारात्मक संख्या में पत्थर हैं, चार्ली और डैन द्वारा खेले गए खेल के विजेता का निर्धारण करें। \n * चार्ली पहले जाता है, और वे बारी-बारी से बाएँ से दाएँ सबसे पहले गैर-खाली ढेर से सकारात्मक संख्या में पत्थर \n * लेकर उन्हें समीपवर्ती दाएँ ढेर में डालते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थर ले जा सकता है, हार जाता है। \n * मान लें कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // \"Dan\" लौटाता है\n */",
      "hu": "/**\n * Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, és mindegyik halom pozitív számú követ tartalmaz,\n * határozza meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy \n * pozitív számú követ a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, aki \n * csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, \n * ki fogja megnyerni a játékot.\n *\n * @példa\n * gameWinner([3, 1, 2, 2]) // visszatér \"Dan\"\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9863777298382463",
      "hy": "0.9716057870310627",
      "bn": "0.9565648986879579",
      "bg": "0.9791285154519971",
      "zh": "0.943989013373496",
      "fr": "0.9815718677691072",
      "de": "0.9678961660348552",
      "ha": "0.9376024507320813",
      "hi": "0.9142782782390595",
      "hu": "0.9519328382022243"
    },
    "canonical_solution": "{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    if (n === 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones === 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "Write a JavaScript function `function gameWinner(piles)` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "sq": "Shkruani një funksion JavaScript `function gameWinner(piles)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh,  \npërcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin kthesa duke lëvizur një  \nnumër pozitiv gurësh nga grumbulli më i majtë jo-bosh në grumbullin ngjitur në të djathtë. Lojtari që mund të  \nlëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni  \nkush do ta fitojë lojën.",
      "hy": "Գրեք JavaScript ֆունկցիա `function gameWinner(piles)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է քարերի N կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ:\nորոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են\nքարերի դրական քանակություն ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: Խաղացողը, ով կարող է\nմիայն քարեր տեղափոխել վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք\nով կհաղթի խաղը.",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function gameWinner(piles)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nধরা যাক ১ থেকে N পর্যন্ত নম্বরযুক্ত পাথরের Nটি স্তূপ রয়েছে, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, \nচার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে \nবামদিকের প্রথম খালি না থাকা স্তূপ থেকে ডান পাশের সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। \nযে খেলোয়াড় কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয় উভয় খেলোয়াড়ই \nসর্বোত্তম কৌশল ব্যবহার করে, খেলা কে জিতবে তা খুঁজে বের করুন।",
      "bg": "Напишете JavaScript функция `function gameWinner(piles)`, за да решите следния проблем:  \nДадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни,  \nопределете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да преместват  \nположителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може  \nда премества камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете  \nкой ще спечели играта.",
      "zh": "编写一个 JavaScript 函数 `function gameWinner(piles)` 来解决以下问题：  \n给定一个编号从 1 到 N 的石头堆序列，每堆包含一个正数的石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，他们轮流将一个正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉游戏。假设两位玩家都使用最佳策略，找出谁将赢得比赛。",
      "fr": "Écrire une fonction JavaScript `function gameWinner(piles)` pour résoudre le problème suivant :  \nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres,  \ndéterminer le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un  \nnombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut  \ndéplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez  \nqui gagnera le jeu.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function gameWinner(piles)`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.",
      "ha": "Rubuta wani aiki na JavaScript `function gameWinner(piles)` don warware matsalar mai zuwa:\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin yana dauke da adadi mai kyau na duwatsu,\n tantance wanda zai ci nasara a wani wasa da Charlie da Dan suka buga. Charlie ne ke farawa, kuma suna juyawa suna motsa a\n adadi mai kyau na duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa. Dan wasan da zai iya\n kawai motsa duwatsu a cikin tarin karshe ya rasa. Ana tsammanin duka 'yan wasan suna amfani da mafi kyawun dabaru, gano\n wanda zai ci nasara a wasan.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "hi": "JavaScript फ़ंक्शन `function gameWinner(piles)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए N पत्थरों के ढेरों की एक श्रृंखला, जिन्हें 1 से N तक क्रमांकित किया गया है, और प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन होगा। चार्ली पहले जाता है, और वे बारी-बारी से बाएँ से दाएँ सबसे पहले गैर-खाली ढेर से एक सकारात्मक संख्या में पत्थर को पास के दाएँ ढेर में ले जाते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थर ले जा सकता है, हार जाता है। मान लें कि दोनों खिलाड़ी सर्वश्रेष्ठ संभव रणनीति का उपयोग करते हैं, यह पता करें कि खेल कौन जीतेगा।",
      "hu": "Írj egy JavaScript függvényt `function gameWinner(piles)` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, 1-től N-ig számozva, ahol minden halom pozitív számú követ tartalmaz,\nhatározd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva mozgatnak egy\npozitív számú követ a bal szélső nem üres halomból a szomszédos jobb halomba. Az a játékos veszít, aki csak\naz utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítsd ki,\nki fogja megnyerni a játékot."
    },
    "instruction_bertscore": {
      "sq": "0.9455107207226043",
      "hy": "0.9406130914174271",
      "bn": "0.9045511498494",
      "bg": "0.943607245781147",
      "zh": "0.9202640047715459",
      "fr": "0.939360528234621",
      "de": "0.9180302075064275",
      "ha": "0.9624221113639146",
      "hi": "0.9188384345268584",
      "hu": "0.9319240053990558"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\", \"Test 1 failed\");\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\", \"Test 2 failed\");\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\", \"Test 3 failed\");\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\", \"Test 4 failed\");\n    console.assert(gameWinner([1, 1]) === \"Charlie\", \"Test 5 failed\");\n    console.assert(gameWinner([2, 1]) === \"Charlie\", \"Test 6 failed\");\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\", \"Test 7 failed\");\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\", \"Test 8 failed\");\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\", \"Test 9 failed\");\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\", \"Test 10 failed\");\n})();",
    "entry_point": "gameWinner",
    "signature": "function gameWinner(piles)",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, with each pile containing a positive number of stones,\n determine the winner of a game played by Charlie and Dan. Charlie goes first, and they take turns moving a\n positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player who can\n only move stones in the last pile loses. Assuming both players use the best possible strategy, find out\n who will win the game.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, me secilin grumbull që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, dhe ata marrin me radhë duke lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar se të dy lojtarët përdorin strategjinë më të mirë të mundshme, zbuloni kush do të fitojë lojën.\n\n@example\ngameWinner([3, 1, 2, 2]) // kthen \"Dan\"",
      "hy": "Տրված է N քարերի կույտերի հաջորդականություն, համարակալված 1-ից N, որտեղ յուրաքանչյուր կույտ պարունակում է քարերի դրական քանակ: որոշեք Չարլիի և Դենի կողմից խաղացած խաղի հաղթողը: Չարլին առաջինն է գնում, և նրանք հերթով տեղափոխում են դրական քանակի քարեր ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Խաղացողը, ով կարող է միայն քարեր տեղափոխել վերջին կույտում, պարտվում է: Ենթադրելով, որ երկու խաղացողներն էլ օգտագործում են հնարավոր լավագույն ռազմավարությունը, պարզեք, թե ով կհաղթի խաղը:\n\n@example\ngameWinner([3, 1, 2, 2]) // վերադարձնում է \"Dan\"",
      "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, এবং তারা পালাক্রমে বামদিকের প্রথম খালি না হওয়া স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। যে খেলোয়াড় শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। ধরে নেওয়া হয়েছে উভয় খেলোয়াড়ই সর্বোত্তম কৌশল ব্যবহার করে, খুঁজে বের করুন কে গেমটি জিতবে।\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, като всяка купчина съдържа положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва пръв и те се редуват да местят положителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който може да мести камъни само в последната купчина, губи. Приемайки, че и двамата играчи използват най-добрата възможна стратегия, разберете кой ще спечели играта.\n\n@example\ngameWinner([3, 1, 2, 2]) // връща \"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie先开始，他们轮流将正数的石头从最左边的非空堆移动到相邻的右边堆。只能在最后一堆移动石头的玩家输掉游戏。假设两位玩家都使用最佳策略，找出谁将赢得比赛。\n\n@example\ngameWinner([3, 1, 2, 2]) // 返回 \"Dan\"",
      "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chaque tas contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, et ils jouent à tour de rôle en déplaçant un nombre positif de pierres du tas non vide le plus à gauche vers le tas adjacent à droite. Le joueur qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant que les deux joueurs utilisent la meilleure stratégie possible, découvrez qui gagnera le jeu.\n\n@example\ngameWinner([3, 1, 2, 2]) // retourne \"Dan\"",
      "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, und sie ziehen abwechselnd eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Der Spieler, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide Spieler verwenden die bestmögliche Strategie, finden Sie heraus, wer das Spiel gewinnen wird.\n\n@example\ngameWinner([3, 1, 2, 2]) // gibt \"Dan\" zurück",
      "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, tare da kowanne tarin dauke da adadi mai kyau na duwatsu, tantance wanda zai ci nasara a wasan da Charlie da Dan suka buga. Charlie ne ke farawa, kuma suna juyawa suna motsa adadi mai kyau na duwatsu daga mafi hagu da ba komai a ciki zuwa tarin dama kusa. Dan wasan da zai iya motsa duwatsu a cikin tarin karshe kawai zai yi rashin nasara. Idan aka dauka cewa duka 'yan wasan suna amfani da mafi kyawun dabaru, gano wanda zai ci nasara a wasan.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "hi": "दिए गए पत्थरों के N ढेरों की एक अनुक्रमणिका है, जिन्हें 1 से N तक क्रमांकित किया गया है, जिसमें प्रत्येक ढेर में पत्थरों की एक सकारात्मक संख्या है, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन होगा। चार्ली पहले जाता है, और वे बारी-बारी से बाएं से दाएं सबसे निकटतम गैर-खाली ढेर से पत्थरों की एक सकारात्मक संख्या को दाएं सटे हुए ढेर में स्थानांतरित करते हैं। वह खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को स्थानांतरित कर सकता है, हार जाता है। यह मानते हुए कि दोनों खिलाड़ी सबसे अच्छी संभव रणनीति का उपयोग करते हैं, पता करें कि खेल कौन जीतेगा।\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" लौटाता है",
      "hu": "Adott egy N kövekből álló sorozat, amelyeket 1-től N-ig számoznak, és mindegyik halom pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék nyertesét. Charlie kezd, és felváltva mozgatnak egy pozitív számú követ a bal szélső nem üres halomból a szomszédos jobb halomba. Az a játékos veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve, hogy mindkét játékos a lehető legjobb stratégiát alkalmazza, derítse ki, ki fogja megnyerni a játékot.\n\n@example\ngameWinner([3, 1, 2, 2]) // visszaadja \"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.986256366675434",
      "hy": "0.9804569554403584",
      "bn": "0.9176355289393112",
      "bg": "0.9873623406370363",
      "zh": "0.9471043322696472",
      "fr": "0.9811539494474099",
      "de": "0.9630319066336918",
      "ha": "0.9595189297147088",
      "hi": "0.9528526954967969",
      "hu": "0.9603507937504828"
    }
  },
  {
    "task_id": "JavaScript/36",
    "prompt": {
      "en": "\n/**\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps\n * to the right and then open the door at that position. It is guaranteed that\n * C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n * \n * Example:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "sq": "/**\n * Duke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa\n * djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që\n * C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja minimale totale e nevojshme për të hapur të gjitha dyert.\n * \n * Shembull:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "hy": "/**\n * Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\n * Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝\n * i քայլ աջ շարժվելու և այն դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ\n * C_i >= C_{i+1} համար 1 <= i < n:\n * Խնդիրը կայանում է որոշելու բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n * \n * Օրինակ:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "bn": "/**\n * একটি বৃত্তে n দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i নির্বাচন করতে পারে এবং i ধাপ\n * ডানদিকে সরতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে\n * C_i >= C_{i+1} যেখানে 1 <= i < n।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n * \n * উদাহরণ:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */",
      "bg": "/**\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се придвижи i стъпки\n * надясно и след това да отвори вратата на тази позиция. Гарантирано е, че\n * C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n * \n * Пример:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "zh": "/**\n * 给定 n 个门排成一个圆圈，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付费用 C_i 向右移动 i 步，\n * 然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总费用。\n * \n * 示例:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "fr": "/**\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas\n * vers la droite puis ouvrir la porte à cette position. Il est garanti que\n * C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum requis pour ouvrir toutes les portes.\n * \n * Exemple :\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "de": "/**\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1.\n * Bei jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\n * nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\n * C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n * \n * Beispiel:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)",
      "ha": "/**\n * An ba da ƙofa n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.\n * Kowanne juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i\n * zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa\n * C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shi ne don tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofin.\n * \n * Misali:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */",
      "hi": "/**\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\n * प्रत्येक बारी में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है\n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि\n * C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n * \n * उदाहरण:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */",
      "hu": "/**\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést\n * jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy\n * C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n * \n * Példa:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n, C)"
    },
    "prompt_bertscore": {
      "sq": "0.9932769574931122",
      "hy": "0.9765989575495178",
      "bn": "0.9406843997242186",
      "bg": "0.9854040437104133",
      "zh": "0.9919930107101026",
      "fr": "0.9977912301628921",
      "de": "0.9785125626404079",
      "ha": "0.9736425429581945",
      "hi": "0.9563646792638747",
      "hu": "0.9592793814751807"
    },
    "canonical_solution": "{\n   return C[n-2] * (n - 1) + C[n-1];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function minTotalCost(n, C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "sq": "Shkruani një funksion JavaScript `function minTotalCost(n, C)` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1.  \nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa  \nnë të djathtë dhe pastaj të hapë derën në atë pozicion. Është e garantuar që  \nC_i >= C_{i+1} për 1 <= i < n.  \nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.  \n\nShembull:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "hy": "Գրեք JavaScript ֆունկցիա `function minTotalCost(n, C)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\nՅուրաքանչյուր քայլի ժամանակ, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու համար, ապա բացել այդ դիրքի դուռը: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bn": "একটি JavaScript ফাংশন `function minTotalCost(n, C)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে। \nপ্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে সরতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত করা হয়েছে যে 1 <= i < n এর জন্য C_i >= C_{i+1}। \nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bg": "Напишете JavaScript функция `function minTotalCost(n, C)`, за да решите следния проблем:  \nДадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:  \n    > minTotalCost(3, [1, 1, 1])  \n    3",
      "zh": "编写一个 JavaScript 函数 `function minTotalCost(n, C)` 来解决以下问题：  \n给定 n 扇门按圆形排列，玩家从第 1 扇门前开始。  \n每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。  \n保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "fr": "Écrire une fonction JavaScript `function minTotalCost(n, C)` pour résoudre le problème suivant :  \nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function minTotalCost(n, C)`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, der Spieler beginnt vor Tür 1.\nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\nnach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\nC_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "ha": "Rubuta aikin JavaScript `function minTotalCost(n, C)` don warware matsalar mai zuwa:  \nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.  \nA kowanne juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i  \nzuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa  \nC_i >= C_{i+1} don 1 <= i < n.  \nAikin shi ne ƙayyade mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "hi": "JavaScript फ़ंक्शन `function minTotalCost(n, C)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाज़े जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाज़ा 1 के सामने से शुरू करता है।\nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है और फिर उस स्थिति पर दरवाज़ा खोल सकता है। यह सुनिश्चित किया गया है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाज़े खोलने के लिए न्यूनतम कुल लागत क्या होगी।",
      "hu": "Írj egy JavaScript függvényt `function minTotalCost(n, C)` a következő probléma megoldására:  \nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.  \nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.  \nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:  \n    > minTotalCost(3, [1, 1, 1])  \n    3  "
    },
    "instruction_bertscore": {
      "sq": "0.9878783823669649",
      "hy": "0.9799093314798452",
      "bn": "0.9563503778764402",
      "bg": "0.9893917472400697",
      "zh": "0.9796425708781153",
      "fr": "0.9934920741957729",
      "de": "0.9920639217561321",
      "ha": "0.9775913149331681",
      "hi": "0.9250039215541814",
      "hu": "0.9724255346135937"
    },
    "level": "easy",
    "test": "function testMinTotalCost() {\n    console.assert(minTotalCost(5, [4, 3, 3, 3, 3]) === 15);\n    console.assert(minTotalCost(3, [1, 1, 1]) === 3);\n    console.assert(minTotalCost(4, [5, 4, 3, 2]) === 11);\n    console.assert(minTotalCost(4, [100, 99, 98, 97]) === 391);\n    console.assert(minTotalCost(6, [10, 9, 8, 7, 6, 5]) === 35);\n    console.assert(minTotalCost(7, [2, 2, 2, 2, 2, 2, 2]) === 14);\n    console.assert(minTotalCost(8, [9, 7, 7, 7, 7, 7, 7, 7]) === 56);\n    console.assert(minTotalCost(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]) === 18);\n    console.assert(minTotalCost(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]) === 50);\n    console.assert(minTotalCost(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === 11);\n\n}\n\ntestMinTotalCost();",
    "entry_point": "minTotalCost",
    "signature": "function minTotalCost(n, C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "sq": "Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n. Detyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դռան 1 դիմացից։ Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այն դիրքի դուռը բացելու համար։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար։ Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը։\n\nՕրինակ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। \nপ্রত্যেক টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে \nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে \nC_i >= C_{i+1} যেখানে 1 <= i < n। \nসকল দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করাই কাজ।\n\nউদাহরণ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "zh": "给定 n 个门按圆形排列，玩家从门 1 前面开始。  \n每一轮，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    > minTotalCost(3, [1, 1, 1])  \n    3  ",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n. La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1.\nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\nnach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\nC_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "ha": "An ba da ƙofa n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. A kowane juyi, ɗan wasa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne a tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।  \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह सुनिश्चित किया गया है कि  \nC_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ott lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén. A feladat az, hogy meghatározzuk az összes ajtó kinyitásához szükséges minimális összköltséget.\n\nPélda:\n    > minTotalCost(3, [1, 1, 1])\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9775235819732352",
      "hy": "0.9778612536209945",
      "bn": "0.9600961496019962",
      "bg": "0.996128296612868",
      "zh": "0.9909891327643523",
      "fr": "0.996128296612868",
      "de": "0.9929964913950908",
      "ha": "0.9749042431385281",
      "hi": "0.9506296242722544",
      "hu": "0.9685520435530324"
    }
  },
  {
    "task_id": "JavaScript/37",
    "prompt": {
      "en": "\n/**\n * Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\n * calculate the total number of handshakes that occur. Each student will shake hands with \n * every student already in the classroom who has a smaller ID number. The sequence represents \n * the order in which students enter the classroom.\n *\n * Examples:\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n, order)",
      "sq": "/**\n * Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në klasë, ku ID-të variojnë nga 0 deri në N-1,\n * llogarit numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me \n * çdo student që tashmë është në klasë dhe ka një numër ID më të vogël. Sekuenca përfaqëson \n * rendin në të cilin studentët hyjnë në klasë.\n *\n * Shembuj:\n *    countHandshakes(3, [2, 1, 0])  // kthen 0\n */\nfunction countHandshakes(n, order)",
      "hy": "/**\n * Տրված է ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1,\n * հաշվարկել ընդհանուր ձեռքսեղմումների քանակը, որոնք տեղի են ունենում։ Յուրաքանչյուր ուսանող ձեռք կսեղմի \n * արդեն դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, ով ունի ավելի փոքր ID համար։ Հաջորդականությունը ներկայացնում է \n * այն կարգը, որով ուսանողները մտնում են դասարան։\n *\n * Օրինակներ:\n *    countHandshakes(3, [2, 1, 0])  // վերադարձնում է 0\n */\nfunction countHandshakes(n, order)",
      "bn": "/**\n * একটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডি সমূহের একটি ক্রম দেওয়া হয়েছে, যেখানে আইডি 0 থেকে N-1 পর্যন্ত বিস্তৃত,\n * মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে \n * যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রম নির্দেশ করে।\n *\n * উদাহরণ:\n *    countHandshakes(3, [2, 1, 0])  // 0 ফেরত দেয়\n */\nfunction countHandshakes(n, order)",
      "bg": "/**\n * Дадена е последователност от студентски ID номера, влизащи в класната стая, където ID номерата варират от 0 до N-1,\n * изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с \n * всеки студент, който вече е в класната стая и има по-малък ID номер. Последователността представлява \n * реда, в който студентите влизат в класната стая.\n *\n * Примери:\n *    countHandshakes(3, [2, 1, 0])  // връща 0\n */\nfunction countHandshakes(n, order)",
      "zh": "/**\n * 给定一个进入教室的学生ID序列，其中ID范围从0到N-1，\n * 计算发生的握手总数。每个学生将与教室中已经存在的ID号较小的每个学生握手。\n * 该序列表示学生进入教室的顺序。\n *\n * 例子:\n *    countHandshakes(3, [2, 1, 0])  // 返回 0\n */\nfunction countHandshakes(n, order)",
      "fr": "/**\n * Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1,\n * calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de \n * chaque étudiant déjà dans la salle de classe qui a un numéro d'ID plus petit. La séquence représente \n * l'ordre dans lequel les étudiants entrent dans la salle de classe.\n *\n * Exemples :\n *    countHandshakes(3, [2, 1, 0])  // retourne 0\n */\nfunction countHandshakes(n, order)",
      "de": "/**\n * Gegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen,\n * berechne die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Student wird jedem Studenten die Hand schütteln,\n * der bereits im Klassenraum ist und eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n *\n * Beispiele:\n *    countHandshakes(3, [2, 1, 0])  // gibt 0 zurück\n */\nfunction countHandshakes(n, order)",
      "ha": "/**\n * An ba da jerin lambobin ID na ɗalibai suna shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1,\n * ƙididdige jimlar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da \n * kowane ɗalibi da ke cikin aji wanda ke da ƙaramin lambar ID. Jerin yana wakiltar \n * tsarin da ɗalibai ke shiga aji.\n *\n * Misalai:\n *    countHandshakes(3, [2, 1, 0])  // yana dawowa 0\n */\nfunction countHandshakes(n, order)",
      "hi": "/**\n * दिए गए अनुक्रम में छात्र आईडी के साथ एक कक्षा में प्रवेश करते हैं, जहां आईडी 0 से N-1 तक होती हैं,\n * कुल कितनी बार हाथ मिलाए जाते हैं, यह गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा \n * जो पहले से ही कक्षा में हैं और जिनकी आईडी संख्या उससे छोटी है। अनुक्रम उस क्रम को दर्शाता है \n * जिसमें छात्र कक्षा में प्रवेश करते हैं।\n *\n * उदाहरण:\n *    countHandshakes(3, [2, 1, 0])  // 0 लौटाता है\n */\nfunction countHandshakes(n, order)",
      "hu": "/**\n * Adott egy diákazonosító sorozat, akik belépnek egy tanterembe, ahol az azonosítók 0-tól N-1-ig terjednek,\n * számítsd ki a kézfogások összes számát, ami történik. Minden diák kezet fog minden olyan diákkal, \n * aki már a tanteremben van, és kisebb azonosítószámmal rendelkezik. A sorozat azt az sorrendet képviseli, \n * amelyben a diákok belépnek a tanterembe.\n *\n * Példák:\n *    countHandshakes(3, [2, 1, 0])  // 0-t ad vissza\n */\nfunction countHandshakes(n, order)"
    },
    "prompt_bertscore": {
      "sq": "0.9837216443830478",
      "hy": "0.9939803076723567",
      "bn": "0.9531029697769008",
      "bg": "0.978257521231159",
      "zh": "0.9813345044637706",
      "fr": "0.9971955376501684",
      "de": "0.9853430641834356",
      "ha": "0.9578025645921863",
      "hi": "0.9192770104081835",
      "hu": "0.9567736592184256"
    },
    "canonical_solution": "{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countHandshakes(n, order)` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n\nExamples:\ncountHandshakes(3, [2, 1, 0])  // returns 0",
      "sq": "Shkruani një funksion JavaScript `function countHandshakes(n, order)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1,\nllogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me\nçdo student që tashmë është në klasë dhe që ka një numër ID më të vogël. Sekuenca përfaqëson\nradhën në të cilën studentët hyjnë në klasë.\n\nShembuj:\ncountHandshakes(3, [2, 1, 0])  // kthen 0",
      "hy": "Գրեք JavaScript ֆունկցիա `function countHandshakes(n, order)`՝ հետևյալ խնդիրը լուծելու համար:\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1,\nհաշվեք ընդհանուր ձեռքսեղմումների քանակը, որոնք տեղի են ունենում։ Յուրաքանչյուր ուսանող ձեռք կսեղմի\nդասարանում արդեն գտնվող յուրաքանչյուր ուսանողի հետ, ով ունի ավելի փոքր ID համար։ Հաջորդականությունը ներկայացնում է\nդասարան մտնող ուսանողների կարգը։",
      "bn": "একটি JavaScript ফাংশন `function countHandshakes(n, order)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত রয়েছে, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র তার চেয়ে ছোট আইডি নম্বরের ছাত্রদের সাথে, যারা ইতিমধ্যে শ্রেণীকক্ষে আছে, হ্যান্ডশেক করবে। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\ncountHandshakes(3, [2, 1, 0])  // 0 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function countHandshakes(n, order)` за решаване на следния проблем:  \nДадена е последователност от идентификатори на ученици, които влизат в класната стая, където идентификаторите варират от 0 до N-1,  \nизчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с  \nвсеки ученик, който вече е в класната стая и има по-малък идентификационен номер. Последователността представлява  \nреда, в който учениците влизат в класната стая.\n\nПримери:  \ncountHandshakes(3, [2, 1, 0])  // връща 0",
      "zh": "编写一个 JavaScript 函数 `function countHandshakes(n, order)` 来解决以下问题：  \n给定一个进入教室的学生ID序列，其中ID的范围是从0到N-1，  \n计算发生的握手总数。每个学生将与教室中每个ID号较小的学生握手。该序列表示学生进入教室的顺序。\n\n示例：  \ncountHandshakes(3, [2, 1, 0])  // 返回 0",
      "fr": "Écrire une fonction JavaScript `function countHandshakes(n, order)` pour résoudre le problème suivant :  \nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1,  \ncalculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de  \nchaque étudiant déjà dans la salle de classe qui a un numéro d'ID plus petit. La séquence représente  \nl'ordre dans lequel les étudiants entrent dans la salle de classe.  \n\nExemples :  \ncountHandshakes(3, [2, 1, 0])  // returns 0",
      "de": "Schreiben Sie eine JavaScript-Funktion `function countHandshakes(n, order)`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von Studenten-IDs, die ein Klassenzimmer betreten, wobei die IDs von 0 bis N-1 reichen.\nBerechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Student wird jedem bereits im Klassenzimmer befindlichen Studenten die Hand schütteln, der eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten das Klassenzimmer betreten.\n\nBeispiele:\ncountHandshakes(3, [2, 1, 0])  // gibt 0 zurück",
      "ha": "Rubuta wani aikin JavaScript `function countHandshakes(n, order)` don warware matsalar mai zuwa:\nAn ba da jerin lambobin ID na ɗalibai da ke shiga aji, inda lambobin ID ɗin ke tsakanin 0 zuwa N-1,\nƙididdige jimlar adadin musabaha da ke faruwa. Kowanne ɗalibi zai yi musabaha da\nduk wani ɗalibi da ke cikin aji wanda ke da ƙaramin lamba ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\ncountHandshakes(3, [2, 1, 0])  // returns 0",
      "hi": "JavaScript फ़ंक्शन `function countHandshakes(n, order)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nएक कक्षा में प्रवेश करने वाले छात्र आईडी का अनुक्रम दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं,\nकुल हैंडशेक की संख्या की गणना करें जो होती है। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा\nजो पहले से कक्षा में हैं और जिनकी आईडी संख्या छोटी है। अनुक्रम दर्शाता है\nजिस क्रम में छात्र कक्षा में प्रवेश करते हैं।",
      "hu": "Írj egy JavaScript függvényt `function countHandshakes(n, order)` a következő probléma megoldására:\nAdott egy sorozat diákazonosító, akik belépnek egy osztályterembe, ahol az azonosítók 0-tól N-1-ig terjednek,\nszámítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog\nminden már az osztályteremben lévő diákkal, akinek kisebb az azonosító száma. A sorozat azt az sorrendet képviseli,\namelyben a diákok belépnek az osztályterembe.\n\nPéldák:\ncountHandshakes(3, [2, 1, 0])  // visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.9935935743204818",
      "hy": "0.950627439338063",
      "bn": "0.9658161086846578",
      "bg": "0.9836419936002528",
      "zh": "0.9845628440467306",
      "fr": "0.9974799763558104",
      "de": "0.9852171325218595",
      "ha": "0.9631554547306955",
      "hi": "0.9174214053885555",
      "hu": "0.9949627335369552"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2, \"Test 1 failed\");\n    console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15, \"Test 2 failed\");\n    console.assert(countHandshakes(3, [1, 2, 0]) === 1, \"Test 3 failed\");\n    console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0, \"Test 4 failed\");\n    console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6, \"Test 5 failed\");\n    console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0, \"Test 6 failed\");\n    console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5, \"Test 7 failed\");\n    console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3, \"Test 8 failed\");\n    console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4, \"Test 9 failed\");\n    console.assert(countHandshakes(3, [2, 0, 1]) === 1, \"Test 10 failed\");\n    console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7, \"Test 11 failed\");\n    console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0, \"Test 12 failed\");\n})();",
    "entry_point": "countHandshakes",
    "signature": "function countHandshakes(n, order)",
    "docstring": {
      "en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1,\ncalculate the total number of handshakes that occur. Each student will shake hands with\nevery student already in the classroom who has a smaller ID number. The sequence represents\nthe order in which students enter the classroom.\n\nExamples:\ncountHandshakes(3, [2, 1, 0])  // returns 0",
      "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në klasë, ku ID-të variojnë nga 0 deri në N-1,\nllogaritet numri total i shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me\nçdo student që tashmë është në klasë dhe që ka një numër ID më të vogël. Sekuenca përfaqëson\nradhën në të cilën studentët hyjnë në klasë.\n\nShembuj:\ncountHandshakes(3, [2, 1, 0])  // kthen 0",
      "hy": "Ունենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջունումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ողջունում է արդեն դասարանում գտնվող բոլոր ուսանողներին, որոնց ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մտնելու հերթականությունը։\n\nՕրինակներ:\ncountHandshakes(3, [2, 1, 0])  // վերադարձնում է 0",
      "bn": "প্রদত্ত একটি সিকোয়েন্স যেখানে ছাত্রদের আইডি রয়েছে যারা একটি শ্রেণীকক্ষে প্রবেশ করছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করুন। প্রতিটি ছাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে যার আইডি নম্বর ছোট। সিকোয়েন্সটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\ncountHandshakes(3, [2, 1, 0])  // 0 রিটার্ন করে",
      "bg": "Дадена е последователност от идентификатори на студенти, влизащи в класна стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая и има по-малък идентификационен номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\ncountHandshakes(3, [2, 1, 0])  // връща 0",
      "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与已经在教室中且ID号较小的每个学生握手。序列表示学生进入教室的顺序。\n\n示例：\ncountHandshakes(3, [2, 1, 0])  // 返回 0",
      "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe qui a un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\ncountHandshakes(3, [2, 1, 0])  // retourne 0",
      "de": "Angenommen, eine Sequenz von Studenten-IDs betritt einen Klassenraum, wobei die IDs von 0 bis N-1 reichen, berechnen Sie die Gesamtanzahl der stattfindenden Händedrucke. Jeder Student wird mit jedem bereits im Klassenraum befindlichen Studenten, der eine kleinere ID-Nummer hat, Händeschütteln. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\ncountHandshakes(3, [2, 1, 0])  // gibt 0 zurück",
      "ha": "An ba da jerin lambobin dalibai suna shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, ƙididdige adadin yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai gaisa da kowanne dalibi da ke cikin aji wanda ke da ƙaramin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\ncountHandshakes(3, [2, 1, 0])  // yana dawowa 0",
      "hi": "एक कक्षा में प्रवेश करने वाले छात्र आईडी की एक अनुक्रम दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हाथ मिलाने की संख्या की गणना करें जो होती है। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से कक्षा में हैं और जिनकी आईडी संख्या छोटी है। अनुक्रम उस क्रम को दर्शाता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\ncountHandshakes(3, [2, 1, 0])  // 0 लौटाता है",
      "hu": "Adott egy diákazonosítókból álló sorozat, akik belépnek egy osztályterembe, ahol az azonosítók 0-tól N-1-ig terjednek, számítsuk ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden olyan diákkal, aki már az osztályteremben van, és kisebb azonosító számmal rendelkezik. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\ncountHandshakes(3, [2, 1, 0])  // visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9779035618921549",
      "hy": "0.9437991227292266",
      "bn": "0.9598305807825525",
      "bg": "0.9768879647539235",
      "zh": "0.9806065241172777",
      "fr": "0.9968469413314521",
      "de": "0.9806744557075916",
      "ha": "0.8945604389441072",
      "hi": "0.94778623036774",
      "hu": "0.9822237726796638"
    }
  },
  {
    "task_id": "JavaScript/38",
    "prompt": {
      "en": "\n/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n, counts)",
      "sq": "/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, \n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e \n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh \n * ndër elementët më të shpeshtë në një sekuencë.\n * Për shembull:\n *   maxModeSum(3, [1, 2, 3])\n *   Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.\n */\nfunction maxModeSum(n, counts)",
      "hy": "/**\n * Տրված է n դրական ամբողջ թիվ, որը ներկայացնում է 1-ից n թվերի քանակը,\n * գտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար\n * հաջորդականության, որը կառուցված է այս թվերից։ Մոդան հաջորդականության ամենահաճախ հանդիպող տարրերի\n * մեջ ամենամեծ թիվն է։\n * Օրինակ:\n *   maxModeSum(3, [1, 2, 3])\n *   Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է։\n */\nfunction maxModeSum(n, counts)",
      "bn": "/**\n * ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপনকারী n ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে, \n * এই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \n * মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * উদাহরণস্বরূপ:\n *   maxModeSum(3, [1, 2, 3])\n *   একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।\n */ \nfunction maxModeSum(n, counts)",
      "bg": "/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на модата (най-често срещания елемент) за всички префикси на\n * последователност, конструирана от тези числа. Модата е най-голямото число\n * сред най-често срещаните елементи в последователност.\n * Например:\n *   maxModeSum(3, [1, 2, 3])\n *   Последователност, която достига максималната си стойност е [3, 2, 3, 1, 2, 2], и сумата е 17.\n */\nfunction maxModeSum(n, counts)",
      "zh": "/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中最大的数字。\n * 例如：\n *   maxModeSum(3, [1, 2, 3])\n *   一个达到最大值的序列是 [3, 2, 3, 1, 2, 2]，和是 17。\n */\nfunction maxModeSum(n, counts)",
      "fr": "/**\n * Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\n * trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une\n * séquence construite à partir de ces nombres. Le mode est le plus grand nombre\n * parmi les éléments les plus fréquents dans une séquence.\n * Par exemple :\n *   maxModeSum(3, [1, 2, 3])\n *   Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.\n */\nfunction maxModeSum(n, counts)",
      "de": "/**\n * Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * Zum Beispiel:\n *   maxModeSum(3, [1, 2, 3])\n *   Eine Sequenz, die ihren Maximalwert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.\n */\nfunction maxModeSum(n, counts)",
      "ha": "/**\n * An ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\n * nemo mafi girman jimillar yanayin (mafi yawan abu) don dukkan ƙarin\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba\n * tsakanin abubuwan da suka fi yawa a cikin jerin.\n * Alal misali:\n *   maxModeSum(3, [1, 2, 3])\n *   Jerin da ya kai ga ƙimar sa mafi girma shine [3, 2, 3, 1, 2, 2], kuma jimillar ita ce 17.\n */\nfunction maxModeSum(n, counts)",
      "hi": "/**\n * दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\n * जो इन संख्याओं से निर्मित होता है। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\n * उदाहरण के लिए:\n *   maxModeSum(3, [1, 2, 3])\n *   एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।\n */\nfunction maxModeSum(n, counts)",
      "hu": "/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számát jelölik, \n * keresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az \n * ezekből a számokból felépített sorozat minden előtagjára. A módusz a legnagyobb \n * szám a sorozat leggyakrabban előforduló elemei között.\n * Például:\n *   maxModeSum(3, [1, 2, 3])\n *   Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17.\n */\nfunction maxModeSum(n, counts)"
    },
    "prompt_bertscore": {
      "sq": "0.9891561716081624",
      "hy": "0.9590092441569732",
      "bn": "0.9838867062296878",
      "bg": "0.987805087756363",
      "zh": "0.9535735251495725",
      "fr": "0.998571053038835",
      "de": "0.998571053038835",
      "ha": "0.9433784235821948",
      "hi": "0.9811879152425668",
      "hu": "0.9520911466159091"
    },
    "canonical_solution": "{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n\n  for (let i = 0; i <= n; ++i) {\n    f[i] = 0;\n  }\n\n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function maxModeSum(n, counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   maxModeSum(3, [1, 2, 3]) A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "sq": "Shkruani një funksion JavaScript `function maxModeSum(n, counts)` për të zgjidhur problemin në vijim:  \nDuke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë. Për shembull: maxModeSum(3, [1, 2, 3]) Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.",
      "hy": "Գրեք JavaScript ֆունկցիա `function maxModeSum(n, counts)`՝ հետևյալ խնդիրը լուծելու համար: Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար, որոնք կազմված են այդ թվերից: Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի շարքում: Օրինակ՝ maxModeSum(3, [1, 2, 3]) Շարքը, որը հասնում է իր առավելագույն արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է:",
      "bn": "একটি JavaScript ফাংশন `function maxModeSum(n, counts)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনাকে উপস্থাপন করে, একটি ক্রম থেকে গঠিত প্রতিটি উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমে সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা। উদাহরণস্বরূপ: maxModeSum(3, [1, 2, 3]) একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।",
      "bg": "Напишете JavaScript функция `function maxModeSum(n, counts)`, за да решите следния проблем:  \nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, съставена от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност. Например: maxModeSum(3, [1, 2, 3]) Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.",
      "zh": "编写一个 JavaScript 函数 `function maxModeSum(n, counts)` 来解决以下问题：  \n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。例如：maxModeSum(3, [1, 2, 3]) 一个达到其最大值的序列是 [3, 2, 3, 1, 2, 2]，和为 17。",
      "fr": "Écrire une fonction JavaScript `function maxModeSum(n, counts)` pour résoudre le problème suivant :  \nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n, trouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence. Par exemple : maxModeSum(3, [1, 2, 3]) Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function maxModeSum(n, counts)`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen. Finden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz. Zum Beispiel: maxModeSum(3, [1, 2, 3]) Eine Sequenz, die ihren maximalen Wert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.",
      "ha": "Rubuta aikin JavaScript `function maxModeSum(n, counts)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (mafi yawan abu) don dukkanin gaban jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin abubuwan da suka fi yawa a cikin jerin. Alal misali: maxModeSum(3, [1, 2, 3]) Jerin da ya kai darajarsa mafi girma shine [3, 2, 3, 1, 2, 2], kuma jimlar ita ce 17.",
      "hi": "JavaScript फ़ंक्शन `function maxModeSum(n, counts)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है। उदाहरण के लिए: maxModeSum(3, [1, 2, 3]) एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।",
      "hu": "Írj egy JavaScript függvényt `function maxModeSum(n, counts)` a következő probléma megoldására:  \nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik. Találd meg a módusz (leggyakrabban előforduló elem) maximális összegét a számokból felépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között. Például: maxModeSum(3, [1, 2, 3]) Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17."
    },
    "instruction_bertscore": {
      "sq": "0.9907336940943414",
      "hy": "0.9508175286127134",
      "bn": "0.964900621258468",
      "bg": "0.9785940010966322",
      "zh": "0.9807292776927572",
      "fr": "1",
      "de": "0.9914122154759566",
      "ha": "0.9576134684694411",
      "hi": "0.9589542235414266",
      "hu": "0.9384084928183208"
    },
    "level": "easy",
    "test": "(function testMaxModeSum() {\n  console.assert(maxModeSum(3, [1, 3, 2]) === 17, 'Test case 1 failed');\n  console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37, 'Test case 2 failed');\n  console.assert(maxModeSum(2, [1, 1]) === 4, 'Test case 3 failed');\n  console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75, 'Test case 4 failed');\n  console.assert(maxModeSum(1, [100000]) === 100000, 'Test case 5 failed');\n  console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62, 'Test case 6 failed');\n  console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000, 'Test case 7 failed');\n  console.assert(maxModeSum(3, [2, 2, 5]) === 27, 'Test case 8 failed');\n  console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64, 'Test case 9 failed');\n  console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126, 'Test case 10 failed');\n  console.assert(maxModeSum(3, [3, 1, 2]) === 16, 'Test case 11 failed');\n})();",
    "entry_point": "maxModeSum",
    "signature": "function maxModeSum(n, counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence. For example:   maxModeSum(3, [1, 2, 3]) A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë. Për shembull: maxModeSum(3, [1, 2, 3]) Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մաքսիմալ գումարը մոդայի (ամենահաճախ հանդիպող տարրի) բոլոր նախածանցների համար, որոնք կառուցված են այս թվերից։ Մոդան ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի շարքում։ Օրինակ՝ maxModeSum(3, [1, 2, 3])։ Շարքը, որը հասնում է իր մաքսիմալ արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է։",
      "bn": "প্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, এই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা। উদাহরণস্বরূপ: \n\nmaxModeSum(3, [1, 2, 3]) একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, съставена от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователността. Например: maxModeSum(3, [1, 2, 3]) Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。例如：\n\nmaxModeSum(3, [1, 2, 3])\n\n一个达到其最大值的序列是 [3, 2, 3, 1, 2, 2]，其和为 17。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence. Par exemple : maxModeSum(3, [1, 2, 3]) Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.",
      "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen, finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz. Zum Beispiel: maxModeSum(3, [1, 2, 3]) Eine Sequenz, die ihren Maximalwert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe beträgt 17.",
      "ha": "An ba da lambobi masu kyau n waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (mafi yawan abu) don dukkanin gaban jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin abubuwan da suka fi yawa a cikin jerin. Alal misali:   maxModeSum(3, [1, 2, 3]) Wani jeri da ya kai matsakaicin ƙimar sa shine [3, 2, 3, 1, 2, 2], kuma jumlar ita ce 17.",
      "hi": "n धनात्मक पूर्णांकों को दिया गया है जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, इन संख्याओं से निर्मित अनुक्रम के सभी उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है। उदाहरण के लिए: \n\nmaxModeSum(3, [1, 2, 3]) एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelölik, találja meg az összes előtag móduszának (leggyakoribb elem) maximális összegét egy ezen számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat leggyakoribb elemei között. Például: maxModeSum(3, [1, 2, 3]) Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17."
    },
    "docstring_bertscore": {
      "sq": "0.9948592471084361",
      "hy": "0.9341518437527432",
      "bn": "0.9638462911959348",
      "bg": "0.9744293178974737",
      "zh": "0.9745119481359842",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9626346458716221",
      "hi": "0.9528604420816572",
      "hu": "0.9347878582328168"
    }
  },
  {
    "task_id": "JavaScript/39",
    "prompt": {
      "en": "\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n */\nfunction sumOfXorSubarrays(A)",
      "sq": "/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvargje përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.\n * Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\n * Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n *\n * Shembull:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // kthen 39\n */",
      "hy": "/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\n * Ենթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը:\n * Ենթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n *\n * Օրինակ:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // վերադարձնում է 39\n */\nfunction sumOfXorSubarrays(A)",
      "bn": "/**\n * পূর্ণসংখ্যার একটি অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যাতে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n *\n * উদাহরণ:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 ফেরত দেয়\n */\nfunction sumOfXorSubarrays(A)",
      "bg": "/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\n * Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= дължината на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n *\n * Пример:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // връща 39\n */\nfunction sumOfXorSubarrays(A)",
      "zh": "/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= 数组的长度。\n * 子数组的异或和是从L到R的所有元素进行异或运算的结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 返回39\n */",
      "fr": "/**\n * Étant donné un tableau A d'entiers, la tâche est de calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemple:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // retourne 39\n */\nfunction sumOfXorSubarrays(A)",
      "de": "/**\n * Gegeben ein Array A von ganzen Zahlen, ist die Aufgabe, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // gibt 39 zurück\n */\nfunction sumOfXorSubarrays(A)",
      "ha": "/**\n * An ba da jerin lambobi A, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.\n * Ana ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= tsawon jerin.\n * Jimillar XOR na ƙaramin jeri ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan jerin.\n *\n * Misali:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // yana dawowa 39\n */\nfunction sumOfXorSubarrays(A)",
      "hi": "/**\n * दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य यह है कि सभी उप-सरणियों के XOR का योग गणना करें।\n * एक उप-सरणी को (L, R) इंडेक्स की एक जोड़ी द्वारा परिभाषित किया जाता है, जिससे 1 <= L <= R <= सरणी की लंबाई।\n * एक उप-सरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम होता है।\n * अंतिम परिणाम सभी संभावित उप-सरणियों के लिए XOR योगों का योग होता है।\n *\n * उदाहरण:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 लौटाता है\n */\nfunction sumOfXorSubarrays(A)",
      "hu": "/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // visszaadja: 39\n */\nfunction sumOfXorSubarrays(A)"
    },
    "prompt_bertscore": {
      "sq": "0.973013281911076",
      "hy": "0.9737090841358411",
      "bn": "0.992388086537981",
      "bg": "0.9862833804072547",
      "zh": "0.9427398269071676",
      "fr": "0.9927138403628782",
      "de": "0.9762602927498533",
      "ha": "0.9574833655698632",
      "hi": "0.978797597237193",
      "hu": "0.9704114225499"
    },
    "canonical_solution": "{\n    const n = A.length;\n    let q = new Array(n + 1).fill(0);\n    let w = Array.from({ length: 21 }, () => [0, 0]);\n    let ans = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function sumOfXorSubarrays(A)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "sq": "Shkruani një funksion JavaScript `function sumOfXorSubarrays(A)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR e të gjitha nënvargjeve.  \nNjë nënvarg përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.  \nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.  \nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembull:  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // kthen 39",
      "hy": "JavaScript ֆունկցիա `function sumOfXorSubarrays(A)` գրել հետևյալ խնդիրը լուծելու համար: Տրված է ամբողջ թվերի զանգված A, խնդիրը բոլոր ենթազանգվածների XOR գումարը հաշվարկելն է: Ենթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը: Ենթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է: Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // վերադարձնում է 39",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function sumOfXorSubarrays(A)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function sumOfXorSubarrays(A)`, за да решите следния проблем:  \nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.  \nПодмасив се определя от двойка индекси (L, R), така че 1 <= L <= R <= дължината на масива.  \nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.  \nКрайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПример:  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // връща 39",
      "zh": "编写一个 JavaScript 函数 `function sumOfXorSubarrays(A)` 来解决以下问题：  \n给定一个整数数组 A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= 数组的长度。  \n子数组的异或和是从 L 到 R 的所有元素的异或结果。  \n最终结果是所有可能子数组的异或和的总和。  \n\n示例：  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 返回 39  ",
      "fr": "Écrire une fonction JavaScript `function sumOfXorSubarrays(A)` pour résoudre le problème suivant :  \nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.  \n\nExemple :  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // retourne 39",
      "de": "Schreiben Sie eine JavaScript-Funktion `function sumOfXorSubarrays(A)`, um das folgende Problem zu lösen:\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // gibt 39 zurück",
      "ha": "Rubuta wani aikin JavaScript `function sumOfXorSubarrays(A)` don warware matsalar mai zuwa:\nAn ba da wani array A na lambobi masu cikakken lamba, aikin shi ne a ƙididdige jumlar XOR na dukkan subarrays.\nAna ayyana wani subarray ta hanyar ma'aurata na alamomin (L, R) ta yadda 1 <= L <= R <= tsawon array.\nJumlar XOR na wani subarray ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jumlar XOR sums don dukkan subarrays masu yiwuwa.\n\nMisali:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39",
      "hi": "`function sumOfXorSubarrays(A)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी उप-श्रृंखलाओं के XOR का योग गणना करें।\nएक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है ताकि 1 <= L <= R <= array की लंबाई।\nएक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n\nउदाहरण:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function sumOfXorSubarrays(A)` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // visszaadja 39"
    },
    "instruction_bertscore": {
      "sq": "0.9854145711206082",
      "hy": "0.9649637857196371",
      "bn": "0.9782706308363074",
      "bg": "0.9831100614398414",
      "zh": "0.9649157171674266",
      "fr": "0.9935526564619885",
      "de": "0.9935526564619885",
      "ha": "0.9840481927294692",
      "hi": "0.9859812635977007",
      "hu": "0.9781367539594898"
    },
    "level": "middle",
    "test": "const testSumOfXorSubarrays = () => {\n    console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39);\n    console.assert(sumOfXorSubarrays([1, 1, 1]) === 4);\n    console.assert(sumOfXorSubarrays([2, 3, 1]) === 9);\n    console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74);\n    console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0);\n    console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72);\n    console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125);\n    console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390);\n    console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192);\n    console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192);\n    console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218);\n}\n\ntestSumOfXorSubarrays();",
    "entry_point": "sumOfXorSubarrays",
    "signature": "function sumOfXorSubarrays(A)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve. Një nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut. Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembull:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // kthen 39",
      "hy": "Տրված է A ամբողջ թվերի զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // վերադարձնում է 39",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা। \nএকটি উপঅ্যারে (L, R) সূচক জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য। \nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল। \nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 ফেরত দেয়",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира от двойка индекси (L, R) така че 1 <= L <= R <= дължината на масива. XOR сумата на подмасив е резултатът от прилагането на XOR върху всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПример:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // връща 39",
      "zh": "给定一个整数数组A，任务是计算所有子数组的异或和之和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= 数组的长度。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和之和。\n\n示例：\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 返回 39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemple :  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // renvoie 39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // gibt 39 zurück",
      "ha": "An ba da wani array A na lambobi masu cikakken lamba, aikin shi ne a ƙididdige jumlar XOR na dukkan subarrays.\nAnfani ne aka bayyana ta hanyar ma'aurata na alamomin (L, R) wanda 1 <= L <= R <= tsawon jerin.\nJimillar XOR na wani subarray shine sakamakon XORing duk abubuwa daga L zuwa R.\nSakamakon karshe shine jimillar XOR na dukkanin subarrays masu yiwuwa.\n\nMisali:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // yana dawowa 39",
      "hi": "दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उपसरणियों के XOR का योग गणना करना है। एक उपसरणी को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= सरणी की लंबाई। एक उपसरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। अंतिम परिणाम सभी संभावित उपसरणियों के XOR योगों का योग है।\n\nउदाहरण:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 लौटाता है",
      "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása. \nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza. \nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye. \nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // visszaadja a 39-et"
    },
    "docstring_bertscore": {
      "sq": "0.9897832477210895",
      "hy": "0.9725772882247044",
      "bn": "0.9495502667817108",
      "bg": "0.9892574731024901",
      "zh": "0.9777780274913408",
      "fr": "0.9910803041092473",
      "de": "0.9910803041092473",
      "ha": "0.9543237520987412",
      "hi": "0.9737654951640551",
      "hu": "0.9676393369521771"
    }
  },
  {
    "task_id": "JavaScript/40",
    "prompt": {
      "en": "\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n * and b >= k. Different legal representations of the same number are counted only once.\n * Example:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n, k) {",
      "sq": "/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë\n * dhe b >= k. Reprezentimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n * Shembull:\n *   countPowerNumbers(99, 1) kthen 99\n */\nfunction countPowerNumbers(n, k) {",
      "hy": "/**\n * Տրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են\n * և b >= k: Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n * Օրինակ:\n *   countPowerNumbers(99, 1) վերադարձնում է 99\n */\nfunction countPowerNumbers(n, k) {",
      "bn": "/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\n * যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা\n * এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে কেবল একবার গণনা করা হয়।\n * উদাহরণ:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n, k) {",
      "bg": "/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа\n * и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n * Пример:\n *   countPowerNumbers(99, 1) връща 99\n */\nfunction countPowerNumbers(n, k) {",
      "zh": "/**\n * 给定两个正整数 n 和 k，找出有多少个正整数 x，\n * 其中 1 <= x <= n，可以表示为 x = a^b，且 a 和 b 为正整数\n * 且 b >= k。相同数字的不同合法表示仅计数一次。\n * 示例：\n *   countPowerNumbers(99, 1) 返回 99\n */\nfunction countPowerNumbers(n, k) {",
      "fr": "/**\n * Étant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs\n * et b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.\n * Exemple :\n *   countPowerNumbers(99, 1) retourne 99\n */\nfunction countPowerNumbers(n, k) {",
      "de": "/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind\n * und b >= k. Verschiedene gültige Darstellungen derselben Zahl werden nur einmal gezählt.\n * Beispiel:\n *   countPowerNumbers(99, 1) gibt 99 zurück\n */\nfunction countPowerNumbers(n, k) {",
      "ha": "/**\n * An ba lambobi guda biyu masu kyau n da k, nemo adadin lambobi masu kyau x,\n * inda 1 <= x <= n, wanda za a iya bayyana shi azaman x = a^b tare da a da b suna kasancewa lambobi masu kyau\n * kuma b >= k. Ana kirga wakilcin doka daban-daban na lamba ɗaya sau ɗaya kawai.\n * Misali:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n, k) {",
      "hi": "/**\n * दिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं\n * और b >= k. एक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n * उदाहरण:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n, k) {",
      "hu": "/**\n * Két pozitív egész szám, n és k esetén, találja meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok\n * és b >= k. Ugyanazon szám különböző jogszerű ábrázolásait csak egyszer számoljuk.\n * Példa:\n *   countPowerNumbers(99, 1) visszaadja 99\n */\nfunction countPowerNumbers(n, k) {"
    },
    "prompt_bertscore": {
      "sq": "0.9924214564419949",
      "hy": "0.9855005780755962",
      "bn": "0.9692522156461804",
      "bg": "0.9924214564419949",
      "zh": "0.9703180662708135",
      "fr": "1",
      "de": "0.9855005780755962",
      "ha": "0.970411223919519",
      "hi": "0.9805113801647619",
      "hu": "0.96878960548875"
    },
    "canonical_solution": "let count = 0;\n    let x = 0;\n    let mp = new Array(n + 1).fill(false);\n    \n    for (let i = 2; i <= Math.cbrt(n); ++i) {\n        let t = i * i;\n        let m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if (Math.pow(Math.floor(Math.sqrt(t)), 2) === t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k === 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += Math.floor(Math.sqrt(n)) - x;\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countPowerNumbers(n, k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99\n",
      "sq": "Shkruani një funksion JavaScript `function countPowerNumbers(n, k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,  \nku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë  \ndhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.  \nShembull:  \n  countPowerNumbers(99, 1) kthen 99  ",
      "hy": "Գրեք JavaScript ֆունկցիա `function countPowerNumbers(n, k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու դրական ամբողջ թվեր n և k, գտնել դրական ամբողջ թվերի քանակը x,\nորտեղ 1 <= x <= n, որը կարող է արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են\nև b >= k: Նույն թվի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ:\nՕրինակ:\n  countPowerNumbers(99, 1) վերադարձնում է 99",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function countPowerNumbers(n, k)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, এমন ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\nযেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যেতে পারে যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা\nএবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\nউদাহরণ:\n  countPowerNumbers(99, 1) returns 99",
      "bg": "Напишете JavaScript функция `function countPowerNumbers(n, k)` за решаване на следния проблем:  \nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,  \nкъдето 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа  \nи b >= k. Различните легални представяния на едно и също число се броят само веднъж.  \nПример:  \n  countPowerNumbers(99, 1) връща 99  ",
      "zh": "编写一个 JavaScript 函数 `function countPowerNumbers(n, k)` 来解决以下问题：  \n给定两个正整数 n 和 k，找出多少个正整数 x，满足 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数，且 b >= k。相同数字的不同合法表示只计数一次。  \n示例：  \ncountPowerNumbers(99, 1) 返回 99  ",
      "fr": "Écrire une fonction JavaScript `function countPowerNumbers(n, k)` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x,  \noù 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs  \net b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.  \nExemple :  \n  countPowerNumbers(99, 1) retourne 99  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function countPowerNumbers(n, k)`, um das folgende Problem zu lösen:\nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x,\nfür die 1 <= x <= n gilt, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind\nund b >= k. Verschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\nBeispiel:\n  countPowerNumbers(99, 1) gibt 99 zurück",
      "ha": "Rubuta wani aikin JavaScript `function countPowerNumbers(n, k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu masu kyau n da k, nemo adadin lambobi masu kyau x,\ninda 1 <= x <= n, wanda za a iya bayyana shi a matsayin x = a^b tare da a da b kasancewa lambobi masu kyau\nkuma b >= k. Ana kirga wakilcin doka daban-daban na wannan lambar sau daya kawai.\nMisali:\n  countPowerNumbers(99, 1) returns 99",
      "hi": "JavaScript फ़ंक्शन `function countPowerNumbers(n, k)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए दो धनात्मक पूर्णांक n और k के लिए, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें,\nजहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं\nऔर b >= k। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\nउदाहरण:\n  countPowerNumbers(99, 1) returns 99",
      "hu": "Írj egy JavaScript függvényt `function countPowerNumbers(n, k)` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát,\nahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok\nés b >= k. Ugyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\nPélda:\n  countPowerNumbers(99, 1) visszaadja 99"
    },
    "instruction_bertscore": {
      "sq": "0.9924011961431293",
      "hy": "0.9847662415569103",
      "bn": "0.9882259855337759",
      "bg": "0.9894384253796129",
      "zh": "0.9584336133127341",
      "fr": "1",
      "de": "0.9624159538221025",
      "ha": "0.9650640940620597",
      "hi": "0.9673636379833006",
      "hu": "0.9613077949263089"
    },
    "level": "hard",
    "test": "const testCountPowerNumbers = () => {\n    console.assert(countPowerNumbers(99, 1) === 99, 'Expected 99, got ' + countPowerNumbers(99, 1));\n    console.assert(countPowerNumbers(99, 3) === 7, 'Expected 7, got ' + countPowerNumbers(99, 3));\n    console.assert(countPowerNumbers(99, 2) === 12, 'Expected 12, got ' + countPowerNumbers(99, 2));\n    console.assert(countPowerNumbers(10, 1) === 10, 'Expected 10, got ' + countPowerNumbers(10, 1));\n    console.assert(countPowerNumbers(10, 2) === 4, 'Expected 4, got ' + countPowerNumbers(10, 2));\n    console.assert(countPowerNumbers(500, 1) === 500, 'Expected 500, got ' + countPowerNumbers(500, 1));\n    console.assert(countPowerNumbers(500, 2) === 30, 'Expected 30, got ' + countPowerNumbers(500, 2));\n    console.assert(countPowerNumbers(500, 3) === 13, 'Expected 13, got ' + countPowerNumbers(500, 3));\n    console.assert(countPowerNumbers(1000, 1) === 1000, 'Expected 1000, got ' + countPowerNumbers(1000, 1));\n    console.assert(countPowerNumbers(1000, 2) === 41, 'Expected 41, got ' + countPowerNumbers(1000, 2));\n    console.assert(countPowerNumbers(1000, 3) === 17, 'Expected 17, got ' + countPowerNumbers(1000, 3));\n    console.assert(countPowerNumbers(1000, 93) === 1, 'Expected 1, got ' + countPowerNumbers(1000, 93));\n    console.assert(countPowerNumbers(50, 2) === 10, 'Expected 10, got ' + countPowerNumbers(50, 2));\n    console.assert(countPowerNumbers(50, 3) === 5, 'Expected 5, got ' + countPowerNumbers(50, 3));\n    console.assert(countPowerNumbers(2, 3) === 1, 'Expected 1, got ' + countPowerNumbers(2, 3));\n};\ntestCountPowerNumbers();",
    "entry_point": "countPowerNumbers",
    "signature": "function countPowerNumbers(n, k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x,\nwhere 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\nand b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99\n",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\nku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë\ndhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\nShembull:\n  countPowerNumbers(99, 1) kthen 99",
      "hy": "Տրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\nՕրինակ:\n  countPowerNumbers(99, 1) վերադարձնում է 99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় এবং a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n\nউদাহরণ:\n  countPowerNumbers(99, 1) 99 প্রদান করে",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\nПример:\n  countPowerNumbers(99, 1) връща 99",
      "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示仅计数一次。\n\n示例：\n  countPowerNumbers(99, 1) 返回 99",
      "fr": "Étant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x,\noù 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs\net b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.\nExemple :\n  countPowerNumbers(99, 1) renvoie 99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\nBeispiel:\n  countPowerNumbers(99, 1) gibt 99 zurück",
      "ha": "An ba da lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, wanda za a iya bayyana shi a matsayin x = a^b tare da a da b suna zama lambobi masu kyau kuma b >= k. Ana kirga daban-daban halattattun wakilci na lamba ɗaya sau ɗaya kawai.\n\nMisali:\n  countPowerNumbers(99, 1) returns 99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन को केवल एक बार गिना जाता है।\nउदाहरण:\n  countPowerNumbers(99, 1) 99 लौटाता है",
      "hu": "Két pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k. Ugyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n\nPélda:\n  countPowerNumbers(99, 1) visszaadja 99"
    },
    "docstring_bertscore": {
      "sq": "0.9890787057595587",
      "hy": "0.9717144378494889",
      "bn": "0.9572902968394973",
      "bg": "1",
      "zh": "0.959462915947257",
      "fr": "1",
      "de": "0.9823332180196139",
      "ha": "0.9904204539834495",
      "hi": "0.9474866957531394",
      "hu": "0.947974134708199"
    }
  },
  {
    "task_id": "JavaScript/41",
    "prompt": {
      "en": "\n/**\n * Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', \n * such that the longest balanced subsequence is of length 2 * k. The result should be calculated \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * For example:\n *     countBalancedSubsequences(2, 2, 2)\n *     // returns 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "sq": "/**\n * Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\n * të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Për shembull:\n *     countBalancedSubsequences(2, 2, 2)\n *     // kthen 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "hy": "/**\n * Տրված է երեք ամբողջ թիվ՝ n, m և k, գտնել հաջորդականությունների քանակը, որոնք կազմված են n '(' և m ')' նշաններից,\n * այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի\n * 1,000,000,007 (10^9 + 7) մոդուլով։\n * \n * Օրինակ՝\n *     countBalancedSubsequences(2, 2, 2)\n *     // վերադարձնում է 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "bn": "/**\n * তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হলে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, \n * যাতে দীর্ঘতম ব্যালেন্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা \n * মডুলো গণনা করা উচিত।\n * \n * উদাহরণস্বরূপ:\n *     countBalancedSubsequences(2, 2, 2)\n *     // 2 রিটার্ন করে\n */\nfunction countBalancedSubsequences(n, m, k)",
      "bg": "/**\n * Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\n * такива, че най-дългата балансирана подредба е с дължина 2 * k. Резултатът трябва да бъде изчислен\n * по модул 1,000,000,007 (10^9 + 7).\n * \n * Например:\n *     countBalancedSubsequences(2, 2, 2)\n *     // връща 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "zh": "/**\n * 给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n * 使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n * \n * 例如:\n *     countBalancedSubsequences(2, 2, 2)\n *     // 返回 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "fr": "/**\n * Étant donné trois entiers n, m, et k, trouvez le nombre de séquences consistant en n '(' et m ')', \n * telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Par exemple :\n *     countBalancedSubsequences(2, 2, 2)\n *     // retourne 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "de": "/**\n * Gegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\n * so dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n * \n * Zum Beispiel:\n *     countBalancedSubsequences(2, 2, 2)\n *     // gibt 2 zurück\n */\nfunction countBalancedSubsequences(n, m, k)",
      "ha": "/**\n * An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', \n * ta yadda mafi tsawon jeri mai daidaito yana da tsawon 2 * k. Dole ne a ƙididdige sakamakon \n * modulo 1,000,000,007 (10^9 + 7).\n * \n * Alal misali:\n *     countBalancedSubsequences(2, 2, 2)\n *     // yana dawowa 2\n */\nfunction countBalancedSubsequences(n, m, k)",
      "hi": "/**\n * तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने हैं,\n * ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) से \n * मापांकित किया जाना चाहिए।\n * \n * उदाहरण के लिए:\n *     countBalancedSubsequences(2, 2, 2)\n *     // 2 लौटाता है\n */\nfunction countBalancedSubsequences(n, m, k)",
      "hu": "/**\n * Adott három egész szám: n, m és k, keresse meg azon sorozatok számát, amelyek n '(' és m ')' \n * karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. \n * Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n * \n * Például:\n *     countBalancedSubsequences(2, 2, 2)\n *     // visszaadja: 2\n */\nfunction countBalancedSubsequences(n, m, k)"
    },
    "prompt_bertscore": {
      "sq": "0.9726080759337647",
      "hy": "0.9780251236853482",
      "bn": "0.9777136712478856",
      "bg": "0.9892399936289591",
      "zh": "0.9846516318270532",
      "fr": "0.9962391323654854",
      "de": "0.9742020847415698",
      "ha": "0.9826202389202093",
      "hi": "0.9795937078043807",
      "hu": "0.9588878809941609"
    },
    "canonical_solution": "{\n    const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countBalancedSubsequences(n, m, k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    countBalancedSubsequences(2, 2, 2)\n    // returns 2",
      "sq": "Shkruani një funksion JavaScript `function countBalancedSubsequences(n, m, k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar të jetë me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    countBalancedSubsequences(2, 2, 2)\n    // kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `function countBalancedSubsequences(n, m, k)` հետևյալ խնդիրը լուծելու համար:\nԵրեք ամբողջ թիվ n, m և k տրված են, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    countBalancedSubsequences(2, 2, 2)\n    // վերադարձնում է 2",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function countBalancedSubsequences(n, m, k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    countBalancedSubsequences(2, 2, 2)\n    // 2 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function countBalancedSubsequences(n, m, k)` за решаване на следния проблем:  \nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредба да е с дължина 2 * k. Резултатът трябва да се изчисли по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    countBalancedSubsequences(2, 2, 2)\n    // връща 2",
      "zh": "编写一个 JavaScript 函数 `function countBalancedSubsequences(n, m, k)` 来解决以下问题：  \n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应计算为对 1,000,000,007 (10^9 + 7) 取模。\n\n例如：  \n    countBalancedSubsequences(2, 2, 2)  \n    // 返回 2",
      "fr": "Écrire une fonction JavaScript `function countBalancedSubsequences(n, m, k)` pour résoudre le problème suivant :  \nÉtant donné trois entiers n, m, et k, trouver le nombre de séquences constituées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    countBalancedSubsequences(2, 2, 2)\n    // retourne 2",
      "de": "Schreiben Sie eine JavaScript-Funktion `function countBalancedSubsequences(n, m, k)`, um das folgende Problem zu lösen:  \nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    countBalancedSubsequences(2, 2, 2)\n    // gibt 2 zurück",
      "ha": "Rubuta wani aikin JavaScript `function countBalancedSubsequences(n, m, k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku n, m, da k, nemo yawan jerin abubuwa da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon jerin da aka daidaita yana da tsawon 2 * k. Dole ne a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nAlal misali:\n    countBalancedSubsequences(2, 2, 2)\n    // yana dawowa 2",
      "hi": "JavaScript फ़ंक्शन `function countBalancedSubsequences(n, m, k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना किया जाना चाहिए।\n\nउदाहरण के लिए:\n    countBalancedSubsequences(2, 2, 2)\n    // 2 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function countBalancedSubsequences(n, m, k)` a következő probléma megoldására:\nAdott három egész szám: n, m és k. Találd meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    countBalancedSubsequences(2, 2, 2)\n    // 2-t ad vissza"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9768462523739062",
      "bn": "0.9835444660831647",
      "bg": "0.9805236952483861",
      "zh": "0.9754510725775172",
      "fr": "0.9971889828475943",
      "de": "0.9800537357668576",
      "ha": "0.9804303389692998",
      "hi": "0.9611196919554689",
      "hu": "0.964957032286682"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2, 'Test case 1 failed');\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0, 'Test case 2 failed');\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4, 'Test case 3 failed');\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14, 'Test case 4 failed');\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35, 'Test case 5 failed');\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6, 'Test case 6 failed');\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6, 'Test case 7 failed');\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27, 'Test case 8 failed');\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110, 'Test case 9 failed');\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659, 'Test case 10 failed');\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648, 'Test case 11 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531, 'Test case 12 failed');\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485, 'Test case 13 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024, 'Test case 14 failed');\n})();",
    "entry_point": "countBalancedSubsequences",
    "signature": "function countBalancedSubsequences(n, m, k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')', such that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    countBalancedSubsequences(2, 2, 2)\n    // returns 2",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënpasuesi më i gjatë i balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    countBalancedSubsequences(2, 2, 2)\n    // kthen 2",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')', այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    countBalancedSubsequences(2, 2, 2)\n    // վերադարձնում է 2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n টি '(' এবং m টি ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালান্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো হিসাব করা উচিত।\n\nউদাহরণস্বরূপ:\n    countBalancedSubsequences(2, 2, 2)\n    // 2 প্রদান করে",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана подредена последователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    countBalancedSubsequences(2, 2, 2)\n    // връща 2",
      "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    countBalancedSubsequences(2, 2, 2)\n    // 返回 2",
      "fr": "Étant donnés trois entiers n, m et k, trouvez le nombre de séquences consistant en n '(' et m ')', de telle sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    countBalancedSubsequences(2, 2, 2)\n    // renvoie 2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    countBalancedSubsequences(2, 2, 2)\n    // gibt 2 zurück",
      "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon subsequence mai daidaituwa yana da tsawon 2 * k. A sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    countBalancedSubsequences(2, 2, 2)\n    // ya dawo da 2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से मिलकर बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के मापांक में गणना किया जाना चाहिए।\n\nउदाहरण के लिए:\n    countBalancedSubsequences(2, 2, 2)\n    // 2 लौटाता है",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg az n '(' és m ')' karakterekből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    countBalancedSubsequences(2, 2, 2)\n    // visszatér 2"
    },
    "docstring_bertscore": {
      "sq": "0.9991498619691707",
      "hy": "0.9777706781672426",
      "bn": "0.9568002756894842",
      "bg": "0.9780314798575414",
      "zh": "0.9786132682435925",
      "fr": "0.9963710229384926",
      "de": "0.9843443506275922",
      "ha": "0.9594182241115241",
      "hi": "0.972068397188493",
      "hu": "0.9399895906513586"
    }
  },
  {
    "task_id": "JavaScript/42",
    "prompt": {
      "en": "\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left \n * corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations\n * to cut the paper such that the remaining area is less than k.\n * In each operation, a line is randomly chosen that is parallel to the axes, passes through points with\n * integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part\n * of the paper along this line is then discarded.\n * The answer should be modulo 10^9+7.\n *\n * For example:\n *    expectedCuts(3, 3, 4) // returns 3\n *    expectedCuts(5, 5, 12) // returns 2\n */\nfunction expectedCuts(n, m, k)",
      "sq": "/**\n * Duke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë\n * në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve\n * për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k.\n * Në secilën operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon nëpër pika me\n * koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet.\n * Përgjigjja duhet të jetë modulo 10^9+7.\n *\n * Për shembull:\n *    expectedCuts(3, 3, 4) // kthen 3\n *    expectedCuts(5, 5, 12) // kthen 2\n */\nfunction expectedCuts(n, m, k)",
      "hy": "/**\n * Ունենալով n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝\n * իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվել գործողությունների\n * սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի k-ից փոքր։\n * Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է\n * ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն շոշափում է եզրը)։ Թղթի այս գծի երկայնքով\n * ներքևի կամ աջ մասը ապա դուրս է մնում։\n * Պատասխանը պետք է լինի 10^9+7 մոդուլով։\n *\n * Օրինակ՝\n *    expectedCuts(3, 3, 4) // վերադարձնում է 3\n *    expectedCuts(5, 5, 12) // վերադարձնում է 2\n */",
      "bn": "/**\n * একটি আয়তাকার কাগজ n x m আকারের একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম \n * কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যা গণনা করতে হবে \n * যাতে অবশিষ্ট ক্ষেত্রফল k এর চেয়ে কম হয়।\n * প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ \n * বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের \n * বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\n * উত্তরটি 10^9+7 দ্বারা মডুলো হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *    expectedCuts(3, 3, 4) // 3 প্রদান করে\n *    expectedCuts(5, 5, 12) // 2 প্রদান করে\n */",
      "bg": "/**\n * Даден е правоъгълник от хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв \n * ъгъл в (0,0) и горен десен ъгъл в (n,m), трябва да изчислите очаквания брой операции\n * за да се изреже хартията така, че останалата площ да е по-малка от k.\n * При всяка операция се избира случайно линия, която е успоредна на осите, преминава през точки с\n * цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част\n * на хартията по тази линия след това се изхвърля.\n * Отговорът трябва да бъде по модул 10^9+7.\n *\n * Например:\n *    expectedCuts(3, 3, 4) // връща 3\n *    expectedCuts(5, 5, 12) // връща 2\n */",
      "zh": "/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 位置，右上角在 (n,m) 位置，\n * 你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n * 在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。\n * 然后沿着这条线丢弃纸张的底部或右侧部分。\n * 答案应对 10^9+7 取模。\n *\n * 例如:\n *    expectedCuts(3, 3, 4) // 返回 3\n *    expectedCuts(5, 5, 12) // 返回 2\n */",
      "fr": "/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche\n * à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations\n * pour couper le papier de sorte que la surface restante soit inférieure à k.\n * À chaque opération, une ligne est choisie au hasard qui est parallèle aux axes, passe par des points avec\n * des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite\n * du papier le long de cette ligne est alors jetée.\n * La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *    expectedCuts(3, 3, 4) // retourne 3\n *    expectedCuts(5, 5, 12) // retourne 2\n */",
      "de": "/**\n * Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem platziert ist, \n * mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete \n * Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist.\n * Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit \n * ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder \n * rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\n * Die Antwort sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *    expectedCuts(3, 3, 4) // gibt 3 zurück\n *    expectedCuts(5, 5, 12) // gibt 2 zurück\n */",
      "ha": "/**\n * An ba takardar murabba'i mai girman n x m a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu\n * a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammani\n * don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k.\n * A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ɗakunan ajiya, yana wucewa ta wuraren da ke da\n * daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Sashin ƙasa ko dama\n * na takardar tare da wannan layin ana watsar.\n * Amsar ya kamata ta zama modulo 10^9+7.\n *\n * Alal misali:\n *    expectedCuts(3, 3, 4) // returns 3\n *    expectedCuts(5, 5, 12) // returns 2\n */",
      "hi": "/**\n * एक आयताकार कागज जिसका आकार n x m है, को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \n * जिसकी निचली-बाईं कोने पर (0,0) और ऊपरी-दाईं कोने पर (n,m) है। \n * आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है जिससे कागज का शेष क्षेत्रफल k से कम हो जाए।\n * प्रत्येक ऑपरेशन में, एक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, \n * पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। \n * इस रेखा के साथ कागज का निचला या दायां भाग फिर त्याग दिया जाता है।\n * उत्तर को 10^9+7 के मापांक में होना चाहिए।\n *\n * उदाहरण के लिए:\n *    expectedCuts(3, 3, 4) // 3 लौटाता है\n *    expectedCuts(5, 5, 12) // 2 लौटाता है\n */\nfunction expectedCuts(n, m, k)",
      "hu": "/**\n * Adott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben van elhelyezve, \n * az alsó-bal sarok a (0,0) pontban és a felső-jobb sarok az (n,m) pontban található. Ki kell számítani a várható \n * műveletek számát, hogy a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k.\n * Minden művelet során véletlenszerűen kiválasztunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú \n * pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papírnak az ezen a vonalon lévő alsó vagy \n * jobb részét eldobjuk.\n * Az eredményt 10^9+7 modullal kell megadni.\n *\n * Például:\n *    expectedCuts(3, 3, 4) // visszaadja 3\n *    expectedCuts(5, 5, 12) // visszaadja 2\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9589315796779886",
      "hy": "0.9272712873536947",
      "bn": "0.9442059177495861",
      "bg": "0.9340203504404981",
      "zh": "0.9262193408557339",
      "fr": "0.9617896722306996",
      "de": "0.9509694808542051",
      "ha": "0.9304684419668322",
      "hi": "0.9519505163061364",
      "hu": "0.9184169408583025"
    },
    "canonical_solution": "{\n    const MD = 1000000007;\n    const N = 1000000;\n    let vv = new Array(N * 2 + 2).fill(0);\n    let ans = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function expectedCuts(n, m, k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    expectedCuts(3, 3, 4) // returns 3\n    expectedCuts(5, 5, 12) // returns 2\n",
      "sq": "Shkruani një funksion JavaScript `function expectedCuts(n, m, k)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    expectedCuts(3, 3, 4) // kthen 3\n    expectedCuts(5, 5, 12) // kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `function expectedCuts(n, m, k)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է հարթ Cartesian կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, դուք պետք է հաշվեք գործողությունների ակնկալվող քանակը, որպեսզի կտրեք թուղթը այնպես, որ մնացած տարածքը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    expectedCuts(3, 3, 4) // վերադարձնում է 3\n    expectedCuts(5, 5, 12) // վերադարձնում է 2",
      "bn": "একটি JavaScript ফাংশন `function expectedCuts(n, m, k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি আয়তাকার কাগজের টুকরো, যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, আপনাকে কাগজটি কাটার জন্য প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান দিকের অংশটি তখন বাতিল করা হয়। উত্তরটি 10^9+7 এর মডুলো হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    expectedCuts(3, 3, 4) // 3 রিটার্ন করে\n    expectedCuts(5, 5, 12) // 2 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function expectedCuts(n, m, k)`, за да решите следния проблем:\nДаден е правоъгълник от хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    expectedCuts(3, 3, 4) // връща 3\n    expectedCuts(5, 5, 12) // връща 2",
      "zh": "编写一个JavaScript函数 `function expectedCuts(n, m, k)` 来解决以下问题：  \n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应取模 10^9+7。\n\n例如：\n    expectedCuts(3, 3, 4) // 返回 3\n    expectedCuts(5, 5, 12) // 返回 2",
      "fr": "Écrire une fonction JavaScript `function expectedCuts(n, m, k)` pour résoudre le problème suivant :  \nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et traverse (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    expectedCuts(3, 3, 4) // retourne 3\n    expectedCuts(5, 5, 12) // retourne 2",
      "de": "Schreiben Sie eine JavaScript-Funktion `function expectedCuts(n, m, k)`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    expectedCuts(3, 3, 4) // gibt 3 zurück\n    expectedCuts(5, 5, 12) // gibt 2 zurück",
      "ha": "Rubuta aikin JavaScript `function expectedCuts(n, m, k)` don warware matsalar mai zuwa:\nAn ba da takarda murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammanin don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da manyan layukan, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ƙasa ko ɓangaren dama na takardar tare da wannan layin. Amsar ya kamata ta kasance modulo 10^9+7.\n\nAlal misali:\n    expectedCuts(3, 3, 4) // returns 3\n    expectedCuts(5, 5, 12) // returns 2",
      "hi": "`function expectedCuts(n, m, k)` लिखने के लिए एक JavaScript फ़ंक्शन निम्नलिखित समस्या को हल करने के लिए:\nदिया गया है कि एक आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां हिस्सा तब त्याग दिया जाता है। उत्तर 10^9+7 के मापांक के रूप में होना चाहिए।\n\nउदाहरण के लिए:\n    expectedCuts(3, 3, 4) // 3 लौटाता है\n    expectedCuts(5, 5, 12) // 2 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function expectedCuts(n, m, k)`, hogy megoldja a következő problémát:\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. Ki kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választanak ki egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. A válasznak 10^9+7 modulo szerint kell lennie.\n\nPéldául:\n    expectedCuts(3, 3, 4) // visszaadja 3\n    expectedCuts(5, 5, 12) // visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9637930582538174",
      "hy": "0.962799707718262",
      "bn": "0.9530048463686696",
      "bg": "0.956639385080846",
      "zh": "0.9632219959083421",
      "fr": "0.9681984814747903",
      "de": "0.9592289293583978",
      "ha": "0.9494845201255883",
      "hi": "0.9580403251582851",
      "hu": "0.9587986959530762"
    },
    "level": "hard",
    "test": "function testExpectedCuts() {\n    console.assert(expectedCuts(2, 4, 10) === 0, 'Test 1 failed');\n    console.assert(expectedCuts(2, 4, 8) === 1, 'Test 2 failed');\n    console.assert(expectedCuts(2, 4, 2) === 833333342, 'Test 3 failed');\n    console.assert(expectedCuts(2, 4, 6) === 250000003, 'Test 4 failed');\n    console.assert(expectedCuts(3, 3, 4) === 666666673, 'Test 5 failed');\n    console.assert(expectedCuts(5, 5, 12) === 666666673, 'Test 6 failed');\n    console.assert(expectedCuts(6, 7, 20) === 722222229, 'Test 7 failed');\n    console.assert(expectedCuts(10, 10, 50) === 714285721, 'Test 9 failed');\n    console.assert(expectedCuts(1, 10, 5) === 945634929, 'Test 10 failed');\n    console.assert(expectedCuts(10, 1, 5) === 945634929, 'Test 11 failed');\n}\n\ntestExpectedCuts();",
    "entry_point": "expectedCuts",
    "signature": "function expectedCuts(n, m, k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    expectedCuts(3, 3, 4) // returns 3\n    expectedCuts(5, 5, 12) // returns 2\n",
      "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ kartezian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    expectedCuts(3, 3, 4) // kthen 3\n    expectedCuts(5, 5, 12) // kthen 2",
      "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվարկել գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է մի գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    expectedCuts(3, 3, 4) // վերադարձնում է 3\n    expectedCuts(5, 5, 12) // վերադարձնում է 2",
      "bn": "একটি আয়তাকার কাগজের টুকরো n x m আকারের, যা একটি প্লেন কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে স্থাপন করা হয়েছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত। আপনাকে এমন অপারেশনগুলির প্রত্যাশিত সংখ্যা গণনা করতে হবে যাতে কাগজের অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষগুলির সমান্তরাল, পূর্ণসংখ্যা কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 দ্বারা মডুলো করা উচিত।\n\nউদাহরণস্বরূপ:\n    expectedCuts(3, 3, 4) // 3 ফেরত দেয়\n    expectedCuts(5, 5, 12) // 2 ফেরত দেয়",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за изрязване на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайно линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модуло 10^9+7.\n\nНапример:\n    expectedCuts(3, 3, 4) // връща 3\n    expectedCuts(5, 5, 12) // връща 2",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条平行于坐标轴的直线，该直线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应对 10^9+7 取模。\n\n例如：\n    expectedCuts(3, 3, 4) // 返回 3\n    expectedCuts(5, 5, 12) // 返回 2",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie aléatoirement, parallèle aux axes, passant par des points avec des coordonnées entières, et traversant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite éliminée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    expectedCuts(3, 3, 4) // retourne 3\n    expectedCuts(5, 5, 12) // retourne 2",
      "de": "Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur die Kante berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    expectedCuts(3, 3, 4) // gibt 3 zurück\n    expectedCuts(5, 5, 12) // gibt 2 zurück",
      "ha": "An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya kasance ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin. Amsar yakamata ta kasance modulo 10^9+7.\n\nMisali:\n    expectedCuts(3, 3, 4) // yana dawowa 3\n    expectedCuts(5, 5, 12) // yana dawowa 2",
      "hi": "दिया गया एक आयताकार कागज जिसका आकार n x m है, एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर स्थिति (0,0) है और ऊपरी-दाईं कोने पर स्थिति (n,m) है। आपको कागज को इस प्रकार काटने के लिए अपेक्षित संचालन की संख्या की गणना करनी है कि शेष क्षेत्रफल k से कम हो। प्रत्येक संचालन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। इस रेखा के साथ कागज के निचले या दाईं हिस्से को फिर त्याग दिया जाता है। उत्तर को 10^9+7 से मोड्यूलो लेना चाहिए।\n\nउदाहरण के लिए:\n    expectedCuts(3, 3, 4) // 3 लौटाता है\n    expectedCuts(5, 5, 12) // 2 लौटाता है",
      "hu": "Egy n x m méretű téglalap alakú papírt helyezünk el a síkbeli derékszögű koordináta-rendszerben, amelynek bal alsó sarka a (0,0) pontban, a jobb felső sarka pedig az (n,m) pontban van. Ki kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradó terület kisebb legyen, mint k. Minden művelet során véletlenszerűen kiválasztunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papírnak a vonal mentén lévő alsó vagy jobb részét ezután elvetjük. Az eredményt 10^9+7 modullal kell megadni.\n\nPéldául:\n    expectedCuts(3, 3, 4) // visszaadja 3\n    expectedCuts(5, 5, 12) // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9619978368700242",
      "hy": "0.9452515080753537",
      "bn": "0.9502699046522002",
      "bg": "0.9523283112908648",
      "zh": "0.9349163720893464",
      "fr": "0.9550980133240152",
      "de": "0.9610708288817343",
      "ha": "0.93863095884508",
      "hi": "0.939275117170776",
      "hu": "0.9360140035749452"
    }
  },
  {
    "task_id": "JavaScript/43",
    "prompt": {
      "en": "\n/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "sq": "/**\n * Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\n * të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke\n * ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1\n * pika ndarëse 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni atë në [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Rezultati duhet të jetë modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // kthen 2\n */\nconst countPermutations = (n, k, q) => {",
      "hy": "/**\n * Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը\n * այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ\n * p-ն բաժանելով հենց k ոչ դատարկ հարակից հատվածների և տեսակավորելով յուրաքանչյուր հատվածը (այսինքն՝ ընտրել k-1\n * կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Արդյունքը պետք է լինի 998244353 մոդուլով։\n * \n * @օրինակ\n * countPermutations(2, 1, [1, 2])\n * // վերադարձնում է 2\n */",
      "bn": "/**\n * একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশন p এর সংখ্যা খুঁজুন\n * যাতে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা পাওয়া যেতে পারে\n * p কে ঠিক k টি খালি নয় এমন সংলগ্ন সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে (অর্থাৎ, k-1 টি\n * ব্রেকপয়েন্ট 1 <= x1 < x2 < ... < x(k-1) < n নির্বাচন করে, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n]) এ ভাগ করে)।\n * ফলাফলটি 998244353 মডুলো আকারে হওয়া উচিত।\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "bg": "/**\n * Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента\n * такива, че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез\n * разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1\n * точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Резултатът трябва да бъде по модул 998244353.\n * \n * @пример\n * countPermutations(2, 1, [1, 2])\n * // връща 2\n */\nconst countPermutations = (n, k, q) => {",
      "zh": "/**\n * 给定一个由n个元素组成的排列q和一个整数k，找出有多少个由n个元素组成的排列p\n * 使得f(p) = q，其中f(p)是可以通过将p分成恰好k个非空连续段并对每个段进行排序得到的字典序最小的排列\n * （即选择k-1个断点1 <= x1 < x2 < ... < x(k-1) < n，并将其分为[1, x1], (x1, x2], ..., (x(k-1), n]）。\n * 结果应对998244353取模。\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "fr": "/**\n * Étant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments\n * telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n * divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1\n * points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et le diviser en [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Le résultat doit être modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "de": "/**\n * Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen\n * so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem\n * p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1\n * Trennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Das Ergebnis sollte modulo 998244353 sein.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "ha": "/**\n * An ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo yawan permutations p na abubuwa n\n * ta yadda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za'a iya samu ta\n * hanyar raba p zuwa daidai k sassa masu cike da babu komai kuma a jera kowane sashe (wato, zaɓi k-1\n * wuraren tsagewa 1 <= x1 < x2 < ... < x(k-1) < n, kuma a raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Sakamakon ya kasance modulo 998244353.\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "hi": "/**\n * दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें\n * ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो प्राप्त किया जा सकता है\n * p को ठीक k गैर-खाली निरंतर खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (अर्थात, k-1\n * ब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n]) में विभाजित करें।\n * परिणाम 998244353 के मापांक में होना चाहिए।\n * \n * @example\n * countPermutations(2, 1, [1, 2])\n * // returns 2\n */\nconst countPermutations = (n, k, q) => {",
      "hu": "/**\n * Adott egy q permutáció n elemről és egy egész szám k, meg kell találni az n elem p permutációinak számát\n * úgy, hogy f(p) = q, ahol f(p) a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy\n * p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1\n * töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre).\n * Az eredménynek 998244353-mal vett maradéka kell legyen.\n * \n * @példa\n * countPermutations(2, 1, [1, 2])\n * // visszaadja 2\n */\nconst countPermutations = (n, k, q) => {"
    },
    "prompt_bertscore": {
      "sq": "0.9764086696444864",
      "hy": "0.975979826651832",
      "bn": "0.9935848345837163",
      "bg": "0.999999801369619",
      "zh": "0.9761599844074307",
      "fr": "0.9979719838096338",
      "de": "0.9943813424116661",
      "ha": "0.97315033687399",
      "hi": "0.9917568391870522",
      "hu": "0.9622326179804074"
    },
    "canonical_solution": "const P = 998244353;\n    let dp = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc = new Array(n + 1).fill(0);\n    let f = new Array(n + 1).fill(0);\n    \n    dp[0][0] = f[0] = jc[0] = 1;\n    \n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n    \n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n    \n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n    \n    return ans;\n};",
    "instruction": {
      "en": "Write a JavaScript function `const countPermutations = (n, k, q) =>` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n\n @example\n countPermutations(2, 1, [1, 2])\n // returns 2\n",
      "sq": "Shkruani një funksion JavaScript `const countPermutations = (n, k, q) =>` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\ntë tilla që f(p) = q, ku f(p) është permutacioni leksikografikisht më i vogël që mund të merret duke\nndarë p në saktësisht k segmente të pandara bosh dhe duke renditur secilin segment (d.m.th., zgjidhni k-1\npikat e ndarjes 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni në [1, x1], (x1, x2], ..., (x(k-1), n]).\nRezultati duhet të jetë modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `const countPermutations = (n, k, q) =>` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերից կազմված q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերից կազմված p փոխատեղումների քանակը\n այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարող է ստացվել\n p-ն բաժանելով հենց k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն՝ ընտրել k-1\n կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n] հատվածների):\n Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n @օրինակ\n countPermutations(2, 1, [1, 2])\n // վերադարձնում է 2",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `const countPermutations = (n, k, q) =>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন\nযাতে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট permutation যা পাওয়া যেতে পারে\np কে ঠিক k টি খালি নয় এমন ধারাবাহিক segment এ ভাগ করে এবং প্রতিটি segment কে সাজিয়ে (অর্থাৎ, k-1 টি\nbreakpoints 1 <= x1 < x2 < ... < x(k-1) < n বেছে নিন, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n]) এ ভাগ করুন)।\nফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 2 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `const countPermutations = (n, k, q) =>` за решаване на следния проблем:  \nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, така че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]).  \nРезултатът трябва да бъде модуло 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// връща 2",
      "zh": "编写一个 JavaScript 函数 `const countPermutations = (n, k, q) =>` 来解决以下问题：\n给定一个 n 个元素的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序（即，选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其分成 [1, x1], (x1, x2], ..., (x(k-1), n]）可以获得的字典序最小的排列。结果应对 998244353 取模。\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 返回 2",
      "fr": "Écrire une fonction JavaScript `const countPermutations = (n, k, q) =>` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments\n tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1\n points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et le diviser en [1, x1], (x1, x2], ..., (x(k-1), n]).\n Le résultat doit être modulo 998244353.\n\n @example\n countPermutations(2, 1, [1, 2])\n // returns 2",
      "de": "Schreiben Sie eine JavaScript-Funktion `const countPermutations = (n, k, q) =>`, um das folgende Problem zu lösen:\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen,\nso dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem\np in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1\nTrennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\nDas Ergebnis sollte modulo 998244353 sein.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// gibt 2 zurück",
      "ha": "Rubuta aikin JavaScript `const countPermutations = (n, k, q) =>` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n\n ta yadda f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za a iya samu ta\n raba p zuwa daidai k sassa masu ci gaba da ba komai ba kuma a tsara kowane sashi (wato, zaɓi k-1\n wuraren tsagewa 1 <= x1 < x2 < ... < x(k-1) < n, kuma raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n Sakamakon ya zama modulo 998244353.\n\n @misali\n countPermutations(2, 1, [1, 2])\n // ya dawo da 2",
      "hi": "JavaScript फ़ंक्शन `const countPermutations = (n, k, q) =>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या ज्ञात करें\nऐसे कि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो प्राप्त किया जा सकता है\np को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (अर्थात् k-1\nब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n]) में विभाजित करें)।\nपरिणाम 998244353 के मापांक में होना चाहिए।\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 2 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `const countPermutations = (n, k, q) =>` a következő probléma megoldására:\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről,\namelyekre f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni,\nhogy p-t pontosan k nem üres, egymást követő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válassz k-1\ntöréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és oszd fel [1, x1], (x1, x2], ..., (x(k-1), n] szegmensekre).\nAz eredményt 998244353-mal modulozva kell megadni.\n\n @példa\n countPermutations(2, 1, [1, 2])\n // visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9898297272302516",
      "hy": "0.994055985847531",
      "bn": "0.9944472876981697",
      "bg": "0.9956313233995187",
      "zh": "0.998110230554834",
      "fr": "0.9975314216244984",
      "de": "0.9955045972164184",
      "ha": "0.9767664029607301",
      "hi": "0.9765971698760885",
      "hu": "0.9751122091474717"
    },
    "level": "hard",
    "test": "console.assert(countPermutations(2, 1, [1, 2]) === 2, 'Test failed for input ([1, 2])');\nconsole.assert(countPermutations(3, 3, [3, 1, 2]) === 1, 'Test failed for input ([3, 1, 2])');\nconsole.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13, 'Test failed for input ([1, 2, 3, 6, 5, 4])');\nconsole.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720, 'Test failed for input ([1, 2, 3, 4, 5, 6])');\nconsole.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0, 'Test failed for input ([1, 2, 5, 3, 4, 5])');\nconsole.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1, 'Test failed for input ([1, 2, 3, 4, 5, 6, 7, 8, 9])');\nconsole.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093);",
    "entry_point": "countPermutations",
    "signature": "const countPermutations = (n, k, q) =>",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n The result should be modulo 998244353.\n\n @example\n countPermutations(2, 1, [1, 2])\n // returns 2\n",
      "sq": "Given një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\n të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke\n ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1\n pika ndarjeje 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni atë në [1, x1], (x1, x2], ..., (x(k-1), n]).\n Rezultati duhet të jetë modulo 998244353.\n\n @shembull\n countPermutations(2, 1, [1, 2])\n // kthen 2",
      "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, \nորոնց համար f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն \nճշգրիտ k չդատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 \nբեկման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n]).\n Արդյունքը պետք է լինի 998244353 մոդուլով։\n\n @օրինակ\n countPermutations(2, 1, [1, 2])\n // վերադարձնում է 2",
      "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া হয়েছে, n উপাদানের পারমুটেশন p-এর সংখ্যা খুঁজে বের করুন\nযেমন f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা পাওয়া যেতে পারে\np-কে ঠিক kটি খালি নয় এমন ধারাবাহিক অংশে ভাগ করে এবং প্রতিটি অংশকে সাজিয়ে (অর্থাৎ, k-1টি\nব্রেকপয়েন্ট 1 <= x1 < x2 < ... < x(k-1) < n নির্বাচন করুন, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n]) ভাগ করুন।\nফলাফলটি 998244353 মডুলো হতে হবে।\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 2 ফেরত দেয়",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, така че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]). Резултатът трябва да бъде модуло 998244353.\n\n @пример\n countPermutations(2, 1, [1, 2])\n // връща 2",
      "zh": "给定一个 n 个元素的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是可以通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序而获得的字典序最小的排列（即，选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其划分为 [1, x1], (x1, x2], ..., (x(k-1), n]）。结果应取模 998244353。\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 返回 2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments\n tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1\n points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et divisez-le en [1, x1], (x1, x2], ..., (x(k-1), n]).\n Le résultat doit être modulo 998244353.\n\n @exemple\n countPermutations(2, 1, [1, 2])\n // retourne 2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen,\nso dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem\np in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1\nTrennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\nDas Ergebnis sollte modulo 998244353 sein.\n\n@example\ncountPermutations(2, 1, [1, 2])\n// gibt 2 zurück",
      "ha": "An ba da permutation q na abubuwa n da kuma lamba k, gano yawan permutations p na abubuwa n\n irin wanda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsari na lexicographically wanda za'a iya samu ta hanyar\n raba p zuwa daidai k sassa masu ci gaba ba tare da komai ba kuma tsara kowane sashe (wato, zaɓi k-1\n wuraren tsayawa 1 <= x1 < x2 < ... < x(k-1) < n, kuma raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n Sakamakon ya kamata ya zama modulo 998244353.\n\n @misali\n countPermutations(2, 1, [1, 2])\n // ya dawo da 2",
      "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें\nजिसके लिए f(p) = q, जहाँ f(p) वह शब्दकोश क्रम में सबसे छोटी क्रमचय है जो प्राप्त की जा सकती है\np को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (अर्थात, k-1\nब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n] में विभाजित करें)।\nपरिणाम 998244353 के मापांक में होना चाहिए।\n\n@example\ncountPermutations(2, 1, [1, 2])\n// 2 लौटाता है",
      "hu": "Adott egy q permutáció n elemről és egy k egész szám, találja meg az n elemű p permutációk számát úgy, hogy f(p) = q, ahol f(p) a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre). Az eredménynek 998244353-mal vett maradékát kell adni.\n\n @példa\n countPermutations(2, 1, [1, 2])\n // visszaadja: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9764909026222348",
      "hy": "0.9876553204490627",
      "bn": "0.9805598459777345",
      "bg": "0.9956474124603825",
      "zh": "0.9936920949894751",
      "fr": "0.9961094267266697",
      "de": "1",
      "ha": "0.9606827051171921",
      "hi": "0.9868602030337801",
      "hu": "0.9683528172808543"
    }
  },
  {
    "task_id": "JavaScript/44",
    "prompt": {
      "en": "\n/**\n * Determines the number of ways to choose a triplet (a, b, c) \n * from an array of distinct integers representing heights such that the \n * greatest common divisor (GCD) of the maximum and minimum values \n * of the triplet is 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights)",
      "sq": "/**\n * Përcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c) \n * nga një varg i numrave të plotë të ndryshëm që përfaqësojnë lartësitë në mënyrë të tillë që \n * faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale \n * të treshes është 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Kthen: 1\n */\nfunction countTriplets(heights)",
      "hy": "/**\n * Սահմանում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) \n * տարբեր բարձրություններ ներկայացնող ամբողջ թվերի զանգվածից այնպես, որ \n * եռյակի առավելագույն և նվազագույն արժեքների \n * ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Վերադարձնում է: 1\n */\nfunction countTriplets(heights)",
      "bn": "/**\n * একটি অ্যারের ভিন্ন পূর্ণসংখ্যা যা উচ্চতাকে উপস্থাপন করে সেখান থেকে \n * একটি ত্রয়ী (a, b, c) নির্বাচন করার উপায়ের সংখ্যা নির্ধারণ করে \n * যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের \n * গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights)",
      "bg": "/**\n * Определя броя начини за избор на тройка (a, b, c) \n * от масив от различни цели числа, представляващи височини, така че \n * най-големият общ делител (НОД) на максималната и минималната стойност \n * на тройката да е 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Връща: 1\n */\nfunction countTriplets(heights)",
      "zh": "/**\n * 确定从表示高度的不同整数数组中选择三元组 (a, b, c) 的方法数，\n * 使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n * \n * @example\n * countTriplets([1, 5, 7])\n * // 返回: 1\n */\nfunction countTriplets(heights)",
      "fr": "/**\n * Détermine le nombre de façons de choisir un triplet (a, b, c) \n * à partir d'un tableau d'entiers distincts représentant des hauteurs tel que le \n * plus grand commun diviseur (PGCD) des valeurs maximale et minimale \n * du triplet soit 1.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Retourne : 1\n */\nfunction countTriplets(heights)",
      "de": "/**\n * Bestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) \n * aus einem Array von verschiedenen ganzen Zahlen, die Höhen darstellen, \n * so auszuwählen, dass der größte gemeinsame Teiler (GCD) der maximalen \n * und minimalen Werte des Tripels 1 ist.\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Gibt zurück: 1\n */\nfunction countTriplets(heights)",
      "ha": "/**\n * Yana tantance yawan hanyoyin zaɓar triplet (a, b, c)\n * daga jerin lambobi daban-daban da ke wakiltar tsayi ta yadda\n * babbar mai raba kowa da kowa (GCD) na mafi girma da mafi ƙarancin ƙima\n * na triplet ɗin shine 1.\n * \n * @misali\n * countTriplets([1, 5, 7])\n * // Yana dawowa: 1\n */\nfunction countTriplets(heights)",
      "hi": "/**\n * एक त्रिक (a, b, c) को चुनने के तरीकों की संख्या निर्धारित करता है \n * जो ऊँचाइयों का प्रतिनिधित्व करने वाले भिन्न पूर्णांकों की एक सरणी से है, \n * ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n * \n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights)",
      "hu": "/**\n * Meghatározza, hogy hányféleképpen lehet kiválasztani egy hármas (a, b, c) \n * különböző egész számokat tartalmazó tömbből, amelyek magasságokat jelképeznek, úgy, hogy a \n * hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n * \n * @példa\n * countTriplets([1, 5, 7])\n * // Visszatér: 1\n */\nfunction countTriplets(heights)"
    },
    "prompt_bertscore": {
      "sq": "0.9976104765161503",
      "hy": "0.965862786824201",
      "bn": "0.9744724206901583",
      "bg": "0.9921177505893926",
      "zh": "0.9690315372928506",
      "fr": "1",
      "de": "0.9832838630232469",
      "ha": "0.9643120794394616",
      "hi": "0.9880750264441894",
      "hu": "0.9608018833458131"
    },
    "canonical_solution": "{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a, b) {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function countTriplets(heights)` to solve the following problem:\nDetermines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "sq": "Shkruani një funksion JavaScript `function countTriplets(heights)` për të zgjidhur problemin në vijim:  \nPërcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c) nga një varg i numrave të plotë të ndryshëm që përfaqësojnë lartësitë, në mënyrë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të tresheve të jetë 1.",
      "hy": "Գրեք JavaScript ֆունկցիա `function countTriplets(heights)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է եղանակների քանակը, թե ինչպես ընտրել եռյակ (a, b, c) տարբեր ամբողջ թվերի զանգվածից, որոնք ներկայացնում են բարձրությունները, այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n@example\ncountTriplets([1, 5, 7])\n// Վերադարձնում է: 1",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function countTriplets(heights)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পৃথক পূর্ণসংখ্যার অ্যারের থেকে একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা নির্ধারণ করে যা উচ্চতা উপস্থাপন করে যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "bg": "Напишете JavaScript функция `function countTriplets(heights)`, за да решите следния проблем:  \nОпределя броя на начините за избор на тройка (a, b, c) от масив от различни цели числа, представляващи височини, така че най-големият общ делител (НОД) на максималните и минималните стойности на тройката да е 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Връща: 1",
      "zh": "编写一个 JavaScript 函数 `function countTriplets(heights)` 来解决以下问题：  \n确定从表示高度的不同整数数组中选择三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。  \n\n@example  \ncountTriplets([1, 5, 7])  \n// 返回: 1  ",
      "fr": "Écrire une fonction JavaScript `function countTriplets(heights)` pour résoudre le problème suivant :  \nDétermine le nombre de façons de choisir un triplet (a, b, c) à partir d'un tableau d'entiers distincts représentant des hauteurs, de sorte que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Renvoie : 1",
      "de": "Schreiben Sie eine JavaScript-Funktion `function countTriplets(heights)`, um das folgende Problem zu lösen:\nBestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) aus einem Array von verschiedenen ganzen Zahlen, die Höhen darstellen, so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\n@example\ncountTriplets([1, 5, 7])\n// Gibt zurück: 1",
      "ha": "Rubuta aikin JavaScript `function countTriplets(heights)` don warware matsalar mai zuwa:  \nYana tantance yawan hanyoyin zaɓar triplet (a, b, c) daga jerin lambobi daban-daban da ke wakiltar tsayi ta yadda mafi girman abin raba da ke tsakanin mafi girma da mafi ƙanƙanta na triplet ɗin zai zama 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "hi": "JavaScript फ़ंक्शन `function countTriplets(heights)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि एक अद्वितीय पूर्णांकों की array से (a, b, c) त्रिक को चुनने के कितने तरीके हैं जो ऊँचाइयों का प्रतिनिधित्व करते हैं ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "hu": "Írj egy JavaScript függvényt `function countTriplets(heights)`, hogy megoldja a következő problémát:  \nMeghatározza, hányféleképpen lehet választani egy hármas (a, b, c) egy tömbből, amely különböző egész számokat tartalmaz, amelyek magasságokat képviselnek, úgy hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n\n@example\ncountTriplets([1, 5, 7])\n// Visszatér: 1"
    },
    "instruction_bertscore": {
      "sq": "0.9387364315774095",
      "hy": "0.9873567789863673",
      "bn": "0.9900416658468159",
      "bg": "0.9855873795521085",
      "zh": "0.9798702012947813",
      "fr": "0.9877856219790216",
      "de": "0.9916444143913864",
      "ha": "0.9125482076202457",
      "hi": "0.9614243909599764",
      "hu": "0.9711396015267738"
    },
    "level": "hard",
    "test": "const main = () => {\n    console.assert(countTriplets([1, 5, 7]) === 1);\n    console.assert(countTriplets([1, 6, 2, 3]) === 3);\n    console.assert(countTriplets([16, 4, 8, 2]) === 0);\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77);\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7);\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104);\n    console.assert(countTriplets([3, 7, 11, 13]) === 4);\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10);\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87);\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122);\n}\n\nmain();",
    "entry_point": "countTriplets",
    "signature": "function countTriplets(heights)",
    "docstring": {
      "en": "Determines the number of ways to choose a triplet (a, b, c) from an array of distinct integers representing heights such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "sq": "Përcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c) nga një varg i numrave të plotë të ndryshëm që përfaqësojnë lartësitë në mënyrë të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes është 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Kthen: 1",
      "hy": "Սահմանում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) տարբեր ամբողջ թվերից կազմված զանգվածից, որոնք ներկայացնում են բարձրությունները այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n@example\ncountTriplets([1, 5, 7])\n// Վերադարձնում է: 1",
      "bn": "একটি পৃথক পূর্ণসংখ্যার অ্যারের থেকে একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা নির্ধারণ করে যা উচ্চতা উপস্থাপন করে যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।\n\n@example\ncountTriplets([1, 5, 7])\n// ফেরত দেয়: 1",
      "bg": "Определя броя на начините за избор на тройка (a, b, c) от масив от различни цели числа, представляващи височини, така че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Връща: 1",
      "zh": "确定从一个表示高度的不同整数数组中选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n@example\ncountTriplets([1, 5, 7])\n// 返回: 1",
      "fr": "Détermine le nombre de façons de choisir un triplet (a, b, c) à partir d'un tableau d'entiers distincts représentant des hauteurs, de sorte que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Renvoie : 1",
      "de": "Bestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) aus einem Array von verschiedenen ganzen Zahlen zu wählen, die Höhen darstellen, sodass der größte gemeinsame Teiler (GGT) der maximalen und minimalen Werte des Tripels 1 ist.\n\n@example\ncountTriplets([1, 5, 7])\n// Gibt zurück: 1",
      "ha": "Yana ƙayyade yawan hanyoyin zaɓar triplet (a, b, c) daga wani tsari na lambobi daban-daban masu wakiltar tsawo ta yadda babban raba mai haɗin kai (GCD) na mafi girma da ƙananan ƙimar triplet ɗin shine 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "hi": "त्रयक (a, b, c) चुनने के तरीकों की संख्या निर्धारित करता है जो ऊँचाइयों का प्रतिनिधित्व करने वाले भिन्न पूर्णांकों के एक सरणी से होते हैं ताकि त्रयक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n@example\ncountTriplets([1, 5, 7])\n// लौटाता है: 1",
      "hu": "Meghatározza, hogy hányféleképpen lehet kiválasztani egy (a, b, c) hármast egy különböző egész számokat tartalmazó tömbből, amelyek magasságokat képviselnek, úgy, hogy a hármas maximális és minimális értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n\n@example\ncountTriplets([1, 5, 7])\n// Visszatér: 1"
    },
    "docstring_bertscore": {
      "sq": "0.9843580561238836",
      "hy": "0.9560524323048879",
      "bn": "0.999999801369619",
      "bg": "0.9925177921767968",
      "zh": "0.976970793622815",
      "fr": "0.9843290560882525",
      "de": "0.989985254818602",
      "ha": "0.9691219141162215",
      "hi": "0.999999801369619",
      "hu": "0.9673840969125472"
    }
  },
  {
    "task_id": "JavaScript/45",
    "prompt": {
      "en": "\n/**\n * Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all \n * connected pixels of the same color to a chosen color, where two pixels are connected if they are \n * adjacent and have the same color. The goal is to find the minimum number of operations required \n * to make all pixels the same color.\n * Note: For each color, there are at most 20 pixels of that color.\n * \n * Examples:\n *    extraNumber(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction minOperations(n, pixels)",
      "sq": "/**\n * Duke pasur një imazh 1 me n piksel, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë \n * pikselët e lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy pikselë janë të lidhur nëse janë \n * ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjeni numrin minimal të operacioneve të kërkuara \n * për t'i bërë të gjithë pikselët të së njëjtës ngjyrë.\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n * \n * Shembuj:\n *    extraNumber(5, [1, 2, 3, 2, 1]) kthen 2\n */\nfunction minOperations(n, pixels)",
      "hy": "/**\n * Տրված է 1xn չափսի պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք փոխել \n * նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ \n * Նպատակն է գտնել նվազագույն քանակությամբ գործողություններ, որոնք անհրաժեշտ են բոլոր պիքսելները նույն գույնի դարձնելու համար։\n * Նշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n * \n * Օրինակներ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) վերադարձնում է 2\n */\nfunction minOperations(n, pixels)",
      "bn": "/**\n * একটি 1 বাই n পিক্সেল ইমেজ দেওয়া আছে, যেখানে প্রতিটি পিক্সেলের রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি সমস্ত সংযুক্ত পিক্সেলগুলিকে একটি পছন্দের রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। লক্ষ্য হল সমস্ত পিক্সেলকে একই রঙে পরিণত করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\n * নোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n * \n * উদাহরণ:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 প্রদান করে\n */",
      "bg": "/**\n * Дадено е изображение 1 на n пиксела, като всеки пиксел има цвят, представен с цяло число. Можете да промените всички \n * свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими \n * за да се направят всички пиксели с един и същ цвят.\n * Забележка: За всеки цвят има най-много 20 пиксела от този цвят.\n * \n * Примери:\n *    extraNumber(5, [1, 2, 3, 2, 1]) връща 2\n */",
      "zh": "/**\n * 给定一个 1 x n 像素的图像，每个像素的颜色由一个整数表示。你可以将所有相同颜色的相连像素更改为选定的颜色，其中如果两个像素相邻且颜色相同，则它们是相连的。目标是找到使所有像素颜色相同所需的最小操作次数。\n * 注意：对于每种颜色，最多有 20 个该颜色的像素。\n * \n * 示例:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 返回 2\n */",
      "fr": "/**\n * Étant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous \n * les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont \n * adjacents et ont la même couleur. Le but est de trouver le nombre minimum d'opérations nécessaires \n * pour que tous les pixels soient de la même couleur.\n * Remarque : Pour chaque couleur, il y a au maximum 20 pixels de cette couleur.\n * \n * Exemples :\n *    extraNumber(5, [1, 2, 3, 2, 1]) retourne 2\n */",
      "de": "/**\n * Gegeben ein 1x n Pixelbild, hat jedes Pixel eine Farbe, die durch eine ganze Zahl dargestellt wird. Sie können alle \n * verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie \n * benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, \n * um alle Pixel in dieselbe Farbe zu ändern.\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n * \n * Beispiele:\n *    extraNumber(5, [1, 2, 3, 2, 1]) gibt 2 zurück\n */\nfunction minOperations(n, pixels)",
      "ha": "/**\n * An bayar da hoton pixel 1 ta n, kowane pixel yana da launi wanda aka wakilta da lamba. Za ka iya canza duk \n * pixels masu haɗuwa na launi ɗaya zuwa launi da aka zaɓa, inda pixels biyu suke haɗuwa idan suna \n * kusa kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata \n * don sa duk pixels su zama launi ɗaya.\n * Lura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.\n * \n * Misalai:\n *    extraNumber(5, [1, 2, 3, 2, 1]) yana dawowa 2\n */\nfunction minOperations(n, pixels)",
      "hi": "/**\n * दिए गए 1 बाय n पिक्सेल छवि में, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप सभी \n * जुड़े हुए पिक्सेल को एक चुने हुए रंग में बदल सकते हैं, जहाँ दो पिक्सेल जुड़े हुए होते हैं यदि वे \n * आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बनाने के लिए \n * न्यूनतम संख्या में ऑपरेशन्स का पता लगाना।\n * नोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n * \n * उदाहरण:\n *    extraNumber(5, [1, 2, 3, 2, 1]) 2 लौटाता है\n */\nfunction minOperations(n, pixels)",
      "hu": "/**\n * Adott egy 1 x n pixeles kép, ahol minden pixel színét egy egész szám reprezentálja. Módosíthatod az összes \n * összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor van összekapcsolva, ha szomszédosak \n * és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz, hogy minden pixel \n * azonos színű legyen.\n * Megjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n * \n * Példák:\n *    extraNumber(5, [1, 2, 3, 2, 1]) visszaadja 2\n */\nfunction minOperations(n, pixels)"
    },
    "prompt_bertscore": {
      "sq": "0.9884309720870039",
      "hy": "0.964621744203495",
      "bn": "0.9270317391141666",
      "bg": "0.9597044504905954",
      "zh": "0.9370742925489095",
      "fr": "0.9633111809494268",
      "de": "0.9868061755701386",
      "ha": "0.981348607220824",
      "hi": "0.9520965096361971",
      "hu": "0.970610847452459"
    },
    "canonical_solution": "{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}",
    "instruction": {
      "en": "Write a JavaScript function `function minOperations(n, pixels)` to solve the following problem:\nGiven a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\nextraNumber(5, [1, 2, 3, 2, 1]) returns 2",
      "sq": "Shkruani një funksion JavaScript `function minOperations(n, pixels)` për të zgjidhur problemin në vijim:  \nDuke pasur një imazh 1 me n pikselë, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë pikselët e lidhur me të njëjtën ngjyrë në një ngjyrë të zgjedhur, ku dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjeni numrin minimal të operacioneve të kërkuara për t'i bërë të gjithë pikselët me të njëjtën ngjyrë.  \nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:  \nextraNumber(5, [1, 2, 3, 2, 1]) kthen 2",
      "hy": "Գրեք JavaScript ֆունկցիա `function minOperations(n, pixels)` հետևյալ խնդիրը լուծելու համար:\nՏրված է 1-ից n պիքսել պատկեր, յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք փոխել նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել այդ գույնի:\n\nՕրինակներ:\nextraNumber(5, [1, 2, 3, 2, 1]) վերադարձնում է 2",
      "bn": "একটি JavaScript ফাংশন `function minOperations(n, pixels)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক একটি 1 বাই n পিক্সেল ইমেজ, প্রতিটি পিক্সেলের একটি রঙ আছে যা একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একই রঙের সংযুক্ত পিক্সেলগুলিকে একটি পছন্দের রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং তাদের রঙ একই হয়। লক্ষ্য হল সমস্ত পিক্সেলকে একই রঙে করার জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function minOperations(n, pixels)`, за да решите следния проблем:  \nДадено е изображение с размер 1 на n пиксела, като всеки пиксел има цвят, представен от цяло число. Можете да промените всички свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими, за да се направят всички пиксели с един и същ цвят.  \nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.  \n\nПримери:  \nextraNumber(5, [1, 2, 3, 2, 1]) връща 2",
      "zh": "编写一个JavaScript函数 `function minOperations(n, pixels)` 来解决以下问题：  \n给定一个1乘n的像素图像，每个像素都有一个由整数表示的颜色。你可以将所有相同颜色的连接像素更改为一个选定的颜色，其中如果两个像素相邻且颜色相同，则它们是连接的。目标是找到使所有像素颜色相同所需的最小操作次数。  \n注意：对于每种颜色，最多有20个该颜色的像素。\n\n示例：  \nextraNumber(5, [1, 2, 3, 2, 1]) 返回 2",
      "fr": "Écrire une fonction JavaScript `function minOperations(n, pixels)` pour résoudre le problème suivant :  \nÉtant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont adjacents et ont la même couleur. L'objectif est de trouver le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.  \nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :  \nextraNumber(5, [1, 2, 3, 2, 1]) renvoie 2",
      "de": "Schreiben Sie eine JavaScript-Funktion `function minOperations(n, pixels)`, um das folgende Problem zu lösen:\nGegeben ist ein 1-mal-n-Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können alle verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\nextraNumber(5, [1, 2, 3, 2, 1]) gibt 2 zurück",
      "ha": "Rubuta aikin JavaScript `function minOperations(n, pixels)` don warware matsalar mai zuwa:\nAn ba da hoton pixel 1 ta n, kowanne pixel yana da launi wanda aka wakilta da lamba. Kuna iya canza duk pixels masu haɗin kai na launi ɗaya zuwa launi da aka zaɓa, inda pixels biyu suka haɗu idan suna makwabtaka kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\nLura: Ga kowane launi, akwai mafi yawa pixels 20 na wannan launi.\n\nMisalai:\nextraNumber(5, [1, 2, 3, 2, 1]) yana dawowa 2",
      "hi": "`function minOperations(n, pixels)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए 1 बाय n पिक्सेल इमेज में, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप चुने गए रंग में एक ही रंग के सभी जुड़े पिक्सेल को बदल सकते हैं, जहां दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बदलने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या का पता लगाया जाए।\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 लौटाता है।",
      "hu": "Írj egy JavaScript függvényt `function minOperations(n, pixels)` a következő probléma megoldására:  \nAdott egy 1 x n képpontból álló kép, ahol minden képpont színe egy egész számmal van reprezentálva. Megváltoztathatod az összes összekapcsolt, azonos színű képpontot egy választott színre, ahol két képpont akkor van összekapcsolva, ha szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz, hogy az összes képpont azonos színű legyen.  \nMegjegyzés: Minden szín esetében legfeljebb 20 képpont van abból a színből.\n\nPéldák:  \nextraNumber(5, [1, 2, 3, 2, 1]) visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9884317666085282",
      "hy": "0.981735737833461",
      "bn": "0.9638540377807951",
      "bg": "0.9780612744146966",
      "zh": "0.9797255983773879",
      "fr": "0.9914567086813084",
      "de": "0.9759931348873614",
      "ha": "0.9714675402858625",
      "hi": "0.9528669968842314",
      "hu": "0.9680429538864399"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2);\n    console.assert(minOperations(4, [1, 1, 2, 2]) === 1);\n    console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3);\n    console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0);\n    console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1);\n    console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2);\n    console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1);\n    console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8);\n    console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5);\n    console.assert(minOperations(3, [3, 3, 3]) === 0);\n    console.assert(minOperations(4, [2, 1, 1, 2]) === 1);\n})();",
    "entry_point": "minOperations",
    "signature": "function minOperations(n, pixels)",
    "docstring": {
      "en": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all connected pixels of the same color to a chosen color, where two pixels are connected if they are adjacent and have the same color. The goal is to find the minimum number of operations required to make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\nextraNumber(5, [1, 2, 3, 2, 1]) returns 2",
      "sq": "Duke pasur një imazh 1 me n piksel, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjendet numri minimal i operacioneve të nevojshme për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\nShënim: Për çdo ngjyrë, ka më së shumti 20 piksela të asaj ngjyre.\n\nShembuj:\nextraNumber(5, [1, 2, 3, 2, 1]) kthen 2",
      "hy": "Տրված է 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք փոխել նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n\nՕրինակներ:\nextraNumber(5, [1, 2, 3, 2, 1]) վերադարձնում է 2",
      "bn": "একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ রয়েছে যা একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি নির্বাচিত রঙে একই রঙের সংযুক্ত সমস্ত পিক্সেল পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙ থাকে। সমস্ত পিক্সেলকে একই রঙে পরিবর্তন করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করাই লক্ষ্য।\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল থাকতে পারে।\n\nউদাহরণ:\nextraNumber(5, [1, 2, 3, 2, 1]) ২ ফেরত দেয়",
      "bg": "Дадено е изображение с размери 1 на n пиксела, като всеки пиксел има цвят, представен с цяло число. Можете да промените всички свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими, за да се направят всички пиксели с един и същ цвят.\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\nextraNumber(5, [1, 2, 3, 2, 1]) връща 2",
      "zh": "给定一个 1 x n 像素的图像，每个像素的颜色由一个整数表示。您可以将所有相同颜色的连接像素更改为选定的颜色，其中如果两个像素相邻并且颜色相同，则它们是连接的。目标是找到使所有像素颜色相同所需的最小操作次数。\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\nextraNumber(5, [1, 2, 3, 2, 1]) 返回 2",
      "fr": "Étant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont adjacents et ont la même couleur. L'objectif est de trouver le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples:\nextraNumber(5, [1, 2, 3, 2, 1]) retourne 2",
      "de": "Gegeben ein 1x n Pixel Bild, wobei jedes Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Sie können alle verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\nextraNumber(5, [1, 2, 3, 2, 1]) gibt 2 zurück",
      "ha": "An ba da hoton pixel 1 ta n, kowane pixel yana da launi wanda aka wakilta da lamba. Za ka iya canza duk pixels da aka haɗa na launi ɗaya zuwa launi da aka zaɓa, inda aka haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\nLura: Don kowane launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\nextraNumber(5, [1, 2, 3, 2, 1]) yana dawowa 2",
      "hi": "1 by n पिक्सेल छवि दी गई है, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक चुने हुए रंग में एक ही रंग के सभी जुड़े पिक्सेल को बदल सकते हैं, जहाँ दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम संचालन की संख्या का पता लगाना है। \nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\nextraNumber(5, [1, 2, 3, 2, 1]) 2 लौटाता है",
      "hu": "Egy 1 x n pixeles képet kapunk, ahol minden pixel színe egy egész számmal van ábrázolva. Megváltoztathatja az összes összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\nextraNumber(5, [1, 2, 3, 2, 1]) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.979310460881025",
      "hy": "0.9786579600793254",
      "bn": "0.9562516585770658",
      "bg": "0.9692204347852148",
      "zh": "0.9744972494877876",
      "fr": "0.9911019548207801",
      "de": "0.9790748852491177",
      "ha": "0.9655584850804556",
      "hi": "0.9547396841166284",
      "hu": "0.9444128906066245"
    }
  },
  {
    "task_id": "JavaScript/46",
    "prompt": {
      "en": "\n/**\n * Given an integer n, write a function to compute the sum of all numbers from 1 to n\n * that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\n * it should only be counted once.\n * For example:\n *     sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "sq": "/**\n * Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n\n * që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,\n * ai duhet të numërohet vetëm një herë.\n * Për shembull:\n *     sumOfMultiples(10); // kthen 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "hy": "/**\n * Տրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվարկելու 1-ից n բոլոր այն թվերի գումարը,\n * որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի,\n * այն պետք է հաշվել միայն մեկ անգամ։\n * Օրինակ:\n *     sumOfMultiples(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "bn": "/**\n * একটি পূর্ণসংখ্যা n দেওয়া হলে, 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন\n * যা হয় 3 অথবা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়েরই গুণিতক হয়,\n * তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n * উদাহরণস্বরূপ:\n *     sumOfMultiples(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "bg": "/**\n * Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\n * които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5,\n * то трябва да бъде преброено само веднъж.\n * Например:\n *     sumOfMultiples(10); // връща 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "zh": "/**\n * 给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。\n * 如果一个数字同时是 3 和 5 的倍数，它应该只被计算一次。\n * 例如：\n *     sumOfMultiples(10); // 返回 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "fr": "/**\n * Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n\n * qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5,\n * il ne doit être compté qu'une seule fois.\n * Par exemple :\n *     sumOfMultiples(10); // retourne 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "de": "/**\n * Gegeben eine ganze Zahl n, schreibe eine Funktion, um die Summe aller Zahlen von 1 bis n\n * zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist,\n * sollte sie nur einmal gezählt werden.\n * Zum Beispiel:\n *     sumOfMultiples(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "ha": "/**\n * Idan aka ba da lamba n, rubuta wata aiki don lissafin jimillar dukkan lambobi daga 1 zuwa n\n * waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5,\n * ya kamata a ƙirga shi sau ɗaya kawai.\n * Alal misali:\n *     sumOfMultiples(10); // ya dawo da 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "hi": "/**\n * दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे\n * जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों की गुणज है,\n * तो उसे केवल एक बार गिना जाना चाहिए।\n * उदाहरण के लिए:\n *     sumOfMultiples(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)",
      "hu": "/**\n * Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét,\n * amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3-nak, mind az 5-nek többszöröse,\n * akkor csak egyszer kell számolni.\n * Például:\n *     sumOfMultiples(10); // visszaadja 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9915085512107585",
      "hy": "0.9858797634729919",
      "bn": "0.9960909541012334",
      "bg": "0.9879512797168047",
      "zh": "0.979720433987481",
      "fr": "0.9923443878541534",
      "de": "0.996943078435873",
      "ha": "0.9912497358242701",
      "hi": "0.9858732086704177",
      "hu": "0.9906524542684981"
    },
    "canonical_solution": "{\n    let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function sumOfMultiples(n)` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "sq": "Shkruani një funksion JavaScript `function sumOfMultiples(n)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.  \nPër shembull:  \n    sumOfMultiples(10); // kthen 33 (3 + 5 + 6 + 9 + 10)",
      "hy": "Գրեք JavaScript ֆունկցիա `function sumOfMultiples(n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից մինչև n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվի առնվի միայն մեկ անգամ։\nՕրինակ:\n    sumOfMultiples(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function sumOfMultiples(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়েরই গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\nউদাহরণস্বরূপ:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "bg": "Напишете функция на JavaScript `function sumOfMultiples(n)`, за да решите следния проблем:  \nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да се брои само веднъж.  \nНапример:  \n    sumOfMultiples(10); // връща 33 (3 + 5 + 6 + 9 + 10)",
      "zh": "编写一个 JavaScript 函数 `function sumOfMultiples(n)` 来解决以下问题：  \n给定一个整数 n，编写一个函数来计算从 1 到 n 的所有 3 或 5 的倍数的和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。  \n例如：  \n    sumOfMultiples(10); // 返回 33 (3 + 5 + 6 + 9 + 10)",
      "fr": "Écrire une fonction JavaScript `function sumOfMultiples(n)` pour résoudre le problème suivant :  \nÉtant donné un entier n, écrire une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.  \nPar exemple :  \n    sumOfMultiples(10); // retourne 33 (3 + 5 + 6 + 9 + 10)",
      "de": "Schreiben Sie eine JavaScript-Funktion `function sumOfMultiples(n)`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches sowohl von 3 als auch von 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    sumOfMultiples(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)",
      "ha": "Rubuta wani aikin JavaScript `function sumOfMultiples(n)` don warware matsalar mai zuwa:\nAn ba da wani cikakken lamba n, rubuta wani aiki don lissafin jimillar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5. Idan lamba tana da yawa na 3 da 5 duka, ya kamata a ƙidaya shi sau ɗaya kawai.\nMisali:\n    sumOfMultiples(10); // yana dawowa 33 (3 + 5 + 6 + 9 + 10)",
      "hi": "`function sumOfMultiples(n)` समस्या को हल करने के लिए एक JavaScript फ़ंक्शन लिखें:\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    sumOfMultiples(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)",
      "hu": "Írj egy JavaScript függvényt `function sumOfMultiples(n)` a következő probléma megoldására:\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1 és n közötti szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor csak egyszer kell számolni.\nPéldául:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "sq": "0.9918037159569764",
      "hy": "0.987502970946809",
      "bn": "0.9915584074363983",
      "bg": "0.9918037159569764",
      "zh": "0.9684429954738442",
      "fr": "0.9927917034722439",
      "de": "0.9970044552236128",
      "ha": "0.9819307928676373",
      "hi": "0.973320960371299",
      "hu": "0.9884492460820592"
    },
    "level": "easy",
    "test": "const testSumOfMultiples = () => {\n    console.assert(sumOfMultiples(10) === 33, 'Test case n=10 failed');\n    console.assert(sumOfMultiples(15) === 60, 'Test case n=15 failed');\n    console.assert(sumOfMultiples(20) === 98, 'Test case n=20 failed');\n    console.assert(sumOfMultiples(5) === 8, 'Test case n=5 failed');\n    console.assert(sumOfMultiples(3) === 3, 'Test case n=3 failed');\n    console.assert(sumOfMultiples(6) === 14, 'Test case n=6 failed');\n    console.assert(sumOfMultiples(9) === 23, 'Test case n=9 failed');\n    console.assert(sumOfMultiples(12) === 45, 'Test case n=12 failed');\n    console.assert(sumOfMultiples(17) === 60, 'Test case n=17 failed');\n    console.assert(sumOfMultiples(21) === 119, 'Test case n=21 failed');\n    console.assert(sumOfMultiples(25) === 168, 'Test case n=25 failed');\n};\n\ntestSumOfMultiples();",
    "entry_point": "sumOfMultiples",
    "signature": "function sumOfMultiples(n)",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish të 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5, ai duhet të numërohet vetëm një herë.\nPër shembull:\n    sumOfMultiples(10); // kthen 33 (3 + 5 + 6 + 9 + 10)",
      "hy": "Տրված է n ամբողջ թիվը, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի: Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվի առնվի միայն մեկ անգամ:\nՕրինակ:\n    sumOfMultiples(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ অথবা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়েরই গুণিতক হয়, তবে এটি কেবল একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    sumOfMultiples(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)",
      "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да се брои само веднъж.\nНапример:\n    sumOfMultiples(10); // връща 33 (3 + 5 + 6 + 9 + 10)",
      "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n例如：\n    sumOfMultiples(10); // 返回 33 (3 + 5 + 6 + 9 + 10)",
      "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\nPar exemple :\n    sumOfMultiples(10); // retourne 33 (3 + 5 + 6 + 9 + 10)",
      "de": "Angenommen, eine ganze Zahl n ist gegeben, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\nZum Beispiel:\n    sumOfMultiples(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)",
      "ha": "An ba da wani lamba n, rubuta wata aiki don ƙididdige jumlar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙirga ta sau ɗaya kawai.\nMisali:\n    sumOfMultiples(10); // yana dawowa 33 (3 + 5 + 6 + 9 + 10)",
      "hi": "दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\nउदाहरण के लिए:\n    sumOfMultiples(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)",
      "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor azt csak egyszer kell számolni.\nPéldául:\n    sumOfMultiples(10); // visszaadja a 33-at (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "sq": "0.9891949045324642",
      "hy": "0.9852149475876681",
      "bn": "0.9898460149214965",
      "bg": "0.9887452053498011",
      "zh": "0.9845797276291185",
      "fr": "0.9898460149214965",
      "de": "0.9703675252356913",
      "ha": "0.9692802225299063",
      "hi": "0.9750520241420181",
      "hu": "0.9887376573953218"
    }
  },
  {
    "task_id": "JavaScript/47",
    "prompt": {
      "en": "\n/**\n * Determine if a given string is a palindrome.\n * A palindrome is a word, phrase, number, or other sequence of characters\n * that reads the same forward and backward (ignoring spaces, punctuation,\n * and capitalization).\n * \n * Examples:\n * isPalindrome(\"racecar\") // returns true\n * isPalindrome(\"hello\") // returns false\n */\nfunction isPalindrome(str)",
      "sq": "/**\n * Përcaktoni nëse një varg i dhënë është një palindrom.\n * Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\n * që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,\n * dhe shkronjat e mëdha).\n * \n * Shembuj:\n * isPalindrome(\"racecar\") // kthen true\n * isPalindrome(\"hello\") // kthen false\n */\nfunction isPalindrome(str)",
      "hy": "/**\n * Պարզել, արդյոք տրված տողը պալինդրոմ է:\n * Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է,\n * որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\n * և մեծատառերը):\n * \n * Օրինակներ:\n * isPalindrome(\"racecar\") // վերադարձնում է true\n * isPalindrome(\"hello\") // վերադարձնում է false\n */\nfunction isPalindrome(str)",
      "bn": "/**\n * একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন।\n * একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম\n * যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন,\n * এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * \n * উদাহরণসমূহ:\n * isPalindrome(\"racecar\") // true রিটার্ন করে\n * isPalindrome(\"hello\") // false রিটার্ন করে\n */\nfunction isPalindrome(str)",
      "bg": "/**\n * Определете дали даден низ е палиндром.\n * Палиндром е дума, фраза, число или друга последователност от символи,\n * която се чете еднакво напред и назад (като се игнорират интервалите, пунктуацията\n * и главните букви).\n * \n * Примери:\n * isPalindrome(\"racecar\") // връща true\n * isPalindrome(\"hello\") // връща false\n */\nfunction isPalindrome(str)",
      "zh": "/**\n * 确定给定的字符串是否是回文。\n * 回文是指正读和反读都相同的单词、短语、数字或其他字符序列\n * （忽略空格、标点符号和大小写）。\n * \n * 示例:\n * isPalindrome(\"racecar\") // 返回 true\n * isPalindrome(\"hello\") // 返回 false\n */\nfunction isPalindrome(str)",
      "fr": "/**\n * Déterminer si une chaîne donnée est un palindrome.\n * Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères\n * qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation,\n * et la capitalisation).\n * \n * Exemples :\n * isPalindrome(\"racecar\") // retourne true\n * isPalindrome(\"hello\") // retourne false\n */\nfunction isPalindrome(str)",
      "de": "/**\n * Bestimmen, ob eine gegebene Zeichenkette ein Palindrom ist.\n * Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\n * die vorwärts und rückwärts gleich gelesen wird (ohne Berücksichtigung von Leerzeichen, \n * Satzzeichen und Groß-/Kleinschreibung).\n * \n * Beispiele:\n * isPalindrome(\"racecar\") // gibt true zurück\n * isPalindrome(\"hello\") // gibt false zurück\n */\nfunction isPalindrome(str)",
      "ha": "/**\n * Tantance ko wani kirtani da aka bayar palindrome ne.\n * Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa\n * da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu,\n * da manyan ba).\n * \n * Misalai:\n * isPalindrome(\"racecar\") // ya dawo da true\n * isPalindrome(\"hello\") // ya dawo da false\n */\nfunction isPalindrome(str)",
      "hi": "/**\n * यह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं।\n * एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है\n * जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न,\n * और बड़े अक्षरों को नजरअंदाज करते हुए)।\n * \n * उदाहरण:\n * isPalindrome(\"racecar\") // true लौटाता है\n * isPalindrome(\"hello\") // false लौटाता है\n */\nfunction isPalindrome(str)",
      "hu": "/**\n * Határozza meg, hogy egy adott sztring palindróm-e.\n * Egy palindróm egy szó, kifejezés, szám vagy más karaktersorozat,\n * amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\n * és a nagybetűket).\n * \n * Példák:\n * isPalindrome(\"racecar\") // visszaadja: true\n * isPalindrome(\"hello\") // visszaadja: false\n */\nfunction isPalindrome(str)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9970890717659338",
      "bn": "1",
      "bg": "0.9992513620938795",
      "zh": "0.9793938856410597",
      "fr": "1",
      "de": "0.9903459675905614",
      "ha": "1",
      "hi": "0.956252850359352",
      "hu": "0.9913051537005788"
    },
    "canonical_solution": "{\n  let start = 0;\n  let end = str.length - 1;\n\n  while (start < end) {\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while (!isalnum(str[start]) && start < end) start++;\n    while (!isalnum(str[end]) && start < end) end--;\n    if (str[start].toLowerCase() !== str[end].toLowerCase())\n      return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\n// Helper function to check if a character is alphanumeric\nfunction isalnum(char) {\n  let code = char.charCodeAt(0);\n  return (code > 47 && code < 58) || // numeric (0-9)\n         (code > 64 && code < 91) || // upper alpha (A-Z)\n         (code > 96 && code < 123);  // lower alpha (a-z)\n}",
    "instruction": {
      "en": "Write a JavaScript function `function isPalindrome(str)` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\nisPalindrome(\"hello\") // returns false",
      "sq": "Shkruani një funksion JavaScript `function isPalindrome(str)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse një varg i dhënë është një palindrom.\nNjë palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\nqë lexohet njësoj përpara dhe mbrapa (duke injoruar hapësirat, shenjat e pikësimit,\ndhe shkronjat e mëdha).\n\nShembuj:\nisPalindrome(\"racecar\") // kthen true\nisPalindrome(\"hello\") // kthen false",
      "hy": "Գրեք JavaScript ֆունկցիա `function isPalindrome(str)`՝ հետևյալ խնդիրը լուծելու համար:\nՍահմանեք՝ արդյոք տրված տողը պալինդրոմ է:\nՊալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է,\nորը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\nև մեծատառերը):\n\nՕրինակներ:\nisPalindrome(\"racecar\") // վերադարձնում է true\nisPalindrome(\"hello\") // վերադարձնում է false",
      "bn": "একটি JavaScript ফাংশন `function isPalindrome(str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা।\nএকটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম\nযা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন,\nএবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\nisPalindrome(\"racecar\") // true রিটার্ন করে\nisPalindrome(\"hello\") // false রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function isPalindrome(str)` за решаване на следния проблем:  \nОпределете дали даден низ е палиндром.  \nПалиндром е дума, фраза, число или друга последователност от символи,  \nкоято се чете еднакво напред и назад (като се игнорират интервали, пунктуация  \nи главни букви).\n\nПримери:  \nisPalindrome(\"racecar\") // връща true  \nisPalindrome(\"hello\") // връща false",
      "zh": "编写一个 JavaScript 函数 `function isPalindrome(str)` 来解决以下问题：  \n确定给定的字符串是否是回文。  \n回文是指正着读和反着读都相同的单词、短语、数字或其他字符序列（忽略空格、标点符号和大小写）。  \n\n示例：  \nisPalindrome(\"racecar\") // 返回 true  \nisPalindrome(\"hello\") // 返回 false",
      "fr": "Écrire une fonction JavaScript `function isPalindrome(str)` pour résoudre le problème suivant :  \nDéterminer si une chaîne donnée est un palindrome.  \nUn palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères  \nqui se lit de la même façon de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation,  \net la capitalisation).\n\nExemples :  \nisPalindrome(\"racecar\") // retourne true  \nisPalindrome(\"hello\") // retourne false",
      "de": "Schreiben Sie eine JavaScript-Funktion `function isPalindrome(str)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist.\nEin Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\ndie vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion\nund Groß-/Kleinschreibung).\n\nBeispiele:\nisPalindrome(\"racecar\") // gibt true zurück\nisPalindrome(\"hello\") // gibt false zurück",
      "ha": "Rubuta wani aikin JavaScript `function isPalindrome(str)` don warware matsalar mai zuwa:  \nGano ko wani kirtani da aka bayar palindrome ne.  \nPalindrome kalma ce, jimla, lamba, ko wata jerin haruffa  \nwanda yake karanta iri ɗaya a gaba da baya (ba tare da la'akari da sarari, rubutu,  \nda manyan haruffa ba).  \n\nMisalai:  \nisPalindrome(\"racecar\") // returns true  \nisPalindrome(\"hello\") // returns false  ",
      "hi": "एक JavaScript फ़ंक्शन `function isPalindrome(str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं।\nएक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है\nजो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों को अनदेखा करते हुए)।\n\nउदाहरण:\nisPalindrome(\"racecar\") // returns true\nisPalindrome(\"hello\") // returns false",
      "hu": "Írj egy JavaScript függvényt `function isPalindrome(str)` a következő probléma megoldására:\nHatározd meg, hogy egy adott string palindróm-e.\nA palindróm egy szó, kifejezés, szám vagy más karakterlánc,\namely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\nés a nagybetűket).\n\nPéldák:\nisPalindrome(\"racecar\") // visszaadja: true\nisPalindrome(\"hello\") // visszaadja: false"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9969740647753145",
      "bn": "0.9985182173574797",
      "bg": "0.9991766770706104",
      "zh": "0.9875631559522625",
      "fr": "0.999999801369619",
      "de": "0.9942198559118848",
      "ha": "0.999999801369619",
      "hi": "0.972768767912022",
      "hu": "0.992701525279254"
    },
    "level": "hard",
    "test": "const testIsPalindrome = () => {\n  console.assert(isPalindrome(\"A man a plan a canal Panama\") === true, \"Test 1 failed\");\n  console.assert(isPalindrome(\"No lemon, no melon\") === true, \"Test 2 failed\");\n  console.assert(isPalindrome(\"Was it a car or a cat I saw\") === true, \"Test 3 failed\");\n  console.assert(isPalindrome(\"Madam, in Eden, I'm Adam\") === true, \"Test 4 failed\");\n  console.assert(isPalindrome(\"Never odd or even\") === true, \"Test 5 failed\");\n  console.assert(isPalindrome(\"Eva, can I see bees in a cave\") === true, \"Test 6 failed\");\n  console.assert(isPalindrome(\"hello\") === false, \"Test 7 failed\");\n  console.assert(isPalindrome(\"GitHub\") === false, \"Test 8 failed\");\n  console.assert(isPalindrome(\"programming\") === false, \"Test 9 failed\");\n};\n\ntestIsPalindrome();",
    "entry_point": "isPalindrome",
    "signature": "function isPalindrome(str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\nisPalindrome(\"hello\") // returns false",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom.\nNjë palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\nqë lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,\ndhe kapitalizimin).\n\nShembuj:\nisPalindrome(\"racecar\") // kthen true\nisPalindrome(\"hello\") // kthen false",
      "hy": "Սահմանել, արդյոք տրված տողը պալինդրոմ է:\nՊալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն,\nորն ընթերցվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\nև մեծատառերը):\n\nՕրինակներ:\nisPalindrome(\"racecar\") // վերադարձնում է true\nisPalindrome(\"hello\") // վերադարձնում է false",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। \nএকটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\nisPalindrome(\"racecar\") // true ফেরত দেয়\nisPalindrome(\"hello\") // false ফেরত দেয়",
      "bg": "Определете дали даден низ е палиндром.  \nПалиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n\nПримери:  \nisPalindrome(\"racecar\") // връща true  \nisPalindrome(\"hello\") // връща false",
      "zh": "确定给定的字符串是否是回文。  \n回文是指一个单词、短语、数字或其他字符序列，正反读起来都一样（忽略空格、标点和大小写）。\n\n示例：  \nisPalindrome(\"racecar\") // 返回 true  \nisPalindrome(\"hello\") // 返回 false",
      "fr": "Déterminer si une chaîne donnée est un palindrome.  \nUn palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière de gauche à droite et de droite à gauche (en ignorant les espaces, la ponctuation et la capitalisation).\n\nExemples :  \nisPalindrome(\"racecar\") // retourne true  \nisPalindrome(\"hello\") // retourne false  ",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n\nBeispiele:\nisPalindrome(\"racecar\") // gibt true zurück\nisPalindrome(\"hello\") // gibt false zurück",
      "ha": "Kunna ko wani kirtani da aka bayar palindrome ne.  \nPalindrome kalma ce, jimla, lamba, ko wata jerin haruffa  \nwanda ke karanta iri ɗaya gaba da baya (watsi da sarari, rubutu,  \nda manyan baƙaƙe).\n\nMisalai:  \nisPalindrome(\"racecar\") // yana dawowa gaskiya  \nisPalindrome(\"hello\") // yana dawowa ƙarya  ",
      "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें।  \nएक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है  \nजो आगे और पीछे से समान पढ़ा जाता है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\nisPalindrome(\"racecar\") // true लौटाता है\nisPalindrome(\"hello\") // false लौटाता है",
      "hu": "Határozza meg, hogy egy adott sztring palindróm-e.\nA palindróm olyan szó, kifejezés, szám vagy más karakterlánc,\namely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\nés a nagybetűket).\n\nPéldák:\nisPalindrome(\"racecar\") // visszaadja: true\nisPalindrome(\"hello\") // visszaadja: false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9968254892503005",
      "bn": "0.9974273393048362",
      "bg": "1",
      "zh": "0.994602219395377",
      "fr": "0.9516489953877254",
      "de": "1",
      "ha": "0.9878811631922993",
      "hi": "0.9630775916213298",
      "hu": "0.9901840838300179"
    }
  },
  {
    "task_id": "JavaScript/48",
    "prompt": {
      "en": "\n/**\n * Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\n * For example:\n *   addDigits(38)  // returns 2\n *   Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n */\nfunction addDigits(num)",
      "sq": "/**\n * Duke pasur një numër jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\n * Për shembull:\n *   addDigits(38)  // kthen 2\n *   Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n */\nfunction addDigits(num)",
      "hy": "/**\n * Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\n * Օրինակ:\n *   addDigits(38)  // վերադարձնում է 2\n *   Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը:\n */\nfunction addDigits(num)",
      "bn": "/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\n * উদাহরণস্বরূপ:\n *   addDigits(38)  // 2 ফেরত দেয়\n *   ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক রয়েছে, 2 হল ফলাফল।\n */\nfunction addDigits(num)",
      "bg": "/**\n * Като се даде неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\n * Например:\n *   addDigits(38)  // връща 2\n *   Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n */\nfunction addDigits(num)",
      "zh": "/**\n * 给定一个非负整数 num，反复将所有位上的数字相加，直到结果只有一位数字。\n * 例如：\n *   addDigits(38)  // 返回 2\n *   解释：3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，因此 2 是结果。\n */\nfunction addDigits(num)",
      "fr": "/**\n * Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\n * Par exemple :\n *   addDigits(38)  // renvoie 2\n *   Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n */\nfunction addDigits(num)",
      "de": "/**\n * Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\n * Zum Beispiel:\n *   addDigits(38)  // gibt 2 zurück\n *   Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n */\nfunction addDigits(num)",
      "ha": "/**\n * An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\n * Alal misali:\n *   addDigits(38)  // yana dawowa 2\n *   Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n */\nfunction addDigits(num)",
      "hi": "/**\n * दिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसके सभी अंकों को तब तक जोड़ते रहें जब तक परिणाम में केवल एक अंक न रह जाए।\n * उदाहरण के लिए:\n *   addDigits(38)  // 2 लौटाता है\n *   व्याख्या: 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n */\nfunction addDigits(num)",
      "hu": "/**\n * Adott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\n * Például:\n *   addDigits(38)  // visszaadja a 2-t\n *   Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény.\n */\nfunction addDigits(num)"
    },
    "prompt_bertscore": {
      "sq": "0.9917925926556385",
      "hy": "0.9936078757079163",
      "bn": "0.9928707583638958",
      "bg": "0.9522581947663594",
      "zh": "0.9664805273092195",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.9820380532733961",
      "hu": "0.9660522802077083"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function addDigits(num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Shkruani një funksion JavaScript `function addDigits(num)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.  \nPër shembull:  \n  addDigits(38)  // kthen 2  \n  Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Գրեք JavaScript ֆունկցիա `function addDigits(num)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, շարունակաբար գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n  addDigits(38)  // վերադարձնում է 2\n  Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function addDigits(num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া আছে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফল এক অঙ্কের হয়।\nউদাহরণস্বরূপ:\n  addDigits(38)  // 2 ফেরত দেয়\n  ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এক অঙ্কের, তাই 2 হল ফলাফল।",
      "bg": "Напишете JavaScript функция `function addDigits(num)`, за да решите следния проблем:  \nДадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.  \nНапример:  \n  addDigits(38)  // връща 2  \n  Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.",
      "zh": "编写一个 JavaScript 函数 `function addDigits(num)` 来解决以下问题：  \n给定一个非负整数 num，重复将其所有位数相加，直到结果只有一位数字。  \n例如：  \n  addDigits(38)  // 返回 2  \n  解释：3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，因此结果是 2。",
      "fr": "Écrire une fonction JavaScript `function addDigits(num)` pour résoudre le problème suivant :  \nÉtant donné un entier non négatif num, additionner de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.  \nPar exemple :  \n  addDigits(38)  // renvoie 2  \n  Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Schreiben Sie eine JavaScript-Funktion `function addDigits(num)`, um das folgende Problem zu lösen:  \nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.  \nZum Beispiel:  \n  addDigits(38)  // gibt 2 zurück  \n  Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "Rubuta wani aikin JavaScript `function addDigits(num)` don warware matsalar mai zuwa:  \nAn ba da lamba mara kyau num, ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.  \nMisali:  \n  addDigits(38)  // yana dawowa 2  \n  Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.",
      "hi": "एक जावास्क्रिप्ट फ़ंक्शन `function addDigits(num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n  addDigits(38)  // 2 लौटाता है\n  व्याख्या: 3 + 8 = 11, और 1 + 1 = 2. चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Írj egy JavaScript függvényt `function addDigits(num)` a következő probléma megoldására:\nAdott egy nem negatív egész szám num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n  addDigits(38)  // visszaadja a 2-t\n  Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény."
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9949891513776329",
      "bn": "0.9741345504120179",
      "bg": "0.9574317216707942",
      "zh": "0.9625935293827478",
      "fr": "1",
      "de": "1",
      "ha": "0.9949891513776329",
      "hi": "0.9767435604669111",
      "hu": "0.9741345504120179"
    },
    "level": "easy",
    "test": "const testAddDigits = () => {\n    console.assert(addDigits(38) === 2, 'Test 1 failed');\n    console.assert(addDigits(0) === 0, 'Test 2 failed');\n    console.assert(addDigits(9) === 9, 'Test 3 failed');\n    console.assert(addDigits(123) === 6, 'Test 4 failed');\n    console.assert(addDigits(456) === 6, 'Test 5 failed');\n    console.assert(addDigits(9999) === 9, 'Test 6 failed');\n    console.assert(addDigits(100) === 1, 'Test 7 failed');\n    console.assert(addDigits(1010) === 2, 'Test 8 failed');\n    console.assert(addDigits(1234) === 1, 'Test 9 failed');\n    console.assert(addDigits(9876) === 3, 'Test 10 failed');\n    console.assert(addDigits(199) === 1, 'Test 11 failed');\n};\n\ntestAddDigits();",
    "entry_point": "addDigits",
    "signature": "function addDigits(num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni në mënyrë të përsëritur të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n  addDigits(38)  // kthen 2\n  Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\nՕրինակ:\n  addDigits(38)  // վերադարձնում է 2\n  Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է։",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলটি কেবল এক অঙ্কের হয়। উদাহরণস্বরূপ:\n  addDigits(38)  // 2 ফেরত দেয়\n  ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 কেবল এক অঙ্কের, তাই 2 হল ফলাফল।",
      "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n  addDigits(38)  // връща 2\n  Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.",
      "zh": "给定一个非负整数 num，重复相加其所有数字，直到结果只有一位数字。\n\n例如：\n  addDigits(38)  // 返回 2\n  解释：3 + 8 = 11，然后 1 + 1 = 2。由于 2 只有一位数字，因此结果是 2。",
      "fr": "Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n  addDigits(38)  // renvoie 2\n  Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Für eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n  addDigits(38)  // gibt 2 zurück\n  Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara dukkan lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n  addDigits(38)  // yana dawowa 2\n  Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.",
      "hi": "एक गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण:\n  addDigits(38)  // 2 लौटाता है\n  व्याख्या: 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Adott egy nem negatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n  addDigits(38)  // visszaadja a 2-t\n  Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény."
    },
    "docstring_bertscore": {
      "sq": "0.9954072683297113",
      "hy": "0.993703019660432",
      "bn": "0.965771814109687",
      "bg": "0.9441459313745136",
      "zh": "0.9518412695965672",
      "fr": "1",
      "de": "0.8719026713794575",
      "ha": "0.9497786917199009",
      "hi": "0.9739009610839209",
      "hu": "0.9712478550844379"
    }
  },
  {
    "task_id": "JavaScript/49",
    "prompt": {
      "en": "\n/**\n * You are playing a game called Nim. In this game, you start with a pile\n * of n stones, and you and your opponent take turns to remove 1 to 3\n * stones from the pile. The one who removes the last stone wins the game.\n * Given the number of stones n, determine if you can win the game if both\n * you and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *   canWinNim(1) // returns true\n */\nfunction canWinNim(n)",
      "sq": "/**\n * Po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull\n * prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3\n * gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën.\n * Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse të dy\n * ju dhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë merrni radhën e parë.\n *\n * Ja disa raste:\n *   canWinNim(1) // kthen true\n */\nfunction canWinNim(n)",
      "hy": "/**\n * Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով,\n * և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։ Նա, ով հեռացնում է\n * վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք\n * հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ։\n * Նշում: Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա որոշ դեպքեր:\n *   canWinNim(1) // վերադարձնում է true\n */",
      "bn": "/**\n * আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি একটি স্তূপের সাথে শুরু করেন\n * n পাথর, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে 1 থেকে 3\n * পাথর স্তূপ থেকে সরিয়ে নেন। যে শেষ পাথরটি সরায় সে গেমটি জিতে।\n * পাথরের সংখ্যা n দেওয়া আছে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি উভয়\n * আপনি এবং আপনার প্রতিপক্ষ সর্বোত্তমভাবে খেলে।\n * নোট: আপনি সর্বদা প্রথম পালা নেন।\n *\n * এখানে কিছু উদাহরণ রয়েছে:\n *   canWinNim(1) // true ফেরত দেয়\n */\nfunction canWinNim(n)",
      "bg": "/**\n * Играете игра, наречена Nim. В тази игра започвате с купчина\n * от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3\n * камъка от купчината. Този, който премахне последния камък, печели играта.\n * Като се даде броят на камъните n, определете дали можете да спечелите играта, ако и двамата\n * вие и вашият противник играете оптимално.\n * Забележка: Винаги вие правите първия ход.\n *\n * Ето някои случаи:\n *   canWinNim(1) // връща true\n */\nfunction canWinNim(n)",
      "zh": "/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。\n * 给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n * 注意：你总是先手。\n *\n * 这里有一些情况：\n *   canWinNim(1) // 返回 true\n */\nfunction canWinNim(n)",
      "fr": "/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas\n * de n pierres, et vous et votre adversaire prenez à tour de rôle 1 à 3\n * pierres du tas. Celui qui enlève la dernière pierre gagne la partie.\n * Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\n * Remarque : Vous jouez toujours le premier tour.\n *\n * Voici quelques cas :\n *   canWinNim(1) // renvoie true\n */\nfunction canWinNim(n)",
      "de": "/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen\n * von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3\n * Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel.\n * Angesichts der Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl\n * du als auch dein Gegner optimal spielen.\n * Hinweis: Du bist immer der Erste, der an der Reihe ist.\n *\n * Hier sind einige Fälle:\n *   canWinNim(1) // gibt true zurück\n */",
      "ha": "/**\n * Kana wasa da ake kira Nim. A cikin wannan wasa, ka fara da tarin\n * duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3\n * duwatsu daga tarin. Wanda ya cire dutse na karshe shi ne ya ci wasan.\n * An ba da yawan duwatsu n, ka tantance ko za ka iya cin nasara idan duka\n * kai da abokin hamayyarka kuna wasa da hikima.\n * Lura: Kai ne kullum ke fara wasa.\n *\n * Ga wasu lokuta:\n *   canWinNim(1) // ya dawo da true\n */",
      "hi": "/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं,\n * और आप और आपका प्रतिद्वंद्वी बारी-बारी से 1 से 3 पत्थर ढेर से हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है।\n * दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों\n * सर्वोत्तम तरीके से खेलते हैं।\n * नोट: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *   canWinNim(1) // true लौटाता है\n */\nfunction canWinNim(n)",
      "hu": "/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom\n * n kővel kezdesz, és te és az ellenfeled felváltva távolítotok el 1-3\n * követ a halomból. Az nyer, aki az utolsó követ eltávolítja.\n * Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha mindketten\n * optimálisan játszotok.\n * Megjegyzés: Mindig te kezded az első kört.\n *\n * Íme néhány eset:\n *   canWinNim(1) // visszaadja, hogy igaz\n */\nfunction canWinNim(n)"
    },
    "prompt_bertscore": {
      "sq": "0.98190060104972",
      "hy": "0.9508516930382515",
      "bn": "0.9882814034100847",
      "bg": "0.9849734130443297",
      "zh": "0.9385590546471453",
      "fr": "0.9837595827858254",
      "de": "0.9694349555967324",
      "ha": "0.953018551864961",
      "hi": "0.9832546643572347",
      "hu": "0.9706048885410279"
    },
    "canonical_solution": "{\n    return n % 4 !== 0;\n}",
    "instruction": {
      "en": "Write a JavaScript function `function canWinNim(n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true",
      "sq": "Shkruani një funksion JavaScript `function canWinNim(n)` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n  canWinNim(1) // kthen true",
      "hy": "Գրեք JavaScript ֆունկցիա `function canWinNim(n)`՝ հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե և դուք, և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք քայլում։\n\nԱհա մի քանի դեպքեր:\n  canWinNim(1) // վերադարձնում է true",
      "bn": "একটি JavaScript ফাংশন `function canWinNim(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩টি পাথর স্তূপ থেকে সরান। যে শেষ পাথরটি সরায় সে খেলাটি জেতে। প্রদত্ত n সংখ্যক পাথর, নির্ধারণ করুন আপনি খেলাটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলে। লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n  canWinNim(1) // true রিটার্ন করে",
      "bg": "Напишете JavaScript функция `function canWinNim(n)`, за да решите следния проблем:  \nИграете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. Забележка: Винаги вие вземате първия ход.\n\nЕто някои случаи:  \n  canWinNim(1) // връща true",
      "zh": "编写一个 JavaScript 函数 `function canWinNim(n)` 来解决以下问题：\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，确定如果你和你的对手都以最佳方式进行游戏，你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n  canWinNim(1) // 返回 true",
      "fr": "Écrivez une fonction JavaScript `function canWinNim(n)` pour résoudre le problème suivant :  \nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :  \n  canWinNim(1) // retourne true",
      "de": "Schreiben Sie eine JavaScript-Funktion `function canWinNim(n)`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen. Hinweis: Sie sind immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n  canWinNim(1) // gibt true zurück",
      "ha": "Rubuta wani aikin JavaScript `function canWinNim(n)` don warware matsalar mai zuwa:\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance idan za ka iya cin wasan idan kai da abokin hamayyarka kuna wasa da hikima. Lura: Kai ne koyaushe ke fara juyawa.\n\nGa wasu lokuta:\n  canWinNim(1) // returns true",
      "hi": "JavaScript फ़ंक्शन `function canWinNim(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक गेम खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही अनुकूल रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ उदाहरण हैं:\n  canWinNim(1) // true लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function canWinNim(n)` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszotok. Megjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n  canWinNim(1) // visszaadja true"
    },
    "instruction_bertscore": {
      "sq": "0.9972487705922858",
      "hy": "0.9863634284508118",
      "bn": "0.976189977594967",
      "bg": "0.9891627264107365",
      "zh": "0.9804287499262514",
      "fr": "0.9930701832664548",
      "de": "0.984873104701907",
      "ha": "0.9840944736082503",
      "hi": "0.9751118118867096",
      "hu": "0.9869068811733233"
    },
    "level": "easy",
    "test": "function testCanWinNim() {\n    console.assert(canWinNim(1) === true, \"Test case 1 failed\");\n    console.assert(canWinNim(2) === true, \"Test case 2 failed\");\n    console.assert(canWinNim(3) === true, \"Test case 3 failed\");\n    console.assert(canWinNim(4) === false, \"Test case 4 failed\");\n    console.assert(canWinNim(5) === true, \"Test case 5 failed\");\n    console.assert(canWinNim(6) === true, \"Test case 6 failed\");\n    console.assert(canWinNim(7) === true, \"Test case 7 failed\");\n    console.assert(canWinNim(8) === false, \"Test case 8 failed\");\n    console.assert(canWinNim(9) === true, \"Test case 9 failed\");\n    console.assert(canWinNim(10) === true, \"Test case 10 failed\");\n    console.assert(canWinNim(11) === true, \"Test case 11 failed\");\n    console.assert(canWinNim(12) === false, \"Test case 12 failed\");\n    console.assert(canWinNim(13) === true, \"Test case 13 failed\");\n    console.assert(canWinNim(14) === true, \"Test case 14 failed\");\n    console.assert(canWinNim(15) === true, \"Test case 15 failed\");\n    console.assert(canWinNim(16) === false, \"Test case 16 failed\");\n    console.assert(canWinNim(17) === true, \"Test case 17 failed\");\n    console.assert(canWinNim(18) === true, \"Test case 18 failed\");\n    console.assert(canWinNim(19) === true, \"Test case 19 failed\");\n    console.assert(canWinNim(20) === false, \"Test case 20 failed\");\n}\ntestCanWinNim();",
    "entry_point": "canWinNim",
    "signature": "function canWinNim(n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last stone wins the game. Given the number of stones n, determine if you can win the game if both you and your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n  canWinNim(1) // kthen true",
      "hy": "Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n  canWinNim(1) // վերադարձնում է true",
      "bn": "আপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি একটি n পাথরের স্তূপ দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে স্তূপ থেকে ১ থেকে ৩টি পাথর সরান। যে ব্যক্তি শেষ পাথরটি সরায় সে খেলায় জেতে। পাথরের সংখ্যা n দেওয়া আছে, যদি আপনি এবং আপনার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলেন, তবে আপনি কি খেলাটি জিততে পারবেন তা নির্ধারণ করুন। লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n  canWinNim(1) // true ফেরত দেয়",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като имате предвид броя на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. Забележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n  canWinNim(1) // връща true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n  canWinNim(1) // 返回 true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous jouez toujours le premier tour.\n\nVoici quelques cas :\n  canWinNim(1) // renvoie true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen. Hinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n  canWinNim(1) // gibt true zurück",
      "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe shi ne zai ci wasan. An ba da adadin duwatsu n, tantance ko za ka iya cin nasara a wasan idan kai da abokin hamayyarka kuna wasa da kyau. Lura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:\n  canWinNim(1) // yana dawowa da gaskiya",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही अनुकूल रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n  canWinNim(1) // true लौटाता है",
      "hu": "Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha te és az ellenfeled is optimálisan játszotok. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n  canWinNim(1) // visszaadja: true"
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9705325870823313",
      "bn": "0.9872415733653671",
      "bg": "0.9837558088085858",
      "zh": "0.964883340415318",
      "fr": "0.9842448368066937",
      "de": "0.9721422876902379",
      "ha": "0.984906871866683",
      "hi": "0.9868445112336783",
      "hu": "0.9625710841496908"
    }
  },
  {
    "task_id": "JavaScript/50",
    "prompt": {
      "en": "\n/**\n * Given two integers a and b, return the sum if the sum is even,\n * or return the product of a and b if the sum is odd.\n * Examples:\n *   evenSumOrOddProduct(2, 3) returns 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "sq": "/**\n * Duke pasur dy numra të plotë a dhe b, kthe shumën nëse shuma është çift,\n * ose kthe produktin e a dhe b nëse shuma është tek.\n * Shembuj:\n *   evenSumOrOddProduct(2, 3) kthen 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "hy": "/**\n * Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\n * կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *   evenSumOrOddProduct(2, 3) վերադարձնում է 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "bn": "/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি যদি জোড় হয় তবে যোগফল ফেরত দিন,\n * অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণ:\n *   evenSumOrOddProduct(2, 3) 6 ফেরত দেয়\n */\nfunction evenSumOrOddProduct(a, b)",
      "bg": "/**\n * Дадени са две цели числа a и b, върни сумата, ако сумата е четна,\n * или върни произведението на a и b, ако сумата е нечетна.\n * Примери:\n *   evenSumOrOddProduct(2, 3) връща 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "zh": "/**\n * 给定两个整数 a 和 b，如果它们的和是偶数，则返回和，\n * 如果和是奇数，则返回 a 和 b 的乘积。\n * 示例:\n *   evenSumOrOddProduct(2, 3) 返回 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "fr": "/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire,\n * ou retourner le produit de a et b si la somme est impaire.\n * Exemples :\n *   evenSumOrOddProduct(2, 3) retourne 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "de": "/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist,\n * oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n * Beispiele:\n *   evenSumOrOddProduct(2, 3) gibt 6 zurück\n */\nfunction evenSumOrOddProduct(a, b)",
      "ha": "/**\n * Idan aka ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar ta zama lamba mai lamba biyu,\n * ko kuma dawo da samfurin a da b idan jumlar ta zama lamba mai lamba daya.\n * Misalai:\n *   evenSumOrOddProduct(2, 3) returns 6\n */\nfunction evenSumOrOddProduct(a, b)",
      "hi": "/**\n * दिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं,\n * या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n * उदाहरण:\n *   evenSumOrOddProduct(2, 3) 6 लौटाता है\n */\nfunction evenSumOrOddProduct(a, b)",
      "hu": "/**\n * Két egész szám, a és b esetén térj vissza az összeggel, ha az összeg páros,\n * vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n * Példák:\n *   evenSumOrOddProduct(2, 3) visszaadja 6\n */\nfunction evenSumOrOddProduct(a, b)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9620192889511759",
      "bg": "1",
      "zh": "0.9559253088610256",
      "fr": "1",
      "de": "1",
      "ha": "0.9635729757916308",
      "hi": "0.9971597841815821",
      "hu": "0.9873031487834879"
    },
    "canonical_solution": "{\n    let sum = a + b;\n    if (sum % 2 === 0) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}",
    "instruction": {
      "en": "Write a JavaScript function `function evenSumOrOddProduct(a, b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even,\n or return the product of a and b if the sum is odd.\n Examples:\n   evenSumOrOddProduct(2, 3) returns 6\n",
      "sq": "Shkruani një funksion JavaScript `function evenSumOrOddProduct(a, b)` për të zgjidhur problemin në vijim:  \nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift,  \nose kthejeni produktin e a dhe b nëse shuma është tek.  \nShembuj:  \n  evenSumOrOddProduct(2, 3) kthen 6",
      "hy": "Գրեք JavaScript ֆունկցիա `function evenSumOrOddProduct(a, b)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\nկամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\n   evenSumOrOddProduct(2, 3) վերադարձնում է 6",
      "bn": "একটি জাভাস্ক্রিপ্ট ফাংশন `function evenSumOrOddProduct(a, b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি যদি জোড় হয় তবে যোগফল ফেরত দিন,\nঅথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণসমূহ:\n   evenSumOrOddProduct(2, 3) 6 ফেরত দেয়",
      "bg": "Напишете JavaScript функция `function evenSumOrOddProduct(a, b)` за решаване на следния проблем:  \nДадени са два цели числа a и b, върнете сумата, ако сумата е четна,  \nили върнете произведението на a и b, ако сумата е нечетна.  \nПримери:  \n  evenSumOrOddProduct(2, 3) връща 6  ",
      "zh": "编写一个 JavaScript 函数 `function evenSumOrOddProduct(a, b)` 来解决以下问题：  \n给定两个整数 a 和 b，如果它们的和是偶数则返回和，  \n如果和是奇数则返回 a 和 b 的乘积。  \n示例：  \n  evenSumOrOddProduct(2, 3) 返回 6  ",
      "fr": "Écrire une fonction JavaScript `function evenSumOrOddProduct(a, b)` pour résoudre le problème suivant :  \nÉtant donné deux entiers a et b, retourner la somme si la somme est paire,  \nou retourner le produit de a et b si la somme est impaire.  \nExemples :  \n  evenSumOrOddProduct(2, 3) retourne 6  ",
      "de": "Schreiben Sie eine JavaScript-Funktion `function evenSumOrOddProduct(a, b)`, um das folgende Problem zu lösen:  \nGegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist,  \noder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.  \nBeispiele:  \n   evenSumOrOddProduct(2, 3) gibt 6 zurück  ",
      "ha": "Rubuta aikin JavaScript `function evenSumOrOddProduct(a, b)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu a da b, dawo da jimlar idan jimlar tana da lamba maɗaukaki,\n ko dawo da samfurin a da b idan jimlar tana da lamba maras maɗaukaki.\n Misalai:\n   evenSumOrOddProduct(2, 3) returns 6",
      "hi": "`function evenSumOrOddProduct(a, b)` नामक एक JavaScript फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं। उदाहरण: evenSumOrOddProduct(2, 3) 6 लौटाता है",
      "hu": "Írj egy JavaScript függvényt `function evenSumOrOddProduct(a, b)` a következő probléma megoldására:  \nAdott két egész szám, a és b, add vissza az összegüket, ha az összeg páros,  \nvagy add vissza a szorzatukat, ha az összeg páratlan.  \nPéldák:  \n  evenSumOrOddProduct(2, 3) visszaadja 6"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "0.9843405766503526",
      "fr": "1",
      "de": "1",
      "ha": "0.9626153787246616",
      "hi": "0.992194223286091",
      "hu": "0.9664312669747228"
    },
    "level": "easy",
    "test": "const testEvenSumOrOddProduct = () => {\n    console.assert(evenSumOrOddProduct(2, 3) === 6, 'Test Case 1 Failed');\n    console.assert(evenSumOrOddProduct(5, 5) === 10, 'Test Case 2 Failed');\n    console.assert(evenSumOrOddProduct(1, 1) === 2, 'Test Case 3 Failed');\n    console.assert(evenSumOrOddProduct(0, 0) === 0, 'Test Case 4 Failed');\n    console.assert(evenSumOrOddProduct(-1, -1) === -2, 'Test Case 5 Failed');\n    console.assert(evenSumOrOddProduct(100, 200) === 300, 'Test Case 6 Failed');\n    console.assert(evenSumOrOddProduct(3, 4) === 12, 'Test Case 7 Failed');\n    console.assert(evenSumOrOddProduct(-5, 5) === 0, 'Test Case 8 Failed');\n    console.assert(evenSumOrOddProduct(7, 8) === 56, 'Test Case 9 Failed');\n    console.assert(evenSumOrOddProduct(9, 10) === 90, 'Test Case 10 Failed');\n    console.assert(evenSumOrOddProduct(11, 14) === 154, 'Test Case 11 Failed');\n}\n\ntestEvenSumOrOddProduct();",
    "entry_point": "evenSumOrOddProduct",
    "signature": "function evenSumOrOddProduct(a, b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even,\n or return the product of a and b if the sum is odd.\n Examples:\n   evenSumOrOddProduct(2, 3) returns 6\n",
      "sq": "Given dy numra të plotë a dhe b, kthe shumën nëse shuma është çift, ose kthe produktin e a dhe b nëse shuma është tek.\nShembuj:\n   evenSumOrOddProduct(2, 3) returns 6",
      "hy": "Տրված են երկու ամբողջ թվեր a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\n կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n Օրինակներ:\n   evenSumOrOddProduct(2, 3) վերադարձնում է 6",
      "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন। \nউদাহরণসমূহ:\n   evenSumOrOddProduct(2, 3) 6 ফেরত দেয়",
      "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\nПримери:\n   evenSumOrOddProduct(2, 3) връща 6",
      "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n示例：\n   evenSumOrOddProduct(2, 3) 返回 6",
      "fr": "Étant donné deux entiers a et b, renvoyer la somme si la somme est paire, ou renvoyer le produit de a et b si la somme est impaire.\nExemples:\n   evenSumOrOddProduct(2, 3) renvoie 6",
      "de": "Gegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist,\n oder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.\nBeispiele:\n   evenSumOrOddProduct(2, 3) gibt 6 zurück  ",
      "ha": "An ba da lambobi guda biyu a da b, dawo da jimlar idan jimlar tana da lamba maɗaukaki,\n ko dawo da samfurin a da b idan jimlar tana da lamba maras maɗaukaki.\nMisalai:\n   evenSumOrOddProduct(2, 3) returns 6",
      "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं। उदाहरण: evenSumOrOddProduct(2, 3) 6 लौटाता है",
      "hu": "Két egész szám, a és b esetén térjen vissza az összeggel, ha az összeg páros, vagy térjen vissza a és b szorzatával, ha az összeg páratlan.\nPéldák:\n   evenSumOrOddProduct(2, 3) visszatér 6"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "0.9375956972991261",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.9226944461138887",
      "hu": "0.9710655123946479"
    }
  }
]