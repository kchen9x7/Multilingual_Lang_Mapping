[
  {
    "task_id": "Rust/1",
    "prompt": {
      "en": " /*\n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n ",
      "sq": " /*\n  Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n  pragu i dhënë.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "hy": " /*\n  Ստուգել, արդյոք տրված թվերի ցուցակում կան երկու թիվ, որոնք միմյանց ավելի մոտ են,\n  քան տրված շեմը։\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "bn": " /*\n  প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি প্রদত্ত সীমার চেয়ে একে অপরের কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "bg": " /*\n  Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго\n  от даден праг.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{",
      "zh": " /*\n  检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "fr": " /*\n  Vérifiez si, dans une liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "de": " /*\n  Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der\n  angegebene Schwellenwert.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "ha": " /*\n  Duba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da ke kusa da juna fiye da\n  ƙayyadadden tazara.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "hi": " /*\n  जाँच करें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "hu": " /*\n  Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9851049063565748",
      "hy": "0.9775921094546922",
      "bn": "0.9825135744055936",
      "bg": "0.9690102838420799",
      "zh": "0.9632444411413991",
      "fr": "0.9744754001458737",
      "de": "0.9746843593067225",
      "ha": "0.9617467680683961",
      "hi": "0.9784331104879939",
      "hu": "0.962987810689102"
    },
    "canonical_solution": "\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\n  given threshold.",
      "sq": "Shkruani një funksion në Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` për të zgjidhur problemin e mëposhtëm:  \nKontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.",
      "hy": "Գրեք Rust ֆունկցիա `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` լուծելու համար հետևյալ խնդիրը:\nՍտուգեք, արդյոք տրված թվերի ցանկում կան երկու թվեր, որոնք միմյանց ավելի մոտ են, քան տրված շեմը։",
      "bn": "Rust ফাংশন `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করুন যে প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি পরস্পরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা।",
      "bg": "Напишете функция на Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` за решаване на следния проблем:\nПроверете дали в дадения списък от числа, има ли две числа, които са по-близо едно до друго от дадения праг.",
      "zh": "编写一个 Rust 函数 `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` 来解决以下问题：\n检查在给定的数字列表中，是否存在任意两个数字之间的距离小于给定的阈值。",
      "fr": "Écrire une fonction Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` pour résoudre le problème suivant :\nVérifiez si, dans la liste de nombres donnée, il y a deux nombres plus proches l'un de l'autre que le seuil donné.",
      "de": "Schreiben Sie eine Rust-Funktion `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{`, um das folgende Problem zu lösen:\nÜberprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.",
      "ha": "Rubuta aikin Rust `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` don warware matsalar mai zuwa:\nDuba idan a cikin jerin lambobin da aka bayar, akwai wasu lambobi guda biyu da suka fi kusa da juna fiye da\n  iyaka da aka bayar.",
      "hi": "Rust फ़ंक्शन `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के जितना करीब हैं उससे कम दूरी पर हैं\n  दिए गए सीमा से।",
      "hu": "Írj egy Rust függvényt `fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{` a következő probléma megoldására:\nEllenőrizd, hogy a megadott számok listájában van-e bármely két szám, amelyek közelebb vannak egymáshoz, mint a megadott küszöbérték."
    },
    "instruction_bertscore": {
      "sq": "0.9789713988205985",
      "hy": "0.9635989963715464",
      "bn": "0.9483108132040531",
      "bg": "0.9677034945652513",
      "zh": "0.934817454159591",
      "fr": "0.9757780181847006",
      "de": "0.9669691580465654",
      "ha": "0.974003652990916",
      "hi": "0.9487579301917627",
      "hu": "0.9667296098070373"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_has_close_elements() {\n  assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n  }\n \n }\n ",
    "entry_point": "has_close_elements",
    "signature": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se sa pragu i dhënë.",
      "hy": "Ստուգել, արդյոք տրված թվերի ցանկում կա՞ն երկու թվեր, որոնք միմյանց ավելի մոտ են, քան տրված շեմը:",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনও দুটি সংখ্যা কি প্রদত্ত সীমার চেয়ে একে অপরের কাছাকাছি আছে কিনা তা পরীক্ষা করুন।",
      "bg": "Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от дадения праг.",
      "zh": "检查给定数字列表中，是否有任意两个数字之间的距离小于给定的阈值。",
      "fr": "Vérifiez si, dans la liste donnée de nombres, deux nombres sont plus proches l'un de l'autre que le seuil donné.",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.",
      "ha": "Duba ko a cikin jerin lambobin da aka bayar, akwai wasu lambobi guda biyu da ke kusa da juna fiye da \n  ƙayyadadden tazara.",
      "hi": "दिए गए संख्याओं की सूची में जांचें कि क्या कोई दो संख्याएं दी गई सीमा से अधिक निकट हैं।",
      "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték."
    },
    "docstring_bertscore": {
      "sq": "0.9577258932651068",
      "hy": "0.8968498527159153",
      "bn": "0.8729466726621768",
      "bg": "0.8968498527159153",
      "zh": "0.8364651771962027",
      "fr": "0.9286404465701681",
      "de": "0.8954505016815245",
      "ha": "0.8918517164379345",
      "hi": "0.8312543543133348",
      "hu": "0.8951440150035876"
    }
  },
  {
    "task_id": "Rust/2",
    "prompt": {
      "en": " /*\n  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n ",
      "sq": " /*\n  Hyrja për këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të\n  ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n  Grupet e veçanta janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n  Injoroni çdo hapësirë në vargun e hyrjes.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "hy": " /*\n  Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի բազմակի խմբեր: Ձեր նպատակը\n  այդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցուցակը:\n  Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ չեն ներդրված:\n  Անտեսեք մուտքային տողի ցանկացած բացատ:\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "bn": " /*\n  এই ফাংশনের ইনপুট একটি স্ট্রিং যা একাধিক গোষ্ঠীর নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল \n  সেই গোষ্ঠীগুলিকে পৃথক স্ট্রিংয়ে বিভক্ত করা এবং সেইগুলির তালিকা ফেরত দেওয়া।\n  পৃথক গোষ্ঠীগুলি ভারসাম্যপূর্ণ (প্রত্যেকটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়।\n  ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "bg": " /*\n  Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\n  разделите тези групи на отделни низове и да върнете списък с тях.\n  Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n  Игнорирайте всички интервали в входния низ.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "zh": " /*\n  此函数的输入是一个包含多个嵌套括号组的字符串。您的目标是将这些组分离成独立的字符串，并返回这些字符串的列表。\n  独立的组是平衡的（每个开括号都有正确的闭合）并且不相互嵌套。\n  忽略输入字符串中的任何空格。\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "fr": " /*\n  L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n  séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n  Les groupes séparés sont équilibrés (chaque accolade ouverte est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n  Ignorez tous les espaces dans la chaîne d'entrée.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "de": " /*\n  Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n  diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n  Separate Gruppen sind ausgeglichen (jede öffnende Klammer ist korrekt geschlossen) und nicht ineinander verschachtelt.\n  Ignorieren Sie alle Leerzeichen im Eingabestring.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "ha": " /*\n  Shigarwa zuwa wannan aikin wata kirtani ce da ke dauke da rukuni da dama na baka-baka masu zurfi. Manufarka ita ce\n  raba wadannan rukuni zuwa kirtani daban-daban kuma mayar da jerin su.\n  Rukuni daban-daban suna daidaituwa (kowace bude baka an rufe ta yadda ya kamata) kuma ba a cikin juna suke ba\n  Yi watsi da duk wani sarari a cikin kirtanin shigarwa.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{",
      "hi": " /*\n  इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n  उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उन स्ट्रिंग्स की सूची लौटाएं।\n  अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n  इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "hu": " /*\n  Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A cél az,\n  hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját.\n  A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n  Figyelmen kívül kell hagyni a bemeneti karakterláncban található szóközöket.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n"
    },
    "prompt_bertscore": {
      "sq": "0.959833162977506",
      "hy": "0.9557995758298304",
      "bn": "0.9554698493973126",
      "bg": "0.9514855225841338",
      "zh": "0.9444450687283521",
      "fr": "0.9649526624182991",
      "de": "0.9550872872834394",
      "ha": "0.9556476235883388",
      "hi": "0.9497202943878766",
      "hu": "0.9461109817340917"
    },
    "canonical_solution": "\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn separate_paren_groups(paren_string: String) -> Vec<String>{` to solve the following problem:\nInput to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.",
      "sq": "Shkruani një funksion Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` për të zgjidhur problemin e mëposhtëm:\nInput-i për këtë funksion është një varg që përmban disa grupe të kllapave të folezuara. Qëllimi juaj është të\n  ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n  Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n  Injoroni çdo hapësirë në vargun e input-it.",
      "hy": "Rust ֆունկցիա գրեք `fn separate_paren_groups(paren_string: String) -> Vec<String>{` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի բազմաթիվ խմբեր։ Ձեր նպատակը\nայդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցանկը։\nԱռանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ ներդրված չեն։\nԱնտեսեք մուտքագրված տողի ցանկացած բացատ։",
      "bn": "Rust ফাংশন `fn separate_paren_groups(paren_string: String) -> Vec<String>{` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনের ইনপুট একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল\n  সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং সেই তালিকাটি ফেরত দেওয়া।\n  আলাদা গ্রুপগুলো ভারসাম্যপূর্ণ (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়\n  ইনপুট স্ট্রিংয়ের যেকোনো ফাঁকা স্থান উপেক্ষা করুন।",
      "bg": "Напишете функция на Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{`, за да решите следния проблем:\nВходът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\n  разделите тези групи на отделни низове и да върнете списък с тях.\n  Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n  Игнорирайте всички интервали в входния низ.",
      "zh": "编写一个 Rust 函数 `fn separate_paren_groups(paren_string: String) -> Vec<String>{` 来解决以下问题：\n此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是\n将这些组分离成独立的字符串并返回这些字符串的列表。\n分离的组是平衡的（每个开括号都有正确的闭合）且不相互嵌套。\n忽略输入字符串中的任何空格。",
      "fr": "Écrire une fonction Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` pour résoudre le problème suivant :\nL'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n  séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n  Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n  Ignorez tous les espaces dans la chaîne d'entrée.",
      "de": "Schreiben Sie eine Rust-Funktion `fn separate_paren_groups(paren_string: String) -> Vec<String>{`, um das folgende Problem zu lösen:\nDer Eingang zu dieser Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n  diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n  Separate Gruppen sind ausgeglichen (jede öffnende Klammer ist ordnungsgemäß geschlossen) und nicht ineinander verschachtelt.\n  Ignorieren Sie alle Leerzeichen im Eingabestring.",
      "ha": "Rubuta aikin Rust `fn separate_paren_groups(paren_string: String) -> Vec<String>{` don warware matsalar mai zuwa:\nShigar da wannan aikin shine wani igiyar rubutu mai dauke da kungiyoyi da dama na baka-baka da aka sanya a juna. Manufarka ita ce\n  raba wadannan kungiyoyi zuwa igiyoyi daban-daban kuma dawo da jerin wadannan.\n  Kungiyoyi daban-daban suna daidaitacce (kowace baka-baka a bude tana da rufewa daidai) kuma ba a sanya su a juna ba\n  Yi watsi da duk wani sarari a cikin igiyar shigar.",
      "hi": "Rust फ़ंक्शन `fn separate_paren_groups(paren_string: String) -> Vec<String>{` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n  उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उन स्ट्रिंग्स की सूची लौटाएं।\n  अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n  इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।",
      "hu": "Írj egy Rust függvényt `fn separate_paren_groups(paren_string: String) -> Vec<String>{` a következő probléma megoldására:\nEnnek a függvénynek a bemenete egy olyan string, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A célod az,\n  hogy ezeket a csoportokat külön stringekre bontsd, és visszaadd ezek listáját.\n  A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően van lezárva), és nincsenek egymásba ágyazva.\n  Hagyd figyelmen kívül a bemeneti stringben található szóközöket."
    },
    "instruction_bertscore": {
      "sq": "0.9371213679492147",
      "hy": "0.9232529947453588",
      "bn": "0.9248716337204121",
      "bg": "0.9351771737796453",
      "zh": "0.9096625054445708",
      "fr": "0.9449605145671377",
      "de": "0.9435482525579796",
      "ha": "0.9125601254431077",
      "hi": "0.912482063703361",
      "hu": "0.9360682296689677"
    },
    "level": "middle",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_separate_paren_groups() {\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()()) ((())) () ((())()())\")),\n  vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"() (()) ((())) (((())))\")),\n  vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()(())((())))\")),\n  vec![\"(()(())((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n  vec![\"()\", \"(())\", \"(()())\"]\n  );\n  }\n \n }\n ",
    "entry_point": "separate_paren_groups",
    "signature": "fn separate_paren_groups(paren_string: String) -> Vec<String>{",
    "docstring": {
      "en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.",
      "sq": "Inputi për këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre. Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës. Injoroni çdo hapësirë në vargun e hyrjes.",
      "hy": "Մուտք այս ֆունկցիայի համար տող է, որը պարունակում է փակագծերի բազմակի խմբեր։ Ձեր նպատակը\nայդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել այդ տողերի ցուցակը։\nԱռանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և մեկը մյուսի մեջ ներդրված չեն։\nԱնտեսեք մուտքագրված տողի ցանկացած բացատ։",
      "bn": "এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গোষ্ঠী নেস্টেড বন্ধনীগুলি ধারণ করে। আপনার লক্ষ্য হল সেই গোষ্ঠীগুলিকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং সেগুলির তালিকা ফেরত দেওয়া। পৃথক গোষ্ঠীগুলি সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়। ইনপুট স্ট্রিংয়ের যেকোনো ফাঁকা স্থান উপেক্ষা করুন।",
      "bg": "Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\nразделите тези групи на отделни низове и да върнете списък с тях.\nОтделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\nИгнорирайте всички интервали в входния низ.",
      "zh": "输入此函数的是一个包含多个嵌套括号组的字符串。您的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。  \n分离的组是平衡的（每个开括号都有正确的闭合）且不相互嵌套。  \n忽略输入字符串中的任何空格。",
      "fr": "L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de renvoyer la liste de celles-ci. Les groupes séparés sont équilibrés (chaque accolade ouverte est correctement fermée) et ne sont pas imbriqués les uns dans les autres. Ignorez tous les espaces dans la chaîne d'entrée.",
      "de": "Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben. Separate Gruppen sind ausgeglichen (jede öffnende Klammer ist ordnungsgemäß geschlossen) und nicht ineinander verschachtelt. Ignorieren Sie alle Leerzeichen im Eingabestring.",
      "ha": "Shigarwa zuwa wannan aikin shine wani igiyar rubutu wanda ke dauke da kungiyoyi da dama na kowane irin kunkuntar baka. Manufarka ita ce raba wadannan kungiyoyi zuwa igiyoyi daban-daban kuma dawo da jerin wadannan. Kungiyoyi daban-daban suna daidaituwa (kowace bude baka tana da rufewa daidai) kuma ba a cikin juna suke ba. Yi watsi da duk wani sarari a cikin igiyar rubutu na shigarwa.",
      "hi": "इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उन स्ट्रिंग्स की सूची लौटाना है।  \nअलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही तरीके से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।  \nइनपुट स्ट्रिंग में किसी भी स्पेस को नज़रअंदाज़ करें।",
      "hu": "A függvény bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekkel. A cél az, hogy ezeket a csoportokat külön karakterláncokká válasszuk szét, és visszaadjuk ezek listáját. A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva. Figyelmen kívül kell hagyni az input karakterláncban található szóközöket."
    },
    "docstring_bertscore": {
      "sq": "0.907101762572269",
      "hy": "0.9031549769011058",
      "bn": "0.8932431222570838",
      "bg": "0.9070405844149103",
      "zh": "0.8961077696123689",
      "fr": "0.9370387377107042",
      "de": "0.9277468084858922",
      "ha": "0.8548206572408381",
      "hi": "0.8914866337975923",
      "hu": "0.8783033367779257"
    }
  },
  {
    "task_id": "Rust/3",
    "prompt": {
      "en": " /*\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n ",
      "sq": " /*\n  Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n  një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n  (pjesa e mbetur gjithmonë më e vogël se 1).\n \n  Kthe pjesën dhjetore të numrit.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "hy": " /*\n  Տրված դրական իրական թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվը) և տասնորդական մասի (մնացորդային մասը, որը միշտ փոքր է 1-ից):\n \n  Վերադարձնել թվի տասնորդական մասը:\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "bn": " /*\n  একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্টাংশ যা সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\n  সংখ্যার দশমিক অংশ ফেরত দিন।\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "bg": " /*\n  Дадено е положително число с плаваща запетая, което може да бъде разложено на\n  цяла част (най-голямото цяло число, по-малко от даденото число) и десетична част\n  (остатъчната част, която винаги е по-малка от 1).\n \n  Връща десетичната част на числото.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "zh": " /*\n  给定一个正浮点数，它可以分解为整数部分（小于给定数的最大整数）和小数部分（剩余部分总是小于1）。\n \n  返回该数的小数部分。\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "fr": " /*\n  Étant donné un nombre à virgule flottante positif, il peut être décomposé en\n  une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n  (partie restante toujours inférieure à 1).\n \n  Retourne la partie décimale du nombre.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "de": " /*\n  Gegeben eine positive Gleitkommazahl, kann sie in einen\n  ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen\n  (übrig gebliebener Teil, der immer kleiner als 1 ist) zerlegt werden.\n \n  Gib den Dezimalteil der Zahl zurück.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "ha": " /*\n  Idan aka ba da lamba mai kyau mai iyo, za a iya raba ta zuwa\n  wani ɓangare na cikakken lamba (mafi girman cikakken lamba ƙasa da lambar da aka bayar) da kuma na ɗigo\n  (ɓangaren da ya rage koyaushe ƙasa da 1).\n \n  Mayar da ɓangaren ɗigo na lambar.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "hi": " /*\n  दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को इसके घटकों में विभाजित किया जा सकता है:\n  एक पूर्णांक भाग (दिया गया संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव\n  (शेष भाग जो हमेशा 1 से छोटा होता है)।\n \n  संख्या के दशमलव भाग को लौटाएं।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "hu": " /*\n  Adott egy pozitív lebegőpontos szám, amely felbontható egy egész részre\n  (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n  (mindig 1-nél kisebb maradék rész).\n \n  Adja vissza a szám tizedes részét.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9632529822477837",
      "hy": "0.9395299599496438",
      "bn": "0.9475804492929878",
      "bg": "0.9404754405633698",
      "zh": "0.941819572351833",
      "fr": "0.9700630248615647",
      "de": "0.9449070829946393",
      "ha": "0.9287953782673753",
      "hi": "0.9310943262974731",
      "hu": "0.955136746248317"
    },
    "canonical_solution": "\n  return number % 1.0;\n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn truncate_number(number: &f32) -> f32{` to solve the following problem:\nGiven a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.",
      "sq": "Shkruani një funksion Rust `fn truncate_number(number: &f32) -> f32{` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër pozitiv me presje lëvizëse, ai mund të dekompozohet në\n  një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n  (pjesa e mbetur gjithmonë më e vogël se 1).\n \n  Kthe pjesën dhjetore të numrit.",
      "hy": "Գրեք Rust ֆունկցիա `fn truncate_number(number: &f32) -> f32{` հետևյալ խնդիրը լուծելու համար:\nՏրված է դրական լողացող կետով թիվ, այն կարող է բաժանվել\n  ամբողջ թվային մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի\n  (մնացորդային մաս, որը միշտ փոքր է 1-ից):\n \n  Վերադարձնել թվի տասնորդական մասը։",
      "bn": "Rust ফাংশন `fn truncate_number(number: &f32) -> f32{` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশ (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (বাকি অংশ সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\nসংখ্যার দশমিক অংশটি ফেরত দিন।",
      "bg": "Напишете функция на Rust `fn truncate_number(number: &f32) -> f32{` за решаване на следния проблем:\nДадено е положително число с плаваща запетая, което може да бъде разложено на\n  цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n  (остатъчната част, която винаги е по-малка от 1).\n\n  Върнете десетичната част на числото.",
      "zh": "编写一个 Rust 函数 `fn truncate_number(number: &f32) -> f32{` 来解决以下问题：  \n给定一个正浮点数，它可以分解为整数部分（小于给定数字的最大整数）和小数部分（始终小于1的剩余部分）。\n\n返回数字的小数部分。",
      "fr": "Écrire une fonction Rust `fn truncate_number(number: &f32) -> f32{` pour résoudre le problème suivant :\nÉtant donné un nombre à virgule flottante positif, il peut être décomposé en\n  une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n  (partie restante toujours inférieure à 1).\n \n  Retourner la partie décimale du nombre.",
      "de": "Schreiben Sie eine Rust-Funktion `fn truncate_number(number: &f32) -> f32{`, um das folgende Problem zu lösen:\nGegeben ist eine positive Gleitkommazahl, die in einen ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen (Restteil, der immer kleiner als 1 ist) zerlegt werden kann.\n\nGeben Sie den Dezimalteil der Zahl zurück.",
      "ha": "Rubuta aikin Rust `fn truncate_number(number: &f32) -> f32{` don warware matsalar mai zuwa:\nAn ba da lamba mai iyo mai kyau, za a iya raba ta zuwa\n  ɓangaren cikakken lamba (babban cikakken lamba ƙanana fiye da lambar da aka bayar) da kuma decimals\n  (ɓangaren da ya rage koyaushe ƙanana fiye da 1).\n\n  Mayar da ɓangaren decimal na lambar.",
      "hi": "Rust फ़ंक्शन `fn truncate_number(number: &f32) -> f32{` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए धनात्मक फ्लोटिंग पॉइंट संख्या को \n  एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव में विभाजित किया जा सकता है\n  (हमेशा 1 से छोटा बचा हुआ भाग)।\n\n  संख्या के दशमलव भाग को लौटाएं।",
      "hu": "Írj egy Rust függvényt `fn truncate_number(number: &f32) -> f32{` a következő probléma megoldására:\nAdott egy pozitív lebegőpontos szám, amely felbontható egy egész részre (a megadott számnál kisebb legnagyobb egész) és tizedesjegyekre (mindig 1-nél kisebb maradék rész).\n\nVissza kell adni a szám tizedes részét."
    },
    "instruction_bertscore": {
      "sq": "0.9428717174801747",
      "hy": "0.9129559957925103",
      "bn": "0.901778468360534",
      "bg": "0.9198464837106105",
      "zh": "0.9242060233135643",
      "fr": "0.9678230700546343",
      "de": "0.9234621525365886",
      "ha": "0.9477395522281967",
      "hi": "0.8912691335303591",
      "hu": "0.9134541607881458"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_truncate_number() {\n  assert_eq!(truncate_number(&3.5), 0.5);\n  let t1: f32 = 1.33 - 0.33;\n  assert!(truncate_number(&t1) < 0.000001);\n  let t2: f32 = 123.456 - 0.456;\n  assert!(truncate_number(&t2) < 0.000001);\n  }\n \n }\n ",
    "entry_point": "truncate_number",
    "signature": "fn truncate_number(number: &f32) -> f32{",
    "docstring": {
      "en": "Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.",
      "sq": "Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n  një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n  (pjesa e mbetur gjithmonë më e vogël se 1).\n \n  Kthe pjesën dhjetore të numrit.",
      "hy": "Տրված դրական տասնորդական թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի (մնացորդային մասը, որը միշտ փոքր է 1-ից):\n\nՎերադարձնել թվի տասնորդական մասը։",
      "bn": "একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্টাংশ যা সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\n  সংখ্যার দশমিক অংশটি ফেরত দিন।",
      "bg": "Дадено е положително число с плаваща запетая, което може да бъде разложено на\n  цяла част (най-голямото цяло число, по-малко от даденото число) и десетични части\n  (оставащата част, която винаги е по-малка от 1).\n \n  Връща десетичната част на числото.",
      "zh": "给定一个正浮点数，它可以被分解为整数部分（小于给定数字的最大整数）和小数部分（剩余部分总是小于1）。\n\n返回数字的小数部分。",
      "fr": "Étant donné un nombre flottant positif, il peut être décomposé en une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales (la partie restante toujours inférieure à 1).\n\nRetourne la partie décimale du nombre.",
      "de": "Gegeben eine positive Gleitkommazahl, kann sie in einen\n  ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen\n  (übrig gebliebener Teil, der immer kleiner als 1 ist) zerlegt werden.\n \n  Gib den Dezimalteil der Zahl zurück.",
      "ha": "An ba da lamba mai kyau mai iyo, za a iya rarraba ta zuwa\n  ɓangaren lamba mai cikakken adadi (mafi girman lamba mai ƙasa da lambar da aka bayar) da kuma kaso\n  (ɓangaren da ya rage koyaushe ƙasa da 1).\n\n  Mayar da ɓangaren kaso na lambar.",
      "hi": "Rust फ़ंक्शन `fn truncate_number(number: &f32) -> f32{` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए धनात्मक फ्लोटिंग पॉइंट संख्या को \n  एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव में विभाजित किया जा सकता है\n  (हमेशा 1 से छोटा बचा हुआ भाग)।\n\n  संख्या के दशमलव भाग को लौटाएं।",
      "hu": "Egy pozitív lebegőpontos szám esetén az felbontható egy egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre (a maradék rész mindig kisebb, mint 1).\n\n  Visszaadja a szám tizedes részét."
    },
    "docstring_bertscore": {
      "sq": "0.890272406278326",
      "hy": "0.8300246336243479",
      "bn": "0.9502899663206847",
      "bg": "0.8764385947607702",
      "zh": "0.8868702651119604",
      "fr": "0.9467569277332172",
      "de": "0.892583272131286",
      "ha": "0.850287911945622",
      "hi": "0.9094604983470583",
      "hu": "0.8983656011535925"
    }
  },
  {
    "task_id": "Rust/4",
    "prompt": {
      "en": " /*\n  You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n ",
      "sq": " /*\n  Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me\n  bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n  në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "hy": " /*\n  Ձեզ տրված է բանկային հաշվի վրա ավանդների և ելքերի գործողությունների ցուցակ, որը սկսվում է\n  զրոյական մնացորդով։ Ձեր խնդիրն է հայտնաբերել՝ արդյոք որևէ պահին հաշվի մնացորդը ընկնում է զրոյից ցածր, և\n  այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "bn": " /*\n  আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময় ফাংশনটি True রিটার্ন করা উচিত। অন্যথায় এটি False রিটার্ন করা উচিত।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "bg": " /*\n  Получавате списък с операции за депозити и тегления на банкова сметка, която започва с\n  нулев баланс. Вашата задача е да откриете дали в даден момент балансът на сметката пада под нула, и\n  в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "zh": " /*\n  你有一个关于银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，\n  如果是这样，函数应该返回True。否则，它应该返回False。\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "fr": " /*\n  Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n  un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n  à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "de": " /*\n  Sie haben eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit\n  einem Kontostand von null beginnt. Ihre Aufgabe ist es zu erkennen, ob zu irgendeinem Zeitpunkt der Kontostand unter null fällt, und\n  in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "ha": " /*\n  An ba ku jerin ajiya da cire kudi a kan asusun banki wanda ke farawa da\n  sifili a matsayin ma'auni. Aikin ku shi ne gano ko a kowane lokaci ma'aunin asusun ya faɗi ƙasa da sifili, kuma\n  a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "hi": " /*\n  आपके पास जमा और निकासी संचालन की एक सूची है जो एक बैंक खाते पर की जाती है, जिसकी शुरुआत\n  शून्य शेष राशि से होती है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है,\n  और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "hu": " /*\n  Adott egy lista, amely banki számlán végzett befizetési és kifizetési műveleteket tartalmaz, és a számla kezdeti egyenlege nulla. A feladat az, hogy észleljük, ha bármelyik ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False-t kell visszaadnia.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{"
    },
    "prompt_bertscore": {
      "sq": "0.983609418217763",
      "hy": "0.980499859602662",
      "bn": "0.9771060609122998",
      "bg": "0.9793434335242768",
      "zh": "0.9757879441203761",
      "fr": "0.9752077503607494",
      "de": "0.9726410485770166",
      "ha": "0.9718874449113702",
      "hi": "0.971448074508521",
      "hu": "0.9564663780189646"
    },
    "canonical_solution": "\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n ",
    "instruction": {
      "en": "Write a Rust function `fn below_zero(operations:Vec<i32>) -> bool{` to solve the following problem:\nYou're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.",
      "sq": "Shkruani një funksion Rust `fn below_zero(operations:Vec<i32>) -> bool{` për të zgjidhur problemin e mëposhtëm:  \nJu jepet një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë moment funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.",
      "hy": "Գրեք Rust ֆունկցիա `fn below_zero(operations:Vec<i32>) -> bool{` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է բանկային հաշվի մուտքերի և ելքերի գործողությունների ցանկ, որը սկսվում է զրոյական մնացորդով: Ձեր խնդիրն է հայտնաբերել, արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False:",
      "bn": "একটি Rust ফাংশন `fn below_zero(operations:Vec<i32>) -> bool{` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই মুহূর্তে ফাংশনটি True রিটার্ন করা উচিত। অন্যথায় এটি False রিটার্ন করা উচিত।",
      "bg": "Напишете функция на Rust `fn below_zero(operations:Vec<i32>) -> bool{` за решаване на следния проблем:  \nДаден ви е списък от операции за депозити и тегления от банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.",
      "zh": "编写一个 Rust 函数 `fn below_zero(operations:Vec<i32>) -> bool{` 来解决以下问题：  \n你有一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并且在那时函数应该返回 True。否则，它应该返回 False。",
      "fr": "Écrire une fonction Rust `fn below_zero(operations:Vec<i32>) -> bool{` pour résoudre le problème suivant :  \nOn vous donne une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde de zéro. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.",
      "de": "Schreiben Sie eine Rust-Funktion `fn below_zero(operations:Vec<i32>) -> bool{`, um das folgende Problem zu lösen:\nSie haben eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Ihre Aufgabe ist es festzustellen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.",
      "ha": "Rubuta aikin Rust `fn below_zero(operations:Vec<i32>) -> bool{` don warware matsalar mai zuwa:\nAn ba ku jerin ayyukan ajiya da cire kudi akan asusun banki wanda ya fara da\n  sifili a matsayin ma'auni. Ayyukanku shine gano ko a kowane lokaci ma'aunin asusun ya faɗi ƙasa da sifili, kuma\n  a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.",
      "hi": "Rust फ़ंक्शन `fn below_zero(operations:Vec<i32>) -> bool{` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको जमा और निकासी ऑपरेशनों की एक सूची दी गई है जो एक बैंक खाते पर की जाती हैं जो शून्य शेष राशि से शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।",
      "hu": "Írj egy Rust függvényt `fn below_zero(operations:Vec<i32>) -> bool{` a következő probléma megoldására:\nAdott egy lista befizetési és kifizetési műveletekről egy bankszámlán, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármelyik ponton a számla egyenlege nulla alá esik, és ebben az esetben a függvénynek True-t kell visszaadnia. Ellenkező esetben False-t kell visszaadnia."
    },
    "instruction_bertscore": {
      "sq": "0.9661279583828826",
      "hy": "0.9626068376182771",
      "bn": "0.9532741891653529",
      "bg": "0.9587186479095192",
      "zh": "0.9505410351223128",
      "fr": "0.9652142586301221",
      "de": "0.9451053161149121",
      "ha": "0.9635556949484808",
      "hi": "0.9339901586225808",
      "hu": "0.9401929881615383"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_below_zero() {\n  assert_eq!(below_zero(vec![]), false);\n  assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);\n  assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n  assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n  }\n \n }\n ",
    "entry_point": "below_zero",
    "signature": "fn below_zero(operations:Vec<i32>) -> bool{",
    "docstring": {
      "en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.",
      "sq": "Ju jepet një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me një bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.",
      "hy": "Ձեզ տրված է բանկային հաշվի վրա ավանդների և հանման գործողությունների ցուցակ, որը սկսվում է զրոյական մնացորդով։ Ձեր խնդիրն է հայտնաբերել, արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։",
      "bn": "তোমাকে একটি ব্যাংক অ্যাকাউন্টে জমা এবং উত্তোলনের অপারেশনগুলির একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। তোমার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময়ে ফাংশনটি True রিটার্ন করা উচিত। অন্যথায় এটি False রিটার্ন করা উচিত।",
      "bg": "Получавате списък с операции за депозити и тегления по банкова сметка, която започва с нулев баланс. Вашата задача е да установите дали в някакъв момент балансът на сметката пада под нула, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.",
      "zh": "您有一个银行账户的存款和取款操作列表，该账户以零余额开始。您的任务是检测账户余额是否在任何时候低于零，并且在这种情况下函数应返回True。否则，它应返回False。",
      "fr": "Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.",
      "de": "Du hast eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Deine Aufgabe ist es, zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.",
      "ha": "Ana ba ku jerin ajiya da ayyukan cire kudi akan asusun banki wanda ke farawa da\n  sifili ma'auni. Ayyukanku shine gano idan a kowane lokaci ma'aunin asusun ya faɗi ƙasa da sifili, kuma\n  a wannan lokacin aikin yakamata ya dawo da True. In ba haka ba yakamata ya dawo da False.",
      "hi": "आपको एक बैंक खाते पर जमा और निकासी संचालन की एक सूची दी गई है जो शून्य शेष राशि के साथ शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।",
      "hu": "Egy bankszámlán végrehajtott befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármikor az egyenleg nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False értéket kell visszaadnia."
    },
    "docstring_bertscore": {
      "sq": "0.953650196476652",
      "hy": "0.9290818032768277",
      "bn": "0.9454493439348646",
      "bg": "0.9521102151324885",
      "zh": "0.9057894116447714",
      "fr": "0.933673144534449",
      "de": "0.8959691256064066",
      "ha": "0.9415561884665807",
      "hi": "0.9469088799747089",
      "hu": "0.8921810456096902"
    }
  },
  {
    "task_id": "Rust/5",
    "prompt": {
      "en": " /*\n  For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n ",
      "sq": " /*\n  Për një listë të dhënë të numrave të hyrjes, llogaritni Devijimin Absolut Mesatar\n  rreth mesatares së këtij dataset-i.\n  Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit\n  element dhe një pikë qendrore (mesatarja në këtë rast):\n  DAM = mesatarja | x - x_mesatarja |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "hy": " /*\n  Տրված թվերի ցուցակի համար հաշվարկեք միջին բացարձակ շեղումը\n  այս տվյալների հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև միջին բացարձակ տարբերությունն է.\n  MAD = միջին | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "bn": " /*\n  প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি হিসাব করুন।\n  গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n  MAD = গড় | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "bg": " /*\n  За даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n  около средната стойност на този набор от данни.\n  Средно Абсолютно Отклонение е средната абсолютна разлика между всеки\n  елемент и централната точка (в този случай средната стойност):\n  MAD = средно | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "zh": " /*\n  对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n  平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：\n  MAD = average | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n ",
      "fr": " /*\n  Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne\n  autour de la moyenne de cet ensemble de données.\n  La Déviation Absolue Moyenne est la différence absolue moyenne entre chaque\n  élément et un point central (la moyenne dans ce cas) :\n  MAD = moyenne | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "de": " /*\n  Für eine gegebene Liste von Eingabezahlen berechne die mittlere absolute Abweichung\n  um den Mittelwert dieses Datensatzes.\n  Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n  Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n  MAD = Durchschnitt | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "ha": " /*\n  Don wani jerin lambobin shigarwa, lissafa Matsakaicin Bambancin Dangi\n  a kusa da matsakaicin wannan bayanan.\n  Matsakaicin Bambancin Dangi shine matsakaicin bambancin dangi tsakanin kowane\n  abu da wani tsakiya (matsakaici a wannan yanayin):\n  MAD = matsakaici | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "hi": " /*\n  दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटासेट के औसत के चारों ओर औसत निरपेक्ष विचलन की गणना करें।\n  औसत निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:\n  MAD = औसत | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "hu": " /*\n  Egy adott számokból álló lista esetén számítsa ki az átlagos abszolút eltérést\n  ennek az adathalmaznak az átlaga körül.\n  Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag)\n  közötti átlagos abszolút különbség:\n  MAD = átlag | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9802926881152425",
      "hy": "0.9517671804644412",
      "bn": "0.970611244713221",
      "bg": "0.9631010300062919",
      "zh": "0.981992958593525",
      "fr": "0.9719065134279495",
      "de": "0.9745496879083808",
      "ha": "0.9652972861293947",
      "hi": "0.970611244713221",
      "hu": "0.9663190408094382"
    },
    "canonical_solution": "\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n ",
    "instruction": {
      "en": "Write a Rust function `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` to solve the following problem:\nFor a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |",
      "sq": "Shkruani një funksion në Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` për të zgjidhur problemin e mëposhtëm:\nPër një listë të dhënë të numrave të hyrjes, llogaritni Devijimin Absolut Mesatar\nrreth mesatares së këtij grupi të dhënash.\nDevijimi Absolut Mesatar është mesatarja e diferencës absolute midis çdo\nelementi dhe një pikë qendrore (mesatarja në këtë rast):\nMAD = mesatarja | x - x_mean |",
      "hy": "Գրեք Rust ֆունկցիա `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` հետևյալ խնդիրը լուծելու համար:\nՏրված թվերի ցուցակի համար հաշվարկել Միջին բացարձակ շեղումը\n  այս տվյալների հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը յուրաքանչյուր\n  տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև միջին բացարձակ տարբերությունն է:\n  MAD = միջին | x - x_mean |",
      "bn": "Rust ফাংশন `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন।\nগড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\nMAD = average | x - x_mean |",
      "bg": "Напишете функция на Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` за решаване на следния проблем:\nЗа даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n  около средната стойност на този набор от данни.\n  Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n  елемент и централната точка (в този случай средната стойност):\n  MAD = средно | x - x_mean |",
      "zh": "编写一个 Rust 函数 `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` 来解决以下问题：\n对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n平均绝对偏差是每个元素与中心点（在本例中为平均值）之间的平均绝对差：\nMAD = average | x - x_mean |",
      "fr": "Écrire une fonction Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` pour résoudre le problème suivant :  \nPour une liste donnée de nombres en entrée, calculer la Déviation Absolue Moyenne autour de la moyenne de cet ensemble de données.  \nLa Déviation Absolue Moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :  \nMAD = moyenne | x - x_mean |",
      "de": "Schreiben Sie eine Rust-Funktion `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{`, um das folgende Problem zu lösen:\nFür eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung\n  um den Mittelwert dieses Datensatzes.\n  Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n  Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n  MAD = Durchschnitt | x - x_mean |",
      "ha": "Rubuta aikin Rust `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` don warware matsalar mai zuwa:\nDon jerin lambobin shigarwa da aka bayar, lissafa Matsakaicin Bambancin Dangi\n  a kusa da matsakaicin wannan bayanan.\n  Matsakaicin Bambancin Dangi shine matsakaicin bambancin dangi tsakanin kowanne\n  abu da wani tsakiya (matsakaici a wannan yanayin):\n  MAD = matsakaici | x - x_mean |",
      "hi": "Rust फ़ंक्शन `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।\nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में माध्य) के बीच औसत निरपेक्ष अंतर है:\nMAD = average | x - x_mean |",
      "hu": "Írj egy Rust függvényt `fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{` a következő probléma megoldására:\nEgy adott számok listájára számítsd ki az átlagos abszolút eltérést\n  az adathalmaz átlagához képest.\n  Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti átlagos abszolút különbség:\n  MAD = average | x - x_mean |"
    },
    "instruction_bertscore": {
      "sq": "0.9714278142096555",
      "hy": "0.944040260011803",
      "bn": "0.9429346833109629",
      "bg": "0.9598836150942888",
      "zh": "0.9412749278470353",
      "fr": "0.9730830011748192",
      "de": "0.9632954891493251",
      "ha": "0.9529496271227419",
      "hi": "0.9394032337665436",
      "hu": "0.9390343771489618"
    },
    "level": "easy",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_mean_absolute_deviation() {\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n  }\n \n }\n ",
    "entry_point": "mean_absolute_deviation",
    "signature": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
    "docstring": {
      "en": "For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |",
      "sq": "Për një listë të dhënë numrash hyrës, llogaritni Devijimin Absolut Mesatar\n  rreth mesatares së këtij grupi të dhënash.\n  Devijimi Absolut Mesatar është mesatarja e diferencës absolute midis secilit\n  element dhe një pikë qendrore (mesatarja në këtë rast):\n  MAD = mesatarja | x - x_mean |",
      "hy": "Տրված թվերի ցուցակի համար հաշվարկեք միջին բացարձակ շեղումը\n  այս տվյալների հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը տվյալների այս հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը միջին բացարձակ տարբերությունն է յուրաքանչյուր\n  տարրի և կենտրոնական կետի (այս դեպքում՝ միջինի) միջև:\n  MAD = միջին | x - x_mean |",
      "bn": "প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি (Mean Absolute Deviation) গণনা করুন। গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য: MAD = গড় | x - x_mean |",
      "bg": "За даден списък от входни числа, изчислете Средно Абсолютно Отклонение около средната стойност на този набор от данни. Средното Абсолютно Отклонение е средната абсолютна разлика между всеки елемент и централната точка (в този случай средната стойност): MAD = средно | x - x_mean |",
      "zh": "对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：\nMAD = average | x - x_mean |",
      "fr": "Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne autour de la moyenne de cet ensemble de données.  \nLa Déviation Absolue Moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :  \nMAD = moyenne | x - x_mean |",
      "de": "Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung um den Mittelwert dieses Datensatzes. Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem Element und einem Mittelpunkt (in diesem Fall der Mittelwert): MAD = Durchschnitt | x - x_mean |",
      "ha": "Don wani jerin lambobin shigarwa da aka bayar, lissafa Matsakaicin Bambancin Dangi\n  a kusa da matsakaicin wannan bayanan.\n  Matsakaicin Bambancin Dangi shine matsakaicin bambancin dangi tsakanin kowanne\n  abu da wani tsakiya (matsakaici a wannan yanayin):\n  MAD = matsakaici | x - x_mean |",
      "hi": "दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।  \nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:  \nMAD = औसत | x - x_mean |  ",
      "hu": "Egy adott bemeneti számok listájára számítsa ki az átlagos abszolút eltérést\n  az adathalmaz átlagához képest.\n  Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti átlagos abszolút különbség:\n  MAD = átlag | x - x_mean |"
    },
    "docstring_bertscore": {
      "sq": "0.9610849316387878",
      "hy": "0.9362976477590631",
      "bn": "0.9222703702503793",
      "bg": "0.9471625309712904",
      "zh": "0.9093063611713752",
      "fr": "0.9514287142951577",
      "de": "0.9250180243112349",
      "ha": "0.9393293432647986",
      "hi": "0.8999611990044458",
      "hu": "0.8606397328836363"
    }
  },
  {
    "task_id": "Rust/6",
    "prompt": {
      "en": "/*\n  Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "sq": "/*\n  Përcakton gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që është e përfshirë në 'source'.\n  Funksioni nuk kërkon që karakteret të jenë të pozicionuara në mënyrë të njëpasnjëshme në 'source', por ato duhet të ruajnë rendin e tyre nga 'target'.\n\n  Argumentet:\n  - source: Një varg që përbëhet nga shkronja të mëdha të alfabetit anglisht.\n  - target: Një varg që përbëhet nga shkronja të mëdha të alfabetit anglisht.\n\n  Kthen:\n  - Gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që është e përfshirë në 'source'.\n\n  Shembull:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") kthen 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") kthen 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") kthen 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "hy": "/*\n  Որոշում է 'target'-ից 'source'-ում պարունակվող ամենաերկար անընդմեջ հաջորդականության երկարությունը:\n  Ֆունկցիան չի պահանջում, որ նիշերը լինեն 'source'-ում հաջորդաբար տեղակայված, բայց նրանք պետք է պահպանեն իրենց կարգը 'target'-ից:\n\n  Արգումենտներ:\n  - source: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n  - target: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - 'target'-ից 'source'-ում պարունակվող ամենաերկար անընդմեջ հաջորդականության երկարությունը:\n\n  Օրինակ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") վերադարձնում է 0\n*/",
      "bn": "/*\n  'source' এর মধ্যে 'target' থেকে অক্ষরের দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য নির্ধারণ করে।\n  ফাংশনটি 'source' এ অক্ষরগুলিকে পরপর অবস্থান করতে হবে না, তবে তাদের অবশ্যই 'target' থেকে তাদের ক্রম বজায় রাখতে হবে।\n\n  আর্গুমেন্ট:\n  - source: বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n  - target: বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্ন করে:\n  - 'source' এর মধ্যে 'target' থেকে অক্ষরের দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 রিটার্ন করে\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "bg": "/*\n  Определя дължината на най-дългата непрекъсната последователност от символи от 'target', която се съдържа в 'source'.\n  Функцията не изисква символите да са последователно разположени в 'source', но те трябва да запазят реда си от 'target'.\n\n  Аргументи:\n  - source: Низ, състоящ се от главни английски букви.\n  - target: Низ, състоящ се от главни английски букви.\n\n  Връща:\n  - Дължината на най-дългата непрекъсната последователност от символи от 'target', която се съдържа в 'source'.\n\n  Пример:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") връща 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") връща 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") връща 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "zh": "/*\n  确定在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n  该函数不要求字符在 'source' 中连续出现，但它们必须保持来自 'target' 的顺序。\n\n  参数:\n  - source: 一个由大写英文字母组成的字符串。\n  - target: 一个由大写英文字母组成的字符串。\n\n  返回:\n  - 在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n\n  示例:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 返回 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 返回 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 返回 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "fr": "/*\n  Détermine la longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n  La fonction ne nécessite pas que les caractères soient positionnés consécutivement dans 'source', mais ils doivent conserver leur ordre de 'target'.\n\n  Arguments:\n  - source: Une chaîne de caractères composée de lettres majuscules anglaises.\n  - target: Une chaîne de caractères composée de lettres majuscules anglaises.\n\n  Retourne:\n  - La longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n\n  Exemple:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "de": "/*\n  Bestimmt die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n  Die Funktion erfordert nicht, dass die Zeichen in 'source' aufeinanderfolgend positioniert sind, aber sie müssen ihre Reihenfolge aus 'target' beibehalten.\n\n  Argumente:\n  - source: Ein String bestehend aus Großbuchstaben des englischen Alphabets.\n  - target: Ein String bestehend aus Großbuchstaben des englischen Alphabets.\n\n  Rückgabe:\n  - Die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n\n  Beispiel:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") gibt 3 zurück\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") gibt 3 zurück\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") gibt 0 zurück\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "ha": "/*\n  Yana ƙayyade tsawon jerin haruffa masu jere mafi tsawo daga 'target' da aka ƙunsa a cikin 'source'.\n  Aikin ba ya buƙatar haruffa su kasance a jere a cikin 'source', amma dole ne su kiyaye tsari daga 'target'.\n\n  Huɗɗa:\n  - source: Wani kirtani mai ƙunshe da manyan haruffan Turanci.\n  - target: Wani kirtani mai ƙunshe da manyan haruffan Turanci.\n\n  Komawa:\n  - Tsawon jerin haruffa masu jere mafi tsawo daga 'target' da aka ƙunsa a cikin 'source'.\n\n  Misali:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "hi": "/*\n  'source' में मौजूद 'target' के वर्णों के सबसे लंबे निरंतर अनुक्रम की लंबाई निर्धारित करता है।\n  फ़ंक्शन को वर्णों को 'source' में लगातार स्थित होने की आवश्यकता नहीं है, लेकिन उन्हें 'target' से अपने क्रम को बनाए रखना चाहिए।\n\n  तर्क:\n  - source: बड़े अक्षरों में अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n  - target: बड़े अक्षरों में अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  लौटाता है:\n  - 'source' में मौजूद 'target' के वर्णों के सबसे लंबे निरंतर अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 लौटाता है\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 लौटाता है\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 लौटाता है\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "hu": "/*\n  Meghatározza a 'target'-ből származó leghosszabb összefüggő karaktersorozat hosszát, amely megtalálható a 'source'-ban.\n  A függvény nem igényli, hogy a karakterek egymás után helyezkedjenek el a 'source'-ban, de meg kell őrizniük a 'target'-beli sorrendjüket.\n\n  Argumentumok:\n  - source: Egy nagybetűs angol betűkből álló string.\n  - target: Egy nagybetűs angol betűkből álló string.\n\n  Visszatér:\n  - A 'target'-ből származó leghosszabb összefüggő karaktersorozat hossza, amely megtalálható a 'source'-ban.\n\n  Példa:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") visszaadja 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") visszaadja 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") visszaadja 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.970679176303535",
      "hy": "0.9349831118973742",
      "bn": "0.9611500824037672",
      "bg": "0.9989150808587874",
      "zh": "0.9576174410770618",
      "fr": "0.9965599204308567",
      "de": "0.9754435246230378",
      "ha": "0.9375629232862553",
      "hi": "0.9648312992554868",
      "hu": "0.9727361925295323"
    },
    "canonical_solution": "{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}",
    "instruction": {
      "en": "Write a Rust function `fn longest_contained_sequence(source: &str, target: &str) -> usize` to solve the following problem:\nDetermines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "sq": "Shkruani një funksion Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` për të zgjidhur problemin në vijim:\nPërcakton gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që përmbahet në 'source'.\n  Funksioni nuk kërkon që karakteret të jenë të pozicionuara në mënyrë të njëpasnjëshme në 'source', por ato duhet të ruajnë rendin e tyre nga 'target'.\n\n  Argumentet:\n  - source: Një varg që përbëhet nga shkronja të mëdha të anglishtes.\n  - target: Një varg që përbëhet nga shkronja të mëdha të anglishtes.\n\n  Kthen:\n  - Gjatësia e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që përmbahet në 'source'.\n\n  Shembull:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") kthen 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") kthen 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") kthen 0",
      "hy": "Գրեք Rust ֆունկցիա `fn longest_contained_sequence(source: &str, target: &str) -> usize` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է 'target'-ից ամենաերկար հարակից հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n  Ֆունկցիան չի պահանջում, որ նիշերը 'source'-ում լինեն հաջորդաբար տեղադրված, բայց նրանք պետք է պահպանեն իրենց կարգը 'target'-ից:\n\n  Արգումենտներ:\n  - source: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n  - target: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - 'target'-ից ամենաերկար հարակից հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n\n  Օրինակ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") վերադարձնում է 0",
      "bn": "Rust ফাংশন `fn longest_contained_sequence(source: &str, target: &str) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n'টার্গেট' থেকে 'সোর্স'-এ অন্তর্ভুক্ত সবচেয়ে দীর্ঘ ক্রমাগত অক্ষরগুলির ক্রমের দৈর্ঘ্য নির্ধারণ করে।\n  ফাংশনটির জন্য প্রয়োজন নেই যে অক্ষরগুলি 'সোর্স'-এ ধারাবাহিকভাবে অবস্থান করবে, তবে তাদের অবশ্যই 'টার্গেট' থেকে তাদের ক্রম বজায় রাখতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - source: একটি স্ট্রিং যা বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত।\n  - target: একটি স্ট্রিং যা বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত।\n\n  রিটার্নস:\n  - 'টার্গেট' থেকে 'সোর্স'-এ অন্তর্ভুক্ত সবচেয়ে দীর্ঘ ক্রমাগত অক্ষরগুলির ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize`, за да решите следния проблем:\nОпределя дължината на най-дългата непрекъсната последователност от символи от 'target', която се съдържа в 'source'.\nФункцията не изисква символите да бъдат последователно позиционирани в 'source', но те трябва да запазят реда си от 'target'.\n\nАргументи:\n- source: Низ, състоящ се от главни английски букви.\n- target: Низ, състоящ се от главни английски букви.\n\nВръща:\n- Дължината на най-дългата непрекъсната последователност от символи от 'target', която се съдържа в 'source'.\n\nПример:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") връща 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") връща 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") връща 0",
      "zh": "编写一个 Rust 函数 `fn longest_contained_sequence(source: &str, target: &str) -> usize` 来解决以下问题：\n确定在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n函数不要求字符在 'source' 中是连续的，但它们必须保持来自 'target' 的顺序。\n\n参数：\n- source: 一个由大写英文字母组成的字符串。\n- target: 一个由大写英文字母组成的字符串。\n\n返回值：\n- 在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n\n示例：\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 返回 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") 返回 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") 返回 0",
      "fr": "Écrire une fonction Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` pour résoudre le problème suivant :\nDétermine la longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n  La fonction ne nécessite pas que les caractères soient positionnés consécutivement dans 'source', mais ils doivent conserver leur ordre de 'target'.\n\n  Arguments :\n  - source : Une chaîne de caractères composée de lettres majuscules anglaises.\n  - target : Une chaîne de caractères composée de lettres majuscules anglaises.\n\n  Renvoie :\n  - La longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n\n  Exemple :\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") renvoie 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") renvoie 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") renvoie 0",
      "de": "Schreiben Sie eine Rust-Funktion `fn longest_contained_sequence(source: &str, target: &str) -> usize`, um das folgende Problem zu lösen:\nBestimmt die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n  Die Funktion erfordert nicht, dass die Zeichen aufeinanderfolgend in 'source' positioniert sind, aber sie müssen ihre Reihenfolge aus 'target' beibehalten.\n\n  Argumente:\n  - source: Ein String, der aus Großbuchstaben des englischen Alphabets besteht.\n  - target: Ein String, der aus Großbuchstaben des englischen Alphabets besteht.\n\n  Rückgabewert:\n  - Die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n\n  Beispiel:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") gibt 3 zurück\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") gibt 3 zurück\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") gibt 0 zurück",
      "ha": "Rubuta aikin Rust `fn longest_contained_sequence(source: &str, target: &str) -> usize` don warware matsalar mai zuwa:\nYana tantance tsawon mafi tsawo jere na haruffa daga 'target' wanda aka samu a cikin 'source'.\n  Aikin ba ya buƙatar haruffa su kasance a jere a cikin 'source', amma dole ne su ci gaba da tsari daga 'target'.\n\n  Huɗɗa:\n  - source: Wani kirtani wanda ya ƙunshi manyan haruffan Ingilishi.\n  - target: Wani kirtani wanda ya ƙunshi manyan haruffan Ingilishi.\n\n  Komawa:\n  - Tsawon mafi tsawo jere na haruffa daga 'target' wanda aka samu a cikin 'source'.\n\n  Misali:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "hi": "Rust फ़ंक्शन `fn longest_contained_sequence(source: &str, target: &str) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह 'target' से वर्णों की सबसे लंबी निरंतर अनुक्रम की लंबाई निर्धारित करता है जो 'source' में शामिल है।\n  फ़ंक्शन को वर्णों को 'source' में लगातार स्थित होने की आवश्यकता नहीं है, लेकिन उन्हें 'target' से अपने क्रम को बनाए रखना चाहिए।\n\n  तर्क:\n  - source: अपरकेस अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n  - target: अपरकेस अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  लौटाता है:\n  - 'target' से वर्णों की सबसे लंबी निरंतर अनुक्रम की लंबाई जो 'source' में शामिल है।\n\n  उदाहरण:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 लौटाता है\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 लौटाता है\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn longest_contained_sequence(source: &str, target: &str) -> usize` a következő probléma megoldására:\nMeghatározza a 'target'-ből származó leghosszabb összefüggő karaktersorozat hosszát, amely megtalálható a 'source'-ban.\n  A függvény nem követeli meg, hogy a karakterek egymás után legyenek elhelyezve a 'source'-ban, de meg kell őrizniük a 'target'-ből származó sorrendjüket.\n\n  Argumentumok:\n  - source: Egy nagybetűs angol betűkből álló string.\n  - target: Egy nagybetűs angol betűkből álló string.\n\n  Visszatérési érték:\n  - A 'target'-ből származó leghosszabb összefüggő karaktersorozat hossza, amely megtalálható a 'source'-ban.\n\n  Példa:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") visszaadja 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") visszaadja 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.9937723416634131",
      "hy": "0.9776604383057682",
      "bn": "0.967286172134697",
      "bg": "0.9911329411602215",
      "zh": "0.9449402542682721",
      "fr": "0.9919375928337939",
      "de": "0.9816850870862971",
      "ha": "0.9495711229717195",
      "hi": "0.9702274908170616",
      "hu": "0.9775154381276128"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_contained_sequence(\"ABCDEABCD\", \"AABZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"XYZ\", \"XYZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"ABCDEF\", \"FED\"), 1);\n        assert_eq!(longest_contained_sequence(\"ABCD\", \"BCD\"), 3);\n    }\n    \n\n}",
    "entry_point": "longest_contained_sequence",
    "signature": "fn longest_contained_sequence(source: &str, target: &str) -> usize",
    "docstring": {
      "en": "Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "sq": "Determinon gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që është e përfshirë në 'source'.\n  Funksioni nuk kërkon që karakteret të jenë të pozicionuara në mënyrë të njëpasnjëshme në 'source', por ato duhet të ruajnë rendin e tyre nga 'target'.\n\n  Argumentet:\n  - source: Një varg që përbëhet nga shkronja të mëdha të alfabetit anglisht.\n  - target: Një varg që përbëhet nga shkronja të mëdha të alfabetit anglisht.\n\n  Kthen:\n  - Gjatësia e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që është e përfshirë në 'source'.\n\n  Shembull:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") kthen 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") kthen 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") kthen 0",
      "hy": "Որոշում է 'target'-ից վերցված ամենաերկար անընդհատ հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n  Ֆունկցիան չի պահանջում, որ նիշերը հաջորդաբար տեղադրված լինեն 'source'-ում, բայց նրանք պետք է պահպանեն իրենց կարգը 'target'-ից:\n\n  Արգումենտներ:\n  - source: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n  - target: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - 'target'-ից վերցված ամենաերկար անընդհատ հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n\n  Օրինակ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") վերադարձնում է 0",
      "bn": "'সোর্স' এ অন্তর্ভুক্ত 'টার্গেট' থেকে অক্ষরের দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য নির্ধারণ করে।\n  ফাংশনটি 'সোর্স' এ অক্ষরগুলিকে পরপর অবস্থান করতে হবে না, তবে তাদের 'টার্গেট' থেকে তাদের ক্রম বজায় রাখতে হবে।\n\n  আর্গুমেন্টস:\n  - সোর্স: বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n  - টার্গেট: বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্নস:\n  - 'সোর্স' এ অন্তর্ভুক্ত 'টার্গেট' থেকে অক্ষরের দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 রিটার্ন করে",
      "bg": "Определя дължината на най-дългата непрекъсната последователност от символи от 'target', която е съдържана в 'source'. \nФункцията не изисква символите да са последователно разположени в 'source', но те трябва да запазят реда си от 'target'.\n\nАргументи:\n- source: Низ, състоящ се от главни английски букви.\n- target: Низ, състоящ се от главни английски букви.\n\nВръща:\n- Дължината на най-дългата непрекъсната последователност от символи от 'target', която е съдържана в 'source'.\n\nПример:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") връща 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") връща 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") връща 0",
      "zh": "确定在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。  \n该函数不要求字符在 'source' 中连续出现，但它们必须保持来自 'target' 的顺序。\n\n参数:\n- source: 一个由大写英文字母组成的字符串。\n- target: 一个由大写英文字母组成的字符串。\n\n返回:\n- 在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n\n示例:\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 返回 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") 返回 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") 返回 0",
      "fr": "Détermine la longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n  La fonction ne nécessite pas que les caractères soient positionnés consécutivement dans 'source', mais ils doivent conserver leur ordre de 'target'.\n\n  Arguments:\n  - source: Une chaîne de caractères composée de lettres majuscules anglaises.\n  - target: Une chaîne de caractères composée de lettres majuscules anglaises.\n\n  Retourne:\n  - La longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n\n  Exemple:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") retourne 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") retourne 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") retourne 0",
      "de": "Bestimmt die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n  Die Funktion erfordert nicht, dass die Zeichen in 'source' aufeinanderfolgend positioniert sind, aber sie müssen ihre Reihenfolge aus 'target' beibehalten.\n\n  Argumente:\n  - source: Ein String, bestehend aus Großbuchstaben des englischen Alphabets.\n  - target: Ein String, bestehend aus Großbuchstaben des englischen Alphabets.\n\n  Rückgabewert:\n  - Die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n\n  Beispiel:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") gibt 3 zurück\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") gibt 3 zurück\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") gibt 0 zurück",
      "ha": "Yana ƙayyade tsawon jerin haruffa mafi tsawo na jere daga 'target' wanda aka ƙunsa a cikin 'source'. \n  Aiki ba ya buƙatar haruffa su kasance a jere a cikin 'source', amma dole ne su kiyaye tsarin su daga 'target'.\n\n  Huɗɗa:\n  - source: Wani igiya da ke ƙunshe da manyan haruffan Turanci.\n  - target: Wani igiya da ke ƙunshe da manyan haruffan Turanci.\n\n  Komawa:\n  - Tsawon jerin haruffa mafi tsawo na jere daga 'target' wanda aka ƙunsa a cikin 'source'.\n\n  Misali:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "hi": "निर्धारित करता है कि 'target' से सबसे लंबा निरंतर वर्णों का अनुक्रम, जो 'source' में शामिल है, की लंबाई क्या है। \n  फ़ंक्शन को 'source' में वर्णों के लगातार स्थित होने की आवश्यकता नहीं है, लेकिन उन्हें 'target' से अपना क्रम बनाए रखना चाहिए।\n\n  तर्क:\n  - source: अपरकेस अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n  - target: अपरकेस अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  लौटाता है:\n  - 'source' में शामिल 'target' से सबसे लंबा निरंतर वर्णों का अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 लौटाता है\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 लौटाता है\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 लौटाता है",
      "hu": "Megállapítja a 'target'-ből származó leghosszabb összefüggő karaktersorozat hosszát, amely a 'source'-ban található.\n  A függvény nem követeli meg, hogy a karakterek egymás után helyezkedjenek el a 'source'-ban, de meg kell őrizniük a 'target'-ből származó sorrendjüket.\n\n  Argumentumok:\n  - source: Egy nagybetűs angol betűkből álló karakterlánc.\n  - target: Egy nagybetűs angol betűkből álló karakterlánc.\n\n  Visszatér:\n  - A 'target'-ből származó leghosszabb összefüggő karaktersorozat hossza, amely a 'source'-ban található.\n\n  Példa:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") visszaadja 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") visszaadja 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9680282552382433",
      "hy": "0.9767244919503318",
      "bn": "0.9655807316831315",
      "bg": "0.9920903395968097",
      "zh": "0.951988256078533",
      "fr": "0.973315200090249",
      "de": "0.9606225201117385",
      "ha": "0.9454598713450594",
      "hi": "0.985920681331485",
      "hu": "0.9685605846594169"
    }
  },
  {
    "task_id": "Rust/7",
    "prompt": {
      "en": "/*\n  Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "sq": "/*\n  Llogarit rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar nga një listë e rezultateve të studentëve.\n  \n  Funksioni merr një vektor të rezultateve të studentëve, secili duke variuar nga 0 deri në 100, që përfaqësojnë rezultatet e studentëve në një provim. Ai kthen një tuple që përmban rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar të llogaritur nga këto rezultate.\n\n  Argumentet:\n  - scores: Një Vec<i32> që përmban rezultatet e provimit të studentëve.\n\n  Kthen:\n  - Një tuple (i32, i32, f64), ku elementi i parë është rezultati më i lartë, i dyti është rezultati më i ulët, dhe i treti është rezultati mesatar i rrumbullakosur në dy vende dhjetore.\n\n  Shembull:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) kthen (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) kthen (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) kthen (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "hy": "/*\n  Հաշվում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը ուսանողների միավորների ցուցակից:\n\n  Ֆունկցիան ընդունում է ամբողջ թվերի միավորների վեկտոր, որոնցից յուրաքանչյուրը տատանվում է 0-ից մինչև 100, ներկայացնելով ուսանողների միավորները քննությունում: Այն վերադարձնում է տուփ, որը պարունակում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը, հաշվարկված այս միավորներից:\n\n  Փոփոխականներ:\n  - scores: A Vec<i32>, որը պարունակում է ուսանողների քննության միավորները:\n\n  Վերադարձնում է:\n  - Տուփ (i32, i32, f64), որտեղ առաջին տարրը ամենաբարձր միավորն է, երկրորդը՝ ամենացածր միավորը, իսկ երրորդը՝ միջին միավորը, կլորացված մինչև երկու տասնորդական:\n\n  Օրինակ:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) վերադարձնում է (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) վերադարձնում է (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) վերադարձնում է (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "bn": "/*\n  ছাত্রদের স্কোরের তালিকা থেকে সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর গণনা করে।\n\n  ফাংশনটি পূর্ণসংখ্যার স্কোরের একটি ভেক্টর নেয়, প্রতিটি 0 থেকে 100 এর মধ্যে, যা একটি পরীক্ষায় ছাত্রদের স্কোর উপস্থাপন করে। এটি একটি টিউপল ফেরত দেয় যা এই স্কোরগুলির থেকে গণনা করা সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর ধারণ করে।\n\n  আর্গুমেন্ট:\n  - scores: A Vec<i32> যা ছাত্রদের পরীক্ষার স্কোর ধারণ করে।\n\n  রিটার্নস:\n  - একটি টিউপল (i32, i32, f64), যেখানে প্রথম উপাদানটি সর্বোচ্চ স্কোর, দ্বিতীয়টি সর্বনিম্ন স্কোর, এবং তৃতীয়টি গড় স্কোর যা দুই দশমিক স্থানে গোল করা হয়।\n\n  উদাহরণ:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "bg": "/*\n  Изчислява най-високата оценка, най-ниската оценка и средната оценка от списък с оценки на ученици.\n  \n  Функцията приема вектор от цели числа, всяко в диапазона от 0 до 100, представляващи оценките на учениците на изпит. Връща кортеж, съдържащ най-високата оценка, най-ниската оценка и средната оценка, изчислена от тези оценки.\n\n  Аргументи:\n  - scores: Vec<i32>, съдържащ оценките на учениците от изпита.\n\n  Връща:\n  - Кортеж (i32, i32, f64), където първият елемент е най-високата оценка, вторият е най-ниската оценка, а третият е средната оценка, закръглена до два знака след десетичната запетая.\n\n  Пример:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) връща (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) връща (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) връща (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "zh": "/*\n  计算学生分数列表中的最高分、最低分和平均分。\n  \n  该函数接受一个整数分数的向量，每个分数范围从0到100，代表学生考试的分数。它返回一个包含最高分、最低分和从这些分数计算出的平均分的元组。\n\n  参数:\n  - scores: 一个包含学生考试分数的 Vec<i32>。\n\n  返回:\n  - 一个元组 (i32, i32, f64)，其中第一个元素是最高分，第二个是最低分，第三个是平均分，四舍五入到小数点后两位。\n\n  示例:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) 返回 (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) 返回 (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) 返回 (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "fr": "/*\n  Calcule le score le plus élevé, le score le plus bas et le score moyen à partir d'une liste de scores d'étudiants.\n  \n  La fonction prend un vecteur de scores entiers, chacun allant de 0 à 100, représentant les scores des étudiants à un examen. Elle renvoie un tuple contenant le score le plus élevé, le score le plus bas et le score moyen calculé à partir de ces scores.\n\n  Arguments :\n  - scores : Un Vec<i32> contenant les scores d'examen des étudiants.\n\n  Renvoie :\n  - Un tuple (i32, i32, f64), où le premier élément est le score le plus élevé, le second est le score le plus bas, et le troisième est le score moyen arrondi à deux décimales.\n\n  Exemple :\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) renvoie (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) renvoie (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) renvoie (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "de": "/*\n  Berechnet die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl aus einer Liste von Schülerpunkten.\n  \n  Die Funktion nimmt einen Vektor von Ganzzahlen, die jeweils zwischen 0 und 100 liegen, und die die Punkte der Schüler in einer Prüfung darstellen. Sie gibt ein Tupel zurück, das die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl enthält, die aus diesen Punkten berechnet wird.\n\n  Argumente:\n  - scores: Ein Vec<i32>, der die Prüfungspunkte der Schüler enthält.\n\n  Rückgabewerte:\n  - Ein Tupel (i32, i32, f64), wobei das erste Element die höchste Punktzahl ist, das zweite die niedrigste Punktzahl und das dritte die durchschnittliche Punktzahl, gerundet auf zwei Dezimalstellen.\n\n  Beispiel:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) gibt (99, 10, 71.29) zurück\n  - exam_statistics(vec![100, 85, 76, 90]) gibt (100, 76, 87.75) zurück\n  - exam_statistics(vec![50, 50, 50, 50]) gibt (50, 50, 50.00) zurück\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "ha": "/*\n  Lissafa mafi girman maki, mafi ƙanƙanta maki, da matsakaicin maki daga jerin maki na ɗalibai.\n  \n  Aikin yana ɗaukar vector na maki na integer, kowanne yana tsakanin 0 zuwa 100, yana wakiltar maki na ɗalibai a jarrabawa. Yana dawowa da tuple wanda ke ɗauke da mafi girman maki, mafi ƙanƙanta maki, da matsakaicin maki da aka lissafa daga waɗannan makin.\n\n  Huɗɗa:\n  - scores: Wani Vec<i32> wanda ke ɗauke da maki na jarrabawa na ɗalibai.\n\n  Dawowa:\n  - Wani tuple (i32, i32, f64), inda abu na farko shine mafi girman maki, na biyu shine mafi ƙanƙanta maki, kuma na uku shine matsakaicin maki da aka zagaye zuwa wurare biyu na goma.\n\n  Misali:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "hi": "/*\n  एक सूची में छात्रों के अंकों से उच्चतम स्कोर, न्यूनतम स्कोर, और औसत स्कोर की गणना करता है।\n  \n  यह फ़ंक्शन पूर्णांक अंकों के एक वेक्टर को लेता है, प्रत्येक 0 से 100 के बीच होता है, जो परीक्षा में छात्रों के अंकों का प्रतिनिधित्व करता है। यह एक ट्यूपल लौटाता है जिसमें उच्चतम स्कोर, न्यूनतम स्कोर, और इन अंकों से गणना किया गया औसत स्कोर शामिल होता है।\n\n  तर्क:\n  - scores: छात्रों के परीक्षा अंकों को शामिल करने वाला एक Vec<i32>।\n\n  रिटर्न करता है:\n  - एक ट्यूपल (i32, i32, f64), जहां पहला तत्व उच्चतम स्कोर है, दूसरा न्यूनतम स्कोर है, और तीसरा औसत स्कोर है जो दो दशमलव स्थानों तक गोल किया गया है।\n\n  उदाहरण:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) (99, 10, 71.29) लौटाता है\n  - exam_statistics(vec![100, 85, 76, 90]) (100, 76, 87.75) लौटाता है\n  - exam_statistics(vec![50, 50, 50, 50]) (50, 50, 50.00) लौटाता है\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "hu": "/*\n  Kiszámítja a legmagasabb pontszámot, legalacsonyabb pontszámot és az átlagpontszámot egy hallgatói pontszámok listájából.\n  \n  A függvény egy egész számokat tartalmazó vektort vesz át, ahol minden érték 0 és 100 között van, és a hallgatók vizsgapontszámait képviseli. Egy olyan tuple-t ad vissza, amely tartalmazza a legmagasabb pontszámot, a legalacsonyabb pontszámot és az ezekből a pontszámokból számított átlagpontszámot.\n\n  Argumentumok:\n  - scores: Egy Vec<i32>, amely a hallgatók vizsgapontszámait tartalmazza.\n\n  Visszatér:\n  - Egy tuple (i32, i32, f64), ahol az első elem a legmagasabb pontszám, a második a legalacsonyabb pontszám, a harmadik pedig az átlagpontszám, két tizedesjegyre kerekítve.\n\n  Példa:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) visszatér (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) visszatér (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) visszatér (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)"
    },
    "prompt_bertscore": {
      "sq": "0.9778173563067858",
      "hy": "0.9733694261842715",
      "bn": "0.9902543989849042",
      "bg": "0.9507233778121029",
      "zh": "0.967833001573686",
      "fr": "0.983033787373524",
      "de": "0.9763937723659087",
      "ha": "0.9675412135439458",
      "hi": "0.9797700915827398",
      "hu": "0.9790025837904209"
    },
    "canonical_solution": "{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}",
    "instruction": {
      "en": "Write a Rust function `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` to solve the following problem:\nCalculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "sq": "Shkruani një funksion në Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` për të zgjidhur problemin e mëposhtëm:\nLlogarit rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar nga një listë e rezultateve të studentëve.\n\nFunksioni merr një vektor të rezultateve të plota, secila që varion nga 0 në 100, që përfaqësojnë rezultatet e studentëve në një provim. Ai kthen një tuple që përmban rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar të llogaritur nga këto rezultate.\n\nArgumentet:\n- scores: Një Vec<i32> që përmban rezultatet e provimit të studentëve.\n\nKthen:\n- Një tuple (i32, i32, f64), ku elementi i parë është rezultati më i lartë, i dyti është rezultati më i ulët dhe i treti është rezultati mesatar i rrumbullakosur në dy vende dhjetore.\n\nShembull:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) kthen (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) kthen (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) kthen (50, 50, 50.00)",
      "hy": "Գրեք Rust ֆունկցիա `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը ուսանողների միավորների ցանկից:\n\nՖունկցիան ընդունում է ամբողջ թվերի միավորների վեկտոր, որոնցից յուրաքանչյուրը տատանվում է 0-ից 100-ի միջև, ներկայացնելով ուսանողների միավորները քննության ժամանակ: Այն վերադարձնում է տյուպլ, որը պարունակում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը, հաշվարկված այս միավորներից:\n\nԱրգումենտներ:\n- scores: A Vec<i32>, որը պարունակում է ուսանողների քննության միավորները:\n\nՎերադարձնում է:\n- Տյուպլ (i32, i32, f64), որտեղ առաջին տարրը ամենաբարձր միավորն է, երկրորդը՝ ամենացածր միավորը, իսկ երրորդը՝ միջին միավորը, կլորացված մինչև երկու տասնորդական:\n\nՕրինակ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) վերադարձնում է (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) վերադարձնում է (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) վերադարձնում է (50, 50, 50.00)",
      "bn": "Rust ফাংশন `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ছাত্রের স্কোরের তালিকা থেকে সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর গণনা করে।\n\nফাংশনটি পূর্ণসংখ্যার স্কোরের একটি ভেক্টর নেয়, প্রতিটি 0 থেকে 100 এর মধ্যে, যা পরীক্ষায় ছাত্রদের স্কোর উপস্থাপন করে। এটি একটি টুপল ফেরত দেয় যা সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং এই স্কোরগুলি থেকে গণনা করা গড় স্কোর ধারণ করে।\n\nআর্গুমেন্টসমূহ:\n- scores: A Vec<i32> যা ছাত্রদের পরীক্ষার স্কোর ধারণ করে।\n\nফেরত দেয়:\n- একটি টুপল (i32, i32, f64), যেখানে প্রথম উপাদানটি সর্বোচ্চ স্কোর, দ্বিতীয়টি সর্বনিম্ন স্কোর এবং তৃতীয়টি গড় স্কোর যা দুই দশমিক স্থানে রাউন্ড করা হয়।\n\nউদাহরণ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "bg": "Напишете функция на Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)`, за да решите следния проблем:\nИзчислява най-високата оценка, най-ниската оценка и средната оценка от списък с оценки на ученици.\n\nФункцията приема вектор от цели числа, всяко от които варира от 0 до 100, представляващи оценките на учениците на изпит. Тя връща кортеж, съдържащ най-високата оценка, най-ниската оценка и средната оценка, изчислена от тези оценки.\n\nАргументи:\n- scores: Vec<i32>, съдържащ оценките на учениците на изпита.\n\nВръща:\n- Кортеж (i32, i32, f64), където първият елемент е най-високата оценка, вторият е най-ниската оценка, а третият е средната оценка, закръглена до два знака след десетичната запетая.\n\nПример:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) връща (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) връща (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) връща (50, 50, 50.00)",
      "zh": "编写一个 Rust 函数 `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` 来解决以下问题：\n计算学生成绩列表中的最高分、最低分和平均分。\n\n函数接受一个整数分数的向量，每个分数范围从 0 到 100，代表学生考试的分数。它返回一个包含最高分、最低分和从这些分数计算出的平均分的元组。\n\n参数：\n- scores: 一个 Vec<i32>，包含学生的考试成绩。\n\n返回：\n- 一个元组 (i32, i32, f64)，其中第一个元素是最高分，第二个是最低分，第三个是平均分，四舍五入到小数点后两位。\n\n示例：\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) 返回 (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) 返回 (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) 返回 (50, 50, 50.00)",
      "fr": "Écrire une fonction Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` pour résoudre le problème suivant :\nCalcule le score le plus élevé, le score le plus bas et le score moyen à partir d'une liste de scores d'étudiants.\n\nLa fonction prend un vecteur de scores entiers, chacun allant de 0 à 100, représentant les scores des étudiants à un examen. Elle retourne un tuple contenant le score le plus élevé, le score le plus bas et le score moyen calculé à partir de ces scores.\n\nArguments :\n- scores : Un Vec<i32> contenant les scores d'examen des étudiants.\n\nRenvoie :\n- Un tuple (i32, i32, f64), où le premier élément est le score le plus élevé, le second est le score le plus bas, et le troisième est le score moyen arrondi à deux décimales.\n\nExemple :\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) renvoie (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) renvoie (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) renvoie (50, 50, 50.00)",
      "de": "Schreiben Sie eine Rust-Funktion `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)`, um das folgende Problem zu lösen:\nBerechnet die höchste Punktzahl, die niedrigste Punktzahl und die Durchschnittspunktzahl aus einer Liste von Schülerpunkten.\n\nDie Funktion nimmt einen Vektor von Ganzzahlen entgegen, die jeweils zwischen 0 und 100 liegen und die Punktzahlen der Schüler in einer Prüfung darstellen. Sie gibt ein Tupel zurück, das die höchste Punktzahl, die niedrigste Punktzahl und die Durchschnittspunktzahl enthält, die aus diesen Punktzahlen berechnet wurden.\n\nArgumente:\n- scores: Ein Vec<i32>, der die Prüfungsergebnisse der Schüler enthält.\n\nRückgabewert:\n- Ein Tupel (i32, i32, f64), wobei das erste Element die höchste Punktzahl ist, das zweite die niedrigste Punktzahl und das dritte die Durchschnittspunktzahl, gerundet auf zwei Dezimalstellen.\n\nBeispiel:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) gibt (99, 10, 71.29) zurück\n- exam_statistics(vec![100, 85, 76, 90]) gibt (100, 76, 87.75) zurück\n- exam_statistics(vec![50, 50, 50, 50]) gibt (50, 50, 50.00) zurück",
      "ha": "Rubuta aikin Rust `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` don warware matsalar mai zuwa:\nLissafa mafi girman maki, mafi ƙarancin maki, da matsakaicin maki daga jerin maki na ɗalibai.\n\nAikin yana ɗaukar vector na maki na integer, kowanne yana tsakanin 0 zuwa 100, yana wakiltar maki na ɗalibai a cikin jarrabawa. Yana mayar da tuple wanda ke ɗauke da mafi girman maki, mafi ƙarancin maki, da matsakaicin maki da aka lissafa daga waɗannan maki.\n\nHuɗɗa:\n- scores: A Vec<i32> wanda ke ɗauke da maki na jarrabawar ɗalibai.\n\nMayarwa:\n- Tuple (i32, i32, f64), inda abu na farko shine mafi girman maki, na biyu shine mafi ƙarancin maki, kuma na uku shine matsakaicin maki da aka zagaye zuwa wurare biyu na decimal.\n\nMisali:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "hi": "Rust फ़ंक्शन `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nछात्रों के अंकों की सूची से उच्चतम अंक, न्यूनतम अंक, और औसत अंक की गणना करता है।\n\nफ़ंक्शन एक वेक्टर लेता है जिसमें पूर्णांक अंक होते हैं, प्रत्येक 0 से 100 के बीच होता है, जो परीक्षा में छात्रों के अंक का प्रतिनिधित्व करता है। यह एक ट्यूपल लौटाता है जिसमें उच्चतम अंक, न्यूनतम अंक, और इन अंकों से गणना किया गया औसत अंक होता है।\n\nआर्गुमेंट्स:\n- scores: एक Vec<i32> जिसमें छात्रों के परीक्षा अंक होते हैं।\n\nरिटर्न्स:\n- एक ट्यूपल (i32, i32, f64), जहाँ पहला तत्व उच्चतम अंक है, दूसरा न्यूनतम अंक है, और तीसरा औसत अंक है जो दो दशमलव स्थानों तक गोल किया गया है।\n\nउदाहरण:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "hu": "Írj egy Rust függvényt `fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)` a következő probléma megoldására:\nKiszámítja a legmagasabb pontszámot, a legalacsonyabb pontszámot és az átlagpontszámot egy hallgatói pontszámok listájából.\n\nA függvény egy egész számokat tartalmazó vektort vesz át, amelyek 0 és 100 között mozognak, és a diákok vizsgapontszámait képviselik. Egy olyan tuple-t ad vissza, amely tartalmazza a legmagasabb pontszámot, a legalacsonyabb pontszámot és az ezekből a pontszámokból számított átlagpontszámot.\n\nArgumentumok:\n- scores: Egy Vec<i32>, amely a diákok vizsgapontszámait tartalmazza.\n\nVisszatérési érték:\n- Egy tuple (i32, i32, f64), ahol az első elem a legmagasabb pontszám, a második a legalacsonyabb pontszám, és a harmadik az átlagpontszám, két tizedesjegyre kerekítve.\n\nPélda:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) visszaadja (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) visszaadja (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) visszaadja (50, 50, 50.00)"
    },
    "instruction_bertscore": {
      "sq": "0.9827197527411078",
      "hy": "0.9765024231843348",
      "bn": "0.9749227157639643",
      "bg": "0.9800646604378145",
      "zh": "0.9781764800356968",
      "fr": "0.987993190727203",
      "de": "0.978490514668113",
      "ha": "0.983705952582946",
      "hi": "0.9782976445681281",
      "hu": "0.980653996778345"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]), (99, 10, 71.29));\n        assert_eq!(exam_statistics(vec![100, 85, 76, 90]), (100, 76, 87.75));\n        assert_eq!(exam_statistics(vec![50, 50, 50, 50]), (50, 50, 50.00));\n    }\n}",
    "entry_point": "exam_statistics",
    "signature": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
    "docstring": {
      "en": "Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "sq": "Llogarit rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar nga një listë e rezultateve të studentëve.\n\nFunksioni merr një vektor të rezultateve të plota, secili duke variuar nga 0 deri në 100, që përfaqësojnë rezultatet e studentëve në një provim. Ai kthen një tuple që përmban rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar të llogaritur nga këto rezultate.\n\nArgumentet:\n- scores: Një Vec<i32> që përmban rezultatet e provimit të studentëve.\n\nKthen:\n- Një tuple (i32, i32, f64), ku elementi i parë është rezultati më i lartë, i dyti është rezultati më i ulët, dhe i treti është rezultati mesatar i rrumbullakosur në dy vende dhjetore.\n\nShembull:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) kthen (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) kthen (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) kthen (50, 50, 50.00)",
      "hy": "Հաշվում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը ուսանողների միավորների ցուցակից:\n\nՖունկցիան ընդունում է ամբողջ թվերի միավորների վեկտոր, որոնցից յուրաքանչյուրը տատանվում է 0-ից մինչև 100, ներկայացնելով ուսանողների քննության միավորները: Այն վերադարձնում է տյուփլ, որը պարունակում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը, հաշվարկված այս միավորներից:\n\nԱրձանագրություններ:\n- scores: A Vec<i32>, որը պարունակում է ուսանողների քննության միավորները:\n\nՎերադարձնում է:\n- Տյուփլ (i32, i32, f64), որտեղ առաջին տարրը ամենաբարձր միավորն է, երկրորդը՝ ամենացածր միավորը, իսկ երրորդը՝ միջին միավորը, կլորացված մինչև երկու տասնորդական թվանշան:\n\nՕրինակ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) վերադարձնում է (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) վերադարձնում է (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) վերադարձնում է (50, 50, 50.00)",
      "bn": "সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর গণনা করে একটি ছাত্রের স্কোরের তালিকা থেকে।\n\nফাংশনটি একটি পূর্ণসংখ্যার স্কোরের ভেক্টর নেয়, প্রতিটি 0 থেকে 100 এর মধ্যে, যা একটি পরীক্ষায় ছাত্রদের স্কোর উপস্থাপন করে। এটি একটি টুপল প্রদান করে যা সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং এই স্কোরগুলি থেকে গণনা করা গড় স্কোর ধারণ করে।\n\nআর্গুমেন্টস:\n- scores: একটি Vec<i32> যা ছাত্রদের পরীক্ষার স্কোর ধারণ করে।\n\nরিটার্নস:\n- একটি টুপল (i32, i32, f64), যেখানে প্রথম উপাদানটি সর্বোচ্চ স্কোর, দ্বিতীয়টি সর্বনিম্ন স্কোর, এবং তৃতীয়টি গড় স্কোর যা দুই দশমিক স্থানে রাউন্ড করা হয়।\n\nউদাহরণ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) প্রদান করে (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) প্রদান করে (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) প্রদান করে (50, 50, 50.00)",
      "bg": "Изчислява най-високата оценка, най-ниската оценка и средната оценка от списък с оценки на ученици.\n\nФункцията приема вектор от цели числа, всяко от които е в диапазона от 0 до 100, представляващи оценките на учениците на изпит. Тя връща кортеж, съдържащ най-високата оценка, най-ниската оценка и средната оценка, изчислена от тези оценки.\n\nАргументи:\n- scores: Vec<i32>, съдържащ изпитните оценки на учениците.\n\nВръща:\n- Кортеж (i32, i32, f64), където първият елемент е най-високата оценка, вторият е най-ниската оценка, а третият е средната оценка, закръглена до два знака след десетичната запетая.\n\nПример:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) връща (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) връща (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) връща (50, 50, 50.00)",
      "zh": "计算学生成绩列表中的最高分、最低分和平均分。\n\n该函数接受一个整数分数的向量，每个分数范围从0到100，表示学生在考试中的分数。它返回一个包含最高分、最低分和从这些分数计算出的平均分的元组。\n\n参数：\n- scores: 一个 Vec<i32>，包含学生的考试成绩。\n\n返回：\n- 一个元组 (i32, i32, f64)，其中第一个元素是最高分，第二个是最低分，第三个是平均分，四舍五入到小数点后两位。\n\n示例：\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) 返回 (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) 返回 (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) 返回 (50, 50, 50.00)",
      "fr": "Calcule le score le plus élevé, le score le plus bas et le score moyen à partir d'une liste de scores d'étudiants.\n\n  La fonction prend un vecteur de scores entiers, chacun allant de 0 à 100, représentant les scores des étudiants à un examen. Elle retourne un tuple contenant le score le plus élevé, le score le plus bas et le score moyen calculé à partir de ces scores.\n\n  Arguments:\n  - scores: Un Vec<i32> contenant les scores d'examen des étudiants.\n\n  Retourne:\n  - Un tuple (i32, i32, f64), où le premier élément est le score le plus élevé, le second est le score le plus bas, et le troisième est le score moyen arrondi à deux décimales.\n\n  Exemple:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "de": "Berechnet die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl aus einer Liste von Schülernoten.\n\nDie Funktion nimmt einen Vektor von Ganzzahlen entgegen, die jeweils von 0 bis 100 reichen und die Noten der Schüler in einer Prüfung darstellen. Sie gibt ein Tupel zurück, das die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl enthält, die aus diesen Noten berechnet werden.\n\nArgumente:\n- scores: Ein Vec<i32>, das die Prüfungsergebnisse der Schüler enthält.\n\nRückgabewerte:\n- Ein Tupel (i32, i32, f64), wobei das erste Element die höchste Punktzahl ist, das zweite die niedrigste Punktzahl und das dritte die durchschnittliche Punktzahl, gerundet auf zwei Dezimalstellen.\n\nBeispiel:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) gibt (99, 10, 71.29) zurück\n- exam_statistics(vec![100, 85, 76, 90]) gibt (100, 76, 87.75) zurück\n- exam_statistics(vec![50, 50, 50, 50]) gibt (50, 50, 50.00) zurück",
      "ha": "Lissafa mafi girman maki, mafi ƙanƙanta maki, da matsakaicin maki daga jerin maki na ɗalibai.\n\n  Aikin yana ɗaukar jerin maki na ɗalibai, kowanne yana tsakanin 0 zuwa 100, wanda ke wakiltar maki na ɗalibai a jarrabawa. Yana dawowa da tuple wanda ke ɗauke da mafi girman maki, mafi ƙarancin maki, da matsakaicin maki da aka ƙididdige daga waɗannan maki.\n\n  Huɗɗa:\n  - scores: A Vec<i32> wanda ke ɗauke da maki na jarrabawar ɗalibai.\n\n  Dawowa:\n  - A tuple (i32, i32, f64), inda na farko shine mafi girman maki, na biyu shine mafi ƙarancin maki, kuma na uku shine matsakaicin maki da aka zagaye zuwa wurare biyu na goma.\n\n  Misali:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "hi": "एक सूची में छात्रों के अंकों से उच्चतम स्कोर, न्यूनतम स्कोर, और औसत स्कोर की गणना करता है।\n\n  यह फ़ंक्शन छात्रों के स्कोर की एक सूची लेता है, जिसमें प्रत्येक स्कोर 0 से 100 के बीच होता है, जो परीक्षा में छात्रों के स्कोर का प्रतिनिधित्व करता है। यह एक टपल लौटाता है जिसमें सबसे उच्च स्कोर, सबसे निम्न स्कोर, और इन स्कोरों से गणना की गई औसत स्कोर शामिल होता है।\n\n  Arguments:\n  - scores: छात्रों के परीक्षा स्कोर वाली एक Vec<i32>।\n\n  Returns:\n  - एक टपल (i32, i32, f64), जहाँ पहला तत्व सबसे उच्च स्कोर है, दूसरा सबसे निम्न स्कोर है, और तीसरा औसत स्कोर है जो दो दशमलव स्थानों तक गोल किया गया है।\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "hu": "Kiszámítja a legmagasabb pontszámot, legalacsonyabb pontszámot és az átlagos pontszámot egy hallgatói pontszámok listájából.\n\nA függvény egy egész számokat tartalmazó vektort vesz át, amelyek mindegyike 0 és 100 között van, és a hallgatók vizsgaeredményeit képviselik. Egy olyan tuple-t ad vissza, amely tartalmazza a legmagasabb pontszámot, a legalacsonyabb pontszámot és az ezen pontszámokból számított átlagos pontszámot.\n\nArgumentumok:\n- scores: Egy Vec<i32>, amely a hallgatók vizsgaeredményeit tartalmazza.\n\nVisszatérési érték:\n- Egy tuple (i32, i32, f64), ahol az első elem a legmagasabb pontszám, a második a legalacsonyabb pontszám, és a harmadik az átlagos pontszám, két tizedesjegyre kerekítve.\n\nPélda:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) visszaadja (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) visszaadja (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) visszaadja (50, 50, 50.00)"
    },
    "docstring_bertscore": {
      "sq": "0.98615387339882",
      "hy": "0.9765784986202711",
      "bn": "0.97650917661729",
      "bg": "0.9553592122750761",
      "zh": "0.981610600693409",
      "fr": "0.981485066292595",
      "de": "0.9680342141496744",
      "ha": "0.974106543528292",
      "hi": "0.9767006563046076",
      "hu": "0.9744851330345444"
    }
  },
  {
    "task_id": "Rust/8",
    "prompt": {
      "en": "/*\n  Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "sq": "/*\n  Llogarit shumën e pikëve për të gjitha nënvargjet jo-bosh të një vargu të dhënë, ku pika e një nënvargu përcaktohet si numri i karaktereve që shfaqen saktësisht një herë në të.\n\n  Argumentet:\n  - s: Një varg që përbëhet nga shkronjat e vogla të anglishtes.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson shumën totale të pikëve për të gjitha nënvargjet jo-bosh.\n\n  Shembull:\n  - sum_of_unique_chars_scores(\"abc\") kthen 10 (Pikët: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") kthen 4 (Pikët: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "hy": "/*\n  Հաշվում է մի տրված տողի բոլոր ոչ-դատարկ ենթատողերի գնահատականների գումարը, որտեղ ենթատողի գնահատականը սահմանվում է որպես այն նիշերի քանակը, որոնք հայտնվում են հենց մեկ անգամ:\n\n  Արգումենտներ:\n  - s: Տող, որը բաղկացած է փոքրատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է բոլոր ոչ-դատարկ ենթատողերի գնահատականների ընդհանուր գումարը:\n\n  Օրինակ:\n  - sum_of_unique_chars_scores(\"abc\") վերադարձնում է 10 (Գնահատականներ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") վերադարձնում է 4 (Գնահատականներ: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "bn": "/*\n  একটি প্রদত্ত স্ট্রিংয়ের সমস্ত নন-এম্পটি সাবস্ট্রিংয়ের স্কোরের যোগফল গণনা করে, যেখানে একটি সাবস্ট্রিংয়ের স্কোর সংজ্ঞায়িত করা হয় যেসব অক্ষর ঠিক একবার উপস্থিত হয় তার গণনা হিসাবে।\n\n  আর্গুমেন্টসমূহ:\n  - s: ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্নস:\n  - সমস্ত নন-এম্পটি সাবস্ট্রিংয়ের জন্য স্কোরের মোট যোগফল নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  উদাহরণ:\n  - sum_of_unique_chars_scores(\"abc\") 10 রিটার্ন করে (স্কোর: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 রিটার্ন করে (স্কোর: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "bg": "/*\n  Изчислява сумата от точките за всички непразни поднизове на даден низ, където точката на подниз е определена като броя на символите, които се появяват точно веднъж в него.\n\n  Аргументи:\n  - s: Низ, състоящ се от малки английски букви.\n\n  Връща:\n  - Цяло число, представляващо общата сума от точките за всички непразни поднизове.\n\n  Пример:\n  - sum_of_unique_chars_scores(\"abc\") връща 10 (Точки: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") връща 4 (Точки: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "zh": "/*\n  计算给定字符串所有非空子字符串的分数总和，其中子字符串的分数定义为其中恰好出现一次的字符的计数。\n\n  参数:\n  - s: 一个由小写英文字母组成的字符串。\n\n  返回:\n  - 一个整数，表示所有非空子字符串的分数总和。\n\n  示例:\n  - sum_of_unique_chars_scores(\"abc\") 返回 10 (分数: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 返回 4 (分数: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "fr": "/*\n  Calcule la somme des scores pour toutes les sous-chaînes non vides d'une chaîne donnée, où le score d'une sous-chaîne est défini comme le nombre de caractères qui apparaissent exactement une fois dans celle-ci.\n\n  Arguments:\n  - s: Une chaîne composée de lettres minuscules anglaises.\n\n  Renvoie:\n  - Un entier représentant la somme totale des scores pour toutes les sous-chaînes non vides.\n\n  Exemple:\n  - sum_of_unique_chars_scores(\"abc\") renvoie 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") renvoie 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "de": "/*\n  Berechnet die Summe der Punktzahlen für alle nicht-leeren Teilstrings eines gegebenen Strings, wobei die Punktzahl eines Teilstrings als die Anzahl der Zeichen definiert ist, die genau einmal darin vorkommen.\n\n  Argumente:\n  - s: Ein String, bestehend aus englischen Kleinbuchstaben.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Gesamtsumme der Punktzahlen für alle nicht-leeren Teilstrings darstellt.\n\n  Beispiel:\n  - sum_of_unique_chars_scores(\"abc\") gibt 10 zurück (Punktzahlen: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") gibt 4 zurück (Punktzahlen: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "ha": "/*\n  Lissafa jimillar maki na dukkan ƙananan rubutattun kirtani marasa komai na wani kirtani da aka bayar, inda maki na kowane ƙaramin kirtani aka ayyana shi a matsayin adadin haruffa da suka bayyana sau ɗaya kawai a ciki.\n\n  Huɗɗa:\n  - s: Wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi.\n\n  Mayarwa:\n  - Wani cikakken lamba da ke wakiltar jimillar maki na dukkan ƙananan rubutattun kirtani marasa komai.\n\n  Misali:\n  - sum_of_unique_chars_scores(\"abc\") yana mayar da 10 (Maki: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") yana mayar da 4 (Maki: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "hi": "/*\n  दिए गए स्ट्रिंग के सभी गैर-खाली उपस्ट्रिंग्स के स्कोर का योग गणना करता है, जहाँ उपस्ट्रिंग का स्कोर उन वर्णों की गिनती के रूप में परिभाषित किया गया है जो उसमें ठीक एक बार प्रकट होते हैं।\n\n  तर्क:\n  - s: एक स्ट्रिंग जिसमें छोटे अंग्रेजी अक्षर होते हैं।\n\n  लौटाता है:\n  - एक पूर्णांक जो सभी गैर-खाली उपस्ट्रिंग्स के स्कोर के कुल योग का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - sum_of_unique_chars_scores(\"abc\") 10 लौटाता है (स्कोर: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 लौटाता है (स्कोर: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "hu": "/*\n  Kiszámítja az összes nem üres részsztring pontszámának összegét egy adott sztringre, ahol a részsztring pontszámát az határozza meg, hogy hány karakter jelenik meg pontosan egyszer benne.\n\n  Argumentumok:\n  - s: Egy sztring, amely kisbetűs angol betűkből áll.\n\n  Visszatér:\n  - Egy egész szám, amely az összes nem üres részsztring pontszámának összegét képviseli.\n\n  Példa:\n  - sum_of_unique_chars_scores(\"abc\") visszatér 10 (Pontszámok: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") visszatér 4 (Pontszámok: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9966989616975812",
      "hy": "0.9864299696284585",
      "bn": "0.9863455517165187",
      "bg": "0.9974329009555051",
      "zh": "0.9699168329011231",
      "fr": "0.9957938030512052",
      "de": "0.9832401643394192",
      "ha": "0.9649181007319991",
      "hi": "0.9925092510704123",
      "hu": "0.9752005996670321"
    },
    "canonical_solution": "{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}",
    "instruction": {
      "en": "Write a Rust function `fn sum_of_unique_chars_scores(s: &str) -> i32` to solve the following problem:\nCalculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "sq": "Shkruani një funksion Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` për të zgjidhur problemin në vijim:\nLlogarit shumën e pikëve për të gjitha nënvargjet jo-bosh të një vargu të dhënë, ku pika e një nënvargu përcaktohet si numri i karaktereve që shfaqen saktësisht një herë në të.\n\n  Argumentet:\n  - s: Një varg që përbëhet nga shkronja të vogla të anglishtes.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson shumën totale të pikëve për të gjitha nënvargjet jo-bosh.\n\n  Shembull:\n  - sum_of_unique_chars_scores(\"abc\") kthen 10 (Pikët: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") kthen 4 (Pikët: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hy": "Գրեք Rust ֆունկցիա `fn sum_of_unique_chars_scores(s: &str) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված տողի բոլոր ոչ դատարկ ենթատողերի միավորների գումարը, որտեղ ենթատողի միավորը սահմանվում է որպես այն նշանների քանակը, որոնք հայտնվում են հենց մեկ անգամ:\n\n  Արգումենտներ:\n  - s: Տող, որը բաղկացած է փոքրատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - Թվային արժեք, որը ներկայացնում է բոլոր ոչ դատարկ ենթատողերի միավորների ընդհանուր գումարը:\n\n  Օրինակ:\n  - sum_of_unique_chars_scores(\"abc\") վերադարձնում է 10 (Միավորներ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") վերադարձնում է 4 (Միավորներ: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "bn": "Rust ফাংশন `fn sum_of_unique_chars_scores(s: &str) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত স্ট্রিং-এর সমস্ত নন-এম্পটি সাবস্ট্রিং-এর স্কোরের যোগফল হিসাব করে, যেখানে একটি সাবস্ট্রিং-এর স্কোর সংজ্ঞায়িত করা হয় সেই চরিত্রগুলির গণনা হিসেবে যা এতে ঠিক একবার উপস্থিত হয়।\n\n  আর্গুমেন্টসমূহ:\n  - s: ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা সমস্ত নন-এম্পটি সাবস্ট্রিং-এর স্কোরের মোট যোগফল উপস্থাপন করে।\n\n  উদাহরণ:\n  - sum_of_unique_chars_scores(\"abc\") 10 রিটার্ন করে (স্কোরসমূহ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 রিটার্ন করে (স্কোরসমূহ: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "bg": "Напишете функция на Rust `fn sum_of_unique_chars_scores(s: &str) -> i32`, за да решите следния проблем:\nИзчислява сумата от точките за всички непразни поднизове на даден низ, където точката на подниз е дефинирана като броят на символите, които се появяват точно веднъж в него.\n\n  Аргументи:\n  - s: Низ, състоящ се от малки английски букви.\n\n  Връща:\n  - Цяло число, представляващо общата сума от точките за всички непразни поднизове.\n\n  Пример:\n  - sum_of_unique_chars_scores(\"abc\") връща 10 (Точки: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") връща 4 (Точки: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "zh": "编写一个 Rust 函数 `fn sum_of_unique_chars_scores(s: &str) -> i32` 来解决以下问题：\n计算给定字符串的所有非空子字符串的分数之和，其中子字符串的分数定义为其中恰好出现一次的字符的数量。\n\n参数：\n- s: 一个由小写英文字母组成的字符串。\n\n返回：\n- 一个整数，表示所有非空子字符串的分数总和。\n\n示例：\n- sum_of_unique_chars_scores(\"abc\") 返回 10 (分数: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n- sum_of_unique_chars_scores(\"aab\") 返回 4 (分数: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "fr": "Écrire une fonction Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` pour résoudre le problème suivant :\nCalcule la somme des scores pour toutes les sous-chaînes non vides d'une chaîne donnée, où le score d'une sous-chaîne est défini comme le nombre de caractères qui apparaissent exactement une fois dans celle-ci.\n\n  Arguments :\n  - s : Une chaîne composée de lettres minuscules anglaises.\n\n  Renvoie :\n  - Un entier représentant la somme totale des scores pour toutes les sous-chaînes non vides.\n\n  Exemple :\n  - sum_of_unique_chars_scores(\"abc\") renvoie 10 (Scores : a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") renvoie 4 (Scores : a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "de": "Schreiben Sie eine Rust-Funktion `fn sum_of_unique_chars_scores(s: &str) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Summe der Punktzahlen für alle nicht-leeren Teilstrings eines gegebenen Strings, wobei die Punktzahl eines Teilstrings als die Anzahl der Zeichen definiert ist, die genau einmal darin vorkommen.\n\n  Argumente:\n  - s: Ein String, bestehend aus englischen Kleinbuchstaben.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Gesamtsumme der Punktzahlen für alle nicht-leeren Teilstrings darstellt.\n\n  Beispiel:\n  - sum_of_unique_chars_scores(\"abc\") gibt 10 zurück (Punktzahlen: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") gibt 4 zurück (Punktzahlen: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "ha": "Rubuta aikin Rust `fn sum_of_unique_chars_scores(s: &str) -> i32` don warware matsalar mai zuwa:\nLissafa jimillar maki na dukkan ƙananan rubutun da ba komai ba na kowane igiyar rubutu, inda maki na ƙaramin rubutu aka ayyana shi azaman adadin haruffa da suka bayyana sau ɗaya kawai a ciki.\n\n  Huɗɗa:\n  - s: Wani igiyar rubutu da ya ƙunshi ƙananan haruffan Ingilishi.\n\n  Mayar da:\n  - Wani lamba mai wakiltar jimillar maki na dukkan ƙananan rubutun da ba komai ba.\n\n  Misali:\n  - sum_of_unique_chars_scores(\"abc\") yana mayar da 10 (Maki: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") yana mayar da 4 (Maki: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hi": "Rust फ़ंक्शन `fn sum_of_unique_chars_scores(s: &str) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए स्ट्रिंग के सभी गैर-खाली उपस्ट्रिंग्स के स्कोर का योग गणना करता है, जहाँ उपस्ट्रिंग का स्कोर उस में ठीक एक बार प्रकट होने वाले वर्णों की गिनती के रूप में परिभाषित किया गया है।\n\n  तर्क:\n  - s: छोटे अक्षरों वाले अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  लौटाता है:\n  - एक पूर्णांक जो सभी गैर-खाली उपस्ट्रिंग्स के स्कोर के कुल योग का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - sum_of_unique_chars_scores(\"abc\") 10 लौटाता है (स्कोर: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 लौटाता है (स्कोर: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hu": "Írj egy Rust függvényt `fn sum_of_unique_chars_scores(s: &str) -> i32` a következő probléma megoldására:\nKiszámítja az összes nem üres részsztring pontszámának összegét egy adott sztring esetén, ahol egy részsztring pontszámát azon karakterek száma határozza meg, amelyek pontosan egyszer fordulnak elő benne.\n\n  Argumentumok:\n  - s: Egy sztring, amely kisbetűs angol betűkből áll.\n\n  Visszatérési érték:\n  - Egy egész szám, amely az összes nem üres részsztring pontszámának összegét képviseli.\n\n  Példa:\n  - sum_of_unique_chars_scores(\"abc\") visszatér 10 (Pontszámok: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") visszatér 4 (Pontszámok: a=0, a=0, b=1, aa=0, ab=1, aab=1)"
    },
    "instruction_bertscore": {
      "sq": "0.9927497924618456",
      "hy": "0.9843338232173974",
      "bn": "0.9836247127571028",
      "bg": "0.9849289198389779",
      "zh": "0.9866373397462589",
      "fr": "0.9954179943702872",
      "de": "0.9835103016576267",
      "ha": "0.971101067232853",
      "hi": "0.9842654943663214",
      "hu": "0.9822714439711121"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(sum_of_unique_chars_scores(\"abc\"), 10); // a=1, b=1, c=1, ab=2, bc=2, abc=3\n        assert_eq!(sum_of_unique_chars_scores(\"aab\"), 6);  // a=1, a=1, b=1, aa=0, ab=2, aab=1\n        assert_eq!(sum_of_unique_chars_scores(\"ababc\"), 21);\n    }\n\n\n}",
    "entry_point": "sum_of_unique_chars_scores",
    "signature": "fn sum_of_unique_chars_scores(s: &str) -> i32",
    "docstring": {
      "en": "Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "sq": "Llogarit shumën e pikëve për të gjitha nënvargjet jo bosh të një vargu të dhënë, ku pika e një nënvargu përcaktohet si numri i karaktereve që shfaqen saktësisht një herë në të.\n\n  Argumentet:\n  - s: Një varg që përbëhet nga shkronjat e vogla të anglishtes.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson shumën totale të pikëve për të gjitha nënvargjet jo bosh.\n\n  Shembull:\n  - sum_of_unique_chars_scores(\"abc\") kthen 10 (Pikët: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") kthen 4 (Pikët: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hy": "Հաշվում է տրված տողի բոլոր ոչ դատարկ ենթատողերի միավորների գումարը, որտեղ ենթատողի միավորը սահմանվում է որպես այնպիսի սիմվոլների քանակը, որոնք հայտնվում են հենց մեկ անգամ:\n\n  Արձանագրություններ:\n  - s: Տող, որը բաղկացած է փոքրատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - Թիվ, որը ներկայացնում է բոլոր ոչ դատարկ ենթատողերի միավորների ընդհանուր գումարը:\n\n  Օրինակ:\n  - sum_of_unique_chars_scores(\"abc\") վերադարձնում է 10 (Միավորներ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") վերադարձնում է 4 (Միավորներ: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "bn": "প্রদত্ত স্ট্রিংয়ের সমস্ত অ-খালি সাবস্ট্রিংয়ের স্কোরের যোগফল গণনা করে, যেখানে একটি সাবস্ট্রিংয়ের স্কোর সংজ্ঞায়িত করা হয় এতে ঠিক একবার উপস্থিত হওয়া অক্ষরের সংখ্যা হিসাবে।\n\n  আর্গুমেন্টস:\n  - s: ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা সমস্ত অ-খালি সাবস্ট্রিংয়ের জন্য স্কোরের মোট যোগফল উপস্থাপন করে।\n\n  উদাহরণ:\n  - sum_of_unique_chars_scores(\"abc\") 10 রিটার্ন করে (স্কোর: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 রিটার্ন করে (স্কোর: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "bg": "Изчислява сумата от точките за всички непразни поднизове на даден низ, където точката на подниза се дефинира като броя на символите, които се появяват точно веднъж в него.\n\nАргументи:\n- s: Низ, състоящ се от малки английски букви.\n\nВръща:\n- Цяло число, представляващо общата сума от точките за всички непразни поднизове.\n\nПример:\n- sum_of_unique_chars_scores(\"abc\") връща 10 (Точки: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n- sum_of_unique_chars_scores(\"aab\") връща 4 (Точки: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "zh": "计算给定字符串的所有非空子字符串的分数总和，其中子字符串的分数定义为其中恰好出现一次的字符的数量。\n\n参数：\n- s: 一个由小写英文字母组成的字符串。\n\n返回：\n- 一个整数，表示所有非空子字符串的分数总和。\n\n示例：\n- sum_of_unique_chars_scores(\"abc\") 返回 10 （分数：a=1, b=1, c=1, ab=2, bc=2, abc=3）\n- sum_of_unique_chars_scores(\"aab\") 返回 4 （分数：a=0, a=0, b=1, aa=0, ab=1, aab=1）",
      "fr": "Calcule la somme des scores pour toutes les sous-chaînes non vides d'une chaîne donnée, où le score d'une sous-chaîne est défini comme le nombre de caractères qui apparaissent exactement une fois dans celle-ci.\n\n  Arguments:\n  - s: Une chaîne composée de lettres minuscules anglaises.\n\n  Retourne:\n  - Un entier représentant la somme totale des scores pour toutes les sous-chaînes non vides.\n\n  Exemple:\n  - sum_of_unique_chars_scores(\"abc\") retourne 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") retourne 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "de": "Berechnet die Summe der Punktzahlen für alle nicht-leeren Teilstrings eines gegebenen Strings, wobei die Punktzahl eines Teilstrings als die Anzahl der Zeichen definiert ist, die genau einmal darin vorkommen.\n\n  Argumente:\n  - s: Ein String, bestehend aus englischen Kleinbuchstaben.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Gesamtsumme der Punktzahlen für alle nicht-leeren Teilstrings darstellt.\n\n  Beispiel:\n  - sum_of_unique_chars_scores(\"abc\") gibt 10 zurück (Punktzahlen: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") gibt 4 zurück (Punktzahlen: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "ha": "Lissafa jimillar maki na dukkan ƙananan rubutattun kirtani marasa komai na wani kirtani da aka bayar, inda maki na kowane ƙaramin kirtani aka ayyana shi a matsayin adadin haruffa da suka bayyana sau ɗaya kawai a ciki.\n\n  Huɗɗa:\n  - s: Wani igiyar haruffa da ya ƙunshi ƙananan haruffan Ingilishi.\n\n  Komawa:\n  - Wani lamba wanda ke wakiltar jimlar maki na dukkan ƙananan igiyoyi marasa komai.\n\n  Misali:\n  - sum_of_unique_chars_scores(\"abc\") yana dawowa 10 (Maki: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") yana dawowa 4 (Maki: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hi": "गणना करता है कि दिए गए स्ट्रिंग के सभी गैर-खाली उपस्ट्रिंग्स के लिए स्कोर का योग, जहाँ उपस्ट्रिंग का स्कोर उन वर्णों की गिनती के रूप में परिभाषित किया गया है जो उसमें केवल एक बार प्रकट होते हैं।\n\n  तर्क:\n  - s: एक स्ट्रिंग जो छोटे अंग्रेजी अक्षरों से बनी होती है।\n\n  वापसी:\n  - एक पूर्णांक जो सभी गैर-खाली उपस्ट्रिंग्स के लिए स्कोर के कुल योग का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - sum_of_unique_chars_scores(\"abc\") 10 लौटाता है (स्कोर: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 लौटाता है (स्कोर: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hu": "Kiszámítja az összes nem üres részsztring pontszámának összegét egy adott sztring esetén, ahol a részsztring pontszámát az egyszer pontosan egyszer előforduló karakterek száma határozza meg.\n\n  Argumentumok:\n  - s: Egy sztring, amely kisbetűs angol betűkből áll.\n\n  Visszatér:\n  - Egy egész szám, amely az összes nem üres részsztring pontszámának összegét jelenti.\n\n  Példa:\n  - sum_of_unique_chars_scores(\"abc\") visszatér 10 (Pontszámok: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") visszatér 4 (Pontszámok: a=0, a=0, b=1, aa=0, ab=1, aab=1)"
    },
    "docstring_bertscore": {
      "sq": "0.9946780962009323",
      "hy": "0.9745272426753239",
      "bn": "0.9885656434853456",
      "bg": "0.9962508515579664",
      "zh": "0.9671078020525277",
      "fr": "0.9935621907202783",
      "de": "0.9807741681588711",
      "ha": "0.9837005895626582",
      "hi": "0.9926097580432159",
      "hu": "0.9699813877749595"
    }
  },
  {
    "task_id": "Rust/9",
    "prompt": {
      "en": "/*\n  Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "sq": "/*\n  Gjeneron një sekuencë numrash të plotë ku secili numër pasues është gjysma e numrit të mëparshëm, i rrumbullakosur poshtë, duke filluar nga një vlerë fillestare.\n\n  Argumentet:\n  - initial_value: Një numër i plotë që përfaqëson vlerën fillestare të sekuencës.\n\n  Kthen:\n  - Një vektor numrash të plotë që përfaqëson sekuencën ku secili element është gjysma e paraardhësit të tij, duke ndaluar kur vlera bëhet më pak se 1.\n\n  Shembull:\n  - generate_dividing_sequence(20) kthen [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) kthen [5, 2, 1]\n  - generate_dividing_sequence(1) kthen [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "hy": "/*\n  Գեներացնում է ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր հաջորդ թիվը նախորդի կեսն է, կլորացված ներքև, սկսած սկզբնական արժեքից:\n\n  Արգումենտներ:\n  - initial_value: Ամբողջ թիվ, որը ներկայացնում է հաջորդականության մեկնարկային արժեքը:\n\n  Վերադարձնում է:\n  - Ամբողջ թվերի վեկտոր, որը ներկայացնում է հաջորդականությունը, որտեղ յուրաքանչյուր տարր նախորդի կեսն է, կանգ առնելով, երբ արժեքը դառնում է փոքր քան 1:\n\n  Օրինակ:\n  - generate_dividing_sequence(20) վերադարձնում է [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) վերադարձնում է [5, 2, 1]\n  - generate_dividing_sequence(1) վերադարձնում է [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "bn": "/*\n  একটি পূর্ণসংখ্যার ক্রম তৈরি করে যেখানে প্রতিটি পরবর্তী পূর্ণসংখ্যা পূর্ববর্তীটির অর্ধেক, নিচের দিকে গোলাকার, একটি প্রাথমিক মান থেকে শুরু করে।\n\n  আর্গুমেন্টসমূহ:\n  - initial_value: ক্রমের শুরুর মানকে উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - পূর্ণসংখ্যার একটি ভেক্টর যা ক্রমকে উপস্থাপন করে যেখানে প্রতিটি উপাদান তার পূর্বসূরির অর্ধেক, যখন মান 1 এর কম হয়ে যায় তখন থামে।\n\n  উদাহরণ:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "bg": "/*\n  Генерира последователност от цели числа, където всяко следващо число е половината от предишното, закръглено надолу, започвайки от начална стойност.\n\n  Аргументи:\n  - initial_value: Цяло число, представляващо началната стойност на последователността.\n\n  Връща:\n  - Вектор от цели числа, представляващ последователността, където всеки елемент е половината от предшественика си, спирайки когато стойността стане по-малка от 1.\n\n  Пример:\n  - generate_dividing_sequence(20) връща [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) връща [5, 2, 1]\n  - generate_dividing_sequence(1) връща [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "zh": "/*\n  生成一个整数序列，其中每个后续整数是前一个整数的一半，向下取整，从初始值开始。\n\n  参数:\n  - initial_value: 一个整数，表示序列的起始值。\n\n  返回:\n  - 一个整数向量，表示序列，其中每个元素是其前一个元素的一半，当值小于1时停止。\n\n  示例:\n  - generate_dividing_sequence(20) 返回 [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) 返回 [5, 2, 1]\n  - generate_dividing_sequence(1) 返回 [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "fr": "/*\n  Génère une séquence d'entiers où chaque entier suivant est la moitié de celui qui le précède, arrondi à l'entier inférieur, en commençant par une valeur initiale.\n\n  Arguments:\n  - initial_value: Un entier représentant la valeur de départ de la séquence.\n\n  Retourne:\n  - Un vecteur d'entiers représentant la séquence où chaque élément est la moitié de son prédécesseur, s'arrêtant lorsque la valeur devient inférieure à 1.\n\n  Exemple:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "de": "/*\n  Erzeugt eine Folge von ganzen Zahlen, bei der jede nachfolgende Zahl die Hälfte der vorherigen ist, abgerundet, beginnend mit einem Anfangswert.\n\n  Argumente:\n  - initial_value: Ein ganzzahliger Wert, der den Startwert der Folge darstellt.\n\n  Rückgabewert:\n  - Ein Vektor von ganzen Zahlen, der die Folge darstellt, bei der jedes Element die Hälfte seines Vorgängers ist, und endet, wenn der Wert kleiner als 1 wird.\n\n  Beispiel:\n  - generate_dividing_sequence(20) gibt [20, 10, 5, 2, 1] zurück\n  - generate_dividing_sequence(5) gibt [5, 2, 1] zurück\n  - generate_dividing_sequence(1) gibt [1] zurück\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "ha": "/*\n  Yana samar da jerin lambobi inda kowanne lamba na gaba rabin wanda ya gabace shi ne, an zagaye kasa, farawa daga wata kima ta farko.\n\n  Huɗa:\n  - initial_value: Wani lamba wanda ke wakiltar kimar farawa na jerin.\n\n  Komawa:\n  - Wani vector na lambobi wanda ke wakiltar jerin inda kowanne abu rabin wanda ya gabace shi ne, yana tsayawa lokacin da kimar ta zama ƙasa da 1.\n\n  Misali:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "hi": "/*\n  एक अनुक्रम उत्पन्न करता है जहाँ प्रत्येक क्रमिक पूर्णांक पिछले वाले का आधा होता है, नीचे की ओर गोल करते हुए, एक प्रारंभिक मान से शुरू होता है।\n\n  तर्क:\n  - initial_value: अनुक्रम के प्रारंभिक मान को दर्शाने वाला एक पूर्णांक।\n\n  लौटाता है:\n  - पूर्णांकों का एक वेक्टर जो अनुक्रम का प्रतिनिधित्व करता है जहाँ प्रत्येक तत्व अपने पूर्ववर्ती का आधा होता है, जब मान 1 से कम हो जाता है तब रुक जाता है।\n\n  उदाहरण:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] लौटाता है\n  - generate_dividing_sequence(5) [5, 2, 1] लौटाता है\n  - generate_dividing_sequence(1) [1] लौटाता है\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "hu": "/*\n  Generál egy egész számokból álló sorozatot, ahol minden következő egész szám az előző fele, lefelé kerekítve, kezdve egy kezdeti értéktől.\n\n  Argumentumok:\n  - initial_value: Egy egész szám, amely a sorozat kezdő értékét jelenti.\n\n  Visszatér:\n  - Egy egész számokat tartalmazó vektor, amely a sorozatot képviseli, ahol minden elem az elődjének a fele, és megáll, amikor az érték kisebb lesz, mint 1.\n\n  Példa:\n  - generate_dividing_sequence(20) visszaadja [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) visszaadja [5, 2, 1]\n  - generate_dividing_sequence(1) visszaadja [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>"
    },
    "prompt_bertscore": {
      "sq": "0.99304237501311",
      "hy": "0.9905799541794205",
      "bn": "0.9943386368797437",
      "bg": "0.9928314295484509",
      "zh": "0.9813456277651085",
      "fr": "0.9814089908566586",
      "de": "0.9817764570615731",
      "ha": "0.978143507392445",
      "hi": "0.9881797046549948",
      "hu": "0.988550944837149"
    },
    "canonical_solution": "{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}",
    "instruction": {
      "en": "Write a Rust function `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` to solve the following problem:\nGenerates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "sq": "Shkruani një funksion në Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` për të zgjidhur problemin e mëposhtëm:\nGjeneron një sekuencë të numrave të plotë ku secili numër pasues është gjysma e atij të mëparshëm, i rrumbullakosur poshtë, duke filluar nga një vlerë fillestare.\n\n  Argumentet:\n  - initial_value: Një numër i plotë që përfaqëson vlerën fillestare të sekuencës.\n\n  Kthen:\n  - Një vektor të numrave të plotë që përfaqëson sekuencën ku secili element është gjysma e paraardhësit të tij, duke ndaluar kur vlera bëhet më pak se 1.\n\n  Shembull:\n  - generate_dividing_sequence(20) kthen [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) kthen [5, 2, 1]\n  - generate_dividing_sequence(1) kthen [1]",
      "hy": "Գրեք Rust ֆունկցիա `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` հետևյալ խնդիրը լուծելու համար:\nԳեներացնում է ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր հաջորդ ամբողջ թիվը նախորդի կեսն է, կլորացված ներքև, սկսած նախնական արժեքից:\n\n  Արգումենտներ:\n  - initial_value: Ամբողջ թիվ, որը ներկայացնում է հաջորդականության մեկնարկային արժեքը:\n\n  Վերադարձնում է:\n  - Վեկտոր ամբողջ թվերի, որը ներկայացնում է հաջորդականությունը, որտեղ յուրաքանչյուր տարր նախորդի կեսն է, դադարելով, երբ արժեքը դառնում է պակաս քան 1:\n\n  Օրինակ:\n  - generate_dividing_sequence(20) վերադարձնում է [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) վերադարձնում է [5, 2, 1]\n  - generate_dividing_sequence(1) վերադարձնում է [1]",
      "bn": "Rust ফাংশন `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার ক্রম তৈরি করে যেখানে প্রতিটি পরবর্তী পূর্ণসংখ্যা পূর্ববর্তী সংখ্যার অর্ধেক, নিচের দিকে গোলাকার, একটি প্রাথমিক মান থেকে শুরু করে।\n\n  আর্গুমেন্টসমূহ:\n  - initial_value: ক্রমের প্রারম্ভিক মান উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - পূর্ণসংখ্যার একটি ভেক্টর যা ক্রম উপস্থাপন করে যেখানে প্রতিটি উপাদান তার পূর্বসূরির অর্ধেক, যখন মান 1 এর কম হয়ে যায় তখন থামে।\n\n  উদাহরণ:\n  - generate_dividing_sequence(20) রিটার্ন করে [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) রিটার্ন করে [5, 2, 1]\n  - generate_dividing_sequence(1) রিটার্ন করে [1]",
      "bg": "Напишете функция на Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` за решаване на следния проблем:\nГенерира последователност от цели числа, където всяко следващо число е половината от предишното, закръглено надолу, започвайки от начална стойност.\n\n  Аргументи:\n  - initial_value: Цяло число, представляващо началната стойност на последователността.\n\n  Връща:\n  - Вектор от цели числа, представляващ последователността, където всеки елемент е половината от своя предшественик, спирайки когато стойността стане по-малка от 1.\n\n  Пример:\n  - generate_dividing_sequence(20) връща [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) връща [5, 2, 1]\n  - generate_dividing_sequence(1) връща [1]",
      "zh": "编写一个 Rust 函数 `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` 来解决以下问题：\n生成一个整数序列，其中每个后续整数是前一个整数的一半，向下取整，从初始值开始。\n\n参数：\n- initial_value: 一个整数，表示序列的起始值。\n\n返回：\n- 一个整数向量，表示序列，其中每个元素是其前驱的一半，当值小于 1 时停止。\n\n示例：\n- generate_dividing_sequence(20) 返回 [20, 10, 5, 2, 1]\n- generate_dividing_sequence(5) 返回 [5, 2, 1]\n- generate_dividing_sequence(1) 返回 [1]",
      "fr": "Écrire une fonction Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` pour résoudre le problème suivant :\nGénère une séquence d'entiers où chaque entier suivant est la moitié du précédent, arrondi à l'entier inférieur, en commençant par une valeur initiale.\n\n  Arguments :\n  - initial_value : Un entier représentant la valeur de départ de la séquence.\n\n  Renvoie :\n  - Un vecteur d'entiers représentant la séquence où chaque élément est la moitié de son prédécesseur, s'arrêtant lorsque la valeur devient inférieure à 1.\n\n  Exemple :\n  - generate_dividing_sequence(20) renvoie [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) renvoie [5, 2, 1]\n  - generate_dividing_sequence(1) renvoie [1]",
      "de": "Schreiben Sie eine Rust-Funktion `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>`, um das folgende Problem zu lösen:\nGeneriert eine Sequenz von ganzen Zahlen, bei der jede nachfolgende Zahl die Hälfte der vorherigen ist, abgerundet, beginnend mit einem Anfangswert.\n\n  Argumente:\n  - initial_value: Eine ganze Zahl, die den Startwert der Sequenz darstellt.\n\n  Rückgabewert:\n  - Ein Vektor von ganzen Zahlen, der die Sequenz darstellt, bei der jedes Element die Hälfte seines Vorgängers ist und endet, wenn der Wert kleiner als 1 wird.\n\n  Beispiel:\n  - generate_dividing_sequence(20) gibt [20, 10, 5, 2, 1] zurück\n  - generate_dividing_sequence(5) gibt [5, 2, 1] zurück\n  - generate_dividing_sequence(1) gibt [1] zurück",
      "ha": "Rubuta aikin Rust `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` don warware matsalar mai zuwa:\nYana samar da jerin lambobi inda kowanne lamba na gaba yake zama rabin wanda ya gabace shi, an zagaye ƙasa, farawa daga wata ƙima ta farko.\n\n  Huɗɗa:\n  - initial_value: Wani lamba wanda ke wakiltar ƙimar farawa na jerin.\n\n  Komawa:\n  - Wani vector na lambobi wanda ke wakiltar jerin inda kowanne abu yake rabin wanda ya gabace shi, yana tsayawa lokacin da ƙimar ta zama ƙasa da 1.\n\n  Misali:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "hi": "Rust फ़ंक्शन `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांकों की अनुक्रम उत्पन्न करता है जहाँ प्रत्येक क्रमिक पूर्णांक अपने पूर्ववर्ती का आधा होता है, नीचे की ओर गोल किया जाता है, एक प्रारंभिक मान से शुरू होता है।\n\n  तर्क:\n  - initial_value: अनुक्रम के प्रारंभिक मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\n\n  लौटाता है:\n  - पूर्णांकों का एक वेक्टर जो अनुक्रम का प्रतिनिधित्व करता है जहाँ प्रत्येक तत्व अपने पूर्ववर्ती का आधा होता है, जब मान 1 से कम हो जाता है तो रुक जाता है।\n\n  उदाहरण:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] लौटाता है\n  - generate_dividing_sequence(5) [5, 2, 1] लौटाता है\n  - generate_dividing_sequence(1) [1] लौटाता है",
      "hu": "Írj egy Rust függvényt `fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>` a következő probléma megoldására:\nGenerál egy egész számokból álló sorozatot, ahol minden következő egész szám az előző fele, lefelé kerekítve, kiindulva egy kezdeti értékből.\n\n  Argumentumok:\n  - initial_value: Egy egész szám, amely a sorozat kezdő értékét jelöli.\n\n  Visszatér:\n  - Egy vektor egész számokkal, amely a sorozatot képviseli, ahol minden elem az elődje fele, és a sorozat akkor áll meg, amikor az érték kisebb lesz, mint 1.\n\n  Példa:\n  - generate_dividing_sequence(20) visszaadja [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) visszaadja [5, 2, 1]\n  - generate_dividing_sequence(1) visszaadja [1]"
    },
    "instruction_bertscore": {
      "sq": "0.9915194758817154",
      "hy": "0.9941620544710036",
      "bn": "0.976714163170518",
      "bg": "0.9945009179010491",
      "zh": "0.9760118061431786",
      "fr": "0.9850320090067349",
      "de": "0.9863483325418532",
      "ha": "0.9799858041765437",
      "hi": "0.9784950831668768",
      "hu": "0.9833784110846195"
    },
    "level": "easy",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(generate_dividing_sequence(20), vec![20, 10, 5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(5), vec![5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(1), vec![1]);\n        assert_eq!(generate_dividing_sequence(15), vec![15, 7, 3, 1]);        \n    }\n    \n\n}\n ",
    "entry_point": "generate_dividing_sequence",
    "signature": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
    "docstring": {
      "en": "Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "sq": "Gjeneron një sekuencë të numrave të plotë ku çdo numër pasues është gjysma e numrit të mëparshëm, i rrumbullakosur poshtë, duke filluar nga një vlerë fillestare.\n\n  Argumentet:\n  - initial_value: Një numër i plotë që përfaqëson vlerën fillestare të sekuencës.\n\n  Kthen:\n  - Një vektor të numrave të plotë që përfaqëson sekuencën ku çdo element është gjysma e paraardhësit të tij, duke ndaluar kur vlera bëhet më pak se 1.\n\n  Shembull:\n  - generate_dividing_sequence(20) kthen [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) kthen [5, 2, 1]\n  - generate_dividing_sequence(1) kthen [1]",
      "hy": "Ստեղծում է ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր հաջորդ ամբողջ թիվը նախորդի կեսն է, կլորացված ներքև, սկսելով սկզբնական արժեքից:\n\n  Արգումենտներ:\n  - initial_value: Ամբողջ թիվ, որը ներկայացնում է հաջորդականության մեկնարկային արժեքը:\n\n  Վերադարձնում է:\n  - Ամբողջ թվերի վեկտոր, որը ներկայացնում է հաջորդականությունը, որտեղ յուրաքանչյուր տարր նախորդի կեսն է, կանգ առնելով, երբ արժեքը դառնում է պակաս քան 1:\n\n  Օրինակ:\n  - generate_dividing_sequence(20) վերադարձնում է [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) վերադարձնում է [5, 2, 1]\n  - generate_dividing_sequence(1) վերադարձնում է [1]",
      "bn": "একটি পূর্ণসংখ্যার ক্রম তৈরি করে যেখানে প্রতিটি পরবর্তী পূর্ণসংখ্যা পূর্ববর্তীটির অর্ধেক হয়, নিচের দিকে গোল করে, একটি প্রাথমিক মান থেকে শুরু করে।\n\nArguments:\n- initial_value: পূর্ণসংখ্যা যা ক্রমের শুরুর মানকে উপস্থাপন করে।\n\nReturns:\n- পূর্ণসংখ্যার একটি ভেক্টর যা ক্রমকে উপস্থাপন করে যেখানে প্রতিটি উপাদান তার পূর্বসূরীর অর্ধেক, যখন মান 1 এর কম হয়ে যায় তখন থামে।\n\nExample:\n- generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n- generate_dividing_sequence(5) returns [5, 2, 1]\n- generate_dividing_sequence(1) returns [1]",
      "bg": "Генерира последователност от цели числа, където всяко следващо число е половината от предишното, закръглено надолу, започвайки от начална стойност.\n\nАргументи:\n- initial_value: Цяло число, представляващо началната стойност на последователността.\n\nВръща:\n- Вектор от цели числа, представляващ последователността, където всеки елемент е половината от предшественика си, спирайки когато стойността стане по-малка от 1.\n\nПример:\n- generate_dividing_sequence(20) връща [20, 10, 5, 2, 1]\n- generate_dividing_sequence(5) връща [5, 2, 1]\n- generate_dividing_sequence(1) връща [1]",
      "zh": "生成一个整数序列，其中每个后续整数是前一个整数的一半，向下取整，从初始值开始。\n\n  参数:\n  - initial_value: 一个整数，表示序列的起始值。\n\n  返回:\n  - 一个整数向量，表示序列，其中每个元素是其前一个元素的一半，当值小于1时停止。\n\n  示例:\n  - generate_dividing_sequence(20) 返回 [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) 返回 [5, 2, 1]\n  - generate_dividing_sequence(1) 返回 [1]",
      "fr": "Génère une séquence d'entiers où chaque entier suivant est la moitié de celui qui le précède, arrondi à l'entier inférieur, en commençant par une valeur initiale.\n\n  Arguments:\n  - initial_value: Un entier représentant la valeur de départ de la séquence.\n\n  Retourne:\n  - Un vecteur d'entiers représentant la séquence où chaque élément est la moitié de son prédécesseur, s'arrêtant lorsque la valeur devient inférieure à 1.\n\n  Exemple:\n  - generate_dividing_sequence(20) retourne [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) retourne [5, 2, 1]\n  - generate_dividing_sequence(1) retourne [1]",
      "de": "Erzeugt eine Folge von ganzen Zahlen, bei der jede nachfolgende Zahl die Hälfte der vorherigen ist, abgerundet, beginnend mit einem Anfangswert.\n\n  Argumente:\n  - initial_value: Eine ganze Zahl, die den Startwert der Folge darstellt.\n\n  Rückgabewerte:\n  - Ein Vektor von ganzen Zahlen, der die Folge darstellt, bei der jedes Element die Hälfte seines Vorgängers ist, und endet, wenn der Wert kleiner als 1 wird.\n\n  Beispiel:\n  - generate_dividing_sequence(20) gibt [20, 10, 5, 2, 1] zurück\n  - generate_dividing_sequence(5) gibt [5, 2, 1] zurück\n  - generate_dividing_sequence(1) gibt [1] zurück",
      "ha": "Yana samar da jerin lambobi inda kowanne lamba na gaba rabin wanda ya gabace shi ne, an zagaye kasa, farawa daga wata kima ta farko.\n\n  Huɗɗa:\n  - initial_value: Wani lamba wanda ke wakiltar ƙimar farawa na jerin.\n\n  Dawowa:\n  - Wani vector na lambobi wanda ke wakiltar jerin inda kowane abu yake rabin wanda ya gabace shi, yana tsayawa lokacin da ƙimar ta zama ƙasa da 1.\n\n  Misali:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "hi": "आधारिक मान से शुरू होकर प्रत्येक क्रमिक पूर्णांक अपने पूर्ववर्ती का आधा होता है, नीचे की ओर पूर्णांकित, का अनुक्रम उत्पन्न करता है।\n\n  तर्क:\n  - initial_value: अनुक्रम के प्रारंभिक मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\n\n  वापसी:\n  - पूर्णांकों का एक वेक्टर जो अनुक्रम का प्रतिनिधित्व करता है, जहाँ प्रत्येक तत्व अपने पूर्ववर्ती का आधा होता है, अनुक्रम तब रुकता है जब मान 1 से कम हो जाता है।\n\n  उदाहरण:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] लौटाता है\n  - generate_dividing_sequence(5) [5, 2, 1] लौटाता है\n  - generate_dividing_sequence(1) [1] लौटाता है",
      "hu": "Generál egy egész számokból álló sorozatot, ahol minden következő egész szám az előző fele, lefelé kerekítve, egy kezdeti értéktől kezdve.\n\n  Argumentumok:\n  - initial_value: Egy egész szám, amely a sorozat kezdő értékét jelenti.\n\n  Visszatér:\n  - Egy egész számokból álló vektor, amely a sorozatot képviseli, ahol minden elem az elődjének fele, és megáll, amikor az érték kisebb lesz, mint 1.\n\n  Példa:\n  - generate_dividing_sequence(20) visszaadja [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) visszaadja [5, 2, 1]\n  - generate_dividing_sequence(1) visszaadja [1]"
    },
    "docstring_bertscore": {
      "sq": "0.9889499932726481",
      "hy": "0.9780998087086173",
      "bn": "0.9928254706370199",
      "bg": "0.9919826819302888",
      "zh": "0.9742515437064474",
      "fr": "0.9742612765951182",
      "de": "0.9779740756774223",
      "ha": "0.9815188334573709",
      "hi": "0.9554873288708436",
      "hu": "0.9902961113649216"
    }
  },
  {
    "task_id": "Rust/10",
    "prompt": {
      "en": "/*\n  Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "sq": "/*\n  Zgjeron një varg të kompresuar ku karakteret e njëpasnjëshme përfaqësohen nga karakteri i ndjekur nga numri i tij.\n  Numri është një shifër e vetme (1-9), dhe specifikon sa herë karakteri shfaqet në mënyrë të njëpasnjëshme. Nëse një karakter shfaqet vetëm një herë, ai nuk ndiqet nga një numër.\n\n  Argumentet:\n  - compressed: Një varg që përmban formatin e kompresuar, i përbërë nga karaktere dhe numra njëshifrorë.\n\n  Kthen:\n  - Një varg që përfaqëson formën e zgjeruar të vargut të kompresuar.\n\n  Shembull:\n  - expand_compressed_string(\"a3b2c\") kthen \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") kthen \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") kthen \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "hy": "/*\n  Ընդլայնում է սեղմված տողը, որտեղ հաջորդական նիշերը ներկայացված են նիշով, որին հաջորդում է դրա քանակը:\n  Քանակը միանիշ թիվ է (1-9), և այն ցույց է տալիս, թե քանի անգամ է նիշը հայտնվում հաջորդաբար: Եթե նիշը հայտնվում է միայն մեկ անգամ, ապա այն չի հաջորդվում քանակով:\n\n  Արգումենտներ:\n  - compressed: Տող, որը պարունակում է սեղմված ձևաչափը, բաղկացած նիշերից և միանիշ թվերից:\n\n  Վերադարձնում է:\n  - Տող, որը ներկայացնում է սեղմված տողի ընդլայնված ձևը:\n\n  Օրինակ:\n  - expand_compressed_string(\"a3b2c\") վերադարձնում է \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") վերադարձնում է \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") վերադարձնում է \"xxxxxxxxxyzz\"\n*/ \n\nfn expand_compressed_string(compressed: &str) -> String ",
      "bn": "/*\n  একটি সংকুচিত স্ট্রিং প্রসারিত করে যেখানে পরপর অক্ষরগুলি অক্ষর দ্বারা উপস্থাপিত হয় এবং তারপরে তার সংখ্যা থাকে।\n  সংখ্যা একটি একক অঙ্ক (1-9), এবং এটি নির্দিষ্ট করে যে অক্ষরটি পরপর কতবার প্রদর্শিত হয়। যদি একটি অক্ষর কেবল একবার প্রদর্শিত হয়, তবে এটি সংখ্যার দ্বারা অনুসরণ করা হয় না।\n\n  আর্গুমেন্টসমূহ:\n  - compressed: একটি স্ট্রিং যা সংকুচিত ফর্ম্যাট ধারণ করে, যা অক্ষর এবং একক অঙ্কের সংখ্যা নিয়ে গঠিত।\n\n  রিটার্নস:\n  - একটি স্ট্রিং যা সংকুচিত স্ট্রিংয়ের প্রসারিত ফর্ম উপস্থাপন করে।\n\n  উদাহরণ:\n  - expand_compressed_string(\"a3b2c\") রিটার্ন করে \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") রিটার্ন করে \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") রিটার্ন করে \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "bg": "/*\n  Разширява компресиран низ, където последователни символи са представени от символа, следван от неговата бройка.\n  Бройката е едноцифрено число (1-9) и указва колко пъти символът се появява последователно. Ако символът се появява само веднъж, не е последван от бройка.\n\n  Аргументи:\n  - compressed: Низ, съдържащ компресирания формат, състоящ се от символи и едноцифрени бройки.\n\n  Връща:\n  - Низ, представляващ разширената форма на компресирания низ.\n\n  Пример:\n  - expand_compressed_string(\"a3b2c\") връща \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") връща \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") връща \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "zh": "/*\n  展开一个压缩字符串，其中连续字符由字符后跟其计数表示。\n  计数是一个单个数字（1-9），它指定字符连续出现的次数。如果一个字符只出现一次，则后面不跟计数。\n\n  参数:\n  - compressed: 一个包含压缩格式的字符串，由字符和单数字计数组成。\n\n  返回:\n  - 一个字符串，表示压缩字符串的展开形式。\n\n  示例:\n  - expand_compressed_string(\"a3b2c\") 返回 \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") 返回 \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") 返回 \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "fr": "/*\n  Développe une chaîne compressée où les caractères consécutifs sont représentés par le caractère suivi de son compte.\n  Le compte est un chiffre unique (1-9), et il spécifie combien de fois le caractère apparaît consécutivement. Si un caractère apparaît une seule fois, il n'est pas suivi d'un compte.\n\n  Arguments:\n  - compressed: Une chaîne contenant le format compressé, composée de caractères et de comptes à un chiffre.\n\n  Renvoie:\n  - Une chaîne représentant la forme développée de la chaîne compressée.\n\n  Exemple:\n  - expand_compressed_string(\"a3b2c\") renvoie \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") renvoie \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") renvoie \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "de": "/*\n  Erweitert einen komprimierten String, bei dem aufeinanderfolgende Zeichen durch das Zeichen gefolgt von seiner Anzahl dargestellt werden.\n  Die Anzahl ist eine einstellige Zahl (1-9) und gibt an, wie oft das Zeichen hintereinander erscheint. Wenn ein Zeichen nur einmal vorkommt, folgt keine Anzahl.\n\n  Argumente:\n  - compressed: Ein String, der das komprimierte Format enthält, bestehend aus Zeichen und einstelligen Zahlen.\n\n  Rückgabewert:\n  - Ein String, der die erweiterte Form des komprimierten Strings darstellt.\n\n  Beispiel:\n  - expand_compressed_string(\"a3b2c\") gibt \"aaabbc\" zurück\n  - expand_compressed_string(\"H3el5o2\") gibt \"HHHellllloo\" zurück\n  - expand_compressed_string(\"x9y1z2\") gibt \"xxxxxxxxxyzz\" zurück\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "ha": "/*\n  Faɗaɗa wani ɗaurewar kirtani inda haruffa masu jere suna wakilta ta hanyar harafin da aka biyo bayan adadinsa.\n  Adadin yana da lamba guda ɗaya (1-9), kuma yana bayyana sau nawa harafin ya bayyana a jere. Idan harafi ya bayyana sau ɗaya kawai, ba a biyo shi da adadi.\n\n  Huɗɗa:\n  - compressed: Wani kirtani mai ɗauke da tsarin ɗaurewa, wanda ya ƙunshi haruffa da lambobi guda ɗaya.\n\n  Mayarwa:\n  - Wani kirtani wanda ke wakiltar tsarin faɗaɗa na kirtani mai ɗaurewa.\n\n  Misali:\n  - expand_compressed_string(\"a3b2c\") yana mayar da \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") yana mayar da \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") yana mayar da \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "hi": "/*\n  एक संकुचित स्ट्रिंग का विस्तार करता है जहाँ लगातार वर्णों को वर्ण के बाद उसकी गिनती द्वारा दर्शाया जाता है।\n  गिनती एकल अंक (1-9) होती है, और यह निर्दिष्ट करती है कि वर्ण कितनी बार लगातार आता है। यदि कोई वर्ण केवल एक बार आता है, तो उसके बाद गिनती नहीं होती।\n\n  तर्क:\n  - compressed: एक स्ट्रिंग जिसमें संकुचित प्रारूप होता है, जिसमें वर्ण और एकल-अंक गिनती शामिल होती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो संकुचित स्ट्रिंग के विस्तारित रूप का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "hu": "/*\n  Kibont egy tömörített karakterláncot, ahol az egymást követő karaktereket a karakter és annak száma képviseli.\n  A szám egyjegyű (1-9), és azt jelzi, hogy a karakter hányszor jelenik meg egymás után. Ha egy karakter csak egyszer jelenik meg, akkor nem követi szám.\n\n  Argumentumok:\n  - compressed: Egy karakterlánc, amely a tömörített formát tartalmazza, karakterekből és egyjegyű számokból áll.\n\n  Visszatér:\n  - Egy karakterlánc, amely a tömörített karakterlánc kibővített formáját képviseli.\n\n  Példa:\n  - expand_compressed_string(\"a3b2c\") visszaadja \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") visszaadja \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") visszaadja \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9823751290300123",
      "hy": "0.9861667843735873",
      "bn": "0.991158564479375",
      "bg": "0.9882728623037002",
      "zh": "0.9718038215209546",
      "fr": "0.9892207264819987",
      "de": "0.9744642768445358",
      "ha": "0.9715442116129419",
      "hi": "0.9706334913158969",
      "hu": "0.965446854806314"
    },
    "canonical_solution": "{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}",
    "instruction": {
      "en": "Write a Rust function `fn expand_compressed_string(compressed: &str) -> String` to solve the following problem:\nExpands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "sq": "Shkruani një funksion Rust `fn expand_compressed_string(compressed: &str) -> String` për të zgjidhur problemin e mëposhtëm:\nZgjeron një varg të kompresuar ku karakteret e njëpasnjëshme përfaqësohen nga karakteri i ndjekur nga numri i tij.\n  Numri është një shifër e vetme (1-9), dhe specifikon sa herë shfaqet karakteri në mënyrë të njëpasnjëshme. Nëse një karakter shfaqet vetëm një herë, nuk ndiqet nga një numër.\n\n  Argumentet:\n  - compressed: Një varg që përmban formatin e kompresuar, i përbërë nga karaktere dhe numra njëshifrorë.\n\n  Kthen:\n  - Një varg që përfaqëson formën e zgjeruar të vargut të kompresuar.\n\n  Shembull:\n  - expand_compressed_string(\"a3b2c\") kthen \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") kthen \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") kthen \"xxxxxxxxxyzz\"",
      "hy": "Գրեք Rust ֆունկցիա `fn expand_compressed_string(compressed: &str) -> String` հետևյալ խնդիրը լուծելու համար:\nԸնդլայնում է սեղմված տողը, որտեղ հաջորդական նիշերը ներկայացված են նիշով, որին հաջորդում է նրա քանակը:\n  Քանակը միանիշ թիվ է (1-9), և այն նշում է, թե քանի անգամ է նիշը հայտնվում հաջորդաբար: Եթե նիշը հայտնվում է միայն մեկ անգամ, ապա նրան չի հաջորդում քանակը:\n\n  Փոփոխականներ:\n  - compressed: Տող, որը պարունակում է սեղմված ձևաչափը, բաղկացած նիշերից և միանիշ քանակներից:\n\n  Վերադարձնում է:\n  - Տող, որը ներկայացնում է սեղմված տողի ընդլայնված ձևը:\n\n  Օրինակ:\n  - expand_compressed_string(\"a3b2c\") վերադարձնում է \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") վերադարձնում է \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") վերադարձնում է \"xxxxxxxxxyzz\"",
      "bn": "Rust ফাংশন `fn expand_compressed_string(compressed: &str) -> String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সংকুচিত স্ট্রিং প্রসারিত করে যেখানে পরপর অক্ষরগুলি অক্ষর দ্বারা উপস্থাপিত হয় এবং তারপরে তার গণনা থাকে। \nগণনা একটি একক সংখ্যা (1-9), এবং এটি নির্দেশ করে যে অক্ষরটি পরপর কতবার উপস্থিত হয়। যদি কোনো অক্ষর শুধুমাত্র একবার উপস্থিত হয়, তবে এটি গণনা দ্বারা অনুসরণ করা হয় না।\n\nআর্গুমেন্টসমূহ:\n- compressed: একটি স্ট্রিং যা সংকুচিত ফরম্যাট ধারণ করে, যা অক্ষর এবং একক-সংখ্যার গণনা নিয়ে গঠিত।\n\nফেরত দেয়:\n- একটি স্ট্রিং যা সংকুচিত স্ট্রিংয়ের প্রসারিত ফর্ম উপস্থাপন করে।\n\nউদাহরণ:\n- expand_compressed_string(\"a3b2c\") ফেরত দেয় \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") ফেরত দেয় \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") ফেরত দেয় \"xxxxxxxxxyzz\"",
      "bg": "Напишете функция на Rust `fn expand_compressed_string(compressed: &str) -> String`, за да решите следния проблем:\nРазширява компресиран низ, където последователни символи са представени от символа, последван от неговия брой.\n  Броят е едноцифрено число (1-9) и указва колко пъти символът се появява последователно. Ако символ се появява само веднъж, той не е последван от брой.\n\n  Аргументи:\n  - compressed: Низ, съдържащ компресирания формат, състоящ се от символи и едноцифрени числа.\n\n  Връща:\n  - Низ, представляващ разширената форма на компресирания низ.\n\n  Пример:\n  - expand_compressed_string(\"a3b2c\") връща \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") връща \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") връща \"xxxxxxxxxyzz\"",
      "zh": "编写一个 Rust 函数 `fn expand_compressed_string(compressed: &str) -> String` 来解决以下问题：\n展开一个压缩字符串，其中连续字符由字符后跟其计数表示。\n计数是一个一位数（1-9），它指定字符连续出现的次数。如果一个字符只出现一次，则后面不跟计数。\n\n参数：\n- compressed: 一个包含压缩格式的字符串，由字符和一位数字计数组成。\n\n返回：\n- 一个字符串，表示压缩字符串的展开形式。\n\n示例：\n- expand_compressed_string(\"a3b2c\") 返回 \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") 返回 \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") 返回 \"xxxxxxxxxyzz\"",
      "fr": "Écrire une fonction Rust `fn expand_compressed_string(compressed: &str) -> String` pour résoudre le problème suivant :\nDéveloppe une chaîne compressée où les caractères consécutifs sont représentés par le caractère suivi de son nombre.\n  Le nombre est un chiffre unique (1-9), et il spécifie combien de fois le caractère apparaît consécutivement. Si un caractère apparaît une seule fois, il n'est pas suivi d'un nombre.\n\n  Arguments :\n  - compressed: Une chaîne contenant le format compressé, composé de caractères et de chiffres uniques.\n\n  Renvoie :\n  - Une chaîne représentant la forme développée de la chaîne compressée.\n\n  Exemple :\n  - expand_compressed_string(\"a3b2c\") renvoie \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") renvoie \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") renvoie \"xxxxxxxxxyzz\"",
      "de": "Schreiben Sie eine Rust-Funktion `fn expand_compressed_string(compressed: &str) -> String`, um das folgende Problem zu lösen:\nErweitert einen komprimierten String, bei dem aufeinanderfolgende Zeichen durch das Zeichen gefolgt von seiner Anzahl dargestellt werden.\n  Die Anzahl ist eine einstellige Zahl (1-9) und gibt an, wie oft das Zeichen hintereinander erscheint. Wenn ein Zeichen nur einmal vorkommt, folgt keine Anzahl.\n\n  Argumente:\n  - compressed: Ein String, der das komprimierte Format enthält, bestehend aus Zeichen und einstelligen Zahlen.\n\n  Rückgabewert:\n  - Ein String, der die erweiterte Form des komprimierten Strings darstellt.\n\n  Beispiel:\n  - expand_compressed_string(\"a3b2c\") gibt \"aaabbc\" zurück\n  - expand_compressed_string(\"H3el5o2\") gibt \"HHHellllloo\" zurück\n  - expand_compressed_string(\"x9y1z2\") gibt \"xxxxxxxxxyzz\" zurück",
      "ha": "Rubuta aikin Rust `fn expand_compressed_string(compressed: &str) -> String` don warware matsalar mai zuwa:\nYa faɗaɗa wani matsewar zare inda haruffa masu jere suke wakilta ta hanyar harafin da aka biyo baya da adadinsa.\n  Adadin yana da lamba guda (1-9), kuma yana nuna sau nawa harafin ya bayyana a jere. Idan harafi ya bayyana sau ɗaya kawai, ba a biyo shi da adadi.\n\n  Huɗɗa:\n  - compressed: Zare wanda ke ƙunshe da tsarin matsewa, wanda ya ƙunshi haruffa da lambobi guda ɗaya.\n\n  Mayarwa:\n  - Zare wanda ke wakiltar faɗaɗa tsarin matsewar zaren.\n\n  Misali:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "hi": "Rust फ़ंक्शन `fn expand_compressed_string(compressed: &str) -> String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक संकुचित स्ट्रिंग का विस्तार करता है जहाँ लगातार वर्णों को वर्ण के बाद उसकी गिनती द्वारा दर्शाया जाता है।\n  गिनती एकल अंक (1-9) है, और यह निर्दिष्ट करता है कि वर्ण कितनी बार लगातार प्रकट होता है। यदि कोई वर्ण केवल एक बार प्रकट होता है, तो उसके बाद गिनती नहीं होती है।\n\n  तर्क:\n  - compressed: एक स्ट्रिंग जिसमें संकुचित प्रारूप होता है, जिसमें वर्ण और एकल-अंक गिनती होती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो संकुचित स्ट्रिंग के विस्तारित रूप का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" लौटाता है\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" लौटाता है\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" लौटाता है",
      "hu": "Írj egy Rust függvényt `fn expand_compressed_string(compressed: &str) -> String` a következő probléma megoldására:\nKibont egy tömörített karakterláncot, ahol az egymást követő karaktereket a karakter és az azt követő szám jelzi.\n  A szám egyjegyű (1-9), és megadja, hogy a karakter hányszor jelenik meg egymás után. Ha egy karakter csak egyszer jelenik meg, akkor nem követi szám.\n\n  Argumentumok:\n  - compressed: Egy karakterlánc, amely a tömörített formátumot tartalmazza, karakterekből és egyjegyű számokból áll.\n\n  Visszatér:\n  - Egy karakterlánc, amely a tömörített karakterlánc kibővített formáját képviseli.\n\n  Példa:\n  - expand_compressed_string(\"a3b2c\") visszaadja \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") visszaadja \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") visszaadja \"xxxxxxxxxyzz\""
    },
    "instruction_bertscore": {
      "sq": "0.9824829853269142",
      "hy": "0.9806321474364311",
      "bn": "0.9801238522913629",
      "bg": "0.9875687176029315",
      "zh": "0.979282056736537",
      "fr": "0.9712387180869103",
      "de": "0.9739967009275797",
      "ha": "0.971385505938495",
      "hi": "0.9695072570554292",
      "hu": "0.9723740893449057"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(expand_compressed_string(\"a3b2c\"), \"aaabbc\");\n        assert_eq!(expand_compressed_string(\"H3el5o2\"), \"HHHellllloo\");\n        assert_eq!(expand_compressed_string(\"x9y1z2\"), \"xxxxxxxxxyzz\");\n        assert_eq!(expand_compressed_string(\"r4s\"), \"rrrrs\");\n        \n    }\n    \n\n}\n ",
    "entry_point": "expand_compressed_string",
    "signature": "fn expand_compressed_string(compressed: &str) -> String",
    "docstring": {
      "en": "Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "sq": "Zgjeron një varg të kompresuar ku karakteret e njëpasnjëshme përfaqësohen nga karakteri i ndjekur nga numri i tij.\n  Numri është një shifër e vetme (1-9), dhe specifikon sa herë shfaqet karakteri në mënyrë të njëpasnjëshme. Nëse një karakter shfaqet vetëm një herë, nuk ndiqet nga një numër.\n\n  Argumentet:\n  - compressed: Një varg që përmban formatin e kompresuar, i përbërë nga karaktere dhe numra njëshifrorë.\n\n  Kthen:\n  - Një varg që përfaqëson formën e zgjeruar të vargut të kompresuar.\n\n  Shembull:\n  - expand_compressed_string(\"a3b2c\") kthen \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") kthen \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") kthen \"xxxxxxxxxyzz\"",
      "hy": "Սեղմված տողը ընդլայնում է, որտեղ հաջորդական նիշերը ներկայացված են նիշով, որին հաջորդում է դրա քանակը:\nՔանակը միանիշ է (1-9) և նշում է, թե քանի անգամ է նիշը հայտնվում հաջորդաբար: Եթե նիշը հայտնվում է միայն մեկ անգամ, նրան չի հաջորդում քանակ:  \n\nԱրգումենտներ:  \n  - compressed: Տող, որը պարունակում է սեղմված ձևաչափը, բաղկացած նիշերից և միանիշ քանակներից:  \n\nՎերադարձնում է:  \n  - Տող, որը ներկայացնում է սեղմված տողի ընդլայնված ձևը:  \n\nՕրինակ:  \n- expand_compressed_string(\"a3b2c\") returns \"aaabbc\"  \n- expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"  \n- expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "bn": "সংকুচিত স্ট্রিং প্রসারিত করে যেখানে পরপর অক্ষরগুলি অক্ষরের পরে তার গণনা দ্বারা উপস্থাপিত হয়। গণনা একটি একক সংখ্যা (1-9), এবং এটি নির্দিষ্ট করে যে অক্ষরটি পরপর কতবার উপস্থিত হয়। যদি কোনো অক্ষর মাত্র একবার উপস্থিত হয়, তবে এটি কোনো গণনা দ্বারা অনুসরণ করা হয় না।\n\nArguments:\n- compressed: একটি স্ট্রিং যা সংকুচিত ফর্ম্যাট ধারণ করে, যা অক্ষর এবং একক-সংখ্যার গণনা নিয়ে গঠিত।\n\nReturns:\n- একটি স্ট্রিং যা সংকুচিত স্ট্রিংয়ের প্রসারিত ফর্ম উপস্থাপন করে।\n\nExample:\n- expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "bg": "Разширява компресиран низ, където последователни символи са представени от символа, последван от неговата бройка. Бройката е едноцифрено число (1-9) и указва колко пъти символът се появява последователно. Ако символът се появява само веднъж, той не е последван от бройка.\n\nАргументи:\n- compressed: Низ, съдържащ компресирания формат, състоящ се от символи и едноцифрени бройки.\n\nВръща:\n- Низ, представляващ разширената форма на компресирания низ.\n\nПример:\n- expand_compressed_string(\"a3b2c\") връща \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") връща \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") връща \"xxxxxxxxxyzz\"",
      "zh": "扩展一个压缩字符串，其中连续字符由字符后跟其计数表示。计数是一个单一数字（1-9），指定字符连续出现的次数。如果一个字符只出现一次，则不跟随计数。\n\nArguments:\n- compressed: 包含压缩格式的字符串，由字符和单一数字计数组成。\n\nReturns:\n- 表示压缩字符串扩展形式的字符串。\n\nExample:\n- expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "fr": "Développe une chaîne compressée où les caractères consécutifs sont représentés par le caractère suivi de son nombre.\n  Le nombre est un chiffre unique (1-9), et il spécifie combien de fois le caractère apparaît consécutivement. Si un caractère apparaît une seule fois, il n'est pas suivi d'un nombre.\n\n  Arguments:\n  - compressed: Une chaîne contenant le format compressé, composée de caractères et de chiffres uniques.\n\n  Retourne:\n  - Une chaîne représentant la forme développée de la chaîne compressée.\n\n  Exemple:\n  - expand_compressed_string(\"a3b2c\") retourne \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") retourne \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") retourne \"xxxxxxxxxyzz\"",
      "de": "Erweitert einen komprimierten String, bei dem aufeinanderfolgende Zeichen durch das Zeichen gefolgt von seiner Anzahl dargestellt werden.\n  Die Anzahl ist eine einstellige Zahl (1-9) und gibt an, wie oft das Zeichen hintereinander erscheint. Wenn ein Zeichen nur einmal erscheint, folgt keine Anzahl.\n\n  Argumente:\n  - compressed: Ein String, der das komprimierte Format enthält, bestehend aus Zeichen und einstelligen Zahlen.\n\n  Rückgabewerte:\n  - Ein String, der die erweiterte Form des komprimierten Strings darstellt.\n\n  Beispiel:\n  - expand_compressed_string(\"a3b2c\") gibt \"aaabbc\" zurück\n  - expand_compressed_string(\"H3el5o2\") gibt \"HHHellllloo\" zurück\n  - expand_compressed_string(\"x9y1z2\") gibt \"xxxxxxxxxyzz\" zurück",
      "ha": "Faɗaɗa wani matsewar kirtani inda haruffa masu jere suna wakilta ta hanyar harafin da ke biye da adadinsa. \nAdadin yana da lamba guda ɗaya (1-9), kuma yana nuna sau nawa harafin ya bayyana a jere. Idan harafi ya bayyana sau ɗaya kawai, ba a bi shi da adadi.\n\nHujjoji:\n- compressed: Wani kirtani da ke ɗauke da tsarin matsewa, wanda ya ƙunshi haruffa da lambobi guda ɗaya.\n\nAbin da ake dawowa da shi:\n- Wani kirtani da ke wakiltar faɗaɗa tsarin matsewar kirtani.\n\nMisali:\n- expand_compressed_string(\"a3b2c\") yana dawowa da \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") yana dawowa da \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") yana dawowa da \"xxxxxxxxxyzz\"",
      "hi": "संपीड़ित स्ट्रिंग का विस्तार करता है जहाँ लगातार वर्णों को वर्ण के बाद उसकी गिनती द्वारा दर्शाया जाता है। \nगिनती एकल अंक (1-9) है, और यह निर्दिष्ट करता है कि वर्ण कितनी बार लगातार प्रकट होता है। यदि कोई वर्ण केवल एक बार प्रकट होता है, तो उसके बाद कोई गिनती नहीं होती।\n\nआर्गुमेंट्स:\n- compressed: एक स्ट्रिंग जिसमें संपीड़ित प्रारूप होता है, जिसमें वर्ण और एकल-अंक गिनती शामिल होती है।\n\nरिटर्न्स:\n- एक स्ट्रिंग जो संपीड़ित स्ट्रिंग के विस्तारित रूप का प्रतिनिधित्व करती है।\n\nउदाहरण:\n- expand_compressed_string(\"a3b2c\") \"aaabbc\" लौटाता है\n- expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" लौटाता है\n- expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" लौटाता है",
      "hu": "Kibont egy tömörített karakterláncot, ahol az egymást követő karaktereket a karakter és annak száma képviseli.\n  A szám egyjegyű (1-9), és azt jelzi, hogy a karakter hányszor jelenik meg egymás után. Ha egy karakter csak egyszer jelenik meg, akkor nem követi szám.\n\n  Argumentumok:\n  - compressed: Egy karakterlánc, amely a tömörített formátumot tartalmazza, karakterekből és egyjegyű számokból áll.\n\n  Visszatér:\n  - Egy karakterlánc, amely a tömörített karakterlánc kibővített formáját képviseli.\n\n  Példa:\n  - expand_compressed_string(\"a3b2c\") visszatér \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") visszatér \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") visszatér \"xxxxxxxxxyzz\""
    },
    "docstring_bertscore": {
      "sq": "0.9791015017201763",
      "hy": "1",
      "bn": "0.9850757076905626",
      "bg": "0.9873903475207622",
      "zh": "0.9627943446979741",
      "fr": "0.962770707682631",
      "de": "0.9686515573739308",
      "ha": "0.9759778403480217",
      "hi": "0.9690907291463989",
      "hu": "0.9607089243274888"
    }
  },
  {
    "task_id": "Rust/11",
    "prompt": {
      "en": "/*\n  Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin e shtigjeve të dallueshme nga këndi i sipërm i majtë deri te këndi i poshtëm i djathtë i një rrjeti,\n  me kufizimin që mund të lëvizet vetëm djathtas ose poshtë dhe nuk mund të hyhet në qeliza ku numrat e rreshtave dhe kolonave janë çift.\n\n  Argumentet:\n  - rows: Numri i rreshtave në rrjet.\n  - cols: Numri i kolonave në rrjet.\n\n  Kthen:\n  - Numri i shtigjeve të dallueshme që plotësojnë kufizimet e dhëna.\n\n  Shembull:\n  - count_walking_paths(3, 4) kthen 2\n  - count_walking_paths(2, 2) kthen 0\n  - count_walking_paths(4, 5) kthen 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է տարբեր ուղիների քանակը ցանցի վերին ձախ անկյունից մինչև ներքևի աջ անկյուն,\n  այն սահմանափակմամբ, որ կարելի է շարժվել միայն աջ կամ ներքև և չի կարելի մտնել բջիջներ, որտեղ և՛ տողի, և՛ սյունակի համարները զույգ են:\n\n  Փաստարկներ:\n  - rows: Տողերի քանակը ցանցում:\n  - cols: Սյունակների քանակը ցանցում:\n\n  Վերադարձնում է:\n  - Տարբեր ուղիների քանակը, որոնք բավարարում են տրված սահմանափակումները:\n\n  Օրինակ:\n  - count_walking_paths(3, 4) վերադարձնում է 2\n  - count_walking_paths(2, 2) վերադարձնում է 0\n  - count_walking_paths(4, 5) վերադարձնում է 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "bn": "/*\n  একটি গ্রিডের উপরের-বাম কোণ থেকে নিচের-ডান কোণে যাওয়ার ভিন্ন পথের সংখ্যা গণনা করে,\n  শর্ত সহ যে কেবল ডান বা নিচে সরানো যায় এবং এমন কোষে প্রবেশ করা যায় না যেখানে সারি এবং কলামের উভয় সংখ্যাই জোড়।\n\n  আর্গুমেন্ট:\n  - rows: গ্রিডের সারির সংখ্যা।\n  - cols: গ্রিডের কলামের সংখ্যা।\n\n  রিটার্নস:\n  - প্রদত্ত শর্তগুলি পূরণ করে এমন ভিন্ন পথের সংখ্যা।\n\n  উদাহরণ:\n  - count_walking_paths(3, 4) রিটার্ন করে 2\n  - count_walking_paths(2, 2) রিটার্ন করে 0\n  - count_walking_paths(4, 5) রিটার্ন করে 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните пътища от горния ляв ъгъл до долния десен ъгъл на решетка,\n  с ограничението, че може да се движите само надясно или надолу и не можете да влизате в клетки, където и редовият, и колонният номер са четни.\n\n  Аргументи:\n  - rows: Броят на редовете в решетката.\n  - cols: Броят на колоните в решетката.\n\n  Връща:\n  - Броят на различните пътища, които отговарят на дадените ограничения.\n\n  Пример:\n  - count_walking_paths(3, 4) връща 2\n  - count_walking_paths(2, 2) връща 0\n  - count_walking_paths(4, 5) връща 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "zh": "/*\n  计算从网格的左上角到右下角的不同路径数量，\n  约束条件是只能向右或向下移动，且不能进入行号和列号均为偶数的单元格。\n\n  参数:\n  - rows: 网格的行数。\n  - cols: 网格的列数。\n\n  返回值:\n  - 满足给定约束条件的不同路径数量。\n\n  示例:\n  - count_walking_paths(3, 4) 返回 2\n  - count_walking_paths(2, 2) 返回 0\n  - count_walking_paths(4, 5) 返回 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre de chemins distincts du coin supérieur gauche au coin inférieur droit d'une grille,\n  avec la contrainte que l'on ne peut se déplacer que vers la droite ou vers le bas et ne peut pas entrer dans les cellules où les numéros de ligne et de colonne sont pairs.\n\n  Arguments:\n  - rows: Le nombre de lignes dans la grille.\n  - cols: Le nombre de colonnes dans la grille.\n\n  Returns:\n  - Le nombre de chemins distincts satisfaisant les contraintes données.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der unterschiedlichen Pfade von der oberen linken Ecke zur unteren rechten Ecke eines Gitters,\n  mit der Einschränkung, dass man sich nur nach rechts oder unten bewegen kann und keine Zellen betreten darf, bei denen sowohl die Zeilen- als auch die Spaltennummer gerade sind.\n\n  Argumente:\n  - rows: Die Anzahl der Zeilen im Gitter.\n  - cols: Die Anzahl der Spalten im Gitter.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Pfade, die die gegebenen Einschränkungen erfüllen.\n\n  Beispiel:\n  - count_walking_paths(3, 4) gibt 2 zurück\n  - count_walking_paths(2, 2) gibt 0 zurück\n  - count_walking_paths(4, 5) gibt 3 zurück\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "ha": "/*\n  Lissafa adadin hanyoyi daban-daban daga saman hagu zuwa ƙasan dama na grid,\n  tare da ƙuntatawa cewa mutum zai iya motsawa kawai dama ko ƙasa kuma ba zai iya shiga ƙwayoyin inda lambobin layi da ginshiƙi duka biyun suke ma'aurata ba.\n\n  Huɗodi:\n  - rows: Adadin layukan a cikin grid.\n  - cols: Adadin ginshiƙai a cikin grid.\n\n  Mayarwa:\n  - Adadin hanyoyi daban-daban da suka cika ƙuntatawar da aka bayar.\n\n  Misali:\n  - count_walking_paths(3, 4) yana mayar da 2\n  - count_walking_paths(2, 2) yana mayar da 0\n  - count_walking_paths(4, 5) yana mayar da 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "hi": "/*\n  ग्रिड के शीर्ष-बाएँ कोने से निचले-दाएँ कोने तक भिन्न पथों की संख्या की गणना करता है,\n  इस बाधा के साथ कि कोई केवल दाएँ या नीचे की ओर जा सकता है और उन कोशिकाओं में प्रवेश नहीं कर सकता जहाँ पंक्ति और स्तंभ दोनों संख्याएँ सम हैं।\n\n  तर्क:\n  - rows: ग्रिड में पंक्तियों की संख्या।\n  - cols: ग्रिड में स्तंभों की संख्या।\n\n  लौटाता है:\n  - दिए गए बाधाओं को संतोषजनक बनाने वाले भिन्न पथों की संख्या।\n\n  उदाहरण:\n  - count_walking_paths(3, 4) 2 लौटाता है\n  - count_walking_paths(2, 2) 0 लौटाता है\n  - count_walking_paths(4, 5) 3 लौटाता है\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja az egyedi utak számát a rács bal felső sarkától a jobb alsó sarkáig,\n  azzal a megszorítással, hogy csak jobbra vagy lefelé lehet mozogni, és nem lehet belépni olyan cellákba, ahol mind a sor, mind az oszlop száma páros.\n\n  Argumentumok:\n  - rows: A rács sorainak száma.\n  - cols: A rács oszlopainak száma.\n\n  Visszatér:\n  - Az egyedi utak száma, amelyek megfelelnek a megadott megszorításoknak.\n\n  Példa:\n  - count_walking_paths(3, 4) visszaadja 2\n  - count_walking_paths(2, 2) visszaadja 0\n  - count_walking_paths(4, 5) visszaadja 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9848407279497984",
      "hy": "0.9808971203647316",
      "bn": "0.9726708431341718",
      "bg": "0.9804551677669291",
      "zh": "0.9698467163766178",
      "fr": "0.9887577190638064",
      "de": "0.9836437812736821",
      "ha": "0.9530088189762903",
      "hi": "0.9912576810395115",
      "hu": "0.973394652242663"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_walking_paths(rows: i32, cols: i32) -> i32` to solve the following problem:\nCalculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "sq": "Shkruani një funksion Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e shtigjeve të dallueshme nga këndi i sipërm i majtë deri në këndin e poshtëm të djathtë të një rrjeti,\n  me kufizimin që mund të lëvizet vetëm djathtas ose poshtë dhe nuk mund të hyhet në qeliza ku numrat e rreshtave dhe kolonave janë çift.\n\n  Argumentet:\n  - rows: Numri i rreshtave në rrjet.\n  - cols: Numri i kolonave në rrjet.\n\n  Kthen:\n  - Numri i shtigjeve të dallueshme që plotësojnë kufizimet e dhëna.\n\n  Shembull:\n  - count_walking_paths(3, 4) kthen 2\n  - count_walking_paths(2, 2) kthen 0\n  - count_walking_paths(4, 5) kthen 3",
      "hy": "Գրեք Rust ֆունկցիա `fn count_walking_paths(rows: i32, cols: i32) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տարբեր ուղիների քանակը ցանցի վերին ձախ անկյունից մինչև ներքևի աջ անկյունը,\n  այն սահմանափակմամբ, որ կարելի է շարժվել միայն աջ կամ ներքև և չի կարելի մուտք գործել բջիջներ, որտեղ թե՛ տողի և թե՛ սյունակի համարները զույգ են:\n\n  Արգումենտներ:\n  - rows: Տողերի քանակը ցանցում:\n  - cols: Սյունակների քանակը ցանցում:\n\n  Վերադարձնում է:\n  - Տարբեր ուղիների քանակը, որոնք բավարարում են տրված սահմանափակումները:\n\n  Օրինակ:\n  - count_walking_paths(3, 4) վերադարձնում է 2\n  - count_walking_paths(2, 2) վերադարձնում է 0\n  - count_walking_paths(4, 5) վերադարձնում է 3",
      "bn": "Rust ফাংশন `fn count_walking_paths(rows: i32, cols: i32) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি গ্রিডের উপরের-বাম কোণ থেকে নিচের-ডান কোণে যাওয়ার ভিন্ন পথের সংখ্যা গণনা করে,\n  যেখানে শর্ত হল যে কেবল ডান বা নিচে সরানো যেতে পারে এবং এমন কোষে প্রবেশ করা যাবে না যেখানে সারি এবং কলাম উভয়ের সংখ্যা জোড়।\n\n  আর্গুমেন্টসমূহ:\n  - rows: গ্রিডের সারির সংখ্যা।\n  - cols: গ্রিডের কলামের সংখ্যা।\n\n  রিটার্নস:\n  - প্রদত্ত শর্তাবলী পূরণকারী ভিন্ন পথের সংখ্যা।\n\n  উদাহরণ:\n  - count_walking_paths(3, 4) রিটার্ন করে 2\n  - count_walking_paths(2, 2) রিটার্ন করে 0\n  - count_walking_paths(4, 5) রিটার্ন করে 3",
      "bg": "Напишете функция на Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32`, за да решите следния проблем:\nИзчислява броя на различните пътища от горния ляв ъгъл до долния десен ъгъл на решетка,\n  с ограничението, че може да се движите само надясно или надолу и не може да влизате в клетки, където и редовете, и колоните са четни.\n\n  Аргументи:\n  - rows: Броят на редовете в решетката.\n  - cols: Броят на колоните в решетката.\n\n  Връща:\n  - Броят на различните пътища, които отговарят на дадените ограничения.\n\n  Пример:\n  - count_walking_paths(3, 4) връща 2\n  - count_walking_paths(2, 2) връща 0\n  - count_walking_paths(4, 5) връща 3",
      "zh": "编写一个 Rust 函数 `fn count_walking_paths(rows: i32, cols: i32) -> i32` 来解决以下问题：\n计算从网格的左上角到右下角的不同路径的数量，\n  约束条件是只能向右或向下移动，并且不能进入行号和列号均为偶数的单元格。\n\n  参数：\n  - rows: 网格的行数。\n  - cols: 网格的列数。\n\n  返回值：\n  - 满足给定约束条件的不同路径的数量。\n\n  示例：\n  - count_walking_paths(3, 4) 返回 2\n  - count_walking_paths(2, 2) 返回 0\n  - count_walking_paths(4, 5) 返回 3",
      "fr": "Écrire une fonction Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` pour résoudre le problème suivant :\nCalcule le nombre de chemins distincts du coin supérieur gauche au coin inférieur droit d'une grille,\navec la contrainte que l'on ne peut se déplacer que vers la droite ou vers le bas et ne peut pas entrer dans les cellules où les numéros de ligne et de colonne sont pairs.\n\nArguments :\n- rows : Le nombre de lignes dans la grille.\n- cols : Le nombre de colonnes dans la grille.\n\nRenvoie :\n- Le nombre de chemins distincts satisfaisant les contraintes données.\n\nExemple :\n- count_walking_paths(3, 4) renvoie 2\n- count_walking_paths(2, 2) renvoie 0\n- count_walking_paths(4, 5) renvoie 3",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_walking_paths(rows: i32, cols: i32) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der unterschiedlichen Pfade von der oberen linken Ecke zur unteren rechten Ecke eines Gitters, mit der Einschränkung, dass man sich nur nach rechts oder unten bewegen kann und keine Zellen betreten darf, bei denen sowohl die Zeilen- als auch die Spaltennummer gerade sind.\n\nArgumente:\n- rows: Die Anzahl der Zeilen im Gitter.\n- cols: Die Anzahl der Spalten im Gitter.\n\nRückgabewert:\n- Die Anzahl der unterschiedlichen Pfade, die die gegebenen Einschränkungen erfüllen.\n\nBeispiel:\n- count_walking_paths(3, 4) gibt 2 zurück\n- count_walking_paths(2, 2) gibt 0 zurück\n- count_walking_paths(4, 5) gibt 3 zurück",
      "ha": "Rubuta aikin Rust `fn count_walking_paths(rows: i32, cols: i32) -> i32` don warware matsalar mai zuwa:\nYana ƙididdige adadin hanyoyin daban-daban daga saman hagu zuwa ƙasan dama na grid,\ntare da ƙuntatawa cewa mutum zai iya motsawa kawai dama ko ƙasa kuma ba zai iya shiga sel inda lambobin layi da ginshiƙi duka biyu suke ma'aurata ba.\n\nHujjoji:\n- rows: Adadin layuka a cikin grid.\n- cols: Adadin ginshiƙai a cikin grid.\n\nYana dawowa:\n- Adadin hanyoyin daban-daban da suka cika ƙuntatawar da aka bayar.\n\nMisali:\n- count_walking_paths(3, 4) yana dawowa 2\n- count_walking_paths(2, 2) yana dawowa 0\n- count_walking_paths(4, 5) yana dawowa 3",
      "hi": "Rust फ़ंक्शन `fn count_walking_paths(rows: i32, cols: i32) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nग्रिड के ऊपरी-बाएँ कोने से निचले-दाएँ कोने तक के विशिष्ट पथों की संख्या की गणना करता है,\n  इस बाधा के साथ कि कोई केवल दाएँ या नीचे की ओर जा सकता है और उन कोशिकाओं में प्रवेश नहीं कर सकता जहाँ पंक्ति और स्तंभ दोनों संख्याएँ सम हैं।\n\n  तर्क:\n  - rows: ग्रिड में पंक्तियों की संख्या।\n  - cols: ग्रिड में स्तंभों की संख्या।\n\n  लौटाता है:\n  - दिए गए बाधाओं को संतुष्ट करने वाले विशिष्ट पथों की संख्या।\n\n  उदाहरण:\n  - count_walking_paths(3, 4) 2 लौटाता है\n  - count_walking_paths(2, 2) 0 लौटाता है\n  - count_walking_paths(4, 5) 3 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_walking_paths(rows: i32, cols: i32) -> i32` a következő probléma megoldására:\nKiszámítja a különböző utak számát a rács bal felső sarkától a jobb alsó sarokig,\nazzal a megkötéssel, hogy csak jobbra vagy lefelé lehet mozogni, és nem lehet belépni olyan cellákba, ahol mind a sor, mind az oszlop száma páros.\n\nArgumentumok:\n- rows: A rács sorainak száma.\n- cols: A rács oszlopainak száma.\n\nVisszatér:\n- A megadott feltételeknek megfelelő különböző utak száma.\n\nPélda:\n- count_walking_paths(3, 4) visszaadja 2\n- count_walking_paths(2, 2) visszaadja 0\n- count_walking_paths(4, 5) visszaadja 3"
    },
    "instruction_bertscore": {
      "sq": "0.9872997720670103",
      "hy": "0.9778543015576583",
      "bn": "0.9644900522608689",
      "bg": "0.9767989783432199",
      "zh": "0.9667770824681046",
      "fr": "0.9907128379043327",
      "de": "0.9782738089224039",
      "ha": "0.965071642016539",
      "hi": "0.9725439183206905",
      "hu": "0.9697974560421211"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(count_walking_paths(3, 4), 2);\n        assert_eq!(count_walking_paths(2, 2), 0);\n        assert_eq!(count_walking_paths(4, 5), 3);\n        assert_eq!(count_walking_paths(1, 1), 1);        \n    }\n    \n\n}",
    "entry_point": "count_walking_paths",
    "signature": "fn count_walking_paths(rows: i32, cols: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "sq": "Llogarit numrin e shtigjeve të veçanta nga këndi i sipërm i majtë deri te këndi i poshtëm i djathtë i një grile,\nme kufizimin që mund të lëvizet vetëm djathtas ose poshtë dhe nuk mund të hyhet në qeliza ku numrat e rreshtit dhe kolonës janë çift.\n\nArgumentet:\n- rows: Numri i rreshtave në grilë.\n- cols: Numri i kolonave në grilë.\n\nKthen:\n- Numri i shtigjeve të veçanta që plotësojnë kufizimet e dhëna.\n\nShembull:\n- count_walking_paths(3, 4) kthen 2\n- count_walking_paths(2, 2) kthen 0\n- count_walking_paths(4, 5) kthen 3",
      "hy": "Հաշվում է տարբեր ուղիների քանակը ցանցի վերին ձախ անկյունից դեպի ներքևի աջ անկյուն,\n  սահմանափակմամբ, որ կարելի է շարժվել միայն աջ կամ ներքև և չի կարելի մտնել այն բջիջները, որտեղ և՛ տողի, և՛ սյան համարները զույգ են։\n\n  Արգումենտներ:\n  - rows: Ցանցի տողերի քանակը։\n  - cols: Ցանցի սյուների քանակը։\n\n  Վերադարձնում է:\n  - Տրված սահմանափակումներին բավարարող տարբեր ուղիների քանակը։\n\n  Օրինակ:\n  - count_walking_paths(3, 4) վերադարձնում է 2\n  - count_walking_paths(2, 2) վերադարձնում է 0\n  - count_walking_paths(4, 5) վերադարձնում է 3",
      "bn": "শীর্ষ-বাম কোণ থেকে গ্রিডের নিচের-ডান কোণে ভিন্ন পথের সংখ্যা গণনা করে, \n  যেখানে শর্ত হল যে শুধুমাত্র ডান বা নিচে সরানো যায় এবং এমন কোষে প্রবেশ করা যায় না যেখানে সারি এবং কলামের উভয় সংখ্যাই জোড়।\n\n  আর্গুমেন্টসমূহ:\n  - rows: গ্রিডের সারির সংখ্যা।\n  - cols: গ্রিডের কলামের সংখ্যা।\n\n  রিটার্নসমূহ:\n  - প্রদত্ত শর্তগুলি পূরণ করে এমন ভিন্ন পথের সংখ্যা।\n\n  উদাহরণ:\n  - count_walking_paths(3, 4) রিটার্ন করে 2\n  - count_walking_paths(2, 2) রিটার্ন করে 0\n  - count_walking_paths(4, 5) রিটার্ন করে 3",
      "bg": "Изчислява броя на различните пътища от горния ляв ъгъл до долния десен ъгъл на мрежа,\n  с ограничението, че може да се движи само надясно или надолу и не може да влиза в клетки, където и редовият, и колонният номер са четни.\n\n  Аргументи:\n  - rows: Броят на редовете в мрежата.\n  - cols: Броят на колоните в мрежата.\n\n  Връща:\n  - Броят на различните пътища, които отговарят на дадените ограничения.\n\n  Пример:\n  - count_walking_paths(3, 4) връща 2\n  - count_walking_paths(2, 2) връща 0\n  - count_walking_paths(4, 5) връща 3",
      "zh": "计算从网格的左上角到右下角的不同路径数量，限制条件是只能向右或向下移动，并且不能进入行号和列号均为偶数的单元格。\n\n参数:\n- rows: 网格的行数。\n- cols: 网格的列数。\n\n返回:\n- 满足给定约束条件的不同路径数量。\n\n示例:\n- count_walking_paths(3, 4) 返回 2\n- count_walking_paths(2, 2) 返回 0\n- count_walking_paths(4, 5) 返回 3",
      "fr": "Calcule le nombre de chemins distincts du coin supérieur gauche au coin inférieur droit d'une grille,\navec la contrainte que l'on ne peut se déplacer que vers la droite ou vers le bas et ne peut pas entrer dans les cellules où les numéros de ligne et de colonne sont pairs.\n\nArguments:\n- rows: Le nombre de lignes dans la grille.\n- cols: Le nombre de colonnes dans la grille.\n\nReturns:\n- Le nombre de chemins distincts satisfaisant les contraintes données.\n\nExample:\n- count_walking_paths(3, 4) returns 2\n- count_walking_paths(2, 2) returns 0\n- count_walking_paths(4, 5) returns 3",
      "de": "Berechnet die Anzahl der unterschiedlichen Pfade vom oberen linken Eckpunkt zum unteren rechten Eckpunkt eines Gitters, mit der Einschränkung, dass man sich nur nach rechts oder unten bewegen kann und keine Zellen betreten darf, bei denen sowohl die Zeilen- als auch die Spaltennummer gerade sind.\n\nArgumente:\n- rows: Die Anzahl der Zeilen im Gitter.\n- cols: Die Anzahl der Spalten im Gitter.\n\nRückgabewert:\n- Die Anzahl der unterschiedlichen Pfade, die die gegebenen Einschränkungen erfüllen.\n\nBeispiel:\n- count_walking_paths(3, 4) gibt 2 zurück\n- count_walking_paths(2, 2) gibt 0 zurück\n- count_walking_paths(4, 5) gibt 3 zurück",
      "ha": "Yana ƙididdige adadin hanyoyin daban-daban daga saman hagu zuwa ƙasan dama na grid,\ntare da ƙuntatawa cewa mutum zai iya motsawa kawai dama ko ƙasa kuma ba zai iya shiga sel inda lambobin layi da ginshiƙi duka biyu suke ma'aurata ba.\n\n  Huɗɗa:\n  - rows: Yawan layuka a cikin grid.\n  - cols: Yawan ginshikai a cikin grid.\n\n  Komawa:\n  - Yawan hanyoyin daban-daban da suka cika ƙa'idodin da aka bayar.\n\n  Misali:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "hi": "ऊपरी-बाएँ कोने से निचले-दाएँ कोने तक ग्रिड में विभिन्न पथों की संख्या की गणना करता है, इस बाधा के साथ कि कोई केवल दाएँ या नीचे की ओर बढ़ सकता है और उन कोशिकाओं में प्रवेश नहीं कर सकता जहाँ पंक्ति और स्तंभ संख्या दोनों सम हैं।\n\nArguments:\n- rows: ग्रिड में पंक्तियों की संख्या।\n- cols: ग्रिड में स्तंभों की संख्या।\n\nReturns:\n- दिए गए बाधाओं को संतुष्ट करने वाले विभिन्न पथों की संख्या।\n\nExample:\n- count_walking_paths(3, 4) returns 2\n- count_walking_paths(2, 2) returns 0\n- count_walking_paths(4, 5) returns 3",
      "hu": "Kiszámítja az egyedi útvonalak számát a rács bal felső sarkától a jobb alsó sarokig, azzal a megkötéssel, hogy csak jobbra vagy lefelé lehet mozogni, és nem lehet belépni olyan cellákba, ahol mind a sor, mind az oszlop száma páros.\n\nArgok:\n- rows: A rács sorainak száma.\n- cols: A rács oszlopainak száma.\n\nVisszatér:\n- Az adott feltételeknek megfelelő egyedi útvonalak száma.\n\nPélda:\n- count_walking_paths(3, 4) visszaadja 2\n- count_walking_paths(2, 2) visszaadja 0\n- count_walking_paths(4, 5) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9758848813296973",
      "hy": "0.9785963846612046",
      "bn": "0.9674869874499233",
      "bg": "0.978803158887862",
      "zh": "0.9593252650931997",
      "fr": "0.987514094248147",
      "de": "0.97030396351376",
      "ha": "0.9809132094255956",
      "hi": "0.9790274125880503",
      "hu": "0.9560536240871741"
    }
  },
  {
    "task_id": "Rust/12",
    "prompt": {
      "en": "/*\n  Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "sq": "/*\n  Numëron numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave në një varg të dhënë.\n\n  Argumentet:\n  - input: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla të anglishtes, si dhe shifra.\n\n  Kthen:\n  - Një treshe që përmban tre vlera usize që përfaqësojnë numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave, përkatësisht.\n\n  Shembull:\n  - count_character_types(\"Rust3IsFun!\") kthen (3, 6, 1)\n  - count_character_types(\"1234\") kthen (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") kthen (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "hy": "/*\n  Հաշվում է մեծատառերի, փոքրատառերի և թվանշանների քանակը տրված տողում:\n\n  Արգումենտներ:\n  - input: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, ինչպես նաև թվանշաններ:\n\n  Վերադարձնում է:\n  - Եռյակ, որը պարունակում է երեք usize արժեքներ, որոնք ներկայացնում են մեծատառերի, փոքրատառերի և թվանշանների քանակը, համապատասխանաբար:\n\n  Օրինակ:\n  - count_character_types(\"Rust3IsFun!\") վերադարձնում է (3, 6, 1)\n  - count_character_types(\"1234\") վերադարձնում է (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") վերադարձնում է (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "bn": "/*\n  প্রদত্ত স্ট্রিং-এ বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - input: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, পাশাপাশি সংখ্যা থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা যথাক্রমে বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার গণনা উপস্থাপন করে তিনটি usize মান ধারণ করে।\n\n  উদাহরণ:\n  - count_character_types(\"Rust3IsFun!\") (3, 6, 1) রিটার্ন করে\n  - count_character_types(\"1234\") (0, 0, 4) রিটার্ন করে\n  - count_character_types(\"HelloWorld!\") (2, 8, 0) রিটার্ন করে\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "bg": "/*\n  Брои броя на главните букви, малките букви и цифрите в даден низ.\n\n  Аргументи:\n  - input: Низ, който може да съдържа главни и малки английски букви, както и цифри.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize, представляващи броя на главните букви, малките букви и цифрите, съответно.\n\n  Пример:\n  - count_character_types(\"Rust3IsFun!\") връща (3, 6, 1)\n  - count_character_types(\"1234\") връща (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") връща (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "zh": "/*\n  统计给定字符串中大写字母、小写字母和数字的数量。\n\n  参数:\n  - input: 一个字符串，可能包含大写和小写的英文字母，以及数字。\n\n  返回:\n  - 一个包含三个 usize 值的元组，分别表示大写字母、小写字母和数字的数量。\n\n  示例:\n  - count_character_types(\"Rust3IsFun!\") 返回 (3, 6, 1)\n  - count_character_types(\"1234\") 返回 (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") 返回 (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "fr": "/*\n  Compte le nombre de lettres majuscules, de lettres minuscules et de chiffres dans une chaîne donnée.\n\n  Arguments:\n  - input: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, ainsi que des chiffres.\n\n  Renvoie:\n  - Un tuple contenant trois valeurs usize représentant les comptes de lettres majuscules, de lettres minuscules et de chiffres, respectivement.\n\n  Exemple:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "de": "/*\n  Zählt die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern in einem gegebenen String.\n\n  Argumente:\n  - input: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets sowie Ziffern enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält, die die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern darstellen.\n\n  Beispiel:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "ha": "/*\n  Yana ƙididdige adadin haruffan manyan baki, haruffan ƙananan baki, da lambobi a cikin kirtani da aka bayar.\n\n  Huɗa:\n  - input: Wani kirtani wanda zai iya ƙunsar haruffan manyan baki da ƙananan baki na Ingilishi, da kuma lambobi.\n\n  Mayarwa:\n  - Wani tuple mai ɗauke da ƙimar uku na usize wanda ke wakiltar ƙididdigar haruffan manyan baki, haruffan ƙananan baki, da lambobi, bi da bi.\n\n  Misali:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "hi": "/*\n  दिए गए स्ट्रिंग में बड़े अक्षरों, छोटे अक्षरों, और अंकों की संख्या गिनता है।\n\n  तर्क:\n  - input: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, साथ ही अंक हो सकते हैं।\n\n  लौटाता है:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं जो क्रमशः बड़े अक्षरों, छोटे अक्षरों, और अंकों की संख्या को दर्शाते हैं।\n\n  उदाहरण:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "hu": "/*\n  Megszámolja a nagybetűk, kisbetűk és számjegyek számát egy adott sztringben.\n\n  Argumentumok:\n  - input: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, valamint számjegyeket.\n\n  Visszatér:\n  - Egy hármas, amely három usize értéket tartalmaz, amelyek a nagybetűk, kisbetűk és számjegyek számát képviselik, ebben a sorrendben.\n\n  Példa:\n  - count_character_types(\"Rust3IsFun!\") visszaadja (3, 6, 1)\n  - count_character_types(\"1234\") visszaadja (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") visszaadja (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)"
    },
    "prompt_bertscore": {
      "sq": "0.9969905510969405",
      "hy": "0.9974050927021603",
      "bn": "0.9892749525760212",
      "bg": "0.9989180603145029",
      "zh": "0.9841870353658125",
      "fr": "0.999999801369619",
      "de": "0.9806837913355002",
      "ha": "0.9762739982461447",
      "hi": "0.9964979477519739",
      "hu": "0.9839546378200017"
    },
    "canonical_solution": "{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_character_types(input: &str) -> (usize, usize, usize)` to solve the following problem:\nCounts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "sq": "Shkruani një funksion Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave në një varg të dhënë.\n\n  Argumentet:\n  - input: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla të anglishtes, si dhe shifra.\n\n  Kthen:\n  - Një tuple që përmban tre vlera usize që përfaqësojnë numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave, përkatësisht.\n\n  Shembull:\n  - count_character_types(\"Rust3IsFun!\") kthen (3, 6, 1)\n  - count_character_types(\"1234\") kthen (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") kthen (2, 8, 0)",
      "hy": "Գրեք Rust ֆունկցիա `fn count_character_types(input: &str) -> (usize, usize, usize)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է մեծատառերի, փոքրատառերի և թվանշանների քանակը տրված տողում:\n\n  Արգումենտներ:\n  - input: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, ինչպես նաև թվանշաններ:\n\n  Վերադարձնում է:\n  - Թյուպլ, որը պարունակում է երեք usize արժեքներ, որոնք ներկայացնում են մեծատառերի, փոքրատառերի և թվանշանների քանակները համապատասխանաբար:\n\n  Օրինակ:\n  - count_character_types(\"Rust3IsFun!\") վերադարձնում է (3, 6, 1)\n  - count_character_types(\"1234\") վերադարձնում է (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") վերադարձնում է (2, 8, 0)",
      "bn": "Rust ফাংশন `fn count_character_types(input: &str) -> (usize, usize, usize)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত স্ট্রিং-এ বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - input: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, পাশাপাশি সংখ্যা থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে, যা যথাক্রমে বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_character_types(\"Rust3IsFun!\") রিটার্ন করে (3, 6, 1)\n  - count_character_types(\"1234\") রিটার্ন করে (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") রিটার্ন করে (2, 8, 0)",
      "bg": "Напишете функция на Rust `fn count_character_types(input: &str) -> (usize, usize, usize)`, за да решите следния проблем:\nБрои броя на главните букви, малките букви и цифрите в даден низ.\n\n  Аргументи:\n  - input: Низ, който може да съдържа главни и малки английски букви, както и цифри.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize, представляващи броя на главните букви, малките букви и цифрите, съответно.\n\n  Пример:\n  - count_character_types(\"Rust3IsFun!\") връща (3, 6, 1)\n  - count_character_types(\"1234\") връща (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") връща (2, 8, 0)",
      "zh": "编写一个 Rust 函数 `fn count_character_types(input: &str) -> (usize, usize, usize)` 来解决以下问题：\n计算给定字符串中大写字母、小写字母和数字的数量。\n\n参数：\n- input: 一个字符串，可能包含大写和小写英文字母，以及数字。\n\n返回：\n- 一个包含三个 usize 值的元组，分别表示大写字母、小写字母和数字的数量。\n\n示例：\n- count_character_types(\"Rust3IsFun!\") 返回 (3, 6, 1)\n- count_character_types(\"1234\") 返回 (0, 0, 4)\n- count_character_types(\"HelloWorld!\") 返回 (2, 8, 0)",
      "fr": "Écrire une fonction Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` pour résoudre le problème suivant :\nCompte le nombre de lettres majuscules, de lettres minuscules et de chiffres dans une chaîne donnée.\n\n  Arguments :\n  - input : Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, ainsi que des chiffres.\n\n  Renvoie :\n  - Un tuple contenant trois valeurs usize représentant les comptes de lettres majuscules, de lettres minuscules et de chiffres, respectivement.\n\n  Exemple :\n  - count_character_types(\"Rust3IsFun!\") renvoie (3, 6, 1)\n  - count_character_types(\"1234\") renvoie (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") renvoie (2, 8, 0)",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_character_types(input: &str) -> (usize, usize, usize)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern in einem gegebenen String.\n\n  Argumente:\n  - input: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets sowie Ziffern enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält, die die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern darstellen.\n\n  Beispiel:\n  - count_character_types(\"Rust3IsFun!\") gibt (3, 6, 1) zurück\n  - count_character_types(\"1234\") gibt (0, 0, 4) zurück\n  - count_character_types(\"HelloWorld!\") gibt (2, 8, 0) zurück",
      "ha": "Rubuta aikin Rust `fn count_character_types(input: &str) -> (usize, usize, usize)` don warware matsalar mai zuwa:\nYana ƙididdige adadin manyan haruffa, ƙananan haruffa, da lambobi a cikin kirtani da aka bayar.\n\n  Huɗɗa:\n  - input: Wani kirtani wanda zai iya ƙunsar manyan da ƙananan haruffan Ingilishi, da kuma lambobi.\n\n  Dawowa:\n  - Wani tuple wanda ke ɗauke da ƙimar uku na usize waɗanda ke wakiltar ƙididdigar manyan haruffa, ƙananan haruffa, da lambobi, bi da bi.\n\n  Misali:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "hi": "Rust फ़ंक्शन `fn count_character_types(input: &str) -> (usize, usize, usize)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में बड़े अक्षरों, छोटे अक्षरों, और अंकों की संख्या गिनें।\n\n  तर्क:\n  - input: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, साथ ही अंक हो सकते हैं।\n\n  रिटर्न करता है:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं जो क्रमशः बड़े अक्षरों, छोटे अक्षरों, और अंकों की गिनती का प्रतिनिधित्व करते हैं।\n\n  उदाहरण:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "hu": "Írj egy Rust függvényt `fn count_character_types(input: &str) -> (usize, usize, usize)` a következő probléma megoldására:\nSzámolja meg a nagybetűk, kisbetűk és számjegyek számát egy adott sztringben.\n\n  Argumentumok:\n  - input: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, valamint számjegyeket.\n\n  Visszatér:\n  - Egy hármas tuple, amely három usize értéket tartalmaz, amelyek a nagybetűk, kisbetűk és számjegyek számát képviselik, sorrendben.\n\n  Példa:\n  - count_character_types(\"Rust3IsFun!\") visszaadja (3, 6, 1)\n  - count_character_types(\"1234\") visszaadja (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") visszaadja (2, 8, 0)"
    },
    "instruction_bertscore": {
      "sq": "0.9970888731355527",
      "hy": "1",
      "bn": "0.98173553920308",
      "bg": "0.9790282071095744",
      "zh": "0.986296490012403",
      "fr": "0.996197221355087",
      "de": "0.9777869658584875",
      "ha": "0.978228521195528",
      "hi": "0.9762271214762205",
      "hu": "0.985761181135514"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_character_types(\"Rust3IsFun!\"), (3, 6, 1));\n        assert_eq!(count_character_types(\"1234\"), (0, 0, 4));\n        assert_eq!(count_character_types(\"HelloWorld!\"), (2, 8, 0));\n        assert_eq!(count_character_types(\"NoDigitsHere\"), (3, 9, 0));        \n    }\n    \n\n}",
    "entry_point": "count_character_types",
    "signature": "fn count_character_types(input: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "sq": "Numëron numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave në një varg të dhënë.\n\n  Argumentet:\n  - input: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla të anglishtes, si dhe shifra.\n\n  Kthen:\n  - Një tuple që përmban tre vlera usize që përfaqësojnë numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave, përkatësisht.\n\n  Shembull:\n  - count_character_types(\"Rust3IsFun!\") kthen (3, 6, 1)\n  - count_character_types(\"1234\") kthen (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") kthen (2, 8, 0)",
      "hy": "Հաշվում է մեծատառերի, փոքրատառերի և թվանշանների քանակը տրված տողում։\n\n  Արգումենտներ:\n  - input: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, ինչպես նաև թվանշաններ։\n\n  Վերադարձնում է:\n  - Եռյակ, որը պարունակում է երեք usize արժեքներ, որոնք ներկայացնում են մեծատառերի, փոքրատառերի և թվանշանների քանակները համապատասխանաբար։\n\n  Օրինակ:\n  - count_character_types(\"Rust3IsFun!\") վերադարձնում է (3, 6, 1)\n  - count_character_types(\"1234\") վերադարձնում է (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") վերադարձնում է (2, 8, 0)",
      "bn": "প্রদত্ত স্ট্রিং-এ বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা গণনা করে।\n\n  আর্গুমেন্টস:\n  - input: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, পাশাপাশি সংখ্যা থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে যা যথাক্রমে বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার গণনা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "bg": "Брои броя на главните букви, малките букви и цифрите в даден низ.\n\n  Аргументи:\n  - input: Низ, който може да съдържа главни и малки английски букви, както и цифри.\n\n  Връща:\n  - Кортеж, съдържащ три usize стойности, представляващи броя на главните букви, малките букви и цифрите, съответно.\n\n  Пример:\n  - count_character_types(\"Rust3IsFun!\") връща (3, 6, 1)\n  - count_character_types(\"1234\") връща (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") връща (2, 8, 0)",
      "zh": "计算给定字符串中大写字母、小写字母和数字的数量。\n\n  参数:\n  - input: 一个字符串，可能包含大写和小写的英文字母，以及数字。\n\n  返回:\n  - 一个元组，包含三个 usize 值，分别表示大写字母、小写字母和数字的数量。\n\n  示例:\n  - count_character_types(\"Rust3IsFun!\") 返回 (3, 6, 1)\n  - count_character_types(\"1234\") 返回 (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") 返回 (2, 8, 0)",
      "fr": "Compte le nombre de lettres majuscules, de lettres minuscules et de chiffres dans une chaîne donnée.\n\n  Arguments:\n  - input: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, ainsi que des chiffres.\n\n  Renvoie:\n  - Un tuple contenant trois valeurs usize représentant les comptes des lettres majuscules, des lettres minuscules et des chiffres, respectivement.\n\n  Exemple:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "de": "Zählt die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern in einem gegebenen String.\n\n  Argumente:\n  - input: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets sowie Ziffern enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält, die die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern darstellen.\n\n  Beispiel:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "ha": "Yana ƙididdige adadin haruffan manyan baki, haruffan ƙananan baki, da lambobi a cikin kirtani da aka bayar.\n\n  Huɗɗa:\n  - input: Wani kirtani wanda zai iya ƙunsar manyan haruffa da ƙananan haruffan Ingilishi, da kuma lambobi.\n\n  Komawa:\n  - Wani tuple wanda ke ɗauke da ƙimomi uku na usize waɗanda ke wakiltar ƙididdigar manyan haruffa, ƙananan haruffa, da lambobi, bi da bi.\n\n  Misali:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "hi": "दिए गए स्ट्रिंग में बड़े अक्षरों, छोटे अक्षरों, और अंकों की संख्या गिनता है।\n\n  तर्क:\n  - input: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, साथ ही अंक हो सकते हैं।\n\n  रिटर्न:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं जो क्रमशः बड़े अक्षरों, छोटे अक्षरों और अंकों की गिनती का प्रतिनिधित्व करते हैं।\n\n  उदाहरण:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "hu": "Számolja meg a nagybetűk, kisbetűk és számjegyek számát egy adott sztringben.\n\n  Argumentumok:\n  - input: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, valamint számjegyeket.\n\n  Visszatérési érték:\n  - Egy hármas, amely három usize értéket tartalmaz, és a nagybetűk, kisbetűk és számjegyek számát képviseli, ebben a sorrendben.\n\n  Példa:\n  - count_character_types(\"Rust3IsFun!\") visszaadja (3, 6, 1)\n  - count_character_types(\"1234\") visszaadja (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") visszaadja (2, 8, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.996532310807893",
      "hy": "0.998212326570686",
      "bn": "0.993560800307611",
      "bg": "0.9987394916019526",
      "zh": "0.9799715027891092",
      "fr": "1",
      "de": "0.977619520447275",
      "ha": "0.9844794192866959",
      "hi": "0.998747039556432",
      "hu": "0.9731499396132279"
    }
  },
  {
    "task_id": "Rust/13",
    "prompt": {
      "en": "/*\n  Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "sq": "/*\n  Konverton një sekuencë të dhënë numrash në vargun më të madh të mundshëm leksikografik të shkronjave të mëdha të alfabetit anglez, ku secila shkronjë korrespondon me pozicionin e saj në alfabet (A=1, B=2, ..., Z=26).\n\n  Funksioni interpreton sekuencën e numrave si një numër njëshifror ose dyshifror (që përfaqëson një shkronjë) për të maksimizuar rendin leksikografik të vargut rezultues.\n\n  Argumentet:\n  - encoded_sequence: Një varg që përbëhet nga shifra që përfaqësojnë pozicionet e koduara të shkronjave.\n\n  Kthen:\n  - Një varg i shkronjave të mëdha të alfabetit anglez që përfaqëson interpretimin më të madh të mundshëm leksikografik të sekuencës së koduar.\n\n  Shembuj:\n  - max_lexicographic_string(\"123242526\") kthen \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") kthen \"WRS\"\n  - max_lexicographic_string(\"102\") kthen \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "hy": "/*\n  Վերածում է տրված թվերի հաջորդականությունը լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեծատառ անգլերեն տառերի տողի, որտեղ յուրաքանչյուր տառ համապատասխանում է այբուբենի իր դիրքին (A=1, B=2, ..., Z=26):\n\n  Ֆունկցիան մեկնաբանում է թվերի հաջորդականությունը որպես մեկանիշ կամ երկնիշ թիվ (ներկայացնող տառ)՝ առավելագույնի հասցնելու համար ստացված տողի լեքսիկոգրաֆիկ կարգը:\n\n  Արգումենտներ:\n  - encoded_sequence: Թվանշաններից կազմված տող, որը ներկայացնում է կոդավորված տառերի դիրքերը:\n\n  Վերադարձնում է.\n  - Մեծատառ անգլերեն տառերի տող, որը ներկայացնում է կոդավորված հաջորդականության լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեկնաբանումը:\n\n  Օրինակներ:\n  - max_lexicographic_string(\"123242526\") վերադարձնում է \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") վերադարձնում է \"WRS\"\n  - max_lexicographic_string(\"102\") վերադարձնում է \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "bn": "/*\n  প্রদত্ত সংখ্যার একটি ক্রমকে লেক্সিকোগ্রাফিকভাবে সবচেয়ে বড় সম্ভাব্য বড় হাতের ইংরেজি অক্ষরের স্ট্রিংয়ে রূপান্তর করে, যেখানে প্রতিটি অক্ষর বর্ণমালার অবস্থানের সাথে সম্পর্কিত (A=1, B=2, ..., Z=26)।\n\n  ফাংশনটি সংখ্যার ক্রমকে একক-অঙ্ক বা দ্বিগুণ-অঙ্কের সংখ্যা (একটি অক্ষর উপস্থাপন করে) হিসাবে ব্যাখ্যা করে যাতে ফলাফল স্ট্রিংয়ের লেক্সিকোগ্রাফিক ক্রম সর্বাধিক হয়।\n\n  আর্গুমেন্টসমূহ:\n  - encoded_sequence: একটি স্ট্রিং যা এনকোড করা অক্ষরের অবস্থানগুলি উপস্থাপনকারী সংখ্যা নিয়ে গঠিত।\n\n  রিটার্ন করে:\n  - বড় হাতের ইংরেজি অক্ষরের একটি স্ট্রিং যা এনকোড করা ক্রমের লেক্সিকোগ্রাফিকভাবে সবচেয়ে বড় সম্ভাব্য ব্যাখ্যা উপস্থাপন করে।\n\n  উদাহরণসমূহ:\n  - max_lexicographic_string(\"123242526\") রিটার্ন করে \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") রিটার্ন করে \"WRS\"\n  - max_lexicographic_string(\"102\") রিটার্ন করে \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "bg": "/*\n  Преобразува дадена последователност от числа в лексикографски най-голямата възможна низ от главни английски букви, където всяка буква съответства на позицията си в азбуката (A=1, B=2, ..., Z=26).\n\n  Функцията интерпретира последователността от числа като едноцифрено или двуцифрено число (представляващо буква), за да максимизира лексикографския ред на получения низ.\n\n  Аргументи:\n  - encoded_sequence: Низ, състоящ се от цифри, представляващи кодираните позиции на буквите.\n\n  Връща:\n  - Низ от главни английски букви, който представлява лексикографски най-голямата възможна интерпретация на кодираната последователност.\n\n  Примери:\n  - max_lexicographic_string(\"123242526\") връща \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") връща \"WRS\"\n  - max_lexicographic_string(\"102\") връща \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "zh": "/*\n  将给定的数字序列转换为字典序最大的可能大写英文字母字符串，其中每个字母对应其在字母表中的位置 (A=1, B=2, ..., Z=26)。\n\n  该函数将数字序列解释为单个数字或双位数字（代表一个字母），以最大化结果字符串的字典序。\n\n  参数:\n  - encoded_sequence: 一个由数字组成的字符串，表示编码的字母位置。\n\n  返回:\n  - 一个大写英文字母字符串，表示编码序列的字典序最大可能解释。\n\n  示例:\n  - max_lexicographic_string(\"123242526\") 返回 \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") 返回 \"WRS\"\n  - max_lexicographic_string(\"102\") 返回 \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "fr": "/*\n  Convertit une séquence donnée de nombres en la chaîne lexicographiquement la plus grande possible de lettres majuscules anglaises, où chaque lettre correspond à sa position dans l'alphabet (A=1, B=2, ..., Z=26).\n\n  La fonction interprète la séquence de nombres soit comme un nombre à un chiffre, soit comme un nombre à deux chiffres (représentant une lettre) pour maximiser l'ordre lexicographique de la chaîne résultante.\n\n  Arguments :\n  - encoded_sequence : Une chaîne composée de chiffres représentant les positions des lettres encodées.\n\n  Renvoie :\n  - Une chaîne de lettres majuscules anglaises qui représente l'interprétation lexicographiquement la plus grande possible de la séquence encodée.\n\n  Exemples :\n  - max_lexicographic_string(\"123242526\") renvoie \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") renvoie \"WRS\"\n  - max_lexicographic_string(\"102\") renvoie \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "de": "/*\n  Wandelt eine gegebene Sequenz von Zahlen in die lexikografisch größtmögliche Zeichenfolge aus Großbuchstaben des englischen Alphabets um, wobei jeder Buchstabe seiner Position im Alphabet entspricht (A=1, B=2, ..., Z=26).\n\n  Die Funktion interpretiert die Zahlenfolge entweder als einstellige oder zweistellige Zahl (die einen Buchstaben darstellt), um die lexikografische Reihenfolge der resultierenden Zeichenfolge zu maximieren.\n\n  Argumente:\n  - encoded_sequence: Ein String, der aus Ziffern besteht, die die kodierten Buchstabenpositionen darstellen.\n\n  Rückgabewert:\n  - Ein String aus Großbuchstaben des englischen Alphabets, der die lexikografisch größtmögliche Interpretation der kodierten Sequenz darstellt.\n\n  Beispiele:\n  - max_lexicographic_string(\"123242526\") gibt \"LCXYZ\" zurück\n  - max_lexicographic_string(\"231819\") gibt \"WRS\" zurück\n  - max_lexicographic_string(\"102\") gibt \"JB\" zurück\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "ha": "/*\n  Canza jerin lambobi da aka bayar zuwa mafi girman yiwuwar jeri na manyan haruffan Ingilishi, inda kowace harafi ta dace da matsayinta a haruffa (A=1, B=2, ..., Z=26).\n\n  Aikin yana fassara jerin lambobi a matsayin ko dai lamba guda ɗaya ko lambobi biyu (wakiltar harafi) don haɓaka tsarin lexicographic na sakamakon jeri.\n\n  Huɗɗa:\n  - encoded_sequence: Wani jeri mai ƙunshe da lambobi da ke wakiltar matsayi na haruffa da aka loda.\n\n  Mayarwa:\n  - Wani jeri na manyan haruffan Ingilishi wanda ke wakiltar mafi girman yiwuwar fassarar lexicographic na jerin da aka loda.\n\n  Misalai:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "hi": "/*\n  दिए गए संख्याओं के अनुक्रम को अंग्रेजी के बड़े अक्षरों की वर्णक्रमानुसार सबसे बड़ी संभव स्ट्रिंग में परिवर्तित करता है, जहाँ प्रत्येक अक्षर वर्णमाला में उसकी स्थिति के अनुसार होता है (A=1, B=2, ..., Z=26)।\n\n  यह फ़ंक्शन संख्याओं के अनुक्रम को या तो एकल-अंकीय या दोहरे-अंकीय संख्या के रूप में व्याख्या करता है (जो एक अक्षर का प्रतिनिधित्व करता है) ताकि परिणामी स्ट्रिंग का वर्णक्रमानुसार क्रम अधिकतम हो सके।\n\n  तर्क:\n  - encoded_sequence: अंकों से बना एक स्ट्रिंग जो एन्कोडेड अक्षर स्थितियों का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - अंग्रेजी के बड़े अक्षरों की एक स्ट्रिंग जो एन्कोडेड अनुक्रम की वर्णक्रमानुसार सबसे बड़ी संभव व्याख्या का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "hu": "/*\n  Egy adott számok sorozatát átalakítja a lehetséges legnagyobb lexikografikus sorrendű nagybetűs angol betűk sorozatává, ahol minden betű az ábécé szerinti pozíciójának felel meg (A=1, B=2, ..., Z=26).\n\n  A függvény a számok sorozatát vagy egyjegyű, vagy kétjegyű számként értelmezi (amely egy betűt képvisel), hogy maximalizálja a kapott sztring lexikografikus sorrendjét.\n\n  Argumentumok:\n  - encoded_sequence: Egy számjegyekből álló sztring, amely a kódolt betűpozíciókat képviseli.\n\n  Visszatér:\n  - Egy nagybetűs angol betűkből álló sztring, amely a kódolt sorozat lehetséges legnagyobb lexikografikus értelmezését képviseli.\n\n  Példák:\n  - max_lexicographic_string(\"123242526\") visszatér \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") visszatér \"WRS\"\n  - max_lexicographic_string(\"102\") visszatér \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9829589037198738",
      "hy": "0.9759313608388595",
      "bn": "0.9751833188238821",
      "bg": "0.9938218006282908",
      "zh": "0.9618401243474825",
      "fr": "0.9810768808595682",
      "de": "0.976030676029377",
      "ha": "0.9360251268762833",
      "hi": "0.9690841743438249",
      "hu": "0.9748192293354452"
    },
    "canonical_solution": "{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_lexicographic_string(encoded_sequence: &str) -> String` to solve the following problem:\nConverts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "sq": "Shkruani një funksion në Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` për të zgjidhur problemin e mëposhtëm:\nKonverton një sekuencë të dhënë numrash në vargun më të madh të mundshëm leksikografik të shkronjave të mëdha të alfabetit anglisht, ku secila shkronjë korrespondon me pozicionin e saj në alfabet (A=1, B=2, ..., Z=26).\n\n  Funksioni interpreton sekuencën e numrave si një numër me një shifër ose me dy shifra (që përfaqëson një shkronjë) për të maksimizuar rendin leksikografik të vargut rezultues.\n\n  Argumentet:\n  - encoded_sequence: Një varg që përbëhet nga shifra që përfaqësojnë pozicionet e koduara të shkronjave.\n\n  Kthen:\n  - Një varg me shkronja të mëdha të alfabetit anglisht që përfaqëson interpretimin më të madh të mundshëm leksikografik të sekuencës së koduar.\n\n  Shembuj:\n  - max_lexicographic_string(\"123242526\") kthen \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") kthen \"WRS\"\n  - max_lexicographic_string(\"102\") kthen \"JB\"",
      "hy": "Գրեք Rust ֆունկցիա `fn max_lexicographic_string(encoded_sequence: &str) -> String` հետևյալ խնդիրը լուծելու համար:\nՎերածում է տրված թվերի հաջորդականությունը հնարավորինս լեքսիկոգրաֆիկորեն մեծ տառերի մեծատառ անգլերեն տառերի, որտեղ յուրաքանչյուր տառ համապատասխանում է այբուբենի իր դիրքին (A=1, B=2, ..., Z=26):\n\n  Ֆունկցիան մեկնաբանում է թվերի հաջորդականությունը որպես միանիշ կամ երկնիշ թիվ (ներկայացնող տառ)՝ առավելագույնի հասցնելու համար ստացված տողի լեքսիկոգրաֆիկ կարգը:\n\n  Արգումենտներ:\n  - encoded_sequence: Նիշերի տող, որը բաղկացած է թվանշաններից, որոնք ներկայացնում են կոդավորված տառերի դիրքերը:\n\n  Վերադարձնում է.\n  - Մեծատառ անգլերեն տառերի տող, որը ներկայացնում է կոդավորված հաջորդականության լեքսիկոգրաֆիկորեն հնարավորինս մեծ մեկնաբանությունը:\n\n  Օրինակներ:\n  - max_lexicographic_string(\"123242526\") վերադարձնում է \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") վերադարձնում է \"WRS\"\n  - max_lexicographic_string(\"102\") վերադարձնում է \"JB\"",
      "bn": "Rust ফাংশন `fn max_lexicographic_string(encoded_sequence: &str) -> String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার একটি সিকোয়েন্সকে লেক্সিকোগ্রাফিকভাবে সবচেয়ে বড় সম্ভাব্য বড় হাতের ইংরেজি অক্ষরের স্ট্রিংয়ে রূপান্তর করে, যেখানে প্রতিটি অক্ষর বর্ণমালায় তার অবস্থানের সাথে সম্পর্কিত (A=1, B=2, ..., Z=26)।\n\n  ফাংশনটি সংখ্যার সিকোয়েন্সকে একক-অঙ্ক বা দ্বিগুণ-অঙ্কের সংখ্যা (যা একটি অক্ষরকে উপস্থাপন করে) হিসেবে ব্যাখ্যা করে যাতে ফলাফল স্ট্রিংয়ের লেক্সিকোগ্রাফিক ক্রম সর্বাধিক হয়।\n\n  আর্গুমেন্টসমূহ:\n  - encoded_sequence: একটি স্ট্রিং যা এনকোড করা অক্ষর অবস্থানগুলিকে উপস্থাপন করে এমন সংখ্যার সমন্বয়ে গঠিত।\n\n  রিটার্নস:\n  - বড় হাতের ইংরেজি অক্ষরের একটি স্ট্রিং যা এনকোড করা সিকোয়েন্সের লেক্সিকোগ্রাফিকভাবে সবচেয়ে বড় সম্ভাব্য ব্যাখ্যাকে উপস্থাপন করে।\n\n  উদাহরণসমূহ:\n  - max_lexicographic_string(\"123242526\") রিটার্ন করে \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") রিটার্ন করে \"WRS\"\n  - max_lexicographic_string(\"102\") রিটার্ন করে \"JB\"",
      "bg": "Напишете функция на Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String`, за да решите следния проблем:\nПреобразува дадена последователност от числа в лексикографски най-голямата възможна низ от главни английски букви, където всяка буква съответства на позицията си в азбуката (A=1, B=2, ..., Z=26).\n\nФункцията интерпретира последователността от числа като едноцифрено или двуцифрено число (представляващо буква), за да максимизира лексикографския ред на получения низ.\n\nАргументи:\n- encoded_sequence: Низ, състоящ се от цифри, представляващи кодираните позиции на буквите.\n\nВръща:\n- Низ от главни английски букви, който представлява лексикографски най-голямата възможна интерпретация на кодираната последователност.\n\nПримери:\n- max_lexicographic_string(\"123242526\") връща \"LCXYZ\"\n- max_lexicographic_string(\"231819\") връща \"WRS\"\n- max_lexicographic_string(\"102\") връща \"JB\"",
      "zh": "编写一个 Rust 函数 `fn max_lexicographic_string(encoded_sequence: &str) -> String` 来解决以下问题：\n将给定的数字序列转换为字典序最大的可能大写英文字母字符串，其中每个字母对应于其在字母表中的位置 (A=1, B=2, ..., Z=26)。\n\n函数将数字序列解释为单个数字或双位数字（表示一个字母），以最大化结果字符串的字典序。\n\n参数：\n- encoded_sequence: 一个由数字组成的字符串，表示编码的字母位置。\n\n返回：\n- 一个大写英文字母字符串，表示编码序列的字典序最大可能解释。\n\n示例：\n- max_lexicographic_string(\"123242526\") 返回 \"LCXYZ\"\n- max_lexicographic_string(\"231819\") 返回 \"WRS\"\n- max_lexicographic_string(\"102\") 返回 \"JB\"",
      "fr": "Écrire une fonction Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` pour résoudre le problème suivant :\nConvertit une séquence donnée de chiffres en la chaîne lexicographiquement la plus grande possible de lettres majuscules anglaises, où chaque lettre correspond à sa position dans l'alphabet (A=1, B=2, ..., Z=26).\n\n  La fonction interprète la séquence de chiffres soit comme un nombre à un chiffre, soit comme un nombre à deux chiffres (représentant une lettre) pour maximiser l'ordre lexicographique de la chaîne résultante.\n\n  Arguments :\n  - encoded_sequence : Une chaîne composée de chiffres représentant les positions des lettres encodées.\n\n  Renvoie :\n  - Une chaîne de lettres majuscules anglaises qui représente l'interprétation lexicographiquement la plus grande possible de la séquence encodée.\n\n  Exemples :\n  - max_lexicographic_string(\"123242526\") renvoie \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") renvoie \"WRS\"\n  - max_lexicographic_string(\"102\") renvoie \"JB\"",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_lexicographic_string(encoded_sequence: &str) -> String`, um das folgende Problem zu lösen:\nWandelt eine gegebene Sequenz von Zahlen in die lexikografisch größtmögliche Zeichenkette aus Großbuchstaben des englischen Alphabets um, wobei jeder Buchstabe seiner Position im Alphabet entspricht (A=1, B=2, ..., Z=26).\n\n  Die Funktion interpretiert die Zahlenfolge entweder als einstellige oder zweistellige Zahl (die einen Buchstaben darstellt), um die lexikografische Reihenfolge der resultierenden Zeichenkette zu maximieren.\n\n  Argumente:\n  - encoded_sequence: Ein String, der aus Ziffern besteht, die die kodierten Buchstabenpositionen darstellen.\n\n  Rückgabewert:\n  - Ein String aus Großbuchstaben des englischen Alphabets, der die lexikografisch größtmögliche Interpretation der kodierten Sequenz darstellt.\n\n  Beispiele:\n  - max_lexicographic_string(\"123242526\") gibt \"LCXYZ\" zurück\n  - max_lexicographic_string(\"231819\") gibt \"WRS\" zurück\n  - max_lexicographic_string(\"102\") gibt \"JB\" zurück",
      "ha": "Rubuta aikin Rust `fn max_lexicographic_string(encoded_sequence: &str) -> String` don warware matsalar mai zuwa:\nCanza jerin lambobi da aka bayar zuwa mafi girman yuwuwar jerin haruffan Turanci manya, inda kowanne harafi ya dace da matsayinsa a cikin haruffa (A=1, B=2, ..., Z=26).\n\n  Aikin yana fassara jerin lambobi a matsayin ko dai lamba guda ɗaya ko lambobi biyu (wakiltar harafi) don haɓaka oda na lexicographic na jerin da aka samu.\n\n  Huɗɗa:\n  - encoded_sequence: Wani igiyar rubutu da ke ƙunshe da lambobi da ke wakiltar matsayen haruffan da aka loda.\n\n  Komawa:\n  - Wani igiyar rubutu na manyan haruffan Turanci wanda ke wakiltar mafi girman yuwuwar fassarar lexicographic na jerin da aka loda.\n\n  Misalai:\n  - max_lexicographic_string(\"123242526\") yana dawowa \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") yana dawowa \"WRS\"\n  - max_lexicographic_string(\"102\") yana dawowa \"JB\"",
      "hi": "Rust फ़ंक्शन `fn max_lexicographic_string(encoded_sequence: &str) -> String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं के दिए गए अनुक्रम को बड़े अक्षरों में अंग्रेजी अक्षरों की वर्णक्रमानुसार सबसे बड़ी संभव स्ट्रिंग में परिवर्तित करता है, जहाँ प्रत्येक अक्षर वर्णमाला में अपनी स्थिति के अनुरूप होता है (A=1, B=2, ..., Z=26)।\n\n  फ़ंक्शन संख्याओं के अनुक्रम को एकल-अंक या दोहरे-अंक संख्या (जो एक अक्षर का प्रतिनिधित्व करती है) के रूप में व्याख्या करता है ताकि परिणामी स्ट्रिंग के वर्णक्रमानुसार क्रम को अधिकतम किया जा सके।\n\n  तर्क:\n  - encoded_sequence: अंक वाले एक स्ट्रिंग जो एन्कोडेड अक्षर स्थितियों का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - बड़े अक्षरों में अंग्रेजी अक्षरों की एक स्ट्रिंग जो एन्कोडेड अनुक्रम की वर्णक्रमानुसार सबसे बड़ी संभव व्याख्या का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - max_lexicographic_string(\"123242526\") \"LCXYZ\" लौटाता है\n  - max_lexicographic_string(\"231819\") \"WRS\" लौटाता है\n  - max_lexicographic_string(\"102\") \"JB\" लौटाता है",
      "hu": "Írj egy Rust függvényt `fn max_lexicographic_string(encoded_sequence: &str) -> String` a következő probléma megoldására:\nEgy adott számsorozatot átalakít a lehető legnagyobb lehetséges lexikografikus sorrendű nagybetűs angol betűk sorozatává, ahol minden betű az ábécében elfoglalt helyének felel meg (A=1, B=2, ..., Z=26).\n\n  A függvény a számsorozatot egyjegyű vagy kétjegyű számként értelmezi (amely egy betűt képvisel) annak érdekében, hogy maximalizálja a kapott sorozat lexikografikus sorrendjét.\n\n  Argumentumok:\n  - encoded_sequence: Egy számjegyekből álló karakterlánc, amely a kódolt betűpozíciókat képviseli.\n\n  Visszatér:\n  - Egy nagybetűs angol betűkből álló karakterlánc, amely a kódolt sorozat lehető legnagyobb lexikografikus értelmezését képviseli.\n\n  Példák:\n  - max_lexicographic_string(\"123242526\") visszatér \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") visszatér \"WRS\"\n  - max_lexicographic_string(\"102\") visszatér \"JB\""
    },
    "instruction_bertscore": {
      "sq": "0.9789656385395484",
      "hy": "0.9750573871623059",
      "bn": "0.9617853023623169",
      "bg": "0.9873587652901776",
      "zh": "0.9667860208352512",
      "fr": "0.9773505749113538",
      "de": "0.9779887743256188",
      "ha": "0.9562993298685143",
      "hi": "0.9674554052193387",
      "hu": "0.9701611482697959"
    },
    "level": "hard",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_lexicographic_string(\"123242526\"), \"LCXYZ\");\n        assert_eq!(max_lexicographic_string(\"231819\"), \"WRS\");\n        assert_eq!(max_lexicographic_string(\"102\"), \"JB\");\n        assert_eq!(max_lexicographic_string(\"26\"), \"Z\");   \n    }\n    \n\n}",
    "entry_point": "max_lexicographic_string",
    "signature": "fn max_lexicographic_string(encoded_sequence: &str) -> String",
    "docstring": {
      "en": "Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "sq": "Konverton një sekuencë të dhënë numrash në vargun më të madh të mundshëm leksikografik të shkronjave të mëdha të anglishtes, ku secila shkronjë korrespondon me pozicionin e saj në alfabet (A=1, B=2, ..., Z=26).\n\n  Funksioni interpreton sekuencën e numrave si një numër njëshifror ose dyshifror (që përfaqëson një shkronjë) për të maksimizuar rendin leksikografik të vargut rezultues.\n\n  Argumentet:\n  - encoded_sequence: Një varg që përbëhet nga shifrat që përfaqësojnë pozicionet e shkronjave të koduara.\n\n  Kthen:\n  - Një varg i shkronjave të mëdha të anglishtes që përfaqëson interpretimin më të madh të mundshëm leksikografik të sekuencës së koduar.\n\n  Shembuj:\n  - max_lexicographic_string(\"123242526\") kthen \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") kthen \"WRS\"\n  - max_lexicographic_string(\"102\") kthen \"JB\"",
      "hy": "Վերածում է տրված թվերի հաջորդականությունը լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեծատառ անգլերեն տառերի տողի, որտեղ յուրաքանչյուր տառ համապատասխանում է այբուբենի իր դիրքին (A=1, B=2, ..., Z=26):\n\nՖունկցիան մեկնաբանում է թվերի հաջորդականությունը որպես մեկանիշ կամ երկնիշ թիվ (ներկայացնող տառ)՝ առավելագույնի հասցնելու համար ստացված տողի լեքսիկոգրաֆիկ կարգը:\n\nԱրգումենտներ:\n- encoded_sequence: Թվանշաններից բաղկացած տող, որը ներկայացնում է կոդավորված տառերի դիրքերը:\n\nՎերադարձնում է:\n- Մեծատառ անգլերեն տառերի տող, որը ներկայացնում է կոդավորված հաջորդականության լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեկնաբանությունը:\n\nՕրինակներ:\n- max_lexicographic_string(\"123242526\") վերադարձնում է \"LCXYZ\"\n- max_lexicographic_string(\"231819\") վերադարձնում է \"WRS\"\n- max_lexicographic_string(\"102\") վերադարձնում է \"JB\"",
      "bn": "একটি প্রদত্ত সংখ্যার ক্রমকে বৃহত্তম লেক্সিকোগ্রাফিক সম্ভাব্য স্ট্রিংয়ে রূপান্তর করে, যেখানে প্রতিটি অক্ষর বর্ণমালায় তার অবস্থানের সাথে সম্পর্কিত (A=1, B=2, ..., Z=26)।\n\nফাংশনটি সংখ্যার ক্রমকে একক-সংখ্যা বা দ্বিগুণ-সংখ্যা (যা একটি অক্ষর প্রতিনিধিত্ব করে) হিসাবে ব্যাখ্যা করে যাতে ফলাফল স্ট্রিংয়ের লেক্সিকোগ্রাফিক ক্রম সর্বাধিক হয়।\n\nArguments:\n- encoded_sequence: একটি স্ট্রিং যা সংখ্যার সমন্বয়ে গঠিত যা এনকোড করা অক্ষরের অবস্থানগুলি প্রতিনিধিত্ব করে।\n\nReturns:\n- একটি বড় হাতের ইংরেজি অক্ষরের স্ট্রিং যা এনকোড করা ক্রমের লেক্সিকোগ্রাফিকভাবে বৃহত্তম সম্ভাব্য ব্যাখ্যা প্রতিনিধিত্ব করে।\n\nExamples:\n- max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n- max_lexicographic_string(\"231819\") returns \"WRS\"\n- max_lexicographic_string(\"102\") returns \"JB\"",
      "bg": "Преобразува дадена последователност от числа в лексикографски най-голямата възможна поредица от главни английски букви, където всяка буква съответства на позицията си в азбуката (A=1, B=2, ..., Z=26).\n\nФункцията интерпретира последователността от числа като едноцифрено или двуцифрено число (представляващо буква), за да максимизира лексикографския ред на получената поредица.\n\nАргументи:\n- encoded_sequence: Низ, състоящ се от цифри, представляващи позициите на кодираните букви.\n\nВръща:\n- Низ от главни английски букви, който представлява лексикографски най-голямата възможна интерпретация на кодираната последователност.\n\nПримери:\n- max_lexicographic_string(\"123242526\") връща \"LCXYZ\"\n- max_lexicographic_string(\"231819\") връща \"WRS\"\n- max_lexicographic_string(\"102\") връща \"JB\"",
      "zh": "将给定的数字序列转换为按字典序排列的可能的最大大写英文字母字符串，其中每个字母对应于其在字母表中的位置（A=1, B=2, ..., Z=26）。\n\n该函数将数字序列解释为单个数字或双位数字（代表一个字母），以最大化结果字符串的字典序。\n\n参数:\n- encoded_sequence: 一个由数字组成的字符串，表示编码的字母位置。\n\n返回:\n- 一个大写英文字母字符串，表示编码序列的按字典序排列的最大可能解释。\n\n示例:\n- max_lexicographic_string(\"123242526\") 返回 \"LCXYZ\"\n- max_lexicographic_string(\"231819\") 返回 \"WRS\"\n- max_lexicographic_string(\"102\") 返回 \"JB\"",
      "fr": "Convertit une séquence donnée de nombres en la chaîne lexicographiquement la plus grande possible de lettres majuscules anglaises, où chaque lettre correspond à sa position dans l'alphabet (A=1, B=2, ..., Z=26).\n\n  La fonction interprète la séquence de nombres soit comme un nombre à un chiffre, soit comme un nombre à deux chiffres (représentant une lettre) pour maximiser l'ordre lexicographique de la chaîne résultante.\n\n  Arguments:\n  - encoded_sequence: Une chaîne composée de chiffres représentant les positions des lettres encodées.\n\n  Returns:\n  - Une chaîne de lettres majuscules anglaises qui représente l'interprétation lexicographiquement la plus grande possible de la séquence encodée.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "de": "Konvertiert eine gegebene Sequenz von Zahlen in die lexikografisch größtmögliche Zeichenkette aus Großbuchstaben des englischen Alphabets, wobei jeder Buchstabe seiner Position im Alphabet entspricht (A=1, B=2, ..., Z=26).\n\n  Die Funktion interpretiert die Zahlenfolge entweder als einstellige oder zweistellige Zahl (die einen Buchstaben darstellt), um die lexikografische Reihenfolge der resultierenden Zeichenkette zu maximieren.\n\n  Argumente:\n  - encoded_sequence: Ein String bestehend aus Ziffern, die die kodierten Buchstabenpositionen darstellen.\n\n  Rückgabewert:\n  - Ein String aus Großbuchstaben des englischen Alphabets, der die lexikografisch größtmögliche Interpretation der kodierten Sequenz darstellt.\n\n  Beispiele:\n  - max_lexicographic_string(\"123242526\") gibt \"LCXYZ\" zurück\n  - max_lexicographic_string(\"231819\") gibt \"WRS\" zurück\n  - max_lexicographic_string(\"102\") gibt \"JB\" zurück",
      "ha": "Canza jerin lambobi da aka bayar zuwa mafi girman yiwuwar jeri na manyan haruffan Ingilishi, inda kowace harafi ta dace da matsayinta a haruffa (A=1, B=2, ..., Z=26).\n\n  Aikin wannan aiki yana fassara jerin lambobi a matsayin ko dai lamba guda ɗaya ko lambobi biyu (wakiltar harafi) don haɓaka oda na lexicographic na sakamakon kirtani.\n\n  Huɗɗa:\n  - encoded_sequence: Wani kirtani mai ƙunshe da lambobi da ke wakiltar matsayi na haruffan da aka lamba.\n\n  Dawowa:\n  - Wani kirtani na manyan haruffan Ingilishi wanda ke wakiltar mafi girman fassarar lexicographically na jerin lambobin da aka lamba.\n\n  Misalai:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "hi": "दिए गए संख्याओं के अनुक्रम को बड़े अक्षरों में अंग्रेजी अक्षरों की वर्णक्रमानुसार सबसे बड़ी संभव स्ट्रिंग में बदलता है, जहाँ प्रत्येक अक्षर वर्णमाला में उसकी स्थिति के अनुसार होता है (A=1, B=2, ..., Z=26)।\n\n  यह फ़ंक्शन संख्याओं के अनुक्रम को या तो एकल अंक या दोहरे अंक संख्या (जो एक अक्षर का प्रतिनिधित्व करती है) के रूप में व्याख्यायित करता है ताकि परिणामी स्ट्रिंग का वर्णक्रमानुसार क्रम अधिकतम हो सके।\n\n  तर्क:\n  - encoded_sequence: एक स्ट्रिंग जिसमें अंक होते हैं जो एन्कोडेड अक्षर स्थितियों का प्रतिनिधित्व करते हैं।\n\n  वापसी:\n  - बड़े अक्षरों में अंग्रेजी अक्षरों की एक स्ट्रिंग जो एन्कोडेड अनुक्रम की वर्णक्रमानुसार सबसे बड़ी संभव व्याख्या का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "hu": "Átalakít egy adott számokból álló sorozatot a lehető legnagyobb lexikografikus sorrendű nagybetűs angol betűk sorozatává, ahol minden betű az ábécében elfoglalt helyének felel meg (A=1, B=2, ..., Z=26).\n\nA függvény a számok sorozatát vagy egyjegyű, vagy kétjegyű számként értelmezi (amely egy betűt jelöl), hogy maximalizálja a kapott sztring lexikografikus sorrendjét.\n\nArgok:\n- encoded_sequence: Egy számjegyekből álló sztring, amely a kódolt betűpozíciókat jelöli.\n\nVisszatér:\n- Egy nagybetűs angol betűkből álló sztring, amely az encoded_sequence lehető legnagyobb lexikografikus értelmezését képviseli.\n\nPéldák:\n- max_lexicographic_string(\"123242526\") visszaadja \"LCXYZ\"\n- max_lexicographic_string(\"231819\") visszaadja \"WRS\"\n- max_lexicographic_string(\"102\") visszaadja \"JB\""
    },
    "docstring_bertscore": {
      "sq": "0.9821047930814238",
      "hy": "0.9803910101538548",
      "bn": "0.9440261572547496",
      "bg": "0.9852262695193871",
      "zh": "0.950092329091555",
      "fr": "0.9735986456439858",
      "de": "0.9771767733279483",
      "ha": "0.9586977917195105",
      "hi": "0.9757444496503057",
      "hu": "0.9595227036919484"
    }
  },
  {
    "task_id": "Rust/14",
    "prompt": {
      "en": "/*\n    Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "sq": "/*\n    Llogarit shumën maksimale të numrave përgjatë një rruge nga maja në fund të një trekëndëshi numerik të dhënë.\n\n    Rruga lëviz poshtë në numrin më të afërt majtas ose djathtas në rreshtin tjetër. Dallimi midis numrit të lëvizjeve majtas dhe djathtas nuk duhet të kalojë një.\n\n    Argumentet:\n    - triangle: Një vektor i vektorëve të i32, që përfaqëson rreshtat e trekëndëshit numerik. Çdo vektor i brendshëm përfaqëson një rresht në trekëndësh.\n\n    Kthen:\n    - Shuma maksimale e arritshme në çdo rrugë të vlefshme nga maja në fund të trekëndëshit.\n\n    Shembuj:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) kthen 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) kthen 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "hy": "/*\n    Հաշվարկում է թվերի առավելագույն գումարը ճանապարհի երկայնքով, որը տանում է վերևից դեպի ներքև տրված թվային եռանկյունում:\n\n    Ճանապարհը շարժվում է դեպի ներքև՝ հաջորդ տողում ամենամոտ ձախ կամ աջ թվին: Ձախ և աջ շարժումների քանակների տարբերությունը չպետք է գերազանցի մեկ:\n\n    Արգումենտներ:\n    - triangle: i32-ների վեկտորների վեկտոր, որը ներկայացնում է թվային եռանկյունու տողերը: Յուրաքանչյուր ներքին վեկտոր ներկայացնում է եռանկյունու մեկ տող:\n\n    Վերադարձնում է:\n    - Առավելագույն գումարը, որը հնարավոր է հասնել ցանկացած վավեր ճանապարհով վերևից դեպի ներքև եռանկյունու մեջ:\n\n    Օրինակներ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) վերադարձնում է 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) վերադարձնում է 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "bn": "/*\n    একটি প্রদত্ত সংখ্যাসূচক ত্রিভুজের উপরের দিক থেকে নিচের দিকে একটি পথ বরাবর সংখ্যাগুলোর সর্বাধিক যোগফল গণনা করে।\n\n    পথটি পরবর্তী সারিতে নিকটতম বাম বা ডান সংখ্যায় নিচে চলে যায়। বাম দিকে এবং ডান দিকে যাওয়ার চলাফেরার পার্থক্য একের বেশি হওয়া উচিত নয়।\n\n    আর্গুমেন্টসমূহ:\n    - triangle: i32 এর ভেক্টরের ভেক্টর, যা সংখ্যাসূচক ত্রিভুজের সারিগুলিকে উপস্থাপন করে। প্রতিটি অভ্যন্তরীণ ভেক্টর ত্রিভুজের একটি সারি উপস্থাপন করে।\n\n    রিটার্নস:\n    - ত্রিভুজের উপরের দিক থেকে নিচের দিকে যেকোনো বৈধ পথে অর্জনযোগ্য সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 রিটার্ন করে\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 রিটার্ন করে\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "bg": "/*\n    Изчислява максималната сума на числата по път от върха до дъното на даден числов триъгълник.\n\n    Пътят се движи надолу към най-близкото ляво или дясно число на следващия ред. Разликата между броя на движенията наляво и надясно не трябва да надвишава едно.\n\n    Аргументи:\n    - triangle: Вектор от вектори от i32, представляващи редовете на числовия триъгълник. Всеки вътрешен вектор представлява ред в триъгълника.\n\n    Връща:\n    - Максималната сума, която може да се постигне по който и да е валиден път от върха до дъното на триъгълника.\n\n    Примери:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) връща 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) връща 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "zh": "/*\n    计算从顶部到底部沿路径的数字最大和。\n\n    路径向下移动到下一行的最近左侧或右侧的数字。向左和向右移动的次数之差不得超过一。\n\n    参数:\n    - triangle: 一个i32的向量的向量，表示数字三角形的行。每个内部向量表示三角形中的一行。\n\n    返回:\n    - 从三角形顶部到底部的任何有效路径上可实现的最大和。\n\n    示例:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "fr": "/*\n    Calcule la somme maximale de nombres le long d'un chemin du haut vers le bas d'un triangle numérique donné.\n\n    Le chemin descend vers le nombre le plus proche à gauche ou à droite sur la ligne suivante. La différence entre le nombre de mouvements vers la gauche et vers la droite ne doit pas dépasser un.\n\n    Arguments :\n    - triangle : Un vecteur de vecteurs de i32, représentant les lignes du triangle numérique. Chaque vecteur interne représente une ligne dans le triangle.\n\n    Renvoie :\n    - La somme maximale réalisable sur tout chemin valide du haut vers le bas du triangle.\n\n    Exemples :\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) renvoie 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) renvoie 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "de": "/*\n    Berechnet die maximale Summe von Zahlen entlang eines Pfades von der Spitze bis zum Boden eines gegebenen numerischen Dreiecks.\n\n    Der Pfad bewegt sich nach unten entweder zur nächstgelegenen linken oder rechten Zahl in der nächsten Zeile. Der Unterschied zwischen der Anzahl der Bewegungen nach links und nach rechts darf nicht mehr als eins betragen.\n\n    Argumente:\n    - triangle: Ein Vektor von Vektoren von i32, der die Reihen des numerischen Dreiecks darstellt. Jeder innere Vektor repräsentiert eine Reihe im Dreieck.\n\n    Rückgabewert:\n    - Die maximale Summe, die auf einem gültigen Pfad von der Spitze bis zum Boden des Dreiecks erreichbar ist.\n\n    Beispiele:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) gibt 27 zurück\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) gibt 11 zurück\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "ha": "/*\n    Lissafa mafi girman jimlar lambobi tare da hanya daga saman zuwa kasan wani alwatika na lambobi.\n\n    Hanyar tana motsawa zuwa ko dai mafi kusa na hagu ko dama akan layi na gaba. Bambanci tsakanin adadin motsi zuwa hagu da dama bai kamata ya wuce daya ba.\n\n    Huɗɗa:\n    - triangle: Wani vector na vectors na i32, yana wakiltar layukan alwatika na lambobi. Kowanne vector na ciki yana wakiltar layi a cikin alwatika.\n\n    Komawa:\n    - Mafi girman jimla da za a iya samu akan kowace hanya mai inganci daga saman zuwa kasan alwatika.\n\n    Misalai:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "hi": "/*\n    दिए गए संख्यात्मक त्रिभुज के शीर्ष से नीचे तक के पथ के साथ संख्याओं का अधिकतम योगफल गणना करता है।\n\n    पथ अगले पंक्ति में या तो निकटतम बाएँ या दाएँ संख्या की ओर नीचे की ओर बढ़ता है। बाएँ और दाएँ की ओर जाने वाले चालों की संख्या के बीच का अंतर एक से अधिक नहीं होना चाहिए।\n\n    तर्क:\n    - triangle: i32 के वेक्टर का एक वेक्टर, जो संख्यात्मक त्रिभुज की पंक्तियों का प्रतिनिधित्व करता है। प्रत्येक आंतरिक वेक्टर त्रिभुज में एक पंक्ति का प्रतिनिधित्व करता है।\n\n    लौटाता है:\n    - त्रिभुज के शीर्ष से नीचे तक किसी भी वैध पथ पर प्राप्त होने योग्य अधिकतम योगफल।\n\n    उदाहरण:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "hu": "/*\n    Kiszámítja a maximális összegét a számoknak egy útvonal mentén, amely a megadott numerikus háromszög tetejétől az aljáig vezet.\n\n    Az útvonal lefelé halad a következő sorban lévő legközelebbi bal vagy jobb szám felé. A balra és jobbra történő lépések számának különbsége nem haladhatja meg az egyet.\n\n    Argumentumok:\n    - triangle: Egy vektor vektorokból, amelyek i32 típusúak, és a numerikus háromszög sorait képviselik. Minden belső vektor a háromszög egy sorát képviseli.\n\n    Visszatér:\n    - A maximális összeg, amely bármely érvényes útvonalon elérhető a háromszög tetejétől az aljáig.\n\n    Példák:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) visszatér 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) visszatér 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.972404479793204",
      "hy": "0.9666253288569939",
      "bn": "0.9635648319460084",
      "bg": "0.9781971375953245",
      "zh": "0.9632243794729146",
      "fr": "0.9724130208995885",
      "de": "0.9765862452051315",
      "ha": "0.9548028485777974",
      "hi": "0.9877953548676923",
      "hu": "0.9534609017235257"
    },
    "canonical_solution": "{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` to solve the following problem:\nCalculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "sq": "Shkruani një funksion Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit shumën maksimale të numrave përgjatë një rruge nga maja deri në fund të një trekëndëshi numerik të dhënë.\n\n    Rruga lëviz poshtë ose te numri më i afërt në të majtë ose në të djathtë në rreshtin tjetër. Dallimi midis numrit të lëvizjeve në të majtë dhe në të djathtë nuk duhet të kalojë një.\n\n    Argumentet:\n    - triangle: Një vektor vektorësh të i32, që përfaqëson rreshtat e trekëndëshit numerik. Çdo vektor i brendshëm përfaqëson një rresht në trekëndësh.\n\n    Kthen:\n    - Shuma maksimale e arritshme në çdo rrugë të vlefshme nga maja deri në fund të trekëndëshit.\n\n    Shembuj:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) kthen 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) kthen 11",
      "hy": "Գրեք Rust ֆունկցիա `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է թվերի առավելագույն գումարը ճանապարհի երկայնքով, որը սկսվում է վերևից և հասնում է ներքև տրված թվային եռանկյունում:\n\n    Ճանապարհը շարժվում է ներքև դեպի հաջորդ շարքի ամենամոտ ձախ կամ աջ թիվը: Ձախ և աջ շարժումների քանակների տարբերությունը չպետք է գերազանցի մեկին:\n\n    Արգումենտներ:\n    - triangle: i32-ի վեկտորների վեկտոր, որը ներկայացնում է թվային եռանկյան շարքերը: Յուրաքանչյուր ներքին վեկտոր ներկայացնում է եռանկյան մեկ շարքը:\n\n    Վերադարձնում է:\n    - Առավելագույն գումարը, որը հնարավոր է ստանալ ցանկացած վավեր ճանապարհով եռանկյան վերևից ներքև:\n\n    Օրինակներ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) վերադարձնում է 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) վերադարձնում է 11",
      "bn": "Rust ফাংশন `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করতে:\nএকটি প্রদত্ত সংখ্যামূলক ত্রিভুজের শীর্ষ থেকে নিচ পর্যন্ত একটি পথ বরাবর সংখ্যাগুলির সর্বাধিক যোগফল গণনা করে।\n\n    পথটি পরবর্তী সারিতে নিকটতম বাম বা ডান সংখ্যায় নিচে চলে। বামে এবং ডানে যাওয়ার চলাফেরার সংখ্যার মধ্যে পার্থক্য একের বেশি হতে পারবে না।\n\n    আর্গুমেন্টসমূহ:\n    - triangle: i32 এর ভেক্টরের একটি ভেক্টর, যা সংখ্যামূলক ত্রিভুজের সারিগুলি উপস্থাপন করে। প্রতিটি অভ্যন্তরীণ ভেক্টর ত্রিভুজের একটি সারি উপস্থাপন করে।\n\n    রিটার্নস:\n    - ত্রিভুজের শীর্ষ থেকে নিচ পর্যন্ত যেকোনো বৈধ পথে অর্জনযোগ্য সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 রিটার্ন করে\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32`, за да решите следния проблем:\nИзчислява максималната сума на числата по пътя от върха до дъното на даден числов триъгълник.\n\nПътят се движи надолу към най-близкото ляво или дясно число на следващия ред. Разликата между броя на ходовете наляво и надясно не трябва да надвишава едно.\n\nАргументи:\n- triangle: Вектор от вектори от i32, представляващи редовете на числовия триъгълник. Всеки вътрешен вектор представлява ред в триъгълника.\n\nВръща:\n- Максималната сума, която може да се постигне по който и да е валиден път от върха до дъното на триъгълника.\n\nПримери:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) връща 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) връща 11",
      "zh": "编写一个 Rust 函数 `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` 来解决以下问题：\n计算从给定数字三角形的顶部到底部路径上的最大数字和。\n\n路径向下移动到下一行中最接近的左侧或右侧数字。向左和向右移动的次数之差不得超过一。\n\n参数：\n- triangle: 一个 i32 的向量的向量，表示数字三角形的行。每个内部向量表示三角形中的一行。\n\n返回：\n- 从三角形顶部到底部的任何有效路径上可实现的最大和。\n\n示例：\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 返回 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 返回 11",
      "fr": "Écrire une fonction Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` pour résoudre le problème suivant :\nCalcule la somme maximale des nombres le long d'un chemin du haut vers le bas d'un triangle numérique donné.\n\n    Le chemin descend soit vers le nombre le plus proche à gauche, soit vers le nombre le plus proche à droite sur la ligne suivante. La différence entre le nombre de mouvements vers la gauche et vers la droite ne doit pas dépasser un.\n\n    Arguments :\n    - triangle : Un vecteur de vecteurs de i32, représentant les lignes du triangle numérique. Chaque vecteur interne représente une ligne dans le triangle.\n\n    Renvoie :\n    - La somme maximale réalisable sur n'importe quel chemin valide du haut vers le bas du triangle.\n\n    Exemples :\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) renvoie 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) renvoie 11",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32`, um das folgende Problem zu lösen:\nBerechnet die maximale Summe von Zahlen entlang eines Pfades von der Spitze bis zum Boden eines gegebenen numerischen Dreiecks.\n\n    Der Pfad bewegt sich nach unten entweder zur nächstgelegenen linken oder rechten Zahl in der nächsten Zeile. Der Unterschied zwischen der Anzahl der Bewegungen nach links und nach rechts darf nicht mehr als eins betragen.\n\n    Argumente:\n    - triangle: Ein Vektor von Vektoren von i32, der die Reihen des numerischen Dreiecks darstellt. Jeder innere Vektor repräsentiert eine Reihe im Dreieck.\n\n    Rückgabewert:\n    - Die maximale Summe, die auf einem gültigen Pfad von der Spitze bis zum Boden des Dreiecks erreichbar ist.\n\n    Beispiele:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) gibt 27 zurück\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) gibt 11 zurück",
      "ha": "Rubuta aikin Rust `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` don warware matsalar mai zuwa:\nƘididdige mafi girman jimillar lambobi a kan hanya daga saman zuwa ƙasan wani alwatika na lambobi da aka bayar.\n\n    Hanyar tana motsawa ƙasa zuwa ko dai mafi kusa hagu ko dama lamba a kan layi na gaba. Bambanci tsakanin yawan motsi zuwa hagu da dama bai kamata ya wuce daya ba.\n\n    Huɗɗa:\n    - triangle: Wata vector na vectors na i32, wanda ke wakiltar layukan alwatika na lambobi. Kowanne vector na ciki yana wakiltar layi a cikin alwatika.\n\n    Mayarwa:\n    - Mafi girman jimillar da za a iya samu a kan kowace hanya mai inganci daga saman zuwa ƙasan alwatika.\n\n    Misalai:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "hi": "Rust फ़ंक्शन `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए संख्यात्मक त्रिभुज के शीर्ष से नीचे तक के पथ के साथ संख्याओं का अधिकतम योग गणना करता है।\n\n    पथ अगले पंक्ति में निकटतम बाएँ या दाएँ संख्या की ओर नीचे की ओर चलता है। बाएँ और दाएँ की ओर जाने वाले चालों की संख्या के बीच का अंतर एक से अधिक नहीं होना चाहिए।\n\n    तर्क:\n    - triangle: i32 के वेक्टर का एक वेक्टर, जो संख्यात्मक त्रिभुज की पंक्तियों का प्रतिनिधित्व करता है। प्रत्येक आंतरिक वेक्टर त्रिभुज में एक पंक्ति का प्रतिनिधित्व करता है।\n\n    रिटर्न करता है:\n    - त्रिभुज के शीर्ष से नीचे तक के किसी भी मान्य पथ पर प्राप्त किया जा सकने वाला अधिकतम योग।\n\n    उदाहरण:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "hu": "Írj egy Rust függvényt `fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32` a következő probléma megoldására:\nKiszámítja a maximális összeget a számok mentén egy adott numerikus háromszög tetejétől az aljáig vezető úton.\n\n    Az út lefelé halad a következő sor legközelebbi bal vagy jobb számához. A balra és jobbra történő mozgások számának különbsége nem haladhatja meg az egyet.\n\n    Argumentumok:\n    - triangle: Egy i32 vektorok vektora, amely a numerikus háromszög sorait képviseli. Minden belső vektor a háromszög egy sorát képviseli.\n\n    Visszatérési érték:\n    - A maximális összeg, amely bármely érvényes úton elérhető a háromszög tetejétől az aljáig.\n\n    Példák:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) visszaadja 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) visszaadja 11"
    },
    "instruction_bertscore": {
      "sq": "0.9783274391252833",
      "hy": "0.9703166758581463",
      "bn": "0.9694123117332945",
      "bg": "0.9786895423099099",
      "zh": "0.9703409087646325",
      "fr": "0.9698588328298609",
      "de": "0.9823719509439157",
      "ha": "0.9661579515704188",
      "hi": "0.9792169059715575",
      "hu": "0.9639926817867576"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]), 27);\n        assert_eq!(max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]), 8);      \n    }\n    \n\n}",
    "entry_point": "max_triangle_path_sum",
    "signature": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32",
    "docstring": {
      "en": "Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "sq": "Llogarit shumën maksimale të numrave përgjatë një rruge nga maja në fund të një trekëndëshi numerik të dhënë.\n\n    Rruga lëviz poshtë ose te numri më i afërt majtas ose djathtas në rreshtin tjetër. Diferenca midis numrit të lëvizjeve majtas dhe djathtas nuk duhet të kalojë një.\n\n    Argumentet:\n    - triangle: Një vektor i vektorëve të i32, që përfaqëson rreshtat e trekëndëshit numerik. Çdo vektor i brendshëm përfaqëson një rresht në trekëndësh.\n\n    Kthen:\n    - Shuma maksimale e arritshme në çdo rrugë të vlefshme nga maja në fund të trekëndëshit.\n\n    Shembuj:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) kthen 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) kthen 11",
      "hy": "Հաշվում է առավելագույն գումարը թվերի, որոնք գտնվում են ուղու երկայնքով, սկսած վերևից մինչև ներքև տրված թվային եռանկյունու մեջ:\n\nՈւղին շարժվում է ներքև դեպի հաջորդ շարքի ամենամոտ ձախ կամ աջ թիվը: Ձախ և աջ շարժումների քանակների տարբերությունը չպետք է գերազանցի մեկին:\n\nԱրձանագրություններ:\n- եռանկյունի: i32 վեկտորների վեկտոր, որը ներկայացնում է թվային եռանկյունու շարքերը: Յուրաքանչյուր ներքին վեկտոր ներկայացնում է եռանկյունու մի շարք:\n\nՎերադարձնում է:\n- Առավելագույն գումարը, որը հնարավոր է հասնել ցանկացած վավեր ուղու վրա, սկսած եռանկյունու վերևից մինչև ներքև:\n\nՕրինակներ:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) վերադարձնում է 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) վերադարձնում է 11",
      "bn": "শীর্ষ থেকে প্রদত্ত সংখ্যাসূচক ত্রিভুজের নীচ পর্যন্ত একটি পথে সংখ্যাগুলির সর্বাধিক যোগফল গণনা করে।\n\n    পথটি পরবর্তী সারিতে নিকটতম বাম বা ডান সংখ্যায় নিচে চলে যায়। বাম দিকে এবং ডান দিকে চলার মধ্যে পার্থক্য একটির বেশি হতে পারবে না।\n\n    আর্গুমেন্টসমূহ:\n    - triangle: i32 এর ভেক্টরের একটি ভেক্টর, যা সংখ্যাসূচক ত্রিভুজের সারিগুলি উপস্থাপন করে। প্রতিটি অভ্যন্তরীণ ভেক্টর ত্রিভুজের একটি সারি উপস্থাপন করে।\n\n    রিটার্নস:\n    - ত্রিভুজের শীর্ষ থেকে নীচ পর্যন্ত যেকোনো বৈধ পথে অর্জনযোগ্য সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 রিটার্ন করে\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 রিটার্ন করে",
      "bg": "Изчислява максималната сума от числа по път от върха до дъното на даден числов триъгълник.\n\nПътят се движи надолу към най-близкото ляво или дясно число на следващия ред. Разликата между броя на ходовете наляво и надясно не трябва да надвишава едно.\n\nАргументи:\n- triangle: Вектор от вектори от i32, представляващ редовете на числовия триъгълник. Всеки вътрешен вектор представлява ред в триъгълника.\n\nВръща:\n- Максималната сума, която може да се постигне по валиден път от върха до дъното на триъгълника.\n\nПримери:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) връща 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) връща 11",
      "zh": "计算从给定的数字三角形的顶部到底部路径上的最大数字和。\n\n路径向下移动到下一行中最接近的左侧或右侧数字。向左和向右移动的次数之差不得超过一。\n\n参数:\n- triangle: 一个i32的向量的向量，表示数字三角形的行。每个内部向量表示三角形中的一行。\n\n返回值:\n- 从三角形顶部到底部的任何有效路径上可达到的最大和。\n\n示例:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 返回 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 返回 11",
      "fr": "Calcule la somme maximale de nombres le long d'un chemin du sommet à la base d'un triangle numérique donné.\n\nLe chemin descend vers le nombre le plus proche à gauche ou à droite sur la ligne suivante. La différence entre le nombre de mouvements vers la gauche et vers la droite ne doit pas dépasser un.\n\nArguments:\n- triangle: Un vecteur de vecteurs de i32, représentant les lignes du triangle numérique. Chaque vecteur interne représente une ligne dans le triangle.\n\nReturns:\n- La somme maximale réalisable sur un chemin valide du sommet à la base du triangle.\n\nExamples:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "de": "Berechnet die maximale Summe von Zahlen entlang eines Pfades von der Spitze bis zum Boden eines gegebenen numerischen Dreiecks.\n\n    Der Pfad bewegt sich entweder zum nächstgelegenen linken oder rechten Wert in der nächsten Zeile. Der Unterschied zwischen der Anzahl der Bewegungen nach links und nach rechts darf nicht mehr als eins betragen.\n\n    Argumente:\n    - triangle: Ein Vektor von Vektoren von i32, der die Reihen des numerischen Dreiecks darstellt. Jeder innere Vektor repräsentiert eine Reihe im Dreieck.\n\n    Rückgabewerte:\n    - Die maximale Summe, die auf einem gültigen Pfad von der Spitze bis zum Boden des Dreiecks erreichbar ist.\n\n    Beispiele:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) gibt 27 zurück\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) gibt 11 zurück",
      "ha": "Lissafa mafi girman jimlar lambobi tare da hanya daga saman zuwa kasan wani alwatika na lambobi.\n\n    Hanyar tana motsawa ƙasa zuwa ko dai mafi kusa hagu ko dama lamba a kan layi na gaba. Bambanci tsakanin adadin motsi zuwa hagu da dama bai kamata ya wuce ɗaya ba.\n\n    Huɗɗa:\n    - triangle: Wata vector na vectors na i32, wanda ke wakiltar layukan alwatika na lambobi. Kowanne vector na ciki yana wakiltar layi a cikin alwatika.\n\n    Komawa:\n    - Mafi girman jimlar da za a iya samu akan kowace hanya mai inganci daga saman zuwa ƙasan alwatika.\n\n    Misalai:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "hi": "गणना करता है कि दिए गए संख्यात्मक त्रिभुज के शीर्ष से नीचे तक के पथ के साथ संख्याओं का अधिकतम योगफल क्या है।\n\n    पथ अगले पंक्ति में या तो निकटतम बाएँ या दाएँ संख्या की ओर नीचे की ओर चलता है। बाएँ और दाएँ की ओर जाने वाले चालों की संख्या के बीच का अंतर एक से अधिक नहीं होना चाहिए।\n\n    तर्क:\n    - triangle: i32 के वेक्टर का एक वेक्टर, जो संख्यात्मक त्रिभुज की पंक्तियों का प्रतिनिधित्व करता है। प्रत्येक आंतरिक वेक्टर त्रिभुज में एक पंक्ति का प्रतिनिधित्व करता है।\n\n    लौटाता है:\n    - त्रिभुज के शीर्ष से नीचे तक किसी भी मान्य पथ पर प्राप्त होने योग्य अधिकतम योगफल।\n\n    उदाहरण:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 लौटाता है\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 लौटाता है",
      "hu": "Kiszámítja a maximális összeget egy adott számháromszög tetejétől az aljáig vezető út mentén.\n\nAz út lefelé halad a következő sor legközelebbi bal vagy jobb számához. A balra és jobbra tett lépések közötti különbség nem haladhatja meg az egyet.\n\nArgumentumok:\n- triangle: Vektorok vektora i32 típusban, amely a számháromszög sorait képviseli. Minden belső vektor a háromszög egy sorát jelenti.\n\nVisszatérési érték:\n- A háromszög tetejétől az aljáig bármely érvényes úton elérhető maximális összeg.\n\nPéldák:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) visszaadja 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) visszaadja 11"
    },
    "docstring_bertscore": {
      "sq": "0.9680725498132141",
      "hy": "0.9557129729836993",
      "bn": "0.961365199106428",
      "bg": "0.974391180864315",
      "zh": "0.9651721489893427",
      "fr": "0.9729213160446568",
      "de": "0.9755660795681363",
      "ha": "0.9741834134857524",
      "hi": "0.9729235009788482",
      "hu": "0.94692059916719"
    }
  },
  {
    "task_id": "Rust/15",
    "prompt": {
      "en": "/*\n    Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "sq": "/*\n    Llogarit numrin e seksioneve të dallueshme të formuara në një plan nga një grup i dhënë vijash.\n\n    Çdo vijë përfaqësohet nga një dyshe (pjerrësia, prerja në boshtin y), duke ndjekur ekuacionin y = pjerrësia * x + prerja në boshtin y.\n    Kjo funksion supozon se vijat nuk mbivendosen dhe vijat paralele nuk kontribuojnë në seksione të reja.\n\n    Argumentet:\n    - vijat: Një segment i dysheve, ku çdo dyshe përfaqëson një vijë në plan me pjerrësinë dhe prerjen në boshtin y si (i32, i32).\n\n    Kthen:\n    - Një numër i plotë që përfaqëson numrin total të seksioneve të dallueshme të formuara në plan.\n\n    Shembull:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) kthen 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) kthen 2 (Vija paralele)\n    - count_plane_sections(&[]) kthen 0 (Pa vija)\n*/",
      "hy": "/*\n    Հաշվում է հարթության վրա ձևավորված տարբեր հատվածների քանակը տրված գծերի հավաքածուով:\n\n    Յուրաքանչյուր գիծ ներկայացված է (թեքություն, y-հատված) զույգով, հետևելով հավասարմանը y = թեքություն * x + y-հատված:\n    Այս ֆունկցիան ենթադրում է, որ գծերը չեն համընկնում և զուգահեռ գծերը չեն նպաստում նոր հատվածների ձևավորմանը:\n\n    Փաստարկներ:\n    - lines: Զույգերի շերտ, որտեղ յուրաքանչյուր զույգ ներկայացնում է հարթության վրա գիծ իր թեքությամբ և y-հատվածով որպես (i32, i32):\n\n    Վերադարձնում է:\n    - Թիվ, որը ներկայացնում է հարթության վրա ձևավորված տարբեր հատվածների ընդհանուր քանակը:\n\n    Օրինակ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) վերադարձնում է 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) վերադարձնում է 2 (Զուգահեռ գծեր)\n    - count_plane_sections(&[]) վերադարձնում է 0 (Գծեր չկան)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "bn": "/*\n    প্রদত্ত রেখাগুলির একটি সেট দ্বারা একটি সমতলে গঠিত পৃথক অংশগুলির সংখ্যা গণনা করে।\n\n    প্রতিটি রেখাকে একটি টুপল (ঢাল, y-অবস্থান) দ্বারা উপস্থাপন করা হয়, যা সমীকরণ y = slope * x + y-intercept অনুসরণ করে।\n    এই ফাংশনটি ধরে নেয় যে রেখাগুলি ওভারল্যাপিং নয় এবং সমান্তরাল রেখাগুলি নতুন অংশে অবদান রাখে না।\n\n    আর্গুমেন্টসমূহ:\n    - lines: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপল একটি সমতলে রেখাকে তার ঢাল এবং y-অবস্থান হিসেবে (i32, i32) দিয়ে উপস্থাপন করে।\n\n    রিটার্নস:\n    - একটি পূর্ণসংখ্যা যা সমতলে গঠিত মোট পৃথক অংশগুলির সংখ্যা উপস্থাপন করে।\n\n    উদাহরণ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 রিটার্ন করে\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 রিটার্ন করে (সমান্তরাল রেখা)\n    - count_plane_sections(&[]) 0 রিটার্ন করে (কোন রেখা নেই)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "bg": "/*\n    Изчислява броя на различните сечения, образувани на равнина от даден набор от прави.\n\n    Всяка права е представена чрез кортеж (наклон, y-пресечна точка), следвайки уравнението y = наклон * x + y-пресечна точка.\n    Тази функция приема, че правите не се припокриват и успоредните прави не допринасят за нови сечения.\n\n    Аргументи:\n    - lines: Срез от кортежи, където всеки кортеж представлява права на равнината с нейния наклон и y-пресечна точка като (i32, i32).\n\n    Връща:\n    - Цяло число, представляващо общия брой на различните сечения, образувани на равнината.\n\n    Пример:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) връща 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) връща 2 (Успоредни прави)\n    - count_plane_sections(&[]) връща 0 (Няма прави)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "zh": "/*\n    计算给定线集合在平面上形成的不同区域数量。\n\n    每条线由一个元组 (斜率, y-截距) 表示，遵循方程 y = 斜率 * x + y-截距。\n    此函数假设线条不重叠且平行线不形成新的区域。\n\n    参数:\n    - lines: 一个元组切片，其中每个元组表示平面上的一条线，其斜率和 y-截距为 (i32, i32)。\n\n    返回:\n    - 一个整数，表示在平面上形成的不同区域的总数。\n\n    示例:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 返回 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) 返回 2 (平行线)\n    - count_plane_sections(&[]) 返回 0 (无线)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "fr": "/*\n    Calcule le nombre de sections distinctes formées sur un plan par un ensemble donné de lignes.\n\n    Chaque ligne est représentée par un tuple (pente, ordonnée à l'origine), suivant l'équation y = pente * x + ordonnée à l'origine.\n    Cette fonction suppose que les lignes ne se chevauchent pas et que les lignes parallèles ne contribuent pas à de nouvelles sections.\n\n    Arguments:\n    - lines: Un ensemble de tuples, où chaque tuple représente une ligne sur le plan avec sa pente et son ordonnée à l'origine comme (i32, i32).\n\n    Renvoie:\n    - Un entier représentant le nombre total de sections distinctes formées sur le plan.\n\n    Exemple:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Lignes parallèles)\n    - count_plane_sections(&[]) returns 0 (Aucune ligne)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "de": "/*\n    Berechnet die Anzahl der unterschiedlichen Abschnitte, die durch eine gegebene Menge von Linien auf einer Ebene gebildet werden.\n\n    Jede Linie wird durch ein Tupel (Steigung, y-Achsenabschnitt) dargestellt, entsprechend der Gleichung y = Steigung * x + y-Achsenabschnitt.\n    Diese Funktion geht davon aus, dass sich Linien nicht überlappen und parallele Linien nicht zu neuen Abschnitten beitragen.\n\n    Argumente:\n    - lines: Ein Slice von Tupeln, wobei jedes Tupel eine Linie auf der Ebene mit ihrer Steigung und ihrem y-Achsenabschnitt als (i32, i32) darstellt.\n\n    Rückgabewert:\n    - Eine ganze Zahl, die die Gesamtanzahl der unterschiedlichen Abschnitte auf der Ebene darstellt.\n\n    Beispiel:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) gibt 6 zurück\n    - count_plane_sections(&[(0, 1), (0, 2)]) gibt 2 zurück (Parallele Linien)\n    - count_plane_sections(&[]) gibt 0 zurück (Keine Linien)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "ha": "/*\n    Lissafa adadin sassan daban-daban da aka samar a kan wani fili ta hanyar wani saiti na layuka.\n\n    Kowanne layi ana wakilta shi da wani tuple (matsayi, y-intercept), bisa ga daidaitawar y = matsayi * x + y-intercept.\n    Wannan aikin yana tsammanin layuka ba sa juna kuma layuka masu layi daya ba sa kara sabbin sassa.\n\n    Hujojji:\n    - layuka: Wani yanki na tuples, inda kowanne tuple ke wakiltar layi a kan fili tare da matsayi da y-intercept dinsa a matsayin (i32, i32).\n\n    Komawa:\n    - Wani cikakken lamba da ke wakiltar jimillar adadin sassan daban-daban da aka samar a kan fili.\n\n    Misali:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Layuka masu layi daya)\n    - count_plane_sections(&[]) returns 0 (Babu layi)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "hi": "/*\n    दिए गए लाइनों के सेट द्वारा एक समतल पर बनने वाले भिन्न खंडों की संख्या की गणना करता है।\n\n    प्रत्येक रेखा को एक ट्यूपल (ढलान, y-अवरोध) द्वारा दर्शाया गया है, जो समीकरण y = slope * x + y-intercept का अनुसरण करता है।\n    यह फ़ंक्शन मानता है कि रेखाएँ ओवरलैप नहीं हो रही हैं और समानांतर रेखाएँ नए खंडों में योगदान नहीं करती हैं।\n\n    तर्क:\n    - lines: ट्यूपल्स का एक स्लाइस, जहाँ प्रत्येक ट्यूपल समतल पर एक रेखा को उसके ढलान और y-अवरोध के साथ (i32, i32) के रूप में दर्शाता है।\n\n    लौटाता है:\n    - एक पूर्णांक जो समतल पर बनने वाले भिन्न खंडों की कुल संख्या का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 लौटाता है\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 लौटाता है (समानांतर रेखाएँ)\n    - count_plane_sections(&[]) 0 लौटाता है (कोई रेखाएँ नहीं)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "hu": "/*\n    Kiszámítja a síkon létrejövő különálló szakaszok számát egy adott egyeneskészlet alapján.\n\n    Minden egyenes egy tuple-ként van ábrázolva (meredekség, y-metszet), az y = meredekség * x + y-metszet egyenlet szerint.\n    Ez a függvény feltételezi, hogy az egyenesek nem fedik át egymást, és a párhuzamos egyenesek nem járulnak hozzá új szakaszokhoz.\n\n    Argumentumok:\n    - lines: Tuple-ok szelete, ahol minden tuple egy egyenest ábrázol a síkon, a meredekségével és y-metszetével mint (i32, i32).\n\n    Visszatérési érték:\n    - Egy egész szám, amely a síkon létrejövő különálló szakaszok teljes számát jelenti.\n\n    Példa:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) visszaadja a 6-ot\n    - count_plane_sections(&[(0, 1), (0, 2)]) visszaadja a 2-t (Párhuzamos egyenesek)\n    - count_plane_sections(&[]) visszaadja a 0-t (Nincsenek egyenesek)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9377180536138435",
      "hy": "0.9653751492387603",
      "bn": "0.9869686552218251",
      "bg": "0.9890848633013708",
      "zh": "0.9690698729563904",
      "fr": "0.9838525418041498",
      "de": "0.9846359400269514",
      "ha": "0.9738866596964864",
      "hi": "0.9938208074763857",
      "hu": "0.9714405265540417"
    },
    "canonical_solution": "{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` to solve the following problem:\nCalculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)",
      "sq": "Shkruani një funksion Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` për të zgjidhur problemin në vijim:\nLlogarit numrin e seksioneve të dallueshme të formuara në një plan nga një grup i dhënë vijash.\n\n    Çdo vijë përfaqësohet nga një dyshe (pjerrësia, prerja në y), duke ndjekur ekuacionin y = pjerrësia * x + prerja në y.\n    Ky funksion supozon që vijat nuk mbivendosen dhe vijat paralele nuk kontribuojnë në seksione të reja.\n\n    Argumentet:\n    - lines: Një segment dysheve, ku çdo dyshe përfaqëson një vijë në plan me pjerrësinë dhe prerjen në y si (i32, i32).\n\n    Kthen:\n    - Një numër të plotë që përfaqëson numrin total të seksioneve të dallueshme të formuara në plan.\n\n    Shembull:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) kthen 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) kthen 2 (Vija paralele)\n    - count_plane_sections(&[]) kthen 0 (Pa vija)",
      "hy": "Գրեք Rust ֆունկցիա `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է հարթության վրա տրված գծերի հավաքածուով ձևավորված տարբեր հատվածների քանակը:\n\n    Յուրաքանչյուր գիծ ներկայացված է (թեքություն, y-հատված) տուպլով, հետևելով հավասարմանը y = թեքություն * x + y-հատված:\n    Այս ֆունկցիան ենթադրում է, որ գծերը չեն համընկնում և զուգահեռ գծերը չեն նպաստում նոր հատվածների ձևավորմանը:\n\n    Արգումենտներ:\n    - lines: Տուպլերի կտոր, որտեղ յուրաքանչյուր տուպլ ներկայացնում է հարթության վրա գիծ իր թեքությամբ և y-հատվածով որպես (i32, i32):\n\n    Վերադարձնում է.\n    - Թիվ, որը ներկայացնում է հարթության վրա ձևավորված տարբեր հատվածների ընդհանուր քանակը:\n\n    Օրինակ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) վերադարձնում է 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) վերադարձնում է 2 (Զուգահեռ գծեր)\n    - count_plane_sections(&[]) վերադարձնում է 0 (Գծեր չկան)",
      "bn": "Rust ফাংশন `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত লাইনগুলির একটি সেট দ্বারা একটি প্লেনে গঠিত পৃথক বিভাগগুলির সংখ্যা গণনা করে।\n\n    প্রতিটি লাইন একটি টুপল (slope, y-intercept) দ্বারা উপস্থাপিত হয়, যা সমীকরণ y = slope * x + y-intercept অনুসরণ করে।\n    এই ফাংশনটি ধরে নেয় যে লাইনগুলি ওভারল্যাপিং নয় এবং সমান্তরাল লাইনগুলি নতুন বিভাগে অবদান রাখে না।\n\n    আর্গুমেন্ট:\n    - lines: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপল প্লেনে তার slope এবং y-intercept সহ একটি লাইনের প্রতিনিধিত্ব করে (i32, i32) হিসাবে।\n\n    রিটার্নস:\n    - একটি পূর্ণসংখ্যা যা প্লেনে গঠিত মোট পৃথক বিভাগের সংখ্যা উপস্থাপন করে।\n\n    উদাহরণ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 রিটার্ন করে\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 রিটার্ন করে (সমান্তরাল লাইন)\n    - count_plane_sections(&[]) 0 রিটার্ন করে (কোনো লাইন নেই)",
      "bg": "Напишете функция на Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize`, за да решите следния проблем:\nИзчислява броя на различните сечения, образувани на равнината от даден набор от прави линии.\n\n    Всяка линия е представена от двойка (наклон, y-пресечна точка), следвайки уравнението y = наклон * x + y-пресечна точка.\n    Тази функция приема, че линиите не се припокриват и паралелните линии не допринасят за нови сечения.\n\n    Аргументи:\n    - lines: Срез от двойки, където всяка двойка представлява линия на равнината с нейния наклон и y-пресечна точка като (i32, i32).\n\n    Връща:\n    - Цяло число, представляващо общия брой на различните сечения, образувани на равнината.\n\n    Пример:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) връща 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) връща 2 (Паралелни линии)\n    - count_plane_sections(&[]) връща 0 (Няма линии)",
      "zh": "编写一个 Rust 函数 `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` 来解决以下问题：\n计算给定直线集合在平面上形成的不同区域的数量。\n\n每条直线由一个元组 (斜率, y-截距) 表示，遵循方程 y = 斜率 * x + y-截距。\n此函数假设直线不重叠且平行线不产生新区域。\n\n参数：\n- lines: 一个元组切片，其中每个元组表示平面上的一条直线，其斜率和 y-截距为 (i32, i32)。\n\n返回：\n- 一个整数，表示平面上形成的不同区域的总数。\n\n示例：\n- count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 返回 6\n- count_plane_sections(&[(0, 1), (0, 2)]) 返回 2 (平行线)\n- count_plane_sections(&[]) 返回 0 (无直线)",
      "fr": "Écrire une fonction Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` pour résoudre le problème suivant :\nCalcule le nombre de sections distinctes formées sur un plan par un ensemble donné de lignes.\n\n    Chaque ligne est représentée par un tuple (pente, ordonnée à l'origine), suivant l'équation y = pente * x + ordonnée à l'origine.\n    Cette fonction suppose que les lignes ne se chevauchent pas et que les lignes parallèles ne contribuent pas à de nouvelles sections.\n\n    Arguments :\n    - lines : Une tranche de tuples, où chaque tuple représente une ligne sur le plan avec sa pente et son ordonnée à l'origine comme (i32, i32).\n\n    Renvoie :\n    - Un entier représentant le nombre total de sections distinctes formées sur le plan.\n\n    Exemple :\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) renvoie 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) renvoie 2 (Lignes parallèles)\n    - count_plane_sections(&[]) renvoie 0 (Pas de lignes)",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_plane_sections(lines: &[(i32, i32)]) -> usize`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der unterschiedlichen Abschnitte, die auf einer Ebene durch eine gegebene Menge von Linien gebildet werden.\n\n    Jede Linie wird durch ein Tupel (Steigung, y-Achsenabschnitt) dargestellt, entsprechend der Gleichung y = Steigung * x + y-Achsenabschnitt.\n    Diese Funktion geht davon aus, dass sich Linien nicht überlappen und parallele Linien nicht zu neuen Abschnitten beitragen.\n\n    Argumente:\n    - lines: Ein Slice von Tupeln, wobei jedes Tupel eine Linie auf der Ebene mit ihrer Steigung und ihrem y-Achsenabschnitt als (i32, i32) darstellt.\n\n    Rückgabewert:\n    - Eine ganze Zahl, die die Gesamtanzahl der unterschiedlichen Abschnitte auf der Ebene darstellt.\n\n    Beispiel:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) gibt 6 zurück\n    - count_plane_sections(&[(0, 1), (0, 2)]) gibt 2 zurück (Parallele Linien)\n    - count_plane_sections(&[]) gibt 0 zurück (Keine Linien)",
      "ha": "Rubuta aikin Rust `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` don warware matsalar mai zuwa:\nYana ƙididdige adadin sassan daban-daban da aka kafa akan jirgin sama ta hanyar saiti na layuka da aka bayar.\n\n    Kowanne layi ana wakilta shi da tulu (slope, y-intercept), bisa ga daidaiton y = slope * x + y-intercept.\n    Wannan aikin yana ɗauka cewa layuka ba sa maimaita kuma layukan da ke layi ɗaya ba sa ƙara sabbin sassa.\n\n    Huɗɗa:\n    - lines: Yanke na tuluka, inda kowanne tulu ke wakiltar layi akan jirgin tare da gangarawa da y-intercept dinsa a matsayin (i32, i32).\n\n    Dawowa:\n    - Lamba ce wadda ke wakiltar jimillar adadin sassan daban-daban da aka kafa akan jirgin.\n\n    Misali:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Layukan da ke layi ɗaya)\n    - count_plane_sections(&[]) returns 0 (Babu layi)",
      "hi": "Rust फ़ंक्शन `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए लाइनों के सेट द्वारा विमान पर बने विशिष्ट खंडों की संख्या की गणना करता है।\n\n    प्रत्येक रेखा को एक टपल (ढलान, y-अवरोध) द्वारा दर्शाया गया है, जो समीकरण y = slope * x + y-intercept का पालन करता है।\n    यह फ़ंक्शन मानता है कि रेखाएँ ओवरलैप नहीं हो रही हैं और समानांतर रेखाएँ नए खंडों में योगदान नहीं करती हैं।\n\n    तर्क:\n    - lines: टपल का एक स्लाइस, जहाँ प्रत्येक टपल विमान पर एक रेखा का प्रतिनिधित्व करता है, जिसमें उसका ढलान और y-अवरोध (i32, i32) के रूप में होता है।\n\n    लौटाता है:\n    - एक पूर्णांक जो विमान पर बने कुल विशिष्ट खंडों की संख्या का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 लौटाता है\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 लौटाता है (समानांतर रेखाएँ)\n    - count_plane_sections(&[]) 0 लौटाता है (कोई रेखाएँ नहीं)",
      "hu": "Készíts egy Rust függvényt `fn count_plane_sections(lines: &[(i32, i32)]) -> usize` a következő probléma megoldására:\nKiszámítja a síkon kialakított különálló szakaszok számát egy adott vonalkészlet alapján.\n\n    Minden vonal egy (meredekség, y-metszet) párként van ábrázolva, az y = meredekség * x + y-metszet egyenletet követve.\n    Ez a függvény feltételezi, hogy a vonalak nem fedik egymást, és a párhuzamos vonalak nem járulnak hozzá új szakaszokhoz.\n\n    Argumentumok:\n    - lines: Egy tuple-ökből álló szelet, ahol minden tuple egy vonalat ábrázol a síkon a meredekségével és y-metszetével (i32, i32) formátumban.\n\n    Visszatér:\n    - Egy egész szám, amely a síkon kialakított különálló szakaszok teljes számát jelenti.\n\n    Példa:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) visszatér 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) visszatér 2 (Párhuzamos vonalak)\n    - count_plane_sections(&[]) visszatér 0 (Nincsenek vonalak)"
    },
    "instruction_bertscore": {
      "sq": "0.9812812715216531",
      "hy": "0.9693779486773755",
      "bn": "0.9699823809268646",
      "bg": "0.9774212873270022",
      "zh": "0.9711650262155463",
      "fr": "0.9890471235289742",
      "de": "0.9879165194001236",
      "ha": "0.9614347197397902",
      "hi": "0.9726901102811322",
      "hu": "0.9664904588282712"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_plane_sections(&[(1, 1), (2, 2), (3, 3)]), 6);\n        assert_eq!(count_plane_sections(&[(0, 1), (0, 2)]), 3);\n    }\n    \n\n}\n ",
    "entry_point": "count_plane_sections",
    "signature": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize",
    "docstring": {
      "en": "Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)",
      "sq": "Llogarit numrin e seksioneve të dallueshme të formuara në një plan nga një grup i dhënë vijash.\n\n    Çdo vijë përfaqësohet nga një dyshe (pjerrësia, prerja në boshtin y), duke ndjekur ekuacionin y = pjerrësia * x + prerja në boshtin y.\n    Kjo funksion supozon se vijat nuk mbivendosen dhe vijat paralele nuk kontribuojnë në seksione të reja.\n\n    Argumentet:\n    - lines: Një segment dysheve, ku çdo dyshe përfaqëson një vijë në plan me pjerrësinë dhe prerjen në boshtin y si (i32, i32).\n\n    Kthen:\n    - Një numër i plotë që përfaqëson numrin total të seksioneve të dallueshme të formuara në plan.\n\n    Shembull:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) kthen 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) kthen 2 (Vija paralele)\n    - count_plane_sections(&[]) kthen 0 (Pa vija)",
      "hy": "Հաշվում է հարթության վրա տրված գծերի հավաքածուով ձևավորված տարբեր հատվածների քանակը:\n\n    Յուրաքանչյուր գիծ ներկայացված է (թեքություն, y-հատված) զույգով, հետևելով հավասարմանը y = թեքություն * x + y-հատված:\n    Այս ֆունկցիան ենթադրում է, որ գծերը չեն համընկնում և զուգահեռ գծերը չեն նպաստում նոր հատվածների ձևավորմանը:\n\n    Արգումենտներ:\n    - lines: Զույգերի մի կտոր, որտեղ յուրաքանչյուր զույգ ներկայացնում է հարթության վրա գիծ իր թեքությամբ և y-հատվածով որպես (i32, i32):\n\n    Վերադարձնում է.\n    - Թիվ, որը ներկայացնում է հարթության վրա ձևավորված տարբեր հատվածների ընդհանուր քանակը:\n\n    Օրինակ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) վերադարձնում է 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) վերադարձնում է 2 (Զուգահեռ գծեր)\n    - count_plane_sections(&[]) վերադարձնում է 0 (Գծեր չկան)",
      "bn": "প্লেনে প্রদত্ত রেখাগুলির সেট দ্বারা গঠিত পৃথক বিভাগগুলির সংখ্যা গণনা করে।\n\n    প্রতিটি রেখা একটি টুপল (ঢাল, y-অবস্থান) দ্বারা উপস্থাপিত হয়, যা সমীকরণ y = slope * x + y-intercept অনুসরণ করে।\n    এই ফাংশনটি ধরে নেয় যে রেখাগুলি ওভারল্যাপ করছে না এবং সমান্তরাল রেখাগুলি নতুন বিভাগে অবদান রাখে না।\n\n    আর্গুমেন্টস:\n    - lines: টুপলের একটি স্লাইস, যেখানে প্রতিটি টুপল প্লেনে একটি রেখাকে তার ঢাল এবং y-অবস্থান হিসাবে (i32, i32) দিয়ে উপস্থাপন করে।\n\n    রিটার্নস:\n    - একটি পূর্ণসংখ্যা যা প্লেনে গঠিত মোট পৃথক বিভাগের সংখ্যা উপস্থাপন করে।\n\n    উদাহরণ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 রিটার্ন করে\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 রিটার্ন করে (সমান্তরাল রেখা)\n    - count_plane_sections(&[]) 0 রিটার্ন করে (কোনো রেখা নেই)",
      "bg": "Изчислява броя на различните секции, образувани на равнината от даден набор от прави линии.\n\n    Всяка линия е представена от кортеж (наклон, y-пресечна точка), следвайки уравнението y = наклон * x + y-пресечна точка.\n    Тази функция предполага, че линиите не се припокриват и паралелните линии не допринасят за нови секции.\n\n    Аргументи:\n    - lines: Срез от кортежи, където всеки кортеж представлява линия на равнината с нейния наклон и y-пресечна точка като (i32, i32).\n\n    Връща:\n    - Цяло число, представляващо общия брой на различните секции, образувани на равнината.\n\n    Пример:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) връща 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) връща 2 (Паралелни линии)\n    - count_plane_sections(&[]) връща 0 (Няма линии)",
      "zh": "计算给定的一组直线在平面上形成的不同区域的数量。\n\n每条直线由一个元组 (斜率, y-截距) 表示，遵循方程 y = 斜率 * x + y-截距。\n此函数假设直线不重叠且平行线不形成新的区域。\n\n参数:\n- lines: 一个元组切片，其中每个元组表示平面上的一条直线，其斜率和 y-截距为 (i32, i32)。\n\n返回:\n- 一个整数，表示在平面上形成的不同区域的总数。\n\n示例:\n- count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 返回 6\n- count_plane_sections(&[(0, 1), (0, 2)]) 返回 2 (平行线)\n- count_plane_sections(&[]) 返回 0 (无直线)",
      "fr": "Calcule le nombre de sections distinctes formées sur un plan par un ensemble donné de lignes.\n\n    Chaque ligne est représentée par un tuple (pente, ordonnée à l'origine), suivant l'équation y = pente * x + ordonnée à l'origine.\n    Cette fonction suppose que les lignes ne se chevauchent pas et que les lignes parallèles ne contribuent pas à de nouvelles sections.\n\n    Arguments:\n    - lines: Une tranche de tuples, où chaque tuple représente une ligne sur le plan avec sa pente et son ordonnée à l'origine comme (i32, i32).\n\n    Retourne:\n    - Un entier représentant le nombre total de sections distinctes formées sur le plan.\n\n    Exemple:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) retourne 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) retourne 2 (Lignes parallèles)\n    - count_plane_sections(&[]) retourne 0 (Pas de lignes)",
      "de": "Berechnet die Anzahl der unterschiedlichen Abschnitte, die auf einer Ebene durch eine gegebene Menge von Linien gebildet werden.\n\n    Jede Linie wird durch ein Tupel (Steigung, y-Achsenabschnitt) dargestellt, gemäß der Gleichung y = Steigung * x + y-Achsenabschnitt.\n    Diese Funktion geht davon aus, dass sich Linien nicht überlappen und parallele Linien nicht zu neuen Abschnitten beitragen.\n\n    Argumente:\n    - lines: Ein Slice von Tupeln, wobei jedes Tupel eine Linie auf der Ebene mit ihrer Steigung und ihrem y-Achsenabschnitt als (i32, i32) darstellt.\n\n    Rückgabewert:\n    - Eine ganze Zahl, die die Gesamtanzahl der unterschiedlichen Abschnitte darstellt, die auf der Ebene gebildet werden.\n\n    Beispiel:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) gibt 6 zurück\n    - count_plane_sections(&[(0, 1), (0, 2)]) gibt 2 zurück (Parallele Linien)\n    - count_plane_sections(&[]) gibt 0 zurück (Keine Linien)",
      "ha": "Lissafa adadin sassan daban-daban da aka samar a kan wani fili ta hanyar wani saiti na layuka.\n\n    Kowanne layi ana wakilta shi da wani tuple (slope, y-intercept), bisa ga daidaiton y = slope * x + y-intercept.\n    Wannan aikin yana ɗauka cewa layuka ba sa maimaita juna kuma layuka masu layi ɗaya ba sa ƙara sabbin sassa.\n\n    Huɗɗa:\n    - lines: Wani yanki na tuples, inda kowanne tuple ke wakiltar wani layi a kan faifai tare da gangara da y-intercept a matsayin (i32, i32).\n\n    Komawa:\n    - Wani cikakken lamba wanda ke wakiltar jimlar adadin sassa daban-daban da aka kafa a kan faifai.\n\n    Misali:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Layuka masu layi ɗaya)\n    - count_plane_sections(&[]) returns 0 (Babu layi)",
      "hi": "विमान पर दिए गए रेखाओं के सेट द्वारा निर्मित विभिन्न खंडों की संख्या की गणना करता है।\n\n    प्रत्येक रेखा को एक टपल (ढलान, y-अवरोध) द्वारा दर्शाया जाता है, जो समीकरण y = slope * x + y-intercept का अनुसरण करता है।\n    यह फ़ंक्शन मानता है कि रेखाएँ ओवरलैप नहीं कर रही हैं और समानांतर रेखाएँ नए खंडों में योगदान नहीं करती हैं।\n\n    तर्क:\n    - lines: टपल का एक स्लाइस, जहाँ प्रत्येक टपल विमान पर एक रेखा का प्रतिनिधित्व करता है, जिसमें उसका ढलान और y-अवरोध (i32, i32) के रूप में होता है।\n\n    वापसी:\n    - एक पूर्णांक जो विमान पर निर्मित विभिन्न खंडों की कुल संख्या का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 लौटाता है\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 लौटाता है (समानांतर रेखाएँ)\n    - count_plane_sections(&[]) 0 लौटाता है (कोई रेखाएँ नहीं)",
      "hu": "Számítja a síkon képződött különálló szakaszok számát a megadott egyenesek halmazával.\n\n    Minden egyenes egy (meredekség, y-metszet) párként van ábrázolva, az y = meredekség * x + y-metszet egyenlet alapján.\n    Ez a függvény feltételezi, hogy az egyenesek nem fedik egymást, és a párhuzamos egyenesek nem járulnak hozzá új szakaszokhoz.\n\n    Argumentumok:\n    - lines: Egy vágás tuple-ökből, ahol minden tuple egy egyenest ábrázol a síkon a meredekségével és y-metszetével mint (i32, i32).\n\n    Visszatér:\n    - Egy egész szám, amely a síkon képződött különálló szakaszok teljes számát képviseli.\n\n    Példa:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) visszaadja 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) visszaadja 2 (Párhuzamos egyenesek)\n    - count_plane_sections(&[]) visszaadja 0 (Nincsenek egyenesek)"
    },
    "docstring_bertscore": {
      "sq": "0.9752651545408685",
      "hy": "0.9553639794042209",
      "bn": "0.9808117093008867",
      "bg": "0.9859298183290126",
      "zh": "0.9661233898841188",
      "fr": "0.9858098455788676",
      "de": "0.9858676470197487",
      "ha": "0.9782269321524797",
      "hi": "0.9723039728204004",
      "hu": "0.9647540320372643"
    }
  },
  {
    "task_id": "Rust/16",
    "prompt": {
      "en": "/*\n  Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "sq": "/*\n  Llogarit numrin e peshave të dallueshme që mund të maten duke përdorur një grup të dhënë peshash në një peshore.\n  Peshat mund të vendosen në njërën anë të peshores, dhe e njëjta peshë nuk mund të përdoret më shumë se një herë.\n\n  Argumentet:\n  - weights: Një segment i numrave të plotë që përfaqësojnë peshat.\n\n  Kthen:\n  - Numri total i peshave të dallueshme që mund të maten.\n\n  Shembull:\n  - distinct_weights_count(&[1, 4, 6]) kthen 10\n  - distinct_weights_count(&[2, 3]) kthen 5 (pesha: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) kthen 1 (vetëm zero mund të matet)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "hy": "/*\n  Հաշվում է տարբեր կշիռների քանակը, որոնք կարող են չափվել տրված կշիռների հավաքածուի միջոցով հավասարակշռության կշեռքի վրա:\n  Կշիռները կարող են տեղադրվել կշեռքի երկու կողմերում, և նույն կշիռը չի կարող օգտագործվել մեկից ավելի անգամ:\n\n  Արգումենտներ:\n  - weights: ամբողջ թվերի կտոր, որը ներկայացնում է կշիռները:\n\n  Վերադարձնում է:\n  - Տարբեր կշիռների ընդհանուր քանակը, որոնք կարող են չափվել:\n\n  Օրինակ:\n  - distinct_weights_count(&[1, 4, 6]) վերադարձնում է 10\n  - distinct_weights_count(&[2, 3]) վերադարձնում է 5 (կշիռներ: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) վերադարձնում է 1 (միայն զրոն կարող է չափվել)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32",
      "bn": "/*\n  প্রদত্ত ওজন সেট ব্যবহার করে একটি ভারসাম্য স্কেলে মাপা যেতে পারে এমন ভিন্ন ওজনের সংখ্যা গণনা করে।\n  ওজনগুলি স্কেলের যেকোনো পাশে রাখা যেতে পারে এবং একই ওজন একাধিকবার ব্যবহার করা যাবে না।\n\n  আর্গুমেন্টসমূহ:\n  - weights: ওজনগুলিকে উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্ন করে:\n  - মোট ভিন্ন ওজনের সংখ্যা যা মাপা যেতে পারে।\n\n  উদাহরণ:\n  - distinct_weights_count(&[1, 4, 6]) 10 রিটার্ন করে\n  - distinct_weights_count(&[2, 3]) 5 রিটার্ন করে (ওজন: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 রিটার্ন করে (শুধুমাত্র শূন্য মাপা যেতে পারে)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните тежести, които могат да бъдат измерени с даден набор от тежести на везна.\n  Тежестите могат да бъдат поставени от двете страни на везната и една и съща тежест не може да се използва повече от веднъж.\n\n  Аргументи:\n  - weights: Срез от цели числа, представляващи тежестите.\n\n  Връща:\n  - Общият брой на различните тежести, които могат да бъдат измерени.\n\n  Пример:\n  - distinct_weights_count(&[1, 4, 6]) връща 10\n  - distinct_weights_count(&[2, 3]) връща 5 (тежести: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) връща 1 (може да се измери само нула)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "zh": "/*\n  计算可以使用给定的一组砝码在天平上测量的不同重量的数量。\n  砝码可以放在天平的任一侧，并且同一个砝码不能使用多次。\n\n  参数:\n  - weights: 一个表示砝码的整数切片。\n\n  返回:\n  - 可以测量的不同重量的总数。\n\n  示例:\n  - distinct_weights_count(&[1, 4, 6]) 返回 10\n  - distinct_weights_count(&[2, 3]) 返回 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 返回 1 (只有零可以测量)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "fr": "/*\n  Calcule le nombre de poids distincts qui peuvent être mesurés en utilisant un ensemble donné de poids sur une balance.\n  Les poids peuvent être placés de chaque côté de la balance, et le même poids ne peut pas être utilisé plus d'une fois.\n\n  Arguments:\n  - weights: Une tranche d'entiers représentant les poids.\n\n  Retourne:\n  - Le nombre total de poids distincts qui peuvent être mesurés.\n\n  Exemple:\n  - distinct_weights_count(&[1, 4, 6]) retourne 10\n  - distinct_weights_count(&[2, 3]) retourne 5 (poids: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) retourne 1 (seul zéro peut être mesuré)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der unterschiedlichen Gewichte, die mit einem gegebenen Satz von Gewichten auf einer Waage gemessen werden können.\n  Die Gewichte können auf beide Seiten der Waage gelegt werden, und dasselbe Gewicht kann nicht mehr als einmal verwendet werden.\n\n  Argumente:\n  - weights: Ein Slice von ganzen Zahlen, das die Gewichte darstellt.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der unterschiedlichen Gewichte, die gemessen werden können.\n\n  Beispiel:\n  - distinct_weights_count(&[1, 4, 6]) gibt 10 zurück\n  - distinct_weights_count(&[2, 3]) gibt 5 zurück (Gewichte: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) gibt 1 zurück (nur Null kann gemessen werden)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "ha": "/*\n  Lissafa yawan nau'ikan nauyi daban-daban da za a iya aunawa ta amfani da saitin nauyi da aka bayar akan ma'aunin ma'auni.\n  Ana iya sanya nauyin a kowane gefe na ma'aunin, kuma ba za a iya amfani da nauyi ɗaya fiye da sau ɗaya ba.\n\n  Huɗɗa:\n  - weights: Wani yanki na lambobi masu nuna nauyin.\n\n  Komawa:\n  - Jimillar yawan nau'ikan nauyi daban-daban da za a iya aunawa.\n\n  Misali:\n  - distinct_weights_count(&[1, 4, 6]) yana dawowa 10\n  - distinct_weights_count(&[2, 3]) yana dawowa 5 (nauyi: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) yana dawowa 1 (sai sifili kawai za a iya aunawa)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "hi": "/*\n  दिए गए वज़नों के सेट का उपयोग करके एक संतुलन पैमाने पर मापे जा सकने वाले भिन्न-भिन्न वज़नों की संख्या की गणना करता है।\n  वज़न को पैमाने के किसी भी तरफ रखा जा सकता है, और एक ही वज़न का एक से अधिक बार उपयोग नहीं किया जा सकता।\n\n  तर्क:\n  - weights: वज़नों का एक स्लाइस जो पूर्णांकों का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - भिन्न-भिन्न वज़नों की कुल संख्या जो मापी जा सकती है।\n\n  उदाहरण:\n  - distinct_weights_count(&[1, 4, 6]) 10 लौटाता है\n  - distinct_weights_count(&[2, 3]) 5 लौटाता है (वज़न: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 लौटाता है (केवल शून्य मापा जा सकता है)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "hu": "/*\n  Kiszámítja a különböző mérhető súlyok számát egy adott súlykészlet segítségével egy mérleggel.\n  A súlyok a mérleg mindkét oldalára helyezhetők, és ugyanazt a súlyt nem lehet többször használni.\n\n  Argumentumok:\n  - weights: Egész számokat tartalmazó szelet, amely a súlyokat reprezentálja.\n\n  Visszatérési érték:\n  - A különböző mérhető súlyok teljes száma.\n\n  Példa:\n  - distinct_weights_count(&[1, 4, 6]) visszaadja 10\n  - distinct_weights_count(&[2, 3]) visszaadja 5 (súlyok: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) visszaadja 1 (csak a nulla mérhető)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9821335944866739",
      "hy": "0.9840515694459467",
      "bn": "0.9655660330349349",
      "bg": "0.980682400922833",
      "zh": "0.964422120670555",
      "fr": "0.9806077158995639",
      "de": "0.9827282938474924",
      "ha": "0.9630881190315247",
      "hi": "0.9827862939187545",
      "hu": "0.9478138399907038"
    },
    "canonical_solution": "{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}",
    "instruction": {
      "en": "Write a Rust function `fn distinct_weights_count(weights: &[i32]) -> i32` to solve the following problem:\nCalculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)",
      "sq": "Shkruani një funksion Rust `fn distinct_weights_count(weights: &[i32]) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e peshave të dallueshme që mund të maten duke përdorur një grup të dhënë peshash në një peshore.\n  Peshat mund të vendosen në njërën anë të peshores, dhe e njëjta peshë nuk mund të përdoret më shumë se një herë.\n\n  Argumentet:\n  - weights: Një segment i numrave të plotë që përfaqësojnë peshat.\n\n  Kthen:\n  - Numri total i peshave të dallueshme që mund të maten.\n\n  Shembull:\n  - distinct_weights_count(&[1, 4, 6]) kthen 10\n  - distinct_weights_count(&[2, 3]) kthen 5 (peshat: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) kthen 1 (vetëm zero mund të matet)",
      "hy": "Գրեք Rust ֆունկցիա `fn distinct_weights_count(weights: &[i32]) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տարբեր կշիռների քանակը, որոնք կարող են չափվել տրված կշիռների հավաքածուով հավասարակշռության կշեռքի վրա:\n  Կշիռները կարող են տեղադրվել կշեռքի ցանկացած կողմում, և նույն կշիռը չի կարող օգտագործվել մեկից ավելի անգամ:\n\n  Արգումենտներ:\n  - weights: Կշիռները ներկայացնող ամբողջ թվերի կտոր:\n\n  Վերադարձնում է.\n  - Տարբեր կշիռների ընդհանուր քանակը, որոնք կարող են չափվել:\n\n  Օրինակ:\n  - distinct_weights_count(&[1, 4, 6]) վերադարձնում է 10\n  - distinct_weights_count(&[2, 3]) վերադարձնում է 5 (կշիռներ: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) վերադարձնում է 1 (կարող է չափվել միայն զրոն)",
      "bn": "Rust ফাংশন `fn distinct_weights_count(weights: &[i32]) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সেটের ওজন ব্যবহার করে একটি ভারসাম্য স্কেলে পরিমাপ করা যেতে পারে এমন পৃথক ওজনের সংখ্যা গণনা করে।\n  ওজন স্কেলের যেকোনো পাশে রাখা যেতে পারে, এবং একই ওজন একাধিকবার ব্যবহার করা যাবে না।\n\n  আর্গুমেন্টসমূহ:\n  - weights: পূর্ণসংখ্যার একটি স্লাইস যা ওজনকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - মোট পৃথক ওজনের সংখ্যা যা পরিমাপ করা যেতে পারে।\n\n  উদাহরণ:\n  - distinct_weights_count(&[1, 4, 6]) রিটার্ন করে 10\n  - distinct_weights_count(&[2, 3]) রিটার্ন করে 5 (ওজন: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) রিটার্ন করে 1 (শুধুমাত্র শূন্য পরিমাপ করা যেতে পারে)",
      "bg": "Напишете функция на Rust `fn distinct_weights_count(weights: &[i32]) -> i32`, за да решите следния проблем:\nИзчислява броя на различните тежести, които могат да бъдат измерени с даден набор от тежести на везна.\nТежестите могат да бъдат поставени от двете страни на везната и една и съща тежест не може да се използва повече от веднъж.\n\nАргументи:\n- weights: Срез от цели числа, представляващи тежестите.\n\nВръща:\n- Общият брой на различните тежести, които могат да бъдат измерени.\n\nПример:\n- distinct_weights_count(&[1, 4, 6]) връща 10\n- distinct_weights_count(&[2, 3]) връща 5 (тежести: 1, 2, 3, 5)\n- distinct_weights_count(&[]) връща 1 (може да се измери само нула)",
      "zh": "编写一个 Rust 函数 `fn distinct_weights_count(weights: &[i32]) -> i32` 来解决以下问题：\n计算使用给定的一组砝码在天平上可以测量的不同重量的数量。\n砝码可以放在天平的任一侧，并且同一个砝码不能被多次使用。\n\n参数：\n- weights: 一个整数切片，表示砝码。\n\n返回值：\n- 可以测量的不同重量的总数。\n\n示例：\n- distinct_weights_count(&[1, 4, 6]) 返回 10\n- distinct_weights_count(&[2, 3]) 返回 5 (weights: 1, 2, 3, 5)\n- distinct_weights_count(&[]) 返回 1 (只有零可以被测量)",
      "fr": "Écrire une fonction Rust `fn distinct_weights_count(weights: &[i32]) -> i32` pour résoudre le problème suivant :\nCalcule le nombre de poids distincts qui peuvent être mesurés en utilisant un ensemble donné de poids sur une balance.\n  Les poids peuvent être placés de chaque côté de la balance, et le même poids ne peut pas être utilisé plus d'une fois.\n\n  Arguments :\n  - weights : Une tranche d'entiers représentant les poids.\n\n  Renvoie :\n  - Le nombre total de poids distincts qui peuvent être mesurés.\n\n  Exemple :\n  - distinct_weights_count(&[1, 4, 6]) renvoie 10\n  - distinct_weights_count(&[2, 3]) renvoie 5 (poids : 1, 2, 3, 5)\n  - distinct_weights_count(&[]) renvoie 1 (seul zéro peut être mesuré)",
      "de": "Schreiben Sie eine Rust-Funktion `fn distinct_weights_count(weights: &[i32]) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der unterschiedlichen Gewichte, die mit einem gegebenen Satz von Gewichten auf einer Waage gemessen werden können.\n  Die Gewichte können auf beiden Seiten der Waage platziert werden, und dasselbe Gewicht kann nicht mehr als einmal verwendet werden.\n\n  Argumente:\n  - weights: Ein Slice von Ganzzahlen, das die Gewichte darstellt.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der unterschiedlichen Gewichte, die gemessen werden können.\n\n  Beispiel:\n  - distinct_weights_count(&[1, 4, 6]) gibt 10 zurück\n  - distinct_weights_count(&[2, 3]) gibt 5 zurück (Gewichte: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) gibt 1 zurück (nur Null kann gemessen werden)",
      "ha": "Rubuta aikin Rust `fn distinct_weights_count(weights: &[i32]) -> i32` don warware matsalar mai zuwa:\nƘididdige adadin nau'ikan nauyi daban-daban da za a iya aunawa ta amfani da saitin nauyi da aka bayar akan ma'aunin ma'auni.\n  Ana iya sanya nauyin a kowane gefen ma'aunin, kuma ba za a iya amfani da nauyi ɗaya fiye da sau ɗaya ba.\n\n  Huɗɗa:\n  - weights: Yanke lambobi masu nuna nauyin.\n\n  Dawowa:\n  - Jimlar adadin nau'ikan nauyi daban-daban da za a iya aunawa.\n\n  Misali:\n  - distinct_weights_count(&[1, 4, 6]) yana dawowa 10\n  - distinct_weights_count(&[2, 3]) yana dawowa 5 (nauyi: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) yana dawowa 1 (kawai sifili za a iya aunawa)",
      "hi": "Rust फ़ंक्शन `fn distinct_weights_count(weights: &[i32]) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक संतुलन तराजू पर दिए गए वजन के सेट का उपयोग करके मापे जा सकने वाले भिन्न-भिन्न वजन की संख्या की गणना करता है। \nवजन को तराजू के किसी भी तरफ रखा जा सकता है, और एक ही वजन को एक से अधिक बार उपयोग नहीं किया जा सकता।\n\nआर्गुमेंट्स:\n- weights: पूर्णांकों का एक स्लाइस जो वजन का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n- मापे जा सकने वाले भिन्न-भिन्न वजन की कुल संख्या।\n\nउदाहरण:\n- distinct_weights_count(&[1, 4, 6]) 10 लौटाता है\n- distinct_weights_count(&[2, 3]) 5 लौटाता है (वजन: 1, 2, 3, 5)\n- distinct_weights_count(&[]) 1 लौटाता है (केवल शून्य मापा जा सकता है)",
      "hu": "Írj egy Rust függvényt `fn distinct_weights_count(weights: &[i32]) -> i32` a következő probléma megoldására:\nKiszámítja a különböző súlyok számát, amelyeket meg lehet mérni egy adott súlykészlettel egy mérlegen.\n  A súlyok a mérleg bármelyik oldalára helyezhetők, és ugyanazt a súlyt nem lehet többször használni.\n\n  Argumentumok:\n  - weights: Egy egész számokat tartalmazó szelet, amely a súlyokat reprezentálja.\n\n  Visszatérési érték:\n  - A mérhető különböző súlyok teljes száma.\n\n  Példa:\n  - distinct_weights_count(&[1, 4, 6]) visszaadja 10\n  - distinct_weights_count(&[2, 3]) visszaadja 5 (súlyok: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) visszaadja 1 (csak a nulla mérhető)"
    },
    "instruction_bertscore": {
      "sq": "0.9823691701185813",
      "hy": "0.9861042158035613",
      "bn": "0.9630172079854952",
      "bg": "0.9859026059668109",
      "zh": "0.9689207015402331",
      "fr": "0.9808993052989231",
      "de": "0.9862807982123013",
      "ha": "0.968402276245732",
      "hi": "0.9740207352036849",
      "hu": "0.9822299302214758"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(distinct_weights_count(&[1, 4, 6]), 10);\n        assert_eq!(distinct_weights_count(&[2, 3]), 4);\n        assert_eq!(distinct_weights_count(&[]), 0);\n        assert_eq!(distinct_weights_count(&[1, 2, 2]), 5);  \n        \n    }\n    \n\n}",
    "entry_point": "distinct_weights_count",
    "signature": "fn distinct_weights_count(weights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)",
      "sq": "Llogarit numrin e peshave të dallueshme që mund të maten duke përdorur një grup të caktuar peshash në një peshore. Peshat mund të vendosen në secilën anë të peshores, dhe e njëjta peshë nuk mund të përdoret më shumë se një herë.\n\nArgumentet:\n- weights: Një segment i numrave të plotë që përfaqësojnë peshat.\n\nKthen:\n- Numri total i peshave të dallueshme që mund të maten.\n\nShembull:\n- distinct_weights_count(&[1, 4, 6]) kthen 10\n- distinct_weights_count(&[2, 3]) kthen 5 (pesha: 1, 2, 3, 5)\n- distinct_weights_count(&[]) kthen 1 (vetëm zero mund të matet)",
      "hy": "Հաշվում է տարբեր քաշերի քանակը, որոնք կարելի է չափել տրված քաշերի հավաքածուով հավասարակշռության կշեռքի վրա:\n  Քաշերը կարող են տեղադրվել կշեռքի երկու կողմերում, և նույն քաշը չի կարող օգտագործվել ավելի քան մեկ անգամ:\n\n  Արձանագրություններ:\n  - weights: Integer-ների շերտ, որը ներկայացնում է քաշերը:\n\n  Վերադարձնում է:\n  - Տարբեր քաշերի ընդհանուր քանակը, որոնք կարելի է չափել:\n\n  Օրինակ:\n  - distinct_weights_count(&[1, 4, 6]) վերադարձնում է 10\n  - distinct_weights_count(&[2, 3]) վերադարձնում է 5 (քաշեր: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) վերադարձնում է 1 (կարելի է չափել միայն զրոն)",
      "bn": "ব্যালেন্স স্কেলে প্রদত্ত ওজন সেট ব্যবহার করে কতগুলি স্বতন্ত্র ওজন পরিমাপ করা যেতে পারে তা গণনা করে। \n  ওজনগুলি স্কেলের যেকোনো পাশে রাখা যেতে পারে, এবং একই ওজন একাধিকবার ব্যবহার করা যাবে না।\n\n  আর্গুমেন্টস:\n  - weights: পূর্ণসংখ্যার একটি স্লাইস যা ওজনগুলি উপস্থাপন করে।\n\n  রিটার্নস:\n  - মোট কতগুলি স্বতন্ত্র ওজন পরিমাপ করা যেতে পারে।\n\n  উদাহরণ:\n  - distinct_weights_count(&[1, 4, 6]) 10 রিটার্ন করে\n  - distinct_weights_count(&[2, 3]) 5 রিটার্ন করে (ওজন: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 রিটার্ন করে (শুধুমাত্র শূন্য পরিমাপ করা যেতে পারে)",
      "bg": "Изчислява броя на различните тежести, които могат да бъдат измерени с даден набор от тежести на везна. \nТежестите могат да бъдат поставени от двете страни на везната и една и съща тежест не може да се използва повече от веднъж.\n\nАргументи:\n- weights: Срез от цели числа, представляващи тежестите.\n\nВръща:\n- Общият брой на различните тежести, които могат да бъдат измерени.\n\nПример:\n- distinct_weights_count(&[1, 4, 6]) връща 10\n- distinct_weights_count(&[2, 3]) връща 5 (тежести: 1, 2, 3, 5)\n- distinct_weights_count(&[]) връща 1 (може да се измери само нула)",
      "zh": "计算使用给定的一组砝码在天平上可以测量的不同重量的数量。  \n砝码可以放在天平的任一侧，并且同一个砝码不能被多次使用。\n\n参数:\n- weights: 一个整数切片，表示砝码。\n\n返回:\n- 可以测量的不同重量的总数。\n\n示例:\n- distinct_weights_count(&[1, 4, 6]) 返回 10\n- distinct_weights_count(&[2, 3]) 返回 5 (weights: 1, 2, 3, 5)\n- distinct_weights_count(&[]) 返回 1 (只有零可以被测量)",
      "fr": "Calcule le nombre de poids distincts qui peuvent être mesurés en utilisant un ensemble donné de poids sur une balance.  \nLes poids peuvent être placés de chaque côté de la balance, et le même poids ne peut pas être utilisé plus d'une fois.\n\nArguments:\n- weights: Une tranche d'entiers représentant les poids.\n\nReturns:\n- Le nombre total de poids distincts qui peuvent être mesurés.\n\nExample:\n- distinct_weights_count(&[1, 4, 6]) retourne 10\n- distinct_weights_count(&[2, 3]) retourne 5 (poids : 1, 2, 3, 5)\n- distinct_weights_count(&[]) retourne 1 (seul zéro peut être mesuré)",
      "de": "Berechnet die Anzahl der unterschiedlichen Gewichte, die mit einem gegebenen Satz von Gewichten auf einer Waage gemessen werden können. Die Gewichte können auf beiden Seiten der Waage platziert werden, und dasselbe Gewicht kann nicht mehr als einmal verwendet werden.\n\nArgumente:\n- weights: Ein Slice von ganzen Zahlen, das die Gewichte darstellt.\n\nRückgabewerte:\n- Die Gesamtanzahl der unterschiedlichen Gewichte, die gemessen werden können.\n\nBeispiel:\n- distinct_weights_count(&[1, 4, 6]) gibt 10 zurück\n- distinct_weights_count(&[2, 3]) gibt 5 zurück (Gewichte: 1, 2, 3, 5)\n- distinct_weights_count(&[]) gibt 1 zurück (nur Null kann gemessen werden)",
      "ha": "Lissafa yawan nau'ikan nauyi daban-daban da za a iya aunawa ta amfani da saitin nauyi da aka bayar akan ma'aunin ma'auni.\n  Ana iya sanya nauyin a ko wanne ɓangaren ma'aunin, kuma ba za a iya amfani da nauyi ɗaya fiye da sau ɗaya ba.\n\n  Arguments:\n  - weights: Wani yanki na lambobi masu nuna nauyin.\n\n  Returns:\n  - Jimlar adadin nau'ikan nauyi daban-daban da za a iya auna.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (nauyi: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (ana iya auna sifili kawai)",
      "hi": "विभिन्न भारों की संख्या की गणना करता है जो एक बैलेंस स्केल का उपयोग करके मापे जा सकते हैं। दिए गए भारों का सेट बैलेंस स्केल पर रखा जाता है।\n  भारों को स्केल के किसी भी तरफ रखा जा सकता है, और एक ही भार का उपयोग एक से अधिक बार नहीं किया जा सकता।\n\n  तर्क:\n  - weights: पूर्णांकों का एक स्लाइस जो भारों का प्रतिनिधित्व करता है।\n\n  वापसी:\n  - मापे जा सकने वाले विभिन्न भारों की कुल संख्या।\n\n  उदाहरण:\n  - distinct_weights_count(&[1, 4, 6]) 10 लौटाता है\n  - distinct_weights_count(&[2, 3]) 5 लौटाता है (भार: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 लौटाता है (केवल शून्य मापा जा सकता है)",
      "hu": "Számítja ki a különböző mérhető súlyok számát egy adott súlykészlet segítségével egy mérlegen.\n  A súlyok a mérleg bármelyik oldalára helyezhetők, és ugyanazt a súlyt nem lehet többször használni.\n\n  Argumentumok:\n  - weights: Egész számokat tartalmazó szelet, amely a súlyokat képviseli.\n\n  Visszatérési érték:\n  - A különböző mérhető súlyok teljes száma.\n\n  Példa:\n  - distinct_weights_count(&[1, 4, 6]) visszaadja 10\n  - distinct_weights_count(&[2, 3]) visszaadja 5 (súlyok: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) visszaadja 1 (csak a nulla mérhető)"
    },
    "docstring_bertscore": {
      "sq": "0.9880748278138084",
      "hy": "0.9722439864453278",
      "bn": "0.9713994100651675",
      "bg": "0.9792395498349955",
      "zh": "0.9627055569176515",
      "fr": "0.9836304730381528",
      "de": "0.9773142255516244",
      "ha": "0.9767473344441508",
      "hi": "0.9611228700415655",
      "hu": "0.9493385267955277"
    }
  },
  {
    "task_id": "Rust/17",
    "prompt": {
      "en": "/*\n  Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "sq": "/*\n  Gjen ëndrrën me vlerën më të lartë që është brenda aftësisë së përdoruesit.\n\n  Kjo funksion merr një varg me vlera ëndrrash dhe pikët e aftësisë së përdoruesit. Ajo kthen vlerën më të lartë të ëndrrës që nuk e tejkalon aftësinë e përdoruesit.\n\n  Argumentet:\n  - dreams: Një varg i numrave të plotë 32-bit pa shenjë, secili që përfaqëson aftësinë e kërkuar për një ëndërr.\n  - ability: Një numër i plotë 32-bit pa shenjë që përfaqëson pikët e aftësisë së përdoruesit.\n\n  Kthen:\n  - Vlera e ëndrrës që është më e larta por ende brenda aftësisë së përdoruesit.\n\n  Shembuj:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) kthen 98\n  - max_dream_within_ability(&[20, 40, 60], 50) kthen 40\n  - max_dream_within_ability(&[10, 20, 30], 5) kthen 0 (Asnjë ëndërr brenda aftësisë)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "hy": "/*\n  Գտնում է ամենաբարձր արժեքով երազանքը, որը գտնվում է օգտագործողի կարողությունների սահմաններում։\n\n  Այս ֆունկցիան ընդունում է երազանքների արժեքների զանգված և օգտագործողի կարողությունների միավոր։ Այն վերադարձնում է ամենաբարձր երազանքի արժեքը, որը չի գերազանցում օգտագործողի կարողությունները։\n\n  Արգումենտներ:\n  - dreams: Անկյունային 32-բիթանոց ամբողջ թվերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է երազանքի համար պահանջվող կարողությունը։\n  - ability: Անկյունային 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է օգտագործողի կարողությունների միավորը։\n\n  Վերադարձնում է:\n  - Երազանքի արժեքը, որը ամենաբարձրն է, բայց դեռ գտնվում է օգտագործողի կարողությունների սահմաններում։\n\n  Օրինակներ:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) վերադարձնում է 98\n  - max_dream_within_ability(&[20, 40, 60], 50) վերադարձնում է 40\n  - max_dream_within_ability(&[10, 20, 30], 5) վերադարձնում է 0 (Ոչ մի երազանք կարողությունների սահմաններում)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
      "bn": "/*\n  এমন একটি স্বপ্ন খুঁজে বের করে যার মান ব্যবহারকারীর সামর্থ্যের মধ্যে সর্বোচ্চ।\n\n  এই ফাংশনটি স্বপ্নের মানগুলির একটি অ্যারে এবং ব্যবহারকারীর সামর্থ্যের স্কোর নেয়। এটি এমন সর্বোচ্চ স্বপ্নের মান ফেরত দেয় যা ব্যবহারকারীর সামর্থ্য অতিক্রম করে না।\n\n  আর্গুমেন্টসমূহ:\n  - dreams: স্বপ্নের জন্য প্রয়োজনীয় সামর্থ্য উপস্থাপনকারী প্রতিটি ৩২-বিট পূর্ণসংখ্যার একটি অ্যারে।\n  - ability: ব্যবহারকারীর সামর্থ্যের স্কোর উপস্থাপনকারী একটি ৩২-বিট পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - স্বপ্নের মান যা সর্বোচ্চ কিন্তু এখনও ব্যবহারকারীর সামর্থ্যের মধ্যে।\n\n  উদাহরণসমূহ:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 ফেরত দেয়\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 ফেরত দেয়\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 ফেরত দেয় (সামর্থ্যের মধ্যে কোনো স্বপ্ন নেই)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "bg": "/*\n  Намира мечтата с най-висока стойност, която е в рамките на възможностите на потребителя.\n\n  Тази функция приема масив от стойности на мечти и оценка на възможностите на потребителя. Тя връща стойността на най-високата мечта, която не надвишава възможностите на потребителя.\n\n  Аргументи:\n  - dreams: Масив от беззнакови 32-битови цели числа, всяко от които представлява необходимите възможности за мечта.\n  - ability: Беззнаково 32-битово цяло число, представляващо оценката на възможностите на потребителя.\n\n  Връща:\n  - Стойността на мечтата, която е най-висока, но все още в рамките на възможностите на потребителя.\n\n  Примери:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) връща 98\n  - max_dream_within_ability(&[20, 40, 60], 50) връща 40\n  - max_dream_within_ability(&[10, 20, 30], 5) връща 0 (Няма мечта в рамките на възможностите)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "zh": "/*\n  找到用户能力范围内价值最高的梦想。\n\n  此函数接受一个梦想价值数组和用户的能力值。它返回不超过用户能力的最高梦想价值。\n\n  参数：\n  - dreams: 一个无符号32位整数数组，每个整数代表一个梦想所需的能力。\n  - ability: 一个无符号32位整数，代表用户的能力值。\n\n  返回：\n  - 在用户能力范围内价值最高的梦想。\n\n  示例：\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 返回 98\n  - max_dream_within_ability(&[20, 40, 60], 50) 返回 40\n  - max_dream_within_ability(&[10, 20, 30], 5) 返回 0 （没有在能力范围内的梦想）\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "fr": "/*\n  Trouve le rêve de plus grande valeur qui est à la portée de l'utilisateur.\n\n  Cette fonction prend un tableau de valeurs de rêves et le score de capacité de l'utilisateur. Elle renvoie la valeur du rêve la plus élevée qui ne dépasse pas la capacité de l'utilisateur.\n\n  Arguments :\n  - dreams : Un tableau d'entiers non signés de 32 bits, chacun représentant la capacité requise pour un rêve.\n  - ability : Un entier non signé de 32 bits représentant le score de capacité de l'utilisateur.\n\n  Renvoie :\n  - La valeur du rêve qui est la plus élevée mais toujours à la portée de l'utilisateur.\n\n  Exemples :\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) renvoie 98\n  - max_dream_within_ability(&[20, 40, 60], 50) renvoie 40\n  - max_dream_within_ability(&[10, 20, 30], 5) renvoie 0 (Aucun rêve à la portée)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "de": "/*\n  Findet den höchstbewerteten Traum, der innerhalb der Fähigkeit des Benutzers liegt.\n\n  Diese Funktion nimmt ein Array von Traumwerten und den Fähigkeitswert des Benutzers. Sie gibt den höchsten Traumwert zurück, der die Fähigkeit des Benutzers nicht überschreitet.\n\n  Argumente:\n  - dreams: Ein Array von unsignierten 32-Bit-Integern, von denen jeder die für einen Traum erforderliche Fähigkeit darstellt.\n  - ability: Ein unsignierter 32-Bit-Integer, der den Fähigkeitswert des Benutzers darstellt.\n\n  Rückgabewert:\n  - Der Wert des Traums, der der höchste ist, aber dennoch innerhalb der Fähigkeit des Benutzers liegt.\n\n  Beispiele:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) gibt 98 zurück\n  - max_dream_within_ability(&[20, 40, 60], 50) gibt 40 zurück\n  - max_dream_within_ability(&[10, 20, 30], 5) gibt 0 zurück (Kein Traum innerhalb der Fähigkeit)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "ha": "/*\n  Nemi mafarki mafi girma wanda yake cikin ikon mai amfani.\n\n  Wannan aikin yana ɗaukar jerin ƙimar mafarki da ƙimar ikon mai amfani. Yana dawo da mafi girman ƙimar mafarki wanda bai wuce ikon mai amfani ba.\n\n  Huɗɗa:\n  - dreams: Jerin lambobi masu ɗauke da unsigned 32-bit, kowanne yana wakiltar ikon da ake buƙata don mafarki.\n  - ability: Lamba mai ɗauke da unsigned 32-bit wanda ke wakiltar ƙimar ikon mai amfani.\n\n  Komawa:\n  - Ƙimar mafarkin da yake mafi girma amma har yanzu yana cikin ikon mai amfani.\n\n  Misalai:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) yana dawowa 98\n  - max_dream_within_ability(&[20, 40, 60], 50) yana dawowa 40\n  - max_dream_within_ability(&[10, 20, 30], 5) yana dawowa 0 (Babu mafarki cikin ikon)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "hi": "/*\n  उपयोगकर्ता की क्षमता के भीतर सबसे उच्च-मूल्य वाले सपने को खोजता है।\n\n  यह फ़ंक्शन सपनों के मूल्यों की एक array और उपयोगकर्ता की क्षमता स्कोर लेता है। यह सबसे उच्च सपने का मूल्य लौटाता है जो उपयोगकर्ता की क्षमता से अधिक नहीं होता।\n\n  तर्क:\n  - dreams: unsigned 32-bit पूर्णांकों की एक array, प्रत्येक एक सपने के लिए आवश्यक क्षमता का प्रतिनिधित्व करता है।\n  - ability: unsigned 32-bit पूर्णांक जो उपयोगकर्ता की क्षमता स्कोर का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - उस सपने का मूल्य जो सबसे उच्च है लेकिन फिर भी उपयोगकर्ता की क्षमता के भीतर है।\n\n  उदाहरण:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 लौटाता है\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 लौटाता है\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 लौटाता है (क्षमता के भीतर कोई सपना नहीं)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
      "hu": "/*\n  Megkeresi a legmagasabb értékű álmot, amely a felhasználó képességein belül van.\n\n  Ez a függvény egy álomértékek tömbjét és a felhasználó képességpontszámát veszi. Visszaadja a legmagasabb álomértéket, amely nem haladja meg a felhasználó képességét.\n\n  Argumentumok:\n  - dreams: Egy tömb 32 bites előjel nélküli egész számokkal, amelyek mindegyike egy álomhoz szükséges képességet jelöl.\n  - ability: Egy 32 bites előjel nélküli egész szám, amely a felhasználó képességpontszámát jelöli.\n\n  Visszatér:\n  - Az álom értéke, amely a legmagasabb, de még mindig a felhasználó képességein belül van.\n\n  Példák:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) visszaadja 98\n  - max_dream_within_ability(&[20, 40, 60], 50) visszaadja 40\n  - max_dream_within_ability(&[10, 20, 30], 5) visszaadja 0 (Nincs álom a képességen belül)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 "
    },
    "prompt_bertscore": {
      "sq": "0.9815543882955762",
      "hy": "0.9809350587675094",
      "bn": "0.9674506380901939",
      "bg": "0.9561283091104432",
      "zh": "0.9489716564817562",
      "fr": "0.9681222074084729",
      "de": "0.987275340530143",
      "ha": "0.9600627796979823",
      "hi": "0.9907321050512932",
      "hu": "0.9843971863089475"
    },
    "canonical_solution": "{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` to solve the following problem:\nFinds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)",
      "sq": "Shkruani një funksion në Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` për të zgjidhur problemin e mëposhtëm:\nGjen ëndrrën me vlerën më të lartë që është brenda aftësisë së përdoruesit.\n\nKy funksion merr një varg me vlera ëndrrash dhe pikët e aftësisë së përdoruesit. Ai kthen vlerën më të lartë të ëndrrës që nuk e tejkalon aftësinë e përdoruesit.\n\nArgumentet:\n- dreams: Një varg me numra të plotë pa shenjë 32-bit, secili që përfaqëson aftësinë e kërkuar për një ëndërr.\n- ability: Një numër i plotë pa shenjë 32-bit që përfaqëson pikët e aftësisë së përdoruesit.\n\nKthen:\n- Vlera e ëndrrës që është më e larta por ende brenda aftësisë së përdoruesit.\n\nShembuj:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) kthen 98\n- max_dream_within_ability(&[20, 40, 60], 50) kthen 40\n- max_dream_within_ability(&[10, 20, 30], 5) kthen 0 (Asnjë ëndërr brenda aftësisë)",
      "hy": "Գրեք Rust ֆունկցիա `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաբարձր արժեքով երազանքը, որը գտնվում է օգտագործողի կարողությունների սահմաններում:\n\nԱյս ֆունկցիան ընդունում է երազանքների արժեքների զանգված և օգտագործողի կարողությունների միավոր: Այն վերադարձնում է ամենաբարձր երազանքի արժեքը, որը չի գերազանցում օգտագործողի կարողությունները:\n\nԱրգումենտներ:\n- dreams: Անստորագիր 32-բիթանոց ամբողջ թվերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է երազանքի համար պահանջվող կարողությունը:\n- ability: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է օգտագործողի կարողությունների միավորը:\n\nՎերադարձնում է:\n- Երազանքի արժեքը, որը ամենաբարձրն է, բայց դեռ գտնվում է օգտագործողի կարողությունների սահմաններում:\n\nՕրինակներ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) վերադարձնում է 98\n- max_dream_within_ability(&[20, 40, 60], 50) վերադարձնում է 40\n- max_dream_within_ability(&[10, 20, 30], 5) վերադարձնում է 0 (Ոչ մի երազանք կարողությունների սահմաններում)",
      "bn": "Rust ফাংশন `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nব্যবহারকারীর ক্ষমতার মধ্যে সর্বোচ্চ মূল্যের স্বপ্ন খুঁজে বের করে।\n\nএই ফাংশনটি স্বপ্নের মানের একটি অ্যারে এবং ব্যবহারকারীর ক্ষমতা স্কোর নেয়। এটি সর্বোচ্চ স্বপ্নের মান প্রদান করে যা ব্যবহারকারীর ক্ষমতা অতিক্রম করে না।\n\nআর্গুমেন্টসমূহ:\n- dreams: অনসাইনড ৩২-বিট পূর্ণসংখ্যার একটি অ্যারে, প্রতিটি স্বপ্নের জন্য প্রয়োজনীয় ক্ষমতা উপস্থাপন করে।\n- ability: একটি অনসাইনড ৩২-বিট পূর্ণসংখ্যা যা ব্যবহারকারীর ক্ষমতা স্কোর উপস্থাপন করে।\n\nফেরত দেয়:\n- স্বপ্নের মান যা সর্বোচ্চ কিন্তু এখনও ব্যবহারকারীর ক্ষমতার মধ্যে।\n\nউদাহরণসমূহ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) ফেরত দেয় 98\n- max_dream_within_ability(&[20, 40, 60], 50) ফেরত দেয় 40\n- max_dream_within_ability(&[10, 20, 30], 5) ফেরত দেয় 0 (ক্ষমতার মধ্যে কোনো স্বপ্ন নেই)",
      "bg": "Напишете функция на Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32`, за да решите следния проблем:\nНамира мечтата с най-висока стойност, която е в рамките на способностите на потребителя.\n\nТази функция приема масив от стойности на мечти и резултат за способностите на потребителя. Тя връща стойността на най-високата мечта, която не надвишава способностите на потребителя.\n\nАргументи:\n- dreams: Масив от беззнакови 32-битови цели числа, всяко от които представлява необходимите способности за мечта.\n- ability: Беззнаково 32-битово цяло число, представляващо резултата за способностите на потребителя.\n\nВръща:\n- Стойността на мечтата, която е най-висока, но все още в рамките на способностите на потребителя.\n\nПримери:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) връща 98\n- max_dream_within_ability(&[20, 40, 60], 50) връща 40\n- max_dream_within_ability(&[10, 20, 30], 5) връща 0 (Няма мечта в рамките на способностите)",
      "zh": "编写一个 Rust 函数 `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` 来解决以下问题：\n找到在用户能力范围内价值最高的梦想。\n\n此函数接受一个梦想值数组和用户的能力值。它返回不超过用户能力的最高梦想值。\n\n参数：\n- dreams: 一个无符号32位整数数组，每个整数代表一个梦想所需的能力。\n- ability: 一个无符号32位整数，代表用户的能力值。\n\n返回：\n- 在用户能力范围内的最高梦想值。\n\n示例：\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 返回 98\n- max_dream_within_ability(&[20, 40, 60], 50) 返回 40\n- max_dream_within_ability(&[10, 20, 30], 5) 返回 0 (没有在能力范围内的梦想)",
      "fr": "Écrire une fonction Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` pour résoudre le problème suivant :\nTrouver le rêve de la plus grande valeur qui est à la portée de l'utilisateur.\n\n  Cette fonction prend un tableau de valeurs de rêves et le score de capacité de l'utilisateur. Elle renvoie la valeur du rêve la plus élevée qui ne dépasse pas la capacité de l'utilisateur.\n\n  Arguments :\n  - dreams : Un tableau d'entiers non signés de 32 bits, chacun représentant la capacité requise pour un rêve.\n  - ability : Un entier non signé de 32 bits représentant le score de capacité de l'utilisateur.\n\n  Renvoie :\n  - La valeur du rêve qui est la plus élevée mais toujours à la portée de l'utilisateur.\n\n  Exemples :\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) renvoie 98\n  - max_dream_within_ability(&[20, 40, 60], 50) renvoie 40\n  - max_dream_within_ability(&[10, 20, 30], 5) renvoie 0 (Aucun rêve à la portée)",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32`, um das folgende Problem zu lösen:\nFindet den höchstbewerteten Traum, der innerhalb der Fähigkeiten des Benutzers liegt.\n\n  Diese Funktion nimmt ein Array von Traumwerten und den Fähigkeitswert des Benutzers. Sie gibt den höchsten Traumwert zurück, der die Fähigkeiten des Benutzers nicht übersteigt.\n\n  Argumente:\n  - dreams: Ein Array von 32-Bit-Unsigned-Integern, von denen jeder die erforderliche Fähigkeit für einen Traum darstellt.\n  - ability: Ein 32-Bit-Unsigned-Integer, das den Fähigkeitswert des Benutzers darstellt.\n\n  Rückgabewert:\n  - Der Wert des Traums, der am höchsten ist, aber immer noch innerhalb der Fähigkeiten des Benutzers liegt.\n\n  Beispiele:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) gibt 98 zurück\n  - max_dream_within_ability(&[20, 40, 60], 50) gibt 40 zurück\n  - max_dream_within_ability(&[10, 20, 30], 5) gibt 0 zurück (Kein Traum innerhalb der Fähigkeiten)",
      "ha": "Rubuta aikin Rust `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` don warware matsalar mai zuwa:\nNemo mafarkin da ya fi kima wanda yake cikin ikon mai amfani.\n\n  Wannan aikin yana karɓar jerin kimar mafarki da kuma maki ikon mai amfani. Yana dawo da mafi girman kimar mafarki wanda ba ya wuce ikon mai amfani.\n\n  Huɗɗa:\n  - dreams: Jerin lambobin 32-bit marasa alama, kowanne yana wakiltar ikon da ake buƙata don mafarki.\n  - ability: Lamba 32-bit marasa alama wadda ke wakiltar maki ikon mai amfani.\n\n  Dawowa:\n  - Kimar mafarkin da ya fi kima amma har yanzu yana cikin ikon mai amfani.\n\n  Misalai:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) yana dawo da 98\n  - max_dream_within_ability(&[20, 40, 60], 50) yana dawo da 40\n  - max_dream_within_ability(&[10, 20, 30], 5) yana dawo da 0 (Babu mafarki cikin ikon)",
      "hi": "Rust फ़ंक्शन `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउपयोगकर्ता की क्षमता के भीतर सबसे अधिक मूल्य वाला सपना खोजें।\n\nयह फ़ंक्शन सपनों के मूल्यों की एक array और उपयोगकर्ता की क्षमता स्कोर लेता है। यह सबसे अधिक सपना मूल्य लौटाता है जो उपयोगकर्ता की क्षमता से अधिक नहीं होता।\n\nतर्क:\n- dreams: unsigned 32-बिट पूर्णांकों की एक array, प्रत्येक सपना के लिए आवश्यक क्षमता का प्रतिनिधित्व करता है।\n- ability: unsigned 32-बिट पूर्णांक जो उपयोगकर्ता की क्षमता स्कोर का प्रतिनिधित्व करता है।\n\nवापसी:\n- उस सपने का मूल्य जो सबसे अधिक है लेकिन फिर भी उपयोगकर्ता की क्षमता के भीतर है।\n\nउदाहरण:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 लौटाता है\n- max_dream_within_ability(&[20, 40, 60], 50) 40 लौटाता है\n- max_dream_within_ability(&[10, 20, 30], 5) 0 लौटाता है (क्षमता के भीतर कोई सपना नहीं)",
      "hu": "Írj egy Rust függvényt `fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32` a következő probléma megoldására:\nMegtalálja a legmagasabb értékű álmot, amely a felhasználó képességein belül van.\n\n  Ez a függvény egy álomértékeket tartalmazó tömböt és a felhasználó képességpontszámát veszi át. Visszaadja a legmagasabb álomértéket, amely nem haladja meg a felhasználó képességeit.\n\n  Argumentumok:\n  - dreams: Egy tömb 32 bites előjel nélküli egész számokkal, amelyek mindegyike egy álomhoz szükséges képességet jelképez.\n  - ability: Egy 32 bites előjel nélküli egész szám, amely a felhasználó képességpontszámát jelképezi.\n\n  Visszatér:\n  - Az álom értéke, amely a legmagasabb, de még mindig a felhasználó képességein belül van.\n\n  Példák:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) visszaadja 98\n  - max_dream_within_ability(&[20, 40, 60], 50) visszaadja 40\n  - max_dream_within_ability(&[10, 20, 30], 5) visszaadja 0 (Nincs álom a képességen belül)"
    },
    "instruction_bertscore": {
      "sq": "0.9824525948786159",
      "hy": "0.9882925267114226",
      "bn": "0.9683700981240044",
      "bg": "0.9811513672524563",
      "zh": "0.9522516399637853",
      "fr": "0.9797190435748138",
      "de": "0.9824255811467951",
      "ha": "0.9633723591067855",
      "hi": "0.9688754138133572",
      "hu": "0.9928066007508215"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_dream_within_ability(&[50, 69, 240, 135, 98], 100), 98);\n        assert_eq!(max_dream_within_ability(&[20, 40, 60], 50), 40);\n        assert_eq!(max_dream_within_ability(&[10, 20, 30], 5), 0); // No dream within ability\n        assert_eq!(max_dream_within_ability(&[120, 200, 300, 400], 350), 300);\n    \n    }\n    \n\n}",
    "entry_point": "max_dream_within_ability",
    "signature": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
    "docstring": {
      "en": "Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)",
      "sq": "Gjen ëndrrën me vlerën më të lartë që është brenda aftësisë së përdoruesit.\n\nKjo funksion merr një varg me vlera ëndrrash dhe pikët e aftësisë së përdoruesit. Ajo kthen vlerën më të lartë të ëndrrës që nuk e tejkalon aftësinë e përdoruesit.\n\nArgumentet:\n- dreams: Një varg i numrave të plotë 32-bit pa shenjë, secili që përfaqëson aftësinë e kërkuar për një ëndërr.\n- ability: Një numër i plotë 32-bit pa shenjë që përfaqëson pikët e aftësisë së përdoruesit.\n\nKthen:\n- Vlera e ëndrrës që është më e larta por ende brenda aftësisë së përdoruesit.\n\nShembuj:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) kthen 98\n- max_dream_within_ability(&[20, 40, 60], 50) kthen 40\n- max_dream_within_ability(&[10, 20, 30], 5) kthen 0 (Asnjë ëndërr brenda aftësisë)",
      "hy": "Գտնում է ամենաբարձր արժեք ունեցող երազանքը, որը գտնվում է օգտագործողի կարողությունների սահմաններում:\n\nԱյս ֆունկցիան ընդունում է երազանքների արժեքների զանգված և օգտագործողի կարողության միավոր: Այն վերադարձնում է ամենաբարձր երազանքի արժեքը, որը չի գերազանցում օգտագործողի կարողությունը:\n\nԱրգումենտներ:\n- dreams: Անստորագիր 32-բիթանոց ամբողջ թվերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է երազանքի համար պահանջվող կարողությունը:\n- ability: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է օգտագործողի կարողության միավորը:\n\nՎերադարձնում է:\n- Երազանքի արժեքը, որը ամենաբարձրն է, բայց դեռ գտնվում է օգտագործողի կարողության սահմաններում:\n\nՕրինակներ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) վերադարձնում է 98\n- max_dream_within_ability(&[20, 40, 60], 50) վերադարձնում է 40\n- max_dream_within_ability(&[10, 20, 30], 5) վերադարձնում է 0 (Ոչ մի երազանք կարողության սահմաններում)",
      "bn": "ব্যবহারকারীর ক্ষমতার মধ্যে সর্বোচ্চ মূল্যের স্বপ্ন খুঁজে বের করে।\n\nএই ফাংশনটি স্বপ্নের মানগুলির একটি অ্যারে এবং ব্যবহারকারীর ক্ষমতা স্কোর নেয়। এটি সর্বোচ্চ স্বপ্নের মান ফেরত দেয় যা ব্যবহারকারীর ক্ষমতা অতিক্রম করে না।\n\nআর্গুমেন্টস:\n- dreams: একটি আনসাইনড ৩২-বিট পূর্ণসংখ্যার অ্যারে, প্রতিটি একটি স্বপ্নের জন্য প্রয়োজনীয় ক্ষমতা উপস্থাপন করে।\n- ability: একটি আনসাইনড ৩২-বিট পূর্ণসংখ্যা যা ব্যবহারকারীর ক্ষমতা স্কোর উপস্থাপন করে।\n\nরিটার্নস:\n- সেই স্বপ্নের মান যা সর্বোচ্চ কিন্তু এখনও ব্যবহারকারীর ক্ষমতার মধ্যে।\n\nউদাহরণসমূহ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 ফেরত দেয়\n- max_dream_within_ability(&[20, 40, 60], 50) 40 ফেরত দেয়\n- max_dream_within_ability(&[10, 20, 30], 5) 0 ফেরত দেয় (ক্ষমতার মধ্যে কোনো স্বপ্ন নেই)",
      "bg": "Намира мечтата с най-висока стойност, която е в рамките на възможностите на потребителя.\n\n  Тази функция приема масив от стойности на мечти и оценка на способностите на потребителя. Връща стойността на мечтата с най-висока стойност, която не надвишава способностите на потребителя.\n\n  Аргументи:\n  - dreams: Масив от беззнакови 32-битови цели числа, всяко от които представлява необходимата способност за мечта.\n  - ability: Беззнаково 32-битово цяло число, представляващо оценката на способностите на потребителя.\n\n  Връща:\n  - Стойността на мечтата, която е най-високата, но все още в рамките на възможностите на потребителя.\n\n  Примери:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) връща 98\n  - max_dream_within_ability(&[20, 40, 60], 50) връща 40\n  - max_dream_within_ability(&[10, 20, 30], 5) връща 0 (Няма мечта в рамките на възможностите)",
      "zh": "找到在用户能力范围内的最高价值梦想。\n\n此函数接受一个梦想值数组和用户的能力分数。它返回不超过用户能力的最高梦想值。\n\n参数：\n- dreams: 一个无符号32位整数数组，每个整数代表一个梦想所需的能力。\n- ability: 一个无符号32位整数，代表用户的能力分数。\n\n返回：\n- 在用户能力范围内的最高梦想值。\n\n示例：\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 返回 98\n- max_dream_within_ability(&[20, 40, 60], 50) 返回 40\n- max_dream_within_ability(&[10, 20, 30], 5) 返回 0 （没有在能力范围内的梦想）",
      "fr": "Trouve le rêve de plus grande valeur qui est à la portée de l'utilisateur.\n\n  Cette fonction prend un tableau de valeurs de rêves et le score de capacité de l'utilisateur. Elle renvoie la valeur du rêve la plus élevée qui ne dépasse pas la capacité de l'utilisateur.\n\n  Arguments:\n  - dreams: Un tableau d'entiers non signés de 32 bits, chacun représentant la capacité requise pour un rêve.\n  - ability: Un entier non signé de 32 bits représentant le score de capacité de l'utilisateur.\n\n  Renvoie:\n  - La valeur du rêve qui est la plus élevée mais toujours à la portée de la capacité de l'utilisateur.\n\n  Exemples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) renvoie 98\n  - max_dream_within_ability(&[20, 40, 60], 50) renvoie 40\n  - max_dream_within_ability(&[10, 20, 30], 5) renvoie 0 (Aucun rêve à la portée de la capacité)",
      "de": "Findet den höchstbewerteten Traum, der innerhalb der Fähigkeit des Benutzers liegt.\n\n  Diese Funktion nimmt ein Array von Traumwerten und die Fähigkeitsbewertung des Benutzers. Sie gibt den höchsten Traumwert zurück, der die Fähigkeit des Benutzers nicht überschreitet.\n\n  Argumente:\n  - dreams: Ein Array von 32-Bit-Unsigned-Integern, wobei jeder Wert die erforderliche Fähigkeit für einen Traum darstellt.\n  - ability: Ein 32-Bit-Unsigned-Integer, das die Fähigkeitsbewertung des Benutzers darstellt.\n\n  Rückgabewerte:\n  - Der Wert des Traums, der der höchste ist, aber dennoch innerhalb der Fähigkeit des Benutzers liegt.\n\n  Beispiele:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) gibt 98 zurück\n  - max_dream_within_ability(&[20, 40, 60], 50) gibt 40 zurück\n  - max_dream_within_ability(&[10, 20, 30], 5) gibt 0 zurück (Kein Traum innerhalb der Fähigkeit)",
      "ha": "Nemi mafarki mafi girma wanda yake cikin ikon mai amfani.\n\n  Wannan aikin yana ɗaukar jerin ƙimomin mafarki da ƙimar ƙarfin mai amfani. Yana mayar da mafi girman ƙimar mafarki wanda ba ya wuce ƙarfin mai amfani.\n\n  Arguments:\n  - dreams: Jerin lambobin ɓangarorin 32-bit marasa alama, kowanne yana wakiltar ƙarfin da ake buƙata don mafarki.\n  - ability: Lambar ɓangare 32-bit marasa alama wanda ke wakiltar ƙimar ƙarfin mai amfani.\n\n  Returns:\n  - Ƙimar mafarkin da ita ce mafi girma amma har yanzu tana cikin ƙarfin mai amfani.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (Babu mafarki cikin ƙarfin)",
      "hi": "उपयोगकर्ता की क्षमता के भीतर सबसे उच्च मूल्य वाला सपना खोजता है।\n\nयह फ़ंक्शन सपनों के मूल्यों की एक array और उपयोगकर्ता की क्षमता स्कोर लेता है। यह सबसे उच्च सपना मूल्य लौटाता है जो उपयोगकर्ता की क्षमता से अधिक नहीं होता।\n\nआर्गुमेंट्स:\n- dreams: unsigned 32-बिट पूर्णांकों की एक array, प्रत्येक सपना के लिए आवश्यक क्षमता को दर्शाती है।\n- ability: unsigned 32-बिट पूर्णांक जो उपयोगकर्ता की क्षमता स्कोर को दर्शाता है।\n\nरिटर्न्स:\n- उस सपने का मूल्य जो सबसे उच्च है लेकिन फिर भी उपयोगकर्ता की क्षमता के भीतर है।\n\nउदाहरण:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 लौटाता है\n- max_dream_within_ability(&[20, 40, 60], 50) 40 लौटाता है\n- max_dream_within_ability(&[10, 20, 30], 5) 0 लौटाता है (क्षमता के भीतर कोई सपना नहीं)",
      "hu": "Megtalálja a legmagasabb értékű álmot, amely a felhasználó képességein belül van.\n\n  Ez a függvény egy álomértékek tömbjét és a felhasználó képességpontszámát veszi át. Visszaadja a legmagasabb álomértéket, amely nem haladja meg a felhasználó képességeit.\n\n  Argumentumok:\n  - dreams: Egy 32 bites előjel nélküli egész számokat tartalmazó tömb, ahol minden elem egy álomhoz szükséges képességet jelöl.\n  - ability: Egy 32 bites előjel nélküli egész szám, amely a felhasználó képességpontszámát jelöli.\n\n  Visszatérési érték:\n  - Az álom értéke, amely a legmagasabb, de még a felhasználó képességein belül van.\n\n  Példák:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) visszaadja 98\n  - max_dream_within_ability(&[20, 40, 60], 50) visszaadja 40\n  - max_dream_within_ability(&[10, 20, 30], 5) visszaadja 0 (Nincs álom a képességen belül)"
    },
    "docstring_bertscore": {
      "sq": "0.9726001307185234",
      "hy": "0.9810343739580268",
      "bn": "0.9693614623557495",
      "bg": "0.9605724652557178",
      "zh": "0.8362105795809174",
      "fr": "0.9682463513966196",
      "de": "0.9732595835835592",
      "ha": "0.9713126085886552",
      "hi": "0.975558730244038",
      "hu": "0.9795660981814169"
    }
  },
  {
    "task_id": "Rust/18",
    "prompt": {
      "en": "/*\n  Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "sq": "/*\n  Llogarit vlerën e polinomit f(x) = ax^3 + bx^2 + cx + d për një grup të dhënë koeficientësh dhe vlerën e x.\n  Kjo funksion përdor numra realë si për koeficientët ashtu edhe për vlerën e x, duke ofruar vlerën e polinomit si një numër me presje lundruese me precizion të dyfishtë.\n\n  Argumentet:\n  - x: Vlera në të cilën polinomi vlerësohet.\n  - a: Koeficienti i x^3.\n  - b: Koeficienti i x^2.\n  - c: Koeficienti i x.\n  - d: Termi konstant në polinom.\n\n  Kthen:\n  - Vlera e llogaritur e polinomit në x, si një numër me presje lundruese me precizion të dyfishtë.\n\n  Shembull:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) kthen 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "hy": "/*\n  Հաշվարկում է բազմապատկիչի արժեքը f(x) = ax^3 + bx^2 + cx + d տրված գործակիցների և x-ի արժեքի համար:\n  Այս ֆունկցիան օգտագործում է իրական թվեր ինչպես գործակիցների, այնպես էլ x-ի արժեքի համար՝ ապահովելով բազմապատկիչի արժեքը որպես կրկնակի ճշգրտության լողացող կետային թիվ:\n\n  Արգումենտներ:\n  - x: Արժեքը, որի դեպքում բազմապատկիչը գնահատվում է:\n  - a: x^3-ի գործակիցը:\n  - b: x^2-ի գործակիցը:\n  - c: x-ի գործակիցը:\n  - d: Բազմապատկիչի հաստատուն անդամը:\n\n  Վերադարձնում է:\n  - Բազմապատկիչի հաշվարկված արժեքը x-ի դեպքում, որպես կրկնակի ճշգրտության լողացող կետային թիվ:\n\n  Օրինակ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) վերադարձնում է 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "bn": "/*\n  প্রদত্ত সেটের গুণাঙ্ক এবং x এর মানের জন্য বহুপদী f(x) = ax^3 + bx^2 + cx + d এর মান গণনা করে।\n  এই ফাংশনটি গুণাঙ্ক এবং x এর মান উভয়ের জন্য বাস্তব সংখ্যা ব্যবহার করে, বহুপদীর মানকে ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যারূপে প্রদান করে।\n\n  আর্গুমেন্টসমূহ:\n  - x: যে মানে বহুপদীটি মূল্যায়ন করা হয়।\n  - a: x^3 এর গুণাঙ্ক।\n  - b: x^2 এর গুণাঙ্ক।\n  - c: x এর গুণাঙ্ক।\n  - d: বহুপদীর ধ্রুবক পদ।\n\n  রিটার্ন করে:\n  - x এ বহুপদীর গণিতকৃত মান, ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যারূপে।\n\n  উদাহরণ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 রিটার্ন করে\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "bg": "/*\n  Изчислява стойността на полинома f(x) = ax^3 + bx^2 + cx + d за даден набор от коефициенти и стойността на x.\n  Тази функция използва реални числа както за коефициентите, така и за стойността на x, предоставяйки стойността на полинома като число с двойна точност.\n\n  Аргументи:\n  - x: Стойността, при която се оценява полиномът.\n  - a: Коефициентът на x^3.\n  - b: Коефициентът на x^2.\n  - c: Коефициентът на x.\n  - d: Константният член в полинома.\n\n  Връща:\n  - Изчислената стойност на полинома при x, като число с двойна точност.\n\n  Пример:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) връща 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "zh": "/*\n  计算多项式 f(x) = ax^3 + bx^2 + cx + d 的值，给定一组系数和 x 的值。\n  这个函数使用实数作为系数和 x 的值，提供多项式的值作为双精度浮点数。\n\n  参数:\n  - x: 多项式被求值的点。\n  - a: x^3 的系数。\n  - b: x^2 的系数。\n  - c: x 的系数。\n  - d: 多项式中的常数项。\n\n  返回:\n  - 多项式在 x 处的计算值，作为双精度浮点数。\n\n  示例:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 返回 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "fr": "/*\n  Calcule la valeur du polynôme f(x) = ax^3 + bx^2 + cx + d pour un ensemble donné de coefficients et la valeur de x.\n  Cette fonction utilise des nombres réels pour les coefficients et la valeur de x, fournissant la valeur du polynôme en tant que nombre à virgule flottante en double précision.\n\n  Arguments :\n  - x : La valeur à laquelle le polynôme est évalué.\n  - a : Le coefficient de x^3.\n  - b : Le coefficient de x^2.\n  - c : Le coefficient de x.\n  - d : Le terme constant dans le polynôme.\n\n  Renvoie :\n  - La valeur calculée du polynôme en x, en tant que nombre à virgule flottante en double précision.\n\n  Exemple :\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) renvoie 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "de": "/*\n  Berechnet den Wert des Polynoms f(x) = ax^3 + bx^2 + cx + d für einen gegebenen Satz von Koeffizienten und den Wert von x.\n  Diese Funktion verwendet reelle Zahlen sowohl für die Koeffizienten als auch für den Wert von x und liefert den Wert des Polynoms als Gleitkommazahl mit doppelter Genauigkeit.\n\n  Argumente:\n  - x: Der Wert, bei dem das Polynom ausgewertet wird.\n  - a: Der Koeffizient von x^3.\n  - b: Der Koeffizient von x^2.\n  - c: Der Koeffizient von x.\n  - d: Der konstante Term im Polynom.\n\n  Rückgabewert:\n  - Der berechnete Wert des Polynoms bei x, als Gleitkommazahl mit doppelter Genauigkeit.\n\n  Beispiel:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) gibt 33.0838692 zurück\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "ha": "/*\n  Lissafi darajar polinomial f(x) = ax^3 + bx^2 + cx + d don saitin abubuwan da aka bayar da kuma darajar x.\n  Wannan aiki yana amfani da lambobi na ainihi don duka abubuwan da kuma darajar x, yana bayar da darajar polinomial a matsayin lamba mai tsawo na ninki biyu.\n\n  Huɗa:\n  - x: Darajar da ake tantance polinomial a kai.\n  - a: Abun x^3.\n  - b: Abun x^2.\n  - c: Abun x.\n  - d: Abun da ba shi da x a cikin polinomial.\n\n  Mayarwa:\n  - Darajar da aka lissafa na polinomial a x, a matsayin lamba mai tsawo na ninki biyu.\n\n  Misali:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) yana mayar da 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "hi": "/*\n  दिए गए गुणांक और x के मान के लिए बहुपद f(x) = ax^3 + bx^2 + cx + d का मान गणना करता है।\n  यह फ़ंक्शन गुणांकों और x के मान दोनों के लिए वास्तविक संख्याओं का उपयोग करता है, जो बहुपद के मान को डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में प्रदान करता है।\n\n  तर्क:\n  - x: वह मान जिस पर बहुपद का मूल्यांकन किया जाता है।\n  - a: x^3 का गुणांक।\n  - b: x^2 का गुणांक।\n  - c: x का गुणांक।\n  - d: बहुपद में स्थिर पद।\n\n  लौटाता है:\n  - x पर बहुपद का गणना किया गया मान, डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में।\n\n  उदाहरण:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 लौटाता है\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "hu": "/*\n  Kiszámítja az f(x) = ax^3 + bx^2 + cx + d polinom értékét egy adott együttható-készlet és az x értéke alapján.\n  Ez a függvény valós számokat használ mind az együtthatók, mind az x értékéhez, és a polinom értékét dupla pontosságú lebegőpontos számként adja meg.\n\n  Argumentumok:\n  - x: Az érték, amelynél a polinomot kiértékeljük.\n  - a: Az x^3 együtthatója.\n  - b: Az x^2 együtthatója.\n  - c: Az x együtthatója.\n  - d: A polinom konstans tagja.\n\n  Visszatér:\n  - A polinom x-nél számított értéke, dupla pontosságú lebegőpontos számként.\n\n  Példa:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) visszaadja 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 "
    },
    "prompt_bertscore": {
      "sq": "0.9626149814638996",
      "hy": "0.9602971635476034",
      "bn": "0.9613356031796538",
      "bg": "0.9739500227880364",
      "zh": "0.9538674981135041",
      "fr": "0.990964502597104",
      "de": "0.9848141114787397",
      "ha": "0.9702404017918289",
      "hi": "0.9622199056360211",
      "hu": "0.9807296749535193"
    },
    "canonical_solution": "{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}",
    "instruction": {
      "en": "Write a Rust function `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` to solve the following problem:\nCalculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "sq": "Shkruani një funksion Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` për të zgjidhur problemin e mëposhtëm:\nLlogarit vlerën e polinomit f(x) = ax^3 + bx^2 + cx + d për një grup të dhënë koeficientësh dhe vlerën e x.\nKy funksion përdor numra realë si për koeficientët ashtu edhe për vlerën e x, duke ofruar vlerën e polinomit si një numër me presje lundruese me precizion të dyfishtë.\n\nArgumentet:\n- x: Vlera në të cilën polinomi vlerësohet.\n- a: Koeficienti i x^3.\n- b: Koeficienti i x^2.\n- c: Koeficienti i x.\n- d: Termi konstant në polinom.\n\nKthen:\n- Vlera e llogaritur e polinomit në x, si një numër me presje lundruese me precizion të dyfishtë.\n\nShembull:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) kthen 33.0838692",
      "hy": "Գրեք Rust ֆունկցիա `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է բազմապատիկի արժեքը f(x) = ax^3 + bx^2 + cx + d տրված գործակիցների և x-ի արժեքի համար:\n  Այս ֆունկցիան օգտագործում է իրական թվեր ինչպես գործակիցների, այնպես էլ x-ի արժեքի համար՝ ապահովելով բազմապատիկի արժեքը որպես կրկնակի ճշգրտության լողացող կետով թիվ:\n\n  Արգումենտներ:\n  - x: Արժեքը, որի դեպքում բազմապատիկը գնահատվում է:\n  - a: x^3-ի գործակիցը:\n  - b: x^2-ի գործակիցը:\n  - c: x-ի գործակիցը:\n  - d: Բազմապատիկի հաստատուն անդամը:\n\n  Վերադարձնում է:\n  - Բազմապատիկի հաշվարկված արժեքը x-ում, որպես կրկնակի ճշգրտության լողացող կետով թիվ:\n\n  Օրինակ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) վերադարձնում է 33.0838692",
      "bn": "Rust ফাংশন `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া সেটের সহগ এবং x এর মানের জন্য বহুপদী f(x) = ax^3 + bx^2 + cx + d এর মান গণনা করে।\n  এই ফাংশনটি সহগ এবং x এর মান উভয়ের জন্য বাস্তব সংখ্যা ব্যবহার করে, বহুপদীর মানকে ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যার হিসাবে প্রদান করে।\n\n  আর্গুমেন্টসমূহ:\n  - x: যে মানে বহুপদীটি মূল্যায়ন করা হয়।\n  - a: x^3 এর সহগ।\n  - b: x^2 এর সহগ।\n  - c: x এর সহগ।\n  - d: বহুপদীর ধ্রুবক পদ।\n\n  রিটার্নস:\n  - x এ বহুপদীর গণনা করা মান, ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যার হিসাবে।\n\n  উদাহরণ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 প্রদান করে।",
      "bg": "Напишете функция на Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64`, за да решите следния проблем:\nИзчислява стойността на полинома f(x) = ax^3 + bx^2 + cx + d за даден набор от коефициенти и стойността на x.\n  Тази функция използва реални числа както за коефициентите, така и за стойността на x, предоставяйки стойността на полинома като число с двойна точност.\n\n  Аргументи:\n  - x: Стойността, при която се оценява полиномът.\n  - a: Коефициентът на x^3.\n  - b: Коефициентът на x^2.\n  - c: Коефициентът на x.\n  - d: Константният член в полинома.\n\n  Връща:\n  - Изчислената стойност на полинома при x, като число с двойна точност.\n\n  Пример:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) връща 33.0838692",
      "zh": "编写一个 Rust 函数 `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` 来解决以下问题：\n计算多项式 f(x) = ax^3 + bx^2 + cx + d 的值，给定一组系数和 x 的值。\n此函数使用实数作为系数和 x 的值，提供多项式的值作为双精度浮点数。\n\n参数：\n- x: 多项式被计算的值。\n- a: x^3 的系数。\n- b: x^2 的系数。\n- c: x 的系数。\n- d: 多项式中的常数项。\n\n返回：\n- 多项式在 x 处的计算值，作为双精度浮点数。\n\n示例：\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 返回 33.0838692",
      "fr": "Écrire une fonction Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` pour résoudre le problème suivant :  \nCalcule la valeur du polynôme f(x) = ax^3 + bx^2 + cx + d pour un ensemble donné de coefficients et la valeur de x.  \nCette fonction utilise des nombres réels pour les coefficients ainsi que pour la valeur de x, fournissant la valeur du polynôme sous forme de nombre à virgule flottante en double précision.\n\nArguments :  \n- x : La valeur à laquelle le polynôme est évalué.  \n- a : Le coefficient de x^3.  \n- b : Le coefficient de x^2.  \n- c : Le coefficient de x.  \n- d : Le terme constant dans le polynôme.\n\nRenvoie :  \n- La valeur calculée du polynôme en x, sous forme de nombre à virgule flottante en double précision.\n\nExemple :  \n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "de": "Schreiben Sie eine Rust-Funktion `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64`, um das folgende Problem zu lösen:\nBerechnet den Wert des Polynoms f(x) = ax^3 + bx^2 + cx + d für einen gegebenen Satz von Koeffizienten und den Wert von x.\n  Diese Funktion verwendet reelle Zahlen sowohl für die Koeffizienten als auch für den Wert von x und liefert den Wert des Polynoms als Gleitkommazahl mit doppelter Genauigkeit.\n\n  Argumente:\n  - x: Der Wert, bei dem das Polynom ausgewertet wird.\n  - a: Der Koeffizient von x^3.\n  - b: Der Koeffizient von x^2.\n  - c: Der Koeffizient von x.\n  - d: Der konstante Term im Polynom.\n\n  Rückgabewert:\n  - Der berechnete Wert des Polynoms bei x, als Gleitkommazahl mit doppelter Genauigkeit.\n\n  Beispiel:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) gibt 33.0838692 zurück",
      "ha": "Rubuta aikin Rust `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` don warware matsalar mai zuwa:\nLissafa darajar polynomial f(x) = ax^3 + bx^2 + cx + d don saitin coefficients da kuma darajar x.\n  Wannan aikin yana amfani da lambobi na gaske don duka coefficients da darajar x, yana bayar da darajar polynomial a matsayin lamba mai tsawon ninki biyu.\n\n  Huɗa:\n  - x: Darajar da za a auna polynomial.\n  - a: Coefficient na x^3.\n  - b: Coefficient na x^2.\n  - c: Coefficient na x.\n  - d: Kalmar da ba ta da canji a cikin polynomial.\n\n  Mayarwa:\n  - Darajar da aka lissafa na polynomial a x, a matsayin lamba mai tsawon ninki biyu.\n\n  Misali:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "hi": "Rust फ़ंक्शन `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए गुणांक और x के मान के लिए बहुपद f(x) = ax^3 + bx^2 + cx + d का मान गणना करता है। \n  यह फ़ंक्शन गुणांकों और x के मान दोनों के लिए वास्तविक संख्याओं का उपयोग करता है, जो बहुपद का मान डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में प्रदान करता है।\n\n  तर्क:\n  - x: वह मान जिस पर बहुपद का मूल्यांकन किया जाता है।\n  - a: x^3 का गुणांक।\n  - b: x^2 का गुणांक।\n  - c: x का गुणांक।\n  - d: बहुपद में स्थिरांक पद।\n\n  लौटाता है:\n  - x पर बहुपद का गणना किया गया मान, डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में।\n\n  उदाहरण:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 लौटाता है।",
      "hu": "Készíts egy Rust függvényt `fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64` a következő probléma megoldására:\nKiszámítja az f(x) = ax^3 + bx^2 + cx + d polinom értékét adott együtthatók és az x értéke alapján.\n  Ez a függvény valós számokat használ mind az együtthatók, mind az x értéke esetén, és a polinom értékét dupla pontosságú lebegőpontos számként adja vissza.\n\n  Argumentumok:\n  - x: Az érték, amelynél a polinomot kiértékeljük.\n  - a: Az x^3 együtthatója.\n  - b: Az x^2 együtthatója.\n  - c: Az x együtthatója.\n  - d: A polinom konstans tagja.\n\n  Visszatér:\n  - A polinom kiszámított értéke x-nél, dupla pontosságú lebegőpontos számként.\n\n  Példa:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) visszatér 33.0838692"
    },
    "instruction_bertscore": {
      "sq": "0.9689415577302418",
      "hy": "0.966824952389934",
      "bn": "0.9640339969060128",
      "bg": "0.9753289148931806",
      "zh": "0.961928514867043",
      "fr": "0.9825026497346367",
      "de": "0.9873101008468241",
      "ha": "0.9515623925415942",
      "hi": "0.9646439908061709",
      "hu": "0.972706199341996"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert!((polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) - 33.0838692).abs() < 1e-7);\n        assert!((polynomial_value(0.0, 1.0, 1.0, 1.0, 1.0) - 1.0).abs() < 1e-7);\n        assert!((polynomial_value(1.0, 1.0, 1.0, 1.0, 1.0) - 4.0).abs() < 1e-7);\n    }\n    \n\n}",
    "entry_point": "polynomial_value",
    "signature": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64",
    "docstring": {
      "en": "Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "sq": "Llogarit vlerën e polinomit f(x) = ax^3 + bx^2 + cx + d për një grup të dhënë koeficientësh dhe vlerën e x. Kjo funksion përdor numra realë si për koeficientët ashtu edhe për vlerën e x, duke ofruar vlerën e polinomit si një numër me presje të lëvizshme me precizion të dyfishtë.\n\nArguments:\n- x: Vlera në të cilën vlerësohet polinomi.\n- a: Koeficienti i x^3.\n- b: Koeficienti i x^2.\n- c: Koeficienti i x.\n- d: Termi konstant në polinom.\n\nReturns:\n- Vlera e llogaritur e polinomit në x, si një numër me presje të lëvizshme me precizion të dyfishtë.\n\nExample:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) kthen 33.0838692",
      "hy": "Հաշվում է բազմապատկի f(x) = ax^3 + bx^2 + cx + d արժեքը տրված գործակիցների և x-ի արժեքի համար։ \n  Այս ֆունկցիան օգտագործում է իրական թվեր ինչպես գործակիցների, այնպես էլ x-ի արժեքի համար՝ ապահովելով բազմապատկի արժեքը որպես կրկնակի ճշգրտության լողացող կետային թիվ։\n\n  Արգումենտներ:\n  - x: Արժեքը, որի համար բազմապատիկը գնահատվում է։\n  - a: x^3-ի գործակիցը։\n  - b: x^2-ի գործակիցը։\n  - c: x-ի գործակիցը։\n  - d: Բազմապատկի հաստատուն անդամը։\n\n  Վերադարձնում է:\n  - Բազմապատկի հաշվարկված արժեքը x-ում, որպես կրկնակի ճշգրտության լողացող կետային թիվ։\n\n  Օրինակ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) վերադարձնում է 33.0838692",
      "bn": "প্রদত্ত সেটের গুণাঙ্ক এবং x এর মানের জন্য বহুপদী f(x) = ax^3 + bx^2 + cx + d এর মান গণনা করে।\n  এই ফাংশনটি গুণাঙ্ক এবং x এর মান উভয়ের জন্য বাস্তব সংখ্যা ব্যবহার করে, পলিনোমিয়ালের মানকে ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যা হিসাবে প্রদান করে।\n\n  Arguments:\n  - x: যে মানে পলিনোমিয়ালটি মূল্যায়ন করা হয়।\n  - a: x^3 এর গুণাঙ্ক।\n  - b: x^2 এর গুণাঙ্ক।\n  - c: x এর গুণাঙ্ক।\n  - d: পলিনোমিয়ালের ধ্রুবক পদ।\n\n  Returns:\n  - x এ পলিনোমিয়ালের গণনা করা মান, ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যা হিসাবে।\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "bg": "Изчислява стойността на полинома f(x) = ax^3 + bx^2 + cx + d за даден набор от коефициенти и стойността на x. Тази функция използва реални числа както за коефициентите, така и за стойността на x, като предоставя стойността на полинома като число с двойна точност.\n\nАргументи:\n- x: Стойността, при която се оценява полиномът.\n- a: Коефициентът на x^3.\n- b: Коефициентът на x^2.\n- c: Коефициентът на x.\n- d: Константният член в полинома.\n\nВръща:\n- Изчислената стойност на полинома при x, като число с двойна точност.\n\nПример:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) връща 33.0838692",
      "zh": "计算多项式 f(x) = ax^3 + bx^2 + cx + d 的值，给定一组系数和 x 的值。\n此函数使用实数作为系数和 x 的值，提供多项式值作为双精度浮点数。\n\n参数：\n- x: 计算多项式的值所用的 x。\n- a: x^3 的系数。\n- b: x^2 的系数。\n- c: x 的系数。\n- d: 多项式中的常数项。\n\n返回：\n- 在 x 处计算的多项式值，作为双精度浮点数。\n\n示例：\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 返回 33.0838692",
      "fr": "Calcule la valeur du polynôme f(x) = ax^3 + bx^2 + cx + d pour un ensemble donné de coefficients et la valeur de x.\n  Cette fonction utilise des nombres réels pour les coefficients ainsi que pour la valeur de x, fournissant la valeur du polynôme en tant que nombre à virgule flottante en double précision.\n\n  Arguments:\n  - x: La valeur à laquelle le polynôme est évalué.\n  - a: Le coefficient de x^3.\n  - b: Le coefficient de x^2.\n  - c: Le coefficient de x.\n  - d: Le terme constant dans le polynôme.\n\n  Retourne:\n  - La valeur calculée du polynôme en x, en tant que nombre à virgule flottante en double précision.\n\n  Exemple:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) retourne 33.0838692",
      "de": "Berechnet den Wert des Polynoms f(x) = ax^3 + bx^2 + cx + d für einen gegebenen Satz von Koeffizienten und den Wert von x. Diese Funktion verwendet reelle Zahlen sowohl für die Koeffizienten als auch für den Wert von x und liefert den Wert des Polynoms als Gleitkommazahl mit doppelter Genauigkeit.\n\nArgumente:\n- x: Der Wert, bei dem das Polynom ausgewertet wird.\n- a: Der Koeffizient von x^3.\n- b: Der Koeffizient von x^2.\n- c: Der Koeffizient von x.\n- d: Der konstante Term im Polynom.\n\nRückgabewert:\n- Der berechnete Wert des Polynoms bei x, als Gleitkommazahl mit doppelter Genauigkeit.\n\nBeispiel:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) gibt 33.0838692 zurück.",
      "ha": "Lissafi darajar polinomial f(x) = ax^3 + bx^2 + cx + d don saitin abubuwan da aka bayar da kuma darajar x. Wannan aiki yana amfani da lambobi na gaske don duka abubuwan da ke cikin lissafin da kuma darajar x, yana bayar da darajar polynomial a matsayin lamba mai tsawon ninki biyu.\n\n  Arguments:\n  - x: Darajar da ake tantance polynomial a kai.\n  - a: Abun da ke tare da x^3.\n  - b: Abun da ke tare da x^2.\n  - c: Abun da ke tare da x.\n  - d: Abun da ke tsaye a cikin polynomial.\n\n  Returns:\n  - Darajar da aka lissafa na polynomial a x, a matsayin lamba mai tsawon ninki biyu.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "hi": "Polynomial f(x) = ax^3 + bx^2 + cx + d के मान की गणना दिए गए गुणांक और x के मान के लिए करता है। यह फ़ंक्शन गुणांक और x के मान दोनों के लिए वास्तविक संख्याओं का उपयोग करता है, और बहुपद के मान को डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में प्रदान करता है।\n\nArguments:\n- x: वह मान जिस पर बहुपद का मूल्यांकन किया जाता है।\n- a: x^3 का गुणांक।\n- b: x^2 का गुणांक।\n- c: x का गुणांक।\n- d: बहुपद में स्थिरांक पद।\n\nReturns:\n- x पर बहुपद का गणना किया गया मान, डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में।\n\nExample:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 लौटाता है।",
      "hu": "Kiszámítja az f(x) = ax^3 + bx^2 + cx + d polinom értékét adott együtthatók és az x értéke alapján.\n  Ez a függvény valós számokat használ mind az együtthatók, mind az x értékére, és a polinom értékét dupla pontosságú lebegőpontos számként adja meg.\n\n  Argumentumok:\n  - x: Az érték, amelynél a polinomot kiértékeljük.\n  - a: Az x^3 együtthatója.\n  - b: Az x^2 együtthatója.\n  - c: Az x együtthatója.\n  - d: A polinom konstans tagja.\n\n  Visszatérési érték:\n  - A polinom x-nél számított értéke, dupla pontosságú lebegőpontos számként.\n\n  Példa:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) visszaadja 33.0838692"
    },
    "docstring_bertscore": {
      "sq": "0.991317270153822",
      "hy": "0.9621984535548694",
      "bn": "0.9730317545365123",
      "bg": "0.9715271294001729",
      "zh": "0.9567790222387135",
      "fr": "0.9771724034595655",
      "de": "0.9809296957472214",
      "ha": "0.9640645859846921",
      "hi": "0.9324853348558605",
      "hu": "0.960590540620392"
    }
  },
  {
    "task_id": "Rust/19",
    "prompt": {
      "en": "/*\n  Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin minimal të kovave që një gjirafë ka nevojë të pijë për të shuar etjen e saj, duke pasur parasysh madhësinë e kovave.\n  \n  Një gjirafë ka nevojë të pijë 20 litra ujë për të shuar etjen e saj. Kjo funksion përcakton sa kova uji do t'i duheshin, bazuar në volumin e secilës kovë. Kovat janë në formë cilindrike, me lartësi dhe rreze të dhënë.\n\n  Argumentet:\n  - height: Lartësia e kovës në centimetra (numër i plotë).\n  - radius: Rrezja e bazës së kovës në centimetra (numër i plotë).\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin minimal të kovave të nevojshme që gjirafa të shuajë etjen e saj.\n\n  Shembull:\n  - min_buckets_needed(23, 11) kthen 3\n  - min_buckets_needed(30, 10) kthen 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32",
      "hy": "/*\n  Հաշվում է այն դույլերի նվազագույն քանակը, որոնք անհրաժեշտ են ընձուղտին, որպեսզի հագեցնի իր ծարավը, հաշվի առնելով դույլերի չափսերը։\n  \n  Ընձուղտին անհրաժեշտ է խմել 20 լիտր ջուր, որպեսզի հագեցնի իր ծարավը։ Այս ֆունկցիան որոշում է, թե քանի դույլ ջուր է անհրաժեշտ, հաշվի առնելով յուրաքանչյուր դույլի ծավալը։ Դույլերը գլանաձև են, տրված բարձրությամբ և շառավղով։\n\n  Փաստարկներ:\n  - height: Դույլի բարձրությունը սանտիմետրերով (ամբողջ թիվ)։\n  - radius: Դույլի հիմքի շառավիղը սանտիմետրերով (ամբողջ թիվ)։\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է այն դույլերի նվազագույն քանակը, որոնք անհրաժեշտ են ընձուղտին, որպեսզի հագեցնի իր ծարավը։\n\n  Օրինակ:\n  - min_buckets_needed(23, 11) վերադարձնում է 3\n  - min_buckets_needed(30, 10) վերադարձնում է 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "bn": "/*\n  একটি জিরাফের তৃষ্ণা মেটাতে কতগুলি বালতি প্রয়োজন তা গণনা করে, বালতির আকার দেওয়া হলে।\n\n  একটি জিরাফের তৃষ্ণা মেটাতে ২০ লিটার পানি পান করতে হয়। এই ফাংশনটি নির্ধারণ করে যে এটি কতগুলি বালতি পানির প্রয়োজন হবে, প্রতিটি বালতির আয়তনের উপর ভিত্তি করে। বালতিগুলি নলাকার আকৃতির, প্রদত্ত উচ্চতা এবং ব্যাসার্ধ সহ।\n\n  আর্গুমেন্ট:\n  - height: বালতির উচ্চতা সেন্টিমিটারে (পূর্ণসংখ্যা)।\n  - radius: বালতির ভিত্তির ব্যাসার্ধ সেন্টিমিটারে (পূর্ণসংখ্যা)।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা জিরাফের তৃষ্ণা মেটানোর জন্য প্রয়োজনীয় সর্বনিম্ন বালতির সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - min_buckets_needed(23, 11) 3 রিটার্ন করে\n  - min_buckets_needed(30, 10) 3 রিটার্ন করে\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "bg": "/*\n  Изчислява минималния брой кофи, които жирафът трябва да изпие, за да утоли жаждата си, предвид размера на кофите.\n  \n  Жирафът трябва да изпие 20 литра вода, за да утоли жаждата си. Тази функция определя колко кофи с вода ще му трябват, въз основа на обема на всяка кофа. Кофите са с цилиндрична форма, с дадена височина и радиус.\n\n  Аргументи:\n  - height: Височината на кофата в сантиметри (цяло число).\n  - radius: Радиусът на основата на кофата в сантиметри (цяло число).\n\n  Връща:\n  - Цяло число, представляващо минималния брой кофи, необходими на жирафа, за да утоли жаждата си.\n\n  Пример:\n  - min_buckets_needed(23, 11) връща 3\n  - min_buckets_needed(30, 10) връща 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "zh": "/*\n  计算长颈鹿需要喝多少桶水才能解渴，给定桶的大小。\n  \n  长颈鹿需要喝20升水才能解渴。此函数根据每个桶的体积来确定需要多少桶水。桶是圆柱形的，具有给定的高度和半径。\n\n  参数:\n  - height: 桶的高度，单位为厘米（整数）。\n  - radius: 桶底的半径，单位为厘米（整数）。\n\n  返回:\n  - 一个整数，表示长颈鹿解渴所需的最少桶数。\n\n  示例:\n  - min_buckets_needed(23, 11) 返回 3\n  - min_buckets_needed(30, 10) 返回 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre minimum de seaux dont une girafe a besoin pour étancher sa soif, étant donné la taille des seaux.\n  \n  Une girafe a besoin de boire 20 litres d'eau pour étancher sa soif. Cette fonction détermine combien de seaux d'eau elle aurait besoin, en fonction du volume de chaque seau. Les seaux sont de forme cylindrique, avec une hauteur et un rayon donnés.\n\n  Arguments :\n  - height : La hauteur du seau en centimètres (entier).\n  - radius : Le rayon de la base du seau en centimètres (entier).\n\n  Renvoie :\n  - Un entier représentant le nombre minimum de seaux nécessaires pour que la girafe étanche sa soif.\n\n  Exemple :\n  - min_buckets_needed(23, 11) renvoie 3\n  - min_buckets_needed(30, 10) renvoie 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "de": "/*\n  Berechnet die minimale Anzahl von Eimern, die eine Giraffe benötigt, um ihren Durst zu stillen, basierend auf der Größe der Eimer.\n  \n  Eine Giraffe muss 20 Liter Wasser trinken, um ihren Durst zu stillen. Diese Funktion bestimmt, wie viele Eimer Wasser sie benötigt, basierend auf dem Volumen jedes Eimers. Die Eimer sind zylindrisch geformt, mit gegebener Höhe und Radius.\n\n  Argumente:\n  - height: Die Höhe des Eimers in Zentimetern (Ganzzahl).\n  - radius: Der Radius der Basis des Eimers in Zentimetern (Ganzzahl).\n\n  Rückgabewert:\n  - Eine Ganzzahl, die die minimale Anzahl von Eimern darstellt, die benötigt werden, damit die Giraffe ihren Durst stillen kann.\n\n  Beispiel:\n  - min_buckets_needed(23, 11) gibt 3 zurück\n  - min_buckets_needed(30, 10) gibt 3 zurück\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "ha": "/*\n  Lissafin adadin guga mafi ƙaranci da giwa ke buƙata don shan ruwa don kashe ƙishirwa, la'akari da girman gugan.\n\n  Giwa na buƙatar shan lita 20 na ruwa don kashe ƙishirwa. Wannan aikin yana tantancewa nawa ne guga na ruwa da za ta buƙata, bisa ga ƙarar kowanne guga. Gugunan suna da siffar silinda, tare da tsawo da kuma radius da aka bayar.\n\n  Huɗɗa:\n  - height: Tsawon gugan a cikin santimita (adadi mai lamba).\n  - radius: Radius na tushe na guga a cikin santimita (adadi mai lamba).\n\n  Komawa:\n  - Adadi mai lamba da ke wakiltar adadin guga mafi ƙaranci da ake buƙata don giwa ta kashe ƙishirwa.\n\n  Misali:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "hi": "/*\n  यह गणना करता है कि जिराफ को अपनी प्यास बुझाने के लिए न्यूनतम कितने बाल्टियों की आवश्यकता है, बाल्टियों के आकार को ध्यान में रखते हुए।\n\n  एक जिराफ को अपनी प्यास बुझाने के लिए 20 लीटर पानी पीने की आवश्यकता होती है। यह फ़ंक्शन यह निर्धारित करता है कि उसे कितनी बाल्टियों की आवश्यकता होगी, बाल्टियों की मात्रा के आधार पर। बाल्टियाँ बेलनाकार आकार की होती हैं, जिनकी ऊँचाई और त्रिज्या दी गई होती है।\n\n  तर्क:\n  - height: बाल्टी की ऊँचाई सेंटीमीटर में (पूर्णांक)।\n  - radius: बाल्टी के आधार की त्रिज्या सेंटीमीटर में (पूर्णांक)।\n\n  लौटाता है:\n  - एक पूर्णांक जो दर्शाता है कि जिराफ को अपनी प्यास बुझाने के लिए न्यूनतम कितनी बाल्टियों की आवश्यकता है।\n\n  उदाहरण:\n  - min_buckets_needed(23, 11) 3 लौटाता है\n  - min_buckets_needed(30, 10) 3 लौटाता है\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32",
      "hu": "/*\n  Kiszámítja a minimum vödrök számát, amelyre egy zsiráfnak szüksége van, hogy oltsa a szomját, adott vödörméret esetén.\n  \n  Egy zsiráfnak 20 liter vizet kell innia, hogy oltsa a szomját. Ez a függvény meghatározza, hány vödör vízre lenne szüksége, a vödör térfogata alapján. A vödrök henger alakúak, adott magassággal és sugárral.\n\n  Argumentumok:\n  - height: A vödör magassága centiméterben (egész szám).\n  - radius: A vödör alapjának sugara centiméterben (egész szám).\n\n  Visszatér:\n  - Egy egész szám, amely a minimum vödrök számát jelenti, amelyre a zsiráfnak szüksége van, hogy oltsa a szomját.\n\n  Példa:\n  - min_buckets_needed(23, 11) visszaadja 3\n  - min_buckets_needed(30, 10) visszaadja 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9926715320917178",
      "hy": "0.96938648978376",
      "bn": "0.9783268432341402",
      "bg": "0.9899943918161296",
      "zh": "0.9669095689322549",
      "fr": "0.9918106680203126",
      "de": "0.9846146865761807",
      "ha": "0.9462893518162611",
      "hi": "0.9705397377760485",
      "hu": "0.9752818394928754"
    },
    "canonical_solution": "{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}",
    "instruction": {
      "en": "Write a Rust function `fn min_buckets_needed(height: i32, radius: i32) -> i32` to solve the following problem:\nCalculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3",
      "sq": "Shkruani një funksion Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin minimal të kovave që një gjirafë ka nevojë për të pirë për të shuar etjen, duke pasur parasysh madhësinë e kovave.\n\nNjë gjirafë ka nevojë të pijë 20 litra ujë për të shuar etjen e saj. Ky funksion përcakton sa kova uji do të nevojiten, bazuar në vëllimin e secilës kovë. Kovat janë në formë cilindrike, me lartësi dhe rreze të dhënë.\n\nArgumentet:\n- height: Lartësia e kovës në centimetra (numër i plotë).\n- radius: Rrezja e bazës së kovës në centimetra (numër i plotë).\n\nKthen:\n- Një numër i plotë që përfaqëson numrin minimal të kovave të nevojshme që gjirafa të shuajë etjen e saj.\n\nShembull:\n- min_buckets_needed(23, 11) kthen 3\n- min_buckets_needed(30, 10) kthen 3",
      "hy": "Գրեք Rust ֆունկցիա `fn min_buckets_needed(height: i32, radius: i32) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն նվազագույն դույլերի քանակը, որոնք անհրաժեշտ են ընձուղտին իր ծարավը հագեցնելու համար, հաշվի առնելով դույլերի չափը։\n\n  Ընձուղտին անհրաժեշտ է խմել 20 լիտր ջուր իր ծարավը հագեցնելու համար։ Այս ֆունկցիան որոշում է, թե քանի դույլ ջուր է անհրաժեշտ, հիմնվելով յուրաքանչյուր դույլի ծավալի վրա։ Դույլերը ունեն գլանաձև ձև, տրված բարձրությամբ և շառավղով։\n\n  Արգումենտներ:\n  - height: Դույլի բարձրությունը սանտիմետրերով (ամբողջ թիվ)։\n  - radius: Դույլի հիմքի շառավիղը սանտիմետրերով (ամբողջ թիվ)։\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է նվազագույն դույլերի քանակը, որոնք անհրաժեշտ են ընձուղտի ծարավը հագեցնելու համար։\n\n  Օրինակ:\n  - min_buckets_needed(23, 11) վերադարձնում է 3\n  - min_buckets_needed(30, 10) վերադարձնում է 3",
      "bn": "Rust ফাংশন `fn min_buckets_needed(height: i32, radius: i32) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবালতির আকার দেওয়া হলে, একটি জিরাফের তৃষ্ণা মেটাতে প্রয়োজনীয় সর্বনিম্ন বালতির সংখ্যা গণনা করে।\n\nএকটি জিরাফের তৃষ্ণা মেটাতে 20 লিটার পানি পান করতে হয়। এই ফাংশনটি নির্ধারণ করে যে, প্রতিটি বালতির আয়তনের ভিত্তিতে কতগুলি বালতি পানি প্রয়োজন হবে। বালতিগুলি নলাকার আকারের, প্রদত্ত উচ্চতা এবং ব্যাসার্ধ সহ।\n\nআর্গুমেন্টসমূহ:\n- height: বালতির উচ্চতা সেন্টিমিটারে (পূর্ণসংখ্যা)।\n- radius: বালতির ভিত্তির ব্যাসার্ধ সেন্টিমিটারে (পূর্ণসংখ্যা)।\n\nফেরত দেয়:\n- একটি পূর্ণসংখ্যা যা জিরাফের তৃষ্ণা মেটাতে প্রয়োজনীয় সর্বনিম্ন বালতির সংখ্যা নির্দেশ করে।\n\nউদাহরণ:\n- min_buckets_needed(23, 11) ফেরত দেয় 3\n- min_buckets_needed(30, 10) ফেরত দেয় 3",
      "bg": "Напишете функция на Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32`, за да решите следния проблем:\nИзчислява минималния брой кофи, които жирафът трябва да изпие, за да утоли жаждата си, като се има предвид размерът на кофите.\n\nЖирафът трябва да изпие 20 литра вода, за да утоли жаждата си. Тази функция определя колко кофи вода ще му трябват, въз основа на обема на всяка кофа. Кофите са с цилиндрична форма, с дадена височина и радиус.\n\nАргументи:\n- height: Височината на кофата в сантиметри (цяло число).\n- radius: Радиусът на основата на кофата в сантиметри (цяло число).\n\nВръща:\n- Цяло число, представляващо минималния брой кофи, необходими на жирафа, за да утоли жаждата си.\n\nПример:\n- min_buckets_needed(23, 11) връща 3\n- min_buckets_needed(30, 10) връща 3",
      "zh": "编写一个 Rust 函数 `fn min_buckets_needed(height: i32, radius: i32) -> i32` 来解决以下问题：\n计算长颈鹿需要喝多少桶水才能解渴，给定桶的大小。\n\n长颈鹿需要喝 20 升水才能解渴。此函数根据每个桶的体积来确定需要多少桶水。桶是圆柱形的，给定高度和半径。\n\n参数：\n- height: 桶的高度，单位为厘米（整数）。\n- radius: 桶底的半径，单位为厘米（整数）。\n\n返回：\n- 一个整数，表示长颈鹿解渴所需的最少桶数。\n\n示例：\n- min_buckets_needed(23, 11) 返回 3\n- min_buckets_needed(30, 10) 返回 3",
      "fr": "Écrire une fonction Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` pour résoudre le problème suivant :\nCalcule le nombre minimum de seaux dont une girafe a besoin pour étancher sa soif, étant donné la taille des seaux.\n  \n  Une girafe a besoin de boire 20 litres d'eau pour étancher sa soif. Cette fonction détermine combien de seaux d'eau elle aurait besoin, en fonction du volume de chaque seau. Les seaux sont de forme cylindrique, avec une hauteur et un rayon donnés.\n\n  Arguments :\n  - height : La hauteur du seau en centimètres (entier).\n  - radius : Le rayon de la base du seau en centimètres (entier).\n\n  Renvoie :\n  - Un entier représentant le nombre minimum de seaux nécessaires pour que la girafe étanche sa soif.\n\n  Exemple :\n  - min_buckets_needed(23, 11) renvoie 3\n  - min_buckets_needed(30, 10) renvoie 3",
      "de": "Schreiben Sie eine Rust-Funktion `fn min_buckets_needed(height: i32, radius: i32) -> i32`, um das folgende Problem zu lösen:\nBerechnet die minimale Anzahl von Eimern, die eine Giraffe benötigt, um ihren Durst zu stillen, basierend auf der Größe der Eimer.\n\nEine Giraffe muss 20 Liter Wasser trinken, um ihren Durst zu stillen. Diese Funktion bestimmt, wie viele Eimer Wasser sie benötigt, basierend auf dem Volumen jedes Eimers. Die Eimer sind zylindrisch geformt, mit gegebener Höhe und gegebenem Radius.\n\nArgumente:\n- height: Die Höhe des Eimers in Zentimetern (Ganzzahl).\n- radius: Der Radius der Eimerbasis in Zentimetern (Ganzzahl).\n\nRückgabewert:\n- Eine Ganzzahl, die die minimale Anzahl von Eimern darstellt, die benötigt werden, damit die Giraffe ihren Durst stillen kann.\n\nBeispiel:\n- min_buckets_needed(23, 11) gibt 3 zurück\n- min_buckets_needed(30, 10) gibt 3 zurück",
      "ha": "Rubuta aikin Rust `fn min_buckets_needed(height: i32, radius: i32) -> i32` don warware matsalar mai zuwa:\nYana ƙididdige mafi ƙarancin adadin guga da giwa ke buƙata don shan ruwa don kashe ƙishirwa, la'akari da girman gugan.\n\n  Giwa na buƙatar shan lita 20 na ruwa don kashe ƙishirwa. Wannan aikin yana tantancewa nawa guga na ruwa zai buƙata, bisa ga girman kowanne guga. Gugunan suna da siffar silinda, tare da tsawo da aka bayar da kuma radius.\n\n  Huɗɗa:\n  - height: Tsawon gugan a cikin santimita (cikakken lamba).\n  - radius: Radius na tushen gugan a cikin santimita (cikakken lamba).\n\n  Dawowa:\n  - Cikakken lamba da ke wakiltar mafi ƙarancin adadin guga da ake buƙata don giwa ta kashe ƙishirwa.\n\n  Misali:\n  - min_buckets_needed(23, 11) yana dawowa 3\n  - min_buckets_needed(30, 10) yana dawowa 3",
      "hi": "Rust फ़ंक्शन `fn min_buckets_needed(height: i32, radius: i32) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह जिराफ़ को अपनी प्यास बुझाने के लिए आवश्यक बाल्टियों की न्यूनतम संख्या की गणना करता है, बाल्टियों के आकार को ध्यान में रखते हुए।\n\nएक जिराफ़ को अपनी प्यास बुझाने के लिए 20 लीटर पानी पीने की आवश्यकता होती है। यह फ़ंक्शन यह निर्धारित करता है कि प्रत्येक बाल्टी की मात्रा के आधार पर उसे कितनी बाल्टियों की आवश्यकता होगी। बाल्टियाँ बेलनाकार आकार की होती हैं, जिनकी ऊँचाई और त्रिज्या दी गई है।\n\nआर्गुमेंट्स:\n- height: बाल्टी की ऊँचाई सेंटीमीटर में (पूर्णांक)।\n- radius: बाल्टी के आधार की त्रिज्या सेंटीमीटर में (पूर्णांक)।\n\nरिटर्न्स:\n- एक पूर्णांक जो जिराफ़ की प्यास बुझाने के लिए आवश्यक बाल्टियों की न्यूनतम संख्या का प्रतिनिधित्व करता है।\n\nउदाहरण:\n- min_buckets_needed(23, 11) returns 3\n- min_buckets_needed(30, 10) returns 3",
      "hu": "Írj egy Rust függvényt `fn min_buckets_needed(height: i32, radius: i32) -> i32` a következő probléma megoldására:\nKiszámítja a minimum számú vödröt, amire egy zsiráfnak szüksége van, hogy oltsa a szomját, figyelembe véve a vödrök méretét.\n\nEgy zsiráfnak 20 liter vizet kell innia, hogy oltsa a szomját. Ez a függvény meghatározza, hány vödör vízre lenne szüksége, a vödrök térfogata alapján. A vödrök henger alakúak, adott magassággal és sugárral.\n\nArgumentumok:\n- height: A vödör magassága centiméterben (egész szám).\n- radius: A vödör alapjának sugara centiméterben (egész szám).\n\nVisszatérési érték:\n- Egy egész szám, amely a minimum vödrök számát jelenti, amire a zsiráfnak szüksége van, hogy oltsa a szomját.\n\nPélda:\n- min_buckets_needed(23, 11) visszaadja 3\n- min_buckets_needed(30, 10) visszaadja 3"
    },
    "instruction_bertscore": {
      "sq": "0.986905093499894",
      "hy": "0.9781697266027416",
      "bn": "0.9657638688944457",
      "bg": "0.984309590310911",
      "zh": "0.9645901619729105",
      "fr": "0.9910965918004921",
      "de": "0.9831088696575552",
      "ha": "0.9589613742351438",
      "hi": "0.9629063722328778",
      "hu": "0.9767666015911112"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(min_buckets_needed(23, 11), 3);\n        assert_eq!(min_buckets_needed(30, 10), 3);\n        assert_eq!(min_buckets_needed(50, 5), 6);\n        assert_eq!(min_buckets_needed(40, 8), 3);    \n    }\n    \n\n}",
    "entry_point": "min_buckets_needed",
    "signature": "fn min_buckets_needed(height: i32, radius: i32) -> i32",
    "docstring": {
      "en": "Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3",
      "sq": "Llogarit numrin minimal të kovave që një gjirafë ka nevojë për të pirë për të shuar etjen e saj, duke pasur parasysh madhësinë e kovave.\n\nNjë gjirafë ka nevojë të pijë 20 litra ujë për të shuar etjen e saj. Kjo funksion përcakton sa kova uji do të nevojiten, bazuar në volumin e secilës kovë. Kovat janë në formë cilindrike, me lartësi dhe rreze të dhënë.\n\nArgumentet:\n- height: Lartësia e kovës në centimetra (numër i plotë).\n- radius: Rrezja e bazës së kovës në centimetra (numër i plotë).\n\nKthen:\n- Një numër i plotë që përfaqëson numrin minimal të kovave të nevojshme që gjirafa të shuajë etjen e saj.\n\nShembull:\n- min_buckets_needed(23, 11) kthen 3\n- min_buckets_needed(30, 10) kthen 3",
      "hy": "Հաշվում է, թե նվազագույն քանի դույլ է պետք ընձուղտին խմելու իր ծարավը հագեցնելու համար՝ հաշվի առնելով դույլերի չափը։\n\nԸնձուղտին պետք է խմել 20 լիտր ջուր իր ծարավը հագեցնելու համար։ Այս ֆունկցիան որոշում է, թե քանի դույլ ջուր է անհրաժեշտ՝ հիմնվելով յուրաքանչյուր դույլի ծավալի վրա։ Դույլերը գլանաձև են՝ տրված բարձրությամբ և շառավղով։\n\nԱրգումենտներ:\n- height: Դույլի բարձրությունը սանտիմետրերով (ամբողջ թիվ)։\n- radius: Դույլի հիմքի շառավիղը սանտիմետրերով (ամբողջ թիվ)։\n\nՎերադարձնում է:\n- Ամբողջ թիվ, որը ներկայացնում է նվազագույն դույլերի քանակը, որոնք անհրաժեշտ են ընձուղտի ծարավը հագեցնելու համար։\n\nՕրինակ:\n- min_buckets_needed(23, 11) վերադարձնում է 3\n- min_buckets_needed(30, 10) վերադարձնում է 3",
      "bn": "জিরাফের তৃষ্ণা মেটাতে ন্যূনতম কতগুলো বালতি প্রয়োজন তা গণনা করে, বালতির আকার দেওয়া হলে।\n\nএকটি জিরাফের তৃষ্ণা মেটাতে ২০ লিটার পানি পান করতে হয়। এই ফাংশনটি নির্ধারণ করে যে, প্রতিটি বালতির আয়তনের উপর ভিত্তি করে, কতগুলো বালতি পানির প্রয়োজন হবে। বালতিগুলি নলাকার আকারের, প্রদত্ত উচ্চতা এবং ব্যাসার্ধ সহ।\n\nআর্গুমেন্টসমূহ:\n- height: বালতির উচ্চতা সেন্টিমিটারে (পূর্ণসংখ্যা)।\n- radius: বালতির ভিত্তির ব্যাসার্ধ সেন্টিমিটারে (পূর্ণসংখ্যা)।\n\nফেরত দেয়:\n- একটি পূর্ণসংখ্যা যা জিরাফের তৃষ্ণা মেটাতে প্রয়োজনীয় ন্যূনতম বালতির সংখ্যা উপস্থাপন করে।\n\nউদাহরণ:\n- min_buckets_needed(23, 11) 3 ফেরত দেয়\n- min_buckets_needed(30, 10) 3 ফেরত দেয়",
      "bg": "Изчислява минималния брой кофи, от които жирафът се нуждае, за да утоли жаждата си, като се има предвид размерът на кофите.\n\nЖирафът трябва да изпие 20 литра вода, за да утоли жаждата си. Тази функция определя колко кофи с вода ще са му необходими, въз основа на обема на всяка кофа. Кофите са с цилиндрична форма, с дадена височина и радиус.\n\nАргументи:\n- height: Височината на кофата в сантиметри (цяло число).\n- radius: Радиусът на основата на кофата в сантиметри (цяло число).\n\nВръща:\n- Цяло число, представляващо минималния брой кофи, необходими на жирафа, за да утоли жаждата си.\n\nПример:\n- min_buckets_needed(23, 11) връща 3\n- min_buckets_needed(30, 10) връща 3",
      "zh": "计算长颈鹿需要喝多少桶水才能解渴，给定桶的大小。\n\n长颈鹿需要喝20升水才能解渴。此函数根据每个桶的体积来确定需要多少桶水。桶是圆柱形的，给定高度和半径。\n\n参数:\n- height: 桶的高度，以厘米为单位（整数）。\n- radius: 桶底的半径，以厘米为单位（整数）。\n\n返回:\n- 一个整数，表示长颈鹿解渴所需的最少桶数。\n\n示例:\n- min_buckets_needed(23, 11) 返回 3\n- min_buckets_needed(30, 10) 返回 3",
      "fr": "Calcule le nombre minimum de seaux dont une girafe a besoin pour boire afin d'étancher sa soif, étant donné la taille des seaux.\n\nUne girafe a besoin de boire 20 litres d'eau pour étancher sa soif. Cette fonction détermine combien de seaux d'eau elle aurait besoin, en fonction du volume de chaque seau. Les seaux sont de forme cylindrique, avec une hauteur et un rayon donnés.\n\nArguments:\n- height: La hauteur du seau en centimètres (entier).\n- radius: Le rayon de la base du seau en centimètres (entier).\n\nRenvoie:\n- Un entier représentant le nombre minimum de seaux nécessaires pour que la girafe étanche sa soif.\n\nExemple:\n- min_buckets_needed(23, 11) renvoie 3\n- min_buckets_needed(30, 10) renvoie 3",
      "de": "Berechnet die minimale Anzahl an Eimern, die eine Giraffe benötigt, um ihren Durst zu stillen, basierend auf der Größe der Eimer.\n\nEine Giraffe muss 20 Liter Wasser trinken, um ihren Durst zu stillen. Diese Funktion bestimmt, wie viele Eimer Wasser sie benötigt, basierend auf dem Volumen jedes Eimers. Die Eimer sind zylindrisch geformt, mit gegebener Höhe und Radius.\n\nArgumente:\n- height: Die Höhe des Eimers in Zentimetern (Ganzzahl).\n- radius: Der Radius der Eimerbasis in Zentimetern (Ganzzahl).\n\nRückgabewert:\n- Eine Ganzzahl, die die minimale Anzahl an Eimern darstellt, die benötigt werden, damit die Giraffe ihren Durst stillen kann.\n\nBeispiel:\n- min_buckets_needed(23, 11) gibt 3 zurück\n- min_buckets_needed(30, 10) gibt 3 zurück",
      "ha": "Lissafin adadin guga mafi ƙaranci da giwa ke buƙata don shan ruwa don kashe ƙishirwa, la'akari da girman gugan.\n\nGiraffe na bukatar shan lita 20 na ruwa don kashe kishirwa. Wannan aikin yana tantancewa nawa ne kwandunan ruwa da zai bukata, bisa la'akari da girman kowanne kwando. Kwandunan suna da siffar silinda, tare da tsawo da kuma radius da aka bayar.\n\nArguments:\n- height: Tsawon kwandon a cikin santimita (integer).\n- radius: Radius na tushe na kwandon a cikin santimita (integer).\n\nReturns:\n- Wani integer da ke wakiltar mafi karancin adadin kwanduna da ake bukata don giraffe ya kashe kishirwa.\n\nExample:\n- min_buckets_needed(23, 11) returns 3\n- min_buckets_needed(30, 10) returns 3",
      "hi": "गिरगिट को अपनी प्यास बुझाने के लिए आवश्यक न्यूनतम बाल्टियों की संख्या की गणना करता है, बाल्टियों के आकार को ध्यान में रखते हुए।\n\n  एक गिरगिट को अपनी प्यास बुझाने के लिए 20 लीटर पानी पीने की आवश्यकता होती है। यह फ़ंक्शन निर्धारित करता है कि उसे कितनी बाल्टियों की आवश्यकता होगी, प्रत्येक बाल्टी की मात्रा के आधार पर। बाल्टियाँ बेलनाकार आकार की होती हैं, जिनकी ऊँचाई और त्रिज्या दी गई होती है।\n\n  तर्क:\n  - height: बाल्टी की ऊँचाई सेंटीमीटर में (पूर्णांक)।\n  - radius: बाल्टी के आधार की त्रिज्या सेंटीमीटर में (पूर्णांक)।\n\n  वापसी:\n  - एक पूर्णांक जो गिरगिट की प्यास बुझाने के लिए आवश्यक न्यूनतम बाल्टियों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - min_buckets_needed(23, 11) 3 लौटाता है\n  - min_buckets_needed(30, 10) 3 लौटाता है",
      "hu": "Számítja ki a minimum vödrök számát, amelyre egy zsiráfnak szüksége van, hogy oltsa a szomját, adott a vödrök mérete.\n\nEgy zsiráfnak 20 liter vizet kell innia, hogy oltsa a szomját. Ez a függvény meghatározza, hány vödör vízre lenne szüksége, a vödrök térfogata alapján. A vödrök henger alakúak, adott magassággal és sugárral.\n\nArgumentumok:\n- height: A vödör magassága centiméterben (egész szám).\n- radius: A vödör alapjának sugara centiméterben (egész szám).\n\nVisszatér:\n- Egy egész szám, amely a szükséges minimum vödrök számát jelenti, hogy a zsiráf oltsa a szomját.\n\nPélda:\n- min_buckets_needed(23, 11) visszaadja 3\n- min_buckets_needed(30, 10) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9862456406348581",
      "hy": "0.9677736110897567",
      "bn": "0.9649326007498147",
      "bg": "0.9848184813471225",
      "zh": "0.9539652242609733",
      "fr": "0.9906371597291584",
      "de": "0.982123067076479",
      "ha": "0.9796383996401136",
      "hi": "0.9397111108571476",
      "hu": "0.9864685039223793"
    }
  },
  {
    "task_id": "Rust/20",
    "prompt": {
      "en": "/*\n  Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "sq": "/*\n  Llogarit sipërfaqen e një trekëndëshi duke dhënë koordinatat e kulmeve të tij.\n\n  Argumentet:\n  - x1, y1: Koordinatat x dhe y të kulmit të parë.\n  - x2, y2: Koordinatat x dhe y të kulmit të dytë.\n  - x3, y3: Koordinatat x dhe y të kulmit të tretë.\n\n  Kthen:\n  - Sipërfaqja e trekëndëshit, e rrumbullakosur në dy vende dhjetore.\n\n  Shembuj:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) kthen 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "hy": "/*\n  Հաշվում է եռանկյան մակերեսը՝ տրված նրա գագաթների կոորդինատները։\n\n  Արգումենտներ:\n  - x1, y1: Առաջին գագաթի x և y կոորդինատները։\n  - x2, y2: Երկրորդ գագաթի x և y կոորդինատները։\n  - x3, y3: Երրորդ գագաթի x և y կոորդինատները։\n\n  Վերադարձնում է:\n  - Եռանկյան մակերեսը՝ կլորացված մինչև երկու տասնորդական։\n\n  Օրինակներ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) վերադարձնում է 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "bn": "/*\n  প্রদত্ত বিন্দুগুলির স্থানাঙ্ক অনুযায়ী একটি ত্রিভুজের ক্ষেত্রফল গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - x1, y1: প্রথম বিন্দুর x এবং y স্থানাঙ্ক।\n  - x2, y2: দ্বিতীয় বিন্দুর x এবং y স্থানাঙ্ক।\n  - x3, y3: তৃতীয় বিন্দুর x এবং y স্থানাঙ্ক।\n\n  রিটার্ন করে:\n  - ত্রিভুজের ক্ষেত্রফল, দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\n  উদাহরণসমূহ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 রিটার্ন করে\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "bg": "/*\n  Изчислява площта на триъгълник, дадени координатите на неговите върхове.\n\n  Аргументи:\n  - x1, y1: x и y координатите на първия връх.\n  - x2, y2: x и y координатите на втория връх.\n  - x3, y3: x и y координатите на третия връх.\n\n  Връща:\n  - Площта на триъгълника, закръглена до два знака след десетичната запетая.\n\n  Примери:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) връща 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "zh": "/*\n  计算给定顶点坐标的三角形面积。\n\n  参数:\n  - x1, y1: 第一个顶点的 x 和 y 坐标。\n  - x2, y2: 第二个顶点的 x 和 y 坐标。\n  - x3, y3: 第三个顶点的 x 和 y 坐标。\n\n  返回:\n  - 三角形的面积，四舍五入到小数点后两位。\n\n  示例:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 返回 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "fr": "/*\n  Calcule la surface d'un triangle étant donné les coordonnées de ses sommets.\n\n  Arguments :\n  - x1, y1 : Les coordonnées x et y du premier sommet.\n  - x2, y2 : Les coordonnées x et y du deuxième sommet.\n  - x3, y3 : Les coordonnées x et y du troisième sommet.\n\n  Renvoie :\n  - La surface du triangle, arrondie à deux décimales.\n\n  Exemples :\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) renvoie 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "de": "/*\n  Berechnet die Fläche eines Dreiecks anhand der Koordinaten seiner Eckpunkte.\n\n  Argumente:\n  - x1, y1: Die x- und y-Koordinaten des ersten Eckpunkts.\n  - x2, y2: Die x- und y-Koordinaten des zweiten Eckpunkts.\n  - x3, y3: Die x- und y-Koordinaten des dritten Eckpunkts.\n\n  Rückgabewert:\n  - Die Fläche des Dreiecks, gerundet auf zwei Dezimalstellen.\n\n  Beispiele:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) gibt 6.00 zurück\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "ha": "/*\n  Lissafin yankin wani kusurwar kusurwa idan aka ba da daidaitattun wuraren kololuwanta.\n\n  Huɗɗa:\n  - x1, y1: Daidaitattun x da y na kololuwa na farko.\n  - x2, y2: Daidaitattun x da y na kololuwa na biyu.\n  - x3, y3: Daidaitattun x da y na kololuwa na uku.\n\n  Komawa:\n  - Yankin kusurwar, an zagaye zuwa wurare biyu na adadi mai lamba.\n\n  Misalai:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) yana dawowa 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "hi": "/*\n  दिए गए शीर्षों के निर्देशांक के आधार पर त्रिभुज का क्षेत्रफल गणना करता है।\n\n  तर्क:\n  - x1, y1: पहले शीर्ष के x और y निर्देशांक।\n  - x2, y2: दूसरे शीर्ष के x और y निर्देशांक।\n  - x3, y3: तीसरे शीर्ष के x और y निर्देशांक।\n\n  रिटर्न करता है:\n  - त्रिभुज का क्षेत्रफल, दो दशमलव स्थानों तक पूर्णांकित।\n\n  उदाहरण:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 लौटाता है\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "hu": "/*\n  Kiszámítja egy háromszög területét a csúcsainak koordinátái alapján.\n\n  Argumentumok:\n  - x1, y1: Az első csúcs x és y koordinátái.\n  - x2, y2: A második csúcs x és y koordinátái.\n  - x3, y3: A harmadik csúcs x és y koordinátái.\n\n  Visszatér:\n  - A háromszög területe, két tizedesjegyre kerekítve.\n\n  Példák:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) visszaadja 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 "
    },
    "prompt_bertscore": {
      "sq": "0.9981640593880945",
      "hy": "0.99560470692846",
      "bn": "0.9549937323739719",
      "bg": "0.9811682508348443",
      "zh": "0.9897854326552809",
      "fr": "0.9981640593880945",
      "de": "0.9870894224934943",
      "ha": "0.9899951863376537",
      "hi": "0.9810661548189924",
      "hu": "0.9935087591477798"
    },
    "canonical_solution": "{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}",
    "instruction": {
      "en": "Write a Rust function `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` to solve the following problem:\nCalculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "sq": "Shkruani një funksion Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` për të zgjidhur problemin e mëposhtëm:\nLlogarit sipërfaqen e një trekëndëshi duke dhënë koordinatat e kulmeve të tij.\n\n  Argumentet:\n  - x1, y1: Koordinatat x dhe y të kulmit të parë.\n  - x2, y2: Koordinatat x dhe y të kulmit të dytë.\n  - x3, y3: Koordinatat x dhe y të kulmit të tretë.\n\n  Kthen:\n  - Sipërfaqja e trekëndëshit, e rrumbullakosur në dy vende dhjetore.\n\n  Shembuj:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) kthen 6.00",
      "hy": "Գրեք Rust ֆունկցիա `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է եռանկյան մակերեսը, տրված նրա գագաթների կոորդինատները։\n\n  Արգումենտներ:\n  - x1, y1: Առաջին գագաթի x և y կոորդինատները։\n  - x2, y2: Երկրորդ գագաթի x և y կոորդինատները։\n  - x3, y3: Երրորդ գագաթի x և y կոորդինատները։\n\n  Վերադարձնում է:\n  - Եռանկյան մակերեսը, կլորացված մինչև երկու տասնորդական թվանշան։\n\n  Օրինակներ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) վերադարձնում է 6.00",
      "bn": "Rust ফাংশন `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর শীর্ষবিন্দুগুলির স্থানাঙ্ক দেওয়া হলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - x1, y1: প্রথম শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x2, y2: দ্বিতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x3, y3: তৃতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n\n  রিটার্নস:\n  - ত্রিভুজের ক্ষেত্রফল, দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\n  উদাহরণসমূহ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 রিটার্ন করে।",
      "bg": "Напишете функция на Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32`, за да решите следния проблем:\nИзчислява площта на триъгълник, като се дават координатите на неговите върхове.\n\n  Аргументи:\n  - x1, y1: x и y координатите на първия връх.\n  - x2, y2: x и y координатите на втория връх.\n  - x3, y3: x и y координатите на третия връх.\n\n  Връща:\n  - Площта на триъгълника, закръглена до два знака след десетичната запетая.\n\n  Примери:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) връща 6.00",
      "zh": "编写一个 Rust 函数 `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` 来解决以下问题：\n计算给定顶点坐标的三角形面积。\n\n  参数：\n  - x1, y1: 第一个顶点的 x 和 y 坐标。\n  - x2, y2: 第二个顶点的 x 和 y 坐标。\n  - x3, y3: 第三个顶点的 x 和 y 坐标。\n\n  返回：\n  - 三角形的面积，四舍五入到小数点后两位。\n\n  示例：\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 返回 6.00",
      "fr": "Écrire une fonction Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` pour résoudre le problème suivant :\nCalcule l'aire d'un triangle données les coordonnées de ses sommets.\n\n  Arguments :\n  - x1, y1 : Les coordonnées x et y du premier sommet.\n  - x2, y2 : Les coordonnées x et y du deuxième sommet.\n  - x3, y3 : Les coordonnées x et y du troisième sommet.\n\n  Renvoie :\n  - L'aire du triangle, arrondie à deux décimales.\n\n  Exemples :\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) renvoie 6.00",
      "de": "Schreiben Sie eine Rust-Funktion `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32`, um das folgende Problem zu lösen:\nBerechnet die Fläche eines Dreiecks, gegeben die Koordinaten seiner Eckpunkte.\n\n  Argumente:\n  - x1, y1: Die x- und y-Koordinaten des ersten Eckpunkts.\n  - x2, y2: Die x- und y-Koordinaten des zweiten Eckpunkts.\n  - x3, y3: Die x- und y-Koordinaten des dritten Eckpunkts.\n\n  Rückgabewert:\n  - Die Fläche des Dreiecks, gerundet auf zwei Dezimalstellen.\n\n  Beispiele:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) gibt 6.00 zurück",
      "ha": "Rubuta aikin Rust `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` don warware matsalar mai zuwa:\nLissafa yanki na alwatika da aka ba da daidaitattun wuraren kololuwarsa.\n\n  Huɗɗa:\n  - x1, y1: Daidaitattun x da y na kololuwa na farko.\n  - x2, y2: Daidaitattun x da y na kololuwa na biyu.\n  - x3, y3: Daidaitattun x da y na kololuwa na uku.\n\n  Mayarwa:\n  - Yankin alwatika, an zagaye zuwa wurare biyu na adadi.\n\n  Misalai:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "hi": "Rust फ़ंक्शन `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइसके शीर्षों के निर्देशांक दिए जाने पर त्रिभुज का क्षेत्रफल गणना करता है।\n\n  तर्क:\n  - x1, y1: पहले शीर्ष का x और y निर्देशांक।\n  - x2, y2: दूसरे शीर्ष का x और y निर्देशांक।\n  - x3, y3: तीसरे शीर्ष का x और y निर्देशांक।\n\n  लौटाता है:\n  - त्रिभुज का क्षेत्रफल, दो दशमलव स्थानों तक गोल किया हुआ।\n\n  उदाहरण:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32` a következő probléma megoldására:\nKiszámítja egy háromszög területét a csúcsainak koordinátái alapján.\n\n  Argumentumok:\n  - x1, y1: Az első csúcs x és y koordinátái.\n  - x2, y2: A második csúcs x és y koordinátái.\n  - x3, y3: A harmadik csúcs x és y koordinátái.\n\n  Visszatér:\n  - A háromszög területe, két tizedesjegyre kerekítve.\n\n  Példák:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) visszatér 6.00"
    },
    "instruction_bertscore": {
      "sq": "0.9986667928824938",
      "hy": "1",
      "bn": "0.9692484416689406",
      "bg": "0.983557178427551",
      "zh": "0.9886830340405373",
      "fr": "0.9986667928824938",
      "de": "0.9919222982944542",
      "ha": "0.9866351548120675",
      "hi": "0.9684940434817702",
      "hu": "0.9929041282679096"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0), 6.00);\n        assert_eq!(triangle_area(1.0, 2.0, 4.0, 5.0, 6.0, 3.0), 6.00); // Example test case, replace with correct area\n        assert_eq!(triangle_area(0.0, 0.0, 7.0, 8.0, 9.0, 10.0), 1.00); \n    }\n    \n\n}",
    "entry_point": "triangle_area",
    "signature": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32",
    "docstring": {
      "en": "Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke dhënë koordinatat e kulmeve të tij.\n\n  Argumentet:\n  - x1, y1: Koordinatat x dhe y të kulmit të parë.\n  - x2, y2: Koordinatat x dhe y të kulmit të dytë.\n  - x3, y3: Koordinatat x dhe y të kulmit të tretë.\n\n  Kthen:\n  - Sipërfaqja e trekëndëshit, e rrumbullakosur në dy vende dhjetore.\n\n  Shembuj:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) kthen 6.00",
      "hy": "Հաշվում է եռանկյան մակերեսը՝ հաշվի առնելով նրա գագաթների կոորդինատները։\n\n  Արգումենտներ:\n  - x1, y1: Առաջին գագաթի x և y կոորդինատները։\n  - x2, y2: Երկրորդ գագաթի x և y կոորդինատները։\n  - x3, y3: Երրորդ գագաթի x և y կոորդինատները։\n\n  Վերադարձնում է:\n  - Եռանկյան մակերեսը՝ կլորացված մինչև երկու տասնորդական։\n\n  Օրինակներ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) վերադարձնում է 6.00",
      "bn": "ত্রিভুজের শীর্ষবিন্দুগুলির স্থানাঙ্ক দেওয়া থাকলে তার ক্ষেত্রফল গণনা করে।\n\n  আর্গুমেন্টস:\n  - x1, y1: প্রথম শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x2, y2: দ্বিতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x3, y3: তৃতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n\n  রিটার্নস:\n  - ত্রিভুজের ক্ষেত্রফল, দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\n  উদাহরণ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) রিটার্ন করে 6.00",
      "bg": "Изчислява площта на триъгълник, като се дадат координатите на неговите върхове.\n\n  Аргументи:\n  - x1, y1: x и y координатите на първия връх.\n  - x2, y2: x и y координатите на втория връх.\n  - x3, y3: x и y координатите на третия връх.\n\n  Връща:\n  - Площта на триъгълника, закръглена до два десетични знака.\n\n  Примери:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) връща 6.00",
      "zh": "计算给定顶点坐标的三角形面积。\n\n  参数：\n  - x1, y1: 第一个顶点的 x 和 y 坐标。\n  - x2, y2: 第二个顶点的 x 和 y 坐标。\n  - x3, y3: 第三个顶点的 x 和 y 坐标。\n\n  返回：\n  - 三角形的面积，四舍五入到小数点后两位。\n\n  示例：\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 返回 6.00",
      "fr": "Calcule la surface d'un triangle étant donné les coordonnées de ses sommets.\n\n  Arguments:\n  - x1, y1 : Les coordonnées x et y du premier sommet.\n  - x2, y2 : Les coordonnées x et y du deuxième sommet.\n  - x3, y3 : Les coordonnées x et y du troisième sommet.\n\n  Renvoie:\n  - La surface du triangle, arrondie à deux décimales.\n\n  Exemples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) renvoie 6.00",
      "de": "Berechnet die Fläche eines Dreiecks, gegeben die Koordinaten seiner Eckpunkte.\n\n  Argumente:\n  - x1, y1: Die x- und y-Koordinaten des ersten Eckpunkts.\n  - x2, y2: Die x- und y-Koordinaten des zweiten Eckpunkts.\n  - x3, y3: Die x- und y-Koordinaten des dritten Eckpunkts.\n\n  Rückgabewert:\n  - Die Fläche des Dreiecks, gerundet auf zwei Dezimalstellen.\n\n  Beispiele:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) gibt 6.00 zurück",
      "ha": "Yana lissafin yankin wani alwatika idan an ba da daidaitattun wuraren kololuwansa.\n\n  Huɗɗa:\n  - x1, y1: Daidaitattun x da y na kololuwa na farko.\n  - x2, y2: Daidaitattun x da y na kololuwa na biyu.\n  - x3, y3: Daidaitattun x da y na kololuwa na uku.\n\n  Komawa:\n  - Yankin alwatika, an zagaye zuwa wurare biyu na goma.\n\n  Misalai:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) yana komawa 6.00",
      "hi": "त्रिभुज के क्षेत्रफल की गणना करता है जब इसके शीर्षों के निर्देशांक दिए गए हों।\n\n  तर्क:\n  - x1, y1: पहले शीर्ष का x और y निर्देशांक।\n  - x2, y2: दूसरे शीर्ष का x और y निर्देशांक।\n  - x3, y3: तीसरे शीर्ष का x और y निर्देशांक।\n\n  वापसी:\n  - त्रिभुज का क्षेत्रफल, दो दशमलव स्थानों तक गोल किया गया।\n\n  उदाहरण:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 लौटाता है।",
      "hu": "Számítja egy háromszög területét a csúcsainak koordinátái alapján.\n\n  Argumentumok:\n  - x1, y1: Az első csúcs x és y koordinátái.\n  - x2, y2: A második csúcs x és y koordinátái.\n  - x3, y3: A harmadik csúcs x és y koordinátái.\n\n  Visszatérési érték:\n  - A háromszög területe, két tizedesjegyre kerekítve.\n\n  Példák:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) visszaadja 6.00"
    },
    "docstring_bertscore": {
      "sq": "0.99799621671612",
      "hy": "0.9954730149858338",
      "bn": "0.9784386721386629",
      "bg": "0.9817853954287197",
      "zh": "0.9865461684013639",
      "fr": "0.994152917473476",
      "de": "0.9891694798436916",
      "ha": "0.9900410699556728",
      "hi": "0.9759772444568785",
      "hu": "0.9857190714947346"
    }
  },
  {
    "task_id": "Rust/21",
    "prompt": {
      "en": "/*\n  Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "sq": "/*\n  Llogarit postën bazuar në peshën e një pakete dhe nëse shërbimi ekspres është zgjedhur.\n  Posta llogaritet si më poshtë:\n  - Për peshë deri në dhe duke përfshirë 1000 gram, tarifa bazë është 8 njësi.\n  - Për çdo 500 gram shtesë ose pjesë të saj, shtohet një tarifë shtesë prej 4 njësi.\n  - Nëse shërbimi ekspres (i shënuar me 'y') është zgjedhur, shtohet një tarifë shtesë prej 5 njësi.\n  - Nëse shërbimi ekspres nuk është zgjedhur (i shënuar me 'n'), nuk shtohet asnjë tarifë shtesë.\n\n  Argumentet:\n  - weight: Pesha e paketës në gram.\n  - express: Një karakter që tregon nëse shërbimi ekspres është zgjedhur ('y' për po, 'n' për jo).\n\n  Kthen:\n  - Koston totale të postës si një numër i plotë pa shenjë.\n\n  Shembuj:\n  - calculate_postage(1200, 'y') kthen 17.\n  - calculate_postage(1000, 'n') kthen 8.\n  - calculate_postage(1500, 'y') kthen 17.\n  - calculate_postage(2000, 'n') kthen 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "hy": "/*\n  Հաշվում է փոստային ծախսը փաթեթի քաշի և արդյոք արտահերթ ծառայությունը ընտրված է, թե ոչ:\n  Փոստային ծախսը հաշվարկվում է հետևյալ կերպ.\n  - Մինչև և ներառյալ 1000 գրամ քաշի դեպքում հիմնական վճարը 8 միավոր է:\n  - Յուրաքանչյուր լրացուցիչ 500 գրամի կամ դրա մասի համար ավելացվում է 4 միավոր լրացուցիչ վճար:\n  - Եթե արտահերթ ծառայությունը (նշված է 'y'-ով) ընտրված է, ավելացվում է 5 միավոր լրացուցիչ վճար:\n  - Եթե արտահերթ ծառայությունը ընտրված չէ (նշված է 'n'-ով), լրացուցիչ վճար չի ավելացվում:\n\n  Փաստարկներ:\n  - weight: Փաթեթի քաշը գրամներով:\n  - express: Նիշ, որը ցույց է տալիս արդյոք արտահերթ ծառայությունը ընտրված է ('y' այո-ի համար, 'n' ոչ-ի համար):\n\n  Վերադարձնում է:\n  - Ընդհանուր փոստային ծախսը որպես անստորակետ ամբողջ թիվ:\n\n  Օրինակներ:\n  - calculate_postage(1200, 'y') վերադարձնում է 17.\n  - calculate_postage(1000, 'n') վերադարձնում է 8.\n  - calculate_postage(1500, 'y') վերադարձնում է 17.\n  - calculate_postage(2000, 'n') վերադարձնում է 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32",
      "bn": "/*\n  একটি প্যাকেজের ওজন এবং এক্সপ্রেস পরিষেবা বেছে নেওয়া হয়েছে কিনা তার উপর ভিত্তি করে ডাকমাশুল হিসাব করে।\n  ডাকমাশুল নিম্নরূপ হিসাব করা হয়:\n  - ওজন ১০০০ গ্রাম পর্যন্ত এবং সহ, বেস ফি ৮ ইউনিট।\n  - অতিরিক্ত ৫০০ গ্রাম বা তার অংশের জন্য, অতিরিক্ত ৪ ইউনিট ফি যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা (যা 'y' দ্বারা নির্দেশিত) বেছে নেওয়া হয়, অতিরিক্ত ৫ ইউনিট ফি যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা বেছে না নেওয়া হয় (যা 'n' দ্বারা নির্দেশিত), অতিরিক্ত কোনো ফি যোগ করা হয় না।\n\n  আর্গুমেন্ট:\n  - weight: প্যাকেজের ওজন গ্রামে।\n  - express: একটি চরিত্র যা নির্দেশ করে যে এক্সপ্রেস পরিষেবা বেছে নেওয়া হয়েছে কিনা ('y' হ্যাঁ জন্য, 'n' না জন্য)।\n\n  রিটার্নস:\n  - একটি আনসাইনড পূর্ণসংখ্যা হিসাবে মোট ডাকমাশুল খরচ।\n\n  উদাহরণ:\n  - calculate_postage(1200, 'y') ১৭ রিটার্ন করে।\n  - calculate_postage(1000, 'n') ৮ রিটার্ন করে।\n  - calculate_postage(1500, 'y') ১৭ রিটার্ন করে।\n  - calculate_postage(2000, 'n') ১৬ রিটার্ন করে।\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "bg": "/*\n  Изчислява пощенските разходи въз основа на теглото на пакета и дали е избрана експресна услуга.\n  Пощенските разходи се изчисляват, както следва:\n  - За тегло до и включително 1000 грама, основната такса е 8 единици.\n  - За всеки допълнителни 500 грама или част от тях, се добавя допълнителна такса от 4 единици.\n  - Ако е избрана експресна услуга (обозначена с 'y'), се добавя допълнителна такса от 5 единици.\n  - Ако експресна услуга не е избрана (обозначена с 'n'), не се добавя допълнителна такса.\n\n  Аргументи:\n  - weight: Теглото на пакета в грамове.\n  - express: Символ, указващ дали е избрана експресна услуга ('y' за да, 'n' за не).\n\n  Връща:\n  - Общата стойност на пощенските разходи като беззнаково цяло число.\n\n  Примери:\n  - calculate_postage(1200, 'y') връща 17.\n  - calculate_postage(1000, 'n') връща 8.\n  - calculate_postage(1500, 'y') връща 17.\n  - calculate_postage(2000, 'n') връща 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "zh": "/*\n  根据包裹的重量和是否选择快递服务来计算邮资。\n  邮资计算如下：\n  - 对于重量最多为1000克的包裹，基础费用为8单位。\n  - 每增加500克或其一部分，增加4单位的费用。\n  - 如果选择了快递服务（用'y'表示），则增加5单位的费用。\n  - 如果未选择快递服务（用'n'表示），则不增加额外费用。\n\n  参数:\n  - weight: 包裹的重量，单位为克。\n  - express: 一个字符，指示是否选择快递服务（'y'表示是，'n'表示否）。\n\n  返回:\n  - 总邮资费用，作为无符号整数返回。\n\n  示例:\n  - calculate_postage(1200, 'y') 返回 17。\n  - calculate_postage(1000, 'n') 返回 8。\n  - calculate_postage(1500, 'y') 返回 17。\n  - calculate_postage(2000, 'n') 返回 16。\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "fr": "/*\n  Calcule l'affranchissement en fonction du poids d'un colis et si le service express est choisi.\n  L'affranchissement est calculé comme suit :\n  - Pour un poids allant jusqu'à et y compris 1000 grammes, le tarif de base est de 8 unités.\n  - Pour chaque tranche supplémentaire de 500 grammes ou partie de celle-ci, un tarif supplémentaire de 4 unités est ajouté.\n  - Si le service express (indiqué par 'y') est choisi, un tarif supplémentaire de 5 unités est ajouté.\n  - Si le service express n'est pas choisi (indiqué par 'n'), aucun tarif supplémentaire n'est ajouté.\n\n  Arguments :\n  - weight : Le poids du colis en grammes.\n  - express : Un caractère indiquant si le service express est choisi ('y' pour oui, 'n' pour non).\n\n  Retourne :\n  - Le coût total de l'affranchissement en tant qu'entier non signé.\n\n  Exemples :\n  - calculate_postage(1200, 'y') retourne 17.\n  - calculate_postage(1000, 'n') retourne 8.\n  - calculate_postage(1500, 'y') retourne 17.\n  - calculate_postage(2000, 'n') retourne 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "de": "/*\n  Berechnet das Porto basierend auf dem Gewicht eines Pakets und ob der Expressdienst gewählt wurde.\n  Das Porto wird wie folgt berechnet:\n  - Für ein Gewicht bis einschließlich 1000 Gramm beträgt die Grundgebühr 8 Einheiten.\n  - Für jeweils weitere 500 Gramm oder einen Teil davon wird eine zusätzliche Gebühr von 4 Einheiten erhoben.\n  - Wenn der Expressdienst (angegeben durch 'y') gewählt wird, wird eine zusätzliche Gebühr von 5 Einheiten erhoben.\n  - Wenn der Expressdienst nicht gewählt wird (angegeben durch 'n'), wird keine zusätzliche Gebühr erhoben.\n\n  Argumente:\n  - weight: Das Gewicht des Pakets in Gramm.\n  - express: Ein Zeichen, das angibt, ob der Expressdienst gewählt wurde ('y' für ja, 'n' für nein).\n\n  Rückgabewert:\n  - Die gesamten Portokosten als vorzeichenlose Ganzzahl.\n\n  Beispiele:\n  - calculate_postage(1200, 'y') gibt 17 zurück.\n  - calculate_postage(1000, 'n') gibt 8 zurück.\n  - calculate_postage(1500, 'y') gibt 17 zurück.\n  - calculate_postage(2000, 'n') gibt 16 zurück.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "ha": "/*\n  Lissafa kuɗin aika bisa nauyin kunshin da kuma ko an zaɓi sabis na gaggawa.\n  Ana lissafa kuɗin aika kamar haka:\n  - Don nauyi har zuwa da ciki har da gram 1000, kuɗin asali shine raka'a 8.\n  - Don kowane karin gram 500 ko wani ɓangare na shi, ana ƙara karin kuɗi na raka'a 4.\n  - Idan an zaɓi sabis na gaggawa (wanda aka nuna da 'y'), ana ƙara karin kuɗi na raka'a 5.\n  - Idan ba a zaɓi sabis na gaggawa ba (wanda aka nuna da 'n'), ba a ƙara karin kuɗi ba.\n\n  Huɗɗa:\n  - weight: Nauyin kunshin a cikin gram.\n  - express: Harafi da ke nuna ko an zaɓi sabis na gaggawa ('y' don eh, 'n' don a'a).\n\n  Komawa:\n  - Jimillar kuɗin aika a matsayin cikakken lamba mara alama.\n\n  Misalai:\n  - calculate_postage(1200, 'y') yana dawowa 17.\n  - calculate_postage(1000, 'n') yana dawowa 8.\n  - calculate_postage(1500, 'y') yana dawowa 17.\n  - calculate_postage(2000, 'n') yana dawowa 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "hi": "/*\n  पैकेज के वजन और क्या एक्सप्रेस सेवा चुनी गई है, के आधार पर डाक शुल्क की गणना करता है।\n  डाक शुल्क की गणना निम्नलिखित रूप से की जाती है:\n  - 1000 ग्राम तक और उसके शामिल वजन के लिए, आधार शुल्क 8 यूनिट है।\n  - प्रत्येक अतिरिक्त 500 ग्राम या उसके हिस्से के लिए, अतिरिक्त शुल्क 4 यूनिट जोड़ा जाता है।\n  - यदि एक्सप्रेस सेवा (जिसे 'y' द्वारा दर्शाया गया है) चुनी जाती है, तो अतिरिक्त शुल्क 5 यूनिट जोड़ा जाता है।\n  - यदि एक्सप्रेस सेवा नहीं चुनी जाती है (जिसे 'n' द्वारा दर्शाया गया है), तो कोई अतिरिक्त शुल्क नहीं जोड़ा जाता है।\n\n  तर्क:\n  - weight: पैकेज का वजन ग्राम में।\n  - express: एक वर्ण जो दर्शाता है कि क्या एक्सप्रेस सेवा चुनी गई है ('y' हाँ के लिए, 'n' नहीं के लिए)।\n\n  लौटाता है:\n  - कुल डाक लागत एक असाइन किए गए पूर्णांक के रूप में।\n\n  उदाहरण:\n  - calculate_postage(1200, 'y') 17 लौटाता है।\n  - calculate_postage(1000, 'n') 8 लौटाता है।\n  - calculate_postage(1500, 'y') 17 लौटाता है।\n  - calculate_postage(2000, 'n') 16 लौटाता है।\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "hu": "/*\n  Kiszámítja a postaköltséget a csomag súlya és az expressz szolgáltatás választása alapján.\n  A postaköltség a következőképpen kerül kiszámításra:\n  - 1000 grammig bezárólag az alapdíj 8 egység.\n  - Minden további 500 gramm vagy annak töredéke esetén további 4 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás (amelyet 'y' jelöl) van választva, további 5 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás nincs választva (amelyet 'n' jelöl), nem kerül felszámításra további díj.\n\n  Argumentumok:\n  - weight: A csomag súlya grammban.\n  - express: Egy karakter, amely jelzi, hogy az expressz szolgáltatás van-e választva ('y' igen, 'n' nem).\n\n  Visszatér:\n  - A teljes postaköltség mint előjelnélküli egész szám.\n\n  Példák:\n  - calculate_postage(1200, 'y') visszatér 17.\n  - calculate_postage(1000, 'n') visszatér 8.\n  - calculate_postage(1500, 'y') visszatér 17.\n  - calculate_postage(2000, 'n') visszatér 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 "
    },
    "prompt_bertscore": {
      "sq": "0.9790478715172969",
      "hy": "0.9700840796819544",
      "bn": "0.9855792357064861",
      "bg": "0.9868780797680732",
      "zh": "0.9588374288773781",
      "fr": "0.9624590566147871",
      "de": "0.9671846720099881",
      "ha": "0.9693523253582219",
      "hi": "0.9823356015841863",
      "hu": "0.9642485177175305"
    },
    "canonical_solution": "{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}",
    "instruction": {
      "en": "Write a Rust function `fn calculate_postage(weight: u32, express: char) -> u32` to solve the following problem:\nCalculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "sq": "Shkruani një funksion Rust `fn calculate_postage(weight: u32, express: char) -> u32` për të zgjidhur problemin e mëposhtëm:\nKalkulon tarifën postare bazuar në peshën e një pakete dhe nëse është zgjedhur shërbimi ekspres.\n  Tarifa postare llogaritet si më poshtë:\n  - Për peshë deri në dhe duke përfshirë 1000 gramë, tarifa bazë është 8 njësi.\n  - Për çdo 500 gramë shtesë ose pjesë të tyre, shtohet një tarifë shtesë prej 4 njësi.\n  - Nëse shërbimi ekspres (i shënuar me 'y') është zgjedhur, shtohet një tarifë shtesë prej 5 njësi.\n  - Nëse shërbimi ekspres nuk është zgjedhur (i shënuar me 'n'), nuk shtohet asnjë tarifë shtesë.\n\n  Argumentet:\n  - weight: Pesha e paketës në gramë.\n  - express: Një karakter që tregon nëse është zgjedhur shërbimi ekspres ('y' për po, 'n' për jo).\n\n  Kthen:\n  - Koston totale të tarifës postare si një numër i plotë pa shenjë.\n\n  Shembuj:\n  - calculate_postage(1200, 'y') kthen 17.\n  - calculate_postage(1000, 'n') kthen 8.\n  - calculate_postage(1500, 'y') kthen 17.\n  - calculate_postage(2000, 'n') kthen 16.",
      "hy": "Rust ֆունկցիա `fn calculate_postage(weight: u32, express: char) -> u32` գրեք հետևյալ խնդիրը լուծելու համար:\nՀաշվում է փոստային վճարը փաթեթի քաշի և արդյոք արագացված ծառայությունը ընտրված է, թե ոչ, հիման վրա:\n  Փոստային վճարը հաշվարկվում է հետևյալ կերպ.\n  - Մինչև 1000 գրամ քաշի համար, հիմնական վճարը 8 միավոր է:\n  - Յուրաքանչյուր լրացուցիչ 500 գրամի կամ դրա մասի համար, լրացուցիչ 4 միավոր է ավելացվում:\n  - Եթե արագացված ծառայությունը (նշված 'y'-ով) ընտրված է, լրացուցիչ 5 միավոր է ավելացվում:\n  - Եթե արագացված ծառայությունը ընտրված չէ (նշված 'n'-ով), լրացուցիչ վճար չի ավելացվում:\n\n  Արգումենտներ:\n  - weight: Փաթեթի քաշը գրամներով:\n  - express: Նիշ, որը ցույց է տալիս արդյոք արագացված ծառայությունը ընտրված է ('y' այո, 'n' ոչ):\n\n  Վերադարձնում է:\n  - Ընդհանուր փոստային վճարը որպես unsigned integer:\n\n  Օրինակներ:\n  - calculate_postage(1200, 'y') վերադարձնում է 17:\n  - calculate_postage(1000, 'n') վերադարձնում է 8:\n  - calculate_postage(1500, 'y') վերադարձնում է 17:\n  - calculate_postage(2000, 'n') վերադարձնում է 16:",
      "bn": "Rust ফাংশন `fn calculate_postage(weight: u32, express: char) -> u32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্যাকেজের ওজন এবং এক্সপ্রেস সার্ভিস নির্বাচিত হয়েছে কিনা তার উপর ভিত্তি করে ডাকমাশুল গণনা করে।\n  ডাকমাশুল নিম্নরূপে গণনা করা হয়:\n  - ওজন ১০০০ গ্রাম পর্যন্ত এবং সহ, বেস ফি ৮ ইউনিট।\n  - অতিরিক্ত প্রতিটি ৫০০ গ্রাম বা তার অংশের জন্য, অতিরিক্ত ফি ৪ ইউনিট যোগ করা হয়।\n  - যদি এক্সপ্রেস সার্ভিস (যা 'y' দ্বারা নির্দেশিত) নির্বাচিত হয়, অতিরিক্ত ফি ৫ ইউনিট যোগ করা হয়।\n  - যদি এক্সপ্রেস সার্ভিস নির্বাচিত না হয় (যা 'n' দ্বারা নির্দেশিত), অতিরিক্ত কোন ফি যোগ করা হয় না।\n\n  আর্গুমেন্ট:\n  - weight: প্যাকেজের ওজন গ্রামে।\n  - express: একটি চরিত্র যা নির্দেশ করে এক্সপ্রেস সার্ভিস নির্বাচিত হয়েছে কিনা ('y' হ্যাঁ জন্য, 'n' না জন্য)।\n\n  রিটার্নস:\n  - মোট ডাকমাশুল একটি অসম্পূর্ণ পূর্ণসংখ্যা হিসাবে।\n\n  উদাহরণ:\n  - calculate_postage(1200, 'y') ১৭ রিটার্ন করে।\n  - calculate_postage(1000, 'n') ৮ রিটার্ন করে।\n  - calculate_postage(1500, 'y') ১৭ রিটার্ন করে।\n  - calculate_postage(2000, 'n') ১৬ রিটার্ন করে।",
      "bg": "Напишете функция на Rust `fn calculate_postage(weight: u32, express: char) -> u32`, за да решите следния проблем:\nИзчислява пощенските разходи въз основа на теглото на пакета и дали е избрана експресна услуга.\n  Пощенските разходи се изчисляват, както следва:\n  - За тегло до и включително 1000 грама, основната такса е 8 единици.\n  - За всеки допълнителни 500 грама или част от тях се добавя допълнителна такса от 4 единици.\n  - Ако е избрана експресна услуга (обозначена с 'y'), се добавя допълнителна такса от 5 единици.\n  - Ако експресна услуга не е избрана (обозначена с 'n'), не се добавя допълнителна такса.\n\n  Аргументи:\n  - weight: Теглото на пакета в грамове.\n  - express: Символ, указващ дали е избрана експресна услуга ('y' за да, 'n' за не).\n\n  Връща:\n  - Общата стойност на пощенските разходи като беззнаков целочислен тип.\n\n  Примери:\n  - calculate_postage(1200, 'y') връща 17.\n  - calculate_postage(1000, 'n') връща 8.\n  - calculate_postage(1500, 'y') връща 17.\n  - calculate_postage(2000, 'n') връща 16.",
      "zh": "编写一个 Rust 函数 `fn calculate_postage(weight: u32, express: char) -> u32` 来解决以下问题：\n根据包裹的重量和是否选择快递服务计算邮资。\n邮资计算如下：\n- 重量最多为 1000 克时，基本费用为 8 单位。\n- 每增加 500 克或其一部分，增加 4 单位的额外费用。\n- 如果选择快递服务（用 'y' 表示），则增加 5 单位的额外费用。\n- 如果未选择快递服务（用 'n' 表示），则不增加额外费用。\n\n参数：\n- weight: 包裹的重量，以克为单位。\n- express: 一个字符，表示是否选择快递服务（'y' 表示是，'n' 表示否）。\n\n返回：\n- 总邮资费用，作为无符号整数。\n\n示例：\n- calculate_postage(1200, 'y') 返回 17。\n- calculate_postage(1000, 'n') 返回 8。\n- calculate_postage(1500, 'y') 返回 17。\n- calculate_postage(2000, 'n') 返回 16。",
      "fr": "Écrire une fonction Rust `fn calculate_postage(weight: u32, express: char) -> u32` pour résoudre le problème suivant :\nCalcule le tarif postal en fonction du poids d'un colis et si le service express est choisi.\n  Le tarif postal est calculé comme suit :\n  - Pour un poids allant jusqu'à et y compris 1000 grammes, le tarif de base est de 8 unités.\n  - Pour chaque tranche supplémentaire de 500 grammes ou partie de celle-ci, un supplément de 4 unités est ajouté.\n  - Si le service express (indiqué par 'y') est choisi, un supplément de 5 unités est ajouté.\n  - Si le service express n'est pas choisi (indiqué par 'n'), aucun supplément n'est ajouté.\n\n  Arguments :\n  - weight : Le poids du colis en grammes.\n  - express : Un caractère indiquant si le service express est choisi ('y' pour oui, 'n' pour non).\n\n  Renvoie :\n  - Le coût total du tarif postal en tant qu'entier non signé.\n\n  Exemples :\n  - calculate_postage(1200, 'y') renvoie 17.\n  - calculate_postage(1000, 'n') renvoie 8.\n  - calculate_postage(1500, 'y') renvoie 17.\n  - calculate_postage(2000, 'n') renvoie 16.",
      "de": "Schreiben Sie eine Rust-Funktion `fn calculate_postage(weight: u32, express: char) -> u32`, um das folgende Problem zu lösen:\nBerechnet das Porto basierend auf dem Gewicht eines Pakets und ob der Express-Service gewählt wurde.\n  Das Porto wird wie folgt berechnet:\n  - Für ein Gewicht bis einschließlich 1000 Gramm beträgt die Grundgebühr 8 Einheiten.\n  - Für jeweils weitere 500 Gramm oder einen Teil davon wird eine zusätzliche Gebühr von 4 Einheiten erhoben.\n  - Wenn der Express-Service (angegeben durch 'y') gewählt wird, wird eine zusätzliche Gebühr von 5 Einheiten erhoben.\n  - Wenn der Express-Service nicht gewählt wird (angegeben durch 'n'), wird keine zusätzliche Gebühr erhoben.\n\n  Argumente:\n  - weight: Das Gewicht des Pakets in Gramm.\n  - express: Ein Zeichen, das angibt, ob der Express-Service gewählt wurde ('y' für ja, 'n' für nein).\n\n  Rückgabewerte:\n  - Die gesamten Portokosten als vorzeichenlose Ganzzahl.\n\n  Beispiele:\n  - calculate_postage(1200, 'y') gibt 17 zurück.\n  - calculate_postage(1000, 'n') gibt 8 zurück.\n  - calculate_postage(1500, 'y') gibt 17 zurück.\n  - calculate_postage(2000, 'n') gibt 16 zurück.",
      "ha": "Rubuta aikin Rust `fn calculate_postage(weight: u32, express: char) -> u32` don warware matsalar mai zuwa:\nYana ƙididdige kuɗin aikawa bisa ga nauyin fakitin da ko an zaɓi sabis na gaggawa.\n  Ana ƙididdige kuɗin aikawa kamar haka:\n  - Don nauyi har zuwa da ciki har da gram 1000, kuɗin asali shine raka'a 8.\n  - Don kowane gram 500 na ƙarin ko wani ɓangare na shi, ana ƙara kuɗin ƙarin raka'a 4.\n  - Idan an zaɓi sabis na gaggawa (da aka nuna da 'y'), ana ƙara kuɗin ƙarin raka'a 5.\n  - Idan ba a zaɓi sabis na gaggawa ba (da aka nuna da 'n'), ba a ƙara kuɗin ƙarin ba.\n\n  Huɗɗa:\n  - weight: Nauyin fakitin a cikin gram.\n  - express: Harafi da ke nuna ko an zaɓi sabis na gaggawa ('y' don eh, 'n' don a'a).\n\n  Dawowa:\n  - Jimlar kuɗin aikawa a matsayin cikakken lamba mara alama.\n\n  Misalai:\n  - calculate_postage(1200, 'y') yana dawowa 17.\n  - calculate_postage(1000, 'n') yana dawowa 8.\n  - calculate_postage(1500, 'y') yana dawowa 17.\n  - calculate_postage(2000, 'n') yana dawowa 16.",
      "hi": "Rust फ़ंक्शन `fn calculate_postage(weight: u32, express: char) -> u32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nपैकेज के वजन और क्या एक्सप्रेस सेवा चुनी गई है, के आधार पर डाक शुल्क की गणना करता है।\n  डाक शुल्क की गणना निम्नलिखित रूप से की जाती है:\n  - 1000 ग्राम तक और उसके समावेशी वजन के लिए, आधार शुल्क 8 इकाइयाँ है।\n  - प्रत्येक अतिरिक्त 500 ग्राम या उसके हिस्से के लिए, 4 इकाइयों का अतिरिक्त शुल्क जोड़ा जाता है।\n  - यदि एक्सप्रेस सेवा (जिसे 'y' द्वारा दर्शाया गया है) चुनी जाती है, तो 5 इकाइयों का अतिरिक्त शुल्क जोड़ा जाता है।\n  - यदि एक्सप्रेस सेवा नहीं चुनी जाती है (जिसे 'n' द्वारा दर्शाया गया है), तो कोई अतिरिक्त शुल्क नहीं जोड़ा जाता है।\n\n  तर्क:\n  - weight: पैकेज का वजन ग्राम में।\n  - express: एक वर्ण जो दर्शाता है कि एक्सप्रेस सेवा चुनी गई है या नहीं ('y' हाँ के लिए, 'n' नहीं के लिए)।\n\n  रिटर्न करता है:\n  - कुल डाक लागत एक बिना चिह्नित पूर्णांक के रूप में।\n\n  उदाहरण:\n  - calculate_postage(1200, 'y') 17 लौटाता है।\n  - calculate_postage(1000, 'n') 8 लौटाता है।\n  - calculate_postage(1500, 'y') 17 लौटाता है।\n  - calculate_postage(2000, 'n') 16 लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn calculate_postage(weight: u32, express: char) -> u32` a következő probléma megoldására:\nKiszámítja a postaköltséget egy csomag súlya és az expressz szolgáltatás választása alapján.\n  A postaköltség a következőképpen kerül kiszámításra:\n  - 1000 grammig bezárólag az alapdíj 8 egység.\n  - Minden további 500 gramm vagy annak töredéke után további 4 egység díjat számítunk fel.\n  - Ha az expressz szolgáltatást (amit 'y' jelöl) választják, további 5 egység díjat számítunk fel.\n  - Ha az expressz szolgáltatást nem választják (amit 'n' jelöl), nem számítunk fel további díjat.\n\n  Argumentumok:\n  - weight: A csomag súlya grammban.\n  - express: Egy karakter, amely jelzi, hogy az expressz szolgáltatást választották-e ('y' az igen, 'n' a nem esetén).\n\n  Visszatérési érték:\n  - A teljes postaköltség mint előjelnélküli egész szám.\n\n  Példák:\n  - calculate_postage(1200, 'y') visszaadja 17.\n  - calculate_postage(1000, 'n') visszaadja 8.\n  - calculate_postage(1500, 'y') visszaadja 17.\n  - calculate_postage(2000, 'n') visszaadja 16."
    },
    "instruction_bertscore": {
      "sq": "0.9818827243154268",
      "hy": "0.9482422857225961",
      "bn": "0.9730720765038623",
      "bg": "0.9758642237700696",
      "zh": "0.9709612314446046",
      "fr": "0.96844220095232",
      "de": "0.9695606886279275",
      "ha": "0.9674806312777302",
      "hi": "0.9721403013864276",
      "hu": "0.9702751621085101"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_postage(1200, 'y'), 17);\n        assert_eq!(calculate_postage(1000, 'n'), 8);\n        assert_eq!(calculate_postage(1500, 'y'), 17);\n        assert_eq!(calculate_postage(2000, 'n'), 16);\n        \n    }\n    \n\n}",
    "entry_point": "calculate_postage",
    "signature": "fn calculate_postage(weight: u32, express: char) -> u32",
    "docstring": {
      "en": "Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "sq": "Llogarit postën bazuar në peshën e një pakete dhe nëse është zgjedhur shërbimi ekspres.\n  Posta llogaritet si më poshtë:\n  - Për peshë deri në dhe duke përfshirë 1000 gramë, tarifa bazë është 8 njësi.\n  - Për çdo 500 gramë shtesë ose pjesë të tyre, shtohet një tarifë shtesë prej 4 njësi.\n  - Nëse shërbimi ekspres (i shënuar me 'y') është zgjedhur, shtohet një tarifë shtesë prej 5 njësi.\n  - Nëse shërbimi ekspres nuk është zgjedhur (i shënuar me 'n'), nuk shtohet asnjë tarifë shtesë.\n\n  Argumentet:\n  - weight: Pesha e paketës në gramë.\n  - express: Një karakter që tregon nëse është zgjedhur shërbimi ekspres ('y' për po, 'n' për jo).\n\n  Kthen:\n  - Koston totale të postës si një numër i plotë pa shenjë.\n\n  Shembuj:\n  - calculate_postage(1200, 'y') kthen 17.\n  - calculate_postage(1000, 'n') kthen 8.\n  - calculate_postage(1500, 'y') kthen 17.\n  - calculate_postage(2000, 'n') kthen 16.",
      "hy": "Հաշվում է փոստային վճարը փաթեթի քաշի և արդյոք արագ առաքման ծառայություն ընտրված է, թե ոչ։\n  Փոստային վճարը հաշվարկվում է հետևյալ կերպ․\n  - Մինչև 1000 գրամ քաշի համար, հիմնական վճարը կազմում է 8 միավոր։\n  - Յուրաքանչյուր լրացուցիչ 500 գրամի կամ դրա մասի համար, ավելացվում է լրացուցիչ 4 միավոր։\n  - Եթե արագ առաքման ծառայությունը (նշված 'y' տառով) ընտրված է, ավելացվում է լրացուցիչ 5 միավոր։\n  - Եթե արագ առաքման ծառայությունը ընտրված չէ (նշված 'n' տառով), լրացուցիչ վճար չի ավելացվում։\n\n  Արգումենտներ:\n  - weight: Փաթեթի քաշը գրամներով։\n  - express: Սիմվոլ, որը ցույց է տալիս արդյոք արագ առաքման ծառայությունը ընտրված է ('y' այո, 'n' ոչ)։\n\n  Վերադարձնում է:\n  - Ընդհանուր փոստային վճարը որպես անստորակետ ամբողջ թիվ։\n\n  Օրինակներ:\n  - calculate_postage(1200, 'y') վերադարձնում է 17։\n  - calculate_postage(1000, 'n') վերադարձնում է 8։\n  - calculate_postage(1500, 'y') վերադարձնում է 17։\n  - calculate_postage(2000, 'n') վերադարձնում է 16։",
      "bn": "প্যাকেজের ওজন এবং এক্সপ্রেস পরিষেবা বেছে নেওয়া হয়েছে কিনা তার উপর ভিত্তি করে ডাকমাশুল গণনা করে।\n  ডাকমাশুল নিম্নরূপ গণনা করা হয়:\n  - ওজন ১০০০ গ্রাম পর্যন্ত এবং এর মধ্যে হলে, বেস ফি ৮ ইউনিট।\n  - প্রতিটি অতিরিক্ত ৫০০ গ্রাম বা তার অংশের জন্য, অতিরিক্ত ফি ৪ ইউনিট যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা (যা 'y' দ্বারা চিহ্নিত) বেছে নেওয়া হয়, অতিরিক্ত ফি ৫ ইউনিট যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা বেছে না নেওয়া হয় (যা 'n' দ্বারা চিহ্নিত), অতিরিক্ত ফি যোগ করা হয় না।\n\n  আর্গুমেন্টসমূহ:\n  - weight: প্যাকেজের ওজন গ্রামে।\n  - express: একটি চরিত্র যা নির্দেশ করে যে এক্সপ্রেস পরিষেবা বেছে নেওয়া হয়েছে কিনা ('y' হ্যাঁ এর জন্য, 'n' না এর জন্য)।\n\n  রিটার্নস:\n  - মোট ডাকমাশুল একটি অসম্পূর্ণ পূর্ণসংখ্যা হিসাবে।\n\n  উদাহরণসমূহ:\n  - calculate_postage(1200, 'y') রিটার্ন করে 17।\n  - calculate_postage(1000, 'n') রিটার্ন করে 8।\n  - calculate_postage(1500, 'y') রিটার্ন করে 17।\n  - calculate_postage(2000, 'n') রিটার্ন করে 16।",
      "bg": "Изчислява пощенските разходи на базата на теглото на пакет и дали е избрана експресна услуга.\n  Пощенските разходи се изчисляват, както следва:\n  - За тегло до и включително 1000 грама, основната такса е 8 единици.\n  - За всеки допълнителни 500 грама или част от тях, се добавя допълнителна такса от 4 единици.\n  - Ако е избрана експресна услуга (обозначено с 'y'), се добавя допълнителна такса от 5 единици.\n  - Ако експресната услуга не е избрана (обозначено с 'n'), не се добавя допълнителна такса.\n\n  Аргументи:\n  - weight: Теглото на пакета в грамове.\n  - express: Символ, указващ дали е избрана експресна услуга ('y' за да, 'n' за не).\n\n  Връща:\n  - Общата стойност на пощенските разходи като беззнаков цяло число.\n\n  Примери:\n  - calculate_postage(1200, 'y') връща 17.\n  - calculate_postage(1000, 'n') връща 8.\n  - calculate_postage(1500, 'y') връща 17.\n  - calculate_postage(2000, 'n') връща 16.",
      "zh": "根据包裹的重量和是否选择快递服务计算邮费。\n  邮费计算如下：\n  - 重量最多为1000克，基本费用为8个单位。\n  - 每增加500克或其一部分，增加4个单位的费用。\n  - 如果选择快递服务（用'y'表示），则增加5个单位的费用。\n  - 如果不选择快递服务（用'n'表示），则不增加费用。\n\n  参数:\n  - weight: 包裹的重量，单位为克。\n  - express: 一个字符，表示是否选择快递服务（'y'表示是，'n'表示否）。\n\n  返回:\n  - 总邮费作为无符号整数。\n\n  示例:\n  - calculate_postage(1200, 'y') 返回 17。\n  - calculate_postage(1000, 'n') 返回 8。\n  - calculate_postage(1500, 'y') 返回 17。\n  - calculate_postage(2000, 'n') 返回 16。",
      "fr": "Calcule l'affranchissement en fonction du poids d'un colis et si le service express est choisi.\n  L'affranchissement est calculé comme suit :\n  - Pour un poids allant jusqu'à et y compris 1000 grammes, les frais de base sont de 8 unités.\n  - Pour chaque tranche supplémentaire de 500 grammes ou fraction de celle-ci, des frais supplémentaires de 4 unités sont ajoutés.\n  - Si le service express (indiqué par 'y') est choisi, des frais supplémentaires de 5 unités sont ajoutés.\n  - Si le service express n'est pas choisi (indiqué par 'n'), aucun frais supplémentaire n'est ajouté.\n\n  Arguments:\n  - weight: Le poids du colis en grammes.\n  - express: Un caractère indiquant si le service express est choisi ('y' pour oui, 'n' pour non).\n\n  Returns:\n  - Le coût total de l'affranchissement en tant qu'entier non signé.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "de": "Berechnet das Porto basierend auf dem Gewicht eines Pakets und ob der Expressdienst gewählt wurde.\n  Das Porto wird wie folgt berechnet:\n  - Für ein Gewicht bis einschließlich 1000 Gramm beträgt die Grundgebühr 8 Einheiten.\n  - Für je weitere 500 Gramm oder einen Teil davon wird eine zusätzliche Gebühr von 4 Einheiten hinzugefügt.\n  - Wenn der Expressdienst (angegeben durch 'y') gewählt wird, wird eine zusätzliche Gebühr von 5 Einheiten hinzugefügt.\n  - Wenn der Expressdienst nicht gewählt wird (angegeben durch 'n'), wird keine zusätzliche Gebühr hinzugefügt.\n\n  Argumente:\n  - weight: Das Gewicht des Pakets in Gramm.\n  - express: Ein Zeichen, das angibt, ob der Expressdienst gewählt wurde ('y' für ja, 'n' für nein).\n\n  Rückgabewerte:\n  - Die gesamten Portokosten als vorzeichenlose Ganzzahl.\n\n  Beispiele:\n  - calculate_postage(1200, 'y') gibt 17 zurück.\n  - calculate_postage(1000, 'n') gibt 8 zurück.\n  - calculate_postage(1500, 'y') gibt 17 zurück.\n  - calculate_postage(2000, 'n') gibt 16 zurück.",
      "ha": "Lissafa kuɗin aika bisa nauyin kunshin da kuma ko an zaɓi sabis na gaggawa.\n  Ana lissafin kuɗin aikawa bisa nauyin kunshin da kuma ko an zaɓi sabis na gaggawa. Ana lissafin kuɗin aikawa kamar haka:\n  - Don nauyi har zuwa da kuma ciki har da gram 1000, kuɗin asali yana da raka'a 8.\n  - Don kowane karin gram 500 ko wani ɓangare na shi, ana ƙara kuɗin karin raka'a 4.\n  - Idan an zaɓi sabis na gaggawa (wanda aka nuna da 'y'), ana ƙara kuɗin karin raka'a 5.\n  - Idan ba a zaɓi sabis na gaggawa ba (wanda aka nuna da 'n'), ba a ƙara wani karin kuɗi ba.\n\n  Arguments:\n  - weight: Nauyin kunshin a cikin gram.\n  - express: Wata alama da ke nuna ko an zaɓi sabis na gaggawa ('y' don eh, 'n' don a'a).\n\n  Returns:\n  - Jimillar kuɗin aikawa a matsayin cikakken lamba mara alama.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "hi": "पैकेज के वजन और क्या एक्सप्रेस सेवा चुनी गई है, के आधार पर डाक शुल्क की गणना करता है।\nडाक शुल्क की गणना इस प्रकार की जाती है:\n- 1000 ग्राम तक और उसके समावेशी वजन के लिए, आधार शुल्क 8 इकाइयाँ है।\n- प्रत्येक अतिरिक्त 500 ग्राम या उसके हिस्से के लिए, अतिरिक्त शुल्क 4 इकाइयाँ जोड़ी जाती हैं।\n- यदि एक्सप्रेस सेवा (जिसे 'y' द्वारा दर्शाया गया है) चुनी जाती है, तो अतिरिक्त शुल्क 5 इकाइयाँ जोड़ी जाती हैं।\n- यदि एक्सप्रेस सेवा नहीं चुनी जाती (जिसे 'n' द्वारा दर्शाया गया है), तो कोई अतिरिक्त शुल्क नहीं जोड़ा जाता।\n\nआर्गुमेंट्स:\n- weight: पैकेज का वजन ग्राम में।\n- express: एक चरित्र जो दर्शाता है कि एक्सप्रेस सेवा चुनी गई है या नहीं ('y' हाँ के लिए, 'n' नहीं के लिए)।\n\nरिटर्न्स:\n- कुल डाक लागत एक असाइन किए गए पूर्णांक के रूप में।\n\nउदाहरण:\n- calculate_postage(1200, 'y') 17 लौटाता है।\n- calculate_postage(1000, 'n') 8 लौटाता है।\n- calculate_postage(1500, 'y') 17 लौटाता है।\n- calculate_postage(2000, 'n') 16 लौटाता है।",
      "hu": "Kiszámítja a postaköltséget a csomag súlya és az expressz szolgáltatás választása alapján.\n  A postaköltség a következőképpen kerül kiszámításra:\n  - 1000 grammig bezárólag az alapdíj 8 egység.\n  - Minden további 500 gramm vagy annak töredéke esetén további 4 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás (jelölve 'y'-nal) van választva, további 5 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás nincs választva (jelölve 'n'-nel), nem kerül felszámításra további díj.\n\n  Argumentumok:\n  - weight: A csomag súlya grammban.\n  - express: Egy karakter, amely jelzi, hogy az expressz szolgáltatás van-e választva ('y' az igen, 'n' a nem esetén).\n\n  Visszatérési érték:\n  - A teljes postaköltség mint előjelnélküli egész szám.\n\n  Példák:\n  - calculate_postage(1200, 'y') visszatér 17.\n  - calculate_postage(1000, 'n') visszatér 8.\n  - calculate_postage(1500, 'y') visszatér 17.\n  - calculate_postage(2000, 'n') visszatér 16."
    },
    "docstring_bertscore": {
      "sq": "0.9780668360653656",
      "hy": "0.9508771177270239",
      "bn": "0.9809725999095249",
      "bg": "0.9842617203890817",
      "zh": "0.9458285293322601",
      "fr": "0.9708311285450266",
      "de": "0.971402389520883",
      "ha": "0.9750277912355317",
      "hi": "0.9665786507174507",
      "hu": "0.9656997112813713"
    }
  },
  {
    "task_id": "Rust/22",
    "prompt": {
      "en": "/*\n  Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "sq": "/*\n  Llogarit numrin e pacientëve që nuk mund të shërbehen bazuar në stokun e disponueshëm të ilaçeve dhe kërkesat e tyre.\n\n  Argumentet:\n  - total_medicine: Sasia totale e ilaçeve e disponueshme në fillim të ditës.\n  - num_patients: Numri i pacientëve që vijnë për të marrë ilaçe.\n  - patient_requests: Një varg i usize, secili që përfaqëson sasinë e ilaçeve të kërkuara nga një pacient, në rendin që ata mbërrijnë.\n\n  Kthen:\n  - Numrin e pacientëve që nuk mund të shërbehen sepse stoku i ilaçeve është i pamjaftueshëm.\n\n  Shembull:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) kthen 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) kthen 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) kthen 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "hy": "/*\n  Հաշվում է այն հիվանդների քանակը, ովքեր չեն կարող սպասարկվել առկա դեղորայքի պաշարի և նրանց պահանջների հիման վրա:\n\n  Արգումենտներ:\n  - total_medicine: Օրվա սկզբում առկա դեղորայքի ընդհանուր քանակը:\n  - num_patients: Հիվանդների քանակը, ովքեր գալիս են դեղորայք ստանալու:\n  - patient_requests: usize տիպի զանգված, որը ներկայացնում է յուրաքանչյուր հիվանդի պահանջած դեղորայքի քանակը, ըստ նրանց ժամանման հերթականության:\n\n  Վերադարձնում է:\n  - Այն հիվանդների քանակը, ովքեր չեն կարող սպասարկվել, քանի որ դեղորայքի պաշարը բավարար չէ:\n\n  Օրինակ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) վերադարձնում է 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) վերադարձնում է 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) վերադարձնում է 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "bn": "/*\n  উপলব্ধ ওষুধের মজুদ এবং তাদের অনুরোধের ভিত্তিতে কতজন রোগীকে সেবা দেওয়া যাবে না তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - total_medicine: দিনের শুরুতে উপলব্ধ মোট ওষুধের পরিমাণ।\n  - num_patients: ওষুধ নিতে আসা রোগীর সংখ্যা।\n  - patient_requests: একটি usize এর অ্যারে, প্রতিটি রোগীর আগমনের ক্রমে তাদের চাওয়া ওষুধের পরিমাণ উপস্থাপন করে।\n\n  রিটার্নস:\n  - কতজন রোগীকে সেবা দেওয়া যাবে না কারণ ওষুধের মজুদ অপর্যাপ্ত।\n\n  উদাহরণ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 রিটার্ন করে\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 রিটার্ন করে\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 রিটার্ন করে\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "bg": "/*\n  Изчислява броя на пациентите, които не могат да бъдат обслужени въз основа на наличния запас от лекарства и техните заявки.\n\n  Аргументи:\n  - total_medicine: Общото количество лекарства, налично в началото на деня.\n  - num_patients: Броят на пациентите, които идват да получат лекарства.\n  - patient_requests: Масив от usize, всеки представляващ количеството лекарства, заявено от пациент, в реда на тяхното пристигане.\n\n  Връща:\n  - Броят на пациентите, които не могат да бъдат обслужени, защото запасът от лекарства е недостатъчен.\n\n  Пример:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) връща 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) връща 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) връща 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "zh": "/*\n  计算由于可用药品库存和患者请求而无法服务的患者数量。\n\n  参数：\n  - total_medicine: 一天开始时可用的药品总量。\n  - num_patients: 前来领取药品的患者数量。\n  - patient_requests: 一个usize数组，每个元素表示患者请求的药品数量，按他们到达的顺序排列。\n\n  返回值：\n  - 因药品库存不足而无法服务的患者数量。\n\n  示例：\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 返回 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 返回 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 返回 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "fr": "/*\n  Calcule le nombre de patients qui ne peuvent pas être servis en fonction du stock de médicaments disponible et de leurs demandes.\n\n  Arguments :\n  - total_medicine : La quantité totale de médicaments disponible au début de la journée.\n  - num_patients : Le nombre de patients venant chercher des médicaments.\n  - patient_requests : Un tableau de usize, chacun représentant la quantité de médicaments demandée par un patient, dans l'ordre de leur arrivée.\n\n  Renvoie :\n  - Le nombre de patients qui ne peuvent pas être servis parce que le stock de médicaments est insuffisant.\n\n  Exemple :\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) renvoie 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) renvoie 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) renvoie 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "de": "/*\n  Berechnet die Anzahl der Patienten, die nicht bedient werden können, basierend auf dem verfügbaren Medikamentenbestand und ihren Anfragen.\n\n  Argumente:\n  - total_medicine: Die Gesamtmenge an verfügbaren Medikamenten zu Beginn des Tages.\n  - num_patients: Die Anzahl der Patienten, die kommen, um Medikamente zu erhalten.\n  - patient_requests: Ein Array von usize, das die von einem Patienten angeforderte Menge an Medikamenten in der Reihenfolge ihrer Ankunft darstellt.\n\n  Rückgabe:\n  - Die Anzahl der Patienten, die nicht bedient werden können, weil der Medikamentenbestand unzureichend ist.\n\n  Beispiel:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) gibt 2 zurück\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) gibt 1 zurück\n  - count_unserved_patients(10, 3, &[5, 10, 5]) gibt 1 zurück\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "ha": "/*\n  Lissafa adadin marasa lafiya waɗanda ba za a iya yi wa hidima ba bisa ga adadin magungunan da ake da su da buƙatunsu.\n\n  Huɗɗa:\n  - total_medicine: Jimillar adadin magungunan da ake da su a farkon rana.\n  - num_patients: Yawan marasa lafiya da ke zuwa don samun magani.\n  - patient_requests: Jerin usize, kowanne yana wakiltar adadin magungunan da marasa lafiya ke buƙata, a cikin tsari da suka iso.\n\n  Komawa:\n  - Adadin marasa lafiya waɗanda ba za a iya yi wa hidima ba saboda ƙarancin magunguna.\n\n  Misali:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "hi": "/*\n  उपलब्ध दवा स्टॉक और उनकी मांगों के आधार पर उन मरीजों की संख्या की गणना करता है जिन्हें सेवा नहीं दी जा सकती।\n\n  तर्क:\n  - total_medicine: दिन की शुरुआत में उपलब्ध दवा की कुल मात्रा।\n  - num_patients: दवा लेने आने वाले मरीजों की संख्या।\n  - patient_requests: usize का एक array, प्रत्येक मरीज द्वारा मांगी गई दवा की मात्रा का प्रतिनिधित्व करता है, जिस क्रम में वे आते हैं।\n\n  लौटाता है:\n  - उन मरीजों की संख्या जिन्हें सेवा नहीं दी जा सकती क्योंकि दवा का स्टॉक अपर्याप्त है।\n\n  उदाहरण:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 लौटाता है\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 लौटाता है\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 लौटाता है\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "hu": "/*\n  Kiszámítja azon betegek számát, akiket nem lehet ellátni a rendelkezésre álló gyógyszerkészlet és a kéréseik alapján.\n\n  Argumentumok:\n  - total_medicine: A nap elején rendelkezésre álló gyógyszermennyiség.\n  - num_patients: Az orvosságért érkező betegek száma.\n  - patient_requests: Egy usize tömb, amely minden egyes beteg által kért gyógyszermennyiséget tartalmazza, a megérkezésük sorrendjében.\n\n  Visszatér:\n  - Azon betegek száma, akiket nem lehet ellátni, mert a gyógyszerkészlet nem elegendő.\n\n  Példa:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) visszatér 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) visszatér 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) visszatér 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9861046130643234",
      "hy": "0.9823272591081829",
      "bn": "0.965663361921642",
      "bg": "0.985943523825304",
      "zh": "0.9691429689366111",
      "fr": "0.9867475796077333",
      "de": "0.9817548063500403",
      "ha": "0.9673823092391179",
      "hi": "0.9804311334908239",
      "hu": "0.9725000210064818"
    },
    "canonical_solution": "{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` to solve the following problem:\nCalculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "sq": "Shkruani një funksion Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e pacientëve që nuk mund të shërbehen bazuar në stokun e disponueshëm të ilaçeve dhe kërkesat e tyre.\n\n  Argumentet:\n  - total_medicine: Sasia totale e ilaçeve e disponueshme në fillim të ditës.\n  - num_patients: Numri i pacientëve që vijnë për të marrë ilaçe.\n  - patient_requests: Një varg i usize, secila që përfaqëson sasinë e ilaçeve të kërkuara nga një pacient, sipas renditjes së mbërritjes së tyre.\n\n  Kthen:\n  - Numri i pacientëve që nuk mund të shërbehen sepse stoku i ilaçeve është i pamjaftueshëm.\n\n  Shembull:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) kthen 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) kthen 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) kthen 1",
      "hy": "Գրեք Rust ֆունկցիա `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել առկա դեղորայքի պաշարով և նրանց պահանջներով:\n\n  Արգումենտներ:\n  - total_medicine: Օրվա սկզբում առկա դեղորայքի ընդհանուր քանակը:\n  - num_patients: Հիվանդների քանակը, որոնք գալիս են դեղորայք ստանալու:\n  - patient_requests: usize տիպի զանգված, որը ներկայացնում է յուրաքանչյուր հիվանդի պահանջած դեղորայքի քանակը, ըստ նրանց ժամանման հերթականության:\n\n  Վերադարձնում է:\n  - Այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել, քանի որ դեղորայքի պաշարը բավարար չէ:\n\n  Օրինակ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) վերադարձնում է 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) վերադարձնում է 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) վերադարձնում է 1",
      "bn": "Rust ফাংশন `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nউপলব্ধ ওষুধের মজুদ এবং তাদের অনুরোধের ভিত্তিতে কতজন রোগীকে সেবা দেওয়া যাবে না তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - total_medicine: দিনের শুরুতে উপলব্ধ মোট ওষুধের পরিমাণ।\n  - num_patients: ওষুধ নিতে আসা রোগীর সংখ্যা।\n  - patient_requests: একটি usize এর অ্যারে, প্রতিটি রোগীর অনুরোধকৃত ওষুধের পরিমাণ উপস্থাপন করে, তারা আসার ক্রম অনুযায়ী।\n\n  রিটার্নস:\n  - কতজন রোগীকে সেবা দেওয়া যাবে না কারণ ওষুধের মজুদ অপর্যাপ্ত।\n\n  উদাহরণ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) রিটার্ন করে 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) রিটার্ন করে 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) রিটার্ন করে 1",
      "bg": "Напишете функция на Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize`, за да решите следния проблем:\nИзчислява броя на пациентите, които не могат да бъдат обслужени въз основа на наличния запас от лекарства и техните заявки.\n\n  Аргументи:\n  - total_medicine: Общото количество лекарства, налични в началото на деня.\n  - num_patients: Броят на пациентите, които идват да получат лекарства.\n  - patient_requests: Масив от usize, всеки представляващ количеството лекарства, заявено от пациент, в реда на пристигането им.\n\n  Връща:\n  - Броят на пациентите, които не могат да бъдат обслужени, защото запасът от лекарства е недостатъчен.\n\n  Пример:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) връща 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) връща 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) връща 1",
      "zh": "编写一个 Rust 函数 `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` 来解决以下问题：\n计算由于可用药品库存和患者请求而无法服务的患者数量。\n\n参数：\n- total_medicine: 一天开始时可用的药品总量。\n- num_patients: 前来领取药品的患者数量。\n- patient_requests: 一个 usize 数组，每个元素表示患者到达时请求的药品数量。\n\n返回值：\n- 无法服务的患者数量，因为药品库存不足。\n\n示例：\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 返回 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) 返回 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) 返回 1",
      "fr": "Écrire une fonction Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` pour résoudre le problème suivant :\nCalcule le nombre de patients qui ne peuvent pas être servis en fonction du stock de médicaments disponible et de leurs demandes.\n\n  Arguments :\n  - total_medicine : La quantité totale de médicaments disponible au début de la journée.\n  - num_patients : Le nombre de patients venant chercher des médicaments.\n  - patient_requests : Un tableau de usize, chacun représentant la quantité de médicaments demandée par un patient, dans l'ordre de leur arrivée.\n\n  Renvoie :\n  - Le nombre de patients qui ne peuvent pas être servis car le stock de médicaments est insuffisant.\n\n  Exemple :\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) renvoie 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) renvoie 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) renvoie 1",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Patienten, die nicht bedient werden können, basierend auf dem verfügbaren Medikamentenvorrat und ihren Anfragen.\n\n  Argumente:\n  - total_medicine: Die Gesamtmenge an Medikamenten, die zu Beginn des Tages verfügbar ist.\n  - num_patients: Die Anzahl der Patienten, die kommen, um Medikamente zu erhalten.\n  - patient_requests: Ein Array von usize, das die Menge an Medikamenten darstellt, die von einem Patienten in der Reihenfolge ihrer Ankunft angefordert wird.\n\n  Rückgabewert:\n  - Die Anzahl der Patienten, die nicht bedient werden können, weil der Medikamentenvorrat unzureichend ist.\n\n  Beispiel:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) gibt 2 zurück\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) gibt 1 zurück\n  - count_unserved_patients(10, 3, &[5, 10, 5]) gibt 1 zurück",
      "ha": "Rubuta aikin Rust `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` don warware matsalar mai zuwa:\nƘididdige adadin marasa lafiya waɗanda ba za a iya yi musu hidima ba bisa ga adadin magungunan da ake da su da buƙatunsu.\n\n  Huɗɗa:\n  - total_medicine: Jimillar adadin magunguna da ake da su a farkon rana.\n  - num_patients: Adadin marasa lafiya da ke zuwa don samun magani.\n  - patient_requests: Jeri na usize, kowanne yana wakiltar adadin magunguna da mara lafiya ke nema, a cikin tsari da suka iso.\n\n  Mayar da:\n  - Adadin marasa lafiya waɗanda ba za a iya yi musu hidima ba saboda adadin magunguna bai isa ba.\n\n  Misali:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "hi": "Rust फ़ंक्शन `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउपलब्ध दवा स्टॉक और उनकी अनुरोधों के आधार पर उन मरीजों की संख्या की गणना करता है जिन्हें सेवा नहीं दी जा सकती।\n\n  तर्क:\n  - total_medicine: दिन की शुरुआत में उपलब्ध कुल दवा की मात्रा।\n  - num_patients: दवा लेने के लिए आने वाले मरीजों की संख्या।\n  - patient_requests: usize का एक array, प्रत्येक उस दवा की मात्रा का प्रतिनिधित्व करता है जो एक मरीज द्वारा अनुरोध की गई है, जिस क्रम में वे आते हैं।\n\n  लौटाता है:\n  - उन मरीजों की संख्या जिन्हें सेवा नहीं दी जा सकती क्योंकि दवा का स्टॉक अपर्याप्त है।\n\n  उदाहरण:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 लौटाता है\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 लौटाता है\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize` a következő probléma megoldására:\nKiszámítja azon betegek számát, akiket nem lehet kiszolgálni a rendelkezésre álló gyógyszerkészlet és a kéréseik alapján.\n\n  Argumentumok:\n  - total_medicine: A nap elején rendelkezésre álló teljes gyógyszermennyiség.\n  - num_patients: A betegek száma, akik gyógyszert szeretnének kapni.\n  - patient_requests: Egy usize tömb, amely minden egyes beteg által kért gyógyszermennyiséget tartalmazza, a megérkezésük sorrendjében.\n\n  Visszatér:\n  - Azon betegek száma, akiket nem lehet kiszolgálni, mert a gyógyszerkészlet nem elegendő.\n\n  Példa:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) visszaadja 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) visszaadja 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9866709082806538",
      "hy": "0.9772679446728433",
      "bn": "0.9676274191293149",
      "bg": "0.9812894153672757",
      "zh": "0.9609742945165514",
      "fr": "0.9889066918495826",
      "de": "0.9851301324149662",
      "ha": "0.9777241986580804",
      "hi": "0.9788244123386326",
      "hu": "0.9874908544935659"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]), 2);\n        assert_eq!(count_unserved_patients(50, 4, &[10, 15, 10, 20]), 1);\n        assert_eq!(count_unserved_patients(10, 3, &[5, 10, 5]), 1);\n        assert_eq!(count_unserved_patients(20, 5, &[4, 5, 7, 3, 2]), 1);\n        \n    }\n    \n\n}",
    "entry_point": "count_unserved_patients",
    "signature": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize",
    "docstring": {
      "en": "Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "sq": "Llogarit numrin e pacientëve që nuk mund të shërbehen bazuar në stokun e disponueshëm të ilaçeve dhe kërkesat e tyre.\n\n  Argumentet:\n  - total_medicine: Sasia totale e ilaçeve në dispozicion në fillim të ditës.\n  - num_patients: Numri i pacientëve që vijnë për të marrë ilaçe.\n  - patient_requests: Një varg i usize, secili që përfaqëson sasinë e ilaçeve të kërkuara nga një pacient, sipas renditjes së mbërritjes së tyre.\n\n  Kthen:\n  - Numri i pacientëve që nuk mund të shërbehen sepse stoku i ilaçeve është i pamjaftueshëm.\n\n  Shembull:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) kthen 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) kthen 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) kthen 1",
      "hy": "Հաշվում է այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել առկա դեղամիջոցների պաշարների և նրանց պահանջների հիման վրա։\n\n  Արգումենտներ:\n  - total_medicine: Օրվա սկզբում առկա դեղամիջոցների ընդհանուր քանակը։\n  - num_patients: Դեղամիջոց ստանալու համար եկող հիվանդների քանակը։\n  - patient_requests: usize տիպի զանգված, որը ներկայացնում է յուրաքանչյուր հիվանդի պահանջած դեղամիջոցի քանակը՝ ըստ նրանց ժամանման կարգի։\n\n  Վերադարձնում է:\n  - Այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել, քանի որ դեղամիջոցների պաշարը բավարար չէ։\n\n  Օրինակ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) վերադարձնում է 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) վերադարձնում է 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) վերադարձնում է 1",
      "bn": "রোগীদের সংখ্যা গণনা করে যারা উপলব্ধ ওষুধের মজুদ এবং তাদের অনুরোধের ভিত্তিতে সেবা পেতে পারে না।\n\nআর্গুমেন্টস:\n- total_medicine: দিনের শুরুতে উপলব্ধ মোট ওষুধের পরিমাণ।\n- num_patients: ওষুধ নিতে আসা রোগীদের সংখ্যা।\n- patient_requests: একটি usize এর অ্যারে, প্রতিটি রোগীর অনুরোধ করা ওষুধের পরিমাণ উপস্থাপন করে, তারা আসার ক্রম অনুযায়ী।\n\nরিটার্নস:\n- রোগীদের সংখ্যা যারা সেবা পেতে পারে না কারণ ওষুধের মজুদ অপর্যাপ্ত।\n\nউদাহরণ:\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) রিটার্ন করে 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) রিটার্ন করে 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) রিটার্ন করে 1",
      "bg": "Изчислява броя на пациентите, които не могат да бъдат обслужени въз основа на наличния запас от лекарства и техните заявки.\n\nАргументи:\n- total_medicine: Общото количество лекарства, налично в началото на деня.\n- num_patients: Броят на пациентите, които идват да получат лекарства.\n- patient_requests: Масив от usize, всеки представляващ количеството лекарства, заявено от пациент, в реда на пристигането им.\n\nВръща:\n- Броят на пациентите, които не могат да бъдат обслужени, защото запасът от лекарства е недостатъчен.\n\nПример:\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) връща 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) връща 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) връща 1",
      "zh": "计算基于可用药品库存和患者请求无法服务的患者数量。\n\n参数：\n- total_medicine: 一天开始时可用的药品总量。\n- num_patients: 前来领取药品的患者数量。\n- patient_requests: 一个usize数组，每个元素代表患者请求的药品数量，按照他们到达的顺序排列。\n\n返回：\n- 因药品库存不足而无法服务的患者数量。\n\n示例：\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 返回 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) 返回 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) 返回 1",
      "fr": "Calcule le nombre de patients qui ne peuvent pas être servis en fonction du stock de médicaments disponible et de leurs demandes.\n\n  Arguments:\n  - total_medicine: La quantité totale de médicaments disponible au début de la journée.\n  - num_patients: Le nombre de patients venant chercher des médicaments.\n  - patient_requests: Un tableau de usize, chacun représentant la quantité de médicaments demandée par un patient, dans l'ordre de leur arrivée.\n\n  Retourne:\n  - Le nombre de patients qui ne peuvent pas être servis parce que le stock de médicaments est insuffisant.\n\n  Exemple:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) retourne 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) retourne 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) retourne 1",
      "de": "Berechnet die Anzahl der Patienten, die aufgrund des verfügbaren Medikamentenbestands und ihrer Anfragen nicht bedient werden können.\n\n  Argumente:\n  - total_medicine: Die Gesamtmenge an verfügbaren Medikamenten zu Beginn des Tages.\n  - num_patients: Die Anzahl der Patienten, die kommen, um Medikamente zu erhalten.\n  - patient_requests: Ein Array von usize, das jeweils die Menge an Medikamenten darstellt, die von einem Patienten in der Reihenfolge seiner Ankunft angefordert wird.\n\n  Rückgabewert:\n  - Die Anzahl der Patienten, die nicht bedient werden können, weil der Medikamentenbestand nicht ausreicht.\n\n  Beispiel:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) gibt 2 zurück\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) gibt 1 zurück\n  - count_unserved_patients(10, 3, &[5, 10, 5]) gibt 1 zurück",
      "ha": "Lissafa adadin marasa lafiya waɗanda ba za a iya yi wa hidima ba bisa ga adadin magungunan da ake da su da buƙatunsu.\n\n  Huɗɗa:\n  - total_medicine: Jimillar adadin magani da ake da shi a farkon rana.\n  - num_patients: Yawan marasa lafiya da ke zuwa don samun magani.\n  - patient_requests: Jeri na usize, kowanne yana wakiltar adadin magani da mara lafiya ke nema, a cikin tsari da suka iso.\n\n  Komawa:\n  - Yawan marasa lafiya da ba za a iya bauta musu ba saboda adadin magani bai isa ba.\n\n  Misali:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "hi": "मरीजों की संख्या की गणना करता है जिन्हें उपलब्ध दवा स्टॉक और उनकी मांगों के आधार पर सेवा नहीं दी जा सकती।\n\n  तर्क:\n  - total_medicine: दिन की शुरुआत में उपलब्ध कुल दवा की मात्रा।\n  - num_patients: दवा लेने आने वाले मरीजों की संख्या।\n  - patient_requests: usize का एक array, प्रत्येक मरीज द्वारा मांगी गई दवा की मात्रा को दर्शाता है, जिस क्रम में वे आते हैं।\n\n  वापसी:\n  - उन मरीजों की संख्या जिन्हें सेवा नहीं दी जा सकती क्योंकि दवा का स्टॉक अपर्याप्त है।\n\n  उदाहरण:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 लौटाता है\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 लौटाता है\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 लौटाता है",
      "hu": "Számítja azon betegek számát, akiket nem lehet kiszolgálni a rendelkezésre álló gyógyszerkészlet és az ő igényeik alapján.\n\n  Argumentumok:\n  - total_medicine: A nap elején rendelkezésre álló teljes gyógyszermennyiség.\n  - num_patients: Azoknak a betegeknek a száma, akik gyógyszert szeretnének kapni.\n  - patient_requests: Egy usize tömb, amely minden egyes beteg által igényelt gyógyszermennyiséget képvisel, az érkezésük sorrendjében.\n\n  Visszatér:\n  - Azoknak a betegeknek a száma, akiket nem lehet kiszolgálni, mert a gyógyszerkészlet nem elegendő.\n\n  Példa:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) visszatér 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) visszatér 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) visszatér 1"
    },
    "docstring_bertscore": {
      "sq": "0.9818068475098715",
      "hy": "0.9814799019026881",
      "bn": "0.9670938979258552",
      "bg": "0.98071060643694",
      "zh": "0.967240487147059",
      "fr": "0.9816433747062798",
      "de": "0.9806774351633071",
      "ha": "0.9677640768314669",
      "hi": "0.9826325540038335",
      "hu": "0.9819099366776286"
    }
  },
  {
    "task_id": "Rust/23",
    "prompt": {
      "en": "/*\n  Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "sq": "/*\n  Përcakton nëse një sekuencë është një \"Jolly Jumper\". Një sekuencë konsiderohet \"Jolly Jumper\" nëse diferencat absolute midis elementeve të njëpasnjëshme, kur renditen, formojnë një sekuencë numrash të njëpasnjëshëm duke filluar nga 1. Për shembull, një sekuencë e [3, 1, 4, 2] është një Jolly Jumper sepse diferencat absolute janë 2, 3, 2, duke formuar një sekuencë të njëpasnjëshme 1, 2, 3. Një sekuencë me një element të vetëm është gjithmonë një Jolly Jumper.\n\n  Argumentet:\n  - sequence: Një pjesë e numrave të plotë, që përfaqëson sekuencën.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca është një Jolly Jumper.\n\n  Shembuj:\n  - is_jolly_jumper(&[1, 4, 2, 3]) kthen true.\n  - is_jolly_jumper(&[1, 3]) kthen false.\n  - is_jolly_jumper(&[5]) kthen true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "hy": "/*\n  Որոշում է՝ արդյոք հաջորդականությունը \"Jolly Jumper\" է։ Հաջորդականությունը համարվում է \"Jolly Jumper\", եթե հաջորդական տարրերի միջև բացարձակ տարբերությունները, երբ դասավորված են, ձևավորում են հաջորդական թվերի հաջորդականություն սկսած 1-ից։ Օրինակ, [3, 1, 4, 2] հաջորդականությունը Jolly Jumper է, որովհետև բացարձակ տարբերությունները 2, 3, 2 են, ձևավորելով հաջորդականություն 1, 2, 3։ Միակ տարրով հաջորդականությունը միշտ Jolly Jumper է։\n\n  Փաստարկներ:\n  - sequence: Թվերի հաջորդականություն, ներկայացնող հաջորդականությունը։\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հաջորդականությունը Jolly Jumper է։\n\n  Օրինակներ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) վերադարձնում է true։\n  - is_jolly_jumper(&[1, 3]) վերադարձնում է false։\n  - is_jolly_jumper(&[5]) վերադարձնում է true։\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "bn": "/*\n  নির্ধারণ করে যে একটি ক্রম \"Jolly Jumper\" কিনা। একটি ক্রমকে \"Jolly Jumper\" বিবেচনা করা হয় যদি ধারাবাহিক উপাদানগুলির মধ্যে পার্থক্যের মানগুলি, যখন সাজানো হয়, 1 থেকে শুরু করে ধারাবাহিক সংখ্যার একটি ক্রম গঠন করে। উদাহরণস্বরূপ, [3, 1, 4, 2] এর একটি ক্রম একটি Jolly Jumper কারণ পার্থক্যের মানগুলি 2, 3, 2, যা একটি ধারাবাহিক ক্রম 1, 2, 3 গঠন করে। একটি একক উপাদানের ক্রম সর্বদা একটি Jolly Jumper হয়।\n\n  আর্গুমেন্ট:\n  - sequence: পূর্ণসংখ্যার একটি স্লাইস, যা ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি Jolly Jumper কিনা।\n\n  উদাহরণ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true রিটার্ন করে।\n  - is_jolly_jumper(&[1, 3]) false রিটার্ন করে।\n  - is_jolly_jumper(&[5]) true রিটার্ন করে।\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "bg": "/*\n  Определя дали една последователност е \"Jolly Jumper\". Последователност се счита за \"Jolly Jumper\", ако абсолютните разлики между последователните елементи, когато са сортирани, образуват последователност от поредни числа, започващи от 1. Например, последователност от [3, 1, 4, 2] е Jolly Jumper, защото абсолютните разлики са 2, 3, 2, образувайки поредна последователност 1, 2, 3. Последователност с един елемент винаги е Jolly Jumper.\n\n  Аргументи:\n  - sequence: Срез от цели числа, представляващи последователността.\n\n  Връща:\n  - Булева стойност, указваща дали последователността е Jolly Jumper.\n\n  Примери:\n  - is_jolly_jumper(&[1, 4, 2, 3]) връща true.\n  - is_jolly_jumper(&[1, 3]) връща false.\n  - is_jolly_jumper(&[5]) връща true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "zh": "/*\n  判断一个序列是否为“Jolly Jumper”。如果连续元素之间的绝对差在排序后形成从1开始的连续数字序列，则该序列被认为是“Jolly Jumper”。例如，[3, 1, 4, 2]的序列是一个Jolly Jumper，因为绝对差是2, 3, 2，形成了连续序列1, 2, 3。单个元素的序列总是Jolly Jumper。\n\n  参数:\n  - sequence: 整数切片，表示序列。\n\n  返回:\n  - 一个布尔值，指示该序列是否为Jolly Jumper。\n\n  示例:\n  - is_jolly_jumper(&[1, 4, 2, 3]) 返回 true.\n  - is_jolly_jumper(&[1, 3]) 返回 false.\n  - is_jolly_jumper(&[5]) 返回 true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "fr": "/*\n  Détermine si une séquence est un \"Jolly Jumper\". Une séquence est considérée comme un \"Jolly Jumper\" si les différences absolues entre les éléments successifs, une fois triées, forment une séquence de nombres consécutifs commençant par 1. Par exemple, une séquence de [3, 1, 4, 2] est un Jolly Jumper car les différences absolues sont 2, 3, 2, formant une séquence consécutive 1, 2, 3. Une séquence avec un seul élément est toujours un Jolly Jumper.\n\n  Arguments :\n  - sequence: Une tranche d'entiers, représentant la séquence.\n\n  Renvoie :\n  - Une valeur booléenne indiquant si la séquence est un Jolly Jumper.\n\n  Exemples :\n  - is_jolly_jumper(&[1, 4, 2, 3]) renvoie true.\n  - is_jolly_jumper(&[1, 3]) renvoie false.\n  - is_jolly_jumper(&[5]) renvoie true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "de": "/*\n  Bestimmt, ob eine Sequenz ein \"Jolly Jumper\" ist. Eine Sequenz wird als \"Jolly Jumper\" betrachtet, wenn die absoluten Differenzen zwischen aufeinanderfolgenden Elementen, wenn sie sortiert sind, eine Sequenz aufeinanderfolgender Zahlen bilden, beginnend mit 1. Zum Beispiel ist eine Sequenz von [3, 1, 4, 2] ein Jolly Jumper, weil die absoluten Differenzen 2, 3, 2 sind, was eine aufeinanderfolgende Sequenz 1, 2, 3 bildet. Eine Sequenz mit einem einzigen Element ist immer ein Jolly Jumper.\n\n  Argumente:\n  - sequence: Ein Slice von Ganzzahlen, das die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Sequenz ein Jolly Jumper ist.\n\n  Beispiele:\n  - is_jolly_jumper(&[1, 4, 2, 3]) gibt true zurück.\n  - is_jolly_jumper(&[1, 3]) gibt false zurück.\n  - is_jolly_jumper(&[5]) gibt true zurück.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "ha": "/*\n  Yana tantancewa idan jerin lambobi \"Jolly Jumper\" ne. Ana ɗaukar jerin lambobi a matsayin \"Jolly Jumper\" idan bambance-bambancen darajoji tsakanin kowane lamba, idan an jera su, suna samar da jerin lambobi masu jere daga 1. Alal misali, jerin lambobi na [3, 1, 4, 2] Jolly Jumper ne domin bambance-bambancen darajoji su ne 2, 3, 2, suna samar da jerin lambobi masu jere 1, 2, 3. Jerin lambobi da ke da lamba guda ɗaya koyaushe Jolly Jumper ne.\n\n  Huɗɗa:\n  - sequence: Wani yanki na lambobi, yana wakiltar jerin lambobi.\n\n  Komawa:\n  - Wani ƙimar boolean da ke nuna ko jerin lambobin Jolly Jumper ne.\n\n  Misalai:\n  - is_jolly_jumper(&[1, 4, 2, 3]) yana dawowa da true.\n  - is_jolly_jumper(&[1, 3]) yana dawowa da false.\n  - is_jolly_jumper(&[5]) yana dawowa da true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "hi": "/*\n  यह निर्धारित करता है कि कोई अनुक्रम \"Jolly Jumper\" है या नहीं। यदि क्रमिक तत्वों के बीच के परिपूर्ण अंतर, जब क्रमबद्ध किए जाते हैं, तो 1 से शुरू होने वाले क्रमिक संख्याओं का अनुक्रम बनाते हैं, तो अनुक्रम को \"Jolly Jumper\" माना जाता है। उदाहरण के लिए, [3, 1, 4, 2] का अनुक्रम एक Jolly Jumper है क्योंकि परिपूर्ण अंतर 2, 3, 2 हैं, जो 1, 2, 3 का क्रमिक अनुक्रम बनाते हैं। एकल तत्व वाला अनुक्रम हमेशा Jolly Jumper होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों की एक श्रेणी, जो अनुक्रम का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक boolean मान जो यह संकेत करता है कि अनुक्रम Jolly Jumper है या नहीं।\n\n  उदाहरण:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true लौटाता है।\n  - is_jolly_jumper(&[1, 3]) false लौटाता है।\n  - is_jolly_jumper(&[5]) true लौटाता है।\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "hu": "/*\n  Meghatározza, hogy egy sorozat \"Jolly Jumper\"-e. Egy sorozat akkor tekinthető \"Jolly Jumper\"-nek, ha az egymást követő elemek közötti abszolút különbségek, ha sorba rendezzük őket, egy egymást követő számokból álló sorozatot alkotnak, amely 1-től kezdődik. Például a [3, 1, 4, 2] sorozat egy Jolly Jumper, mert az abszolút különbségek 2, 3, 2, amelyek egy egymást követő sorozatot alkotnak: 1, 2, 3. Egyetlen elemből álló sorozat mindig Jolly Jumper.\n\n  Argumentumok:\n  - sequence: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatér:\n  - Egy logikai érték, amely jelzi, hogy a sorozat Jolly Jumper-e.\n\n  Példák:\n  - is_jolly_jumper(&[1, 4, 2, 3]) visszatér true.\n  - is_jolly_jumper(&[1, 3]) visszatér false.\n  - is_jolly_jumper(&[5]) visszatér true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "sq": "0.9975055996749639",
      "hy": "0.9807795311791591",
      "bn": "0.9834489248698869",
      "bg": "0.9952310831817334",
      "zh": "0.970718902379742",
      "fr": "0.9975469147942191",
      "de": "0.9904135019201132",
      "ha": "0.9712037591398481",
      "hi": "0.970781669580149",
      "hu": "0.9844635288562131"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}",
    "instruction": {
      "en": "Write a Rust function `fn is_jolly_jumper(sequence: &[i32]) -> bool` to solve the following problem:\nDetermines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.",
      "sq": "Shkruani një funksion Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse një sekuencë është një \"Jolly Jumper\". Një sekuencë konsiderohet \"Jolly Jumper\" nëse diferencat absolute midis elementeve pasuese, kur renditen, formojnë një sekuencë numrash të njëpasnjëshëm duke filluar nga 1. Për shembull, një sekuencë e [3, 1, 4, 2] është një Jolly Jumper sepse diferencat absolute janë 2, 3, 2, duke formuar një sekuencë të njëpasnjëshme 1, 2, 3. Një sekuencë me një element të vetëm është gjithmonë një Jolly Jumper.\n\n  Argumentet:\n  - sequence: Një prerje e numrave të plotë, që përfaqëson sekuencën.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca është një Jolly Jumper.\n\n  Shembuj:\n  - is_jolly_jumper(&[1, 4, 2, 3]) kthen true.\n  - is_jolly_jumper(&[1, 3]) kthen false.\n  - is_jolly_jumper(&[5]) kthen true.",
      "hy": "Գրեք Rust ֆունկցիա `fn is_jolly_jumper(sequence: &[i32]) -> bool` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է, արդյոք հաջորդականությունը \"Jolly Jumper\" է: Հաջորդականությունը համարվում է \"Jolly Jumper\", եթե հաջորդական տարրերի միջև բացարձակ տարբերությունները, երբ դասավորված են, ձևավորում են հաջորդական թվերի հաջորդականություն սկսած 1-ից: Օրինակ, [3, 1, 4, 2] հաջորդականությունը Jolly Jumper է, քանի որ բացարձակ տարբերությունները 2, 3, 2 են, ձևավորելով հաջորդական հաջորդականություն 1, 2, 3: Միայն մեկ տարր ունեցող հաջորդականությունը միշտ Jolly Jumper է:\n\n  Արգումենտներ:\n  - sequence: Թվերի հաջորդականություն, ներկայացնող հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս, արդյոք հաջորդականությունը Jolly Jumper է:\n\n  Օրինակներ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) վերադարձնում է true:\n  - is_jolly_jumper(&[1, 3]) վերադարձնում է false:\n  - is_jolly_jumper(&[5]) վերադարձնում է true:",
      "bn": "Rust ফাংশন `fn is_jolly_jumper(sequence: &[i32]) -> bool` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nনির্ধারণ করে একটি সিকোয়েন্স \"Jolly Jumper\" কিনা। একটি সিকোয়েন্সকে \"Jolly Jumper\" বলা হয় যদি পরপর উপাদানগুলির মধ্যে পার্থক্যের মান, যখন সাজানো হয়, 1 থেকে শুরু করে ধারাবাহিক সংখ্যার একটি সিকোয়েন্স গঠন করে। উদাহরণস্বরূপ, [3, 1, 4, 2] এর একটি সিকোয়েন্স একটি Jolly Jumper কারণ পার্থক্যের মান 2, 3, 2, যা 1, 2, 3 ধারাবাহিক সিকোয়েন্স গঠন করে। একটি একক উপাদান বিশিষ্ট সিকোয়েন্স সর্বদা একটি Jolly Jumper।\n\n  আর্গুমেন্টসমূহ:\n  - sequence: পূর্ণসংখ্যার একটি স্লাইস, যা সিকোয়েন্স উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে সিকোয়েন্সটি একটি Jolly Jumper কিনা।\n\n  উদাহরণসমূহ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true রিটার্ন করে।\n  - is_jolly_jumper(&[1, 3]) false রিটার্ন করে।\n  - is_jolly_jumper(&[5]) true রিটার্ন করে।",
      "bg": "Напишете функция на Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool`, за да решите следния проблем:\nОпределя дали една последователност е \"Jolly Jumper\". Последователност се счита за \"Jolly Jumper\", ако абсолютните разлики между последователните елементи, когато са сортирани, образуват последователност от поредни числа, започващи от 1. Например, последователност от [3, 1, 4, 2] е Jolly Jumper, защото абсолютните разлики са 2, 3, 2, образувайки поредна последователност 1, 2, 3. Последователност с един елемент винаги е Jolly Jumper.\n\n  Аргументи:\n  - sequence: Срез от цели числа, представляващ последователността.\n\n  Връща:\n  - Булева стойност, указваща дали последователността е Jolly Jumper.\n\n  Примери:\n  - is_jolly_jumper(&[1, 4, 2, 3]) връща true.\n  - is_jolly_jumper(&[1, 3]) връща false.\n  - is_jolly_jumper(&[5]) връща true.",
      "zh": "编写一个 Rust 函数 `fn is_jolly_jumper(sequence: &[i32]) -> bool` 来解决以下问题：\n确定一个序列是否为“Jolly Jumper”。如果连续元素之间的绝对差在排序后形成一个从1开始的连续数字序列，则该序列被认为是“Jolly Jumper”。例如，[3, 1, 4, 2] 的序列是一个 Jolly Jumper，因为绝对差为 2, 3, 2，形成了一个连续序列 1, 2, 3。单个元素的序列总是一个 Jolly Jumper。\n\n  参数：\n  - sequence: 整数切片，表示序列。\n\n  返回：\n  - 一个布尔值，指示序列是否为 Jolly Jumper。\n\n  示例：\n  - is_jolly_jumper(&[1, 4, 2, 3]) 返回 true。\n  - is_jolly_jumper(&[1, 3]) 返回 false。\n  - is_jolly_jumper(&[5]) 返回 true。",
      "fr": "Écrire une fonction Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` pour résoudre le problème suivant :\nDétermine si une séquence est un \"Jolly Jumper\". Une séquence est considérée comme un \"Jolly Jumper\" si les différences absolues entre les éléments successifs, une fois triées, forment une séquence de nombres consécutifs commençant par 1. Par exemple, une séquence de [3, 1, 4, 2] est un Jolly Jumper car les différences absolues sont 2, 3, 2, formant une séquence consécutive 1, 2, 3. Une séquence avec un seul élément est toujours un Jolly Jumper.\n\n  Arguments :\n  - sequence: Une tranche d'entiers, représentant la séquence.\n\n  Renvoie :\n  - Une valeur booléenne indiquant si la séquence est un Jolly Jumper.\n\n  Exemples :\n  - is_jolly_jumper(&[1, 4, 2, 3]) renvoie true.\n  - is_jolly_jumper(&[1, 3]) renvoie false.\n  - is_jolly_jumper(&[5]) renvoie true.",
      "de": "Schreiben Sie eine Rust-Funktion `fn is_jolly_jumper(sequence: &[i32]) -> bool`, um das folgende Problem zu lösen:\nBestimmt, ob eine Sequenz ein \"Jolly Jumper\" ist. Eine Sequenz wird als \"Jolly Jumper\" betrachtet, wenn die absoluten Differenzen zwischen aufeinanderfolgenden Elementen, wenn sortiert, eine Sequenz von aufeinanderfolgenden Zahlen bilden, beginnend mit 1. Zum Beispiel ist eine Sequenz von [3, 1, 4, 2] ein Jolly Jumper, weil die absoluten Differenzen 2, 3, 2 sind, was eine aufeinanderfolgende Sequenz 1, 2, 3 bildet. Eine Sequenz mit einem einzigen Element ist immer ein Jolly Jumper.\n\n  Argumente:\n  - sequence: Ein Slice von Ganzzahlen, das die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Sequenz ein Jolly Jumper ist.\n\n  Beispiele:\n  - is_jolly_jumper(&[1, 4, 2, 3]) gibt true zurück.\n  - is_jolly_jumper(&[1, 3]) gibt false zurück.\n  - is_jolly_jumper(&[5]) gibt true zurück.",
      "ha": "Rubuta aikin Rust `fn is_jolly_jumper(sequence: &[i32]) -> bool` don warware matsalar mai zuwa:\nYana tantance ko jerin lambobi \"Jolly Jumper\" ne. Ana ɗaukar jerin lambobi a matsayin \"Jolly Jumper\" idan bambance-bambancen ƙima tsakanin abubuwa masu zuwa, lokacin da aka jera su, suna samar da jerin lambobi masu jere daga 1. Alal misali, jerin lambobi na [3, 1, 4, 2] Jolly Jumper ne saboda bambance-bambancen ƙima su ne 2, 3, 2, suna samar da jerin lambobi masu jere 1, 2, 3. Jerin lambobi da ke da abu guda koyaushe Jolly Jumper ne.\n\n  Huɗɗa:\n  - sequence: Yanki na lambobi, yana wakiltar jerin lambobi.\n\n  Dawowa:\n  - Ƙimar boolean da ke nuna ko jerin lambobin Jolly Jumper ne.\n\n  Misalai:\n  - is_jolly_jumper(&[1, 4, 2, 3]) yana dawowa true.\n  - is_jolly_jumper(&[1, 3]) yana dawowa false.\n  - is_jolly_jumper(&[5]) yana dawowa true.",
      "hi": "Rust फ़ंक्शन `fn is_jolly_jumper(sequence: &[i32]) -> bool` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करता है कि कोई अनुक्रम \"Jolly Jumper\" है या नहीं। किसी अनुक्रम को \"Jolly Jumper\" माना जाता है यदि क्रमिक तत्वों के बीच के परिपूर्ण अंतर, जब क्रमबद्ध किए जाते हैं, तो 1 से शुरू होने वाले क्रमिक संख्याओं का अनुक्रम बनाते हैं। उदाहरण के लिए, [3, 1, 4, 2] का अनुक्रम एक Jolly Jumper है क्योंकि परिपूर्ण अंतर 2, 3, 2 हैं, जो एक क्रमिक अनुक्रम 1, 2, 3 बनाते हैं। एकल तत्व वाला अनुक्रम हमेशा एक Jolly Jumper होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक स्लाइस, जो अनुक्रम को दर्शाता है।\n\n  लौटाता है:\n  - एक बूलियन मान जो यह दर्शाता है कि अनुक्रम एक Jolly Jumper है या नहीं।\n\n  उदाहरण:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true लौटाता है।\n  - is_jolly_jumper(&[1, 3]) false लौटाता है।\n  - is_jolly_jumper(&[5]) true लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn is_jolly_jumper(sequence: &[i32]) -> bool` a következő probléma megoldására:\nMegállapítja, hogy egy sorozat \"Jolly Jumper\"-e. Egy sorozat akkor tekinthető \"Jolly Jumper\"-nek, ha az egymást követő elemek közötti abszolút különbségek, amikor sorba vannak rendezve, egy egymást követő számokból álló sorozatot alkotnak, amely 1-től kezdődik. Például a [3, 1, 4, 2] sorozat Jolly Jumper, mert az abszolút különbségek 2, 3, 2, amelyek egy egymást követő sorozatot alkotnak: 1, 2, 3. Egyetlen elemből álló sorozat mindig Jolly Jumper.\n\n  Argumentumok:\n  - sequence: Egy egész számokból álló szelet, amely a sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat Jolly Jumper-e.\n\n  Példák:\n  - is_jolly_jumper(&[1, 4, 2, 3]) visszaadja, hogy true.\n  - is_jolly_jumper(&[1, 3]) visszaadja, hogy false.\n  - is_jolly_jumper(&[5]) visszaadja, hogy true."
    },
    "instruction_bertscore": {
      "sq": "0.9900559672342504",
      "hy": "0.9797893587297001",
      "bn": "0.9693648390722271",
      "bg": "0.983819767791279",
      "zh": "0.9760847034930185",
      "fr": "0.9926580252258075",
      "de": "0.9904216457657357",
      "ha": "0.9803969690652858",
      "hi": "0.9788518233312155",
      "hu": "0.9867394357621109"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_jolly_jumper(&[1, 4, 2, 3]), true);\n        assert_eq!(is_jolly_jumper(&[1, 3]), false);\n        assert_eq!(is_jolly_jumper(&[5]), true);\n        assert_eq!(is_jolly_jumper(&[10, 7, 8, 9]), false);\n    }\n    \n\n}",
    "entry_point": "is_jolly_jumper",
    "signature": "fn is_jolly_jumper(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.",
      "sq": "Përcakton nëse një sekuencë është një \"Jolly Jumper\". Një sekuencë konsiderohet \"Jolly Jumper\" nëse diferencat absolute midis elementeve të njëpasnjëshme, kur renditen, formojnë një sekuencë numrash të njëpasnjëshëm duke filluar nga 1. Për shembull, një sekuencë e [3, 1, 4, 2] është një Jolly Jumper sepse diferencat absolute janë 2, 3, 2, duke formuar një sekuencë të njëpasnjëshme 1, 2, 3. Një sekuencë me një element të vetëm është gjithmonë një Jolly Jumper.\n\n  Argumentet:\n  - sequence: Një pjesë e numrave të plotë, që përfaqëson sekuencën.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca është një Jolly Jumper.\n\n  Shembuj:\n  - is_jolly_jumper(&[1, 4, 2, 3]) kthen true.\n  - is_jolly_jumper(&[1, 3]) kthen false.\n  - is_jolly_jumper(&[5]) kthen true.",
      "hy": "Որոշում է՝ արդյոք հաջորդականությունը \"Jolly Jumper\" է: Հաջորդականությունը համարվում է \"Jolly Jumper\", եթե հաջորդական տարրերի միջև բացարձակ տարբերությունները, երբ դասավորված են, կազմում են հաջորդական թվերի հաջորդականություն սկսած 1-ից: Օրինակ, [3, 1, 4, 2] հաջորդականությունը Jolly Jumper է, քանի որ բացարձակ տարբերությունները 2, 3, 2 են, որոնք կազմում են հաջորդական հաջորդականություն 1, 2, 3: Միայն մեկ տարր ունեցող հաջորդականությունը միշտ Jolly Jumper է:\n\n  Արգումենտներ:\n  - sequence: Թվերի հաջորդականություն, որը ներկայացնում է հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հաջորդականությունը Jolly Jumper է:\n\n  Օրինակներ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) վերադարձնում է true:\n  - is_jolly_jumper(&[1, 3]) վերադարձնում է false:\n  - is_jolly_jumper(&[5]) վերադարձնում է true:",
      "bn": "নির্ধারণ করে যদি একটি সিকোয়েন্স \"Jolly Jumper\" হয়। একটি সিকোয়েন্সকে \"Jolly Jumper\" বিবেচনা করা হয় যদি ধারাবাহিক উপাদানগুলির মধ্যে পার্থক্যের মান, যখন সাজানো হয়, ১ থেকে শুরু করে ধারাবাহিক সংখ্যার একটি সিকোয়েন্স গঠন করে। উদাহরণস্বরূপ, [3, 1, 4, 2] এর একটি সিকোয়েন্স একটি Jolly Jumper কারণ মানের পার্থক্যগুলি 2, 3, 2, যা একটি ধারাবাহিক সিকোয়েন্স 1, 2, 3 গঠন করে। একটি একক উপাদান সহ সিকোয়েন্স সর্বদা একটি Jolly Jumper হয়।\n\n  আর্গুমেন্টস:\n  - sequence: পূর্ণসংখ্যার একটি স্লাইস, যা সিকোয়েন্সকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে সিকোয়েন্সটি একটি Jolly Jumper কিনা।\n\n  উদাহরণ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true রিটার্ন করে।\n  - is_jolly_jumper(&[1, 3]) false রিটার্ন করে।\n  - is_jolly_jumper(&[5]) true রিটার্ন করে।",
      "bg": "Определя дали дадена последователност е \"Jolly Jumper\". Последователност се счита за \"Jolly Jumper\", ако абсолютните разлики между последователните елементи, когато са сортирани, образуват последователност от поредни числа, започващи от 1. Например, последователност от [3, 1, 4, 2] е Jolly Jumper, защото абсолютните разлики са 2, 3, 2, образувайки поредна последователност 1, 2, 3. Последователност с един елемент винаги е Jolly Jumper.\n\n  Аргументи:\n  - sequence: Списък от цели числа, представляващи последователността.\n\n  Връща:\n  - Булева стойност, указваща дали последователността е Jolly Jumper.\n\n  Примери:\n  - is_jolly_jumper(&[1, 4, 2, 3]) връща true.\n  - is_jolly_jumper(&[1, 3]) връща false.\n  - is_jolly_jumper(&[5]) връща true.",
      "zh": "确定一个序列是否为“Jolly Jumper”。如果一个序列中相邻元素之间的绝对差值在排序后形成从1开始的连续数字序列，则该序列被认为是“Jolly Jumper”。例如，[3, 1, 4, 2] 的序列是一个 Jolly Jumper，因为绝对差值是 2, 3, 2，形成了连续序列 1, 2, 3。单个元素的序列总是 Jolly Jumper。\n\n  参数:\n  - sequence: 整数切片，表示序列。\n\n  返回:\n  - 一个布尔值，指示该序列是否为 Jolly Jumper。\n\n  示例:\n  - is_jolly_jumper(&[1, 4, 2, 3]) 返回 true。\n  - is_jolly_jumper(&[1, 3]) 返回 false。\n  - is_jolly_jumper(&[5]) 返回 true。",
      "fr": "Détermine si une séquence est un \"Jolly Jumper\". Une séquence est considérée comme un \"Jolly Jumper\" si les différences absolues entre les éléments successifs, une fois triées, forment une séquence de nombres consécutifs commençant à partir de 1. Par exemple, une séquence de [3, 1, 4, 2] est un Jolly Jumper car les différences absolues sont 2, 3, 2, formant une séquence consécutive 1, 2, 3. Une séquence avec un seul élément est toujours un Jolly Jumper.\n\n  Arguments:\n  - sequence: Une tranche d'entiers, représentant la séquence.\n\n  Retourne:\n  - Une valeur booléenne indiquant si la séquence est un Jolly Jumper.\n\n  Exemples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) retourne true.\n  - is_jolly_jumper(&[1, 3]) retourne false.\n  - is_jolly_jumper(&[5]) retourne true.",
      "de": "Bestimmt, ob eine Sequenz ein \"Jolly Jumper\" ist. Eine Sequenz wird als \"Jolly Jumper\" betrachtet, wenn die absoluten Differenzen zwischen aufeinanderfolgenden Elementen, wenn sie sortiert sind, eine Sequenz von aufeinanderfolgenden Zahlen bilden, die bei 1 beginnt. Zum Beispiel ist eine Sequenz von [3, 1, 4, 2] ein Jolly Jumper, weil die absoluten Differenzen 2, 3, 2 sind und eine aufeinanderfolgende Sequenz 1, 2, 3 bilden. Eine Sequenz mit einem einzigen Element ist immer ein Jolly Jumper.\n\n  Argumente:\n  - sequence: Ein Ausschnitt von ganzen Zahlen, der die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Sequenz ein Jolly Jumper ist.\n\n  Beispiele:\n  - is_jolly_jumper(&[1, 4, 2, 3]) gibt true zurück.\n  - is_jolly_jumper(&[1, 3]) gibt false zurück.\n  - is_jolly_jumper(&[5]) gibt true zurück.",
      "ha": "Yana tantancewa idan jerin lambobi \"Jolly Jumper\". Ana ɗaukar jerin lambobi a matsayin \"Jolly Jumper\" idan bambance-bambancen ƙima tsakanin abubuwan da ke jere, idan an tsara su, suna samar da jerin lambobi masu jere daga 1. Alal misali, jerin lambobi na [3, 1, 4, 2] yana da Jolly Jumper saboda bambance-bambancen ƙima sune 2, 3, 2, suna samar da jerin lambobi masu jere 1, 2, 3. Jerin lambobi da ke da abu guda koyaushe yana da Jolly Jumper.\n\n  Huɗɗa:\n  - sequence: Wani yanki na lambobin tsaka-tsaki, yana wakiltar jerin.\n\n  Komawa:\n  - Wata ƙima ta boolean da ke nuna ko jerin yana da Jolly Jumper.\n\n  Misalai:\n  - is_jolly_jumper(&[1, 4, 2, 3]) yana dawowa da true.\n  - is_jolly_jumper(&[1, 3]) yana dawowa da false.\n  - is_jolly_jumper(&[5]) yana dawowa da true.",
      "hi": "निर्धारित करता है कि क्या एक अनुक्रम \"Jolly Jumper\" है। एक अनुक्रम को \"Jolly Jumper\" माना जाता है यदि क्रमिक तत्वों के बीच के परम अंतर, जब क्रमबद्ध होते हैं, तो 1 से शुरू होने वाले क्रमिक संख्याओं का अनुक्रम बनाते हैं। उदाहरण के लिए, [3, 1, 4, 2] का अनुक्रम एक Jolly Jumper है क्योंकि परम अंतर 2, 3, 2 हैं, जो एक क्रमिक अनुक्रम 1, 2, 3 बनाते हैं। एकल तत्व वाला अनुक्रम हमेशा एक Jolly Jumper होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक स्लाइस, जो अनुक्रम का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक बूलियन मान जो इंगित करता है कि अनुक्रम एक Jolly Jumper है या नहीं।\n\n  उदाहरण:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true लौटाता है।\n  - is_jolly_jumper(&[1, 3]) false लौटाता है।\n  - is_jolly_jumper(&[5]) true लौटाता है।",
      "hu": "Meghatározza, hogy egy sorozat \"Jolly Jumper\"-e. Egy sorozat akkor tekinthető \"Jolly Jumper\"-nek, ha az egymást követő elemek közötti abszolút különbségek, amikor sorba rendezzük őket, egy egymást követő számokból álló sorozatot alkotnak, amely 1-től kezdődik. Például a [3, 1, 4, 2] sorozat egy Jolly Jumper, mert az abszolút különbségek 2, 3, 2, amelyek egy egymást követő sorozatot alkotnak: 1, 2, 3. Egyetlen elemből álló sorozat mindig Jolly Jumper.\n\n  Argumentumok:\n  - sequence: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat Jolly Jumper-e.\n\n  Példák:\n  - is_jolly_jumper(&[1, 4, 2, 3]) visszaadja, hogy true.\n  - is_jolly_jumper(&[1, 3]) visszaadja, hogy false.\n  - is_jolly_jumper(&[5]) visszaadja, hogy true."
    },
    "docstring_bertscore": {
      "sq": "0.9948640142375809",
      "hy": "0.9804811883468446",
      "bn": "0.9814775183381157",
      "bg": "0.9865610656799415",
      "zh": "0.9656417112101092",
      "fr": "0.9968109892324849",
      "de": "0.9895053638180217",
      "ha": "0.9855847973571551",
      "hi": "0.9899008369066622",
      "hu": "0.9797792285802673"
    }
  },
  {
    "task_id": "Rust/24",
    "prompt": {
      "en": "/*\n  Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "sq": "/*\n  Llogarit transpozimin e një matrice katrore të dhënë.\n\n  Argumentet:\n  - matrix: Një matricë katrore e përfaqësuar si një vektor vektorësh të i32.\n\n  Kthen:\n  - Një matricë e re që është transpozimi i matricës hyrëse. Në matricën e transpozuar, rreshtat dhe kolonat e matricës origjinale janë ndërruar, në mënyrë që elementi në (i, j) në matricën origjinale të zhvendoset në pozicionin (j, i) në matricën e transpozuar.\n\n  Shembull:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) kthen vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "hy": "/*\n  Հաշվում է տրված քառակուսի մատրիցի տրանսպոզը:\n\n  Արգումենտներ:\n  - matrix: Քառակուսի մատրից, որը ներկայացված է i32 վեկտորների վեկտորով:\n\n  Վերադարձնում է:\n  - Նոր մատրից, որը տրված մատրիցի տրանսպոզն է: Տրանսպոզված մատրիցում, սկզբնական մատրիցի տողերն ու սյունակները փոխվում են, այնպես, որ սկզբնական մատրիցի (i, j) դիրքում գտնվող տարրը տեղափոխվում է տրանսպոզված մատրիցի (j, i) դիրք:\n\n  Օրինակ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) վերադարձնում է vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "bn": "/*\n  প্রদত্ত একটি বর্গাকার ম্যাট্রিক্সের ট্রান্সপোজ গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - matrix: একটি বর্গাকার ম্যাট্রিক্স যা i32 এর ভেক্টরের ভেক্টর হিসেবে উপস্থাপিত।\n\n  রিটার্নস:\n  - একটি নতুন ম্যাট্রিক্স যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ। ট্রান্সপোজ ম্যাট্রিক্সে, মূল ম্যাট্রিক্সের সারি এবং কলামগুলি অদলবদল করা হয়, যাতে মূল ম্যাট্রিক্সের (i, j) স্থিতির উপাদানটি ট্রান্সপোজ ম্যাট্রিক্সের (j, i) স্থানে চলে যায়।\n\n  উদাহরণ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) রিটার্ন করে vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "bg": "/*\n  Изчислява транспонираната матрица на дадена квадратна матрица.\n\n  Аргументи:\n  - matrix: Квадратна матрица, представена като вектор от вектори от i32.\n\n  Връща:\n  - Нова матрица, която е транспонираната на входната матрица. В транспонираната матрица редовете и колоните на оригиналната матрица са разменени, така че елементът на позиция (i, j) в оригиналната матрица се премества на позиция (j, i) в транспонираната матрица.\n\n  Пример:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) връща vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "zh": "/*\n  计算给定方阵的转置。\n\n  参数:\n  - matrix: 一个由i32向量的向量表示的方阵。\n\n  返回:\n  - 一个新的矩阵，它是输入矩阵的转置。在转置矩阵中，原始矩阵的行和列被交换，因此原始矩阵中位置(i, j)的元素移动到转置矩阵中的位置(j, i)。\n\n  示例:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) 返回 vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "fr": "/*\n  Calcule la transposée d'une matrice carrée donnée.\n\n  Arguments:\n  - matrix: Une matrice carrée représentée comme un vecteur de vecteurs de i32.\n\n  Retourne:\n  - Une nouvelle matrice qui est la transposée de la matrice d'entrée. Dans la matrice transposée, les lignes et les colonnes de la matrice originale sont inversées, de sorte que l'élément à la position (i, j) dans la matrice originale se déplace à la position (j, i) dans la matrice transposée.\n\n  Exemple:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) retourne vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "de": "/*\n  Berechnet die Transponierte einer gegebenen quadratischen Matrix.\n\n  Argumente:\n  - matrix: Eine quadratische Matrix, dargestellt als Vektor von Vektoren von i32.\n\n  Rückgabe:\n  - Eine neue Matrix, die die Transponierte der Eingabematrix ist. In der transponierten Matrix werden die Zeilen und Spalten der ursprünglichen Matrix vertauscht, sodass das Element an Position (i, j) in der ursprünglichen Matrix zur Position (j, i) in der transponierten Matrix wechselt.\n\n  Beispiel:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) gibt vec![vec![1, 3], vec![2, 4]] zurück\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "ha": "/*\n  Lissafi juyawar matrix mai kusurwa.\n\n  Huɗɗa:\n  - matrix: Matrix mai kusurwa da aka wakilta a matsayin jerin jerin i32.\n\n  Mayarwa:\n  - Sabon matrix wanda shine juyawar matrix na shigarwa. A cikin matrix da aka juyar, layuka da ginshikai na matrix na asali suna canzawa, don haka abu a (i, j) a cikin matrix na asali yana motsawa zuwa matsayi (j, i) a cikin matrix da aka juyar.\n\n  Misali:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) yana mayar da vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "hi": "/*\n  दिए गए वर्ग मैट्रिक्स का ट्रांसपोज़ गणना करता है।\n\n  तर्क:\n  - matrix: i32 के वेक्टर के वेक्टर के रूप में प्रदर्शित एक वर्ग मैट्रिक्स।\n\n  वापसी:\n  - एक नया मैट्रिक्स जो इनपुट मैट्रिक्स का ट्रांसपोज़ है। ट्रांसपोज़ मैट्रिक्स में, मूल मैट्रिक्स की पंक्तियाँ और स्तंभ स्विच हो जाते हैं, ताकि मूल मैट्रिक्स में (i, j) पर स्थित तत्व ट्रांसपोज़ मैट्रिक्स में स्थिति (j, i) पर चला जाए।\n\n  उदाहरण:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] लौटाता है\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "hu": "/*\n  Egy adott négyzetes mátrix transzponálását végzi el.\n\n  Argumentumok:\n  - matrix: Egy négyzetes mátrix, amelyet i32 vektorok vektoraként ábrázolunk.\n\n  Visszatérési érték:\n  - Egy új mátrix, amely a bemeneti mátrix transzponáltja. A transzponált mátrixban az eredeti mátrix sorai és oszlopai felcserélődnek, így az eredeti mátrix (i, j) pozíciójában lévő elem a transzponált mátrix (j, i) pozíciójába kerül.\n\n  Példa:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) visszaadja vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> "
    },
    "prompt_bertscore": {
      "sq": "0.9860501883399198",
      "hy": "0.9798465642794382",
      "bn": "0.9791092483050367",
      "bg": "0.989501391210401",
      "zh": "0.978888768582088",
      "fr": "0.9827100198524371",
      "de": "0.9804138526476738",
      "ha": "0.9693906610217616",
      "hi": "0.9852119681319526",
      "hu": "0.9782642746641143"
    },
    "canonical_solution": "{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}",
    "instruction": {
      "en": "Write a Rust function `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` to solve the following problem:\nComputes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "sq": "Shkruani një funksion në Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` për të zgjidhur problemin e mëposhtëm:\nLlogarit transpozimin e një matrice katrore të dhënë.\n\n  Argumentet:\n  - matrix: Një matricë katrore e përfaqësuar si një vektor vektorësh të i32.\n\n  Kthen:\n  - Një matricë e re që është transpozimi i matricës hyrëse. Në matricën e transpozuar, rreshtat dhe kolonat e matricës origjinale janë ndërruar, në mënyrë që elementi në (i, j) në matricën origjinale të zhvendoset në pozicionin (j, i) në matricën e transpozuar.\n\n  Shembull:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) kthen vec![vec![1, 3], vec![2, 4]]",
      "hy": "Գրեք Rust ֆունկցիա `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է տրված քառակուսի մատրիցի տրանսպոնացվածը։\n\n  Արգումենտներ:\n  - matrix: Քառակուսի մատրից, որը ներկայացված է i32 վեկտորների վեկտորով։\n\n  Վերադարձնում է:\n  - Նոր մատրից, որը մուտքային մատրիցի տրանսպոնացվածն է։ Տրանսպոնացված մատրիցում, սկզբնական մատրիցի տողերն ու սյունակները փոխվում են, այնպես որ (i, j) դիրքում գտնվող տարրը սկզբնական մատրիցում տեղափոխվում է (j, i) դիրք տրանսպոնացված մատրիցում։\n\n  Օրինակ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) վերադարձնում է vec![vec![1, 3], vec![2, 4]]",
      "bn": "Rust ফাংশন `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত বর্গাকার ম্যাট্রিক্সের ট্রান্সপোজ গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - matrix: একটি বর্গাকার ম্যাট্রিক্স যা i32 এর ভেক্টরের ভেক্টর হিসাবে উপস্থাপিত।\n\n  রিটার্নস:\n  - একটি নতুন ম্যাট্রিক্স যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ। ট্রান্সপোজ ম্যাট্রিক্সে, মূল ম্যাট্রিক্সের সারি এবং কলামগুলি অদলবদল হয়, যাতে মূল ম্যাট্রিক্সের (i, j) অবস্থানের উপাদানটি ট্রান্সপোজ ম্যাট্রিক্সের (j, i) অবস্থানে চলে যায়।\n\n  উদাহরণ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) রিটার্ন করে vec![vec![1, 3], vec![2, 4]]",
      "bg": "Напишете функция на Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>`, за да решите следния проблем:\nИзчислява транспонираната матрица на дадена квадратна матрица.\n\n  Аргументи:\n  - matrix: Квадратна матрица, представена като вектор от вектори от i32.\n\n  Връща:\n  - Нова матрица, която е транспонирана на входната матрица. В транспонираната матрица редовете и колоните на оригиналната матрица са разменени, така че елементът на позиция (i, j) в оригиналната матрица се премества на позиция (j, i) в транспонираната матрица.\n\n  Пример:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) връща vec![vec![1, 3], vec![2, 4]]",
      "zh": "编写一个 Rust 函数 `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` 来解决以下问题：\n计算给定方阵的转置。\n\n  参数:\n  - matrix: 一个方阵，表示为 i32 的向量的向量。\n\n  返回:\n  - 一个新的矩阵，它是输入矩阵的转置。在转置矩阵中，原始矩阵的行和列被交换，因此原始矩阵中位置 (i, j) 的元素移动到转置矩阵中的位置 (j, i)。\n\n  示例:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) 返回 vec![vec![1, 3], vec![2, 4]]",
      "fr": "Écrire une fonction Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` pour résoudre le problème suivant :\nCalcule la transposée d'une matrice carrée donnée.\n\n  Arguments :\n  - matrix : Une matrice carrée représentée comme un vecteur de vecteurs de i32.\n\n  Renvoie :\n  - Une nouvelle matrice qui est la transposée de la matrice d'entrée. Dans la matrice transposée, les lignes et les colonnes de la matrice originale sont inversées, de sorte que l'élément en position (i, j) dans la matrice originale se déplace à la position (j, i) dans la matrice transposée.\n\n  Exemple :\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) renvoie vec![vec![1, 3], vec![2, 4]]",
      "de": "Schreiben Sie eine Rust-Funktion `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>`, um das folgende Problem zu lösen:\nBerechnet die Transponierte einer gegebenen quadratischen Matrix.\n\n  Argumente:\n  - matrix: Eine quadratische Matrix, dargestellt als Vektor von Vektoren von i32.\n\n  Rückgabewert:\n  - Eine neue Matrix, die die Transponierte der Eingabematrix ist. In der transponierten Matrix werden die Zeilen und Spalten der ursprünglichen Matrix vertauscht, sodass das Element an Position (i, j) in der ursprünglichen Matrix an die Position (j, i) in der transponierten Matrix verschoben wird.\n\n  Beispiel:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) gibt vec![vec![1, 3], vec![2, 4]] zurück.",
      "ha": "Rubuta aikin Rust `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` don warware matsalar mai zuwa:\nYana lissafin transpose na matrix mai kusurwa huɗu da aka bayar.\n\n  Huɗɗa:\n  - matrix: Matrix mai kusurwa huɗu da aka wakilta azaman vector na vectors na i32.\n\n  Komawa:\n  - Sabon matrix wanda shine transpose na matrix na shigarwa. A cikin matrix na transpose, layuka da ginshikan matrix na asali suna canzawa, don haka abin da ke a (i, j) a cikin matrix na asali yana motsawa zuwa matsayi (j, i) a cikin matrix na transpose.\n\n  Misali:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) yana dawowa vec![vec![1, 3], vec![2, 4]]",
      "hi": "Rust फ़ंक्शन `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए वर्ग मैट्रिक्स का ट्रांसपोज़ निकालता है।\n\n  तर्क:\n  - matrix: i32 के वेक्टर के वेक्टर के रूप में प्रदर्शित एक वर्ग मैट्रिक्स।\n\n  लौटाता है:\n  - एक नया मैट्रिक्स जो इनपुट मैट्रिक्स का ट्रांसपोज़ है। ट्रांसपोज़ मैट्रिक्स में, मूल मैट्रिक्स की पंक्तियाँ और स्तंभ बदल जाते हैं, ताकि मूल मैट्रिक्स में (i, j) पर स्थित तत्व ट्रांसपोज़ मैट्रिक्स में स्थिति (j, i) पर चला जाए।\n\n  उदाहरण:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>` a következő probléma megoldására:\nEgy adott négyzetes mátrix transzponálását számítja ki.\n\n  Argumentumok:\n  - matrix: Egy négyzetes mátrix, amely vektorok vektoraként van ábrázolva i32 típusú elemekkel.\n\n  Visszatérési érték:\n  - Egy új mátrix, amely a bemeneti mátrix transzponáltja. A transzponált mátrixban az eredeti mátrix sorai és oszlopai felcserélődnek, így az eredeti mátrix (i, j) pozícióján lévő elem a transzponált mátrix (j, i) pozíciójára kerül.\n\n  Példa:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) visszaadja vec![vec![1, 3], vec![2, 4]]"
    },
    "instruction_bertscore": {
      "sq": "0.9807135858926554",
      "hy": "0.9857119208010174",
      "bn": "0.9749693939035076",
      "bg": "0.976338553119981",
      "zh": "0.9823975742630693",
      "fr": "0.9829394379425325",
      "de": "0.9695088460984774",
      "ha": "0.9757478263667833",
      "hi": "0.9704092376157085",
      "hu": "0.970468628099638"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![3, 4]]),\n            vec![vec![1, 3], vec![2, 4]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]),\n            vec![vec![1, 4, 7], vec![2, 5, 8], vec![3, 6, 9]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![1, 2]]),\n            vec![vec![1, 1], vec![2, 2]]\n        );\n    }\n    \n\n}",
    "entry_point": "transpose_matrix",
    "signature": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>",
    "docstring": {
      "en": "Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "sq": "Llogarit transpozimin e një matrice katrore të dhënë.\n\n  Argumentet:\n  - matrix: Një matricë katrore e përfaqësuar si një vektor vektorësh të i32.\n\n  Kthen:\n  - Një matricë e re që është transpozimi i matricës hyrëse. Në matricën e transpozuar, rreshtat dhe kolonat e matricës origjinale janë ndërruar, në mënyrë që elementi në (i, j) në matricën origjinale të zhvendoset në pozicionin (j, i) në matricën e transpozuar.\n\n  Shembull:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) kthen vec![vec![1, 3], vec![2, 4]]",
      "hy": "Հաշվում է տրված քառակուսի մատրիցի տրանսպոզիցիան։\n\n  Արգումենտներ:\n  - matrix: Քառակուսի մատրից, որը ներկայացված է որպես i32 վեկտորների վեկտոր։\n\n  Վերադարձնում է:\n  - Նոր մատրից, որը տրված մատրիցի տրանսպոզիցիան է։ Տրանսպոզված մատրիցում սկզբնական մատրիցի տողերը և սյունակները փոխվում են, այնպես որ սկզբնական մատրիցի (i, j) դիրքում գտնվող տարրը տեղափոխվում է տրանսպոզված մատրիցի (j, i) դիրք։\n\n  Օրինակ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) վերադարձնում է vec![vec![1, 3], vec![2, 4]]",
      "bn": "একটি প্রদত্ত বর্গাকার ম্যাট্রিক্সের ট্রান্সপোজ গণনা করে।\n\n  আর্গুমেন্টস:\n  - matrix: একটি বর্গাকার ম্যাট্রিক্স যা i32 এর ভেক্টর অফ ভেক্টর হিসেবে উপস্থাপিত।\n\n  রিটার্নস:\n  - একটি নতুন ম্যাট্রিক্স যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ। ট্রান্সপোজ ম্যাট্রিক্সে, মূল ম্যাট্রিক্সের সারি এবং কলামগুলি অদলবদল করা হয়, যাতে মূল ম্যাট্রিক্সের (i, j) অবস্থানের উপাদানটি ট্রান্সপোজ ম্যাট্রিক্সের (j, i) অবস্থানে চলে যায়।\n\n  উদাহরণ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) রিটার্ন করে vec![vec![1, 3], vec![2, 4]]",
      "bg": "Изчислява транспонираната матрица на дадена квадратна матрица.\n\n  Аргументи:\n  - matrix: Квадратна матрица, представена като вектор от вектори от i32.\n\n  Връща:\n  - Нова матрица, която е транспонираната на входната матрица. В транспонираната матрица редовете и колоните на оригиналната матрица са разменени, така че елементът на позиция (i, j) в оригиналната матрица се премества на позиция (j, i) в транспонираната матрица.\n\n  Пример:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) връща vec![vec![1, 3], vec![2, 4]]",
      "zh": "计算给定方阵的转置。\n\n  参数:\n  - matrix: 以i32向量的向量表示的方阵。\n\n  返回:\n  - 一个新矩阵，它是输入矩阵的转置。在转置矩阵中，原矩阵的行和列被交换，因此原矩阵中位置(i, j)的元素移动到转置矩阵中的位置(j, i)。\n\n  示例:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) 返回 vec![vec![1, 3], vec![2, 4]]",
      "fr": "Calcule la transposée d'une matrice carrée donnée.\n\n  Arguments:\n  - matrix: Une matrice carrée représentée comme un vecteur de vecteurs de i32.\n\n  Renvoie:\n  - Une nouvelle matrice qui est la transposée de la matrice d'entrée. Dans la matrice transposée, les lignes et les colonnes de la matrice originale sont inversées, de sorte que l'élément à la position (i, j) dans la matrice originale se déplace à la position (j, i) dans la matrice transposée.\n\n  Exemple:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) renvoie vec![vec![1, 3], vec![2, 4]]",
      "de": "Berechnet die Transponierte einer gegebenen quadratischen Matrix.\n\n  Argumente:\n  - matrix: Eine quadratische Matrix, dargestellt als Vektor von Vektoren von i32.\n\n  Rückgabewerte:\n  - Eine neue Matrix, die die Transponierte der Eingabematrix ist. In der transponierten Matrix werden die Zeilen und Spalten der ursprünglichen Matrix vertauscht, sodass das Element an Position (i, j) in der ursprünglichen Matrix an die Position (j, i) in der transponierten Matrix verschoben wird.\n\n  Beispiel:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) gibt vec![vec![1, 3], vec![2, 4]] zurück.",
      "ha": "Lissafi juyawar matrix mai kusurwa.\n\n  Huɗɗa:\n  - matrix: Wani matrix mai siffar murabba'i wanda aka wakilta a matsayin vector na vectors na i32.\n\n  Komawa:\n  - Sabon matrix wanda shine transpose na matrix ɗin da aka shigar. A cikin matrix ɗin da aka transpose, an sauya layuka da ginshiƙai na matrix na asali, don haka abin da ke a (i, j) a cikin matrix na asali yana matsawa zuwa matsayi (j, i) a cikin matrix ɗin da aka transpose.\n\n  Misali:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "hi": "दिए गए वर्ग मैट्रिक्स का ट्रांसपोज़ गणना करता है।\n\n  तर्क:\n  - matrix: एक वर्ग मैट्रिक्स जो i32 के वेक्टर के रूप में दर्शाया गया है।\n\n  रिटर्न:\n  - एक नया मैट्रिक्स जो इनपुट मैट्रिक्स का ट्रांसपोज़ है। ट्रांसपोज़ मैट्रिक्स में, मूल मैट्रिक्स की पंक्तियाँ और स्तंभ स्विच हो जाते हैं, ताकि मूल मैट्रिक्स में (i, j) पर स्थित तत्व ट्रांसपोज़ मैट्रिक्स में स्थिति (j, i) पर चला जाए।\n\n  उदाहरण:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] लौटाता है।",
      "hu": "Kiszámítja a megadott négyzetes mátrix transzponáltját.\n\n  Argumentumok:\n  - matrix: Egy négyzetes mátrix, amely i32 vektorok vektoraként van ábrázolva.\n\n  Visszatér:\n  - Egy új mátrix, amely a bemeneti mátrix transzponáltja. A transzponált mátrixban az eredeti mátrix sorai és oszlopai felcserélődnek, így az eredeti mátrix (i, j) pozíciójában lévő elem a transzponált mátrix (j, i) pozíciójába kerül.\n\n  Példa:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) visszaadja vec![vec![1, 3], vec![2, 4]]"
    },
    "docstring_bertscore": {
      "sq": "0.9793911048157252",
      "hy": "0.9698230793612747",
      "bn": "0.9747552703527519",
      "bg": "0.9831460135388087",
      "zh": "0.9776729520197734",
      "fr": "0.9763071695197775",
      "de": "0.9585327298728705",
      "ha": "0.9784184118397973",
      "hi": "0.9817645392387111",
      "hu": "0.9784045077131249"
    }
  },
  {
    "task_id": "Rust/25",
    "prompt": {
      "en": "/*\n    Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "sq": "/*\n    Transformon një fjalëkalim të dhënë sipas një algoritmi specifik.\n\n    Algoritmi funksionon si më poshtë:\n    - Shkronjat e vogla transformohen në numra bazuar në hartën e tastierës së telefonit (p.sh., abc -> 2, def -> 3, ...).\n    - Shkronjat e mëdha fillimisht konvertohen në të vogla dhe pastaj zhvendosen në shkronjën tjetër në alfabet (p.sh., A -> b, Z -> a).\n    - Numrat dhe simbolet e tjera mbeten të pandryshuara.\n\n    Argumentet:\n    - input: Një varg që përfaqëson fjalëkalimin që do të transformohet. Gjatësia e fjalëkalimit nuk i kalon 100 karaktere.\n\n    Kthen:\n    - Një varg i ri që përfaqëson fjalëkalimin e transformuar.\n\n    Shembuj:\n    - transform_password(\"YUANzi1987\") kthen \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "hy": "/*\n    Փոխակերպում է տրված գաղտնաբառը հատուկ ալգորիթմի համաձայն:\n\n    Ալգորիթմը գործում է հետևյալ կերպ.\n    - Փոքրատառերը փոխակերպվում են թվերի՝ ըստ հեռախոսային ստեղնաշարի քարտեզի (օր.` abc -> 2, def -> 3, ...):\n    - Մեծատառերը նախ փոխակերպվում են փոքրատառերի, ապա տեղափոխվում են այբուբենի հաջորդ տառին (օր.` A -> b, Z -> a):\n    - Թվերը և մյուս սիմվոլները մնում են անփոփոխ:\n\n    Արգումենտներ:\n    - input: Տող, որը ներկայացնում է փոխակերպվող գաղտնաբառը: Գաղտնաբառի երկարությունը չի գերազանցում 100 սիմվոլը:\n\n    Վերադարձնում է.\n    - Նոր տող, որը ներկայացնում է փոխակերպված գաղտնաբառը:\n\n    Օրինակներ:\n    - transform_password(\"YUANzi1987\") վերադարձնում է \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "bn": "/*\n    একটি নির্দিষ্ট অ্যালগরিদম অনুযায়ী প্রদত্ত পাসওয়ার্ড রূপান্তর করে। \n\n    অ্যালগরিদমটি নিম্নরূপ কাজ করে:\n    - ছোট হাতের অক্ষরগুলো টেলিফোন কীপ্যাড ম্যাপিং অনুযায়ী সংখ্যায় রূপান্তরিত হয় (যেমন, abc -> 2, def -> 3, ...).\n    - বড় হাতের অক্ষরগুলো প্রথমে ছোট হাতের অক্ষরে রূপান্তরিত হয় এবং তারপর বর্ণমালায় পরবর্তী অক্ষরে স্থানান্তরিত হয় (যেমন, A -> b, Z -> a).\n    - সংখ্যা এবং অন্যান্য প্রতীক অপরিবর্তিত থাকে।\n\n    আর্গুমেন্টসমূহ:\n    - input: একটি স্ট্রিং যা রূপান্তরিত হওয়ার জন্য পাসওয়ার্ডকে উপস্থাপন করে। পাসওয়ার্ডের দৈর্ঘ্য ১০০ অক্ষর অতিক্রম করে না।\n\n    রিটার্ন করে:\n    - একটি নতুন স্ট্রিং যা রূপান্তরিত পাসওয়ার্ডকে উপস্থাপন করে।\n\n    উদাহরণ:\n    - transform_password(\"YUANzi1987\") রিটার্ন করে \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "bg": "/*\n    Преобразува дадена парола според специфичен алгоритъм.\n\n    Алгоритъмът работи по следния начин:\n    - Малките букви се преобразуват в числа според телефонната клавиатурна подредба (напр. abc -> 2, def -> 3, ...).\n    - Главните букви първо се преобразуват в малки и след това се изместват към следващата буква в азбуката (напр. A -> b, Z -> a).\n    - Числата и другите символи остават непроменени.\n\n    Аргументи:\n    - input: Низ, представляващ паролата, която ще бъде преобразувана. Дължината на паролата не надвишава 100 символа.\n\n    Връща:\n    - Нов низ, представляващ преобразуваната парола.\n\n    Примери:\n    - transform_password(\"YUANzi1987\") връща \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "zh": "/*\n    根据特定算法转换给定的密码。\n\n    算法的工作原理如下：\n    - 小写字母根据电话键盘映射转换为数字（例如，abc -> 2，def -> 3，...）。\n    - 大写字母首先转换为小写，然后在字母表中移到下一个字母（例如，A -> b，Z -> a）。\n    - 数字和其他符号保持不变。\n\n    参数：\n    - input: 表示要转换的密码的字符串。密码长度不超过100个字符。\n\n    返回：\n    - 表示转换后密码的新字符串。\n\n    示例：\n    - transform_password(\"YUANzi1987\") 返回 \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "fr": "/*\n    Transforme un mot de passe donné selon un algorithme spécifique.\n\n    L'algorithme fonctionne comme suit :\n    - Les lettres minuscules sont transformées en chiffres selon la correspondance du clavier téléphonique (par exemple, abc -> 2, def -> 3, ...).\n    - Les lettres majuscules sont d'abord converties en minuscules puis décalées à la lettre suivante dans l'alphabet (par exemple, A -> b, Z -> a).\n    - Les chiffres et autres symboles restent inchangés.\n\n    Arguments :\n    - input : Une chaîne représentant le mot de passe à transformer. La longueur du mot de passe ne dépasse pas 100 caractères.\n\n    Retourne :\n    - Une nouvelle chaîne représentant le mot de passe transformé.\n\n    Exemples :\n    - transform_password(\"YUANzi1987\") retourne \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "de": "/*\n    Transformiert ein gegebenes Passwort gemäß einem spezifischen Algorithmus.\n\n    Der Algorithmus funktioniert wie folgt:\n    - Kleinbuchstaben werden basierend auf der Zuordnung der Telefontastatur in Zahlen umgewandelt (z.B. abc -> 2, def -> 3, ...).\n    - Großbuchstaben werden zuerst in Kleinbuchstaben umgewandelt und dann auf den nächsten Buchstaben im Alphabet verschoben (z.B. A -> b, Z -> a).\n    - Zahlen und andere Symbole bleiben unverändert.\n\n    Argumente:\n    - input: Ein String, der das zu transformierende Passwort darstellt. Die Passwortlänge überschreitet nicht 100 Zeichen.\n\n    Rückgabewert:\n    - Ein neuer String, der das transformierte Passwort darstellt.\n\n    Beispiele:\n    - transform_password(\"YUANzi1987\") gibt \"zvbo941987\" zurück\n*/\n\nfn transform_password(input: &str) -> String ",
      "ha": "/*\n    Canza kalmar sirri da aka bayar bisa ga wani takamaiman hanya.\n\n    Hanyar tana aiki kamar haka:\n    - Haruffan ƙaramin suna ana canza su zuwa lambobi bisa ga taswirar maɓallan wayar tarho (e.g., abc -> 2, def -> 3, ...).\n    - Haruffan babban suna ana fara canza su zuwa ƙaramin suna sannan a matsar da su zuwa harafin da ke gaba a haruffa (e.g., A -> b, Z -> a).\n    - Lambobi da sauran alamomi suna kasancewa ba a canza su ba.\n\n    Huɗɗa:\n    - input: Wani igiya da ke wakiltar kalmar sirri da za a canza. Tsawon kalmar sirri ba ya wuce haruffa 100.\n\n    Komawa:\n    - Sabuwar igiya da ke wakiltar kalmar sirri da aka canza.\n\n    Misalai:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "hi": "/*\n    दिए गए पासवर्ड को एक विशेष एल्गोरिदम के अनुसार परिवर्तित करता है।\n\n    एल्गोरिदम इस प्रकार कार्य करता है:\n    - छोटे अक्षरों को टेलीफोन कीपैड मैपिंग के आधार पर संख्याओं में परिवर्तित किया जाता है (जैसे, abc -> 2, def -> 3, ...).\n    - बड़े अक्षरों को पहले छोटे अक्षरों में परिवर्तित किया जाता है और फिर वर्णमाला में अगले अक्षर में शिफ्ट किया जाता है (जैसे, A -> b, Z -> a).\n    - संख्याएँ और अन्य प्रतीक अपरिवर्तित रहते हैं।\n\n    तर्क:\n    - input: एक स्ट्रिंग जो परिवर्तित किए जाने वाले पासवर्ड का प्रतिनिधित्व करती है। पासवर्ड की लंबाई 100 वर्णों से अधिक नहीं होती है।\n\n    लौटाता है:\n    - एक नई स्ट्रिंग जो परिवर्तित पासवर्ड का प्रतिनिधित्व करती है।\n\n    उदाहरण:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "hu": "/*\n    Egy adott jelszót egy specifikus algoritmus szerint alakít át.\n\n    Az algoritmus a következőképpen működik:\n    - A kisbetűk számokká alakulnak a telefon billentyűzetének leképezése alapján (pl. abc -> 2, def -> 3, ...).\n    - A nagybetűk először kisbetűkké alakulnak, majd az ábécében a következő betűre tolódnak (pl. A -> b, Z -> a).\n    - A számok és más szimbólumok változatlanok maradnak.\n\n    Paraméterek:\n    - input: Egy karakterlánc, amely a átalakítandó jelszót képviseli. A jelszó hossza nem haladja meg a 100 karaktert.\n\n    Visszatér:\n    - Egy új karakterlánc, amely az átalakított jelszót képviseli.\n\n    Példák:\n    - transform_password(\"YUANzi1987\") visszaadja \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9918043118481195",
      "hy": "0.9897687477032739",
      "bn": "0.9921821068328478",
      "bg": "0.9879520742383289",
      "zh": "0.9798380231730537",
      "fr": "0.9904115156163028",
      "de": "0.9941106092023155",
      "ha": "0.9783341925582385",
      "hi": "0.9900216041783314",
      "hu": "0.9771366499909792"
    },
    "canonical_solution": "{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}",
    "instruction": {
      "en": "Write a Rust function `fn transform_password(input: &str) -> String` to solve the following problem:\nTransforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "sq": "Shkruani një funksion Rust `fn transform_password(input: &str) -> String` për të zgjidhur problemin e mëposhtëm:\nTransformon një fjalëkalim të dhënë sipas një algoritmi specifik.\n\n    Algoritmi funksionon si më poshtë:\n    - Shkronjat e vogla transformohen në numra bazuar në hartën e tastierës së telefonit (p.sh., abc -> 2, def -> 3, ...).\n    - Shkronjat e mëdha fillimisht konvertohen në të vogla dhe pastaj zhvendosen në shkronjën tjetër në alfabet (p.sh., A -> b, Z -> a).\n    - Numrat dhe simbolet e tjera mbeten të pandryshuara.\n\n    Argumentet:\n    - input: Një varg që përfaqëson fjalëkalimin që do të transformohet. Gjatësia e fjalëkalimit nuk i kalon 100 karaktere.\n\n    Kthen:\n    - Një varg i ri që përfaqëson fjalëkalimin e transformuar.\n\n    Shembuj:\n    - transform_password(\"YUANzi1987\") kthen \"zvbo941987\"",
      "hy": "Գրեք Rust ֆունկցիա `fn transform_password(input: &str) -> String` հետևյալ խնդիրը լուծելու համար:\nՎերափոխում է տրված գաղտնաբառը հատուկ ալգորիթմի համաձայն։\n\n   Ալգորիթմը գործում է հետևյալ կերպ.\n   - Փոքրատառերը փոխակերպվում են թվերի՝ ըստ հեռախոսային ստեղնաշարի համապատասխանության (օրինակ՝ abc -> 2, def -> 3, ...):\n   - Մեծատառերը նախ փոխակերպվում են փոքրատառերի և հետո տեղափոխվում են այբուբենի հաջորդ տառին (օրինակ՝ A -> b, Z -> a):\n   - Թվերը և այլ սիմվոլները մնում են անփոփոխ։\n\n   Արգումենտներ:\n   - input: Տող, որը ներկայացնում է փոխակերպվող գաղտնաբառը։ Գաղտնաբառի երկարությունը չի գերազանցում 100 սիմվոլը։\n\n   Վերադարձնում է:\n   - Նոր տող, որը ներկայացնում է փոխակերպված գաղտնաբառը։\n\n   Օրինակներ:\n   - transform_password(\"YUANzi1987\") վերադարձնում է \"zvbo941987\"",
      "bn": "Rust ফাংশন `fn transform_password(input: &str) -> String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট অ্যালগরিদম অনুযায়ী প্রদত্ত পাসওয়ার্ড রূপান্তর করে।\n\n    অ্যালগরিদমটি নিম্নরূপ কাজ করে:\n    - ছোট হাতের অক্ষরগুলি টেলিফোন কীপ্যাড ম্যাপিং অনুযায়ী সংখ্যায় রূপান্তরিত হয় (যেমন, abc -> 2, def -> 3, ...)।\n    - বড় হাতের অক্ষরগুলি প্রথমে ছোট হাতের অক্ষরে রূপান্তরিত হয় এবং তারপর বর্ণমালায় পরবর্তী অক্ষরে স্থানান্তরিত হয় (যেমন, A -> b, Z -> a)।\n    - সংখ্যা এবং অন্যান্য প্রতীক অপরিবর্তিত থাকে।\n\n    আর্গুমেন্ট:\n    - input: একটি স্ট্রিং যা রূপান্তরিত পাসওয়ার্ড উপস্থাপন করে। পাসওয়ার্ডের দৈর্ঘ্য 100 অক্ষরের বেশি নয়।\n\n    রিটার্ন:\n    - একটি নতুন স্ট্রিং যা রূপান্তরিত পাসওয়ার্ড উপস্থাপন করে।\n\n    উদাহরণ:\n    - transform_password(\"YUANzi1987\") রিটার্ন করে \"zvbo941987\"",
      "bg": "Напишете функция на Rust `fn transform_password(input: &str) -> String`, за да решите следния проблем:\nТрансформира дадена парола според специфичен алгоритъм.\n\n    Алгоритъмът работи по следния начин:\n    - Малките букви се трансформират в числа според телефонната клавиатура (напр. abc -> 2, def -> 3, ...).\n    - Главните букви първо се преобразуват в малки и след това се изместват към следващата буква в азбуката (напр. A -> b, Z -> a).\n    - Числата и другите символи остават непроменени.\n\n    Аргументи:\n    - input: Низ, представляващ паролата, която трябва да бъде трансформирана. Дължината на паролата не надвишава 100 символа.\n\n    Връща:\n    - Нов низ, представляващ трансформираната парола.\n\n    Примери:\n    - transform_password(\"YUANzi1987\") връща \"zvbo941987\"",
      "zh": "编写一个 Rust 函数 `fn transform_password(input: &str) -> String` 来解决以下问题：\n根据特定算法转换给定密码。\n\n算法如下：\n- 小写字母根据电话键盘映射转换为数字（例如，abc -> 2, def -> 3, ...）。\n- 大写字母首先转换为小写，然后在字母表中移到下一个字母（例如，A -> b, Z -> a）。\n- 数字和其他符号保持不变。\n\n参数：\n- input: 表示要转换的密码的字符串。密码长度不超过 100 个字符。\n\n返回：\n- 表示转换后密码的新字符串。\n\n示例：\n- transform_password(\"YUANzi1987\") 返回 \"zvbo941987\"",
      "fr": "Écrire une fonction Rust `fn transform_password(input: &str) -> String` pour résoudre le problème suivant :\nTransforme un mot de passe donné selon un algorithme spécifique.\n\n    L'algorithme fonctionne comme suit :\n    - Les lettres minuscules sont transformées en chiffres selon le mappage du clavier téléphonique (par exemple, abc -> 2, def -> 3, ...).\n    - Les lettres majuscules sont d'abord converties en minuscules puis décalées vers la lettre suivante dans l'alphabet (par exemple, A -> b, Z -> a).\n    - Les chiffres et autres symboles restent inchangés.\n\n    Arguments :\n    - input : Une chaîne de caractères représentant le mot de passe à transformer. La longueur du mot de passe ne dépasse pas 100 caractères.\n\n    Renvoie :\n    - Une nouvelle chaîne de caractères représentant le mot de passe transformé.\n\n    Exemples :\n    - transform_password(\"YUANzi1987\") renvoie \"zvbo941987\"",
      "de": "Schreiben Sie eine Rust-Funktion `fn transform_password(input: &str) -> String`, um das folgende Problem zu lösen:\nTransformiert ein gegebenes Passwort gemäß einem spezifischen Algorithmus.\n\n    Der Algorithmus funktioniert wie folgt:\n    - Kleinbuchstaben werden basierend auf der Zuordnung der Telefontastatur in Zahlen umgewandelt (z.B. abc -> 2, def -> 3, ...).\n    - Großbuchstaben werden zuerst in Kleinbuchstaben umgewandelt und dann auf den nächsten Buchstaben im Alphabet verschoben (z.B. A -> b, Z -> a).\n    - Zahlen und andere Symbole bleiben unverändert.\n\n    Argumente:\n    - input: Ein String, der das zu transformierende Passwort darstellt. Die Passwortlänge überschreitet nicht 100 Zeichen.\n\n    Rückgabewert:\n    - Ein neuer String, der das transformierte Passwort darstellt.\n\n    Beispiele:\n    - transform_password(\"YUANzi1987\") gibt \"zvbo941987\" zurück.",
      "ha": "Rubuta aikin Rust `fn transform_password(input: &str) -> String` don warware matsalar mai zuwa:\nCanza kalmar sirri da aka bayar bisa ga wata takamaiman hanya.\n\n   Hanyar tana aiki kamar haka:\n   - Haruffan ƙananan suna canzawa zuwa lambobi bisa ga taswirar maɓallan wayar (misali, abc -> 2, def -> 3, ...).\n   - Haruffan manya suna fara canzawa zuwa ƙananan sannan kuma a matsar da su zuwa harafin gaba a cikin haruffa (misali, A -> b, Z -> a).\n   - Lambobi da sauran alamomi suna kasancewa ba a canza su ba.\n\n   Huɗa:\n   - input: Wani kirtani da ke wakiltar kalmar sirri da za a canza. Tsawon kalmar sirri ba zai wuce haruffa 100 ba.\n\n   Dawowa:\n   - Sabon kirtani da ke wakiltar kalmar sirri da aka canza.\n\n   Misalai:\n   - transform_password(\"YUANzi1987\") yana dawowa \"zvbo941987\"",
      "hi": "Rust फ़ंक्शन `fn transform_password(input: &str) -> String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए पासवर्ड को एक विशेष एल्गोरिदम के अनुसार परिवर्तित करता है।\n\n    एल्गोरिदम इस प्रकार काम करता है:\n    - छोटे अक्षरों को टेलीफोन कीपैड मैपिंग के आधार पर संख्याओं में परिवर्तित किया जाता है (जैसे, abc -> 2, def -> 3, ...).\n    - बड़े अक्षरों को पहले छोटे अक्षरों में परिवर्तित किया जाता है और फिर वर्णमाला में अगले अक्षर में स्थानांतरित किया जाता है (जैसे, A -> b, Z -> a).\n    - संख्याएँ और अन्य प्रतीक अपरिवर्तित रहते हैं।\n\n    तर्क:\n    - input: एक स्ट्रिंग जो परिवर्तित किए जाने वाले पासवर्ड का प्रतिनिधित्व करती है। पासवर्ड की लंबाई 100 वर्णों से अधिक नहीं होती है।\n\n    वापसी:\n    - एक नई स्ट्रिंग जो परिवर्तित पासवर्ड का प्रतिनिधित्व करती है।\n\n    उदाहरण:\n    - transform_password(\"YUANzi1987\") \"zvbo941987\" लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn transform_password(input: &str) -> String` a következő probléma megoldására:\nEgy adott jelszót átalakít egy specifikus algoritmus szerint.\n\n    Az algoritmus a következőképpen működik:\n    - A kisbetűket számokká alakítja a telefon billentyűzet kiosztása alapján (pl. abc -> 2, def -> 3, ...).\n    - A nagybetűket először kisbetűkké alakítja, majd az ábécében a következő betűre tolja (pl. A -> b, Z -> a).\n    - A számok és más szimbólumok változatlanok maradnak.\n\n    Argumentumok:\n    - input: Egy string, amely a jelszót reprezentálja, amit át kell alakítani. A jelszó hossza nem haladja meg a 100 karaktert.\n\n    Visszatérési érték:\n    - Egy új string, amely az átalakított jelszót reprezentálja.\n\n    Példák:\n    - transform_password(\"YUANzi1987\") visszaadja \"zvbo941987\""
    },
    "instruction_bertscore": {
      "sq": "0.9921844903974203",
      "hy": "0.9769844991191065",
      "bn": "0.9656504509468747",
      "bg": "0.9863113872909807",
      "zh": "0.9820918821066565",
      "fr": "0.9919111749931162",
      "de": "0.9939622323076825",
      "ha": "0.9770345539751273",
      "hi": "0.9812482988784014",
      "hu": "0.9766889371121266"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(transform_password(\"YUANzi1987\"), \"zvbo941987\");\n        assert_eq!(transform_password(\"ABcdE\"), \"bc23f\");\n        assert_eq!(transform_password(\"Zebra123!\"), \"a3272123!\");\n    }\n    \n\n}",
    "entry_point": "transform_password",
    "signature": "fn transform_password(input: &str) -> String",
    "docstring": {
      "en": "Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "sq": "Transformon një fjalëkalim të dhënë sipas një algoritmi specifik.\n\n    Algoritmi funksionon si më poshtë:\n    - Shkronjat e vogla transformohen në numra bazuar në hartën e tastierës së telefonit (p.sh., abc -> 2, def -> 3, ...).\n    - Shkronjat e mëdha fillimisht konvertohen në të vogla dhe pastaj zhvendosen në shkronjën tjetër në alfabet (p.sh., A -> b, Z -> a).\n    - Numrat dhe simbolet e tjera mbeten të pandryshuara.\n\n    Argumentet:\n    - input: Një varg që përfaqëson fjalëkalimin që do të transformohet. Gjatësia e fjalëkalimit nuk i kalon 100 karaktere.\n\n    Kthen:\n    - Një varg i ri që përfaqëson fjalëkalimin e transformuar.\n\n    Shembuj:\n    - transform_password(\"YUANzi1987\") kthen \"zvbo941987\"",
      "hy": "Փոխակերպում է տրված գաղտնաբառը ըստ հատուկ ալգորիթմի:\n\n    Ալգորիթմը գործում է հետևյալ կերպ.\n    - Փոքրատառ տառերը փոխակերպվում են թվերի՝ հիմնված հեռախոսի ստեղնաշարի քարտեզագրման վրա (օրինակ՝ abc -> 2, def -> 3, ...):\n    - Մեծատառ տառերը նախ փոխակերպվում են փոքրատառերի, ապա տեղափոխվում են այբուբենի հաջորդ տառին (օրինակ՝ A -> b, Z -> a):\n    - Թվերը և այլ սիմվոլները մնում են անփոփոխ:\n\n    Արգումենտներ:\n    - input: Տող, որը ներկայացնում է փոխակերպվող գաղտնաբառը: Գաղտնաբառի երկարությունը չի գերազանցում 100 նիշը:\n\n    Վերադարձնում է.\n    - Նոր տող, որը ներկայացնում է փոխակերպված գաղտնաբառը:\n\n    Օրինակներ.\n    - transform_password(\"YUANzi1987\") վերադարձնում է \"zvbo941987\"",
      "bn": "একটি নির্দিষ্ট অ্যালগরিদম অনুযায়ী প্রদত্ত পাসওয়ার্ড রূপান্তর করে।\n\n    অ্যালগরিদমটি নিম্নরূপ কাজ করে:\n    - ছোট হাতের অক্ষরগুলি টেলিফোন কীপ্যাড ম্যাপিং অনুযায়ী সংখ্যায় রূপান্তরিত হয় (যেমন, abc -> 2, def -> 3, ...)।\n    - বড় হাতের অক্ষরগুলি প্রথমে ছোট হাতের অক্ষরে রূপান্তরিত হয় এবং তারপর বর্ণমালায় পরবর্তী অক্ষরে স্থানান্তরিত হয় (যেমন, A -> b, Z -> a)।\n    - সংখ্যা এবং অন্যান্য প্রতীক অপরিবর্তিত থাকে।\n\n    আর্গুমেন্টসমূহ:\n    - input: একটি স্ট্রিং যা রূপান্তরিত হওয়ার জন্য পাসওয়ার্ডকে উপস্থাপন করে। পাসওয়ার্ডের দৈর্ঘ্য ১০০ অক্ষর অতিক্রম করে না।\n\n    রিটার্নস:\n    - একটি নতুন স্ট্রিং যা রূপান্তরিত পাসওয়ার্ডকে উপস্থাপন করে।\n\n    উদাহরণ:\n    - transform_password(\"YUANzi1987\") রিটার্ন করে \"zvbo941987\"",
      "bg": "Трансформира дадена парола според специфичен алгоритъм.\n\n    Алгоритъмът работи по следния начин:\n    - Малките букви се трансформират в числа според телефонната клавиатура (напр. abc -> 2, def -> 3, ...).\n    - Главните букви първо се преобразуват в малки и след това се изместват към следващата буква в азбуката (напр. A -> b, Z -> a).\n    - Числата и другите символи остават непроменени.\n\n    Аргументи:\n    - input: Низ, представляващ паролата, която трябва да бъде трансформирана. Дължината на паролата не надвишава 100 символа.\n\n    Връща:\n    - Нов низ, представляващ трансформираната парола.\n\n    Примери:\n    - transform_password(\"YUANzi1987\") връща \"zvbo941987\"",
      "zh": "根据特定算法转换给定的密码。\n\n    该算法的工作原理如下：\n    - 小写字母根据电话键盘映射转换为数字（例如，abc -> 2, def -> 3, ...）。\n    - 大写字母首先转换为小写字母，然后在字母表中移到下一个字母（例如，A -> b, Z -> a）。\n    - 数字和其他符号保持不变。\n\n    参数：\n    - input: 一个字符串，表示要转换的密码。密码长度不超过100个字符。\n\n    返回：\n    - 一个新的字符串，表示转换后的密码。\n\n    示例：\n    - transform_password(\"YUANzi1987\") 返回 \"zvbo941987\"",
      "fr": "Transforme un mot de passe donné selon un algorithme spécifique.\n\n    L'algorithme fonctionne comme suit :\n    - Les lettres minuscules sont transformées en chiffres selon le mappage du clavier téléphonique (par exemple, abc -> 2, def -> 3, ...).\n    - Les lettres majuscules sont d'abord converties en minuscules puis décalées à la lettre suivante dans l'alphabet (par exemple, A -> b, Z -> a).\n    - Les chiffres et autres symboles restent inchangés.\n\n    Arguments :\n    - input : Une chaîne de caractères représentant le mot de passe à transformer. La longueur du mot de passe ne dépasse pas 100 caractères.\n\n    Retourne :\n    - Une nouvelle chaîne de caractères représentant le mot de passe transformé.\n\n    Exemples :\n    - transform_password(\"YUANzi1987\") retourne \"zvbo941987\"",
      "de": "Transformiert ein gegebenes Passwort gemäß einem spezifischen Algorithmus.\n\n    Der Algorithmus funktioniert wie folgt:\n    - Kleinbuchstaben werden basierend auf der Zuordnung der Telefontastatur in Zahlen umgewandelt (z.B. abc -> 2, def -> 3, ...).\n    - Großbuchstaben werden zuerst in Kleinbuchstaben umgewandelt und dann auf den nächsten Buchstaben im Alphabet verschoben (z.B. A -> b, Z -> a).\n    - Zahlen und andere Symbole bleiben unverändert.\n\n    Argumente:\n    - input: Ein String, der das zu transformierende Passwort darstellt. Die Passwortlänge überschreitet nicht 100 Zeichen.\n\n    Rückgabewert:\n    - Ein neuer String, der das transformierte Passwort darstellt.\n\n    Beispiele:\n    - transform_password(\"YUANzi1987\") gibt \"zvbo941987\" zurück.",
      "ha": "Canza kalmar sirri da aka bayar bisa ga wani takamaiman hanya.\n\n    Algoritmin yana aiki kamar haka:\n    - Haruffan ƙananan suna canzawa zuwa lambobi bisa ga taswirar maɓallin wayar tarho (misali, abc -> 2, def -> 3, ...).\n    - Haruffan manya suna fara canzawa zuwa ƙananan sannan kuma a matsar da su zuwa harafin gaba a cikin haruffa (misali, A -> b, Z -> a).\n    - Lambobi da sauran alamomi suna kasancewa ba a canza su ba.\n\n    Huɗa:\n    - input: Wani kirtani mai wakiltar kalmar sirri da za a canza. Tsawon kalmar sirri ba ya wuce haruffa 100.\n\n    Komawa:\n    - Sabon kirtani mai wakiltar kalmar sirri da aka canza.\n\n    Misalai:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "hi": "एक दिए गए पासवर्ड को एक विशेष एल्गोरिदम के अनुसार परिवर्तित करता है।\n\n    एल्गोरिदम इस प्रकार कार्य करता है:\n    - छोटे अक्षरों को टेलीफोन कीपैड मैपिंग के आधार पर संख्याओं में परिवर्तित किया जाता है (जैसे, abc -> 2, def -> 3, ...).\n    - बड़े अक्षरों को पहले छोटे अक्षरों में परिवर्तित किया जाता है और फिर वर्णमाला में अगले अक्षर में स्थानांतरित किया जाता है (जैसे, A -> b, Z -> a).\n    - संख्याएं और अन्य प्रतीक अपरिवर्तित रहते हैं।\n\n    तर्क:\n    - input: एक स्ट्रिंग जो परिवर्तित किए जाने वाले पासवर्ड का प्रतिनिधित्व करती है। पासवर्ड की लंबाई 100 वर्णों से अधिक नहीं होती है।\n\n    लौटाता है:\n    - एक नई स्ट्रिंग जो परिवर्तित पासवर्ड का प्रतिनिधित्व करती है।\n\n    उदाहरण:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "hu": "Átalakít egy adott jelszót egy meghatározott algoritmus szerint.\n\n    Az algoritmus a következőképpen működik:\n    - A kisbetűk számokká alakulnak a telefon billentyűzetének megfelelően (pl. abc -> 2, def -> 3, ...).\n    - A nagybetűk először kisbetűkké alakulnak, majd az ábécé következő betűjére tolódnak (pl. A -> b, Z -> a).\n    - A számok és más szimbólumok változatlanok maradnak.\n\n    Argumentumok:\n    - input: Egy string, amely a átalakítandó jelszót képviseli. A jelszó hossza nem haladja meg a 100 karaktert.\n\n    Visszatérési érték:\n    - Egy új string, amely az átalakított jelszót képviseli.\n\n    Példák:\n    - transform_password(\"YUANzi1987\") visszaadja \"zvbo941987\""
    },
    "docstring_bertscore": {
      "sq": "0.9916964555512175",
      "hy": "0.9700173398739267",
      "bn": "0.9828530337267822",
      "bg": "0.9871587444964756",
      "zh": "0.967798241257005",
      "fr": "0.9802108523982561",
      "de": "0.9925028948982192",
      "ha": "0.9837289937071461",
      "hi": "0.9833366987046022",
      "hu": "0.9740121940973004"
    }
  },
  {
    "task_id": "Rust/26",
    "prompt": {
      "en": "/*\n  Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "sq": "/*\n  Përcakton nëse sekuenca e dhënë e numrave formon një sekuencë aritmetike.\n\n  Një sekuencë aritmetike është një sekuencë numrash e tillë që diferenca midis numrave të njëpasnjëshëm është konstante.\n\n  Argumentet:\n  - sequence: Një segment array i numrave të plotë që përfaqëson sekuencën që do të kontrollohet.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca formon një sekuencë aritmetike (`true`) apo jo (`false`).\n\n  Shembuj:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) kthen true (pasi diferenca është 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) kthen false (pasi diferenca nuk është konstante)\n  - is_arithmetic_sequence(&[10, 10, 10]) kthen true (pasi diferenca është 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "hy": "/*\n  Որոշում է՝ արդյոք տրված թվերի հաջորդականությունը կազմում է թվաբանական հաջորդականություն:\n\n  Թվաբանական հաջորդականությունը թվերի այնպիսի հաջորդականություն է, որ հաջորդական թվերի տարբերությունը հաստատուն է:\n\n  Արգումենտներ:\n  - sequence: Թվերի զանգվածի հատված, որը ներկայացնում է ստուգվող հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հաջորդականությունը կազմում է թվաբանական հաջորդականություն (`true`) թե ոչ (`false`):\n\n  Օրինակներ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) վերադարձնում է true (քանի որ տարբերությունը 2 է)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) վերադարձնում է false (քանի որ տարբերությունը հաստատուն չէ)\n  - is_arithmetic_sequence(&[10, 10, 10]) վերադարձնում է true (քանի որ տարբերությունը 0 է)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "bn": "/*\n  প্রদত্ত সংখ্যার ক্রম একটি গাণিতিক ক্রম গঠন করে কিনা তা নির্ধারণ করে।\n\n  একটি গাণিতিক ক্রম হল এমন একটি সংখ্যার ক্রম যেখানে পরপর সংখ্যার মধ্যে পার্থক্য ধ্রুবক হয়।\n\n  আর্গুমেন্টসমূহ:\n  - sequence: পূর্ণসংখ্যার একটি অ্যারে স্লাইস যা যাচাই করার জন্য ক্রম উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা (`true`) অথবা না করে (`false`)।\n\n  উদাহরণসমূহ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true রিটার্ন করে (যেহেতু পার্থক্য 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false রিটার্ন করে (যেহেতু পার্থক্য ধ্রুবক নয়)\n  - is_arithmetic_sequence(&[10, 10, 10]) true রিটার্ন করে (যেহেতু পার্থক্য 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "bg": "/*\n  Определя дали дадената последователност от числа образува аритметична прогресия.\n\n  Аритметична прогресия е последователност от числа, при която разликата между последователните числа е постоянна.\n\n  Аргументи:\n  - sequence: Масив от цели числа, представляващ последователността, която трябва да се провери.\n\n  Връща:\n  - Булева стойност, указваща дали последователността образува аритметична прогресия (`true`) или не (`false`).\n\n  Примери:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) връща true (тъй като разликата е 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) връща false (тъй като разликата не е постоянна)\n  - is_arithmetic_sequence(&[10, 10, 10]) връща true (тъй като разликата е 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "zh": "/*\n  确定给定的数字序列是否构成等差数列。\n\n  等差数列是指连续数字之间的差是恒定的数列。\n\n  参数:\n  - sequence: 表示要检查的序列的整数数组切片。\n\n  返回值:\n  - 一个布尔值，指示序列是否构成等差数列（`true`）或不是（`false`）。\n\n  示例:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) 返回 true （因为差是 2）\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) 返回 false （因为差不是恒定的）\n  - is_arithmetic_sequence(&[10, 10, 10]) 返回 true （因为差是 0）\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "fr": "/*\n  Détermine si la séquence de nombres donnée forme une suite arithmétique.\n\n  Une suite arithmétique est une suite de nombres telle que la différence entre les nombres consécutifs est constante.\n\n  Arguments :\n  - sequence : Une tranche de tableau d'entiers représentant la séquence à vérifier.\n\n  Renvoie :\n  - Une valeur booléenne indiquant si la séquence forme une suite arithmétique (`true`) ou non (`false`).\n\n  Exemples :\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) renvoie true (car la différence est de 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) renvoie false (car la différence n'est pas constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) renvoie true (car la différence est de 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "de": "/*\n  Bestimmt, ob die gegebene Zahlenfolge eine arithmetische Folge bildet.\n\n  Eine arithmetische Folge ist eine Zahlenfolge, bei der der Unterschied zwischen aufeinanderfolgenden Zahlen konstant ist.\n\n  Argumente:\n  - sequence: Ein Array-Slice von Ganzzahlen, das die zu überprüfende Folge darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Folge eine arithmetische Folge bildet (`true`) oder nicht (`false`).\n\n  Beispiele:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) gibt true zurück (da der Unterschied 2 ist)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) gibt false zurück (da der Unterschied nicht konstant ist)\n  - is_arithmetic_sequence(&[10, 10, 10]) gibt true zurück (da der Unterschied 0 ist)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "ha": "/*\n  Yana tantance ko jerin lambobin da aka bayar suna samar da jere na lissafi.\n\n  Jere na lissafi shine jere na lambobi inda bambanci tsakanin lambobi masu jere yake daidai.\n\n  Huɗodi:\n  - sequence: Wani yanki na jerin lambobi masu lamba wanda ke wakiltar jerin da za a duba.\n\n  Komawa:\n  - Ƙimar boolean da ke nuna ko jerin yana samar da jere na lissafi (`true`) ko a'a (`false`).\n\n  Misalai:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) yana dawowa true (domin bambancin shine 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) yana dawowa false (domin bambancin ba daidai bane)\n  - is_arithmetic_sequence(&[10, 10, 10]) yana dawowa true (domin bambancin shine 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "hi": "/*\n  यह निर्धारित करता है कि दिए गए संख्याओं का अनुक्रम एक अंकगणितीय अनुक्रम बनाता है या नहीं।\n\n  एक अंकगणितीय अनुक्रम संख्याओं का ऐसा अनुक्रम है कि लगातार संख्याओं के बीच का अंतर स्थिर होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों की एक array slice जो जांचे जाने वाले अनुक्रम का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक boolean मान जो यह इंगित करता है कि अनुक्रम एक अंकगणितीय अनुक्रम बनाता है (`true`) या नहीं (`false`)।\n\n  उदाहरण:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true लौटाता है (क्योंकि अंतर 2 है)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false लौटाता है (क्योंकि अंतर स्थिर नहीं है)\n  - is_arithmetic_sequence(&[10, 10, 10]) true लौटाता है (क्योंकि अंतर 0 है)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "hu": "/*\n  Meghatározza, hogy a megadott számok sorozata számtani sorozatot alkot-e.\n\n  Egy számtani sorozat olyan számok sorozata, ahol az egymást követő számok közötti különbség állandó.\n\n  Argumentumok:\n  - sequence: Egész számok tömbszelete, amely a vizsgálandó sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat számtani sorozatot alkot-e (`true`) vagy sem (`false`).\n\n  Példák:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) visszaadja a true értéket (mivel a különbség 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) visszaadja a false értéket (mivel a különbség nem állandó)\n  - is_arithmetic_sequence(&[10, 10, 10]) visszaadja a true értéket (mivel a különbség 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "sq": "0.9932709985816811",
      "hy": "0.9832413561217055",
      "bn": "0.980221379808451",
      "bg": "0.9793603171066648",
      "zh": "0.9657527455931076",
      "fr": "0.988681246367108",
      "de": "0.990440912912696",
      "ha": "0.9748567704774608",
      "hi": "0.9955915973233117",
      "hu": "0.9835001715081939"
    },
    "canonical_solution": "{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}",
    "instruction": {
      "en": "Write a Rust function `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` to solve the following problem:\nDetermines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)",
      "sq": "Shkruani një funksion Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` për të zgjidhur problemin në vijim:\nPërcakton nëse sekuenca e dhënë e numrave formon një sekuencë aritmetike.\n\n  Një sekuencë aritmetike është një sekuencë numrash e tillë që diferenca midis numrave të njëpasnjëshëm është konstante.\n\n  Argumentet:\n  - sequence: Një pjesë e vargut të numrave të plotë që përfaqëson sekuencën që do të kontrollohet.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca formon një sekuencë aritmetike (`true`) apo jo (`false`).\n\n  Shembuj:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) kthen true (pasi diferenca është 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) kthen false (pasi diferenca nuk është konstante)\n  - is_arithmetic_sequence(&[10, 10, 10]) kthen true (pasi diferenca është 0)",
      "hy": "Գրեք Rust ֆունկցիա `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է, արդյոք տրված թվերի հաջորդականությունը կազմում է թվաբանական հաջորդականություն:\n\n  Թվաբանական հաջորդականությունը այնպիսի թվերի հաջորդականություն է, որի դեպքում հաջորդական թվերի միջև տարբերությունը հաստատուն է:\n\n  Արգումենտներ:\n  - sequence: Թվերի զանգվածի հատված, որը ներկայացնում է ստուգվող հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հաջորդականությունը կազմում է թվաբանական հաջորդականություն (`true`) թե ոչ (`false`):\n\n  Օրինակներ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) վերադարձնում է true (քանի որ տարբերությունը 2 է)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) վերադարձնում է false (քանի որ տարբերությունը հաստատուն չէ)\n  - is_arithmetic_sequence(&[10, 10, 10]) վերադարձնում է true (քանի որ տարբերությունը 0 է)",
      "bn": "Rust ফাংশন `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা তা নির্ধারণ করে।\n\n  একটি গাণিতিক ক্রম হল এমন একটি সংখ্যার ক্রম যাতে পরপর সংখ্যার মধ্যে পার্থক্য ধ্রুবক হয়।\n\n  আর্গুমেন্টসমূহ:\n  - sequence: পূর্ণসংখ্যার একটি অ্যারে স্লাইস যা যাচাই করার জন্য ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা (`true`) বা না (`false`)।\n\n  উদাহরণসমূহ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true রিটার্ন করে (যেহেতু পার্থক্য 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false রিটার্ন করে (যেহেতু পার্থক্য ধ্রুবক নয়)\n  - is_arithmetic_sequence(&[10, 10, 10]) true রিটার্ন করে (যেহেতু পার্থক্য 0)",
      "bg": "Напишете функция на Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool`, за да решите следния проблем:\nОпределя дали дадената последователност от числа образува аритметична прогресия.\n\n  Аритметична прогресия е последователност от числа, при която разликата между последователните числа е постоянна.\n\n  Аргументи:\n  - sequence: Масив от цели числа, представляващ последователността, която трябва да бъде проверена.\n\n  Връща:\n  - Булева стойност, указваща дали последователността образува аритметична прогресия (`true`) или не (`false`).\n\n  Примери:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) връща true (тъй като разликата е 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) връща false (тъй като разликата не е постоянна)\n  - is_arithmetic_sequence(&[10, 10, 10]) връща true (тъй като разликата е 0)",
      "zh": "编写一个 Rust 函数 `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` 来解决以下问题：\n确定给定的数字序列是否构成等差数列。\n\n等差数列是指连续数字之间的差是恒定的数列。\n\n参数：\n- sequence: 一个整数数组切片，表示要检查的序列。\n\n返回：\n- 一个布尔值，指示该序列是否构成等差数列（`true`）或不构成（`false`）。\n\n示例：\n- is_arithmetic_sequence(&[5, 7, 9, 11]) 返回 true （因为差为 2）\n- is_arithmetic_sequence(&[1, 2, 4, 8]) 返回 false （因为差不是恒定的）\n- is_arithmetic_sequence(&[10, 10, 10]) 返回 true （因为差为 0）",
      "fr": "Écrire une fonction Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` pour résoudre le problème suivant :\nDétermine si la séquence de nombres donnée forme une suite arithmétique.\n\n  Une suite arithmétique est une séquence de nombres telle que la différence entre les nombres consécutifs est constante.\n\n  Arguments :\n  - sequence : Une tranche de tableau d'entiers représentant la séquence à vérifier.\n\n  Renvoie :\n  - Une valeur booléenne indiquant si la séquence forme une suite arithmétique (`true`) ou non (`false`).\n\n  Exemples :\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) renvoie true (car la différence est de 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) renvoie false (car la différence n'est pas constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) renvoie true (car la différence est de 0)",
      "de": "Schreiben Sie eine Rust-Funktion `fn is_arithmetic_sequence(sequence: &[i32]) -> bool`, um das folgende Problem zu lösen:\nBestimmt, ob die gegebene Zahlenfolge eine arithmetische Folge bildet.\n\n  Eine arithmetische Folge ist eine Zahlenfolge, bei der der Unterschied zwischen aufeinanderfolgenden Zahlen konstant ist.\n\n  Argumente:\n  - sequence: Ein Array-Slice von ganzen Zahlen, das die zu überprüfende Folge darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Folge eine arithmetische Folge bildet (`true`) oder nicht (`false`).\n\n  Beispiele:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) gibt true zurück (da der Unterschied 2 ist)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) gibt false zurück (da der Unterschied nicht konstant ist)\n  - is_arithmetic_sequence(&[10, 10, 10]) gibt true zurück (da der Unterschied 0 ist)",
      "ha": "Rubuta aikin Rust `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` don warware matsalar mai zuwa:\nTantance ko jerin lambobin da aka bayar suna samar da jerin lambobi na lissafi.\n\n  Jerin lambobi na lissafi jerin lambobi ne inda bambanci tsakanin lambobi masu jere yake daidai.\n\n  Huɗɗa:\n  - sequence: Yanke jeri na lambobi masu cikakken lamba wanda ke wakiltar jerin da za a duba.\n\n  Dawowa:\n  - Ƙimar boolean da ke nuna ko jerin yana samar da jerin lambobi na lissafi (`true`) ko a'a (`false`).\n\n  Misalai:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) yana dawowa true (domin bambancin shine 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) yana dawowa false (domin bambancin ba ya daidai)\n  - is_arithmetic_sequence(&[10, 10, 10]) yana dawowa true (domin bambancin shine 0)",
      "hi": "Rust फ़ंक्शन `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि दिए गए संख्याओं का अनुक्रम एक अंकगणितीय अनुक्रम बनाता है या नहीं।\n\n  एक अंकगणितीय अनुक्रम संख्याओं का एक अनुक्रम है जिससे कि लगातार संख्याओं के बीच का अंतर स्थिर होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक array slice जो जाँच के लिए अनुक्रम का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक boolean मान जो यह इंगित करता है कि अनुक्रम एक अंकगणितीय अनुक्रम बनाता है (`true`) या नहीं (`false`)।\n\n  उदाहरण:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true लौटाता है (क्योंकि अंतर 2 है)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false लौटाता है (क्योंकि अंतर स्थिर नहीं है)\n  - is_arithmetic_sequence(&[10, 10, 10]) true लौटाता है (क्योंकि अंतर 0 है)",
      "hu": "Írj egy Rust függvényt `fn is_arithmetic_sequence(sequence: &[i32]) -> bool` a következő probléma megoldására:\nMeghatározza, hogy a megadott számok sorozata számtani sorozatot alkot-e.\n\n  Egy számtani sorozat olyan számok sorozata, amelyben az egymást követő számok közötti különbség állandó.\n\n  Argumentumok:\n  - sequence: Egész számokat tartalmazó tömbszelet, amely a vizsgálandó sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat számtani sorozatot alkot-e (`true`) vagy sem (`false`).\n\n  Példák:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) visszaadja true (mivel a különbség 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) visszaadja false (mivel a különbség nem állandó)\n  - is_arithmetic_sequence(&[10, 10, 10]) visszaadja true (mivel a különbség 0)"
    },
    "instruction_bertscore": {
      "sq": "0.9919109763627352",
      "hy": "0.9846768578854446",
      "bn": "0.9755090726487793",
      "bg": "0.9747828799757158",
      "zh": "0.969495339232567",
      "fr": "0.9872985802847241",
      "de": "0.9896857202040014",
      "ha": "0.9660969720434411",
      "hi": "0.9785516928254717",
      "hu": "0.9854378108751892"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_arithmetic_sequence(&[5, 7, 9, 11]), true);  // True, as 2 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[1, 2, 4, 8]), false);  // False, as difference changes\n        assert_eq!(is_arithmetic_sequence(&[10, 10, 10]), true);   // True, as 0 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[3, 6, 9, 12, 16]), false); // False, last difference is not 3\n    }\n}",
    "entry_point": "is_arithmetic_sequence",
    "signature": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)",
      "sq": "Determinon nëse sekuenca e dhënë e numrave formon një sekuencë aritmetike.\n\n  Një sekuencë aritmetike është një sekuencë numrash e tillë që diferenca midis numrave të njëpasnjëshëm është konstante.\n\n  Argumentet:\n  - sequence: Një segment i vargut të numrave të plotë që përfaqëson sekuencën që do të kontrollohet.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca formon një sekuencë aritmetike (`true`) apo jo (`false`).\n\n  Shembuj:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) kthen true (pasi diferenca është 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) kthen false (pasi diferenca nuk është konstante)\n  - is_arithmetic_sequence(&[10, 10, 10]) kthen true (pasi diferenca është 0)",
      "hy": "Սահմանում է, արդյոք տրված թվերի հաջորդականությունը կազմում է թվաբանական հաջորդականություն:\n\n  Թվաբանական հաջորդականությունը թվերի հաջորդականություն է, որի դեպքում հաջորդական թվերի տարբերությունը հաստատուն է:\n\n  Արգումենտներ:\n  - sequence: Անթիվների զանգվածի հատված, որը ներկայացնում է ստուգվող հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս, արդյոք հաջորդականությունը կազմում է թվաբանական հաջորդականություն (`true`) թե ոչ (`false`):\n\n  Օրինակներ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) վերադարձնում է true (քանի որ տարբերությունը 2 է)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) վերադարձնում է false (քանի որ տարբերությունը հաստատուն չէ)\n  - is_arithmetic_sequence(&[10, 10, 10]) վերադարձնում է true (քանի որ տարբերությունը 0 է)",
      "bn": "নির্ধারণ করে যে প্রদত্ত সংখ্যার ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা।\n\nএকটি গাণিতিক ক্রম হল এমন একটি সংখ্যার ক্রম যেখানে পরপর সংখ্যার মধ্যে পার্থক্য ধ্রুবক হয়।\n\nআর্গুমেন্টস:\n- sequence: পূর্ণসংখ্যার একটি অ্যারে স্লাইস যা যাচাই করার জন্য ক্রমটি উপস্থাপন করে।\n\nরিটার্নস:\n- একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা (`true`) বা না (`false`)।\n\nউদাহরণ:\n- is_arithmetic_sequence(&[5, 7, 9, 11]) রিটার্ন করে true (যেহেতু পার্থক্য 2)\n- is_arithmetic_sequence(&[1, 2, 4, 8]) রিটার্ন করে false (যেহেতু পার্থক্য ধ্রুবক নয়)\n- is_arithmetic_sequence(&[10, 10, 10]) রিটার্ন করে true (যেহেতু পার্থক্য 0)",
      "bg": "Определя дали дадената последователност от числа образува аритметична прогресия.\n\n  Аритметична прогресия е последователност от числа, при която разликата между последователните числа е постоянна.\n\n  Аргументи:\n  - sequence: Масив от цели числа, представляващ последователността, която трябва да се провери.\n\n  Връща:\n  - Булева стойност, указваща дали последователността образува аритметична прогресия (`true`) или не (`false`).\n\n  Примери:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) връща true (тъй като разликата е 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) връща false (тъй като разликата не е постоянна)\n  - is_arithmetic_sequence(&[10, 10, 10]) връща true (тъй като разликата е 0)",
      "zh": "确定给定的数字序列是否构成等差数列。\n\n  等差数列是指连续数字之间的差是恒定的序列。\n\n  参数:\n  - sequence: 一个整数数组片段，表示要检查的序列。\n\n  返回:\n  - 一个布尔值，指示序列是否构成等差数列（`true`）或不是（`false`）。\n\n  示例:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) 返回 true （因为差是 2）\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) 返回 false （因为差不是恒定的）\n  - is_arithmetic_sequence(&[10, 10, 10]) 返回 true （因为差是 0）",
      "fr": "Détermine si la séquence de nombres donnée forme une suite arithmétique.\n\n  Une suite arithmétique est une séquence de nombres telle que la différence entre les nombres consécutifs est constante.\n\n  Arguments:\n  - sequence: Une tranche de tableau d'entiers représentant la séquence à vérifier.\n\n  Renvoie:\n  - Une valeur booléenne indiquant si la séquence forme une suite arithmétique (`true`) ou non (`false`).\n\n  Exemples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) renvoie true (car la différence est de 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) renvoie false (car la différence n'est pas constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) renvoie true (car la différence est de 0)",
      "de": "Bestimmt, ob die gegebene Zahlenfolge eine arithmetische Folge bildet.\n\n  Eine arithmetische Folge ist eine Zahlenfolge, bei der der Unterschied zwischen aufeinanderfolgenden Zahlen konstant ist.\n\n  Argumente:\n  - sequence: Ein Array-Slice von ganzen Zahlen, das die zu überprüfende Folge darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Folge eine arithmetische Folge bildet (`true`) oder nicht (`false`).\n\n  Beispiele:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) gibt true zurück (da der Unterschied 2 ist)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) gibt false zurück (da der Unterschied nicht konstant ist)\n  - is_arithmetic_sequence(&[10, 10, 10]) gibt true zurück (da der Unterschied 0 ist)",
      "ha": "Yana tantance ko jerin lambobin da aka bayar suna samar da jere na lissafi.\n\n  Wani jerin lissafi na lamba shine jerin lambobi inda bambanci tsakanin lambobi masu jere yake daidai.\n\n  Arguments:\n  - sequence: Wani yanki na jerin lambobi da ke wakiltar jerin da za a duba.\n\n  Returns:\n  - Wani ƙimar boolean da ke nuna ko jerin yana samar da jerin lissafi (`true`) ko a'a (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (domin bambanci shine 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (domin bambanci ba ya daidai)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (domin bambanci shine 0)",
      "hi": "निर्धारित करता है कि दिए गए संख्याओं का अनुक्रम एक अंकगणितीय अनुक्रम बनाता है या नहीं।\n\n  एक अंकगणितीय अनुक्रम संख्याओं का ऐसा अनुक्रम होता है जिसमें लगातार संख्याओं के बीच का अंतर स्थिर होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों की एक सरणी स्लाइस जो जांचे जाने वाले अनुक्रम का प्रतिनिधित्व करती है।\n\n  वापसी:\n  - एक बूलियन मान जो यह इंगित करता है कि अनुक्रम एक अंकगणितीय अनुक्रम बनाता है (`true`) या नहीं (`false`)।\n\n  उदाहरण:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true लौटाता है (क्योंकि अंतर 2 है)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false लौटाता है (क्योंकि अंतर स्थिर नहीं है)\n  - is_arithmetic_sequence(&[10, 10, 10]) true लौटाता है (क्योंकि अंतर 0 है)",
      "hu": "Meghatározza, hogy a megadott számok sorozata számtani sorozatot alkot-e.\n\n  Egy számtani sorozat olyan számok sorozata, amelyben az egymást követő számok közötti különbség állandó.\n\n  Argumentumok:\n  - sequence: Egész számokat tartalmazó tömbszelet, amely a vizsgálandó sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat számtani sorozatot alkot-e (`true`) vagy sem (`false`).\n\n  Példák:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) visszatérési értéke true (mivel a különbség 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) visszatérési értéke false (mivel a különbség nem állandó)\n  - is_arithmetic_sequence(&[10, 10, 10]) visszatérési értéke true (mivel a különbség 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9878152179057959",
      "hy": "0.9783904049560714",
      "bn": "0.9799222424546125",
      "bg": "0.9781357608075847",
      "zh": "0.965469498669752",
      "fr": "0.9843667958606491",
      "de": "0.9902545976152852",
      "ha": "0.978650412124846",
      "hi": "0.9841854463227643",
      "hu": "0.9859224690049143"
    }
  },
  {
    "task_id": "Rust/27",
    "prompt": {
      "en": "/*\n  Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "sq": "/*\n  Llogarit ditën e vitit për një datë të dhënë në formatin YYYY/MM/DD.\n\n  Argumentet:\n  - date: Një varg që përfaqëson një datë në formatin YYYY/MM/DD.\n\n  Kthen:\n  - Ok(usize): Dita e vitit si një numër nëse data është e vlefshme.\n  - Err(String): Një mesazh gabimi nëse data është e pavlefshme.\n\n  Shembull:\n  - day_of_year(\"1985/1/20\") kthen Ok(20)\n  - day_of_year(\"2006/3/12\") kthen Ok(71)\n  - day_of_year(\"2024/2/30\") kthen Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "hy": "/*\n  Հաշվում է տարվա օրը տրված ամսաթվի համար YYYY/MM/DD ձևաչափով:\n\n  Արգումենտներ:\n  - date: Տող, որը ներկայացնում է ամսաթիվ YYYY/MM/DD ձևաչափով:\n\n  Վերադարձնում է:\n  - Ok(usize): Տարվա օրը որպես թիվ, եթե ամսաթիվը վավեր է:\n  - Err(String): Սխալի հաղորդագրություն, եթե ամսաթիվը անվավեր է:\n\n  Օրինակ:\n  - day_of_year(\"1985/1/20\") վերադարձնում է Ok(20)\n  - day_of_year(\"2006/3/12\") վերադարձնում է Ok(71)\n  - day_of_year(\"2024/2/30\") վերադարձնում է Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "bn": "/*\n  প্রদত্ত তারিখের স্ট্রিং থেকে বছরের দিনের হিসাব করে YYYY/MM/DD ফরম্যাটে।\n\n  আর্গুমেন্টসমূহ:\n  - date: YYYY/MM/DD ফরম্যাটে একটি তারিখ নির্দেশকারী স্ট্রিং।\n\n  রিটার্নস:\n  - Ok(usize): যদি তারিখটি বৈধ হয় তবে বছরের দিনের সংখ্যা হিসাবে।\n  - Err(String): যদি তারিখটি অবৈধ হয় তবে একটি ত্রুটি বার্তা।\n\n  উদাহরণ:\n  - day_of_year(\"1985/1/20\") Ok(20) রিটার্ন করে\n  - day_of_year(\"2006/3/12\") Ok(71) রিটার্ন করে\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") রিটার্ন করে\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "bg": "/*\n  Изчислява деня от годината за дадена дата във формат YYYY/MM/DD.\n\n  Аргументи:\n  - date: Низ, представляващ дата във формат YYYY/MM/DD.\n\n  Връща:\n  - Ok(usize): Денят от годината като число, ако датата е валидна.\n  - Err(String): Съобщение за грешка, ако датата е невалидна.\n\n  Пример:\n  - day_of_year(\"1985/1/20\") връща Ok(20)\n  - day_of_year(\"2006/3/12\") връща Ok(71)\n  - day_of_year(\"2024/2/30\") връща Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "zh": "/*\n  计算给定日期字符串的年份中的第几天，格式为 YYYY/MM/DD。\n\n  参数:\n  - date: 一个表示日期的字符串，格式为 YYYY/MM/DD。\n\n  返回:\n  - Ok(usize): 如果日期有效，则返回年份中的第几天作为数字。\n  - Err(String): 如果日期无效，则返回错误信息。\n\n  示例:\n  - day_of_year(\"1985/1/20\") 返回 Ok(20)\n  - day_of_year(\"2006/3/12\") 返回 Ok(71)\n  - day_of_year(\"2024/2/30\") 返回 Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "fr": "/*\n  Calcule le jour de l'année pour une date donnée sous forme de chaîne au format AAAA/MM/JJ.\n\n  Arguments :\n  - date : Une chaîne représentant une date au format AAAA/MM/JJ.\n\n  Renvoie :\n  - Ok(usize) : Le jour de l'année en tant que nombre si la date est valide.\n  - Err(String) : Un message d'erreur si la date est invalide.\n\n  Exemple :\n  - day_of_year(\"1985/1/20\") renvoie Ok(20)\n  - day_of_year(\"2006/3/12\") renvoie Ok(71)\n  - day_of_year(\"2024/2/30\") renvoie Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "de": "/*\n  Berechnet den Tag des Jahres für ein gegebenes Datumsformat im Format JJJJ/MM/TT.\n\n  Argumente:\n  - date: Ein String, der ein Datum im Format JJJJ/MM/TT darstellt.\n\n  Rückgaben:\n  - Ok(usize): Der Tag des Jahres als Zahl, wenn das Datum gültig ist.\n  - Err(String): Eine Fehlermeldung, wenn das Datum ungültig ist.\n\n  Beispiel:\n  - day_of_year(\"1985/1/20\") gibt Ok(20) zurück\n  - day_of_year(\"2006/3/12\") gibt Ok(71) zurück\n  - day_of_year(\"2024/2/30\") gibt Err(\"Invalid\") zurück\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "ha": "/*\n  Lissafa ranar shekara don takamaiman kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Huɗɗa:\n  - date: Wani kirtani da ke wakiltar kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Komawa:\n  - Ok(usize): Ranar shekara a matsayin lamba idan kwanan wata ya inganta.\n  - Err(String): Saƙon kuskure idan kwanan wata bai inganta ba.\n\n  Misali:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "hi": "/*\n  दिए गए दिनांक स्ट्रिंग के लिए वर्ष का दिन गणना करता है, जो प्रारूप YYYY/MM/DD में है।\n\n  तर्क:\n  - date: एक स्ट्रिंग जो प्रारूप YYYY/MM/DD में दिनांक का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - Ok(usize): यदि दिनांक मान्य है तो वर्ष का दिन एक संख्या के रूप में।\n  - Err(String): यदि दिनांक अमान्य है तो एक त्रुटि संदेश।\n\n  उदाहरण:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "hu": "/*\n  Kiszámítja az év napját egy adott dátum string alapján, amely a YYYY/MM/DD formátumban van.\n\n  Argumentumok:\n  - date: Egy string, amely egy dátumot reprezentál a YYYY/MM/DD formátumban.\n\n  Visszatér:\n  - Ok(usize): Az év napja számként, ha a dátum érvényes.\n  - Err(String): Hibaüzenet, ha a dátum érvénytelen.\n\n  Példa:\n  - day_of_year(\"1985/1/20\") visszatér Ok(20)\n  - day_of_year(\"2006/3/12\") visszatér Ok(71)\n  - day_of_year(\"2024/2/30\") visszatér Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> "
    },
    "prompt_bertscore": {
      "sq": "0.9947823771509755",
      "hy": "0.9876364505628644",
      "bn": "0.9637002978658742",
      "bg": "0.9856668317045225",
      "zh": "0.9573546530829526",
      "fr": "0.9933349575643743",
      "de": "0.9937935951141839",
      "ha": "0.98157623763749",
      "hi": "0.9834979865740026",
      "hu": "0.969842346508235"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "Write a Rust function `fn day_of_year(date: &str) -> Result<usize, String>` to solve the following problem:\nCalculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "sq": "Shkruani një funksion Rust `fn day_of_year(date: &str) -> Result<usize, String>` për të zgjidhur problemin e mëposhtëm:\nLlogarit ditën e vitit për një varg date të dhënë në formatin YYYY/MM/DD.\n\n  Argumentet:\n  - date: Një varg që përfaqëson një datë në formatin YYYY/MM/DD.\n\n  Kthen:\n  - Ok(usize): Dita e vitit si një numër nëse data është e vlefshme.\n  - Err(String): Një mesazh gabimi nëse data është e pavlefshme.\n\n  Shembull:\n  - day_of_year(\"1985/1/20\") kthen Ok(20)\n  - day_of_year(\"2006/3/12\") kthen Ok(71)\n  - day_of_year(\"2024/2/30\") kthen Err(\"Invalid\")",
      "hy": "Գրեք Rust ֆունկցիա `fn day_of_year(date: &str) -> Result<usize, String>` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է տարվա օրը տրված ամսաթվի տողի համար YYYY/MM/DD ձևաչափով:\n\n  Արգումենտներ:\n  - date: Տող, որը ներկայացնում է ամսաթիվ YYYY/MM/DD ձևաչափով:\n\n  Վերադարձնում է:\n  - Ok(usize): Տարվա օրը որպես թիվ, եթե ամսաթիվը վավեր է:\n  - Err(String): Սխալի հաղորդագրություն, եթե ամսաթիվը անվավեր է:\n\n  Օրինակ:\n  - day_of_year(\"1985/1/20\") վերադարձնում է Ok(20)\n  - day_of_year(\"2006/3/12\") վերադարձնում է Ok(71)\n  - day_of_year(\"2024/2/30\") վերադարձնում է Err(\"Invalid\")",
      "bn": "Rust ফাংশন `fn day_of_year(date: &str) -> Result<usize, String>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত তারিখ স্ট্রিং-এর জন্য বছরের দিন গণনা করে, ফরম্যাট YYYY/MM/DD-এ।\n\n  আর্গুমেন্টসমূহ:\n  - date: YYYY/MM/DD ফরম্যাটে একটি তারিখ উপস্থাপনকারী একটি স্ট্রিং।\n\n  রিটার্নস:\n  - Ok(usize): বছরের দিন একটি সংখ্যা হিসেবে যদি তারিখটি বৈধ হয়।\n  - Err(String): একটি ত্রুটি বার্তা যদি তারিখটি অবৈধ হয়।\n\n  উদাহরণ:\n  - day_of_year(\"1985/1/20\") Ok(20) রিটার্ন করে\n  - day_of_year(\"2006/3/12\") Ok(71) রিটার্ন করে\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn day_of_year(date: &str) -> Result<usize, String>` за решаване на следния проблем:\nИзчислява деня от годината за даден низ с дата във формат YYYY/MM/DD.\n\n  Аргументи:\n  - date: Низ, представляващ дата във формат YYYY/MM/DD.\n\n  Връща:\n  - Ok(usize): Денят от годината като число, ако датата е валидна.\n  - Err(String): Съобщение за грешка, ако датата е невалидна.\n\n  Пример:\n  - day_of_year(\"1985/1/20\") връща Ok(20)\n  - day_of_year(\"2006/3/12\") връща Ok(71)\n  - day_of_year(\"2024/2/30\") връща Err(\"Invalid\")",
      "zh": "编写一个 Rust 函数 `fn day_of_year(date: &str) -> Result<usize, String>` 来解决以下问题：\n计算给定日期字符串（格式为 YYYY/MM/DD）在一年中的第几天。\n\n参数：\n- date: 一个表示日期的字符串，格式为 YYYY/MM/DD。\n\n返回：\n- Ok(usize): 如果日期有效，则返回该日期在一年中的天数。\n- Err(String): 如果日期无效，则返回错误信息。\n\n示例：\n- day_of_year(\"1985/1/20\") 返回 Ok(20)\n- day_of_year(\"2006/3/12\") 返回 Ok(71)\n- day_of_year(\"2024/2/30\") 返回 Err(\"Invalid\")",
      "fr": "Écrire une fonction Rust `fn day_of_year(date: &str) -> Result<usize, String>` pour résoudre le problème suivant :\nCalcule le jour de l'année pour une date donnée sous forme de chaîne au format YYYY/MM/DD.\n\n  Arguments :\n  - date : Une chaîne représentant une date au format YYYY/MM/DD.\n\n  Renvoie :\n  - Ok(usize) : Le jour de l'année en tant que nombre si la date est valide.\n  - Err(String) : Un message d'erreur si la date est invalide.\n\n  Exemple :\n  - day_of_year(\"1985/1/20\") renvoie Ok(20)\n  - day_of_year(\"2006/3/12\") renvoie Ok(71)\n  - day_of_year(\"2024/2/30\") renvoie Err(\"Invalid\")",
      "de": "Schreiben Sie eine Rust-Funktion `fn day_of_year(date: &str) -> Result<usize, String>`, um das folgende Problem zu lösen:\nBerechnet den Tag des Jahres für einen gegebenen Datumsstring im Format YYYY/MM/DD.\n\n  Argumente:\n  - date: Ein String, der ein Datum im Format YYYY/MM/DD darstellt.\n\n  Rückgabewerte:\n  - Ok(usize): Der Tag des Jahres als Zahl, wenn das Datum gültig ist.\n  - Err(String): Eine Fehlermeldung, wenn das Datum ungültig ist.\n\n  Beispiel:\n  - day_of_year(\"1985/1/20\") gibt Ok(20) zurück\n  - day_of_year(\"2006/3/12\") gibt Ok(71) zurück\n  - day_of_year(\"2024/2/30\") gibt Err(\"Invalid\") zurück",
      "ha": "Rubuta aikin Rust `fn day_of_year(date: &str) -> Result<usize, String>` don warware matsalar mai zuwa:\nYana lissafin ranar shekara don wata takamaiman kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Huɗɗa:\n  - date: Wata kirtani da ke wakiltar kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Dawowa:\n  - Ok(usize): Ranar shekara a matsayin lamba idan kwanan wata ya dace.\n  - Err(String): Saƙon kuskure idan kwanan wata ba daidai ba ne.\n\n  Misali:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "hi": "Rust फ़ंक्शन `fn day_of_year(date: &str) -> Result<usize, String>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nYYYY/MM/DD प्रारूप में दिए गए दिनांक स्ट्रिंग के लिए वर्ष का दिन गणना करता है।\n\n  तर्क:\n  - date: YYYY/MM/DD प्रारूप में दिनांक को दर्शाने वाली एक स्ट्रिंग।\n\n  लौटाता है:\n  - Ok(usize): यदि दिनांक मान्य है तो वर्ष के दिन को एक संख्या के रूप में।\n  - Err(String): यदि दिनांक अमान्य है तो एक त्रुटि संदेश।\n\n  उदाहरण:\n  - day_of_year(\"1985/1/20\") Ok(20) लौटाता है\n  - day_of_year(\"2006/3/12\") Ok(71) लौटाता है\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") लौटाता है",
      "hu": "Írj egy Rust függvényt `fn day_of_year(date: &str) -> Result<usize, String>` a következő probléma megoldására:\nKiszámítja az év napját egy adott dátum karakterlánc alapján, amely a YYYY/MM/DD formátumban van.\n\n  Argumentumok:\n  - date: Egy karakterlánc, amely egy dátumot reprezentál a YYYY/MM/DD formátumban.\n\n  Visszatérési érték:\n  - Ok(usize): Az év napja számként, ha a dátum érvényes.\n  - Err(String): Egy hibaüzenet, ha a dátum érvénytelen.\n\n  Példa:\n  - day_of_year(\"1985/1/20\") visszatérési értéke Ok(20)\n  - day_of_year(\"2006/3/12\") visszatérési értéke Ok(71)\n  - day_of_year(\"2024/2/30\") visszatérési értéke Err(\"Invalid\")"
    },
    "instruction_bertscore": {
      "sq": "0.9989822179275772",
      "hy": "0.9987676971160595",
      "bn": "0.9875514367597815",
      "bg": "1",
      "zh": "0.9513450909047421",
      "fr": "0.9934211631497435",
      "de": "0.9934304987776521",
      "ha": "0.9793577349117113",
      "hi": "0.9859026059668109",
      "hu": "0.9412930032117095"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(day_of_year(\"1985/1/20\"), Ok(20));\n        assert_eq!(day_of_year(\"2006/3/12\"), Ok(71));\n        assert_eq!(day_of_year(\"2024/2/30\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/13/10\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/2/29\"), Ok(60)); // Leap year case\n\n    }\n    \n\n}",
    "entry_point": "day_of_year",
    "signature": "fn day_of_year(date: &str) -> Result<usize, String>",
    "docstring": {
      "en": "Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "sq": "Llogarit ditën e vitit për një datë të dhënë në formatin YYYY/MM/DD.\n\n  Argumentet:\n  - date: Një varg që përfaqëson një datë në formatin YYYY/MM/DD.\n\n  Kthen:\n  - Ok(usize): Dita e vitit si një numër nëse data është e vlefshme.\n  - Err(String): Një mesazh gabimi nëse data është e pavlefshme.\n\n  Shembull:\n  - day_of_year(\"1985/1/20\") kthen Ok(20)\n  - day_of_year(\"2006/3/12\") kthen Ok(71)\n  - day_of_year(\"2024/2/30\") kthen Err(\"Invalid\")",
      "hy": "Հաշվում է տարվա օրը տրված ամսաթվի տողի համար YYYY/MM/DD ձևաչափով:\n\n  Արհամարհանքներ:\n  - date: Տող, որը ներկայացնում է ամսաթիվը YYYY/MM/DD ձևաչափով:\n\n  Վերադարձնում է:\n  - Ok(usize): Տարվա օրը որպես թիվ, եթե ամսաթիվը վավեր է:\n  - Err(String): Սխալի հաղորդագրություն, եթե ամսաթիվը անվավեր է:\n\n  Օրինակ:\n  - day_of_year(\"1985/1/20\") վերադարձնում է Ok(20)\n  - day_of_year(\"2006/3/12\") վերադարձնում է Ok(71)\n  - day_of_year(\"2024/2/30\") վերադարձնում է Err(\"Invalid\")",
      "bn": "প্রদত্ত তারিখের স্ট্রিং থেকে বছরের দিনের হিসাব করে YYYY/MM/DD ফরম্যাটে।\n\n  আর্গুমেন্টস:\n  - date: YYYY/MM/DD ফরম্যাটে একটি তারিখ উপস্থাপনকারী একটি স্ট্রিং।\n\n  রিটার্নস:\n  - Ok(usize): বছরের দিনের সংখ্যা যদি তারিখটি বৈধ হয়।\n  - Err(String): একটি ত্রুটি বার্তা যদি তারিখটি অবৈধ হয়।\n\n  উদাহরণ:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "bg": "Изчислява деня от годината за даден низ с дата във формат YYYY/MM/DD.\n\nАргументи:\n- date: Низ, представляващ дата във формат YYYY/MM/DD.\n\nВръща:\n- Ok(usize): Денят от годината като число, ако датата е валидна.\n- Err(String): Съобщение за грешка, ако датата е невалидна.\n\nПример:\n- day_of_year(\"1985/1/20\") връща Ok(20)\n- day_of_year(\"2006/3/12\") връща Ok(71)\n- day_of_year(\"2024/2/30\") връща Err(\"Invalid\")",
      "zh": "计算给定日期字符串（格式为 YYYY/MM/DD）在一年中的第几天。\n\n  参数:\n  - date: 一个表示日期的字符串，格式为 YYYY/MM/DD。\n\n  返回:\n  - Ok(usize): 如果日期有效，则返回一年中的第几天作为数字。\n  - Err(String): 如果日期无效，则返回错误信息。\n\n  示例:\n  - day_of_year(\"1985/1/20\") 返回 Ok(20)\n  - day_of_year(\"2006/3/12\") 返回 Ok(71)\n  - day_of_year(\"2024/2/30\") 返回 Err(\"Invalid\")",
      "fr": "Calcule le jour de l'année pour une date donnée sous la forme AAAA/MM/JJ.\n\n  Arguments:\n  - date: Une chaîne de caractères représentant une date au format AAAA/MM/JJ.\n\n  Retourne:\n  - Ok(usize): Le jour de l'année en tant que nombre si la date est valide.\n  - Err(String): Un message d'erreur si la date est invalide.\n\n  Exemple:\n  - day_of_year(\"1985/1/20\") retourne Ok(20)\n  - day_of_year(\"2006/3/12\") retourne Ok(71)\n  - day_of_year(\"2024/2/30\") retourne Err(\"Invalid\")",
      "de": "Berechnet den Tag des Jahres für einen gegebenen Datumsstring im Format YYYY/MM/DD.\n\n  Argumente:\n  - date: Ein String, der ein Datum im Format YYYY/MM/DD darstellt.\n\n  Rückgaben:\n  - Ok(usize): Der Tag des Jahres als Zahl, wenn das Datum gültig ist.\n  - Err(String): Eine Fehlermeldung, wenn das Datum ungültig ist.\n\n  Beispiel:\n  - day_of_year(\"1985/1/20\") gibt Ok(20) zurück\n  - day_of_year(\"2006/3/12\") gibt Ok(71) zurück\n  - day_of_year(\"2024/2/30\") gibt Err(\"Invalid\") zurück",
      "ha": "Lissafa ranar shekara don takamaiman kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Huɗɗa:\n  - date: Wani kirtani da ke wakiltar kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Mayarwa:\n  - Ok(usize): Ranar shekara a matsayin lamba idan kwanan wata ya dace.\n  - Err(String): Saƙon kuskure idan kwanan wata ba daidai ba ne.\n\n  Misali:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "hi": "दिए गए दिनांक स्ट्रिंग के लिए वर्ष का दिन गणना करता है, जो प्रारूप YYYY/MM/DD में है।\n\n  तर्क:\n  - date: YYYY/MM/DD प्रारूप में एक तिथि का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n\n  वापसी:\n  - Ok(usize): यदि तिथि मान्य है तो वर्ष का दिन एक संख्या के रूप में।\n  - Err(String): यदि तिथि अमान्य है तो एक त्रुटि संदेश।\n\n  उदाहरण:\n  - day_of_year(\"1985/1/20\") Ok(20) लौटाता है\n  - day_of_year(\"2006/3/12\") Ok(71) लौटाता है\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") लौटाता है",
      "hu": "Számítja az év napját egy adott dátum karakterlánc alapján, amely az YYYY/MM/DD formátumban van.\n\n  Argumentumok:\n  - date: Egy karakterlánc, amely egy dátumot reprezentál az YYYY/MM/DD formátumban.\n\n  Visszatér:\n  - Ok(usize): Az év napja számként, ha a dátum érvényes.\n  - Err(String): Hibaüzenet, ha a dátum érvénytelen.\n\n  Példa:\n  - day_of_year(\"1985/1/20\") visszatér Ok(20)\n  - day_of_year(\"2006/3/12\") visszatér Ok(71)\n  - day_of_year(\"2024/2/30\") visszatér Err(\"Invalid\")"
    },
    "docstring_bertscore": {
      "sq": "0.9925108401134606",
      "hy": "0.9883612528232607",
      "bn": "0.9912827084675219",
      "bg": "0.9917042021360779",
      "zh": "0.9321202522155183",
      "fr": "0.9888316095655514",
      "de": "1",
      "ha": "0.9895452885246097",
      "hi": "0.9984407515088761",
      "hu": "0.98931308960918"
    }
  },
  {
    "task_id": "Rust/28",
    "prompt": {
      "en": "/*\n  Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "sq": "/*\n  Heq numrat e përsëritur nga një vektor i dhënë dhe pastaj rendit numrat e mbetur në rend rritës.\n\n  Argumentet:\n  - numbers: Një vektor i numrave të plotë që variojnë nga 1 deri në 1000, me një gjatësi që nuk e kalon 100.\n\n  Kthen:\n  - Një vektor që përmban elementet unike të vektorit origjinal, të renditur në rend rritës.\n\n  Shembuj:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) kthen vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) kthen vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) kthen vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "hy": "/*\n  Հեռացնում է կրկնվող թվերը տրված վեկտորից և այնուհետև դասավորում մնացած թվերը աճման կարգով։\n\n  Արգումենտներ:\n  - numbers: ամբողջ թվերի վեկտոր, որոնք տատանվում են 1-ից մինչև 1000, և որոնց երկարությունը չի գերազանցում 100-ը։\n\n  Վերադարձնում է:\n  - Վեկտոր, որը պարունակում է սկզբնական վեկտորի եզակի տարրերը, դասավորված աճման կարգով։\n\n  Օրինակներ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) վերադարձնում է vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) վերադարձնում է vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) վերադարձնում է vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "bn": "/*\n  প্রদত্ত ভেক্টর থেকে সদৃশ সংখ্যা সরিয়ে দেয় এবং তারপর অবশিষ্ট সংখ্যাগুলি ঊর্ধ্বক্রমে সাজায়।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি ভেক্টর যা 1 থেকে 1000 এর মধ্যে রয়েছে, যার দৈর্ঘ্য 100 অতিক্রম করবে না।\n\n  রিটার্নস:\n  - একটি ভেক্টর যা মূল ভেক্টরের অনন্য উপাদানগুলি ঊর্ধ্বক্রমে সাজানো অবস্থায় ধারণ করে।\n\n  উদাহরণসমূহ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "bg": "/*\n  Премахва дублиращите се числа от даден вектор и след това сортира останалите числа във възходящ ред.\n\n  Аргументи:\n  - numbers: Вектор от цели числа в диапазона от 1 до 1000, с дължина, която не надвишава 100.\n\n  Връща:\n  - Вектор, съдържащ уникалните елементи на оригиналния вектор, сортирани във възходящ ред.\n\n  Примери:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) връща vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) връща vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) връща vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "zh": "/*\n  从给定的向量中移除重复的数字，然后将剩余的数字按升序排序。\n\n  参数：\n  - numbers: 一个整数向量，范围从1到1000，长度不超过100。\n\n  返回：\n  - 一个包含原始向量中唯一元素的向量，按升序排序。\n\n  示例：\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) 返回 vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) 返回 vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) 返回 vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "fr": "/*\n  Supprime les nombres en double d'un vecteur donné, puis trie les nombres restants par ordre croissant.\n\n  Arguments :\n  - numbers : Un vecteur d'entiers allant de 1 à 1000, avec une longueur ne dépassant pas 100.\n\n  Renvoie :\n  - Un vecteur contenant les éléments uniques du vecteur original, triés par ordre croissant.\n\n  Exemples :\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "de": "/*\n  Entfernt doppelte Zahlen aus einem gegebenen Vektor und sortiert dann die verbleibenden Zahlen in aufsteigender Reihenfolge.\n\n  Argumente:\n  - numbers: Ein Vektor von ganzen Zahlen im Bereich von 1 bis 1000, mit einer Länge von höchstens 100.\n\n  Rückgabewert:\n  - Ein Vektor, der die einzigartigen Elemente des ursprünglichen Vektors enthält, sortiert in aufsteigender Reihenfolge.\n\n  Beispiele:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) gibt vec![2, 3, 5] zurück\n  - dedup_and_sort(vec![7, 5, 7, 5]) gibt vec![5, 7] zurück\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) gibt vec![1, 2, 3, 4, 5] zurück\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "ha": "/*\n  Yana cire lambobi masu maimaituwa daga wani vector da aka bayar sannan yana tsara sauran lambobin cikin tsari mai hawa.\n\n  Huɗɗa:\n  - numbers: Wani vector na lambobi masu ɗaukar ƙima daga 1 zuwa 1000, tare da tsawon da bai wuce 100 ba.\n\n  Yana dawowa:\n  - Wani vector da ke ɗauke da abubuwan musamman na vector na asali, an tsara su cikin tsari mai hawa.\n\n  Misalai:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) yana dawowa vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) yana dawowa vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) yana dawowa vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "hi": "/*\n  दिए गए वेक्टर से डुप्लिकेट संख्याओं को हटाता है और फिर शेष संख्याओं को आरोही क्रम में व्यवस्थित करता है।\n\n  तर्क:\n  - numbers: 1 से 1000 के बीच की पूर्णांक संख्याओं का एक वेक्टर, जिसकी लंबाई 100 से अधिक नहीं है।\n\n  वापसी:\n  - मूल वेक्टर के अद्वितीय तत्वों को शामिल करने वाला एक वेक्टर, जो आरोही क्रम में व्यवस्थित है।\n\n  उदाहरण:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "hu": "/*\n  Eltávolítja a duplikált számokat egy adott vektorból, majd a megmaradt számokat növekvő sorrendbe rendezi.\n\n  Argumentumok:\n  - numbers: Egy 1 és 1000 közötti egész számokat tartalmazó vektor, melynek hossza nem haladja meg a 100-at.\n\n  Visszatérési érték:\n  - Egy vektor, amely az eredeti vektor egyedi elemeit tartalmazza, növekvő sorrendben rendezve.\n\n  Példák:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) visszaadja vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) visszaadja vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) visszaadja vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "sq": "0.9944891987085681",
      "hy": "0.9981753813198135",
      "bn": "0.9934855193931987",
      "bg": "0.9902796250432957",
      "zh": "0.9783171103454695",
      "fr": "0.9989619576287116",
      "de": "0.9712337523273844",
      "ha": "0.9908379750443848",
      "hi": "0.9860650856184974",
      "hu": "0.9916968528119796"
    },
    "canonical_solution": "{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}",
    "instruction": {
      "en": "Write a Rust function `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` to solve the following problem:\nRemoves duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "sq": "Shkruani një funksion në Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` për të zgjidhur problemin në vijim:\nHeq numrat e përsëritur nga një vektor i dhënë dhe pastaj rendit numrat e mbetur në rend rritës.\n\n  Argumentet:\n  - numbers: Një vektor i numrave të plotë që variojnë nga 1 deri në 1000, me një gjatësi që nuk e kalon 100.\n\n  Kthen:\n  - Një vektor që përmban elementet unike të vektorit origjinal, të renditura në rend rritës.\n\n  Shembuj:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) kthen vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) kthen vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) kthen vec![1, 2, 3, 4, 5]",
      "hy": "Գրեք Rust ֆունկցիա `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` հետևյալ խնդիրը լուծելու համար:\nՀեռացնում է կրկնվող թվերը տրված վեկտորից և ապա դասավորում մնացած թվերը աճման կարգով։\n\n  Արգումենտներ:\n  - numbers: Թվերի վեկտոր, որոնք տատանվում են 1-ից 1000-ի միջև, և որոնց երկարությունը չի գերազանցում 100-ը։\n\n  Վերադարձնում է:\n  - Վեկտոր, որը պարունակում է սկզբնական վեկտորի եզակի տարրերը, դասավորված աճման կարգով։\n\n  Օրինակներ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) վերադարձնում է vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) վերադարձնում է vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) վերադարձնում է vec![1, 2, 3, 4, 5]",
      "bn": "Rust ফাংশন `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ভেক্টর থেকে সদৃশ সংখ্যা সরিয়ে দেয় এবং তারপর অবশিষ্ট সংখ্যাগুলি ঊর্ধ্বক্রমে সাজায়।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি ভেক্টর যা 1 থেকে 1000 পর্যন্ত, যার দৈর্ঘ্য 100 অতিক্রম করবে না।\n\n  রিটার্নস:\n  - মূল ভেক্টরের অনন্য উপাদানগুলি ধারণকারী একটি ভেক্টর, যা ঊর্ধ্বক্রমে সাজানো।\n\n  উদাহরণসমূহ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "bg": "Напишете Rust функция `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` за решаване на следния проблем:\nПремахва дублиращите се числа от даден вектор и след това сортира останалите числа във възходящ ред.\n\n  Аргументи:\n  - numbers: Вектор от цели числа в диапазона от 1 до 1000, с дължина, която не надвишава 100.\n\n  Връща:\n  - Вектор, съдържащ уникалните елементи на оригиналния вектор, сортирани във възходящ ред.\n\n  Примери:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) връща vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) връща vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) връща vec![1, 2, 3, 4, 5]",
      "zh": "编写一个 Rust 函数 `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` 来解决以下问题：\n从给定的向量中删除重复的数字，然后按升序排序剩余的数字。\n\n参数：\n- numbers: 一个整数向量，范围从 1 到 1000，长度不超过 100。\n\n返回：\n- 一个包含原始向量中唯一元素的向量，按升序排序。\n\n示例：\n- dedup_and_sort(vec![2, 3, 2, 5, 3]) 返回 vec![2, 3, 5]\n- dedup_and_sort(vec![7, 5, 7, 5]) 返回 vec![5, 7]\n- dedup_and_sort(vec![1, 2, 3, 4, 5]) 返回 vec![1, 2, 3, 4, 5]",
      "fr": "Écrire une fonction Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` pour résoudre le problème suivant :\nSupprime les nombres dupliqués d'un vecteur donné, puis trie les nombres restants par ordre croissant.\n\n  Arguments :\n  - numbers : Un vecteur d'entiers allant de 1 à 1000, avec une longueur ne dépassant pas 100.\n\n  Renvoie :\n  - Un vecteur contenant les éléments uniques du vecteur original, triés par ordre croissant.\n\n  Exemples :\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) renvoie vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) renvoie vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) renvoie vec![1, 2, 3, 4, 5]",
      "de": "Schreiben Sie eine Rust-Funktion `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>`, um das folgende Problem zu lösen:\nEntfernt doppelte Zahlen aus einem gegebenen Vektor und sortiert dann die verbleibenden Zahlen in aufsteigender Reihenfolge.\n\n  Argumente:\n  - numbers: Ein Vektor von ganzen Zahlen im Bereich von 1 bis 1000, mit einer Länge von maximal 100.\n\n  Rückgabewerte:\n  - Ein Vektor, der die einzigartigen Elemente des ursprünglichen Vektors enthält, sortiert in aufsteigender Reihenfolge.\n\n  Beispiele:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) gibt vec![2, 3, 5] zurück\n  - dedup_and_sort(vec![7, 5, 7, 5]) gibt vec![5, 7] zurück\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) gibt vec![1, 2, 3, 4, 5] zurück",
      "ha": "Rubuta aikin Rust `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` don warware matsalar mai zuwa:\nCire lambobi masu maimaituwa daga wani vector da aka bayar sannan a jera sauran lambobi a cikin tsari mai hawa.\n\n  Huɗɗa:\n  - numbers: Wani vector na lambobi masu lamba daga 1 zuwa 1000, tare da tsawon da bai wuce 100 ba.\n\n  Komawa:\n  - Wani vector da ke ɗauke da abubuwan musamman na vector na asali, an jera su a cikin tsari mai hawa.\n\n  Misalai:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "hi": "Rust फ़ंक्शन `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए वेक्टर से डुप्लिकेट संख्याओं को हटाता है और फिर शेष संख्याओं को आरोही क्रम में सॉर्ट करता है।\n\n  तर्क:\n  - numbers: पूर्णांकों का एक वेक्टर जो 1 से 1000 तक की सीमा में है, जिसकी लंबाई 100 से अधिक नहीं है।\n\n  वापसी:\n  - एक वेक्टर जो मूल वेक्टर के अद्वितीय तत्वों को आरोही क्रम में सॉर्ट करके रखता है।\n\n  उदाहरण:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "hu": "Írj egy Rust függvényt `fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>` a következő probléma megoldására:\nEltávolítja az ismétlődő számokat egy adott vektorból, majd a megmaradt számokat növekvő sorrendbe rendezi.\n\n  Argumentumok:\n  - numbers: Egész számok vektora, amely 1 és 1000 között mozog, hossza nem haladja meg a 100-at.\n\n  Visszatérési érték:\n  - Egy vektor, amely az eredeti vektor egyedi elemeit tartalmazza, növekvő sorrendbe rendezve.\n\n  Példák:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) visszaadja vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) visszaadja vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) visszaadja vec![1, 2, 3, 4, 5]"
    },
    "instruction_bertscore": {
      "sq": "0.995695878273355",
      "hy": "0.9954746040288821",
      "bn": "0.9874455667666899",
      "bg": "0.9917624008377212",
      "zh": "0.9874026626043864",
      "fr": "0.9989905604035807",
      "de": "0.9760984089893099",
      "ha": "0.9862929146655445",
      "hi": "0.9790985222644608",
      "hu": "0.9933434986707588"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(dedup_and_sort(vec![10, 20, 20, 10, 30]), vec![10, 20, 30]);\n        assert_eq!(dedup_and_sort(vec![5, 4, 3, 2, 1]), vec![1, 2, 3, 4, 5]);\n        assert_eq!(dedup_and_sort(vec![1, 1, 1, 1, 1]), vec![1]);\n        assert_eq!(dedup_and_sort(vec![50]), vec![50]);\n    }\n    \n\n}",
    "entry_point": "dedup_and_sort",
    "signature": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>",
    "docstring": {
      "en": "Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "sq": "Heq numrat e dyfishtë nga një vektor i dhënë dhe pastaj rendit numrat e mbetur në rend rritës.\n\n  Argumentet:\n  - numbers: Një vektor i numrave të plotë që variojnë nga 1 deri në 1000, me një gjatësi që nuk e kalon 100.\n\n  Kthen:\n  - Një vektor që përmban elementet unike të vektorit origjinal, të renditura në rend rritës.\n\n  Shembuj:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) kthen vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) kthen vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) kthen vec![1, 2, 3, 4, 5]",
      "hy": "Հեռացնում է կրկնվող թվերը տրված վեկտորից և ապա դասավորում մնացած թվերը աճման կարգով։\n\n  Արձանագրություններ:\n  - numbers: 1-ից մինչև 1000 միջակայքում գտնվող ամբողջ թվերի վեկտոր, որի երկարությունը չի գերազանցում 100-ը։\n\n  Վերադարձնում է:\n  - Վեկտոր, որը պարունակում է սկզբնական վեկտորի եզակի տարրերը, դասավորված աճման կարգով։\n\n  Օրինակներ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) վերադարձնում է vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) վերադարձնում է vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) վերադարձնում է vec![1, 2, 3, 4, 5]",
      "bn": "ডুপ্লিকেট সংখ্যা একটি প্রদত্ত ভেক্টর থেকে সরিয়ে দেয় এবং তারপর অবশিষ্ট সংখ্যাগুলি ঊর্ধ্বক্রমে সাজায়।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি ভেক্টর যা 1 থেকে 1000 এর মধ্যে রয়েছে, যার দৈর্ঘ্য 100 অতিক্রম করে না।\n\n  রিটার্নস:\n  - একটি ভেক্টর যা মূল ভেক্টরের অনন্য উপাদানগুলি ঊর্ধ্বক্রমে সাজানো অবস্থায় ধারণ করে।\n\n  উদাহরণসমূহ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) রিটার্ন করে vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) রিটার্ন করে vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) রিটার্ন করে vec![1, 2, 3, 4, 5]",
      "bg": "Премахва дублиращите се числа от даден вектор и след това сортира останалите числа във възходящ ред.\n\n  Аргументи:\n  - numbers: Вектор от цели числа в диапазона от 1 до 1000, с дължина, която не надвишава 100.\n\n  Връща:\n  - Вектор, съдържащ уникалните елементи на оригиналния вектор, сортирани във възходящ ред.\n\n  Примери:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) връща vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) връща vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) връща vec![1, 2, 3, 4, 5]",
      "zh": "删除给定向量中的重复数字，然后将剩余数字按升序排序。\n\n  参数:\n  - numbers: 一个整数向量，范围从1到1000，长度不超过100。\n\n  返回值:\n  - 一个包含原始向量中唯一元素的向量，按升序排序。\n\n  示例:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) 返回 vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) 返回 vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) 返回 vec![1, 2, 3, 4, 5]",
      "fr": "Supprime les numéros en double d'un vecteur donné, puis trie les numéros restants par ordre croissant.\n\n  Arguments:\n  - numbers: Un vecteur d'entiers allant de 1 à 1000, avec une longueur ne dépassant pas 100.\n\n  Retourne:\n  - Un vecteur contenant les éléments uniques du vecteur original, triés par ordre croissant.\n\n  Exemples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) retourne vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) retourne vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) retourne vec![1, 2, 3, 4, 5]",
      "de": "Entfernt doppelte Zahlen aus einem gegebenen Vektor und sortiert dann die verbleibenden Zahlen in aufsteigender Reihenfolge.\n\n  Argumente:\n  - numbers: Ein Vektor von ganzen Zahlen im Bereich von 1 bis 1000, mit einer Länge von maximal 100.\n\n  Rückgabewerte:\n  - Ein Vektor, der die einzigartigen Elemente des ursprünglichen Vektors enthält, sortiert in aufsteigender Reihenfolge.\n\n  Beispiele:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) gibt vec![2, 3, 5] zurück\n  - dedup_and_sort(vec![7, 5, 7, 5]) gibt vec![5, 7] zurück\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) gibt vec![1, 2, 3, 4, 5] zurück",
      "ha": "Yana cire lambobi masu maimaituwa daga wani vector da aka bayar sannan yana tsara sauran lambobin cikin tsari mai hawa.\n\n  Huɗɗa:\n  - numbers: Wani vector na lambobi masu ɗauke da ƙima daga 1 zuwa 1000, tare da tsawon da bai wuce 100 ba.\n\n  Dawowa:\n  - Wani vector da ke ɗauke da abubuwan da ba su maimaita ba na vector na asali, an jera su a cikin tsari mai hawa.\n\n  Misalai:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "hi": "डुप्लिकेट संख्याओं को दिए गए वेक्टर से हटाता है और फिर शेष संख्याओं को आरोही क्रम में क्रमबद्ध करता है।\n\n  तर्क:\n  - numbers: पूर्णांकों का एक वेक्टर जो 1 से 1000 तक की सीमा में होता है, जिसकी लंबाई 100 से अधिक नहीं होती।\n\n  वापसी:\n  - मूल वेक्टर के अद्वितीय तत्वों वाला एक वेक्टर, जो आरोही क्रम में क्रमबद्ध होता है।\n\n  उदाहरण:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) vec![2, 3, 5] लौटाता है\n  - dedup_and_sort(vec![7, 5, 7, 5]) vec![5, 7] लौटाता है\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) vec![1, 2, 3, 4, 5] लौटाता है",
      "hu": "Eltávolítja az ismétlődő számokat egy adott vektorból, majd a megmaradt számokat növekvő sorrendbe rendezi.\n\n  Argumentumok:\n  - numbers: Egy 1-től 1000-ig terjedő egész számokat tartalmazó vektor, amelynek hossza nem haladja meg a 100-at.\n\n  Visszatérési érték:\n  - Egy vektor, amely az eredeti vektor egyedi elemeit tartalmazza, növekvő sorrendbe rendezve.\n\n  Példák:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) visszaadja vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) visszaadja vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) visszaadja vec![1, 2, 3, 4, 5]"
    },
    "docstring_bertscore": {
      "sq": "0.9899487068284916",
      "hy": "0.9900349124138607",
      "bn": "0.9826349375684059",
      "bg": "0.9896372543910289",
      "zh": "0.9739154611017364",
      "fr": "0.998878532868677",
      "de": "0.9725786786373716",
      "ha": "0.9665828219554525",
      "hi": "0.9919111749931162",
      "hu": "0.9916771884042571"
    }
  },
  {
    "task_id": "Rust/29",
    "prompt": {
      "en": "/*\n  Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "sq": "/*\n  Llogarit numrin e kombinimeve C(n, m), i cili përfaqëson numrin e mënyrave për të zgjedhur m elemente nga një grup prej n elementesh të dallueshme.\n\n  Argumentet:\n  - n: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin total të elementeve (n ≤ 20).\n  - m: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin e elementeve për të zgjedhur (m ≤ n).\n\n  Kthen:\n  - Numrin e kombinimeve C(n, m).\n\n  Shembull:\n  - calculate_combinations(5, 2) kthen 10\n  - calculate_combinations(18, 13) kthen 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "hy": "/*\n  Հաշվում է կոմբինացիայի թիվը C(n, m), որը ներկայացնում է n տարբեր տարրերից m տարր ընտրելու եղանակների քանակը:\n\n  Արգումենտներ:\n  - n: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է տարրերի ընդհանուր քանակը (n ≤ 20):\n  - m: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է ընտրելու տարրերի քանակը (m ≤ n):\n\n  Վերադարձնում է:\n  - Կոմբինացիայի թիվը C(n, m):\n\n  Օրինակ:\n  - calculate_combinations(5, 2) վերադարձնում է 10\n  - calculate_combinations(18, 13) վերադարձնում է 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64",
      "bn": "/*\n  C(n, m) সংখ্যাটি গণনা করে, যা n ভিন্ন উপাদানের একটি সেট থেকে m উপাদান বেছে নেওয়ার উপায়ের সংখ্যা উপস্থাপন করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: একটি আনসাইনড 32-বিট পূর্ণসংখ্যা যা মোট উপাদানের সংখ্যা উপস্থাপন করে (n ≤ 20)।\n  - m: একটি আনসাইনড 32-বিট পূর্ণসংখ্যা যা বেছে নেওয়ার উপাদানের সংখ্যা উপস্থাপন করে (m ≤ n)।\n\n  রিটার্নস:\n  - C(n, m) সংখ্যাটি।\n\n  উদাহরণ:\n  - calculate_combinations(5, 2) 10 রিটার্ন করে\n  - calculate_combinations(18, 13) 8568 রিটার্ন করে\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "bg": "/*\n  Изчислява числото на комбинацията C(n, m), което представлява броя начини да се изберат m елемента от множество от n различни елемента.\n\n  Аргументи:\n  - n: Беззнаков 32-битов целочислен тип, представляващ общия брой елементи (n ≤ 20).\n  - m: Беззнаков 32-битов целочислен тип, представляващ броя на елементите за избор (m ≤ n).\n\n  Връща:\n  - Числото на комбинацията C(n, m).\n\n  Пример:\n  - calculate_combinations(5, 2) връща 10\n  - calculate_combinations(18, 13) връща 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "zh": "/*\n  计算组合数 C(n, m)，表示从 n 个不同元素的集合中选择 m 个元素的方法数。\n\n  参数:\n  - n: 一个无符号的 32 位整数，表示元素的总数 (n ≤ 20)。\n  - m: 一个无符号的 32 位整数，表示要选择的元素数量 (m ≤ n)。\n\n  返回:\n  - 组合数 C(n, m)。\n\n  示例:\n  - calculate_combinations(5, 2) 返回 10\n  - calculate_combinations(18, 13) 返回 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "fr": "/*\n  Calcule le nombre de combinaisons C(n, m), qui représente le nombre de façons de choisir m éléments parmi un ensemble de n éléments distincts.\n\n  Arguments :\n  - n : Un entier non signé de 32 bits représentant le nombre total d'éléments (n ≤ 20).\n  - m : Un entier non signé de 32 bits représentant le nombre d'éléments à choisir (m ≤ n).\n\n  Retourne :\n  - Le nombre de combinaisons C(n, m).\n\n  Exemple :\n  - calculate_combinations(5, 2) retourne 10\n  - calculate_combinations(18, 13) retourne 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "de": "/*\n  Berechnet die Kombinationszahl C(n, m), die die Anzahl der Möglichkeiten darstellt, m Elemente aus einer Menge von n verschiedenen Elementen auszuwählen.\n\n  Argumente:\n  - n: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Gesamtzahl der Elemente darstellt (n ≤ 20).\n  - m: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Anzahl der auszuwählenden Elemente darstellt (m ≤ n).\n\n  Rückgabewert:\n  - Die Kombinationszahl C(n, m).\n\n  Beispiel:\n  - calculate_combinations(5, 2) gibt 10 zurück\n  - calculate_combinations(18, 13) gibt 8568 zurück\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "ha": "/*\n  Lissafa adadin haɗuwa C(n, m), wanda ke wakiltar yawan hanyoyin zaɓar abubuwa m daga saitin abubuwa n daban-daban.\n\n  Huɗɗa:\n  - n: Lamba mai lamba 32-bit marar alama wanda ke wakiltar jimlar yawan abubuwa (n ≤ 20).\n  - m: Lamba mai lamba 32-bit marar alama wanda ke wakiltar yawan abubuwan da za a zaɓa (m ≤ n).\n\n  Mayarwa:\n  - Lambar haɗuwa C(n, m).\n\n  Misali:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "hi": "/*\n  संयोजन संख्या C(n, m) की गणना करता है, जो n भिन्न तत्वों के सेट से m तत्वों को चुनने के तरीकों की संख्या को दर्शाता है।\n\n  तर्क:\n  - n: एक बिना चिन्हित 32-बिट पूर्णांक जो तत्वों की कुल संख्या का प्रतिनिधित्व करता है (n ≤ 20)।\n  - m: एक बिना चिन्हित 32-बिट पूर्णांक जो चुने जाने वाले तत्वों की संख्या का प्रतिनिधित्व करता है (m ≤ n)।\n\n  लौटाता है:\n  - संयोजन संख्या C(n, m)।\n\n  उदाहरण:\n  - calculate_combinations(5, 2) 10 लौटाता है\n  - calculate_combinations(18, 13) 8568 लौटाता है\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "hu": "/*\n  Számítja a C(n, m) kombinációs számot, amely azt jelenti, hogy hányféleképpen választható ki m elem egy n különböző elemből álló halmazból.\n\n  Argumentumok:\n  - n: Egy 32 bites előjelnélküli egész szám, amely az elemek teljes számát jelöli (n ≤ 20).\n  - m: Egy 32 bites előjelnélküli egész szám, amely a kiválasztandó elemek számát jelöli (m ≤ n).\n\n  Visszatérési érték:\n  - A C(n, m) kombinációs szám.\n\n  Példa:\n  - calculate_combinations(5, 2) visszaadja a 10-et\n  - calculate_combinations(18, 13) visszaadja a 8568-at\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 "
    },
    "prompt_bertscore": {
      "sq": "0.9697823601331624",
      "hy": "0.960556574825235",
      "bn": "0.9864760518768586",
      "bg": "0.9709930123055701",
      "zh": "0.9789545152382105",
      "fr": "0.9792564334173836",
      "de": "0.986831202998149",
      "ha": "0.968293426796925",
      "hi": "0.991966791499806",
      "hu": "0.9557050277684579"
    },
    "canonical_solution": "{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn calculate_combinations(n: u32, m: u32) -> u64` to solve the following problem:\nComputes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568",
      "sq": "Shkruani një funksion në Rust `fn calculate_combinations(n: u32, m: u32) -> u64` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e kombinimeve C(n, m), i cili përfaqëson numrin e mënyrave për të zgjedhur m elemente nga një grup me n elemente të dallueshme.\n\n  Argumentet:\n  - n: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin total të elementeve (n ≤ 20).\n  - m: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin e elementeve për të zgjedhur (m ≤ n).\n\n  Kthen:\n  - Numrin e kombinimeve C(n, m).\n\n  Shembull:\n  - calculate_combinations(5, 2) kthen 10\n  - calculate_combinations(18, 13) kthen 8568",
      "hy": "Գրեք Rust ֆունկցիա `fn calculate_combinations(n: u32, m: u32) -> u64` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է C(n, m) կոմբինացիայի թիվը, որը ներկայացնում է n տարբեր տարրերից m տարր ընտրելու եղանակների քանակը։\n\n  Արգումենտներ:\n  - n: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է տարրերի ընդհանուր քանակը (n ≤ 20)։\n  - m: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է ընտրելու տարրերի քանակը (m ≤ n)։\n\n  Վերադարձնում է:\n  - Կոմբինացիայի թիվը C(n, m)։\n\n  Օրինակ:\n  - calculate_combinations(5, 2) վերադարձնում է 10\n  - calculate_combinations(18, 13) վերադարձնում է 8568",
      "bn": "Rust ফাংশন `fn calculate_combinations(n: u32, m: u32) -> u64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংযোজন সংখ্যা C(n, m) গণনা করে, যা n ভিন্ন উপাদানের একটি সেট থেকে m উপাদান বেছে নেওয়ার উপায়ের সংখ্যা উপস্থাপন করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: একটি স্বাক্ষরবিহীন 32-বিট পূর্ণসংখ্যা যা মোট উপাদানের সংখ্যা উপস্থাপন করে (n ≤ 20)।\n  - m: একটি স্বাক্ষরবিহীন 32-বিট পূর্ণসংখ্যা যা বেছে নেওয়ার উপাদানের সংখ্যা উপস্থাপন করে (m ≤ n)।\n\n  রিটার্নস:\n  - সংযোজন সংখ্যা C(n, m)।\n\n  উদাহরণ:\n  - calculate_combinations(5, 2) রিটার্ন করে 10\n  - calculate_combinations(18, 13) রিটার্ন করে 8568",
      "bg": "Напишете функция на Rust `fn calculate_combinations(n: u32, m: u32) -> u64`, за да решите следния проблем:\nИзчислява числото на комбинациите C(n, m), което представлява броя начини да се изберат m елемента от множество с n различни елемента.\n\n  Аргументи:\n  - n: Неподписано 32-битово цяло число, представляващо общия брой елементи (n ≤ 20).\n  - m: Неподписано 32-битово цяло число, представляващо броя на елементите, които да се изберат (m ≤ n).\n\n  Връща:\n  - Числото на комбинациите C(n, m).\n\n  Пример:\n  - calculate_combinations(5, 2) връща 10\n  - calculate_combinations(18, 13) връща 8568",
      "zh": "编写一个 Rust 函数 `fn calculate_combinations(n: u32, m: u32) -> u64` 来解决以下问题：\n计算组合数 C(n, m)，表示从 n 个不同元素的集合中选择 m 个元素的方法数。\n\n参数：\n- n: 一个无符号 32 位整数，表示元素的总数 (n ≤ 20)。\n- m: 一个无符号 32 位整数，表示要选择的元素数量 (m ≤ n)。\n\n返回：\n- 组合数 C(n, m)。\n\n示例：\n- calculate_combinations(5, 2) 返回 10\n- calculate_combinations(18, 13) 返回 8568",
      "fr": "Écrire une fonction Rust `fn calculate_combinations(n: u32, m: u32) -> u64` pour résoudre le problème suivant :\nCalcule le nombre de combinaisons C(n, m), qui représente le nombre de façons de choisir m éléments parmi un ensemble de n éléments distincts.\n\n  Arguments :\n  - n : Un entier non signé de 32 bits représentant le nombre total d'éléments (n ≤ 20).\n  - m : Un entier non signé de 32 bits représentant le nombre d'éléments à choisir (m ≤ n).\n\n  Renvoie :\n  - Le nombre de combinaisons C(n, m).\n\n  Exemple :\n  - calculate_combinations(5, 2) renvoie 10\n  - calculate_combinations(18, 13) renvoie 8568",
      "de": "Schreiben Sie eine Rust-Funktion `fn calculate_combinations(n: u32, m: u32) -> u64`, um das folgende Problem zu lösen:\nBerechnet die Kombinationszahl C(n, m), die die Anzahl der Möglichkeiten darstellt, m Elemente aus einer Menge von n verschiedenen Elementen auszuwählen.\n\n  Argumente:\n  - n: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Gesamtanzahl der Elemente darstellt (n ≤ 20).\n  - m: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Anzahl der auszuwählenden Elemente darstellt (m ≤ n).\n\n  Rückgabewert:\n  - Die Kombinationszahl C(n, m).\n\n  Beispiel:\n  - calculate_combinations(5, 2) gibt 10 zurück\n  - calculate_combinations(18, 13) gibt 8568 zurück",
      "ha": "Rubuta aikin Rust `fn calculate_combinations(n: u32, m: u32) -> u64` don warware matsalar mai zuwa:\nYana lissafa adadin haɗuwa C(n, m), wanda ke wakiltar yawan hanyoyin zaɓar abubuwa m daga wani saitin abubuwa n masu bambanta.\n\n  Huɗɗa:\n  - n: Wani lamba mara alamar 32-bit mai wakiltar jimlar adadin abubuwa (n ≤ 20).\n  - m: Wani lamba mara alamar 32-bit mai wakiltar adadin abubuwan da za a zaɓa (m ≤ n).\n\n  Dawowa:\n  - Adadin haɗuwa C(n, m).\n\n  Misali:\n  - calculate_combinations(5, 2) yana dawowa 10\n  - calculate_combinations(18, 13) yana dawowa 8568",
      "hi": "Rust फ़ंक्शन `fn calculate_combinations(n: u32, m: u32) -> u64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nC(n, m) संयोजन संख्या की गणना करता है, जो n भिन्न तत्वों के सेट से m तत्वों को चुनने के तरीकों की संख्या को दर्शाता है।\n\n  तर्क:\n  - n: एक अनसाइन 32-बिट पूर्णांक जो तत्वों की कुल संख्या का प्रतिनिधित्व करता है (n ≤ 20)।\n  - m: एक अनसाइन 32-बिट पूर्णांक जो चुने जाने वाले तत्वों की संख्या का प्रतिनिधित्व करता है (m ≤ n)।\n\n  लौटाता है:\n  - संयोजन संख्या C(n, m)।\n\n  उदाहरण:\n  - calculate_combinations(5, 2) 10 लौटाता है\n  - calculate_combinations(18, 13) 8568 लौटाता है",
      "hu": "Készíts egy Rust függvényt `fn calculate_combinations(n: u32, m: u32) -> u64` a következő probléma megoldására:\nKiszámítja a kombinációs számot C(n, m), amely azt jelenti, hogy hányféleképpen választhatunk ki m elemet egy n különböző elemből álló halmazból.\n\n  Argumentumok:\n  - n: Egy előjelnélküli 32 bites egész szám, amely az elemek teljes számát jelenti (n ≤ 20).\n  - m: Egy előjelnélküli 32 bites egész szám, amely a kiválasztandó elemek számát jelenti (m ≤ n).\n\n  Visszatérési érték:\n  - A kombinációs szám C(n, m).\n\n  Példa:\n  - calculate_combinations(5, 2) visszaadja a 10-et\n  - calculate_combinations(18, 13) visszaadja a 8568-at"
    },
    "instruction_bertscore": {
      "sq": "0.970548477512814",
      "hy": "0.9736210908770427",
      "bn": "0.9738441527949449",
      "bg": "0.9612859455843951",
      "zh": "0.9838622746928205",
      "fr": "0.9801923797728199",
      "de": "0.9894815281722975",
      "ha": "0.9624169469740078",
      "hi": "0.9731483505701797",
      "hu": "0.9707953750764404"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_combinations(5, 2), 10);\n        assert_eq!(calculate_combinations(18, 13), 8568);\n        assert_eq!(calculate_combinations(10, 0), 1);\n        assert_eq!(calculate_combinations(20, 20), 1);\n        assert_eq!(calculate_combinations(15, 5), 3003);\n    }\n    \n\n}",
    "entry_point": "calculate_combinations",
    "signature": "fn calculate_combinations(n: u32, m: u32) -> u64",
    "docstring": {
      "en": "Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568",
      "sq": "Llogarit numrin e kombinimeve C(n, m), që përfaqëson numrin e mënyrave për të zgjedhur m elemente nga një grup prej n elementesh të dallueshme.\n\n  Argumentet:\n  - n: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin total të elementeve (n ≤ 20).\n  - m: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin e elementeve për të zgjedhur (m ≤ n).\n\n  Kthen:\n  - Numrin e kombinimeve C(n, m).\n\n  Shembull:\n  - calculate_combinations(5, 2) kthen 10\n  - calculate_combinations(18, 13) kthen 8568",
      "hy": "Հաշվում է համակցման թիվը C(n, m), որը ներկայացնում է n տարբեր տարրերից m տարր ընտրելու եղանակների քանակը:\n\n  Արգումենտներ:\n  - n: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է տարրերի ընդհանուր քանակը (n ≤ 20):\n  - m: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է ընտրելու տարրերի քանակը (m ≤ n):\n\n  Վերադարձնում է:\n  - Համակցման թիվը C(n, m):\n\n  Օրինակ:\n  - calculate_combinations(5, 2) վերադարձնում է 10\n  - calculate_combinations(18, 13) վերադարձնում է 8568",
      "bn": "সংযোজন সংখ্যা C(n, m) গণনা করে, যা n ভিন্ন উপাদানের একটি সেট থেকে m উপাদান বেছে নেওয়ার উপায়গুলির সংখ্যা উপস্থাপন করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: একটি আনসাইনড 32-বিট পূর্ণসংখ্যা যা মোট উপাদানের সংখ্যা উপস্থাপন করে (n ≤ 20)।\n  - m: একটি আনসাইনড 32-বিট পূর্ণসংখ্যা যা বেছে নেওয়ার উপাদানের সংখ্যা উপস্থাপন করে (m ≤ n)।\n\n  রিটার্নস:\n  - সংযোজন সংখ্যা C(n, m)।\n\n  উদাহরণ:\n  - calculate_combinations(5, 2) রিটার্ন করে 10\n  - calculate_combinations(18, 13) রিটার্ন করে 8568",
      "bg": "Изчислява числото на комбинация C(n, m), което представлява броя начини да се изберат m елемента от множество от n различни елементи.\n\n  Аргументи:\n  - n: Неподписано 32-битово цяло число, представляващо общия брой елементи (n ≤ 20).\n  - m: Неподписано 32-битово цяло число, представляващо броя на елементите, които да се изберат (m ≤ n).\n\n  Връща:\n  - Числото на комбинация C(n, m).\n\n  Пример:\n  - calculate_combinations(5, 2) връща 10\n  - calculate_combinations(18, 13) връща 8568",
      "zh": "计算组合数 C(n, m)，表示从 n 个不同元素的集合中选择 m 个元素的方法数。\n\n  参数:\n  - n: 一个无符号 32 位整数，表示元素的总数 (n ≤ 20)。\n  - m: 一个无符号 32 位整数，表示要选择的元素数量 (m ≤ n)。\n\n  返回:\n  - 组合数 C(n, m)。\n\n  示例:\n  - calculate_combinations(5, 2) 返回 10\n  - calculate_combinations(18, 13) 返回 8568",
      "fr": "Calcule le nombre de combinaisons C(n, m), qui représente le nombre de façons de choisir m éléments parmi un ensemble de n éléments distincts.\n\n  Arguments:\n  - n : Un entier non signé de 32 bits représentant le nombre total d'éléments (n ≤ 20).\n  - m : Un entier non signé de 32 bits représentant le nombre d'éléments à choisir (m ≤ n).\n\n  Renvoie:\n  - Le nombre de combinaisons C(n, m).\n\n  Exemple:\n  - calculate_combinations(5, 2) renvoie 10\n  - calculate_combinations(18, 13) renvoie 8568",
      "de": "Berechnet die Kombinationszahl C(n, m), die die Anzahl der Möglichkeiten darstellt, m Elemente aus einer Menge von n verschiedenen Elementen auszuwählen.\n\n  Argumente:\n  - n: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Gesamtanzahl der Elemente darstellt (n ≤ 20).\n  - m: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Anzahl der auszuwählenden Elemente darstellt (m ≤ n).\n\n  Rückgabewert:\n  - Die Kombinationszahl C(n, m).\n\n  Beispiel:\n  - calculate_combinations(5, 2) gibt 10 zurück\n  - calculate_combinations(18, 13) gibt 8568 zurück",
      "ha": "Yana lissafin adadin haɗuwa C(n, m), wanda ke wakiltar yawan hanyoyin zaɓar abubuwa m daga saitin abubuwa n daban-daban.\n\n  Huɗɗa:\n  - n: Baƙaƙen lamba 32-bit wanda ke wakiltar jimillar adadin abubuwa (n ≤ 20).\n  - m: Baƙaƙen lamba 32-bit wanda ke wakiltar yawan abubuwan da za a zaɓa (m ≤ n).\n\n  Komawa:\n  - Adadin haɗuwa C(n, m).\n\n  Misali:\n  - calculate_combinations(5, 2) yana dawowa 10\n  - calculate_combinations(18, 13) yana dawowa 8568",
      "hi": "संयोजन संख्या C(n, m) की गणना करता है, जो n भिन्न तत्वों के सेट से m तत्वों को चुनने के तरीकों की संख्या को दर्शाता है।\n\n  तर्क:\n  - n: एक बिना चिह्नित 32-बिट पूर्णांक जो तत्वों की कुल संख्या का प्रतिनिधित्व करता है (n ≤ 20)।\n  - m: एक बिना चिह्नित 32-बिट पूर्णांक जो चुने जाने वाले तत्वों की संख्या का प्रतिनिधित्व करता है (m ≤ n)।\n\n  लौटाता है:\n  - संयोजन संख्या C(n, m)।\n\n  उदाहरण:\n  - calculate_combinations(5, 2) 10 लौटाता है\n  - calculate_combinations(18, 13) 8568 लौटाता है",
      "hu": "Számítja a kombinációs számot C(n, m), amely azt jelenti, hogy hányféleképpen lehet m elemet választani egy n különböző elemből álló halmazból.\n\n  Argumentumok:\n  - n: Egy 32 bites előjelnélküli egész szám, amely az elemek teljes számát jelöli (n ≤ 20).\n  - m: Egy 32 bites előjelnélküli egész szám, amely a kiválasztandó elemek számát jelöli (m ≤ n).\n\n  Visszatérési érték:\n  - A kombinációs szám C(n, m).\n\n  Példa:\n  - calculate_combinations(5, 2) visszaadja 10\n  - calculate_combinations(18, 13) visszaadja 8568"
    },
    "docstring_bertscore": {
      "sq": "0.9637700171296174",
      "hy": "0.963562647011817",
      "bn": "0.9900202137656641",
      "bg": "0.977539472403718",
      "zh": "0.9793031115569267",
      "fr": "0.9736773032748756",
      "de": "0.9834610413231301",
      "ha": "0.9487454164777575",
      "hi": "0.9890719523266036",
      "hu": "0.9655561015158831"
    }
  },
  {
    "task_id": "Rust/30",
    "prompt": {
      "en": "/*\n  Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "sq": "/*\n  Përcakton nëse Yuanzi mund të fitojë një garë kuajsh kundër një kundërshtari duke rregulluar në mënyrë optimale kuajt e tij.\n\n  Funksioni krahason shpejtësitë e kuajve të Yuanzi-t me ato të kuajve të kundërshtarit. Çdo kalë ka një shpejtësi fikse dhe nuk ka barazime. Yuanzi fiton nëse fiton më shumë se gjysmën e garave individuale.\n\n  Argumentet:\n  - yuanzi_horses: Një varg i numrave të plotë që përfaqësojnë shpejtësitë e kuajve të Yuanzi-t.\n  - opponent_horses: Një varg i numrave të plotë që përfaqësojnë shpejtësitë e kuajve të kundërshtarit.\n\n  Kthen:\n  - Një vlerë boolean: `true` nëse Yuanzi mund të fitojë garën, `false` përndryshe.\n\n  Shembuj:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) kthen true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) kthen false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "hy": "/*\n  Որոշում է՝ արդյոք Յուանցին կարող է հաղթել ձիարշավում ընդդիմախոսի դեմ՝ օպտիմալ կերպով դասավորելով իր ձիերը:\n\n  Ֆունկցիան համեմատում է Յուանցիի ձիերի արագությունները ընդդիմախոսի ձիերի արագությունների հետ: Յուրաքանչյուր ձի ունի ֆիքսված արագություն և ոչ մի հավասարություն չկա: Յուանցին հաղթում է, եթե նա հաղթում է ավելի քան կեսը անհատական մրցավազքներից:\n\n  Արգումենտներ:\n  - yuanzi_horses: Թվերի զանգված, որը ներկայացնում է Յուանցիի ձիերի արագությունները:\n  - opponent_horses: Թվերի զանգված, որը ներկայացնում է ընդդիմախոսի ձիերի արագությունները:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք: `true`, եթե Յուանցին կարող է հաղթել մրցավազքը, `false` հակառակ դեպքում:\n\n  Օրինակներ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) վերադարձնում է true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) վերադարձնում է false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
      "bn": "/*\n  ইউয়ানজি প্রতিপক্ষের বিরুদ্ধে ঘোড়দৌড়ে জিততে পারে কিনা তা নির্ধারণ করে তার ঘোড়াগুলিকে সর্বোত্তমভাবে সাজিয়ে।\n\n  ফাংশনটি ইউয়ানজির ঘোড়াগুলির গতি প্রতিপক্ষের ঘোড়াগুলির সাথে তুলনা করে। প্রতিটি ঘোড়ার একটি নির্দিষ্ট গতি থাকে এবং কোনো সমতা নেই। ইউয়ানজি জিতবে যদি সে অর্ধেকের বেশি ব্যক্তিগত দৌড়ে জেতে।\n\n  আর্গুমেন্টসমূহ:\n  - yuanzi_horses: ইউয়ানজির ঘোড়াগুলির গতি প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n  - opponent_horses: প্রতিপক্ষের ঘোড়াগুলির গতি প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n\n  রিটার্ন:\n  - একটি বুলিয়ান মান: `true` যদি ইউয়ানজি দৌড়ে জিততে পারে, অন্যথায় `false`।\n\n  উদাহরণ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "bg": "/*\n  Определя дали Юанзи може да спечели конно състезание срещу противник, като оптимално подреди своите коне.\n\n  Функцията сравнява скоростите на конете на Юанзи със скоростите на конете на противника. Всеки кон има фиксирана скорост и няма равенства. Юанзи печели, ако спечели повече от половината от индивидуалните състезания.\n\n  Аргументи:\n  - yuanzi_horses: Масив от цели числа, представляващи скоростите на конете на Юанзи.\n  - opponent_horses: Масив от цели числа, представляващи скоростите на конете на противника.\n\n  Връща:\n  - Булева стойност: `true`, ако Юанзи може да спечели състезанието, `false` в противен случай.\n\n  Примери:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) връща true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) връща false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
      "zh": "/*\n  确定元子是否可以通过最佳排列他的马匹赢得赛马比赛。\n\n  该函数比较元子的马匹速度与对手的马匹速度。每匹马都有固定的速度，并且没有平局。如果元子赢得超过一半的单场比赛，他就获胜。\n\n  参数:\n  - yuanzi_horses: 一个整数数组，表示元子的马匹速度。\n  - opponent_horses: 一个整数数组，表示对手的马匹速度。\n\n  返回:\n  - 一个布尔值: 如果元子可以赢得比赛，返回 `true`，否则返回 `false`。\n\n  示例:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) 返回 true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) 返回 false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "fr": "/*\n  Détermine si Yuanzi peut gagner une course de chevaux contre un adversaire en arrangeant de manière optimale ses chevaux.\n\n  La fonction compare les vitesses des chevaux de Yuanzi à celles des chevaux de l'adversaire. Chaque cheval a une vitesse fixe et il n'y a pas d'égalité. Yuanzi gagne s'il remporte plus de la moitié des courses individuelles.\n\n  Arguments :\n  - yuanzi_horses: Un tableau d'entiers représentant les vitesses des chevaux de Yuanzi.\n  - opponent_horses: Un tableau d'entiers représentant les vitesses des chevaux de l'adversaire.\n\n  Renvoie :\n  - Une valeur booléenne : `true` si Yuanzi peut gagner la course, `false` sinon.\n\n  Exemples :\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) renvoie true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) renvoie false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "de": "/*\n  Bestimmt, ob Yuanzi ein Pferderennen gegen einen Gegner gewinnen kann, indem er seine Pferde optimal anordnet.\n\n  Die Funktion vergleicht die Geschwindigkeiten von Yuanzis Pferden mit denen der Pferde des Gegners. Jedes Pferd hat eine feste Geschwindigkeit und es gibt keine Unentschieden. Yuanzi gewinnt, wenn er mehr als die Hälfte der Einzelrennen gewinnt.\n\n  Argumente:\n  - yuanzi_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten von Yuanzis Pferden darstellt.\n  - opponent_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten der Pferde des Gegners darstellt.\n\n  Rückgabewert:\n  - Ein boolescher Wert: `true`, wenn Yuanzi das Rennen gewinnen kann, `false` andernfalls.\n\n  Beispiele:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) gibt true zurück\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) gibt false zurück\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "ha": "/*\n  Yana tantance ko Yuanzi zai iya cin gasa tseren doki da abokin hamayya ta hanyar tsara dokinsa cikin hikima.\n\n  Aikin yana kwatanta saurin dokin Yuanzi da na abokin hamayya. Kowanne doki yana da saurin da aka kebe kuma babu daidaito. Yuanzi yana cin nasara idan ya ci fiye da rabin tseren mutum daya.\n\n  Huɗɗa:\n  - yuanzi_horses: Jeri na lambobi masu nuna saurin dokin Yuanzi.\n  - opponent_horses: Jeri na lambobi masu nuna saurin dokin abokin hamayya.\n\n  Komawa:\n  - Kima na boolean: `true` idan Yuanzi zai iya cin tseren, `false` in ba haka ba.\n\n  Misalai:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "hi": "/*\n  यह निर्धारित करता है कि क्या युआन्ज़ी अपने घोड़ों को सही ढंग से व्यवस्थित करके एक घुड़दौड़ में प्रतिद्वंद्वी को हरा सकता है।\n\n  यह फ़ंक्शन युआन्ज़ी के घोड़ों की गति की तुलना प्रतिद्वंद्वी के घोड़ों की गति से करता है। प्रत्येक घोड़े की एक निश्चित गति होती है और कोई टाई नहीं होती। युआन्ज़ी जीतता है यदि वह आधे से अधिक व्यक्तिगत दौड़ जीतता है।\n\n  तर्क:\n  - yuanzi_horses: युआन्ज़ी के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों का एक सरणी।\n  - opponent_horses: प्रतिद्वंद्वी के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों का एक सरणी।\n\n  वापसी मान:\n  - एक बूलियन मान: `true` यदि युआन्ज़ी दौड़ जीत सकता है, अन्यथा `false`।\n\n  उदाहरण:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true लौटाता है\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false लौटाता है\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "hu": "/*\n  Meghatározza, hogy Yuanzi meg tudja-e nyerni a lóversenyt egy ellenféllel szemben azáltal, hogy optimálisan rendezi el a lovait.\n\n  A függvény összehasonlítja Yuanzi lovainak sebességét az ellenfél lovainak sebességével. Minden lónak rögzített sebessége van, és nincs döntetlen. Yuanzi nyer, ha az egyéni versenyek több mint felét megnyeri.\n\n  Argumentumok:\n  - yuanzi_horses: Egész számokat tartalmazó tömb, amely Yuanzi lovainak sebességét reprezentálja.\n  - opponent_horses: Egész számokat tartalmazó tömb, amely az ellenfél lovainak sebességét reprezentálja.\n\n  Visszatérési érték:\n  - Egy logikai érték: `true`, ha Yuanzi meg tudja nyerni a versenyt, `false` különben.\n\n  Példák:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) visszaadja true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) visszaadja false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool"
    },
    "prompt_bertscore": {
      "sq": "0.9997489311983719",
      "hy": "0.9783270418645212",
      "bn": "0.9831487943641432",
      "bg": "0.9947529798545824",
      "zh": "0.9630376669147418",
      "fr": "0.9990956358751482",
      "de": "0.9967073041735847",
      "ha": "0.9527249761617914",
      "hi": "0.9858865169059471",
      "hu": "0.9862772228654427"
    },
    "canonical_solution": "{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}",
    "instruction": {
      "en": "Write a Rust function `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` to solve the following problem:\nDetermines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "sq": "Shkruani një funksion Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse Yuanzi mund të fitojë një garë kuajsh kundër një kundërshtari duke rregulluar në mënyrë optimale kuajt e tij.\n\n  Funksioni krahason shpejtësitë e kuajve të Yuanzi-t me ato të kuajve të kundërshtarit. Çdo kalë ka një shpejtësi fikse dhe nuk ka barazime. Yuanzi fiton nëse fiton më shumë se gjysmën e garave individuale.\n\n  Argumentet:\n  - yuanzi_horses: Një varg me numra të plotë që përfaqësojnë shpejtësitë e kuajve të Yuanzi-t.\n  - opponent_horses: Një varg me numra të plotë që përfaqësojnë shpejtësitë e kuajve të kundërshtarit.\n\n  Kthen:\n  - Një vlerë boolean: `true` nëse Yuanzi mund të fitojë garën, `false` përndryshe.\n\n  Shembuj:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) kthen true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) kthen false",
      "hy": "Գրեք Rust ֆունկցիա `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք Յուանցին կարող է հաղթել ձիարշավում ընդդեմ մրցակցի՝ իր ձիերը օպտիմալ կերպով դասավորելով։\n\n  Ֆունկցիան համեմատում է Յուանցիի ձիերի արագությունները մրցակցի ձիերի արագությունների հետ։ Յուրաքանչյուր ձի ունի հաստատուն արագություն և ոչ մի հավասարություն չկա։ Յուանցին հաղթում է, եթե նա հաղթում է անհատական մրցավազքերի կեսից ավելին։\n\n  Փաստարկներ:\n  - yuanzi_horses: Թվերի զանգված, որը ներկայացնում է Յուանցիի ձիերի արագությունները։\n  - opponent_horses: Թվերի զանգված, որը ներկայացնում է մրցակցի ձիերի արագությունները։\n\n  Վերադարձնում է:\n  - Բուլյան արժեք՝ `true`, եթե Յուանցին կարող է հաղթել մրցավազքում, `false`՝ հակառակ դեպքում։\n\n  Օրինակներ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) վերադարձնում է true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) վերադարձնում է false",
      "bn": "Rust ফাংশন `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nইউয়ানজি প্রতিপক্ষের বিরুদ্ধে ঘোড়দৌড় জিততে পারে কিনা তা নির্ধারণ করে তার ঘোড়াগুলিকে সর্বোত্তমভাবে সাজিয়ে।\n\n  ফাংশনটি ইউয়ানজির ঘোড়াগুলির গতি প্রতিপক্ষের ঘোড়াগুলির গতির সাথে তুলনা করে। প্রতিটি ঘোড়ার একটি নির্দিষ্ট গতি থাকে এবং কোনো সমতা নেই। ইউয়ানজি জেতে যদি সে অর্ধেকের বেশি ব্যক্তিগত দৌড় জেতে।\n\n  আর্গুমেন্টসমূহ:\n  - yuanzi_horses: ইউয়ানজির ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n  - opponent_horses: প্রতিপক্ষের ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n\n  রিটার্ন করে:\n  - একটি বুলিয়ান মান: `true` যদি ইউয়ানজি দৌড় জিততে পারে, অন্যথায় `false`।\n\n  উদাহরণসমূহ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) রিটার্ন করে true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) রিটার্ন করে false",
      "bg": "Напишете функция на Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool`, за да решите следния проблем:\nОпределя дали Юанци може да спечели конно състезание срещу противник, като оптимално подреди своите коне.\n\nФункцията сравнява скоростите на конете на Юанци с тези на конете на противника. Всеки кон има фиксирана скорост и няма равенства. Юанци печели, ако спечели повече от половината от индивидуалните състезания.\n\nАргументи:\n- yuanzi_horses: Масив от цели числа, представляващи скоростите на конете на Юанци.\n- opponent_horses: Масив от цели числа, представляващи скоростите на конете на противника.\n\nВръща:\n- Булева стойност: `true`, ако Юанци може да спечели състезанието, `false` в противен случай.\n\nПримери:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) връща true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) връща false",
      "zh": "编写一个 Rust 函数 `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` 来解决以下问题：\n确定元子是否可以通过最佳排列他的马匹赢得与对手的赛马比赛。\n\n该函数将比较元子的马匹速度与对手马匹的速度。每匹马都有固定的速度，并且没有平局。如果元子赢得超过一半的单场比赛，他就获胜。\n\n参数：\n- yuanzi_horses: 一个整数数组，表示元子马匹的速度。\n- opponent_horses: 一个整数数组，表示对手马匹的速度。\n\n返回值：\n- 一个布尔值：如果元子可以赢得比赛，则返回 `true`，否则返回 `false`。\n\n示例：\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) 返回 true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) 返回 false",
      "fr": "Écrire une fonction Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` pour résoudre le problème suivant :\nDétermine si Yuanzi peut gagner une course de chevaux contre un adversaire en arrangeant de manière optimale ses chevaux.\n\n  La fonction compare les vitesses des chevaux de Yuanzi à celles des chevaux de l'adversaire. Chaque cheval a une vitesse fixe et il n'y a pas d'égalités. Yuanzi gagne s'il remporte plus de la moitié des courses individuelles.\n\n  Arguments :\n  - yuanzi_horses : Un tableau d'entiers représentant les vitesses des chevaux de Yuanzi.\n  - opponent_horses : Un tableau d'entiers représentant les vitesses des chevaux de l'adversaire.\n\n  Renvoie :\n  - Une valeur booléenne : `true` si Yuanzi peut gagner la course, `false` sinon.\n\n  Exemples :\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) renvoie true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) renvoie false",
      "de": "Schreiben Sie eine Rust-Funktion `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool`, um das folgende Problem zu lösen:\nBestimmt, ob Yuanzi ein Pferderennen gegen einen Gegner gewinnen kann, indem er seine Pferde optimal anordnet.\n\n  Die Funktion vergleicht die Geschwindigkeiten von Yuanzis Pferden mit denen der Pferde des Gegners. Jedes Pferd hat eine feste Geschwindigkeit und es gibt keine Unentschieden. Yuanzi gewinnt, wenn er mehr als die Hälfte der einzelnen Rennen gewinnt.\n\n  Argumente:\n  - yuanzi_horses: Ein Array von Ganzzahlen, das die Geschwindigkeiten von Yuanzis Pferden darstellt.\n  - opponent_horses: Ein Array von Ganzzahlen, das die Geschwindigkeiten der Pferde des Gegners darstellt.\n\n  Rückgabewert:\n  - Ein boolescher Wert: `true`, wenn Yuanzi das Rennen gewinnen kann, `false` andernfalls.\n\n  Beispiele:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) gibt true zurück\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) gibt false zurück",
      "ha": "Rubuta aikin Rust `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` don warware matsalar mai zuwa:\nYana tantance ko Yuanzi zai iya cin tseren dawakai da abokin hamayya ta hanyar tsara dawakansa cikin hikima.\n\n  Aikin yana kwatanta saurin dawakai na Yuanzi da na abokin hamayya. Kowanne doki yana da saurin da aka kayyade kuma babu daidai. Yuanzi yana cin nasara idan ya ci fiye da rabin tseren mutum daya.\n\n  Huɗɗa:\n  - yuanzi_horses: Jeri na lambobi masu nuna saurin dawakai na Yuanzi.\n  - opponent_horses: Jeri na lambobi masu nuna saurin dawakai na abokin hamayya.\n\n  Dawowa:\n  - Kima mai ma'ana: `true` idan Yuanzi zai iya cin tseren, `false` in ba haka ba.\n\n  Misalai:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "hi": "Rust फ़ंक्शन `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि क्या युआनज़ी अपने घोड़ों को अनुकूल रूप से व्यवस्थित करके एक प्रतिद्वंद्वी के खिलाफ घुड़दौड़ जीत सकता है।\n\n  फ़ंक्शन युआनज़ी के घोड़ों की गति की तुलना प्रतिद्वंद्वी के घोड़ों की गति से करता है। प्रत्येक घोड़े की एक निश्चित गति होती है और कोई टाई नहीं होती। युआनज़ी जीतता है यदि वह आधे से अधिक व्यक्तिगत दौड़ जीतता है।\n\n  तर्क:\n  - yuanzi_horses: युआनज़ी के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों का एक सरणी।\n  - opponent_horses: प्रतिद्वंद्वी के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों का एक सरणी।\n\n  लौटाता है:\n  - एक बूलियन मान: `true` यदि युआनज़ी दौड़ जीत सकता है, अन्यथा `false`।\n\n  उदाहरण:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true लौटाता है\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false लौटाता है",
      "hu": "Írj egy Rust függvényt `fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool` a következő probléma megoldására:\nHatározza meg, hogy Yuanzi meg tudja-e nyerni a lóversenyt egy ellenféllel szemben azáltal, hogy optimálisan rendezi el a lovait.\n\n  A függvény összehasonlítja Yuanzi lovainak sebességét az ellenfél lovainak sebességével. Minden lónak fix sebessége van, és nincs döntetlen. Yuanzi nyer, ha több mint a felét megnyeri az egyéni versenyeknek.\n\n  Argumentumok:\n  - yuanzi_horses: Egész számokat tartalmazó tömb, amely Yuanzi lovainak sebességét reprezentálja.\n  - opponent_horses: Egész számokat tartalmazó tömb, amely az ellenfél lovainak sebességét reprezentálja.\n\n  Visszatérési érték:\n  - Egy logikai érték: `true`, ha Yuanzi meg tudja nyerni a versenyt, `false` különben.\n\n  Példák:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) visszatérési értéke true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) visszatérési értéke false"
    },
    "instruction_bertscore": {
      "sq": "0.9949478362583776",
      "hy": "0.9823816838325865",
      "bn": "0.9838747884068257",
      "bg": "0.9909063038954607",
      "zh": "0.977579794371068",
      "fr": "0.9948755347996809",
      "de": "0.9940609516070569",
      "ha": "0.9557244935457992",
      "hi": "0.9849207759933555",
      "hu": "0.9883014650785692"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]), true);\n        assert_eq!(can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]), false);\n    }\n    \n\n}",
    "entry_point": "can_win_horse_race",
    "signature": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "sq": "Determinon nëse Yuanzi mund të fitojë një garë kuajsh kundër një kundërshtari duke rregulluar në mënyrë optimale kuajt e tij.\n\n  Funksioni krahason shpejtësitë e kuajve të Yuanzi me ato të kuajve të kundërshtarit. Çdo kalë ka një shpejtësi të fiksuar dhe nuk ka barazime. Yuanzi fiton nëse fiton më shumë se gjysmën e garave individuale.\n\n  Argumentet:\n  - yuanzi_horses: Një varg me numra të plotë që përfaqëson shpejtësitë e kuajve të Yuanzi.\n  - opponent_horses: Një varg me numra të plotë që përfaqëson shpejtësitë e kuajve të kundërshtarit.\n\n  Kthen:\n  - Një vlerë boolean: `true` nëse Yuanzi mund të fitojë garën, `false` përndryshe.\n\n  Shembuj:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) kthen true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) kthen false",
      "hy": "Սահմանում է՝ արդյոք Յուանցին կարող է հաղթել ձիարշավում մրցակցի դեմ՝ օպտիմալ կերպով դասավորելով իր ձիերին։\n\n  Ֆունկցիան համեմատում է Յուանցիի ձիերի արագությունները մրցակցի ձիերի արագությունների հետ։ Յուրաքանչյուր ձի ունի ֆիքսված արագություն և ոչ մի հավասարություն չկա։ Յուանցին հաղթում է, եթե նա հաղթում է անհատական մրցավազքերի կեսից ավելին։\n\n  Արգումենտներ:\n  - yuanzi_horses: ամբողջ թվերի զանգված, որը ներկայացնում է Յուանցիի ձիերի արագությունները։\n  - opponent_horses: ամբողջ թվերի զանգված, որը ներկայացնում է մրցակցի ձիերի արագությունները։\n\n  Վերադարձնում է:\n  - Բուլյան արժեք՝ `true`, եթե Յուանցին կարող է հաղթել մրցավազքը, `false`՝ հակառակ դեպքում։\n\n  Օրինակներ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) վերադարձնում է true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) վերադարձնում է false",
      "bn": "Yuanzi তার ঘোড়াগুলিকে যথাযথভাবে সাজিয়ে প্রতিপক্ষের বিরুদ্ধে ঘোড়দৌড় জিততে পারে কিনা তা নির্ধারণ করে।\n\n  ফাংশনটি Yuanzi এর ঘোড়াগুলির গতি প্রতিপক্ষের ঘোড়াগুলির গতির সাথে তুলনা করে। প্রতিটি ঘোড়ার একটি নির্দিষ্ট গতি থাকে এবং কোনো সমতা নেই। Yuanzi জিতবে যদি সে অর্ধেকের বেশি ব্যক্তিগত দৌড়ে জেতে।\n\n  Arguments:\n  - yuanzi_horses: Yuanzi এর ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n  - opponent_horses: প্রতিপক্ষের ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n\n  Returns:\n  - একটি বুলিয়ান মান: `true` যদি Yuanzi দৌড় জিততে পারে, অন্যথায় `false`।\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "bg": "Определя дали Юанзи може да спечели конно състезание срещу противник, като оптимално подреди своите коне.\n\nФункцията сравнява скоростите на конете на Юанзи с тези на конете на противника. Всеки кон има фиксирана скорост и няма равенства. Юанзи печели, ако спечели повече от половината от индивидуалните състезания.\n\nАргументи:\n- yuanzi_horses: Масив от цели числа, представляващи скоростите на конете на Юанзи.\n- opponent_horses: Масив от цели числа, представляващи скоростите на конете на противника.\n\nВръща:\n- Булева стойност: `true`, ако Юанзи може да спечели състезанието, `false` в противен случай.\n\nПримери:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) връща true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) връща false",
      "zh": "确定元子是否可以通过最佳安排他的马匹赢得赛马。\n\n该函数比较元子的马匹速度与对手马匹速度。每匹马都有固定速度，且没有平局。如果元子赢得超过一半的单场比赛，他就获胜。\n\n参数：\n- yuanzi_horses: 一个整数数组，表示元子马匹的速度。\n- opponent_horses: 一个整数数组，表示对手马匹的速度。\n\n返回：\n- 一个布尔值：如果元子可以赢得比赛，返回 `true`，否则返回 `false`。\n\n示例：\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) 返回 true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) 返回 false",
      "fr": "Détermine si Yuanzi peut gagner une course de chevaux contre un adversaire en arrangeant de manière optimale ses chevaux.\n\n  La fonction compare les vitesses des chevaux de Yuanzi à celles des chevaux de l'adversaire. Chaque cheval a une vitesse fixe et il n'y a pas d'égalité. Yuanzi gagne s'il remporte plus de la moitié des courses individuelles.\n\n  Arguments:\n  - yuanzi_horses: Un tableau d'entiers représentant les vitesses des chevaux de Yuanzi.\n  - opponent_horses: Un tableau d'entiers représentant les vitesses des chevaux de l'adversaire.\n\n  Renvoie:\n  - Une valeur booléenne: `true` si Yuanzi peut gagner la course, `false` sinon.\n\n  Exemples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) renvoie true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) renvoie false",
      "de": "Bestimmt, ob Yuanzi ein Pferderennen gegen einen Gegner gewinnen kann, indem er seine Pferde optimal anordnet.\n\n  Die Funktion vergleicht die Geschwindigkeiten von Yuanzis Pferden mit denen der Pferde des Gegners. Jedes Pferd hat eine feste Geschwindigkeit und es gibt keine Unentschieden. Yuanzi gewinnt, wenn er mehr als die Hälfte der einzelnen Rennen gewinnt.\n\n  Argumente:\n  - yuanzi_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten von Yuanzis Pferden darstellt.\n  - opponent_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten der Pferde des Gegners darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert: `true`, wenn Yuanzi das Rennen gewinnen kann, `false` andernfalls.\n\n  Beispiele:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) gibt true zurück\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) gibt false zurück",
      "ha": "Yana tantance ko Yuanzi zai iya cin gasa tseren doki da abokin hamayya ta hanyar tsara dokinsa cikin hikima.\n\n  Aikin yana kwatanta saurin dawakan Yuanzi da na abokin hamayyarsa. Kowane doki yana da sauri mai tsayi kuma babu daidaito. Yuanzi yana cin nasara idan ya ci fiye da rabin tseren guda.\n\n  Arguments:\n  - yuanzi_horses: Jeri na lambobi da ke wakiltar saurin dawakan Yuanzi.\n  - opponent_horses: Jeri na lambobi da ke wakiltar saurin dawakan abokin hamayya.\n\n  Returns:\n  - Kima na boolean: `true` idan Yuanzi zai iya cin nasarar tseren, `false` in ba haka ba.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "hi": "Yuanzi यह निर्धारित करता है कि वह अपने घोड़ों को सही ढंग से व्यवस्थित करके एक प्रतिद्वंद्वी के खिलाफ घुड़दौड़ जीत सकता है या नहीं।\n\n  फ़ंक्शन Yuanzi के घोड़ों की गति की तुलना प्रतिद्वंद्वी के घोड़ों की गति से करता है। प्रत्येक घोड़े की एक निश्चित गति होती है और कोई टाई नहीं होती। Yuanzi जीतता है यदि वह व्यक्तिगत दौड़ों में से आधे से अधिक जीतता है।\n\n  तर्क:\n  - yuanzi_horses: Yuanzi के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n  - opponent_horses: प्रतिद्वंद्वी के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n\n  लौटाता है:\n  - एक boolean मान: `true` यदि Yuanzi दौड़ जीत सकता है, अन्यथा `false`।\n\n  उदाहरण:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true लौटाता है\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false लौटाता है",
      "hu": "Meghatározza, hogy Yuanzi meg tudja-e nyerni a lóversenyt egy ellenféllel szemben azáltal, hogy optimálisan rendezi el a lovait.\n\n  A függvény összehasonlítja Yuanzi lovainak sebességét az ellenfél lovainak sebességével. Minden lónak rögzített sebessége van, és nincs döntetlen. Yuanzi nyer, ha több mint a versenyek felét megnyeri.\n\n  Argumentumok:\n  - yuanzi_horses: Egész számokat tartalmazó tömb, amely Yuanzi lovainak sebességét jelöli.\n  - opponent_horses: Egész számokat tartalmazó tömb, amely az ellenfél lovainak sebességét jelöli.\n\n  Visszatérési érték:\n  - Egy logikai érték: `true`, ha Yuanzi meg tudja nyerni a versenyt, `false` egyébként.\n\n  Példák:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) visszaadja true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) visszaadja false"
    },
    "docstring_bertscore": {
      "sq": "0.999083916682667",
      "hy": "0.9931971080799361",
      "bn": "0.9713384305381898",
      "bg": "0.9948850690579706",
      "zh": "0.9575038244991098",
      "fr": "0.9925892991139693",
      "de": "0.9955973576043617",
      "ha": "0.9618955422237911",
      "hi": "0.9777573699317132",
      "hu": "0.9873986899967656"
    }
  },
  {
    "task_id": "Rust/31",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin e mënyrave të ndryshme për të ngjitur një shkallë me një numër të caktuar hapash, ku në çdo hap, mund të ngjitesh ose një hap ose dy hapa. Fillon në nivelin 0.\n\n  Argumentet:\n  - stairs: Një numër i plotë që përfaqëson numrin e hapave në shkallë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e mënyrave të ndryshme për të ngjitur shkallën.\n\n  Shembull:\n  - count_ways_to_climb(2) kthen 2 (1 hap + 1 hap, 2 hapa)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է տարբեր եղանակների քանակը, որով կարելի է բարձրանալ աստիճանների որոշակի քանակ ունեցող աստիճանահարթակ, որտեղ յուրաքանչյուր քայլում կարելի է բարձրանալ մեկ կամ երկու քայլ: Դուք սկսում եք 0 մակարդակից:\n\n  Փաստարկներ:\n  - stairs: Ամբողջ թիվ, որը ներկայացնում է աստիճանահարթակի քայլերի քանակը:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է տարբեր եղանակների քանակը, որով կարելի է բարձրանալ աստիճանահարթակը:\n\n  Օրինակ:\n  - count_ways_to_climb(2) վերադարձնում է 2 (1 քայլ + 1 քայլ, 2 քայլ)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "bn": "/*\n  একটি নির্দিষ্ট সংখ্যক ধাপের সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা গণনা করে, যেখানে প্রতিটি ধাপে, একজন হয় এক ধাপ বা দুই ধাপ উঠতে পারে। আপনি স্তর 0 থেকে শুরু করেন।\n\n  আর্গুমেন্ট:\n  - stairs: সিঁড়ির ধাপের সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  উদাহরণ:\n  - count_ways_to_climb(2) 2 রিটার্ন করে (1 ধাপ + 1 ধাপ, 2 ধাপ)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните начини за изкачване на стълбище с даден брой стъпала, като на всяка стъпка може да се изкачат или едно, или две стъпала. Започвате от ниво 0.\n\n  Аргументи:\n  - stairs: Цяло число, представляващо броя на стъпалата в стълбището.\n\n  Връща:\n  - Цяло число, представляващо броя на различните начини за изкачване на стълбището.\n\n  Пример:\n  - count_ways_to_climb(2) връща 2 (1 стъпка + 1 стъпка, 2 стъпки)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "zh": "/*\n  计算爬一个给定台阶数的楼梯的不同方法数，其中在每一步可以爬一个台阶或两个台阶。你从第0级开始。\n\n  参数:\n  - stairs: 一个整数，表示楼梯的台阶数。\n\n  返回:\n  - 一个整数，表示爬楼梯的不同方法数。\n\n  示例:\n  - count_ways_to_climb(2) 返回 2 (1步 + 1步, 2步)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre de façons différentes de monter un escalier d'un nombre donné de marches, où à chaque marche, on peut soit monter d'une marche, soit de deux marches. Vous commencez au niveau 0.\n\n  Arguments:\n  - stairs: Un entier représentant le nombre de marches dans l'escalier.\n\n  Renvoie:\n  - Un entier représentant le nombre de façons différentes de monter l'escalier.\n\n  Exemple:\n  - count_ways_to_climb(2) renvoie 2 (1 marche + 1 marche, 2 marches)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der verschiedenen Möglichkeiten, eine Treppe mit einer bestimmten Anzahl von Stufen zu erklimmen, wobei man bei jedem Schritt entweder eine Stufe oder zwei Stufen steigen kann. Man beginnt auf Ebene 0.\n\n  Argumente:\n  - stairs: Eine ganze Zahl, die die Anzahl der Stufen in der Treppe darstellt.\n\n  Rückgabe:\n  - Eine ganze Zahl, die die Anzahl der verschiedenen Möglichkeiten darstellt, die Treppe zu erklimmen.\n\n  Beispiel:\n  - count_ways_to_climb(2) gibt 2 zurück (1 Schritt + 1 Schritt, 2 Schritte)\n*/",
      "ha": "/*\n  Lissafa adadin hanyoyi daban-daban don hawa matakala na adadin matakai da aka bayar, inda a kowane mataki, za a iya hawa mataki daya ko matakai biyu. Ka fara a matakin 0.\n\n  Huɗa:\n  - stairs: Wani lamba mai nuna adadin matakai a cikin matakalar.\n\n  Komawa:\n  - Wani lamba mai nuna adadin hanyoyi daban-daban don hawa matakalar.\n\n  Misali:\n  - count_ways_to_climb(2) yana dawowa 2 (mataki 1 + mataki 1, matakai 2)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "hi": "/*\n  एक दिए गए सीढ़ियों की संख्या के लिए सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या की गणना करता है, जहाँ प्रत्येक कदम पर, आप या तो एक कदम या दो कदम चढ़ सकते हैं। आप स्तर 0 से शुरू करते हैं।\n\n  तर्क:\n  - stairs: एक पूर्णांक जो सीढ़ियों में कदमों की संख्या का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक पूर्णांक जो सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_ways_to_climb(2) 2 लौटाता है (1 कदम + 1 कदम, 2 कदम)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja, hogy hány különböző módon lehet megmászni egy adott lépcsőfokszámú lépcsőt, ahol minden lépésnél vagy egy lépcsőfokot, vagy két lépcsőfokot lehet megmászni. Az indulás a 0. szinten történik.\n\n  Argumentumok:\n  - stairs: Egy egész szám, amely a lépcsőn lévő lépcsőfokok számát jelöli.\n\n  Visszatér:\n  - Egy egész szám, amely a lépcső megmászásának különböző módjainak számát jelenti.\n\n  Példa:\n  - count_ways_to_climb(2) visszaadja 2 (1 lépés + 1 lépés, 2 lépés)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9877391424698595",
      "hy": "0.9404196254262991",
      "bn": "0.9907056872106155",
      "bg": "0.9838634664751067",
      "zh": "0.9560307815933551",
      "fr": "0.9959970019310039",
      "de": "0.9252772369584854",
      "ha": "0.9748464416976469",
      "hi": "0.9732850082723317",
      "hu": "0.9714621772655745"
    },
    "canonical_solution": "{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_ways_to_climb(stairs: i32) -> i32` to solve the following problem:\nCalculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "sq": "Shkruani një funksion Rust `fn count_ways_to_climb(stairs: i32) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e mënyrave të ndryshme për të ngjitur një shkallë me një numër të caktuar hapash, ku në çdo hap, mund të ngjiteni ose një hap ose dy hapa. Ju filloni në nivelin 0.\n\n  Argumentet:\n  - stairs: Një numër i plotë që përfaqëson numrin e hapave në shkallë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e mënyrave të ndryshme për të ngjitur shkallën.\n\n  Shembull:\n  - count_ways_to_climb(2) kthen 2 (1 hap + 1 hap, 2 hapa)",
      "hy": "Գրեք Rust ֆունկցիա `fn count_ways_to_climb(stairs: i32) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է տարբեր եղանակների քանակը, որով կարելի է բարձրանալ աստիճանների տված քանակով աստիճաններով, որտեղ յուրաքանչյուր քայլում կարելի է կամ մեկ քայլ բարձրանալ, կամ երկու քայլ: Դուք սկսում եք 0 մակարդակից:\n\n  Արգումենտներ:\n  - stairs: Ամբողջ թիվ, որը ներկայացնում է աստիճանների քանակը:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է աստիճանների բարձրանալու տարբեր եղանակների քանակը:\n\n  Օրինակ:\n  - count_ways_to_climb(2) վերադարձնում է 2 (1 քայլ + 1 քայլ, 2 քայլ)",
      "bn": "Rust ফাংশন `fn count_ways_to_climb(stairs: i32) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সংখ্যক ধাপের সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা গণনা করে, যেখানে প্রতিটি ধাপে, একজন হয় এক ধাপ বা দুই ধাপ উঠতে পারে। আপনি স্তর 0 থেকে শুরু করেন।\n\n  আর্গুমেন্ট:\n  - stairs: সিঁড়ির ধাপের সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  উদাহরণ:\n  - count_ways_to_climb(2) 2 রিটার্ন করে (1 ধাপ + 1 ধাপ, 2 ধাপ)",
      "bg": "Напишете функция на Rust `fn count_ways_to_climb(stairs: i32) -> i32`, за да решите следния проблем:\nИзчислява броя на различните начини за изкачване на стълбище с даден брой стъпала, където на всяка стъпка може да се изкачат или една стъпка, или две стъпки. Започвате от ниво 0.\n\n  Аргументи:\n  - stairs: Цяло число, представляващо броя на стъпалата в стълбището.\n\n  Връща:\n  - Цяло число, представляващо броя на различните начини за изкачване на стълбището.\n\n  Пример:\n  - count_ways_to_climb(2) връща 2 (1 стъпка + 1 стъпка, 2 стъпки)",
      "zh": "编写一个 Rust 函数 `fn count_ways_to_climb(stairs: i32) -> i32` 来解决以下问题：\n计算爬一个给定步数的楼梯的不同方式的数量，其中每一步可以爬一阶或两阶。你从0级开始。\n\n参数：\n- stairs: 一个整数，表示楼梯的步数。\n\n返回：\n- 一个整数，表示爬楼梯的不同方式的数量。\n\n示例：\n- count_ways_to_climb(2) 返回 2 (1 step + 1 step, 2 steps)",
      "fr": "Écrire une fonction Rust `fn count_ways_to_climb(stairs: i32) -> i32` pour résoudre le problème suivant :\nCalcule le nombre de façons différentes de monter un escalier d'un nombre donné de marches, où à chaque marche, on peut soit monter d'une marche, soit de deux marches. Vous commencez au niveau 0.\n\n  Arguments :\n  - stairs : Un entier représentant le nombre de marches dans l'escalier.\n\n  Renvoie :\n  - Un entier représentant le nombre de façons différentes de monter l'escalier.\n\n  Exemple :\n  - count_ways_to_climb(2) renvoie 2 (1 marche + 1 marche, 2 marches)",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_ways_to_climb(stairs: i32) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der verschiedenen Möglichkeiten, eine Treppe mit einer gegebenen Anzahl von Stufen zu erklimmen, wobei man bei jedem Schritt entweder eine Stufe oder zwei Stufen steigen kann. Sie beginnen auf Stufe 0.\n\n  Argumente:\n  - stairs: Eine ganze Zahl, die die Anzahl der Stufen in der Treppe darstellt.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Anzahl der verschiedenen Möglichkeiten darstellt, die Treppe zu erklimmen.\n\n  Beispiel:\n  - count_ways_to_climb(2) gibt 2 zurück (1 Schritt + 1 Schritt, 2 Schritte)",
      "ha": "Rubuta aikin Rust `fn count_ways_to_climb(stairs: i32) -> i32` don warware matsalar mai zuwa:\nLissafa adadin hanyoyi daban-daban don hawa matakala na adadin matakai da aka bayar, inda a kowane mataki, za a iya hawa mataki daya ko matakai biyu. Ka fara a matakin 0.\n\n  Huɗɗa:\n  - stairs: Wani cikakken lamba da ke wakiltar adadin matakai a cikin matakalar.\n\n  Dawowa:\n  - Wani cikakken lamba da ke wakiltar adadin hanyoyi daban-daban don hawa matakalar.\n\n  Misali:\n  - count_ways_to_climb(2) yana dawowa 2 (mataki 1 + mataki 1, matakai 2)",
      "hi": "Rust फ़ंक्शन `fn count_ways_to_climb(stairs: i32) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह दिए गए सीढ़ियों की संख्या के लिए सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या की गणना करता है, जहाँ प्रत्येक कदम पर, आप या तो एक कदम या दो कदम चढ़ सकते हैं। आप स्तर 0 से शुरू करते हैं।\n\n  तर्क:\n  - stairs: एक पूर्णांक जो सीढ़ियों में कदमों की संख्या का प्रतिनिधित्व करता है।\n\n  वापसी मान:\n  - एक पूर्णांक जो सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_ways_to_climb(2) 2 लौटाता है (1 कदम + 1 कदम, 2 कदम)",
      "hu": "Írj egy Rust függvényt `fn count_ways_to_climb(stairs: i32) -> i32` a következő probléma megoldására:\nKiszámítja, hogy hány különböző módon lehet megmászni egy adott számú lépcsőfokból álló lépcsőt, ahol minden lépésnél egy vagy két lépcsőfokot lehet megmászni. A 0. szinten kezded.\n\n  Argumentumok:\n  - stairs: Egy egész szám, amely a lépcsőfokok számát jelöli a lépcsőn.\n\n  Visszatérési érték:\n  - Egy egész szám, amely a lépcső megmászásának különböző módjainak számát jelöli.\n\n  Példa:\n  - count_ways_to_climb(2) visszaadja a 2-t (1 lépés + 1 lépés, 2 lépés)"
    },
    "instruction_bertscore": {
      "sq": "0.9906844337598448",
      "hy": "0.9667657605363856",
      "bn": "0.971214882441186",
      "bg": "0.9854825027109221",
      "zh": "0.961763453020403",
      "fr": "0.9950251034766002",
      "de": "0.9672301583672451",
      "ha": "0.9714957457999694",
      "hi": "0.955506993278566",
      "hu": "0.9610440137802946"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n  \n    #[test]\n    fn main() {\n      \n        assert_eq!(count_ways_to_climb(2), 2); // 2 ways: (1+1), (2)\n        assert_eq!(count_ways_to_climb(3), 3); // 3 ways: (1+1+1), (1+2), (2+1)\n        assert_eq!(count_ways_to_climb(4), 5); // 5 ways: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)\n        assert_eq!(count_ways_to_climb(10), 89); \n        assert_eq!(count_ways_to_climb(24), 75025); \n        println!(\"All test cases passed.\");\n    }\n    \n\n}",
    "entry_point": "count_ways_to_climb",
    "signature": "fn count_ways_to_climb(stairs: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "sq": "Llogarit numrin e mënyrave të ndryshme për të ngjitur një shkallë me një numër të caktuar hapash, ku në çdo hap, mund të ngjiteni ose një hap ose dy hapa. Ju filloni në nivelin 0.\n\n  Argumentet:\n  - stairs: Një numër i plotë që përfaqëson numrin e hapave në shkallë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e mënyrave të ndryshme për të ngjitur shkallën.\n\n  Shembull:\n  - count_ways_to_climb(2) kthen 2 (1 hap + 1 hap, 2 hapa)",
      "hy": "Հաշվում է աստիճանների որոշակի քանակով աստիճան բարձրանալու տարբեր եղանակների քանակը, որտեղ յուրաքանչյուր քայլում կարելի է բարձրանալ մեկ կամ երկու քայլ: Դուք սկսում եք մակարդակ 0-ից:\n\n  Արհամարհանքներ:\n  - stairs: Անկախ թիվ, որը ներկայացնում է աստիճանների քանակը աստիճանավանդակում:\n\n  Վերադարձնում է:\n  - Անկախ թիվ, որը ներկայացնում է աստիճան բարձրանալու տարբեր եղանակների քանակը:\n\n  Օրինակ:\n  - count_ways_to_climb(2) վերադարձնում է 2 (1 քայլ + 1 քայլ, 2 քայլ)",
      "bn": "একটি নির্দিষ্ট সংখ্যক ধাপের সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা গণনা করে, যেখানে প্রতিটি ধাপে, আপনি হয় এক ধাপ বা দুই ধাপ উঠতে পারেন। আপনি স্তর 0 থেকে শুরু করেন।\n\n  আর্গুমেন্টসমূহ:\n  - stairs: সিঁড়ির ধাপের সংখ্যা নির্দেশকারী একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা নির্দেশকারী একটি পূর্ণসংখ্যা।\n\n  উদাহরণ:\n  - count_ways_to_climb(2) 2 রিটার্ন করে (1 ধাপ + 1 ধাপ, 2 ধাপ)",
      "bg": "Изчислява броя на различните начини за изкачване на стълбище с даден брой стъпала, където на всяка стъпка може да се изкачи или едно стъпало, или две стъпала. Започвате от ниво 0.\n\nАргументи:\n- stairs: Цяло число, представляващо броя на стъпалата в стълбището.\n\nВръща:\n- Цяло число, представляващо броя на различните начини за изкачване на стълбището.\n\nПример:\n- count_ways_to_climb(2) връща 2 (1 стъпало + 1 стъпало, 2 стъпала)",
      "zh": "计算爬一个给定台阶数的楼梯的不同方式的数量，其中每一步可以选择爬一个台阶或两个台阶。你从0级开始。\n\n  参数:\n  - stairs: 一个整数，表示楼梯的台阶数。\n\n  返回:\n  - 一个整数，表示爬楼梯的不同方式的数量。\n\n  示例:\n  - count_ways_to_climb(2) 返回 2 (1步 + 1步, 2步)",
      "fr": "Calcule le nombre de façons différentes de monter un escalier d'un nombre donné de marches, où à chaque marche, on peut soit monter d'une marche, soit de deux marches. Vous commencez au niveau 0.\n\n  Arguments:\n  - stairs: Un entier représentant le nombre de marches dans l'escalier.\n\n  Retours:\n  - Un entier représentant le nombre de façons différentes de monter l'escalier.\n\n  Exemple:\n  - count_ways_to_climb(2) retourne 2 (1 marche + 1 marche, 2 marches)",
      "de": "Berechnet die Anzahl der verschiedenen Möglichkeiten, eine Treppe mit einer gegebenen Anzahl von Stufen zu erklimmen, wobei man bei jedem Schritt entweder eine Stufe oder zwei Stufen steigen kann. Man beginnt auf Ebene 0.\n\n  Argumente:\n  - stairs: Ein Integer, der die Anzahl der Stufen in der Treppe darstellt.\n\n  Rückgabewert:\n  - Ein Integer, der die Anzahl der verschiedenen Möglichkeiten darstellt, die Treppe zu erklimmen.\n\n  Beispiel:\n  - count_ways_to_climb(2) gibt 2 zurück (1 Schritt + 1 Schritt, 2 Schritte)",
      "ha": "Lissafa adadin hanyoyi daban-daban don hawa matakala na adadin matakai da aka bayar, inda a kowane mataki, za a iya hawa mataki daya ko matakai biyu. Ka fara a matakin 0.\n\n  Huɗɗa:\n  - stairs: Lamba mai ɗauke da adadin matakan da ke cikin matakalar.\n\n  Komawa:\n  - Lamba mai ɗauke da adadin hanyoyin daban-daban na hawa matakalar.\n\n  Misali:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "hi": "सीढ़ियों की एक निश्चित संख्या के साथ एक सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या की गणना करता है, जहाँ प्रत्येक कदम पर, आप या तो एक कदम या दो कदम चढ़ सकते हैं। आप स्तर 0 से शुरू करते हैं।\n\n  तर्क:\n  - stairs: एक पूर्णांक जो सीढ़ी में चरणों की संख्या का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक पूर्णांक जो सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_ways_to_climb(2) 2 लौटाता है (1 कदम + 1 कदम, 2 कदम)",
      "hu": "Kiszámítja, hány különböző módon lehet megmászni egy adott lépcsőfokszámú lépcsőt, ahol minden lépésnél egy vagy két lépcsőfokot lehet megmászni. A 0. szinten kezd.\n\n  Argumentumok:\n  - stairs: Egy egész szám, amely a lépcsőfokok számát jelöli a lépcsőn.\n\n  Visszatér:\n  - Egy egész szám, amely a lépcső megmászásának különböző módjainak számát jelöli.\n\n  Példa:\n  - count_ways_to_climb(2) visszaadja 2 (1 lépés + 1 lépés, 2 lépés)"
    },
    "docstring_bertscore": {
      "sq": "0.9879236700938409",
      "hy": "0.9370933610654888",
      "bn": "0.9756882372524728",
      "bg": "0.988539424275049",
      "zh": "0.9551512462661326",
      "fr": "0.9886498627669044",
      "de": "0.9667743016427701",
      "ha": "1",
      "hi": "0.9720968013329809",
      "hu": "0.9589232372019851"
    }
  },
  {
    "task_id": "Rust/32",
    "prompt": {
      "en": "/*\n  Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "sq": "/*\n  Gjen të gjitha intervalet e numrave natyrorë të njëpasnjëshëm, shuma e të cilëve është e barabartë me shumën e dhënë.\n\n  Funksioni identifikon të gjitha sekuencat e mundshme të njëpasnjëshme të numrave natyrorë ku shuma e të gjithë numrave në sekuencë është e barabartë me shumën e synuar. Funksioni kthen një vektor të tufeve, ku çdo tufë përfaqëson fillimin dhe fundin e një sekuence.\n\n  Argumentet:\n  - target_sum: Një numër i plotë që përfaqëson shumën e synuar (10 <= target_sum <= 2,000,000).\n\n  Kthen:\n  - Një vektor tufe. Çdo tufë përmban dy numra të plotë: numrin e parë dhe të fundit në një sekuencë të njëpasnjëshme që shuma e tyre është e barabartë me shumën e synuar.\n\n  Shembull:\n  - find_sum_sequence_ranges(10000) kthen vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "hy": "/*\n  Գտնում է բոլոր հաջորդական բնական թվերի միջակայքերը, որոնց գումարը հավասար է տրված թիրախային գումարին:\n\n  Ֆունկցիան հայտնաբերում է բոլոր հնարավոր հաջորդական բնական թվերի հաջորդականությունները, որտեղ հաջորդականության բոլոր թվերի գումարը հավասար է թիրախային գումարին: Ֆունկցիան վերադարձնում է տուփերի վեկտոր, որտեղ յուրաքանչյուր տուփ ներկայացնում է հաջորդականության սկիզբն ու վերջը:\n\n  Արգումենտներ:\n  - target_sum: Թիվ, որը ներկայացնում է թիրախային գումարը (10 <= target_sum <= 2,000,000):\n\n  Վերադարձնում է:\n  - Տուփերի վեկտոր: Յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ՝ հաջորդականության առաջին և վերջին թիվը, որը գումարվում է թիրախային գումարին:\n\n  Օրինակ:\n  - find_sum_sequence_ranges(10000) վերադարձնում է vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "bn": "/*\n  এমন সব পরিসরের খোঁজ করে যা ধারাবাহিক প্রাকৃতিক সংখ্যার সমষ্টি যা প্রদত্ত লক্ষ্য সমষ্টির সমান।\n\n  ফাংশনটি সমস্ত সম্ভাব্য ধারাবাহিক প্রাকৃতিক সংখ্যার ক্রম সনাক্ত করে যেখানে ক্রমের সমস্ত সংখ্যার সমষ্টি লক্ষ্য সমষ্টির সমান হয়। ফাংশনটি টাপলগুলির একটি ভেক্টর ফেরত দেয়, প্রতিটি টাপল একটি ক্রমের শুরু এবং শেষ নির্দেশ করে।\n\n  আর্গুমেন্টসমূহ:\n  - target_sum: একটি পূর্ণসংখ্যা যা লক্ষ্য সমষ্টিকে উপস্থাপন করে (10 <= target_sum <= 2,000,000)।\n\n  রিটার্নস:\n  - টাপলগুলির একটি ভেক্টর। প্রতিটি টাপল দুটি পূর্ণসংখ্যা ধারণ করে: একটি ধারাবাহিক ক্রমের প্রথম এবং শেষ সংখ্যা যা লক্ষ্য সমষ্টিতে যোগফল হয়।\n\n  উদাহরণ:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] ফেরত দেয়\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "bg": "/*\n  Намира всички диапазони от последователни естествени числа, чиято сума е равна на дадената целева сума.\n\n  Функцията идентифицира всички възможни непрекъснати последователности от естествени числа, при които сумата на всички числа в последователността е равна на целевата сума. Функцията връща вектор от двойки, като всяка двойка представлява началото и края на последователност.\n\n  Аргументи:\n  - target_sum: Цяло число, представляващо целевата сума (10 <= target_sum <= 2,000,000).\n\n  Връща:\n  - Вектор от двойки. Всяка двойка съдържа две цели числа: първото и последното число в непрекъсната последователност, която се сумира до целевата сума.\n\n  Пример:\n  - find_sum_sequence_ranges(10000) връща vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "zh": "/*\n  找到所有连续自然数的范围，其和等于给定的目标和。\n\n  该函数识别所有可能的连续自然数序列，其中序列中所有数字的和等于目标和。函数返回一个元组的向量，每个元组表示一个序列的开始和结束。\n\n  参数:\n  - target_sum: 一个整数，表示目标和 (10 <= target_sum <= 2,000,000)。\n\n  返回:\n  - 一个元组的向量。每个元组包含两个整数：在一个连续序列中，第一个和最后一个数字，其和等于目标和。\n\n  示例:\n  - find_sum_sequence_ranges(10000) 返回 vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "fr": "/*\n  Trouve toutes les plages de nombres naturels consécutifs dont la somme est égale à la somme cible donnée.\n\n  La fonction identifie toutes les séquences contiguës possibles de nombres naturels où la somme de tous les nombres de la séquence est égale à la somme cible. La fonction renvoie un vecteur de tuples, chaque tuple représentant le début et la fin d'une séquence.\n\n  Arguments :\n  - target_sum : Un entier représentant la somme cible (10 <= target_sum <= 2,000,000).\n\n  Renvoie :\n  - Un vecteur de tuples. Chaque tuple contient deux entiers : le premier et le dernier nombre d'une séquence contiguë qui s'additionne pour atteindre la somme cible.\n\n  Exemple :\n  - find_sum_sequence_ranges(10000) renvoie vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "de": "/*\n  Findet alle Bereiche aufeinanderfolgender natürlicher Zahlen, deren Summe der gegebenen Zielsumme entspricht.\n\n  Die Funktion identifiziert alle möglichen zusammenhängenden Sequenzen natürlicher Zahlen, bei denen die Summe aller Zahlen in der Sequenz der Zielsumme entspricht. Die Funktion gibt einen Vektor von Tupeln zurück, wobei jedes Tupel den Anfang und das Ende einer Sequenz darstellt.\n\n  Argumente:\n  - target_sum: Eine ganze Zahl, die die Zielsumme darstellt (10 <= target_sum <= 2,000,000).\n\n  Rückgabewert:\n  - Ein Vektor von Tupeln. Jedes Tupel enthält zwei ganze Zahlen: die erste und letzte Zahl in einer zusammenhängenden Sequenz, die sich zur Zielsumme addiert.\n\n  Beispiel:\n  - find_sum_sequence_ranges(10000) gibt vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] zurück\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "ha": "/*\n  Nemi duk jerin lambobi masu jere na lambobi na halitta waɗanda jimlar su ta yi daidai da adadin da aka ba.\n\n  Aikin yana gano dukkan yiwuwar jerin lambobi masu jere na lambobi na halitta inda jimlar duk lambobin a cikin jerin ta yi daidai da adadin da aka nufa. Aikin yana dawo da wani vector na tuples, kowanne tuple yana wakiltar farkon da ƙarshen jerin.\n\n  Huɗoɗi:\n  - target_sum: Wani cikakken lamba da ke wakiltar adadin da aka nufa (10 <= target_sum <= 2,000,000).\n\n  Komawa:\n  - Wani vector na tuples. Kowanne tuple yana ƙunshe da lambobi biyu: na farko da na ƙarshe a cikin jerin lambobi masu jere wanda jimlarsu ta yi daidai da adadin da aka nufa.\n\n  Misali:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "hi": "/*\n  उन सभी श्रेणियों को खोजता है जिनमें लगातार प्राकृतिक संख्याओं का योग दिए गए लक्ष्य योग के बराबर होता है।\n\n  यह फ़ंक्शन सभी संभावित निरंतर अनुक्रमों की पहचान करता है जिनमें संख्याओं का योग लक्ष्य योग के बराबर होता है। फ़ंक्शन एक टपल के वेक्टर को लौटाता है, प्रत्येक टपल एक अनुक्रम की शुरुआत और अंत का प्रतिनिधित्व करता है।\n\n  तर्क:\n  - target_sum: एक पूर्णांक जो लक्ष्य योग का प्रतिनिधित्व करता है (10 <= target_sum <= 2,000,000)।\n\n  लौटाता है:\n  - टपल का एक वेक्टर। प्रत्येक टपल में दो पूर्णांक होते हैं: एक निरंतर अनुक्रम में पहला और अंतिम संख्या जो लक्ष्य योग के बराबर होती है।\n\n  उदाहरण:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] लौटाता है\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "hu": "/*\n  Megtalálja az összes egymást követő természetes számokból álló tartományt, amelyek összege megegyezik a megadott célszámmal.\n\n  A függvény azonosítja az összes lehetséges összefüggő természetes számok sorozatát, ahol a sorozat összes számának összege megegyezik a célszámmal. A függvény egy vektorral tér vissza, amely tuple-öket tartalmaz, mindegyik tuple a sorozat kezdetét és végét jelöli.\n\n  Argumentumok:\n  - target_sum: Egy egész szám, amely a célszámot jelöli (10 <= target_sum <= 2,000,000).\n\n  Visszatér:\n  - Egy vektor tuple-ökkel. Mindegyik tuple két egész számot tartalmaz: az első és az utolsó számot egy összefüggő sorozatban, amelynek összege megegyezik a célszámmal.\n\n  Példa:\n  - find_sum_sequence_ranges(10000) visszatér vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> "
    },
    "prompt_bertscore": {
      "sq": "0.9664390135595832",
      "hy": "0.976486532753852",
      "bn": "0.9632349068831094",
      "bg": "0.9732621657785127",
      "zh": "0.9686988314046171",
      "fr": "0.9785844668383425",
      "de": "0.988898349373579",
      "ha": "0.9644356275364654",
      "hi": "0.9669483018565567",
      "hu": "0.9747298456639795"
    },
    "canonical_solution": "{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` to solve the following problem:\nFinds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "sq": "Shkruani një funksion në Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` për të zgjidhur problemin e mëposhtëm:\nGjen të gjitha intervalet e numrave natyrorë të njëpasnjëshëm, shuma e të cilëve është e barabartë me shumën e dhënë të synuar.\n\n  Funksioni identifikon të gjitha sekuencat e mundshme të pandërprera të numrave natyrorë ku shuma e të gjithë numrave në sekuencë është e barabartë me shumën e synuar. Funksioni kthen një vektor të treshave, ku çdo treshe përfaqëson fillimin dhe fundin e një sekuence.\n\n  Argumentet:\n  - target_sum: Një numër i plotë që përfaqëson shumën e synuar (10 <= target_sum <= 2,000,000).\n\n  Kthen:\n  - Një vektor treshash. Çdo treshe përmban dy numra të plotë: numrin e parë dhe të fundit në një sekuencë të pandërprerë që shuma është e barabartë me shumën e synuar.\n\n  Shembull:\n  - find_sum_sequence_ranges(10000) kthen vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "hy": "Գրեք Rust ֆունկցիա `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բոլոր հաջորդական բնական թվերի միջակայքերը, որոնց գումարը հավասար է տրված նպատակային գումարին։\n\n  Ֆունկցիան հայտնաբերում է բոլոր հնարավոր շարունակական հաջորդականությունները բնական թվերի, որտեղ հաջորդականության բոլոր թվերի գումարը հավասար է նպատակային գումարին։ Ֆունկցիան վերադարձնում է տուփերի վեկտոր, որտեղ յուրաքանչյուր տուփ ներկայացնում է հաջորդականության սկիզբը և վերջը։\n\n  Արգումենտներ:\n  - target_sum: Ամբողջ թիվ, որը ներկայացնում է նպատակային գումարը (10 <= target_sum <= 2,000,000):\n\n  Վերադարձնում է:\n  - Տուփերի վեկտոր։ Յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ՝ շարունակական հաջորդականության առաջին և վերջին թիվը, որը գումարվում է նպատակային գումարին։\n\n  Օրինակ:\n  - find_sum_sequence_ranges(10000) վերադարձնում է vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "bn": "Rust ফাংশন `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত লক্ষ্য সমান সংখ্যার সমান যেসব পরপর প্রাকৃতিক সংখ্যার পরিসর আছে তা খুঁজে বের করুন।\n\nফাংশনটি সমস্ত সম্ভাব্য ধারাবাহিক প্রাকৃতিক সংখ্যার ক্রম সনাক্ত করে যেখানে ক্রমের সমস্ত সংখ্যার যোগফল লক্ষ্য সমান হয়। ফাংশনটি একটি টুপলের ভেক্টর ফেরত দেয়, প্রতিটি টুপল একটি ক্রমের শুরু এবং শেষকে উপস্থাপন করে।\n\nআর্গুমেন্টসমূহ:\n- target_sum: একটি পূর্ণসংখ্যা যা লক্ষ্য সমানকে উপস্থাপন করে (10 <= target_sum <= 2,000,000)।\n\nফেরত:\n- একটি টুপলের ভেক্টর। প্রতিটি টুপল দুটি পূর্ণসংখ্যা ধারণ করে: একটি ধারাবাহিক ক্রমের প্রথম এবং শেষ সংখ্যা যা লক্ষ্য সমান পর্যন্ত যোগফল হয়।\n\nউদাহরণ:\n- find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] ফেরত দেয়।",
      "bg": "Напишете функция на Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>`, за да решите следния проблем:\nНамира всички диапазони от последователни естествени числа, чиято сума е равна на дадената целева сума.\n\nФункцията идентифицира всички възможни непрекъснати последователности от естествени числа, при които сумата на всички числа в последователността е равна на целевата сума. Функцията връща вектор от кортежи, като всеки кортеж представлява началото и края на една последователност.\n\nАргументи:\n- target_sum: Цяло число, представляващо целевата сума (10 <= target_sum <= 2,000,000).\n\nВръща:\n- Вектор от кортежи. Всеки кортеж съдържа две цели числа: първото и последното число в непрекъсната последователност, която се сумира до целевата сума.\n\nПример:\n- find_sum_sequence_ranges(10000) връща vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "zh": "编写一个 Rust 函数 `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` 来解决以下问题：\n寻找所有连续自然数的范围，其和等于给定的目标和。\n\n该函数识别所有可能的连续自然数序列，其中序列中所有数字的和等于目标和。函数返回一个元组的向量，每个元组表示一个序列的开始和结束。\n\n参数：\n- target_sum: 表示目标和的整数 (10 <= target_sum <= 2,000,000)。\n\n返回：\n- 一个元组的向量。每个元组包含两个整数：连续序列中第一个和最后一个数字，其和等于目标和。\n\n示例：\n- find_sum_sequence_ranges(10000) 返回 vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "fr": "Écrire une fonction Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` pour résoudre le problème suivant :\nTrouve toutes les plages de nombres naturels consécutifs dont la somme est égale à la somme cible donnée.\n\n  La fonction identifie toutes les séquences contiguës possibles de nombres naturels où la somme de tous les nombres de la séquence est égale à la somme cible. La fonction renvoie un vecteur de tuples, chaque tuple représentant le début et la fin d'une séquence.\n\n  Arguments :\n  - target_sum : Un entier représentant la somme cible (10 <= target_sum <= 2,000,000).\n\n  Renvoie :\n  - Un vecteur de tuples. Chaque tuple contient deux entiers : le premier et le dernier nombre d'une séquence contiguë dont la somme est égale à la somme cible.\n\n  Exemple :\n  - find_sum_sequence_ranges(10000) renvoie vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "de": "Schreiben Sie eine Rust-Funktion `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>`, um das folgende Problem zu lösen:\nFindet alle Bereiche aufeinanderfolgender natürlicher Zahlen, deren Summe der gegebenen Zielsumme entspricht.\n\n  Die Funktion identifiziert alle möglichen zusammenhängenden Sequenzen natürlicher Zahlen, bei denen die Summe aller Zahlen in der Sequenz der Zielsumme entspricht. Die Funktion gibt einen Vektor von Tupeln zurück, wobei jedes Tupel den Anfang und das Ende einer Sequenz darstellt.\n\n  Argumente:\n  - target_sum: Eine ganze Zahl, die die Zielsumme darstellt (10 <= target_sum <= 2.000.000).\n\n  Rückgabe:\n  - Ein Vektor von Tupeln. Jedes Tupel enthält zwei ganze Zahlen: die erste und letzte Zahl in einer zusammenhängenden Sequenz, die sich zur Zielsumme addiert.\n\n  Beispiel:\n  - find_sum_sequence_ranges(10000) gibt vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] zurück.",
      "ha": "Rubuta aikin Rust `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` don warware matsalar mai zuwa:\nNemo dukkan jerin lambobi masu jere na lambobi na halitta waɗanda jimlar su ta yi daidai da adadin da aka bayar.\n\n  Aikin yana gano dukkan yiwuwar jerin lambobi masu jere na lambobi na halitta inda jimlar duk lambobin cikin jerin ta yi daidai da adadin da aka bayar. Aikin yana dawowa da vector na tuples, kowanne tuple yana wakiltar farkon da ƙarshen jerin.\n\n  Huɗɗa:\n  - target_sum: Wani cikakken lamba da ke wakiltar adadin da ake nufi (10 <= target_sum <= 2,000,000).\n\n  Dawowa:\n  - Wani vector na tuples. Kowanne tuple yana ƙunshe da lambobi biyu: na farko da na ƙarshe a cikin jerin lambobi masu jere wanda jimlarsu ta yi daidai da adadin da aka bayar.\n\n  Misali:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "hi": "Rust फ़ंक्शन `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन सभी श्रेणियों को खोजें जो लगातार प्राकृतिक संख्याओं की हैं जिनका योग दिए गए लक्षित योग के बराबर है।\n\n  यह फ़ंक्शन सभी संभावित निरंतर अनुक्रमों की पहचान करता है जिनमें संख्याओं का योग लक्षित योग के बराबर होता है। फ़ंक्शन एक वेक्टर लौटाता है जिसमें प्रत्येक टपल एक अनुक्रम की शुरुआत और अंत का प्रतिनिधित्व करता है।\n\n  तर्क:\n  - target_sum: एक पूर्णांक जो लक्षित योग का प्रतिनिधित्व करता है (10 <= target_sum <= 2,000,000)।\n\n  वापसी मान:\n  - टपल्स का एक वेक्टर। प्रत्येक टपल में दो पूर्णांक होते हैं: एक निरंतर अनुक्रम में पहला और अंतिम संख्या जो लक्षित योग के बराबर होती है।\n\n  उदाहरण:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>` a következő probléma megoldására:\nMegtalálja az összes olyan egymást követő természetes számokból álló tartományt, amelyek összege megegyezik a megadott célszámmal.\n\nA függvény azonosítja az összes lehetséges összefüggő természetes számokból álló sorozatot, ahol a sorozat összes számának összege megegyezik a célszámmal. A függvény egy vektorral tér vissza, amely tuple-öket tartalmaz, minden tuple egy sorozat kezdetét és végét jelöli.\n\nArgumentumok:\n- target_sum: Egy egész szám, amely a célszámot jelöli (10 <= target_sum <= 2,000,000).\n\nVisszatérési érték:\n- Egy vektor tuple-ökkel. Minden tuple két egész számot tartalmaz: az első és utolsó számot egy összefüggő sorozatban, amelynek összege a célszám.\n\nPélda:\n- find_sum_sequence_ranges(10000) visszaadja vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]"
    },
    "instruction_bertscore": {
      "sq": "0.9539769434534543",
      "hy": "0.9725935759159492",
      "bn": "0.9749580719717885",
      "bg": "0.9812127440401961",
      "zh": "0.9708354984134094",
      "fr": "0.9778517193627048",
      "de": "0.9914819347396998",
      "ha": "0.9565412616726148",
      "hi": "0.9476249424983396",
      "hu": "0.9721555959257673"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_sum_sequence_ranges(10000), vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]);\n        assert_eq!(find_sum_sequence_ranges(15), vec![(1, 5), (4, 6), (7, 8)]);\n        assert_eq!(find_sum_sequence_ranges(28), vec![(1, 7)]);\n        assert_eq!(find_sum_sequence_ranges(21334), vec![(5332, 5335)]);\n        println!(\"All test cases passed!\");\n    }\n    \n\n}",
    "entry_point": "find_sum_sequence_ranges",
    "signature": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>",
    "docstring": {
      "en": "Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "sq": "Gjen të gjitha intervalet e numrave natyrorë të njëpasnjëshëm, shuma e të cilëve është e barabartë me shumën e dhënë të synuar.\n\n  Funksioni identifikon të gjitha sekuencat e mundshme të njëpasnjëshme të numrave natyrorë ku shuma e të gjithë numrave në sekuencë është e barabartë me shumën e synuar. Funksioni kthen një vektor të torkave, ku secila torkë përfaqëson fillimin dhe fundin e një sekuence.\n\n  Argumentet:\n  - target_sum: Një numër i plotë që përfaqëson shumën e synuar (10 <= target_sum <= 2,000,000).\n\n  Kthen:\n  - Një vektor të torkave. Secila torkë përmban dy numra të plotë: numrin e parë dhe të fundit në një sekuencë të njëpasnjëshme që e ka shumën të barabartë me shumën e synuar.\n\n  Shembull:\n  - find_sum_sequence_ranges(10000) kthen vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "hy": "Գտնում է բոլոր հաջորդական բնական թվերի միջակայքերը, որոնց գումարը հավասար է տրված թիրախային գումարին։\n\n  Ֆունկցիան հայտնաբերում է բոլոր հնարավոր հաջորդական բնական թվերի հաջորդականությունները, որտեղ հաջորդականության բոլոր թվերի գումարը հավասար է թիրախային գումարին։ Ֆունկցիան վերադարձնում է տուփերի վեկտոր, որտեղ յուրաքանչյուր տուփ ներկայացնում է հաջորդականության սկիզբն ու վերջը։\n\n  Արգումենտներ:\n  - target_sum: Թիվ, որը ներկայացնում է թիրախային գումարը (10 <= target_sum <= 2,000,000)։\n\n  Վերադարձնում է:\n  - Տուփերի վեկտոր։ Յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ՝ հաջորդականության առաջին և վերջին թիվը, որը գումարվում է մինչև թիրախային գումարը։\n\n  Օրինակ:\n  - find_sum_sequence_ranges(10000) վերադարձնում է vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "bn": "সকল পরিসরের ধারাবাহিক প্রাকৃতিক সংখ্যা খুঁজে বের করে যাদের যোগফল প্রদত্ত লক্ষ্য যোগফলের সমান।\n\nফাংশনটি সমস্ত সম্ভাব্য ধারাবাহিক প্রাকৃতিক সংখ্যার ক্রম সনাক্ত করে যেখানে ক্রমের সমস্ত সংখ্যার যোগফল লক্ষ্য যোগফলের সমান। ফাংশনটি টুপলের একটি ভেক্টর ফেরত দেয়, প্রতিটি টুপল একটি ক্রমের শুরু এবং শেষকে উপস্থাপন করে।\n\nআর্গুমেন্টস:\n- target_sum: একটি পূর্ণসংখ্যা যা লক্ষ্য যোগফলকে উপস্থাপন করে (10 <= target_sum <= 2,000,000)।\n\nফেরত:\n- টুপলের একটি ভেক্টর। প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে: একটি ধারাবাহিক ক্রমের প্রথম এবং শেষ সংখ্যা যা লক্ষ্য যোগফলে যুক্ত হয়।\n\nউদাহরণ:\n- find_sum_sequence_ranges(10000) ফেরত দেয় vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "bg": "Намира всички диапазони от последователни естествени числа, чиято сума е равна на дадената целева сума.\n\nФункцията идентифицира всички възможни съседни последователности от естествени числа, където сумата на всички числа в последователността е равна на целевата сума. Функцията връща вектор от наредени двойки, като всяка двойка представлява началото и края на последователност.\n\nАргументи:\n- target_sum: Цяло число, представляващо целевата сума (10 <= target_sum <= 2,000,000).\n\nВръща:\n- Вектор от наредени двойки. Всяка двойка съдържа две цели числа: първото и последното число в съседна последователност, която се сумира до целевата сума.\n\nПример:\n- find_sum_sequence_ranges(10000) връща vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "zh": "找到所有连续自然数的范围，其和等于给定的目标和。\n\n该函数识别所有可能的连续自然数序列，其中序列中所有数字的和等于目标和。函数返回一个元组的向量，每个元组表示一个序列的开始和结束。\n\n参数：\n- target_sum: 一个整数，表示目标和 (10 <= target_sum <= 2,000,000)。\n\n返回：\n- 一个元组的向量。每个元组包含两个整数：一个连续序列中第一个和最后一个数字，其和等于目标和。\n\n示例：\n- find_sum_sequence_ranges(10000) 返回 vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "fr": "Trouve toutes les plages de nombres naturels consécutifs dont la somme est égale à la somme cible donnée.\n\n  La fonction identifie toutes les séquences contiguës possibles de nombres naturels où la somme de tous les nombres de la séquence est égale à la somme cible. La fonction renvoie un vecteur de tuples, chaque tuple représentant le début et la fin d'une séquence.\n\n  Arguments:\n  - target_sum: Un entier représentant la somme cible (10 <= target_sum <= 2,000,000).\n\n  Renvoie:\n  - Un vecteur de tuples. Chaque tuple contient deux entiers : le premier et le dernier nombre dans une séquence contiguë dont la somme est égale à la somme cible.\n\n  Exemple:\n  - find_sum_sequence_ranges(10000) renvoie vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "de": "Findet alle Bereiche von aufeinanderfolgenden natürlichen Zahlen, deren Summe der gegebenen Zielsumme entspricht.\n\n  Die Funktion identifiziert alle möglichen zusammenhängenden Sequenzen von natürlichen Zahlen, bei denen die Summe aller Zahlen in der Sequenz der Zielsumme entspricht. Die Funktion gibt einen Vektor von Tupeln zurück, wobei jedes Tupel den Anfang und das Ende einer Sequenz darstellt.\n\n  Argumente:\n  - target_sum: Ein ganzzahliger Wert, der die Zielsumme darstellt (10 <= target_sum <= 2,000,000).\n\n  Rückgabewert:\n  - Ein Vektor von Tupeln. Jedes Tupel enthält zwei ganze Zahlen: die erste und die letzte Zahl in einer zusammenhängenden Sequenz, die sich zur Zielsumme addieren.\n\n  Beispiel:\n  - find_sum_sequence_ranges(10000) gibt vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] zurück.",
      "ha": "Nemo dukkan jerin lambobi masu jere na lambobi na halitta waɗanda jimlar su ta yi daidai da adadin da aka ba.\n\n  Aikin yana gano dukkan yiwuwar jerin lambobi masu jere na lambobi na halitta inda jimlar duk lambobin a cikin jerin ta yi daidai da adadin da aka nufa. Aikin yana mayar da vector na tuples, kowace tuple tana wakiltar farkon da ƙarshen jerin.\n\n  Huɗaɗɗa:\n  - target_sum: Wani cikakken lamba da ke wakiltar adadin da aka nufa (10 <= target_sum <= 2,000,000).\n\n  Komawa:\n  - Wani vector na tuples. Kowace tuple tana ƙunshe da lambobi biyu: na farko da na ƙarshe a cikin jerin lambobi masu jere waɗanda jimlarsu ta yi daidai da adadin da aka nufa.\n\n  Misali:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "hi": "सभी लगातार प्राकृतिक संख्याओं की श्रेणियों को खोजता है जिनका योग दिए गए लक्ष्य योग के बराबर होता है।\n\nयह फ़ंक्शन सभी संभावित सतत प्राकृतिक संख्याओं के अनुक्रमों की पहचान करता है जहाँ अनुक्रम में सभी संख्याओं का योग लक्ष्य योग के बराबर होता है। फ़ंक्शन एक टपल के वेक्टर को लौटाता है, प्रत्येक टपल एक अनुक्रम की शुरुआत और अंत का प्रतिनिधित्व करता है।\n\nआर्ग्युमेंट्स:\n- target_sum: एक पूर्णांक जो लक्ष्य योग का प्रतिनिधित्व करता है (10 <= target_sum <= 2,000,000)।\n\nरिटर्न:\n- टपल का एक वेक्टर। प्रत्येक टपल में दो पूर्णांक होते हैं: एक सतत अनुक्रम में पहली और अंतिम संख्या जो लक्ष्य योग के बराबर होती है।\n\nउदाहरण:\n- find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] लौटाता है।",
      "hu": "Megtalálja az összes olyan egymást követő természetes számokból álló tartományt, amelyek összege megegyezik a megadott célösszeggel.\n\nA függvény azonosítja az összes lehetséges összefüggő természetes számokból álló sorozatot, ahol a sorozat összes számának összege megegyezik a célösszeggel. A függvény egy vektorral tér vissza, amelyben minden elem egy-egy tuple, és minden tuple egy sorozat kezdetét és végét jelöli.\n\nArgumentumok:\n- target_sum: Egy egész szám, amely a célösszeget jelöli (10 <= target_sum <= 2,000,000).\n\nVisszatérési érték:\n- Egy tuple-öket tartalmazó vektor. Minden tuple két egész számot tartalmaz: az első és az utolsó számot egy összefüggő sorozatban, amely összege a célösszeggel egyenlő.\n\nPélda:\n- find_sum_sequence_ranges(10000) visszaadja a vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]"
    },
    "docstring_bertscore": {
      "sq": "0.9602816703778827",
      "hy": "0.9797514203269224",
      "bn": "0.9828641570281202",
      "bg": "0.9627858035915896",
      "zh": "0.9637509486130381",
      "fr": "0.9749618459490282",
      "de": "0.9779311715151188",
      "ha": "0.9392429390490484",
      "hi": "0.9809926615780095",
      "hu": "0.9548223143551389"
    }
  },
  {
    "task_id": "Rust/33",
    "prompt": {
      "en": "/*\n  Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "sq": "/*\n  Konverton një varg binar (që përbëhet nga '0' dhe '1') në formën e tij të përmbysur. \n  Çdo '0' në vargun hyrës zëvendësohet me një '1', dhe çdo '1' zëvendësohet me një '0'.\n\n  Argumentet:\n  - input: Një varg që përbëhet nga shifrat binare ('0' dhe '1').\n\n  Kthen:\n  - Një varg i ri që përfaqëson sekuencën binare të përmbysur të vargut hyrës.\n\n  Shembull:\n  - invert_binary_string(\"0110\") kthen \"1001\"\n  - invert_binary_string(\"1111\") kthen \"0000\"\n  - invert_binary_string(\"0000\") kthen \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "hy": "/*\n  Տեքստային տող, որը կազմված է '0'-ներից և '1'-ներից, փոխակերպում է իր հակադարձ ձևին։ \n  Մուտքային տողում յուրաքանչյուր '0' փոխարինվում է '1'-ով, իսկ յուրաքանչյուր '1' փոխարինվում է '0'-ով։\n\n  Արգումենտներ:\n  - input: Տող, որը կազմված է բինար թվանշաններից ('0' և '1')։\n\n  Վերադարձնում է:\n  - Նոր տող, որը ներկայացնում է մուտքային տողի հակադարձ բինար հաջորդականությունը։\n\n  Օրինակ:\n  - invert_binary_string(\"0110\") վերադարձնում է \"1001\"\n  - invert_binary_string(\"1111\") վերադարձնում է \"0000\"\n  - invert_binary_string(\"0000\") վերադարձնում է \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "bn": "/*\n  একটি বাইনারি স্ট্রিং (যা '0' এবং '1' নিয়ে গঠিত) তার বিপরীত রূপে রূপান্তর করে।\n  ইনপুট স্ট্রিং-এর প্রতিটি '0' কে '1' দিয়ে প্রতিস্থাপন করা হয়, এবং প্রতিটি '1' কে '0' দিয়ে প্রতিস্থাপন করা হয়।\n\n  আর্গুমেন্টসমূহ:\n  - input: একটি স্ট্রিং যা বাইনারি অঙ্ক ('0' এবং '1') নিয়ে গঠিত।\n\n  রিটার্নস:\n  - একটি নতুন স্ট্রিং যা ইনপুট স্ট্রিং-এর বিপরীত বাইনারি সিকোয়েন্স উপস্থাপন করে।\n\n  উদাহরণ:\n  - invert_binary_string(\"0110\") রিটার্ন করে \"1001\"\n  - invert_binary_string(\"1111\") রিটার্ন করে \"0000\"\n  - invert_binary_string(\"0000\") রিটার্ন করে \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "bg": "/*\n  Преобразува двоична низ (състояща се от '0' и '1') в нейната инвертирана форма. \n  Всеки '0' в входната низ се заменя с '1', а всеки '1' се заменя с '0'.\n\n  Аргументи:\n  - input: Низ, състоящ се от двоични цифри ('0' и '1').\n\n  Връща:\n  - Нова низ, представляваща инвертираната двоична последователност на входната низ.\n\n  Пример:\n  - invert_binary_string(\"0110\") връща \"1001\"\n  - invert_binary_string(\"1111\") връща \"0000\"\n  - invert_binary_string(\"0000\") връща \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "zh": "/*\n  将二进制字符串（由'0'和'1'组成）转换为其反转形式。\n  输入字符串中的每个'0'替换为'1'，每个'1'替换为'0'。\n\n  参数:\n  - input: 一个由二进制数字（'0'和'1'）组成的字符串。\n\n  返回:\n  - 一个新字符串，表示输入字符串的反转二进制序列。\n\n  示例:\n  - invert_binary_string(\"0110\") 返回 \"1001\"\n  - invert_binary_string(\"1111\") 返回 \"0000\"\n  - invert_binary_string(\"0000\") 返回 \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "fr": "/*\n  Convertit une chaîne binaire (composée de '0' et de '1') en sa forme inversée. \n  Chaque '0' dans la chaîne d'entrée est remplacé par un '1', et chaque '1' est remplacé par un '0'.\n\n  Arguments :\n  - input : Une chaîne composée de chiffres binaires ('0' et '1').\n\n  Renvoie :\n  - Une nouvelle chaîne représentant la séquence binaire inversée de la chaîne d'entrée.\n\n  Exemple :\n  - invert_binary_string(\"0110\") renvoie \"1001\"\n  - invert_binary_string(\"1111\") renvoie \"0000\"\n  - invert_binary_string(\"0000\") renvoie \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "de": "/*\n  Konvertiert einen Binärstring (bestehend aus '0' und '1') in seine invertierte Form. \n  Jedes '0' im Eingabestring wird durch ein '1' ersetzt, und jedes '1' wird durch ein '0' ersetzt.\n\n  Argumente:\n  - input: Ein String bestehend aus Binärziffern ('0' und '1').\n\n  Rückgabewerte:\n  - Ein neuer String, der die invertierte Binärsequenz des Eingabestrings darstellt.\n\n  Beispiel:\n  - invert_binary_string(\"0110\") gibt \"1001\" zurück\n  - invert_binary_string(\"1111\") gibt \"0000\" zurück\n  - invert_binary_string(\"0000\") gibt \"1111\" zurück\n*/\nfn invert_binary_string(input: &str) -> String ",
      "ha": "/*\n  Canza wani igiyar binary (wanda ya ƙunshi '0's da '1's) zuwa nau'in da aka juya. \n  Duk wani '0' a cikin igiyar shigarwa ana maye gurbinsa da '1', kuma duk wani '1' ana maye gurbinsa da '0'.\n\n  Huɗɗa:\n  - input: Wani igiya wanda ya ƙunshi lambobin binary ('0' da '1').\n\n  Mayarwa:\n  - Sabuwar igiya wadda ke wakiltar jerin lambobin binary da aka juya na igiyar shigarwa.\n\n  Misali:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "hi": "/*\n  एक बाइनरी स्ट्रिंग (जिसमें '0' और '1' होते हैं) को उसके उल्टे रूप में परिवर्तित करता है। \n  इनपुट स्ट्रिंग में हर '0' को '1' से और हर '1' को '0' से बदला जाता है।\n\n  तर्क:\n  - input: एक स्ट्रिंग जिसमें बाइनरी अंक ('0' और '1') होते हैं।\n\n  लौटाता है:\n  - एक नई स्ट्रिंग जो इनपुट स्ट्रिंग के उल्टे बाइनरी अनुक्रम का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "hu": "/*\n  Egy bináris karakterláncot (amely '0'-kból és '1'-ekből áll) alakít át annak invertált formájára. \n  Az input karakterlánc minden '0'-ját '1'-re cseréli, és minden '1'-et '0'-ra.\n\n  Argumentumok:\n  - input: Egy karakterlánc, amely bináris számjegyekből ('0' és '1') áll.\n\n  Visszatér:\n  - Egy új karakterlánc, amely az input karakterlánc invertált bináris sorozatát képviseli.\n\n  Példa:\n  - invert_binary_string(\"0110\") visszaadja \"1001\"\n  - invert_binary_string(\"1111\") visszaadja \"0000\"\n  - invert_binary_string(\"0000\") visszaadja \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9857019892819656",
      "hy": "0.9583636954186099",
      "bn": "0.9675279053084165",
      "bg": "0.9769878758355841",
      "zh": "0.9530634423310749",
      "fr": "0.9815559773386244",
      "de": "0.9813221893801464",
      "ha": "0.9768093071230337",
      "hi": "0.9763516627251293",
      "hu": "0.978331014472142"
    },
    "canonical_solution": "{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}",
    "instruction": {
      "en": "Write a Rust function `fn invert_binary_string(input: &str) -> String` to solve the following problem:\nConverts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "sq": "Shkruani një funksion Rust `fn invert_binary_string(input: &str) -> String` për të zgjidhur problemin e mëposhtëm:\nKonverton një varg binar (që përbëhet nga '0' dhe '1') në formën e tij të invertuar.\n  Çdo '0' në vargun e hyrjes zëvendësohet me një '1', dhe çdo '1' zëvendësohet me një '0'.\n\n  Argumentet:\n  - input: Një varg që përbëhet nga shifrat binare ('0' dhe '1').\n\n  Kthen:\n  - Një varg i ri që përfaqëson sekuencën binare të invertuar të vargut të hyrjes.\n\n  Shembull:\n  - invert_binary_string(\"0110\") kthen \"1001\"\n  - invert_binary_string(\"1111\") kthen \"0000\"\n  - invert_binary_string(\"0000\") kthen \"1111\"",
      "hy": "Գրեք Rust ֆունկցիա `fn invert_binary_string(input: &str) -> String` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է բինար տողը (կազմված '0'-ներից և '1'-ներից) իր շրջված ձևին: \n  Մուտքային տողում յուրաքանչյուր '0' փոխարինվում է '1'-ով, և յուրաքանչյուր '1' փոխարինվում է '0'-ով:\n\n  Արգումենտներ:\n  - input: Տող, որը բաղկացած է բինար թվանշաններից ('0' և '1'):\n\n  Վերադարձնում է:\n  - Նոր տող, որը ներկայացնում է մուտքային տողի շրջված բինար հաջորդականությունը:\n\n  Օրինակ:\n  - invert_binary_string(\"0110\") վերադարձնում է \"1001\"\n  - invert_binary_string(\"1111\") վերադարձնում է \"0000\"\n  - invert_binary_string(\"0000\") վերադարձնում է \"1111\"",
      "bn": "Rust ফাংশন `fn invert_binary_string(input: &str) -> String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি স্ট্রিং (যা '0' এবং '1' নিয়ে গঠিত) তার বিপরীত রূপে রূপান্তর করে। \n  ইনপুট স্ট্রিংয়ের প্রতিটি '0' কে '1' দিয়ে প্রতিস্থাপন করা হয়, এবং প্রতিটি '1' কে '0' দিয়ে প্রতিস্থাপন করা হয়।\n\n  আর্গুমেন্ট:\n  - input: একটি স্ট্রিং যা বাইনারি সংখ্যা ('0' এবং '1') নিয়ে গঠিত।\n\n  রিটার্নস:\n  - একটি নতুন স্ট্রিং যা ইনপুট স্ট্রিংয়ের বিপরীত বাইনারি সিকোয়েন্স উপস্থাপন করে।\n\n  উদাহরণ:\n  - invert_binary_string(\"0110\") \"1001\" রিটার্ন করে\n  - invert_binary_string(\"1111\") \"0000\" রিটার্ন করে\n  - invert_binary_string(\"0000\") \"1111\" রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn invert_binary_string(input: &str) -> String`, за да решите следния проблем:\nПреобразува двоична низ (състояща се от '0' и '1') в нейната инвертирана форма. \n  Всеки '0' в входния низ се заменя с '1', а всеки '1' се заменя с '0'.\n\n  Аргументи:\n  - input: Низ, състоящ се от двоични цифри ('0' и '1').\n\n  Връща:\n  - Нов низ, представляващ инвертираната двоична последователност на входния низ.\n\n  Пример:\n  - invert_binary_string(\"0110\") връща \"1001\"\n  - invert_binary_string(\"1111\") връща \"0000\"\n  - invert_binary_string(\"0000\") връща \"1111\"",
      "zh": "编写一个 Rust 函数 `fn invert_binary_string(input: &str) -> String` 来解决以下问题：\n将一个由 '0' 和 '1' 组成的二进制字符串转换为其反转形式。\n输入字符串中的每个 '0' 都被替换为 '1'，每个 '1' 都被替换为 '0'。\n\n参数：\n- input: 一个由二进制数字（'0' 和 '1'）组成的字符串。\n\n返回：\n- 一个新的字符串，表示输入字符串的反转二进制序列。\n\n示例：\n- invert_binary_string(\"0110\") 返回 \"1001\"\n- invert_binary_string(\"1111\") 返回 \"0000\"\n- invert_binary_string(\"0000\") 返回 \"1111\"",
      "fr": "Écrire une fonction Rust `fn invert_binary_string(input: &str) -> String` pour résoudre le problème suivant :\nConvertit une chaîne binaire (composée de '0' et '1') en sa forme inversée. \n  Chaque '0' dans la chaîne d'entrée est remplacé par un '1', et chaque '1' est remplacé par un '0'.\n\n  Arguments :\n  - input : Une chaîne composée de chiffres binaires ('0' et '1').\n\n  Renvoie :\n  - Une nouvelle chaîne représentant la séquence binaire inversée de la chaîne d'entrée.\n\n  Exemple :\n  - invert_binary_string(\"0110\") renvoie \"1001\"\n  - invert_binary_string(\"1111\") renvoie \"0000\"\n  - invert_binary_string(\"0000\") renvoie \"1111\"",
      "de": "Schreiben Sie eine Rust-Funktion `fn invert_binary_string(input: &str) -> String`, um das folgende Problem zu lösen:\nKonvertiert einen Binärstring (bestehend aus '0' und '1') in seine invertierte Form.\n  Jedes '0' im Eingabestring wird durch ein '1' ersetzt, und jedes '1' wird durch ein '0' ersetzt.\n\n  Argumente:\n  - input: Ein String, der aus Binärziffern ('0' und '1') besteht.\n\n  Rückgabewert:\n  - Ein neuer String, der die invertierte Binärsequenz des Eingabestrings darstellt.\n\n  Beispiel:\n  - invert_binary_string(\"0110\") gibt \"1001\" zurück\n  - invert_binary_string(\"1111\") gibt \"0000\" zurück\n  - invert_binary_string(\"0000\") gibt \"1111\" zurück",
      "ha": "Rubuta aikin Rust `fn invert_binary_string(input: &str) -> String` don warware matsalar mai zuwa:\nCanza wani igiyar binary (wanda ya ƙunshi '0's da '1's) zuwa nau'in da aka juyar da shi.\n  Kowace '0' a cikin igiyar shigarwa ana maye gurbinsa da '1', kuma kowace '1' ana maye gurbinsa da '0'.\n\n  Huɗa:\n  - input: Wani igiya da ya ƙunshi lambobin binary ('0' da '1').\n\n  Mayarwa:\n  - Sabuwar igiya da ke wakiltar jujjuyawar jerin binary na igiyar shigarwa.\n\n  Misali:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "hi": "Rust फ़ंक्शन `fn invert_binary_string(input: &str) -> String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक बाइनरी स्ट्रिंग (जिसमें '0' और '1' होते हैं) को उसके उल्टे रूप में बदलता है। \nइनपुट स्ट्रिंग में हर '0' को '1' से बदला जाता है, और हर '1' को '0' से बदला जाता है।\n\nआर्गुमेंट्स:\n- input: एक स्ट्रिंग जिसमें बाइनरी अंक ('0' और '1') होते हैं।\n\nरिटर्न करता है:\n- एक नई स्ट्रिंग जो इनपुट स्ट्रिंग के उल्टे बाइनरी अनुक्रम का प्रतिनिधित्व करती है।\n\nउदाहरण:\n- invert_binary_string(\"0110\") \"1001\" लौटाता है\n- invert_binary_string(\"1111\") \"0000\" लौटाता है\n- invert_binary_string(\"0000\") \"1111\" लौटाता है",
      "hu": "Írj egy Rust függvényt `fn invert_binary_string(input: &str) -> String` a következő probléma megoldására:\nÁtalakít egy bináris karakterláncot (amely '0'-kból és '1'-ekből áll) annak invertált formájává. \n  Az input karakterlánc minden '0'-ját '1'-re cseréli, és minden '1'-et '0'-ra.\n\n  Argumentumok:\n  - input: Egy karakterlánc, amely bináris számjegyekből ('0' és '1') áll.\n\n  Visszatér:\n  - Egy új karakterlánc, amely az input karakterlánc invertált bináris sorozatát képviseli.\n\n  Példa:\n  - invert_binary_string(\"0110\") visszatér \"1001\"\n  - invert_binary_string(\"1111\") visszatér \"0000\"\n  - invert_binary_string(\"0000\") visszatér \"1111\""
    },
    "instruction_bertscore": {
      "sq": "0.9856175713700258",
      "hy": "0.9900545768215832",
      "bn": "0.9562206722376244",
      "bg": "0.9770987115882015",
      "zh": "0.961945597079812",
      "fr": "0.9819534367310753",
      "de": "0.9813837647982672",
      "ha": "0.9632243794729146",
      "hi": "0.9669496922692239",
      "hu": "0.9757718606428885"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n   \n        assert_eq!(invert_binary_string(\"0110100100100\"), \"1001011011011\");\n        assert_eq!(invert_binary_string(\"1000000010000000000\"), \"0111111101111111111\");\n        assert_eq!(invert_binary_string(\"11110000\"), \"00001111\");\n        assert_eq!(invert_binary_string(\"0000\"), \"1111\");\n        println!(\"All test cases passed!\");\n        \n        \n    }\n    \n\n}",
    "entry_point": "invert_binary_string",
    "signature": "fn invert_binary_string(input: &str) -> String",
    "docstring": {
      "en": "Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "sq": "Konverton një varg binar (i përbërë nga '0' dhe '1') në formën e tij të përmbysur. \n  Çdo '0' në vargun hyrës zëvendësohet me një '1', dhe çdo '1' zëvendësohet me një '0'.\n\n  Argumentet:\n  - input: Një varg që përbëhet nga shifrat binare ('0' dhe '1').\n\n  Kthen:\n  - Një varg i ri që përfaqëson sekuencën binare të përmbysur të vargut hyrës.\n\n  Shembull:\n  - invert_binary_string(\"0110\") kthen \"1001\"\n  - invert_binary_string(\"1111\") kthen \"0000\"\n  - invert_binary_string(\"0000\") kthen \"1111\"",
      "hy": "Վերածում է երկբայական տողը (կազմված '0'-ներից և '1'-ներից) իր հակադարձ ձևին։ \n  Մուտքային տողի յուրաքանչյուր '0' փոխարինվում է '1'-ով, և յուրաքանչյուր '1' փոխարինվում է '0'-ով։\n\n  Արգումենտներ:\n  - input: Տող, որը կազմված է երկբայական թվանշաններից ('0' և '1')։\n\n  Վերադարձնում է:\n  - Նոր տող, որը ներկայացնում է մուտքային տողի հակադարձված երկբայական հաջորդականությունը։\n\n  Օրինակ:\n  - invert_binary_string(\"0110\") վերադարձնում է \"1001\"\n  - invert_binary_string(\"1111\") վերադարձնում է \"0000\"\n  - invert_binary_string(\"0000\") վերադարձնում է \"1111\"",
      "bn": "একটি বাইনারি স্ট্রিং (যা '0' এবং '1' নিয়ে গঠিত) তার বিপরীত রূপে রূপান্তর করে। ইনপুট স্ট্রিংয়ের প্রতিটি '0' কে '1' দিয়ে প্রতিস্থাপন করা হয়, এবং প্রতিটি '1' কে '0' দিয়ে প্রতিস্থাপন করা হয়।\n\nArguments:\n- input: একটি স্ট্রিং যা বাইনারি ডিজিট ('0' এবং '1') নিয়ে গঠিত।\n\nReturns:\n- একটি নতুন স্ট্রিং যা ইনপুট স্ট্রিংয়ের বিপরীত বাইনারি ক্রমকে উপস্থাপন করে।\n\nExample:\n- invert_binary_string(\"0110\") returns \"1001\"\n- invert_binary_string(\"1111\") returns \"0000\"\n- invert_binary_string(\"0000\") returns \"1111\"",
      "bg": "Преобразува двоична низ (състояща се от '0' и '1') в нейната инвертирана форма. \n  Всеки '0' в входната низ се заменя с '1', а всеки '1' се заменя с '0'.\n\n  Аргументи:\n  - input: Низ, състоящ се от двоични цифри ('0' и '1').\n\n  Връща:\n  - Нов низ, представляващ инвертираната двоична последователност на входната низ.\n\n  Пример:\n  - invert_binary_string(\"0110\") връща \"1001\"\n  - invert_binary_string(\"1111\") връща \"0000\"\n  - invert_binary_string(\"0000\") връща \"1111\"",
      "zh": "将二进制字符串（由 '0' 和 '1' 组成）转换为其反转形式。输入字符串中的每个 '0' 都替换为 '1'，每个 '1' 都替换为 '0'。\n\nArguments:\n- input: 一个由二进制数字（'0' 和 '1'）组成的字符串。\n\nReturns:\n- 一个新字符串，表示输入字符串的反转二进制序列。\n\nExample:\n- invert_binary_string(\"0110\") returns \"1001\"\n- invert_binary_string(\"1111\") returns \"0000\"\n- invert_binary_string(\"0000\") returns \"1111\"",
      "fr": "Convertit une chaîne binaire (composée de '0' et de '1') en sa forme inversée. \n  Chaque '0' dans la chaîne d'entrée est remplacé par un '1', et chaque '1' est remplacé par un '0'.\n\n  Arguments:\n  - input: Une chaîne composée de chiffres binaires ('0' et '1').\n\n  Renvoie:\n  - Une nouvelle chaîne représentant la séquence binaire inversée de la chaîne d'entrée.\n\n  Exemple:\n  - invert_binary_string(\"0110\") renvoie \"1001\"\n  - invert_binary_string(\"1111\") renvoie \"0000\"\n  - invert_binary_string(\"0000\") renvoie \"1111\"",
      "de": "Konvertiert einen Binärstring (bestehend aus '0' und '1') in seine invertierte Form. \n  Jedes '0' im Eingabestring wird durch eine '1' ersetzt, und jede '1' wird durch eine '0' ersetzt.\n\n  Argumente:\n  - input: Ein String, der aus Binärziffern ('0' und '1') besteht.\n\n  Rückgabewert:\n  - Ein neuer String, der die invertierte Binärsequenz des Eingabestrings darstellt.\n\n  Beispiel:\n  - invert_binary_string(\"0110\") gibt \"1001\" zurück\n  - invert_binary_string(\"1111\") gibt \"0000\" zurück\n  - invert_binary_string(\"0000\") gibt \"1111\" zurück",
      "ha": "Canza wani igiyar binary (wanda ya ƙunshi '0's da '1's) zuwa nau'in da aka juya. \n  Kowanne '0' a cikin igiyar shigarwa ana maye gurbinsa da '1', kuma kowanne '1' ana maye gurbinsa da '0'.\n\n  Arguments:\n  - input: Wani igiya wanda ya ƙunshi lambobin binary ('0' da '1').\n\n  Returns:\n  - Sabuwar igiya wadda ke wakiltar jujjuyawar jerin lambobin binary na igiyar shigarwa.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "hi": "एक बाइनरी स्ट्रिंग (जिसमें '0' और '1' होते हैं) को उसके उल्टे रूप में परिवर्तित करता है। \n  इनपुट स्ट्रिंग में हर '0' को '1' से और हर '1' को '0' से बदल दिया जाता है।\n\n  Arguments:\n  - input: एक स्ट्रिंग जो बाइनरी अंकों ('0' और '1') से बनी होती है।\n\n  Returns:\n  - एक नई स्ट्रिंग जो इनपुट स्ट्रिंग के उल्टे बाइनरी अनुक्रम का प्रतिनिधित्व करती है।\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "hu": "Bináris karakterláncot (csak '0' és '1' karakterekből álló) alakít át annak invertált formájára. \n  Az input karakterlánc minden '0' karakterét '1'-re, és minden '1' karakterét '0'-ra cseréli.\n\n  Argumentumok:\n  - input: Egy karakterlánc, amely bináris számjegyekből ('0' és '1') áll.\n\n  Visszatérési érték:\n  - Egy új karakterlánc, amely az input karakterlánc invertált bináris sorozatát képviseli.\n\n  Példa:\n  - invert_binary_string(\"0110\") visszaadja \"1001\"\n  - invert_binary_string(\"1111\") visszaadja \"0000\"\n  - invert_binary_string(\"0000\") visszaadja \"1111\""
    },
    "docstring_bertscore": {
      "sq": "0.9802273387198821",
      "hy": "0.9860825650920285",
      "bn": "0.9653552862006569",
      "bg": "0.9763401421630293",
      "zh": "0.9628350639260862",
      "fr": "0.9795567625535083",
      "de": "0.9798992013304124",
      "ha": "0.9826367252418352",
      "hi": "0.991380434614991",
      "hu": "0.9430804780106424"
    }
  },
  {
    "task_id": "Rust/34",
    "prompt": {
      "en": "/*\n  Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "sq": "/*\n  Llogarit distancën totale minimale nga të gjithë banorët deri te një zyrë postare e vendosur brenda qytetit të tyre. Qyteti është i vendosur në një rrjet, me rrugë që shkojnë nga veriu në jug dhe nga lindja në perëndim, duke formuar blloqe.\n\n  Distanca midis dy pikave (x1, y1) dhe (x2, y2) përcaktohet si |x1 - x2| + |y1 - y2|.\n\n  Argumentet:\n  - residents: Një pjesë e tupleve, secila që përfaqëson koordinatat (x, y) të vendndodhjes së një banori.\n\n  Kthen:\n  - Distancën totale minimale nga të gjithë banorët deri te zyra postare.\n\n  Shembuj:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) kthen 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) kthen 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
      "hy": "/*\n  Հաշվում է բոլոր բնակիչների նվազագույն ընդհանուր հեռավորությունը փոստային բաժանմունքից, որը գտնվում է նրանց քաղաքում։ Քաղաքը դասավորված է ցանցի տեսքով, որտեղ փողոցները անցնում են հյուսիս-հարավ և արևելք-արևմուտք ուղղություններով՝ ձևավորելով բլոկներ։\n\n  Երկու կետերի (x1, y1) և (x2, y2) միջև հեռավորությունը սահմանվում է որպես |x1 - x2| + |y1 - y2|։\n\n  Արգումենտներ:\n  - residents: Կտոր կորտեժների, որոնցից յուրաքանչյուրը ներկայացնում է բնակչի գտնվելու վայրի (x, y) կոորդինատները։\n\n  Վերադարձնում է:\n  - Բոլոր բնակիչների նվազագույն ընդհանուր հեռավորությունը փոստային բաժանմունքից։\n\n  Օրինակներ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) վերադարձնում է 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) վերադարձնում է 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
      "bn": "/*\n  শহরের মধ্যে অবস্থিত একটি ডাকঘরের সাথে সমস্ত বাসিন্দাদের ন্যূনতম মোট দূরত্ব গণনা করে। শহরটি একটি গ্রিডে সাজানো, যেখানে রাস্তা উত্তর-দক্ষিণ এবং পূর্ব-পশ্চিম দিকে চলে, ব্লক তৈরি করে।\n\n  দুটি বিন্দুর মধ্যে দূরত্ব (x1, y1) এবং (x2, y2) হিসাবে সংজ্ঞায়িত করা হয় |x1 - x2| + |y1 - y2|।\n\n  আর্গুমেন্টসমূহ:\n  - বাসিন্দারা: টুপলের একটি স্লাইস, প্রতিটি একটি বাসিন্দার অবস্থানের (x, y) স্থানাঙ্ক উপস্থাপন করে।\n\n  রিটার্ন করে:\n  - সমস্ত বাসিন্দাদের ডাকঘরের সাথে ন্যূনতম মোট দূরত্ব।\n\n  উদাহরণ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 রিটার্ন করে\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 রিটার্ন করে\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "bg": "/*\n  Изчислява минималното общо разстояние от всички жители до пощенски офис, разположен в техния град. Градът е разположен в мрежа, с улици, които вървят север-юг и изток-запад, образувайки блокове.\n\n  Разстоянието между две точки (x1, y1) и (x2, y2) се определя като |x1 - x2| + |y1 - y2|.\n\n  Аргументи:\n  - residents: Масив от кортежи, всеки представляващ (x, y) координатите на местоположението на жител.\n\n  Връща:\n  - Минималното общо разстояние от всички жители до пощенския офис.\n\n  Примери:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) връща 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) връща 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "zh": "/*\n  计算所有居民到位于其城市内的邮局的最小总距离。城市布局为网格状，街道呈南北和东西走向，形成街区。\n\n  两点 (x1, y1) 和 (x2, y2) 之间的距离定义为 |x1 - x2| + |y1 - y2|。\n\n  参数：\n  - residents: 一个元组的切片，每个元组表示居民位置的 (x, y) 坐标。\n\n  返回：\n  - 所有居民到邮局的最小总距离。\n\n  示例：\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 返回 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 返回 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "fr": "/*\n  Calcule la distance totale minimale de tous les résidents à un bureau de poste situé dans leur ville. La ville est disposée en grille, avec des rues orientées nord-sud et est-ouest, formant des blocs.\n\n  La distance entre deux points (x1, y1) et (x2, y2) est définie comme |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: Une tranche de tuples, chacun représentant les coordonnées (x, y) de l'emplacement d'un résident.\n\n  Renvoie:\n  - La distance totale minimale de tous les résidents au bureau de poste.\n\n  Exemples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) renvoie 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) renvoie 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "de": "/*\n  Berechnet die minimale Gesamtdistanz von allen Bewohnern zu einem Postamt, das sich innerhalb ihrer Stadt befindet. Die Stadt ist in einem Raster angelegt, mit Straßen, die von Nord nach Süd und von Ost nach West verlaufen und Blöcke bilden.\n\n  Die Entfernung zwischen zwei Punkten (x1, y1) und (x2, y2) ist definiert als |x1 - x2| + |y1 - y2|.\n\n  Argumente:\n  - residents: Ein Slice von Tupeln, die jeweils die (x, y)-Koordinaten des Standorts eines Bewohners darstellen.\n\n  Rückgabewert:\n  - Die minimale Gesamtdistanz von allen Bewohnern zum Postamt.\n\n  Beispiele:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) gibt 10 zurück\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) gibt 2 zurück\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "ha": "/*\n  Lissafa mafi ƙarancin jimillar nesa daga duk mazauna zuwa ofishin gidan waya da ke cikin birninsu. Birnin yana shimfiɗa a cikin grid, tare da tituna suna gudana arewa-kudu da gabas-yamma, suna samar da tubalan.\n\n  Nesa tsakanin maki biyu (x1, y1) da (x2, y2) ana ayyana shi azaman |x1 - x2| + |y1 - y2|.\n\n  Huɗɗa:\n  - mazauna: Wani yanki na tuples, kowanne yana wakiltar (x, y) tsararren wurin zama na mazaunin.\n\n  Mayarwa:\n  - Mafi ƙarancin jimillar nesa daga duk mazauna zuwa ofishin gidan waya.\n\n  Misalai:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "hi": "/*\n  सभी निवासियों से उनके शहर में स्थित एक डाकघर तक न्यूनतम कुल दूरी की गणना करता है। शहर एक ग्रिड में व्यवस्थित है, जिसमें सड़कें उत्तर-दक्षिण और पूर्व-पश्चिम दिशा में चलती हैं, जो ब्लॉकों का निर्माण करती हैं।\n\n  दो बिंदुओं (x1, y1) और (x2, y2) के बीच की दूरी को |x1 - x2| + |y1 - y2| के रूप में परिभाषित किया गया है।\n\n  तर्क:\n  - residents: ट्यूपल्स का एक स्लाइस, प्रत्येक निवासी के स्थान के (x, y) निर्देशांक का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - सभी निवासियों से डाकघर तक न्यूनतम कुल दूरी।\n\n  उदाहरण:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 लौटाता है\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 लौटाता है\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "hu": "/*\n  Kiszámítja a minimális össztávolságot az összes lakos és egy postahivatal között, amely a városukban található. A város egy rácsra van felosztva, ahol az utcák észak-déli és kelet-nyugati irányban futnak, blokkokat alkotva.\n\n  A távolság két pont között (x1, y1) és (x2, y2) úgy van meghatározva, hogy |x1 - x2| + |y1 - y2|.\n\n  Argumentumok:\n  - residents: Egy tuple-ökből álló szelet, amelyek mindegyike egy lakos helyének (x, y) koordinátáit képviseli.\n\n  Visszatér:\n  - A minimális össztávolság az összes lakos és a postahivatal között.\n\n  Példák:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) visszatér 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) visszatér 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32"
    },
    "prompt_bertscore": {
      "sq": "0.9924301961787604",
      "hy": "0.9833422603552712",
      "bn": "0.981291798931848",
      "bg": "0.9945615001672647",
      "zh": "0.9787084121961083",
      "fr": "0.9802376674996959",
      "de": "0.9844543918586856",
      "ha": "0.9880313277603617",
      "hi": "0.9896279187631202",
      "hu": "0.9816193404301745"
    },
    "canonical_solution": "{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}",
    "instruction": {
      "en": "Write a Rust function `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` to solve the following problem:\nCalculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "sq": "Shkruani një funksion në Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit distancën minimale totale nga të gjithë banorët deri te një zyrë postare e vendosur brenda qytetit të tyre. Qyteti është i organizuar në një rrjet, me rrugë që shkojnë nga veriu në jug dhe nga lindja në perëndim, duke formuar blloqe.\n\nDistanca midis dy pikave (x1, y1) dhe (x2, y2) përcaktohet si |x1 - x2| + |y1 - y2|.\n\nArgumentet:\n- residents: Një pjesë e tupleve, secila që përfaqëson koordinatat (x, y) të vendndodhjes së një banori.\n\nKthen:\n- Distanca minimale totale nga të gjithë banorët deri te zyra postare.\n\nShembuj:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) kthen 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) kthen 2",
      "hy": "Գրեք Rust ֆունկցիա `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է բոլոր բնակիչներից մինչև փոստային գրասենյակ նվազագույն ընդհանուր հեռավորությունը, որը գտնվում է նրանց քաղաքում։ Քաղաքը դասավորված է ցանցի վրա, փողոցները անցնում են հյուսիս-հարավ և արևելք-արևմուտք ուղղություններով, ձևավորելով բլոկներ։\n\n  Երկու կետերի (x1, y1) և (x2, y2) միջև հեռավորությունը սահմանվում է որպես |x1 - x2| + |y1 - y2|։\n\n  Փաստարկներ:\n  - residents: Կտոր կորտեժներից, որոնցից յուրաքանչյուրը ներկայացնում է բնակչի գտնվելու վայրի (x, y) կոորդինատները։\n\n  Վերադարձնում է:\n  - Նվազագույն ընդհանուր հեռավորությունը բոլոր բնակիչներից մինչև փոստային գրասենյակ։\n\n  Օրինակներ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) վերադարձնում է 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) վերադարձնում է 2",
      "bn": "Rust ফাংশন `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসকল বাসিন্দার কাছ থেকে তাদের শহরের মধ্যে অবস্থিত একটি ডাকঘরের ন্যূনতম মোট দূরত্ব গণনা করে। শহরটি একটি গ্রিডে সাজানো, যেখানে রাস্তা উত্তর-দক্ষিণ এবং পূর্ব-পশ্চিম দিকে চলে, ব্লক গঠন করে।\n\nদুটি বিন্দুর মধ্যে দূরত্ব (x1, y1) এবং (x2, y2) সংজ্ঞায়িত করা হয় |x1 - x2| + |y1 - y2| হিসাবে।\n\nআর্গুমেন্টসমূহ:\n- residents: টিউপলের একটি স্লাইস, প্রতিটি একটি বাসিন্দার অবস্থানের (x, y) কোঅর্ডিনেট উপস্থাপন করে।\n\nফেরত দেয়:\n- সকল বাসিন্দার কাছ থেকে ডাকঘরের ন্যূনতম মোট দূরত্ব।\n\nউদাহরণসমূহ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 ফেরত দেয়\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 ফেরত দেয়",
      "bg": "Напишете функция на Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32`, за да решите следния проблем:\nИзчислява минималното общо разстояние от всички жители до пощенска станция, разположена в техния град. Градът е разположен в мрежа, с улици, които вървят север-юг и изток-запад, образувайки блокове.\n\nРазстоянието между две точки (x1, y1) и (x2, y2) се определя като |x1 - x2| + |y1 - y2|.\n\nАргументи:\n- residents: Срез от кортежи, всеки представляващ (x, y) координатите на местоположението на жител.\n\nВръща:\n- Минималното общо разстояние от всички жители до пощенската станция.\n\nПримери:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) връща 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) връща 2",
      "zh": "编写一个 Rust 函数 `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` 来解决以下问题：\n计算所有居民到位于其城市内的邮局的最小总距离。城市布局为网格状，街道呈南北和东西走向，形成街区。\n\n两点 (x1, y1) 和 (x2, y2) 之间的距离定义为 |x1 - x2| + |y1 - y2|。\n\n参数：\n- residents: 一个元组的切片，每个元组表示居民位置的 (x, y) 坐标。\n\n返回值：\n- 所有居民到邮局的最小总距离。\n\n示例：\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 返回 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 返回 2",
      "fr": "Écrire une fonction Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` pour résoudre le problème suivant :\nCalcule la distance totale minimale de tous les résidents à un bureau de poste situé dans leur ville. La ville est disposée en grille, avec des rues allant du nord au sud et d'est en ouest, formant des blocs.\n\n  La distance entre deux points (x1, y1) et (x2, y2) est définie comme |x1 - x2| + |y1 - y2|.\n\n  Arguments :\n  - residents : Un tableau de tuples, chacun représentant les coordonnées (x, y) de l'emplacement d'un résident.\n\n  Renvoie :\n  - La distance totale minimale de tous les résidents au bureau de poste.\n\n  Exemples :\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) renvoie 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) renvoie 2",
      "de": "Schreiben Sie eine Rust-Funktion `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32`, um das folgende Problem zu lösen:\nBerechnet die minimale Gesamtdistanz von allen Bewohnern zu einem Postamt, das sich innerhalb ihrer Stadt befindet. Die Stadt ist in einem Raster angelegt, mit Straßen, die von Nord nach Süd und von Ost nach West verlaufen und Blöcke bilden.\n\n  Die Distanz zwischen zwei Punkten (x1, y1) und (x2, y2) ist definiert als |x1 - x2| + |y1 - y2|.\n\n  Argumente:\n  - residents: Ein Slice von Tupeln, die jeweils die (x, y)-Koordinaten des Standorts eines Bewohners darstellen.\n\n  Rückgabewert:\n  - Die minimale Gesamtdistanz von allen Bewohnern zum Postamt.\n\n  Beispiele:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) gibt 10 zurück\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) gibt 2 zurück",
      "ha": "Rubuta aikin Rust `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` don warware matsalar mai zuwa:\nLissafi mafi ƙarancin jimlar nesa daga duk mazauna zuwa ofishin gidan waya da ke cikin birninsu. Birnin yana shimfiɗa a cikin grid, tare da tituna suna gudana arewa-kudu da gabas-yamma, suna samar da tubalan.\n\n  An ayyana nesa tsakanin maki biyu (x1, y1) da (x2, y2) a matsayin |x1 - x2| + |y1 - y2|.\n\n  Huɗa:\n  - mazauna: Yanke na tuples, kowanne yana wakiltar (x, y) daidaitattun wurin zama na mazaunin.\n\n  Mayarwa:\n  - Mafi ƙarancin jimlar nesa daga duk mazauna zuwa ofishin gidan waya.\n\n  Misalai:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "hi": "Rust फ़ंक्शन `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी निवासियों से उनके शहर में स्थित एक डाकघर तक की न्यूनतम कुल दूरी की गणना करता है। शहर एक ग्रिड में बिछा हुआ है, जिसमें उत्तर-दक्षिण और पूर्व-पश्चिम की ओर सड़कें चलती हैं, जो ब्लॉक बनाती हैं।\n\n  दो बिंदुओं (x1, y1) और (x2, y2) के बीच की दूरी को |x1 - x2| + |y1 - y2| के रूप में परिभाषित किया गया है।\n\n  तर्क:\n  - residents: ट्यूपल्स की एक स्लाइस, प्रत्येक निवासी के स्थान के (x, y) निर्देशांक का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - सभी निवासियों से डाकघर तक की न्यूनतम कुल दूरी।\n\n  उदाहरण:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 लौटाता है\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 लौटाता है",
      "hu": "Készíts egy Rust függvényt `fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32` a következő probléma megoldására:\nKiszámítja a minimális össztávolságot az összes lakos és egy postahivatal között, amely a városukban található. A város egy rácson helyezkedik el, ahol az utcák észak-déli és kelet-nyugati irányban futnak, blokkokat alkotva.\n\n  A távolság két pont között (x1, y1) és (x2, y2) úgy van meghatározva, mint |x1 - x2| + |y1 - y2|.\n\n  Argumentumok:\n  - residents: Egy tuple szelet, amely az egyes lakosok helyzetének (x, y) koordinátáit képviseli.\n\n  Visszatérési érték:\n  - Az összes lakos és a postahivatal közötti minimális össztávolság.\n\n  Példák:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) visszaadja 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9815639225538658",
      "hy": "0.9983871213059967",
      "bn": "0.9777241986580804",
      "bg": "0.9956698576934394",
      "zh": "0.9856153864358345",
      "fr": "0.9839103432450309",
      "de": "0.9867579083875471",
      "ha": "0.9894231308402732",
      "hi": "0.9846037619052237",
      "hu": "0.9821234643372411"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]), 10);\n        assert_eq!(minimum_distance_to_post_office(&[(0, 0), (1, 1)]), 2);\n    \n    }\n\n}",
    "entry_point": "minimum_distance_to_post_office",
    "signature": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
    "docstring": {
      "en": "Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "sq": "Llogarit distancën totale minimale nga të gjithë banorët deri te një zyrë postare e vendosur brenda qytetit të tyre. Qyteti është i shtrirë në një rrjetë, me rrugë që shkojnë nga veriu në jug dhe nga lindja në perëndim, duke formuar blloqe.\n\nDistanca midis dy pikave (x1, y1) dhe (x2, y2) përcaktohet si |x1 - x2| + |y1 - y2|.\n\nArgumentet:\n- residents: Një pjesë e tupleve, secila që përfaqëson koordinatat (x, y) të vendndodhjes së një banori.\n\nKthen:\n- Distanca totale minimale nga të gjithë banorët deri te zyra postare.\n\nShembuj:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) kthen 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) kthen 2",
      "hy": "Հաշվում է բնակիչներից փոստային գրասենյակ գտնվելու նվազագույն ընդհանուր հեռավորությունը, որը գտնվում է նրանց քաղաքի ներսում։ Քաղաքը դասավորված է ցանցաձև, հյուսիս-հարավ և արևելք-արևմուտք ուղղություններով փողոցներով, ձևավորելով բլոկներ։\n\nԵրկու կետերի (x1, y1) և (x2, y2) միջև հեռավորությունը սահմանվում է որպես |x1 - x2| + |y1 - y2|։\n\nԱրգումենտներ:\n- residents: Կտրվածք, որը պարունակում է տուփեր, որոնցից յուրաքանչյուրը ներկայացնում է բնակչի գտնվելու վայրի (x, y) կոորդինատները։\n\nՎերադարձնում է:\n- Բոլոր բնակիչներից փոստային գրասենյակ գտնվելու նվազագույն ընդհանուր հեռավորությունը։\n\nՕրինակներ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) վերադարձնում է 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) վերադարձնում է 2",
      "bn": "শহরের সকল বাসিন্দার কাছ থেকে একটি ডাকঘরের ন্যূনতম মোট দূরত্ব গণনা করে। শহরটি একটি গ্রিডে সাজানো, যেখানে রাস্তা উত্তর-দক্ষিণ এবং পূর্ব-পশ্চিমে চলে, ব্লক তৈরি করে।\n\nদুটি বিন্দুর (x1, y1) এবং (x2, y2) মধ্যে দূরত্বকে সংজ্ঞায়িত করা হয় |x1 - x2| + |y1 - y2| হিসাবে।\n\nআর্গুমেন্টস:\n- residents: টুপলের একটি স্লাইস, প্রতিটি একটি বাসিন্দার অবস্থানের (x, y) স্থানাঙ্ক উপস্থাপন করে।\n\nরিটার্নস:\n- সকল বাসিন্দার কাছ থেকে ডাকঘরের ন্যূনতম মোট দূরত্ব।\n\nউদাহরণ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) রিটার্ন করে 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) রিটার্ন করে 2",
      "bg": "Изчислява минималното общо разстояние от всички жители до пощенска станция, разположена в техния град. Градът е разположен в мрежа, с улици, които вървят от север на юг и от изток на запад, образувайки блокове.\n\nРазстоянието между две точки (x1, y1) и (x2, y2) се определя като |x1 - x2| + |y1 - y2|.\n\nАргументи:\n- residents: Срез от кортежи, всеки представляващ (x, y) координатите на местоположението на жител.\n\nВръща:\n- Минималното общо разстояние от всички жители до пощенската станция.\n\nПримери:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) връща 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) връща 2",
      "zh": "计算所有居民到位于城市内的邮局的最小总距离。城市布局为网格状，街道呈南北和东西走向，形成街区。\n\n两个点 (x1, y1) 和 (x2, y2) 之间的距离定义为 |x1 - x2| + |y1 - y2|。\n\n参数：\n- residents: 一个元组的切片，每个元组代表一个居民位置的 (x, y) 坐标。\n\n返回：\n- 所有居民到邮局的最小总距离。\n\n示例：\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 返回 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 返回 2",
      "fr": "Calcule la distance totale minimale de tous les résidents à un bureau de poste situé dans leur ville. La ville est disposée en grille, avec des rues orientées nord-sud et est-ouest, formant des blocs.\n\nLa distance entre deux points (x1, y1) et (x2, y2) est définie comme |x1 - x2| + |y1 - y2|.\n\nArguments:\n- residents: Une tranche de tuples, chacun représentant les coordonnées (x, y) de l'emplacement d'un résident.\n\nReturns:\n- La distance totale minimale de tous les résidents au bureau de poste.\n\nExamples:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "de": "Berechnet die minimale Gesamtdistanz von allen Bewohnern zu einem Postamt, das sich innerhalb ihrer Stadt befindet. Die Stadt ist in einem Raster angelegt, mit Straßen, die von Nord nach Süd und von Ost nach West verlaufen und Blöcke bilden.\n\n  Die Entfernung zwischen zwei Punkten (x1, y1) und (x2, y2) wird definiert als |x1 - x2| + |y1 - y2|.\n\n  Argumente:\n  - residents: Ein Slice von Tupeln, die jeweils die (x, y)-Koordinaten des Standorts eines Bewohners darstellen.\n\n  Rückgabewerte:\n  - Die minimale Gesamtdistanz von allen Bewohnern zum Postamt.\n\n  Beispiele:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) gibt 10 zurück\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) gibt 2 zurück",
      "ha": "Lissafa mafi ƙarancin jimillar nesa daga duk mazauna zuwa ofishin gidan waya da ke cikin birninsu. Birnin yana shimfiɗa a cikin grid, tare da tituna suna gudana arewa-kudu da gabas-yamma, suna samar da tubalan.\n\n  Nisan tsakanin wurare biyu (x1, y1) da (x2, y2) an ayyana shi a matsayin |x1 - x2| + |y1 - y2|.\n\n  Huɗa:\n  - residents: Wani yanki na tuples, kowanne yana wakiltar (x, y) da ke nuna wurin zama na mazaunin.\n\n  Dawowa:\n  - Mafi ƙarancin nisan jimla daga duk mazauna zuwa ofishin gidan waya.\n\n  Misalai:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "hi": "सभी निवासियों से उनके शहर में स्थित एक डाकघर तक की न्यूनतम कुल दूरी की गणना करता है। शहर एक ग्रिड में व्यवस्थित है, जिसमें सड़कें उत्तर-दक्षिण और पूर्व-पश्चिम दिशा में चलती हैं, जो ब्लॉक बनाती हैं।\n\n  दो बिंदुओं (x1, y1) और (x2, y2) के बीच की दूरी को |x1 - x2| + |y1 - y2| के रूप में परिभाषित किया गया है।\n\n  तर्क:\n  - residents: ट्यूपल्स का एक स्लाइस, प्रत्येक निवासी के स्थान के (x, y) निर्देशांक का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - सभी निवासियों से डाकघर तक की न्यूनतम कुल दूरी।\n\n  उदाहरण:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 लौटाता है\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 लौटाता है",
      "hu": "Kiszámítja a minimális össztávolságot az összes lakos és egy postahivatal között, amely a városukban található. A város egy rácsos elrendezésű, ahol az utcák észak-déli és kelet-nyugati irányban futnak, blokkokat alkotva.\n\nA két pont (x1, y1) és (x2, y2) közötti távolságot |x1 - x2| + |y1 - y2| képlettel határozzuk meg.\n\nArgumentumok:\n- residents: Egy szelet tuple-ökből, amelyek mindegyike egy lakos helyének (x, y) koordinátáit jelöli.\n\nVisszatérési érték:\n- A minimális össztávolság az összes lakos és a postahivatal között.\n\nPéldák:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) visszaadja 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9954452067324889",
      "hy": "0.9879008276000218",
      "bn": "1",
      "bg": "0.9989327589626995",
      "zh": "0.9722414042503744",
      "fr": "0.9815905390249245",
      "de": "0.983170842336438",
      "ha": "0.9834091987936799",
      "hi": "0.9844126794786682",
      "hu": "0.973178741018478"
    }
  },
  {
    "task_id": "Rust/35",
    "prompt": {
      "en": "/*\n  Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "sq": "/*\n  Llogarit numrin maksimal të raketave që mund të kapen nga sistemi, duke pasur parasysh lartësitë e tyre në rendin që zbulohen.\n  Sistemi i kapjes mund të kapë çdo lartësi për raketën e parë, por kapjet e mëvonshme duhet të jenë në lartësi më të vogla ose të barabarta me kapjen e mëparshme.\n\n  Argumentet:\n  - heights: Një segment i numrave të plotë që përfaqësojnë lartësitë e raketave që vijnë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin maksimal të raketave që mund të kapen.\n\n  Shembull:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) kthen 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) kthen 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) kthen 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "hy": "/*\n  Հաշվում է առավելագույն քանակը հրթիռների, որոնք կարող են որսալ համակարգը, հաշվի առնելով նրանց բարձրությունները հայտնաբերման հերթականությամբ:\n  Որսման համակարգը կարող է որսալ ցանկացած բարձրություն առաջին հրթիռի համար, բայց հաջորդ որսումները պետք է լինեն նախորդ որսման բարձրությունից փոքր կամ հավասար:\n\n  Փաստարկներ:\n  - heights: ամբողջ թվերի կտոր, որը ներկայացնում է ներգնա հրթիռների բարձրությունները:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է առավելագույն քանակը հրթիռների, որոնք կարող են որսալ:\n\n  Օրինակ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) վերադարձնում է 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) վերադարձնում է 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) վերադարձնում է 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32",
      "bn": "/*\n  সিস্টেম দ্বারা সর্বাধিক সংখ্যক ক্ষেপণাস্ত্র আটকানো যেতে পারে তা গণনা করে, তাদের উচ্চতা প্রদর্শিত হওয়ার ক্রমে দেওয়া হয়।\n  প্রথম ক্ষেপণাস্ত্রের জন্য ইন্টারসেপশন সিস্টেম যে কোনো উচ্চতা আটকাতে পারে, তবে পরবর্তী ইন্টারসেপশনগুলি অবশ্যই আগের ইন্টারসেপশনের সমান বা কম উচ্চতায় হতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - heights: আসন্ন ক্ষেপণাস্ত্রের উচ্চতাগুলিকে উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্ন করে:\n  - একটি পূর্ণসংখ্যা যা আটকানো যেতে পারে এমন ক্ষেপণাস্ত্রের সর্বাধিক সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 রিটার্ন করে\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 রিটার্ন করে\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 রিটার্ন করে\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "bg": "/*\n  Изчислява максималния брой ракети, които могат да бъдат прехванати от системата, като се вземат предвид височините им в реда, в който са засечени.\n  Системата за прехващане може да прехване всяка височина за първата ракета, но следващите прехващания трябва да бъдат на височини, по-малки или равни на предишното прехващане.\n\n  Аргументи:\n  - heights: Срез от цели числа, представляващи височините на приближаващите ракети.\n\n  Връща:\n  - Цяло число, представляващо максималния брой ракети, които могат да бъдат прехванати.\n\n  Пример:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) връща 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) връща 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) връща 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "zh": "/*\n  计算系统可以拦截的导弹的最大数量，给定它们被检测到的高度顺序。\n  拦截系统可以拦截第一个导弹的任何高度，但后续的拦截必须在小于或等于上一次拦截的高度。\n\n  参数:\n  - heights: 一个整数切片，表示来袭导弹的高度。\n\n  返回:\n  - 一个整数，表示可以拦截的导弹的最大数量。\n\n  示例:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 返回 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 返回 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 返回 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "fr": "/*\n  Calcule le nombre maximum de missiles qui peuvent être interceptés par le système, étant donné leurs hauteurs dans l'ordre où ils sont détectés.\n  Le système d'interception peut intercepter n'importe quelle hauteur pour le premier missile, mais les interceptions suivantes doivent être à des hauteurs inférieures ou égales à l'interception précédente.\n\n  Arguments :\n  - heights: Une tranche d'entiers représentant les hauteurs des missiles entrants.\n\n  Renvoie :\n  - Un entier représentant le nombre maximum de missiles qui peuvent être interceptés.\n\n  Exemple :\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) renvoie 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) renvoie 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) renvoie 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "de": "/*\n  Berechnet die maximale Anzahl von Raketen, die vom System abgefangen werden können, gegeben ihre Höhen in der Reihenfolge, in der sie erkannt werden.\n  Das Abfangsystem kann jede Höhe für die erste Rakete abfangen, aber nachfolgende Abfänge müssen in Höhen erfolgen, die kleiner oder gleich dem vorherigen Abfang sind.\n\n  Argumente:\n  - heights: Ein Slice von ganzen Zahlen, das die Höhen der ankommenden Raketen darstellt.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die maximale Anzahl von Raketen darstellt, die abgefangen werden können.\n\n  Beispiel:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) gibt 5 zurück\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) gibt 5 zurück\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) gibt 1 zurück\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "ha": "/*\n  Lissafa yawan makamai masu linzami mafi girma da tsarin zai iya tarewa, la'akari da tsayinsu a cikin tsari da aka gano su.\n  Tsarin tarewa zai iya tare kowane tsayi don makami na farko, amma tarewa na gaba dole ne ya kasance a tsayi daidai ko ƙasa da tarewar da ta gabata.\n\n  Huɗa:\n  - heights: Wani yanki na lambobin tsari da ke wakiltar tsayin makamai masu linzami da ke zuwa.\n\n  Mayarwa:\n  - Wani lamba da ke wakiltar yawan makamai masu linzami mafi girma da za a iya tarewa.\n\n  Misali:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "hi": "/*\n  यह प्रणाली द्वारा अवरोधित किए जा सकने वाले अधिकतम मिसाइलों की संख्या की गणना करता है, जब उनकी ऊँचाई का पता लगाया जाता है।\n  अवरोधन प्रणाली पहली मिसाइल के लिए किसी भी ऊँचाई को अवरोधित कर सकती है, लेकिन बाद के अवरोधन को पिछले अवरोधन के बराबर या उससे कम ऊँचाई पर होना चाहिए।\n\n  तर्क:\n  - heights: आने वाली मिसाइलों की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\n  लौटाता है:\n  - एक पूर्णांक जो दर्शाता है कि अधिकतम कितनी मिसाइलों को अवरोधित किया जा सकता है।\n\n  उदाहरण:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 लौटाता है\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 लौटाता है\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 लौटाता है\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "hu": "/*\n  Kiszámítja a maximális számú rakétát, amelyet a rendszer képes elfogni, figyelembe véve a magasságukat az észlelés sorrendjében.\n  Az elfogórendszer bármilyen magasságot elfoghat az első rakétánál, de a további elfogásoknak kisebb vagy egyenlő magasságon kell történniük, mint az előző elfogás.\n\n  Argumentumok:\n  - heights: Egész számokat tartalmazó szelet, amely a bejövő rakéták magasságát képviseli.\n\n  Visszatér:\n  - Egy egész szám, amely a maximálisan elfogható rakéták számát jelenti.\n\n  Példa:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) visszaadja 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) visszaadja 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) visszaadja 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.999100204373912",
      "hy": "0.9821824575604085",
      "bn": "0.9829849242997895",
      "bg": "0.9693614623557495",
      "zh": "0.9624205223208664",
      "fr": "0.999100204373912",
      "de": "0.9720294656338101",
      "ha": "0.963232126057775",
      "hi": "0.9650891214900701",
      "hu": "0.9806049350742294"
    },
    "canonical_solution": "{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_missiles_intercepted(heights: &[i32]) -> i32` to solve the following problem:\nCalculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "sq": "Shkruani një funksion Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin maksimal të raketave që mund të kapen nga sistemi, duke pasur parasysh lartësitë e tyre në rendin që janë zbuluar.\n  Sistemi i kapjes mund të kapë çdo lartësi për raketën e parë, por kapjet e mëvonshme duhet të jenë në lartësi më të vogla ose të barabarta me kapjen e mëparshme.\n\n  Argumentet:\n  - heights: Një segment i numrave të plotë që përfaqësojnë lartësitë e raketave që vijnë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin maksimal të raketave që mund të kapen.\n\n  Shembull:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) kthen 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) kthen 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) kthen 1",
      "hy": "Գրեք Rust ֆունկցիա `fn max_missiles_intercepted(heights: &[i32]) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է առավելագույն քանակը հրթիռների, որոնք կարող են որսալ համակարգը՝ հաշվի առնելով դրանց բարձրությունները հայտնաբերման կարգով:\n  Որսման համակարգը կարող է որսալ ցանկացած բարձրություն առաջին հրթիռի համար, բայց հաջորդ որսումները պետք է լինեն նախորդ որսման բարձրությանը հավասար կամ փոքր:\n\n  Փոփոխականներ:\n  - heights: Թվերի զանգված, որը ներկայացնում է մոտեցող հրթիռների բարձրությունները:\n\n  Վերադարձնում է:\n  - Թիվ, որը ներկայացնում է առավելագույն քանակը հրթիռների, որոնք կարող են որսալ:\n\n  Օրինակ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) վերադարձնում է 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) վերադարձնում է 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) վերադարձնում է 1",
      "bn": "Rust ফাংশন `fn max_missiles_intercepted(heights: &[i32]) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nব্যবস্থাটি প্রদত্ত উচ্চতাগুলির ভিত্তিতে সর্বাধিক সংখ্যক ক্ষেপণাস্ত্র আটকাতে পারে তা গণনা করে, যেগুলি সনাক্ত করার ক্রমে থাকে।\n  প্রতিরোধ ব্যবস্থা প্রথম ক্ষেপণাস্ত্রের জন্য যেকোনো উচ্চতা আটকাতে পারে, কিন্তু পরবর্তী প্রতিরোধগুলি অবশ্যই পূর্ববর্তী প্রতিরোধের সমান বা তার চেয়ে কম উচ্চতায় হতে হবে।\n\n  আর্গুমেন্ট:\n  - heights: আসন্ন ক্ষেপণাস্ত্রগুলির উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্ন:\n  - একটি পূর্ণসংখ্যা যা সর্বাধিক সংখ্যক ক্ষেপণাস্ত্রকে উপস্থাপন করে যা আটকানো যেতে পারে।\n\n  উদাহরণ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 ফেরত দেয়\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 ফেরত দেয়\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 ফেরত দেয়",
      "bg": "Напишете функция на Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32`, за да решите следния проблем:\nИзчислява максималния брой ракети, които могат да бъдат прихванати от системата, като се имат предвид техните височини в реда, в който са засечени.\n  Системата за прихващане може да прихване всякаква височина за първата ракета, но последващите прихващания трябва да бъдат на височини, по-малки или равни на предишното прихващане.\n\n  Аргументи:\n  - heights: Срез от цели числа, представляващи височините на входящите ракети.\n\n  Връща:\n  - Цяло число, представляващо максималния брой ракети, които могат да бъдат прихванати.\n\n  Пример:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) връща 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) връща 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) връща 1",
      "zh": "编写一个 Rust 函数 `fn max_missiles_intercepted(heights: &[i32]) -> i32` 来解决以下问题：\n计算系统可以拦截的导弹的最大数量，给定它们被检测到的高度顺序。\n拦截系统可以拦截第一个导弹的任何高度，但随后的拦截必须在小于或等于上一次拦截的高度。\n\n参数：\n- heights: 一个整数切片，表示来袭导弹的高度。\n\n返回：\n- 一个整数，表示可以拦截的导弹的最大数量。\n\n示例：\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 返回 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) 返回 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) 返回 1",
      "fr": "Écrire une fonction Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` pour résoudre le problème suivant :\nCalcule le nombre maximum de missiles qui peuvent être interceptés par le système, étant donné leurs hauteurs dans l'ordre où ils sont détectés.\n  Le système d'interception peut intercepter n'importe quelle hauteur pour le premier missile, mais les interceptions suivantes doivent être à des hauteurs inférieures ou égales à l'interception précédente.\n\n  Arguments :\n  - heights: Une tranche d'entiers représentant les hauteurs des missiles entrants.\n\n  Renvoie :\n  - Un entier représentant le nombre maximum de missiles qui peuvent être interceptés.\n\n  Exemple :\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) renvoie 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) renvoie 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) renvoie 1",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_missiles_intercepted(heights: &[i32]) -> i32`, um das folgende Problem zu lösen:\nBerechnet die maximale Anzahl von Raketen, die vom System abgefangen werden können, basierend auf ihren Höhen in der Reihenfolge, in der sie erkannt werden.\n  Das Abfangsystem kann jede Höhe für die erste Rakete abfangen, aber nachfolgende Abfangvorgänge müssen in Höhen erfolgen, die kleiner oder gleich der vorherigen Abfanghöhe sind.\n\n  Argumente:\n  - heights: Ein Slice von ganzen Zahlen, das die Höhen der ankommenden Raketen darstellt.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die maximale Anzahl von Raketen darstellt, die abgefangen werden können.\n\n  Beispiel:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) gibt 5 zurück\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) gibt 5 zurück\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) gibt 1 zurück",
      "ha": "Rubuta aikin Rust `fn max_missiles_intercepted(heights: &[i32]) -> i32` don warware matsalar mai zuwa:\nYana ƙididdige yawan makamai masu linzami mafi girma da tsarin zai iya tarewa, la'akari da tsayinsu a cikin tsari da aka gano su.\n  Tsarin interception na iya tare kowane tsayi don makami na farko, amma tareda na gaba dole ne su kasance a tsayi daidai ko ƙasa da na interception na baya.\n\n  Huɗɗa:\n  - heights: Wani yanki na lambobi masu nuna tsayin makamai masu linzami masu zuwa.\n\n  Dawowa:\n  - Wani lamba mai nuna yawan makamai masu linzami mafi girma da za a iya tarewa.\n\n  Misali:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "hi": "Rust फ़ंक्शन `fn max_missiles_intercepted(heights: &[i32]) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह प्रणाली द्वारा अवरोधित किए जा सकने वाले मिसाइलों की अधिकतम संख्या की गणना करता है, जब उनकी ऊँचाई उस क्रम में दी जाती है जिसमें वे पता लगाए जाते हैं।\n  अवरोधन प्रणाली पहले मिसाइल के लिए किसी भी ऊँचाई को अवरोधित कर सकती है, लेकिन बाद के अवरोधन पिछले अवरोधन की ऊँचाई से कम या बराबर ऊँचाई पर ही होने चाहिए।\n\n  तर्क:\n  - heights: आने वाले मिसाइलों की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\n  लौटाता है:\n  - एक पूर्णांक जो अवरोधित किए जा सकने वाले मिसाइलों की अधिकतम संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 लौटाता है\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 लौटाता है\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn max_missiles_intercepted(heights: &[i32]) -> i32` a következő probléma megoldására:\nKiszámítja a maximális számú rakétát, amelyet a rendszer képes elfogni, figyelembe véve azok magasságát az észlelés sorrendjében.\n  Az elfogórendszer az első rakétánál bármilyen magasságot elfoghat, de a következő elfogásoknak a korábbi elfogás magasságánál kisebb vagy azzal egyenlő magasságokon kell történniük.\n\n  Argumentumok:\n  - heights: Egész számokat tartalmazó szelet, amely a bejövő rakéták magasságát reprezentálja.\n\n  Visszatérési érték:\n  - Egy egész szám, amely a maximálisan elfogható rakéták számát reprezentálja.\n\n  Példa:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) visszatér 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) visszatér 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) visszatér 1"
    },
    "instruction_bertscore": {
      "sq": "0.9984532652228814",
      "hy": "0.9560466720238379",
      "bn": "0.9666686302800596",
      "bg": "0.9961988103981353",
      "zh": "0.9611522673379587",
      "fr": "0.9984532652228814",
      "de": "0.9773672598633607",
      "ha": "0.9736590292798204",
      "hi": "0.9871084910100737",
      "hu": "0.9793875294688665"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]), 5);\n        assert_eq!(max_missiles_intercepted(&[500, 400, 300, 200, 100]), 5);\n        assert_eq!(max_missiles_intercepted(&[100, 200, 300, 400, 500]), 1);\n    }\n    \n\n}",
    "entry_point": "max_missiles_intercepted",
    "signature": "fn max_missiles_intercepted(heights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "sq": "Llogarit numrin maksimal të raketave që mund të kapen nga sistemi, duke pasur parasysh lartësitë e tyre në rendin që ato zbulohen. Sistemi i kapjes mund të kapë çdo lartësi për raketën e parë, por kapjet pasuese duhet të jenë në lartësi më të vogla ose të barabarta me kapjen e mëparshme.\n\nArgumentet:\n- heights: Një segment i numrave të plotë që përfaqëson lartësitë e raketave hyrëse.\n\nKthen:\n- Një numër i plotë që përfaqëson numrin maksimal të raketave që mund të kapen.\n\nShembull:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) kthen 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) kthen 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) kthen 1",
      "hy": "Հաշվարկում է առավելագույն հրթիռների քանակը, որոնք կարող են որսալ համակարգը՝ հաշվի առնելով դրանց բարձրությունները հայտնաբերման կարգով:\n  Որսման համակարգը կարող է որսալ ցանկացած բարձրություն առաջին հրթիռի համար, բայց հաջորդ որսումները պետք է լինեն նախորդ որսումից փոքր կամ հավասար բարձրություններում:\n\n  Արհգումենտներ:\n  - heights: Մուտքային հրթիռների բարձրությունները ներկայացնող ամբողջ թվերի շերտ:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է առավելագույն հրթիռների քանակը, որոնք կարող են որսալ:\n\n  Օրինակ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) վերադարձնում է 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) վերադարձնում է 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) վերադարձնում է 1",
      "bn": "মিসাইলগুলির উচ্চতা তাদের সনাক্তকরণের ক্রমে দেওয়া হলে, সিস্টেম দ্বারা আটকানো যেতে পারে এমন সর্বাধিক মিসাইলের সংখ্যা গণনা করে।\n  প্রতিরক্ষা ব্যবস্থা প্রথম মিসাইলের জন্য যেকোনো উচ্চতা আটকাতে পারে, কিন্তু পরবর্তী আটকগুলি অবশ্যই পূর্ববর্তী আটকানোর উচ্চতার সমান বা তার চেয়ে কম উচ্চতায় হতে হবে।\n\n  আর্গুমেন্টস:\n  - heights: আসন্ন মিসাইলগুলির উচ্চতাগুলির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা আটকানো যেতে পারে এমন সর্বাধিক মিসাইলের সংখ্যা প্রতিনিধিত্ব করে।\n\n  উদাহরণ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 রিটার্ন করে\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 রিটার্ন করে\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 রিটার্ন করে",
      "bg": "Изчислява максималния брой ракети, които могат да бъдат прихванати от системата, предвид техните височини в реда, в който са засечени. Системата за прихващане може да прихване всяка височина за първата ракета, но следващите прихващания трябва да бъдат на височини, по-малки или равни на предишното прихващане.\n\nАргументи:\n- heights: Списък от цели числа, представляващи височините на пристигащите ракети.\n\nВръща:\n- Цяло число, представляващо максималния брой ракети, които могат да бъдат прихванати.\n\nПример:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) връща 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) връща 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) връща 1",
      "zh": "计算系统可以拦截的导弹最大数量，给定导弹按检测顺序的高度。拦截系统可以拦截第一个导弹的任何高度，但后续的拦截必须在小于或等于上一次拦截的高度。\n\n参数：\n- heights: 一个整数切片，表示来袭导弹的高度。\n\n返回：\n- 一个整数，表示可以拦截的导弹最大数量。\n\n示例：\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 返回 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) 返回 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) 返回 1",
      "fr": "Calcule le nombre maximum de missiles qui peuvent être interceptés par le système, étant donné leurs hauteurs dans l'ordre où ils sont détectés.  \nLe système d'interception peut intercepter n'importe quelle hauteur pour le premier missile, mais les interceptions suivantes doivent être à des hauteurs inférieures ou égales à l'interception précédente.\n\nArguments:\n- heights: Une tranche d'entiers représentant les hauteurs des missiles entrants.\n\nRetours:\n- Un entier représentant le nombre maximum de missiles qui peuvent être interceptés.\n\nExemple:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) retourne 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) retourne 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) retourne 1",
      "de": "Berechnet die maximale Anzahl von Raketen, die vom System abgefangen werden können, basierend auf deren Höhen in der Reihenfolge, in der sie erkannt werden.\n  Das Abfangsystem kann für die erste Rakete jede Höhe abfangen, aber nachfolgende Abfangvorgänge müssen in Höhen erfolgen, die kleiner oder gleich der vorherigen Abfanghöhe sind.\n\n  Argumente:\n  - heights: Ein Slice von ganzen Zahlen, das die Höhen der ankommenden Raketen darstellt.\n\n  Rückgabewerte:\n  - Eine ganze Zahl, die die maximale Anzahl von Raketen darstellt, die abgefangen werden können.\n\n  Beispiel:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) gibt 5 zurück\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) gibt 5 zurück\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) gibt 1 zurück",
      "ha": "Lissafa yawan makamai masu linzami mafi girma da tsarin zai iya tarewa, la'akari da tsayinsu a cikin tsari da aka gano su.\n  Tsarin kakkabo makamai na iya kakkabo kowanne tsawo don makami na farko, amma kakkabo na gaba dole ne ya kasance a tsawo daidai ko ƙasa da kakkabo na baya.\n\n  Arguments:\n  - heights: Wani yanki na lambobi masu ɗauke da tsayin makaman da ke shigowa.\n\n  Returns:\n  - Wani lamba mai ɗauke da yawan makaman da za a iya kakkabo.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "hi": "मिसाइलों की अधिकतम संख्या की गणना करता है जिन्हें सिस्टम द्वारा अवरोधित किया जा सकता है, उनके ऊँचाई के क्रम में जब वे पता लगाए जाते हैं। अवरोधन प्रणाली पहले मिसाइल के लिए किसी भी ऊँचाई को अवरोधित कर सकती है, लेकिन बाद के अवरोधन पिछले अवरोधन के बराबर या उससे कम ऊँचाई पर ही होने चाहिए।\n\nआर्गुमेंट्स:\n- heights: आने वाली मिसाइलों की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\nरिटर्न्स:\n- एक पूर्णांक जो अवरोधित की जा सकने वाली मिसाइलों की अधिकतम संख्या का प्रतिनिधित्व करता है।\n\nउदाहरण:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 लौटाता है\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 लौटाता है\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 लौटाता है",
      "hu": "Kiszámítja a rendszer által elfogható rakéták maximális számát, figyelembe véve azok magasságát az észlelésük sorrendjében. Az elfogórendszer az első rakétát bármilyen magasságban elfoghatja, de a további elfogásoknak az előző elfogás magasságánál kisebb vagy azzal egyenlő magasságban kell történniük.\n\n  Argumentumok:\n  - heights: Egész számok szelete, amely a bejövő rakéták magasságát jelenti.\n\n  Visszatérési érték:\n  - Egy egész szám, amely az elfogható rakéták maximális számát jelenti.\n\n  Példa:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) visszatér 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) visszatér 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) visszatér 1"
    },
    "docstring_bertscore": {
      "sq": "0.9778576782741358",
      "hy": "0.9735581250462546",
      "bn": "0.9535063880807827",
      "bg": "0.9747149483854018",
      "zh": "0.9703993060966568",
      "fr": "0.9981304908536996",
      "de": "0.9646394223074072",
      "ha": "0.9751292913602406",
      "hi": "0.9808772573266282",
      "hu": "0.9750776474611715"
    }
  },
  {
    "task_id": "Rust/36",
    "prompt": {
      "en": "/*\n  Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "sq": "/*\n  Llogarit numrin e rrugëve që një ushtar mund të ndjekë për të lëvizur nga origjina (0, 0) në një pikë të dhënë (n, m) në një tabelë shahu,\n  duke shmangur pikat e kontrollit të një kali të palëvizshëm të vendosur në (horse_x, horse_y).\n\n  Ushtari mund të lëvizë vetëm ose një hap djathtas ose një hap poshtë në një kohë. Pikat e kontrollit të kalit përfshijnë pozicionin e tij aktual\n  dhe të gjitha pikat që ai mund të arrijë me një lëvizje. Ushtari duhet të shmangë këto pika kontrolli.\n\n  Argumentet:\n  - n: koordinata x e pikës së destinacionit, një numër i plotë që nuk e kalon 15.\n  - m: koordinata y e pikës së destinacionit, një numër i plotë që nuk e kalon 15.\n  - horse_x: koordinata x e pozicionit të kalit, një numër i plotë.\n  - horse_y: koordinata y e pozicionit të kalit, një numër i plotë.\n\n  Kthen:\n  - Numri total i rrugëve të vlefshme nga (0, 0) në (n, m) duke shmangur pikat e kontrollit të kalit.\n\n  Shembuj:\n  - count_paths(6, 6, 3, 3) kthen 6\n  - count_paths(5, 5, 1, 1) kthen 12\n  - count_paths(7, 7, 2, 2) kthen 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
      "hy": "/*\n  Հաշվում է ճանապարհների քանակը, որով զինվորը կարող է շարժվել սկզբնակետից (0, 0) մինչև տրված կետը (n, m) շախմատի տախտակի վրա՝\n  խուսափելով անշարժ ձիու վերահսկման կետերից, որը գտնվում է (horse_x, horse_y) կետում:\n\n  Զինվորը կարող է շարժվել միայն մեկ քայլ աջ կամ մեկ քայլ ներքև յուրաքանչյուր անգամ: Ձիու վերահսկման կետերը ներառում են նրա \n  ընթացիկ դիրքը և բոլոր այն կետերը, որոնց նա կարող է հասնել մեկ քայլով: Զինվորը պետք է խուսափի այս վերահսկման կետերից:\n\n  Փաստարկներ:\n  - n: նպատակակետի x-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n  - m: նպատակակետի y-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n  - horse_x: ձիու դիրքի x-կոորդինատը, ամբողջ թիվ:\n  - horse_y: ձիու դիրքի y-կոորդինատը, ամբողջ թիվ:\n\n  Վերադարձնում է:\n  - Ընդհանուր վավեր ճանապարհների քանակը (0, 0) կետից մինչև (n, m) կետը, խուսափելով ձիու վերահսկման կետերից:\n\n  Օրինակներ:\n  - count_paths(6, 6, 3, 3) վերադարձնում է 6\n  - count_paths(5, 5, 1, 1) վերադարձնում է 12\n  - count_paths(7, 7, 2, 2) վերադարձնում է 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
      "bn": "/*\n  একটি দাবার বোর্ডে (0, 0) থেকে একটি নির্দিষ্ট বিন্দু (n, m) পর্যন্ত একটি পানের যাওয়ার পথের সংখ্যা গণনা করে,\n  একটি স্থির ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে যা (horse_x, horse_y) এ অবস্থিত।\n\n  পান শুধুমাত্র এক ধাপ ডানে বা এক ধাপ নিচে যেতে পারে। ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি তার বর্তমান অবস্থান এবং \n  সমস্ত বিন্দু অন্তর্ভুক্ত করে যা এটি এক ধাপে পৌঁছাতে পারে। পানকে এই নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে যেতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - n: গন্তব্য বিন্দুর x-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - m: গন্তব্য বিন্দুর y-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - horse_x: ঘোড়ার অবস্থানের x-সমন্বয়, একটি পূর্ণসংখ্যা।\n  - horse_y: ঘোড়ার অবস্থানের y-সমন্বয়, একটি পূর্ণসংখ্যা।\n\n  রিটার্ন করে:\n  - (0, 0) থেকে (n, m) পর্যন্ত ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে বৈধ পথের মোট সংখ্যা।\n\n  উদাহরণসমূহ:\n  - count_paths(6, 6, 3, 3) 6 রিটার্ন করে\n  - count_paths(5, 5, 1, 1) 12 রিটার্ন করে\n  - count_paths(7, 7, 2, 2) 28 রিটার্ন করে\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "bg": "/*\n  Изчислява броя на пътищата, по които пешка може да се движи от началната точка (0, 0) до дадена точка (n, m) на шахматна дъска,\n  избягвайки контролните точки на неподвижен кон, разположен на (horse_x, horse_y).\n\n  Пешката може да се движи само с една стъпка надясно или с една стъпка надолу наведнъж. Контролните точки на коня включват неговата \n  текуща позиция и всички точки, до които може да достигне с едно движение. Пешката трябва да избягва тези контролни точки.\n\n  Аргументи:\n  - n: x-координата на крайната точка, цяло число, което не надвишава 15.\n  - m: y-координата на крайната точка, цяло число, което не надвишава 15.\n  - horse_x: x-координата на позицията на коня, цяло число.\n  - horse_y: y-координата на позицията на коня, цяло число.\n\n  Връща:\n  - Общият брой на валидните пътища от (0, 0) до (n, m), избягвайки контролните точки на коня.\n\n  Примери:\n  - count_paths(6, 6, 3, 3) връща 6\n  - count_paths(5, 5, 1, 1) връща 12\n  - count_paths(7, 7, 2, 2) връща 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "zh": "/*\n  计算一个棋子从原点 (0, 0) 移动到棋盘上给定点 (n, m) 的路径数量，\n  避开位于 (horse_x, horse_y) 的静止马的控制点。\n\n  棋子每次只能向右移动一步或向下移动一步。马的控制点包括其当前位置和它可以一步到达的所有点。棋子必须避开这些控制点。\n\n  参数:\n  - n: 目的地的 x 坐标，一个不超过 15 的整数。\n  - m: 目的地的 y 坐标，一个不超过 15 的整数。\n  - horse_x: 马的位置的 x 坐标，一个整数。\n  - horse_y: 马的位置的 y 坐标，一个整数。\n\n  返回:\n  - 从 (0, 0) 到 (n, m) 避开马的控制点的有效路径总数。\n\n  示例:\n  - count_paths(6, 6, 3, 3) 返回 6\n  - count_paths(5, 5, 1, 1) 返回 12\n  - count_paths(7, 7, 2, 2) 返回 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "fr": "/*\n  Calcule le nombre de chemins qu'un pion peut emprunter pour se déplacer de l'origine (0, 0) à un point donné (n, m) sur un échiquier,\n  en évitant les points de contrôle d'un cheval stationnaire situé à (horse_x, horse_y).\n\n  Le pion ne peut se déplacer que d'un pas vers la droite ou d'un pas vers le bas à la fois. Les points de contrôle du cheval incluent sa \n  position actuelle et tous les points qu'il peut atteindre en un mouvement. Le pion doit éviter ces points de contrôle.\n\n  Arguments :\n  - n : coordonnée x du point de destination, un entier ne dépassant pas 15.\n  - m : coordonnée y du point de destination, un entier ne dépassant pas 15.\n  - horse_x : coordonnée x de la position du cheval, un entier.\n  - horse_y : coordonnée y de la position du cheval, un entier.\n\n  Renvoie :\n  - Le nombre total de chemins valides de (0, 0) à (n, m) en évitant les points de contrôle du cheval.\n\n  Exemples :\n  - count_paths(6, 6, 3, 3) renvoie 6\n  - count_paths(5, 5, 1, 1) renvoie 12\n  - count_paths(7, 7, 2, 2) renvoie 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "de": "/*\n  Berechnet die Anzahl der Wege, die ein Bauer nehmen kann, um sich vom Ursprung (0, 0) zu einem gegebenen Punkt (n, m) auf einem Schachbrett zu bewegen,\n  wobei die Kontrollpunkte eines stationären Pferdes, das sich an der Position (horse_x, horse_y) befindet, vermieden werden.\n\n  Der Bauer kann sich nur entweder einen Schritt nach rechts oder einen Schritt nach unten bewegen. Die Kontrollpunkte des Pferdes umfassen seine \n  aktuelle Position und alle Punkte, die es in einem Zug erreichen kann. Der Bauer muss diese Kontrollpunkte vermeiden.\n\n  Argumente:\n  - n: x-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n  - m: y-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n  - horse_x: x-Koordinate der Position des Pferdes, eine ganze Zahl.\n  - horse_y: y-Koordinate der Position des Pferdes, eine ganze Zahl.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der gültigen Wege von (0, 0) nach (n, m), die die Kontrollpunkte des Pferdes vermeiden.\n\n  Beispiele:\n  - count_paths(6, 6, 3, 3) gibt 6 zurück\n  - count_paths(5, 5, 1, 1) gibt 12 zurück\n  - count_paths(7, 7, 2, 2) gibt 28 zurück\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "ha": "/*\n  Lissafi yawan hanyoyi da pawn zai iya bi don motsawa daga asali (0, 0) zuwa wani wuri (n, m) a kan allon catur, \n  yana guje wa wuraren iko na doki mai tsayawa a wuri guda wanda ke a (horse_x, horse_y).\n\n  Pawn zai iya motsawa ne kawai ko dai mataki daya zuwa dama ko mataki daya zuwa kasa a lokaci guda. Wuraren iko na doki \n  sun hada da matsayinsa na yanzu da duk wuraren da zai iya kaiwa cikin motsi daya. Pawn dole ne ya guji wadannan wuraren iko.\n\n  Hujojji:\n  - n: x-kwatance na wurin da ake nufi, cikakken lamba wanda ba zai wuce 15 ba.\n  - m: y-kwatance na wurin da ake nufi, cikakken lamba wanda ba zai wuce 15 ba.\n  - horse_x: x-kwatance na wurin doki, cikakken lamba.\n  - horse_y: y-kwatance na wurin doki, cikakken lamba.\n\n  Mayarwa:\n  - Jimillar yawan hanyoyi masu inganci daga (0, 0) zuwa (n, m) yana guje wa wuraren iko na doki.\n\n  Misalai:\n  - count_paths(6, 6, 3, 3) yana mayar da 6\n  - count_paths(5, 5, 1, 1) yana mayar da 12\n  - count_paths(7, 7, 2, 2) yana mayar da 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "hi": "/*\n  गणना करता है कि एक प्यादा कितने रास्ते ले सकता है ताकि वह उत्पत्ति (0, 0) से एक दिए गए बिंदु (n, m) तक शतरंज की बिसात पर जा सके,\n  एक स्थिर घोड़े के नियंत्रण बिंदुओं से बचते हुए जो (horse_x, horse_y) पर स्थित है।\n\n  प्यादा केवल एक बार में या तो एक कदम दाईं ओर या एक कदम नीचे की ओर ही बढ़ सकता है। घोड़े के नियंत्रण बिंदुओं में उसकी \n  वर्तमान स्थिति और सभी बिंदु शामिल हैं जहां वह एक चाल में पहुंच सकता है। प्यादे को इन नियंत्रण बिंदुओं से बचना होगा।\n\n  तर्क:\n  - n: गंतव्य बिंदु का x-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - m: गंतव्य बिंदु का y-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - horse_x: घोड़े की स्थिति का x-निर्देशांक, एक पूर्णांक।\n  - horse_y: घोड़े की स्थिति का y-निर्देशांक, एक पूर्णांक।\n\n  लौटाता है:\n  - (0, 0) से (n, m) तक घोड़े के नियंत्रण बिंदुओं से बचते हुए कुल वैध रास्तों की संख्या।\n\n  उदाहरण:\n  - count_paths(6, 6, 3, 3) 6 लौटाता है\n  - count_paths(5, 5, 1, 1) 12 लौटाता है\n  - count_paths(7, 7, 2, 2) 28 लौटाता है\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "hu": "/*\n  Kiszámítja, hogy hány útvonalon tud egy gyalog eljutni az origóból (0, 0) egy adott pontba (n, m) egy sakktáblán,\n  elkerülve egy helyhez kötött ló kontrollpontjait, amely a (horse_x, horse_y) helyen található.\n\n  A gyalog csak egy lépést tud tenni jobbra vagy egy lépést lefelé egyszerre. A ló kontrollpontjai közé tartozik a \n  jelenlegi pozíciója és minden pont, amit egy lépéssel elérhet. A gyalognak el kell kerülnie ezeket a kontrollpontokat.\n\n  Argumentumok:\n  - n: a célpont x-koordinátája, egy legfeljebb 15-ös egész szám.\n  - m: a célpont y-koordinátája, egy legfeljebb 15-ös egész szám.\n  - horse_x: a ló pozíciójának x-koordinátája, egy egész szám.\n  - horse_y: a ló pozíciójának y-koordinátája, egy egész szám.\n\n  Visszatér:\n  - Az érvényes útvonalak teljes száma (0, 0)-tól (n, m)-ig, elkerülve a ló kontrollpontjait.\n\n  Példák:\n  - count_paths(6, 6, 3, 3) visszatér 6\n  - count_paths(5, 5, 1, 1) visszatér 12\n  - count_paths(7, 7, 2, 2) visszatér 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.977055807425898",
      "hy": "0.9472934283923924",
      "bn": "0.9585323326121085",
      "bg": "0.9622775084465213",
      "zh": "0.9567835907374773",
      "fr": "0.98293705437796",
      "de": "0.9611355823859518",
      "ha": "0.9662503146976",
      "hi": "0.9640723325695525",
      "hu": "0.9560639528669879"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` to solve the following problem:\nCalculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "sq": "Shkruani një funksion në Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e rrugëve që një ushtar mund të ndjekë për t'u zhvendosur nga origjina (0, 0) në një pikë të caktuar (n, m) në një tabelë shahu,\nduke shmangur pikat e kontrollit të një kali të palëvizshëm të vendosur në (horse_x, horse_y).\n\nUshtari mund të lëvizë vetëm ose një hap djathtas ose një hap poshtë në një kohë. Pikat e kontrollit të kalit përfshijnë pozicionin e tij aktual dhe të gjitha pikat që ai mund të arrijë me një lëvizje. Ushtari duhet të shmangë këto pika kontrolli.\n\nArgumentet:\n- n: koordinata x e pikës së destinacionit, një numër i plotë që nuk i kalon 15.\n- m: koordinata y e pikës së destinacionit, një numër i plotë që nuk i kalon 15.\n- horse_x: koordinata x e pozicionit të kalit, një numër i plotë.\n- horse_y: koordinata y e pozicionit të kalit, një numër i plotë.\n\nKthen:\n- Numri total i rrugëve të vlefshme nga (0, 0) në (n, m) duke shmangur pikat e kontrollit të kalit.\n\nShembuj:\n- count_paths(6, 6, 3, 3) kthen 6\n- count_paths(5, 5, 1, 1) kthen 12\n- count_paths(7, 7, 2, 2) kthen 28",
      "hy": "Գրեք Rust ֆունկցիա `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն ուղիների քանակը, որոնցով զինվորը կարող է շարժվել սկզբնակետից (0, 0) մինչև տրված կետը (n, m) շախմատի տախտակի վրա՝ խուսափելով անշարժ ձիու վերահսկման կետերից, որը գտնվում է (horse_x, horse_y) կետում:\n\nԶինվորը կարող է շարժվել միայն մեկ քայլ աջ կամ մեկ քայլ ներքև ամեն անգամ: Ձիու վերահսկման կետերը ներառում են նրա ներկայիս դիրքը և բոլոր այն կետերը, որոնց նա կարող է հասնել մեկ քայլով: Զինվորը պետք է խուսափի այս վերահսկման կետերից:\n\nԱրգումենտներ:\n- n: նպատակակետի x-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n- m: նպատակակետի y-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n- horse_x: ձիու դիրքի x-կոորդինատը, ամբողջ թիվ:\n- horse_y: ձիու դիրքի y-կոորդինատը, ամբողջ թիվ:\n\nՎերադարձնում է:\n- Ընդհանուր վավեր ուղիների քանակը (0, 0) կետից (n, m) կետը՝ խուսափելով ձիու վերահսկման կետերից:\n\nՕրինակներ:\n- count_paths(6, 6, 3, 3) վերադարձնում է 6\n- count_paths(5, 5, 1, 1) վերադարձնում է 12\n- count_paths(7, 7, 2, 2) վերադարձնում է 28",
      "bn": "Rust ফাংশন `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি দাবার গুটির সংখ্যা নির্ণয় করে কতটি পথ আছে যা এটি (0, 0) থেকে একটি নির্দিষ্ট বিন্দুতে (n, m) যেতে পারে দাবার বোর্ডে,\nএকটি স্থির ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে চলা অবস্থায় যা (horse_x, horse_y) তে অবস্থিত।\n\n  গুটি শুধুমাত্র এক ধাপ ডানে বা এক ধাপ নিচে সরতে পারে একবারে। ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলির মধ্যে রয়েছে তার \n  বর্তমান অবস্থান এবং সমস্ত বিন্দু যা এটি এক ধাপে পৌঁছাতে পারে। গুটিকে এই নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে চলতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - n: গন্তব্য বিন্দুর x-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করবে না।\n  - m: গন্তব্য বিন্দুর y-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করবে না।\n  - horse_x: ঘোড়ার অবস্থানের x-সমন্বয়, একটি পূর্ণসংখ্যা।\n  - horse_y: ঘোড়ার অবস্থানের y-সমন্বয়, একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - মোট বৈধ পথের সংখ্যা (0, 0) থেকে (n, m) পর্যন্ত যা ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে চলে।\n\n  উদাহরণসমূহ:\n  - count_paths(6, 6, 3, 3) রিটার্ন করে 6\n  - count_paths(5, 5, 1, 1) রিটার্ন করে 12\n  - count_paths(7, 7, 2, 2) রিটার্ন করে 28",
      "bg": "Напишете функция на Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize`, за да решите следния проблем:\nИзчислява броя на пътищата, по които пешка може да се движи от началната точка (0, 0) до дадена точка (n, m) на шахматна дъска,\n  избягвайки контролните точки на неподвижен кон, разположен на (horse_x, horse_y).\n\n  Пешката може да се движи само с една стъпка надясно или с една стъпка надолу наведнъж. Контролните точки на коня включват неговата \n  текуща позиция и всички точки, до които може да достигне с едно движение. Пешката трябва да избягва тези контролни точки.\n\n  Аргументи:\n  - n: x-координата на крайната точка, цяло число, което не надвишава 15.\n  - m: y-координата на крайната точка, цяло число, което не надвишава 15.\n  - horse_x: x-координата на позицията на коня, цяло число.\n  - horse_y: y-координата на позицията на коня, цяло число.\n\n  Връща:\n  - Общият брой на валидните пътища от (0, 0) до (n, m), избягвайки контролните точки на коня.\n\n  Примери:\n  - count_paths(6, 6, 3, 3) връща 6\n  - count_paths(5, 5, 1, 1) връща 12\n  - count_paths(7, 7, 2, 2) връща 28",
      "zh": "编写一个 Rust 函数 `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` 来解决以下问题：\n计算一个兵从原点 (0, 0) 移动到棋盘上给定点 (n, m) 的路径数量，避开位于 (horse_x, horse_y) 的静止马的控制点。\n\n兵每次只能向右移动一步或向下移动一步。马的控制点包括其当前位置及其一步之内可以到达的所有点。兵必须避开这些控制点。\n\n参数：\n- n: 目的地的 x 坐标，一个不超过 15 的整数。\n- m: 目的地的 y 坐标，一个不超过 15 的整数。\n- horse_x: 马的位置的 x 坐标，一个整数。\n- horse_y: 马的位置的 y 坐标，一个整数。\n\n返回：\n- 从 (0, 0) 到 (n, m) 避开马的控制点的有效路径总数。\n\n示例：\n- count_paths(6, 6, 3, 3) 返回 6\n- count_paths(5, 5, 1, 1) 返回 12\n- count_paths(7, 7, 2, 2) 返回 28",
      "fr": "Écrire une fonction Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` pour résoudre le problème suivant :\nCalcule le nombre de chemins qu'un pion peut emprunter pour se déplacer de l'origine (0, 0) à un point donné (n, m) sur un échiquier,\nen évitant les points de contrôle d'un cheval stationnaire situé à (horse_x, horse_y).\n\nLe pion ne peut se déplacer qu'un pas à la fois soit vers la droite, soit vers le bas. Les points de contrôle du cheval incluent sa position actuelle et tous les points qu'il peut atteindre en un mouvement. Le pion doit éviter ces points de contrôle.\n\nArguments :\n- n : coordonnée x du point de destination, un entier ne dépassant pas 15.\n- m : coordonnée y du point de destination, un entier ne dépassant pas 15.\n- horse_x : coordonnée x de la position du cheval, un entier.\n- horse_y : coordonnée y de la position du cheval, un entier.\n\nRenvoie :\n- Le nombre total de chemins valides de (0, 0) à (n, m) évitant les points de contrôle du cheval.\n\nExemples :\n- count_paths(6, 6, 3, 3) renvoie 6\n- count_paths(5, 5, 1, 1) renvoie 12\n- count_paths(7, 7, 2, 2) renvoie 28",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Pfade, die ein Bauer nehmen kann, um von der Herkunft (0, 0) zu einem gegebenen Punkt (n, m) auf einem Schachbrett zu ziehen,\n  wobei die Kontrollpunkte eines stationären Pferdes vermieden werden, das sich an (horse_x, horse_y) befindet.\n\n  Der Bauer kann sich nur entweder einen Schritt nach rechts oder einen Schritt nach unten bewegen. Die Kontrollpunkte des Pferdes umfassen seine \n  aktuelle Position und alle Punkte, die es in einem Zug erreichen kann. Der Bauer muss diese Kontrollpunkte vermeiden.\n\n  Argumente:\n  - n: x-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n  - m: y-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n  - horse_x: x-Koordinate der Position des Pferdes, eine ganze Zahl.\n  - horse_y: y-Koordinate der Position des Pferdes, eine ganze Zahl.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der gültigen Pfade von (0, 0) nach (n, m), die die Kontrollpunkte des Pferdes vermeiden.\n\n  Beispiele:\n  - count_paths(6, 6, 3, 3) gibt 6 zurück\n  - count_paths(5, 5, 1, 1) gibt 12 zurück\n  - count_paths(7, 7, 2, 2) gibt 28 zurück",
      "ha": "Rubuta aikin Rust `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` don warware matsalar mai zuwa:\nYana ƙididdige yawan hanyoyin da pawn zai iya ɗauka don motsawa daga asali (0, 0) zuwa wani wuri (n, m) akan allon catur,\n  yana guje wa wuraren iko na doki mai tsayawa wanda yake a (horse_x, horse_y).\n\n  Pawn zai iya motsawa ne kawai ko dai mataki ɗaya zuwa dama ko mataki ɗaya ƙasa a lokaci guda. Wuraren iko na doki sun haɗa da\n  wurin da yake yanzu da duk wuraren da zai iya kaiwa a motsi guda. Pawn dole ne ya guji waɗannan wuraren iko.\n\n  Huɗɗa:\n  - n: x-ƙoordinate na wurin da ake nufi, cikakken lamba wanda bai wuce 15 ba.\n  - m: y-ƙoordinate na wurin da ake nufi, cikakken lamba wanda bai wuce 15 ba.\n  - horse_x: x-ƙoordinate na wurin doki, cikakken lamba.\n  - horse_y: y-ƙoordinate na wurin doki, cikakken lamba.\n\n  Ya dawo:\n  - Jimlar yawan hanyoyin da suka dace daga (0, 0) zuwa (n, m) yana guje wa wuraren iko na doki.\n\n  Misalai:\n  - count_paths(6, 6, 3, 3) yana dawowa 6\n  - count_paths(5, 5, 1, 1) yana dawowa 12\n  - count_paths(7, 7, 2, 2) yana dawowa 28",
      "hi": "Rust फ़ंक्शन `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगणना करता है कि एक प्यादा कितने रास्ते ले सकता है ताकि वह एक शतरंज की बिसात पर मूल बिंदु (0, 0) से एक दिए गए बिंदु (n, m) तक जा सके,\nएक स्थिर घोड़े के नियंत्रण बिंदुओं से बचते हुए जो (horse_x, horse_y) पर स्थित है।\n\nप्यादा केवल एक बार में या तो एक कदम दाईं ओर या एक कदम नीचे की ओर बढ़ सकता है। घोड़े के नियंत्रण बिंदुओं में उसकी \nवर्तमान स्थिति और सभी बिंदु शामिल होते हैं जहां वह एक चाल में पहुंच सकता है। प्यादे को इन नियंत्रण बिंदुओं से बचना चाहिए।\n\nतर्क:\n- n: गंतव्य बिंदु का x-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n- m: गंतव्य बिंदु का y-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n- horse_x: घोड़े की स्थिति का x-निर्देशांक, एक पूर्णांक।\n- horse_y: घोड़े की स्थिति का y-निर्देशांक, एक पूर्णांक।\n\nवापसी:\n- (0, 0) से (n, m) तक घोड़े के नियंत्रण बिंदुओं से बचते हुए कुल मान्य रास्तों की संख्या।\n\nउदाहरण:\n- count_paths(6, 6, 3, 3) 6 लौटाता है\n- count_paths(5, 5, 1, 1) 12 लौटाता है\n- count_paths(7, 7, 2, 2) 28 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize` a következő probléma megoldására:\nKiszámítja, hogy hány útvonalon tud egy gyalog eljutni az origóból (0, 0) egy adott pontba (n, m) egy sakktáblán, elkerülve egy helyhez kötött ló kontrollpontjait, amely a (horse_x, horse_y) helyen található.\n\nA gyalog csak egy lépést tehet jobbra vagy egy lépést lefelé egyszerre. A ló kontrollpontjai közé tartozik a jelenlegi pozíciója és minden olyan pont, amelyet egy lépésben elérhet. A gyalognak el kell kerülnie ezeket a kontrollpontokat.\n\nArgumentumok:\n- n: a célpont x-koordinátája, egy egész szám, amely nem haladja meg a 15-öt.\n- m: a célpont y-koordinátája, egy egész szám, amely nem haladja meg a 15-öt.\n- horse_x: a ló pozíciójának x-koordinátája, egy egész szám.\n- horse_y: a ló pozíciójának y-koordinátája, egy egész szám.\n\nVisszatérési érték:\n- Az összes érvényes útvonal száma (0, 0) és (n, m) között, elkerülve a ló kontrollpontjait.\n\nPéldák:\n- count_paths(6, 6, 3, 3) visszaadja 6\n- count_paths(5, 5, 1, 1) visszaadja 12\n- count_paths(7, 7, 2, 2) visszaadja 28"
    },
    "instruction_bertscore": {
      "sq": "0.9711944235119395",
      "hy": "0.9463251052848474",
      "bn": "0.9572519611759576",
      "bg": "0.9660987597168704",
      "zh": "0.9659795814882495",
      "fr": "0.9792067758221248",
      "de": "0.9870679704123426",
      "ha": "0.9585287572652499",
      "hi": "0.9760914569259737",
      "hu": "0.9520571808207522"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_paths(6, 6, 3, 3), 6);\n        assert_eq!(count_paths(5, 5, 1, 1), 10);\n        assert_eq!(count_paths(7, 7, 2, 2), 0);\n    }\n    \n\n}",
    "entry_point": "count_paths",
    "signature": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
    "docstring": {
      "en": "Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "sq": "Llogarit numrin e rrugëve që një ushtar mund të marrë për të lëvizur nga origjina (0, 0) në një pikë të dhënë (n, m) në një tabelë shahu,\nduke shmangur pikat e kontrollit të një kali të palëvizshëm të vendosur në (horse_x, horse_y).\n\nUshtari mund të lëvizë vetëm një hap djathtas ose një hap poshtë në një kohë. Pikat e kontrollit të kalit përfshijnë pozicionin e tij aktual dhe të gjitha pikat që ai mund të arrijë me një lëvizje. Ushtari duhet të shmangë këto pika kontrolli.\n\nArgumentet:\n- n: koordinata x e pikës së destinacionit, një numër i plotë që nuk tejkalon 15.\n- m: koordinata y e pikës së destinacionit, një numër i plotë që nuk tejkalon 15.\n- horse_x: koordinata x e pozicionit të kalit, një numër i plotë.\n- horse_y: koordinata y e pozicionit të kalit, një numër i plotë.\n\nKthen:\n- Numri total i rrugëve të vlefshme nga (0, 0) në (n, m) duke shmangur pikat e kontrollit të kalit.\n\nShembuj:\n- count_paths(6, 6, 3, 3) kthen 6\n- count_paths(5, 5, 1, 1) kthen 12\n- count_paths(7, 7, 2, 2) kthen 28",
      "hy": "Հաշվում է ուղիների քանակը, որով զինվորը կարող է շարժվել սկզբնակետից (0, 0) մինչև տրված կետը (n, m) շախմատի տախտակի վրա՝ խուսափելով (horse_x, horse_y) տեղակայված անշարժ ձիու վերահսկման կետերից:\n\nԶինվորը կարող է շարժվել միայն մեկ քայլ աջ կամ մեկ քայլ ներքև: Ձիու վերահսկման կետերը ներառում են նրա ընթացիկ դիրքը և բոլոր այն կետերը, որոնք նա կարող է հասնել մեկ քայլով: Զինվորը պետք է խուսափի այս վերահսկման կետերից:\n\nԱրձանագրումներ:\n- n: նպատակակետի x-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n- m: նպատակակետի y-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n- horse_x: ձիու դիրքի x-կոորդինատը, ամբողջ թիվ:\n- horse_y: ձիու դիրքի y-կոորդինատը, ամբողջ թիվ:\n\nՎերադարձնում է:\n- Ընդհանուր վավեր ուղիների քանակը (0, 0) կետից (n, m) կետ՝ խուսափելով ձիու վերահսկման կետերից:\n\nՕրինակներ:\n- count_paths(6, 6, 3, 3) վերադարձնում է 6\n- count_paths(5, 5, 1, 1) վերադարձնում է 12\n- count_paths(7, 7, 2, 2) վերադարձնում է 28",
      "bn": "একটি দাবার গুটির কতগুলি পথ আছে তা গণনা করে যা মূল বিন্দু (0, 0) থেকে একটি নির্দিষ্ট বিন্দু (n, m) পর্যন্ত যেতে পারে, একটি স্থির ঘোড়ার নিয়ন্ত্রণ বিন্দু (horse_x, horse_y) এড়িয়ে।\n\n  গুটি কেবলমাত্র এক ধাপ ডানদিকে বা এক ধাপ নিচে যেতে পারে। ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এর বর্তমান অবস্থান এবং সমস্ত বিন্দু অন্তর্ভুক্ত করে যা এটি এক ধাপে পৌঁছাতে পারে। গুটিকে এই নিয়ন্ত্রণ বিন্দুগুলি এড়াতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - n: গন্তব্য বিন্দুর x-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - m: গন্তব্য বিন্দুর y-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - horse_x: ঘোড়ার অবস্থানের x-সমন্বয়, একটি পূর্ণসংখ্যা।\n  - horse_y: ঘোড়ার অবস্থানের y-সমন্বয়, একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - মোট বৈধ পথের সংখ্যা (0, 0) থেকে (n, m) পর্যন্ত, ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে।\n\n  উদাহরণ:\n  - count_paths(6, 6, 3, 3) 6 রিটার্ন করে\n  - count_paths(5, 5, 1, 1) 12 রিটার্ন করে\n  - count_paths(7, 7, 2, 2) 28 রিটার্ন করে",
      "bg": "Изчислява броя на пътищата, по които пешката може да се движи от началната точка (0, 0) до дадена точка (n, m) на шахматната дъска, като избягва контролните точки на неподвижен кон, разположен на (horse_x, horse_y).\n\nПешката може да се движи само с една стъпка надясно или с една стъпка надолу наведнъж. Контролните точки на коня включват неговата текуща позиция и всички точки, които може да достигне с едно движение. Пешката трябва да избягва тези контролни точки.\n\nАргументи:\n- n: x-координата на крайната точка, цяло число, което не надвишава 15.\n- m: y-координата на крайната точка, цяло число, което не надвишава 15.\n- horse_x: x-координата на позицията на коня, цяло число.\n- horse_y: y-координата на позицията на коня, цяло число.\n\nВръща:\n- Общият брой на валидните пътища от (0, 0) до (n, m), избягвайки контролните точки на коня.\n\nПримери:\n- count_paths(6, 6, 3, 3) връща 6\n- count_paths(5, 5, 1, 1) връща 12\n- count_paths(7, 7, 2, 2) връща 28",
      "zh": "计算一个兵从原点 (0, 0) 移动到棋盘上给定点 (n, m) 的路径数量，避开位于 (horse_x, horse_y) 的静止马的控制点。\n\n兵只能每次向右移动一步或向下移动一步。马的控制点包括其当前位置及其一步之内可以到达的所有点。兵必须避开这些控制点。\n\n参数:\n- n: 目的地点的 x 坐标，一个不超过 15 的整数。\n- m: 目的地点的 y 坐标，一个不超过 15 的整数。\n- horse_x: 马的位置的 x 坐标，一个整数。\n- horse_y: 马的位置的 y 坐标，一个整数。\n\n返回:\n- 从 (0, 0) 到 (n, m) 的所有有效路径的总数，避开马的控制点。\n\n示例:\n- count_paths(6, 6, 3, 3) 返回 6\n- count_paths(5, 5, 1, 1) 返回 12\n- count_paths(7, 7, 2, 2) 返回 28",
      "fr": "Calcule le nombre de chemins qu'un pion peut emprunter pour se déplacer de l'origine (0, 0) à un point donné (n, m) sur un échiquier, en évitant les points de contrôle d'un cheval stationnaire situé à (horse_x, horse_y).\n\nLe pion ne peut se déplacer qu'un pas à la fois vers la droite ou vers le bas. Les points de contrôle du cheval incluent sa position actuelle et tous les points qu'il peut atteindre en un mouvement. Le pion doit éviter ces points de contrôle.\n\nArguments:\n- n: coordonnée x du point de destination, un entier ne dépassant pas 15.\n- m: coordonnée y du point de destination, un entier ne dépassant pas 15.\n- horse_x: coordonnée x de la position du cheval, un entier.\n- horse_y: coordonnée y de la position du cheval, un entier.\n\nRetourne:\n- Le nombre total de chemins valides de (0, 0) à (n, m) en évitant les points de contrôle du cheval.\n\nExemples:\n- count_paths(6, 6, 3, 3) retourne 6\n- count_paths(5, 5, 1, 1) retourne 12\n- count_paths(7, 7, 2, 2) retourne 28",
      "de": "Berechnet die Anzahl der Pfade, die ein Bauer nehmen kann, um vom Ursprung (0, 0) zu einem gegebenen Punkt (n, m) auf einem Schachbrett zu gelangen, wobei die Kontrollpunkte eines stationären Pferdes bei (horse_x, horse_y) vermieden werden.\n\nDer Bauer kann sich nur entweder einen Schritt nach rechts oder einen Schritt nach unten bewegen. Die Kontrollpunkte des Pferdes umfassen seine aktuelle Position und alle Punkte, die es in einem Zug erreichen kann. Der Bauer muss diese Kontrollpunkte vermeiden.\n\nArgumente:\n- n: x-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n- m: y-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n- horse_x: x-Koordinate der Position des Pferdes, eine ganze Zahl.\n- horse_y: y-Koordinate der Position des Pferdes, eine ganze Zahl.\n\nRückgabewerte:\n- Die Gesamtanzahl der gültigen Pfade von (0, 0) zu (n, m), die die Kontrollpunkte des Pferdes vermeiden.\n\nBeispiele:\n- count_paths(6, 6, 3, 3) gibt 6 zurück\n- count_paths(5, 5, 1, 1) gibt 12 zurück\n- count_paths(7, 7, 2, 2) gibt 28 zurück",
      "ha": "Yana lissafin adadin hanyoyin da pawn zai iya ɗauka don motsawa daga asali (0, 0) zuwa wani wuri (n, m) akan allo na catur, yana guje wa wuraren sarrafawa na doki mai tsayawa wanda yake a (horse_x, horse_y).\n\nPawn ɗin zai iya motsawa ne kawai ko dai mataki ɗaya zuwa dama ko mataki ɗaya ƙasa a lokaci guda. Wuraren sarrafawa na doki sun haɗa da matsayinsa na yanzu da duk wuraren da zai iya kaiwa a cikin motsi ɗaya. Pawn ɗin dole ne ya guje wa waɗannan wuraren sarrafawa.\n\nHujjoji:\n- n: x-kowodin wurin da ake nufi, cikakken lamba da ba zai wuce 15 ba.\n- m: y-kowodin wurin da ake nufi, cikakken lamba da ba zai wuce 15 ba.\n- horse_x: x-kowodin wurin doki, cikakken lamba.\n- horse_y: y-kowodin wurin doki, cikakken lamba.\n\nYana Mayarwa:\n- Jimillar adadin hanyoyin da suka dace daga (0, 0) zuwa (n, m) yana guje wa wuraren sarrafawa na doki.\n\nMisalai:\n- count_paths(6, 6, 3, 3) yana mayar da 6\n- count_paths(5, 5, 1, 1) yana mayar da 12\n- count_paths(7, 7, 2, 2) yana mayar da 28",
      "hi": "प्यादा शतरंज की बिसात पर मूल बिंदु (0, 0) से एक दिए गए बिंदु (n, m) तक जाने के लिए कितने रास्ते ले सकता है, इसकी गणना करता है, जो (horse_x, horse_y) पर स्थित स्थिर घोड़े के नियंत्रण बिंदुओं से बचते हुए।\n\n  प्यादा केवल एक बार में या तो एक कदम दाईं ओर या एक कदम नीचे की ओर ही चल सकता है। घोड़े के नियंत्रण बिंदुओं में उसकी वर्तमान स्थिति और वे सभी बिंदु शामिल हैं जिन्हें वह एक चाल में पहुंच सकता है। प्यादे को इन नियंत्रण बिंदुओं से बचना चाहिए।\n\n  Arguments:\n  - n: गंतव्य बिंदु का x-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - m: गंतव्य बिंदु का y-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - horse_x: घोड़े की स्थिति का x-निर्देशांक, एक पूर्णांक।\n  - horse_y: घोड़े की स्थिति का y-निर्देशांक, एक पूर्णांक।\n\n  Returns:\n  - (0, 0) से (n, m) तक घोड़े के नियंत्रण बिंदुओं से बचते हुए कुल मान्य रास्तों की संख्या।\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "hu": "Kiszámítja, hány útvonalon tud egy gyalog eljutni az origóból (0, 0) egy adott pontba (n, m) a sakktáblán, elkerülve egy álló ló kontrollpontjait, amely a (ló_x, ló_y) helyen található.\n\nA gyalog csak egy lépést tehet jobbra vagy egy lépést lefelé egyszerre. A ló kontrollpontjai közé tartozik a jelenlegi pozíciója és minden pont, amelyet egy lépésben elérhet. A gyalognak el kell kerülnie ezeket a kontrollpontokat.\n\nArgumentumok:\n- n: a célpont x-koordinátája, egy legfeljebb 15-ös egész szám.\n- m: a célpont y-koordinátája, egy legfeljebb 15-ös egész szám.\n- ló_x: a ló pozíciójának x-koordinátája, egy egész szám.\n- ló_y: a ló pozíciójának y-koordinátája, egy egész szám.\n\nVisszatérési érték:\n- Az összes érvényes útvonal száma (0, 0)-tól (n, m)-ig, elkerülve a ló kontrollpontjait.\n\nPéldák:\n- count_paths(6, 6, 3, 3) visszaadja 6\n- count_paths(5, 5, 1, 1) visszaadja 12\n- count_paths(7, 7, 2, 2) visszaadja 28"
    },
    "docstring_bertscore": {
      "sq": "0.9596651216751504",
      "hy": "0.9491099032269564",
      "bn": "0.9395573709422266",
      "bg": "0.9610374589777205",
      "zh": "0.957886386612983",
      "fr": "0.9725852334399457",
      "de": "0.9604926158425418",
      "ha": "0.9578254070860053",
      "hi": "1",
      "hu": "0.9398362479971996"
    }
  },
  {
    "task_id": "Rust/37",
    "prompt": {
      "en": "/*\n  Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "sq": "/*\n  Llogarit diferencën midis numrit të kth më të madh dhe numrit të kth më të vogël në një listë të dhënë të numrave të plotë.\n  Nëse numri i kth më i madh ose më i vogël nuk ekziston, funksioni kthen None.\n\n  Argumentet:\n  - numbers: Një Vec<i32> që përfaqëson sekuencën e numrave të plotë jo-negativë.\n  - k: Një vlerë usize që përfaqëson pozicionin e kth.\n\n  Kthen:\n  - Një vlerë Option<i32> që përfaqëson diferencën nëse të dy numrat e kth më të madh dhe më të vogël ekzistojnë, përndryshe None.\n\n  Shembull:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) kthen Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) kthen None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "hy": "/*\n  Հաշվում է տրված ամբողջ թվերի ցուցակի k-րդ ամենամեծ և k-րդ ամենափոքր թվերի տարբերությունը:\n  Եթե k-րդ ամենամեծ կամ ամենափոքր թիվը գոյություն չունի, ֆունկցիան վերադարձնում է None:\n\n  Արգումենտներ:\n  - numbers: A Vec<i32>, որը ներկայացնում է ոչ բացասական ամբողջ թվերի հաջորդականությունը:\n  - k: A usize արժեք, որը ներկայացնում է k-րդ դիրքը:\n\n  Վերադարձնում է:\n  - An Option<i32> արժեք, որը ներկայացնում է տարբերությունը, եթե k-րդ ամենամեծ և ամենափոքր թվերը գոյություն ունեն, հակառակ դեպքում՝ None:\n\n  Օրինակ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) վերադարձնում է Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) վերադարձնում է None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "bn": "/*\n  প্রদত্ত পূর্ণসংখ্যার তালিকায় kth বৃহত্তম এবং kth ক্ষুদ্রতম সংখ্যার মধ্যে পার্থক্য গণনা করে।\n  যদি kth বৃহত্তম বা ক্ষুদ্রতম সংখ্যা বিদ্যমান না থাকে, তাহলে ফাংশনটি None প্রদান করে।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: একটি Vec<i32> যা অ-ঋণাত্মক পূর্ণসংখ্যার ক্রম উপস্থাপন করে।\n  - k: একটি usize মান যা kth অবস্থান উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি Option<i32> মান যা পার্থক্য উপস্থাপন করে যদি উভয় kth বৃহত্তম এবং ক্ষুদ্রতম সংখ্যা বিদ্যমান থাকে, অন্যথায় None।\n\n  উদাহরণ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "bg": "/*\n  Изчислява разликата между k-тото по големина и k-тото по малко число в даден списък от цели числа.\n  Ако k-тото по големина или малко число не съществува, функцията връща None.\n\n  Аргументи:\n  - numbers: Vec<i32>, представляващ последователност от неотрицателни цели числа.\n  - k: Стойност от тип usize, представляваща k-тата позиция.\n\n  Връща:\n  - Стойност от тип Option<i32>, представляваща разликата, ако и двете k-то по големина и малко числа съществуват, в противен случай None.\n\n  Пример:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) връща Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) връща None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "zh": "/*\n  计算给定整数列表中第k大和第k小数字之间的差值。\n  如果第k大或第k小的数字不存在，函数返回None。\n\n  参数:\n  - numbers: 一个Vec<i32>，表示非负整数序列。\n  - k: 一个usize值，表示第k个位置。\n\n  返回:\n  - 一个Option<i32>值，如果第k大和第k小的数字都存在，则表示差值，否则为None。\n\n  示例:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) 返回 Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) 返回 None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "fr": "/*\n  Calcule la différence entre le k-ième plus grand et le k-ième plus petit nombre dans une liste donnée d'entiers.\n  Si le k-ième plus grand ou plus petit nombre n'existe pas, la fonction renvoie None.\n\n  Arguments :\n  - numbers : Un Vec<i32> représentant la séquence d'entiers non négatifs.\n  - k : Une valeur usize représentant la position k-ième.\n\n  Renvoie :\n  - Une valeur Option<i32> représentant la différence si les deux nombres k-ième plus grand et plus petit existent, sinon None.\n\n  Exemple :\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) renvoie Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) renvoie None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "de": "/*\n  Berechnet die Differenz zwischen der k-größten und der k-kleinsten Zahl in einer gegebenen Liste von ganzen Zahlen.\n  Wenn die k-größte oder k-kleinste Zahl nicht existiert, gibt die Funktion None zurück.\n\n  Argumente:\n  - numbers: Ein Vec<i32>, der die Sequenz von nicht-negativen ganzen Zahlen darstellt.\n  - k: Ein usize-Wert, der die k-te Position darstellt.\n\n  Rückgabewert:\n  - Ein Option<i32>-Wert, der die Differenz darstellt, wenn sowohl die k-größte als auch die k-kleinste Zahl existieren, andernfalls None.\n\n  Beispiel:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) gibt Some(4) zurück // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) gibt None zurück\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "ha": "/*\n  Lissafa bambanci tsakanin lamba ta k mafi girma da lamba ta k mafi ƙanƙanta a cikin jerin lambobin cikakku da aka bayar.\n  Idan lamba ta k mafi girma ko mafi ƙanƙanta ba ta wanzu, aikin yana dawowa da None.\n\n  Huɗɗa:\n  - numbers: Wani Vec<i32> wanda ke wakiltar jerin lambobin cikakku marasa kyau.\n  - k: Wani ƙimar usize wanda ke wakiltar matsayi na k.\n\n  Dawowa:\n  - Wani Option<i32> wanda ke wakiltar bambanci idan duka lambobi ta k mafi girma da mafi ƙanƙanta suna wanzu, in ba haka ba None.\n\n  Misali:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) yana dawowa Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) yana dawowa None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "hi": "/*\n  दिए गए पूर्णांकों की सूची में से kवें सबसे बड़े और kवें सबसे छोटे संख्याओं के बीच का अंतर निकालता है।\n  यदि kवीं सबसे बड़ी या सबसे छोटी संख्या मौजूद नहीं है, तो फ़ंक्शन None लौटाता है।\n\n  तर्क:\n  - numbers: गैर-ऋणात्मक पूर्णांकों के अनुक्रम का प्रतिनिधित्व करने वाला एक Vec<i32>।\n  - k: kवें स्थान का प्रतिनिधित्व करने वाला एक usize मान।\n\n  लौटाता है:\n  - एक Option<i32> मान जो अंतर का प्रतिनिधित्व करता है यदि दोनों kवीं सबसे बड़ी और सबसे छोटी संख्याएँ मौजूद हैं, अन्यथा None।\n\n  उदाहरण:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) लौटाता है // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None लौटाता है\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "hu": "/*\n  Kiszámítja a különbséget a k-adik legnagyobb és a k-adik legkisebb szám között egy adott egész számokat tartalmazó listában.\n  Ha a k-adik legnagyobb vagy legkisebb szám nem létezik, a függvény None értéket ad vissza.\n\n  Argumentumok:\n  - numbers: Egy Vec<i32>, amely a nem-negatív egész számok sorozatát képviseli.\n  - k: Egy usize érték, amely a k-adik pozíciót jelöli.\n\n  Visszatérési érték:\n  - Egy Option<i32> érték, amely a különbséget jelenti, ha mindkét k-adik legnagyobb és legkisebb szám létezik, különben None.\n\n  Példa:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) visszaadja Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) visszaadja None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> "
    },
    "prompt_bertscore": {
      "sq": "0.9848431115143708",
      "hy": "0.9668297195190788",
      "bn": "0.9937743279672235",
      "bg": "0.9601887113595584",
      "zh": "0.9542174848448876",
      "fr": "0.9711944235119395",
      "de": "0.9544556426717484",
      "ha": "0.9594994639373673",
      "hi": "0.9664680135952143",
      "hu": "0.9655833138780849"
    },
    "canonical_solution": "{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}",
    "instruction": {
      "en": "Write a Rust function `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` to solve the following problem:\nCalculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "sq": "Shkruani një funksion në Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` për të zgjidhur problemin e mëposhtëm:\nLlogarit diferencën midis numrit të kth më të madh dhe numrit të kth më të vogël në një listë të dhënë të numrave të plotë.\nNëse numri i kth më i madh ose më i vogël nuk ekziston, funksioni kthen None.\n\nArgumentet:\n- numbers: Një Vec<i32> që përfaqëson sekuencën e numrave jo-negativë të plotë.\n- k: Një vlerë usize që përfaqëson pozicionin e kth.\n\nKthen:\n- Një vlerë Option<i32> që përfaqëson diferencën nëse të dy numrat e kth më të madh dhe më të vogël ekzistojnë, përndryshe None.\n\nShembull:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) kthen Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) kthen None",
      "hy": "Գրեք Rust ֆունկցիա `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված ամբողջ թվերի ցանկում k-րդ ամենամեծ և k-րդ ամենափոքր թվերի տարբերությունը:\n  Եթե k-րդ ամենամեծ կամ ամենափոքր թիվը գոյություն չունի, ֆունկցիան վերադարձնում է None:\n\n  Արգումենտներ:\n  - numbers: A Vec<i32>, որը ներկայացնում է ոչ բացասական ամբողջ թվերի հաջորդականությունը:\n  - k: A usize արժեք, որը ներկայացնում է k-րդ դիրքը:\n\n  Վերադարձնում է:\n  - An Option<i32> արժեք, որը ներկայացնում է տարբերությունը, եթե և՛ k-րդ ամենամեծ, և՛ ամենափոքր թվերը գոյություն ունեն, հակառակ դեպքում՝ None:\n\n  Օրինակ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) վերադարձնում է Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) վերադարձնում է None",
      "bn": "Rust ফাংশন `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত পূর্ণসংখ্যার তালিকায় kth বৃহত্তম এবং kth ক্ষুদ্রতম সংখ্যার মধ্যে পার্থক্য গণনা করে।\nযদি kth বৃহত্তম বা ক্ষুদ্রতম সংখ্যা বিদ্যমান না থাকে, তাহলে ফাংশনটি None ফেরত দেয়।\n\nআর্গুমেন্টসমূহ:\n- numbers: একটি Vec<i32> যা অ-ঋণাত্মক পূর্ণসংখ্যার ক্রম উপস্থাপন করে।\n- k: একটি usize মান যা kth অবস্থান উপস্থাপন করে।\n\nফেরত দেয়:\n- একটি Option<i32> মান যা পার্থক্য উপস্থাপন করে যদি উভয় kth বৃহত্তম এবং ক্ষুদ্রতম সংখ্যা বিদ্যমান থাকে, অন্যথায় None।\n\nউদাহরণ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) ফেরত দেয় // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None ফেরত দেয়",
      "bg": "Напишете функция на Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` за решаване на следния проблем:\nИзчислява разликата между k-тото най-голямо и k-тото най-малко число в даден списък от цели числа.\nАко k-тото най-голямо или най-малко число не съществува, функцията връща None.\n\nАргументи:\n- numbers: Vec<i32>, представляващ последователност от неотрицателни цели числа.\n- k: Стойност от тип usize, представляваща k-тата позиция.\n\nВръща:\n- Стойност от тип Option<i32>, представляваща разликата, ако и двете k-ти най-голямо и най-малко числа съществуват, в противен случай None.\n\nПример:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) връща Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) връща None",
      "zh": "编写一个 Rust 函数 `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` 来解决以下问题：\n计算给定整数列表中第 k 大和第 k 小数字之间的差值。\n如果第 k 大或第 k 小的数字不存在，函数返回 None。\n\n参数：\n- numbers: 一个 Vec<i32>，表示非负整数的序列。\n- k: 一个 usize 值，表示第 k 个位置。\n\n返回：\n- 一个 Option<i32> 值，如果第 k 大和第 k 小的数字都存在，则返回差值，否则返回 None。\n\n示例：\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) 返回 Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) 返回 None",
      "fr": "Écrire une fonction Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` pour résoudre le problème suivant :\nCalcule la différence entre le k-ième plus grand et le k-ième plus petit nombre dans une liste donnée d'entiers.\nSi le k-ième plus grand ou plus petit nombre n'existe pas, la fonction renvoie None.\n\nArguments :\n- numbers : Un Vec<i32> représentant la séquence d'entiers non négatifs.\n- k : Une valeur usize représentant la position k-ième.\n\nRenvoie :\n- Une valeur Option<i32> représentant la différence si les deux k-ièmes plus grands et plus petits nombres existent, sinon None.\n\nExemple :\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) renvoie Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) renvoie None",
      "de": "Schreiben Sie eine Rust-Funktion `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>`, um das folgende Problem zu lösen:\nBerechnet die Differenz zwischen der k-größten und der k-kleinsten Zahl in einer gegebenen Liste von ganzen Zahlen.\nFalls die k-größte oder k-kleinste Zahl nicht existiert, gibt die Funktion None zurück.\n\nArgumente:\n- numbers: Ein Vec<i32>, der die Sequenz von nicht-negativen ganzen Zahlen darstellt.\n- k: Ein usize-Wert, der die k-te Position darstellt.\n\nRückgabewerte:\n- Ein Option<i32>-Wert, der die Differenz darstellt, falls sowohl die k-größte als auch die k-kleinste Zahl existieren, andernfalls None.\n\nBeispiel:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) gibt Some(4) zurück // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) gibt None zurück",
      "ha": "Rubuta aikin Rust `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` don warware matsalar mai zuwa:\nLissafi bambanci tsakanin lamba ta k mafi girma da kuma lamba ta k mafi ƙanƙanta a cikin jerin lambobin cikakkun lambobi da aka bayar.\n  Idan lamba ta k mafi girma ko mafi ƙanƙanta ba ta wanzu, aikin zai dawo da None.\n\n  Huɗɗa:\n  - numbers: Wani Vec<i32> da ke wakiltar jerin lambobin cikakkun lambobi marasa tabbatacce.\n  - k: Wani ƙima na usize da ke wakiltar matsayi na k.\n\n  Dawowa:\n  - Wani ƙima na Option<i32> da ke wakiltar bambanci idan duka lambobin ta k mafi girma da mafi ƙanƙanta sun wanzu, in ba haka ba None.\n\n  Misali:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "hi": "Rust फ़ंक्शन `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की सूची में से kth सबसे बड़े और kth सबसे छोटे संख्याओं के बीच का अंतर गणना करता है।\n  यदि kth सबसे बड़ी या सबसे छोटी संख्या मौजूद नहीं है, तो फ़ंक्शन None लौटाता है।\n\n  तर्क:\n  - numbers: एक Vec<i32> जो गैर-ऋणात्मक पूर्णांकों का अनुक्रम दर्शाता है।\n  - k: एक usize मान जो kth स्थिति का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक Option<i32> मान जो अंतर का प्रतिनिधित्व करता है यदि दोनों kth सबसे बड़ी और सबसे छोटी संख्याएँ मौजूद हैं, अन्यथा None।\n\n  उदाहरण:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) लौटाता है // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None लौटाता है",
      "hu": "Írj egy Rust függvényt `fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>` a következő probléma megoldására:\nKiszámítja a különbséget a k-adik legnagyobb és a k-adik legkisebb szám között egy adott egész számokat tartalmazó listában.\nHa a k-adik legnagyobb vagy legkisebb szám nem létezik, a függvény None értéket ad vissza.\n\nArgumentumok:\n- numbers: Egy Vec<i32>, amely a nem negatív egész számok sorozatát képviseli.\n- k: Egy usize érték, amely a k-adik pozíciót jelzi.\n\nVisszatérési érték:\n- Egy Option<i32> érték, amely a különbséget képviseli, ha mind a k-adik legnagyobb, mind a legkisebb szám létezik, ellenkező esetben None.\n\nPélda:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) visszaadja Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) visszaadja None"
    },
    "instruction_bertscore": {
      "sq": "0.9814971827458381",
      "hy": "0.9710895466707531",
      "bn": "0.9873758475029466",
      "bg": "0.9622520837577488",
      "zh": "0.9465998111018186",
      "fr": "0.9713078414595104",
      "de": "0.9595902380215002",
      "ha": "0.958472544867417",
      "hi": "0.9866121136878675",
      "hu": "0.9696633805349225"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n     \n        assert_eq!(kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2), Some(4)); // 5 - 1 = 4\n        assert_eq!(kth_largest_minus_kth_smallest(vec![10, 20, 30], 4), None);\n        assert_eq!(kth_largest_minus_kth_smallest(vec![7, 7, 7, 7], 1), Some(0)); // 7 - 7 = 0\n        \n        \n    }\n    \n\n}",
    "entry_point": "kth_largest_minus_kth_smallest",
    "signature": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>",
    "docstring": {
      "en": "Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "sq": "Llogarit ndryshimin midis numrit të kth më të madh dhe numrit të kth më të vogël në një listë të dhënë të numrave të plotë.\n  Nëse numri i kth më i madh ose më i vogël nuk ekziston, funksioni kthen None.\n\n  Argumentet:\n  - numbers: Një Vec<i32> që përfaqëson sekuencën e numrave të plotë jo-negativë.\n  - k: Një vlerë usize që përfaqëson pozicionin e kth.\n\n  Kthen:\n  - Një vlerë Option<i32> që përfaqëson ndryshimin nëse ekzistojnë si numri i kth më i madh ashtu edhe më i vogël, përndryshe None.\n\n  Shembull:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) kthen Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) kthen None",
      "hy": "Հաշվում է տրված ամբողջ թվերի ցուցակի k-րդ ամենամեծ և k-րդ ամենափոքր թվերի տարբերությունը։ \nԵթե k-րդ ամենամեծ կամ ամենափոքր թիվը գոյություն չունի, ֆունկցիան վերադարձնում է None։\n\nԱրգումենտներ:\n- numbers: A Vec<i32>, որը ներկայացնում է ոչ բացասական ամբողջ թվերի հաջորդականությունը։\n- k: A usize արժեք, որը ներկայացնում է k-րդ դիրքը։\n\nՎերադարձնում է:\n- An Option<i32> արժեք, որը ներկայացնում է տարբերությունը, եթե k-րդ ամենամեծ և ամենափոքր թվերը գոյություն ունեն, հակառակ դեպքում՝ None։\n\nՕրինակ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) վերադարձնում է Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) վերադարձնում է None",
      "bn": "দেওয়া পূর্ণসংখ্যার তালিকায় k-তম বৃহত্তম এবং k-তম ক্ষুদ্রতম সংখ্যার মধ্যে পার্থক্য গণনা করে।  \nযদি k-তম বৃহত্তম বা ক্ষুদ্রতম সংখ্যা বিদ্যমান না থাকে, তাহলে ফাংশনটি None প্রদান করে।\n\nআর্গুমেন্টস:\n- numbers: একটি Vec<i32> যা অ-ঋণাত্মক পূর্ণসংখ্যার ক্রম উপস্থাপন করে।\n- k: একটি usize মান যা k-তম অবস্থান উপস্থাপন করে।\n\nরিটার্নস:\n- একটি Option<i32> মান যা পার্থক্য উপস্থাপন করে যদি উভয় k-তম বৃহত্তম এবং ক্ষুদ্রতম সংখ্যা বিদ্যমান থাকে, অন্যথায় None।\n\nউদাহরণ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "bg": "Изчислява разликата между k-тото по големина и k-тото по малко число в даден списък от цели числа. Ако k-тото по големина или малко число не съществува, функцията връща None.\n\nАргументи:\n- numbers: Vec<i32>, представляващ последователността от неотрицателни цели числа.\n- k: Стойност от тип usize, представляваща k-тата позиция.\n\nВръща:\n- Стойност от тип Option<i32>, представляваща разликата, ако и двете k-ти по големина и малко числа съществуват, в противен случай None.\n\nПример:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) връща Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) връща None",
      "zh": "计算给定整数列表中第k大和第k小数字之间的差值。\n如果第k大或第k小的数字不存在，函数返回None。\n\n参数:\n- numbers: 一个Vec<i32>，表示非负整数的序列。\n- k: 一个usize值，表示第k个位置。\n\n返回:\n- 一个Option<i32>值，如果第k大和第k小的数字都存在，则表示它们的差值，否则返回None。\n\n示例:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) 返回 Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) 返回 None",
      "fr": "Calcule la différence entre le k-ième plus grand et le k-ième plus petit nombre dans une liste donnée d'entiers.\n  Si le k-ième plus grand ou plus petit nombre n'existe pas, la fonction renvoie None.\n\n  Arguments:\n  - numbers: Un Vec<i32> représentant la séquence d'entiers non négatifs.\n  - k: Une valeur usize représentant la position k-ième.\n\n  Renvoie:\n  - Une valeur Option<i32> représentant la différence si les deux k-ièmes plus grands et plus petits nombres existent, sinon None.\n\n  Exemple:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) renvoie Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) renvoie None",
      "de": "Berechnet die Differenz zwischen der k-größten und der k-kleinsten Zahl in einer gegebenen Liste von ganzen Zahlen. Wenn die k-größte oder k-kleinste Zahl nicht existiert, gibt die Funktion None zurück.\n\nArgumente:\n- numbers: Ein Vec<i32>, der die Sequenz von nicht-negativen ganzen Zahlen darstellt.\n- k: Ein usize-Wert, der die k-te Position darstellt.\n\nRückgabewerte:\n- Ein Option<i32>-Wert, der die Differenz darstellt, wenn sowohl die k-größte als auch die k-kleinste Zahl existieren, andernfalls None.\n\nBeispiel:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) gibt Some(4) zurück // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) gibt None zurück",
      "ha": "Lissafa bambanci tsakanin lamba ta k mafi girma da lamba ta k mafi ƙanƙanta a cikin jerin lambobin cikakku da aka bayar.\n  Idan ba a sami lamba mafi girma ko mafi ƙanƙanta ba, aikin yana mayar da None.\n\nArguments: \n- numbers: A Vec<i32> wanda ke wakiltar jerin lambobin da ba su da korau. \n- k: Wani usize darajar da ke wakiltar matsayin k.\n\nReturns: \n- An Option<i32> darajar da ke wakiltar bambanci idan duka lambobin mafi girma da mafi ƙanƙanta na k suna nan, in ba haka ba None.\n\nExample: \n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "hi": "kth सबसे बड़े और kth सबसे छोटे संख्याओं के बीच का अंतर गणना करता है एक दिए गए पूर्णांकों की सूची में।  \nयदि kth सबसे बड़ी या सबसे छोटी संख्या मौजूद नहीं है, तो फ़ंक्शन None लौटाता है।\n\nआर्गुमेंट्स:\n- numbers: एक Vec<i32> जो गैर-ऋणात्मक पूर्णांकों के अनुक्रम का प्रतिनिधित्व करता है।\n- k: एक usize मान जो kth स्थिति का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n- एक Option<i32> मान जो अंतर का प्रतिनिधित्व करता है यदि दोनों kth सबसे बड़ी और सबसे छोटी संख्याएं मौजूद हैं, अन्यथा None।\n\nउदाहरण:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) लौटाता है // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None लौटाता है",
      "hu": "Kiszámítja a különbséget a megadott egész számokat tartalmazó lista k-adik legnagyobb és k-adik legkisebb száma között. Ha a k-adik legnagyobb vagy legkisebb szám nem létezik, a függvény None értéket ad vissza.\n\n  Argumentumok:\n  - numbers: Egy Vec<i32>, amely a nem negatív egész számok sorozatát képviseli.\n  - k: Egy usize érték, amely a k-adik pozíciót jelöli.\n\n  Visszatérési érték:\n  - Egy Option<i32> érték, amely a különbséget jelenti, ha mind a k-adik legnagyobb, mind a legkisebb szám létezik, ellenkező esetben None.\n\n  Példa:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) visszaadja Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) visszaadja None"
    },
    "docstring_bertscore": {
      "sq": "0.9839812542910604",
      "hy": "0.9652609367696653",
      "bn": "0.9677569261377497",
      "bg": "0.9578202426960983",
      "zh": "0.9483318680244428",
      "fr": "0.9687028040122379",
      "de": "0.9577906467693242",
      "ha": "0.9811646754879857",
      "hi": "0.9821385602461997",
      "hu": "0.967217843283621"
    }
  },
  {
    "task_id": "Rust/38",
    "prompt": {
      "en": "/*\n  Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "sq": "/*\n  Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor nga një grup bimësh, secila me kërkesën e vet kohore dhe vlerën.\n\n  Argumentet:\n  - total_time: Një u32 që përfaqëson kohën totale të disponueshme për mbledhjen e bimëve.\n  - herbs: Një segment tuplesh, ku çdo tuple përmban dy vlera u32 që përfaqësojnë kohën e kërkuar për të mbledhur një bimë dhe vlerën e saj, përkatësisht.\n\n  Kthen:\n  - Një u32 që përfaqëson vlerën maksimale totale të bimëve që mund të mblidhen brenda kohës së dhënë.\n\n  Shembuj:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) kthen 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) kthen 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) kthen 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "hy": "/*\n  Հաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակի սահմաններում խոտաբույսերի հավաքածուից, որոնցից յուրաքանչյուրն ունի իր ժամանակային պահանջը և արժեքը։\n\n  Արգումենտներ:\n  - total_time: u32, որը ներկայացնում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը։\n  - herbs: կորտեժների կտոր, որտեղ յուրաքանչյուր կորտեժ պարունակում է երկու u32 արժեք, որոնք ներկայացնում են խոտաբույս հավաքելու համար պահանջվող ժամանակը և դրա արժեքը, համապատասխանաբար։\n\n  Վերադարձնում է:\n  - u32, որը ներկայացնում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակի ընթացքում։\n\n  Օրինակներ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) վերադարձնում է 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) վերադարձնում է 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) վերադարձնում է 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
      "bn": "/*\n  একটি নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব বেশি মূল্যমানের ভেষজ সংগ্রহ করা যায় তা গণনা করে, যেখানে প্রতিটি ভেষজের নিজস্ব সময়ের প্রয়োজনীয়তা এবং মূল্যমান রয়েছে।\n\n  আর্গুমেন্টসমূহ:\n  - total_time: একটি u32 যা ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়কে উপস্থাপন করে।\n  - herbs: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপলে দুটি u32 মান রয়েছে যা একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্যমানকে যথাক্রমে উপস্থাপন করে।\n\n  রিটার্ন করে:\n  - একটি u32 যা প্রদত্ত সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্যমান উপস্থাপন করে।\n\n  উদাহরণ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 রিটার্ন করে\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 রিটার্ন করে\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 রিটার্ন করে\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "bg": "/*\n  Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено времево ограничение от набор от билки, всяка със собствено времево изискване и стойност.\n\n  Аргументи:\n  - total_time: u32, представляващо общото време, налично за събиране на билки.\n  - herbs: Срез от кортежи, където всеки кортеж съдържа две u32 стойности, представляващи времето, необходимо за събиране на билка и нейната стойност, съответно.\n\n  Връща:\n  - u32, представляващо максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n  Примери:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) връща 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) връща 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) връща 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "zh": "/*\n  计算在给定时间限制内可以收集的草药的最大总价值，每种草药都有其自身的时间要求和价值。\n\n  参数:\n  - total_time: 一个 u32，表示可用于收集草药的总时间。\n  - herbs: 一个元组的切片，每个元组包含两个 u32 值，分别表示收集一种草药所需的时间及其价值。\n\n  返回:\n  - 一个 u32，表示在给定时间内可以收集的草药的最大总价值。\n\n  示例:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 返回 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 返回 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 返回 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "fr": "/*\n  Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un délai donné à partir d'un ensemble d'herbes, chacune ayant son propre temps requis et sa valeur.\n\n  Arguments:\n  - total_time: Un u32 représentant le temps total disponible pour collecter les herbes.\n  - herbs: Une tranche de tuples, où chaque tuple contient deux valeurs u32 représentant le temps requis pour collecter une herbe et sa valeur, respectivement.\n\n  Renvoie:\n  - Un u32 représentant la valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n  Exemples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) renvoie 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) renvoie 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) renvoie 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "de": "/*\n  Berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines gegebenen Zeitlimits gesammelt werden können, aus einer Menge von Kräutern, von denen jedes seine eigene Zeitanforderung und seinen Wert hat.\n\n  Argumente:\n  - total_time: Ein u32, das die insgesamt verfügbare Zeit zum Sammeln von Kräutern darstellt.\n  - herbs: Ein Slice von Tupeln, wobei jedes Tupel zwei u32-Werte enthält, die die zum Sammeln eines Krauts erforderliche Zeit und dessen Wert darstellen.\n\n  Rückgabewert:\n  - Ein u32, das den maximalen Gesamtwert der Kräuter darstellt, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n  Beispiele:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) gibt 3 zurück\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) gibt 100 zurück\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) gibt 30 zurück\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "ha": "/*\n  Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin iyakar lokaci da aka bayar daga saitin ganyayyaki, kowanne yana da bukatar lokaci da ƙimarsa.\n\n  Huɗɗa:\n  - total_time: Wani u32 da ke wakiltar jimillar lokacin da ake da shi don tattara ganyayyaki.\n  - herbs: Wani yanki na tuples, inda kowanne tuple ya ƙunshi ƙimomi biyu na u32 da ke wakiltar lokacin da ake buƙata don tattara wani ganye da ƙimarsa, bi da bi.\n\n  Komawa:\n  - Wani u32 da ke wakiltar mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin lokacin da aka bayar.\n\n  Misalai:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "hi": "/*\n  जड़ी-बूटियों का अधिकतम कुल मूल्य गणना करता है जिसे जड़ी-बूटियों के एक सेट से एक दिए गए समय सीमा के भीतर एकत्र किया जा सकता है, प्रत्येक के लिए अपना समय आवश्यकताएँ और मूल्य होते हैं।\n\n  तर्क:\n  - total_time: एक u32 जो जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय का प्रतिनिधित्व करता है।\n  - herbs: ट्यूपल का एक स्लाइस, जहां प्रत्येक ट्यूपल में दो u32 मान होते हैं जो क्रमशः एक जड़ी-बूटी को एकत्र करने के लिए आवश्यक समय और उसका मूल्य दर्शाते हैं।\n\n  लौटाता है:\n  - एक u32 जो दिए गए समय के भीतर एकत्र की जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य दर्शाता है।\n\n  उदाहरण:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 लौटाता है\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 लौटाता है\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 लौटाता है\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "hu": "/*\n  Kiszámítja a maximális összértéket, amelyet a gyógynövényekből lehet összegyűjteni egy adott időkorláton belül, ahol minden gyógynövénynek megvan a saját időigénye és értéke.\n\n  Argumentumok:\n  - total_time: Egy u32, amely az összes rendelkezésre álló időt jelenti a gyógynövények gyűjtésére.\n  - herbs: Egy tuple szelet, ahol minden tuple két u32 értéket tartalmaz, amelyek egy gyógynövény gyűjtéséhez szükséges időt és annak értékét képviselik.\n\n  Visszatér:\n  - Egy u32, amely a maximális összértéket jelenti, amelyet a gyógynövényekből lehet összegyűjteni az adott időn belül.\n\n  Példák:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) visszaadja 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) visszaadja 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) visszaadja 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 "
    },
    "prompt_bertscore": {
      "sq": "0.9972704213038186",
      "hy": "0.9818984161155285",
      "bn": "0.9770415060384635",
      "bg": "0.9901926249364024",
      "zh": "0.9690647085664834",
      "fr": "0.9899785013856468",
      "de": "0.9939958008420774",
      "ha": "0.9840056858279277",
      "hi": "0.9952485626552644",
      "hu": "0.972102760244412"
    },
    "canonical_solution": "{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` to solve the following problem:\nCalculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "sq": "Shkruani një funksion Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` për të zgjidhur problemin e mëposhtëm:\nLlogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohe nga një grup bimësh, secila me kërkesën e vet të kohës dhe vlerën.\n\n  Argumentet:\n  - total_time: Një u32 që përfaqëson kohën totale të disponueshme për mbledhjen e bimëve.\n  - herbs: Një segment i dysheve, ku çdo dyshe përmban dy vlera u32 që përfaqësojnë kohën e kërkuar për të mbledhur një bimë dhe vlerën e saj, përkatësisht.\n\n  Kthen:\n  - Një u32 që përfaqëson vlerën maksimale totale të bimëve që mund të mblidhen brenda kohës së dhënë.\n\n  Shembuj:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) kthen 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) kthen 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) kthen 30",
      "hy": "Գրեք Rust ֆունկցիա `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակի սահմաններում խոտաբույսերի հավաքածուից, որոնցից յուրաքանչյուրը ունի իր ժամանակի պահանջը և արժեքը:\n\n  Փաստարկներ:\n  - total_time: u32, որը ներկայացնում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n  - herbs: կտրուկի կտոր, որտեղ յուրաքանչյուր կտրուկ պարունակում է երկու u32 արժեք, որոնք ներկայացնում են խոտաբույս հավաքելու համար պահանջվող ժամանակը և դրա արժեքը, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - u32, որը ներկայացնում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակի սահմաններում:\n\n  Օրինակներ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) վերադարձնում է 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) վերադարձնում է 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) վերադարձնում է 30",
      "bn": "Rust ফাংশন `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সময়সীমার মধ্যে একটি সেটের ভেষজ থেকে সর্বাধিক মোট মূল্য গণনা করে, যেখানে প্রতিটি ভেষজের নিজস্ব সময়ের প্রয়োজনীয়তা এবং মূল্য রয়েছে।\n\n  আর্গুমেন্টসমূহ:\n  - total_time: একটি u32 যা ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময় উপস্থাপন করে।\n  - herbs: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপলে দুটি u32 মান রয়েছে যা একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং তার মূল্য যথাক্রমে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি u32 যা প্রদত্ত সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য উপস্থাপন করে।\n\n  উদাহরণসমূহ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 রিটার্ন করে\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 রিটার্ন করে\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32`, за да решите следния проблем:\nИзчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит от набор от билки, всяка със собствено времево изискване и стойност.\n\n  Аргументи:\n  - total_time: u32, представляващо общото време, налично за събиране на билки.\n  - herbs: Срез от кортежи, където всеки кортеж съдържа две стойности u32, представляващи времето, необходимо за събиране на билка и нейната стойност, съответно.\n\n  Връща:\n  - u32, представляващо максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n  Примери:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) връща 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) връща 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) връща 30",
      "zh": "编写一个 Rust 函数 `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` 来解决以下问题：\n计算在给定时间限制内可以收集的草药的最大总价值，每种草药都有其自身的时间需求和价值。\n\n  参数：\n  - total_time: 一个 u32，表示可用于收集草药的总时间。\n  - herbs: 一个元组的切片，其中每个元组包含两个 u32 值，分别表示收集一种草药所需的时间及其价值。\n\n  返回：\n  - 一个 u32，表示在给定时间内可以收集的草药的最大总价值。\n\n  示例：\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 返回 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 返回 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 返回 30",
      "fr": "Écrire une fonction Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` pour résoudre le problème suivant :\nCalcule la valeur totale maximale des herbes qui peuvent être collectées dans une limite de temps donnée à partir d'un ensemble d'herbes, chacune ayant son propre temps requis et sa valeur.\n\n  Arguments:\n  - total_time: Un u32 représentant le temps total disponible pour collecter les herbes.\n  - herbs: Une tranche de tuples, où chaque tuple contient deux valeurs u32 représentant le temps requis pour collecter une herbe et sa valeur, respectivement.\n\n  Renvoie:\n  - Un u32 représentant la valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n  Exemples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) renvoie 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) renvoie 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) renvoie 30",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32`, um das folgende Problem zu lösen:\nBerechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines vorgegebenen Zeitlimits aus einer Menge von Kräutern gesammelt werden können, wobei jedes Kraut seine eigene Zeitanforderung und seinen Wert hat.\n\n  Argumente:\n  - total_time: Ein u32, das die insgesamt verfügbare Zeit zum Sammeln von Kräutern darstellt.\n  - herbs: Ein Slice von Tupeln, wobei jedes Tupel zwei u32-Werte enthält, die die zum Sammeln eines Krauts erforderliche Zeit und dessen Wert darstellen.\n\n  Rückgabewert:\n  - Ein u32, das den maximalen Gesamtwert der Kräuter darstellt, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n  Beispiele:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) gibt 3 zurück\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) gibt 100 zurück\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) gibt 30 zurück",
      "ha": "Rubuta aikin Rust `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` don warware matsalar mai zuwa:\nLissafa yawan darajar ganyayyaki mafi girma da za a iya tattarawa a cikin iyakar lokaci da aka bayar daga jerin ganyayyaki, kowanne yana da bukatar lokaci da darajar sa.\n\n  Huɗɗa:\n  - total_time: u32 wanda ke wakiltar jimillar lokacin da ake da shi don tattara ganyayyaki.\n  - herbs: Yanki na tuples, inda kowanne tuple ke dauke da u32 biyu masu wakiltar lokacin da ake bukata don tattara ganye da darajar sa, bi da bi.\n\n  Mayarwa:\n  - u32 wanda ke wakiltar yawan darajar ganyayyaki mafi girma da za a iya tattarawa a cikin lokacin da aka bayar.\n\n  Misalai:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "hi": "Rust फ़ंक्शन `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह दिए गए समय सीमा के भीतर एक सेट से जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है, प्रत्येक के पास अपना समय आवश्यकता और मूल्य होता है।\n\n  तर्क:\n  - total_time: एक u32 जो जड़ी-बूटियों को इकट्ठा करने के लिए उपलब्ध कुल समय का प्रतिनिधित्व करता है।\n  - herbs: ट्यूपल्स की एक स्लाइस, जहाँ प्रत्येक ट्यूपल में दो u32 मान होते हैं जो क्रमशः एक जड़ी-बूटी को इकट्ठा करने के लिए आवश्यक समय और उसका मूल्य दर्शाते हैं।\n\n  लौटाता है:\n  - एक u32 जो दिए गए समय के भीतर इकट्ठा की जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 लौटाता है\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 लौटाता है\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32` a következő probléma megoldására:\nKiszámítja a gyógynövények maximális összértékét, amelyet egy adott időkorláton belül lehet összegyűjteni egy gyógynövénykészletből, ahol minden gyógynövénynek megvan a saját időigénye és értéke.\n\n  Argumentumok:\n  - total_time: Egy u32, amely az összes rendelkezésre álló időt jelenti a gyógynövények gyűjtésére.\n  - herbs: Egy szelet tuple-ökből, ahol minden tuple két u32 értéket tartalmaz, amelyek egy gyógynövény gyűjtéséhez szükséges időt és annak értékét képviselik.\n\n  Visszatér:\n  - Egy u32, amely a gyógynövények maximális összértékét jelenti, amelyet az adott időn belül lehet összegyűjteni.\n\n  Példák:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) visszaadja 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) visszaadja 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) visszaadja 30"
    },
    "instruction_bertscore": {
      "sq": "0.9992676497851244",
      "hy": "0.9811529562955046",
      "bn": "0.9696425243449139",
      "bg": "0.9918555584864265",
      "zh": "0.9719947053171291",
      "fr": "0.9933409164758054",
      "de": "0.9875540189547349",
      "ha": "0.9582145240024527",
      "hi": "0.9672116857418089",
      "hu": "0.9935645742848507"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]), 3);\n        assert_eq!(max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]), 110);\n        assert_eq!(max_herbs_value(5, &[(2, 20), (3, 30)]), 50);\n    }\n    \n\n}",
    "entry_point": "max_herbs_value",
    "signature": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
    "docstring": {
      "en": "Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "sq": "Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të dhënë nga një grup bimësh, secila me kërkesën e vet të kohës dhe vlerën.\n\n  Argumentet:\n  - total_time: Një u32 që përfaqëson kohën totale në dispozicion për mbledhjen e bimëve.\n  - herbs: Një segment tuplesh, ku çdo tuple përmban dy vlera u32 që përfaqësojnë kohën e kërkuar për të mbledhur një bimë dhe vlerën e saj, përkatësisht.\n\n  Kthen:\n  - Një u32 që përfaqëson vlerën maksimale totale të bimëve që mund të mblidhen brenda kohës së dhënë.\n\n  Shembuj:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) kthen 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) kthen 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) kthen 30",
      "hy": "Հաշվում է բույսերի առավելագույն ընդհանուր արժեքը, որոնք հնարավոր է հավաքել տրված ժամանակային սահմանափակման շրջանակներում՝ հաշվի առնելով յուրաքանչյուր բույսի համար անհրաժեշտ ժամանակը և արժեքը:\n\n  Արձանագրություններ:\n  - total_time: u32, որը ներկայացնում է բույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n  - herbs: զույգերի կտոր, որտեղ յուրաքանչյուր զույգ պարունակում է երկու u32 արժեք՝ ներկայացնելով բույս հավաքելու համար անհրաժեշտ ժամանակը և դրա արժեքը, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - u32, որը ներկայացնում է բույսերի առավելագույն ընդհանուր արժեքը, որոնք հնարավոր է հավաքել տրված ժամանակի ընթացքում:\n\n  Օրինակներ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) վերադարձնում է 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) վերադարձնում է 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) վերադարձնում է 30",
      "bn": "গণনা করে একটি নির্দিষ্ট সময়সীমার মধ্যে সর্বাধিক মোট মূল্য কতটুকু ভেষজ সংগ্রহ করা যেতে পারে একটি সেট থেকে, যেখানে প্রতিটি ভেষজের নিজস্ব সময় প্রয়োজন এবং মূল্য রয়েছে।\n\n  আর্গুমেন্টসমূহ:\n  - total_time: একটি u32 যা ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়কে উপস্থাপন করে।\n  - herbs: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপলে দুটি u32 মান রয়েছে যা একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্যকে যথাক্রমে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি u32 যা নির্দিষ্ট সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্যকে উপস্থাপন করে।\n\n  উদাহরণসমূহ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) রিটার্ন করে 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) রিটার্ন করে 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) রিটার্ন করে 30",
      "bg": "Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено времево ограничение от набор от билки, всяка със собствено времево изискване и стойност.\n\nАргументи:\n- total_time: u32, представляващо общото време, достъпно за събиране на билки.\n- herbs: Срез от кортежи, където всеки кортеж съдържа две u32 стойности, представляващи времето, необходимо за събиране на билка и нейната стойност, съответно.\n\nВръща:\n- u32, представляващо максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\nПримери:\n- max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) връща 3\n- max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) връща 100\n- max_herbs_value(5, &[(2, 20), (3, 30)]) връща 30",
      "zh": "计算在给定时间限制内可以收集的草药的最大总价值，每种草药都有其自己的时间需求和价值。\n\n  参数:\n  - total_time: 一个 u32，表示收集草药的总可用时间。\n  - herbs: 一个元组切片，其中每个元组包含两个 u32 值，分别表示收集一种草药所需的时间和其价值。\n\n  返回:\n  - 一个 u32，表示在给定时间内可以收集的草药的最大总价值。\n\n  示例:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 返回 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 返回 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 返回 30",
      "fr": "Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un délai donné à partir d'un ensemble d'herbes, chacune ayant son propre temps requis et sa valeur.\n\n  Arguments:\n  - total_time: Un u32 représentant le temps total disponible pour collecter des herbes.\n  - herbs: Une tranche de tuples, où chaque tuple contient deux valeurs u32 représentant le temps nécessaire pour collecter une herbe et sa valeur, respectivement.\n\n  Renvoie:\n  - Un u32 représentant la valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n  Exemples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) renvoie 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) renvoie 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) renvoie 30",
      "de": "Berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines vorgegebenen Zeitlimits aus einer Menge von Kräutern gesammelt werden können, wobei jedes Kraut seine eigene Zeitanforderung und seinen Wert hat.\n\n  Argumente:\n  - total_time: Ein u32, das die insgesamt verfügbare Zeit zum Sammeln von Kräutern darstellt.\n  - herbs: Ein Slice von Tupeln, wobei jedes Tupel zwei u32-Werte enthält, die die zum Sammeln eines Krauts benötigte Zeit und dessen Wert darstellen.\n\n  Rückgabewerte:\n  - Ein u32, das den maximalen Gesamtwert der Kräuter darstellt, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n  Beispiele:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) gibt 3 zurück\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) gibt 100 zurück\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) gibt 30 zurück",
      "ha": "Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin iyakar lokaci da aka bayar daga saitin ganyayyaki, kowanne yana da bukatar lokaci da ƙimarsa.\n\n  Huɗa:\n  - total_time: Wani u32 da ke wakiltar jimillar lokacin da ake da shi don tattara ganyayyaki.\n  - herbs: Wani yanki na tuples, inda kowanne tuple ke dauke da ƙimar u32 guda biyu da ke wakiltar lokacin da ake buƙata don tattara ganye da ƙimar sa, bi da bi.\n\n  Komawa:\n  - Wani u32 da ke wakiltar mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin lokacin da aka bayar.\n\n  Misalai:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "hi": "हर्ब्स के अधिकतम कुल मूल्य की गणना करता है जो एक निर्धारित समय सीमा के भीतर एक सेट से एकत्र किया जा सकता है, जहाँ प्रत्येक हर्ब के लिए उसका अपना समय आवश्यकता और मूल्य होता है।\n\n  तर्क:\n  - total_time: एक u32 जो हर्ब्स एकत्र करने के लिए उपलब्ध कुल समय का प्रतिनिधित्व करता है।\n  - herbs: ट्यूपल्स की एक स्लाइस, जहाँ प्रत्येक ट्यूपल में दो u32 मान होते हैं जो क्रमशः एक हर्ब को एकत्र करने के लिए आवश्यक समय और उसका मूल्य दर्शाते हैं।\n\n  वापसी मान:\n  - एक u32 जो दिए गए समय के भीतर एकत्र किए जा सकने वाले हर्ब्स के अधिकतम कुल मूल्य का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 लौटाता है\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 लौटाता है\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 लौटाता है",
      "hu": "Kiszámítja a maximálisan összegyűjthető gyógynövények összértékét egy adott időkorláton belül egy olyan gyógynövénykészletből, ahol minden gyógynövénynek megvan a saját időigénye és értéke.\n\n  Argumentumok:\n  - total_time: Egy u32, amely az összes rendelkezésre álló időt jelenti a gyógynövények gyűjtésére.\n  - herbs: Egy szelet tuple, ahol minden tuple két u32 értéket tartalmaz, amelyek egy gyógynövény gyűjtéséhez szükséges időt és annak értékét képviselik.\n\n  Visszatérési érték:\n  - Egy u32, amely a maximálisan összegyűjthető gyógynövények összértékét jelenti az adott időn belül.\n\n  Példák:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) visszaadja 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) visszaadja 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) visszaadja 30"
    },
    "docstring_bertscore": {
      "sq": "0.9983748062223725",
      "hy": "0.9436543211814522",
      "bn": "0.9784162269056059",
      "bg": "0.9864683052919982",
      "zh": "0.9690196194699885",
      "fr": "0.990782358537695",
      "de": "0.9819166901105838",
      "ha": "0.9989180603145029",
      "hi": "0.9877627794852026",
      "hu": "0.9885825270677336"
    }
  },
  {
    "task_id": "Rust/39",
    "prompt": {
      "en": "/*\n  Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "sq": "/*\n  Verifikon saktësinë e një numri ISBN të dhënë.\n\n  Një numër ISBN është një varg i formatuar si \"x-xxx-xxxxx-x\", ku 'x' përfaqëson një shifër, dhe '-' është një ndarës. Shifra e fundit është një shifër kontrolli, e llogaritur si shuma e 9 shifrave të para secila e shumëzuar me pozicionin e tyre (1 deri në 9), modulo 11. Nëse rezultati është 10, shifra kontrolluese është 'X'.\n\n  Argumentet:\n  - isbn: Një varg që përfaqëson një numër ISBN.\n\n  Kthen:\n  - Një përgjigje me varg. Nëse ISBN është i saktë, kthen \"Right\". Përndryshe, kthen numrin e korrigjuar ISBN.\n\n  Shembull:\n  - validate_isbn(\"0-670-82162-4\") kthen \"Right\"\n  - validate_isbn(\"0-670-82162-0\") kthen \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "hy": "/*\n  Ստուգում է տրված ISBN համարի ճշտությունը։\n\n  ISBN համարը տող է, որը ձևաչափված է որպես \"x-xxx-xxxxx-x\", որտեղ 'x'-ը ներկայացնում է թիվ, իսկ '-' նշանը բաժանարար է։ Վերջին թիվը ստուգիչ թիվն է, որը հաշվարկվում է առաջին 9 թվերի գումարը, յուրաքանչյուրը բազմապատկված իրենց դիրքով (1-ից 9), 11-ի մոդուլով։ Եթե արդյունքը 10 է, ապա ստուգիչ թիվը 'X' է։\n\n  Արգումենտներ:\n  - isbn: Տող, որը ներկայացնում է ISBN համարը։\n\n  Վերադարձնում է:\n  - Տողի պատասխան։ Եթե ISBN-ը ճիշտ է, վերադարձնում է \"Right\"։ Հակառակ դեպքում, վերադարձնում է ուղղված ISBN համարը։\n\n  Օրինակ:\n  - validate_isbn(\"0-670-82162-4\") վերադարձնում է \"Right\"\n  - validate_isbn(\"0-670-82162-0\") վերադարձնում է \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "bn": "/*\n  প্রদত্ত একটি ISBN নম্বরের সঠিকতা যাচাই করে।\n\n  একটি ISBN নম্বর একটি স্ট্রিং যা \"x-xxx-xxxxx-x\" ফরম্যাটে থাকে, যেখানে 'x' একটি সংখ্যা নির্দেশ করে, এবং '-' একটি বিভাজক। শেষ সংখ্যা একটি চেক ডিজিট, যা প্রথম 9 সংখ্যার প্রতিটি তাদের অবস্থান (1 থেকে 9) দ্বারা গুণ করে, 11 দ্বারা মডুলো হিসাবে গণনা করা হয়। যদি ফলাফল 10 হয়, তাহলে চেক ডিজিট 'X' হয়।\n\n  আর্গুমেন্টসমূহ:\n  - isbn: একটি স্ট্রিং যা একটি ISBN নম্বর নির্দেশ করে।\n\n  রিটার্নস:\n  - একটি স্ট্রিং প্রতিক্রিয়া। যদি ISBN সঠিক হয়, তাহলে \"Right\" রিটার্ন করে। অন্যথায়, সংশোধিত ISBN নম্বর রিটার্ন করে।\n\n  উদাহরণ:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" রিটার্ন করে\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" রিটার্ন করে\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "bg": "/*\n  Валидира коректността на даден ISBN номер.\n\n  ISBN номерът е низ, форматиран като \"x-xxx-xxxxx-x\", където 'x' представлява цифра, а '-' е разделител. Последната цифра е контролна цифра, изчислена като сумата на първите 9 цифри, всяка умножена по тяхната позиция (от 1 до 9), модуло 11. Ако резултатът е 10, контролната цифра е 'X'.\n\n  Аргументи:\n  - isbn: Низ, представляващ ISBN номер.\n\n  Връща:\n  - Низов отговор. Ако ISBN е коректен, връща \"Right\". В противен случай връща коригирания ISBN номер.\n\n  Пример:\n  - validate_isbn(\"0-670-82162-4\") връща \"Right\"\n  - validate_isbn(\"0-670-82162-0\") връща \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "zh": "/*\n  验证给定的ISBN号码的正确性。\n\n  ISBN号码是一个格式为\"x-xxx-xxxxx-x\"的字符串，其中'x'代表一个数字，'-'是分隔符。最后一位是校验位，计算方法是前9位数字分别乘以其位置（1到9），然后对11取模。如果结果是10，校验位为'X'。\n\n  参数:\n  - isbn: 表示ISBN号码的字符串。\n\n  返回:\n  - 一个字符串响应。如果ISBN正确，返回\"Right\"。否则，返回更正后的ISBN号码。\n\n  示例:\n  - validate_isbn(\"0-670-82162-4\") 返回 \"Right\"\n  - validate_isbn(\"0-670-82162-0\") 返回 \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "fr": "/*\n  Valide la validité d'un numéro ISBN donné.\n\n  Un numéro ISBN est une chaîne formatée comme \"x-xxx-xxxxx-x\", où 'x' représente un chiffre, et '-' est un séparateur. Le dernier chiffre est un chiffre de contrôle, calculé comme la somme des 9 premiers chiffres chacun multiplié par leur position (1 à 9), modulo 11. Si le résultat est 10, le chiffre de contrôle est 'X'.\n\n  Arguments :\n  - isbn : Une chaîne représentant un numéro ISBN.\n\n  Renvoie :\n  - Une réponse sous forme de chaîne. Si l'ISBN est correct, renvoie \"Right\". Sinon, renvoie le numéro ISBN corrigé.\n\n  Exemple :\n  - validate_isbn(\"0-670-82162-4\") renvoie \"Right\"\n  - validate_isbn(\"0-670-82162-0\") renvoie \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "de": "/*\n  Überprüft die Korrektheit einer gegebenen ISBN-Nummer.\n\n  Eine ISBN-Nummer ist eine Zeichenkette im Format \"x-xxx-xxxxx-x\", wobei 'x' eine Ziffer darstellt und '-' ein Trennzeichen ist. Die letzte Ziffer ist eine Prüfziffer, die als Summe der ersten 9 Ziffern berechnet wird, wobei jede Ziffer mit ihrer Position (1 bis 9) multipliziert wird, modulo 11. Wenn das Ergebnis 10 ist, ist die Prüfziffer 'X'.\n\n  Argumente:\n  - isbn: Eine Zeichenkette, die eine ISBN-Nummer darstellt.\n\n  Rückgabewerte:\n  - Eine Zeichenkette als Antwort. Wenn die ISBN korrekt ist, wird \"Right\" zurückgegeben. Andernfalls wird die korrigierte ISBN-Nummer zurückgegeben.\n\n  Beispiel:\n  - validate_isbn(\"0-670-82162-4\") gibt \"Right\" zurück\n  - validate_isbn(\"0-670-82162-0\") gibt \"0-670-82162-4\" zurück\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "ha": "/*\n  Tabbatar da daidaiton lambar ISBN da aka bayar.\n\n  Lambar ISBN ita ce igiyar rubutu da aka tsara kamar \"x-xxx-xxxxx-x\", inda 'x' ke wakiltar lamba, kuma '-' shi ne mai raba. Lambar karshe ita ce lambar duba, ana kiranta ta hanyar tara lambobin farko 9 kowanne an ninka da matsayinsu (1 zuwa 9), modulo 11. Idan sakamakon ya zama 10, lambar dubawa ita ce 'X'.\n\n  Huɗa:\n  - isbn: Wani igiyar rubutu da ke wakiltar lambar ISBN.\n\n  Mayarwa:\n  - Martani na igiyar rubutu. Idan ISBN ɗin daidai ne, yana mayar da \"Right\". In ba haka ba, yana mayar da lambar ISBN da aka gyara.\n\n  Misali:\n  - validate_isbn(\"0-670-82162-4\") yana mayar da \"Right\"\n  - validate_isbn(\"0-670-82162-0\") yana mayar da \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "hi": "/*\n  दिए गए ISBN नंबर की शुद्धता की पुष्टि करता है।\n\n  एक ISBN नंबर एक स्ट्रिंग के रूप में होता है \"x-xxx-xxxxx-x\", जहां 'x' एक अंक का प्रतिनिधित्व करता है, और '-' एक विभाजक है। अंतिम अंक एक चेक अंक होता है, जिसे पहले 9 अंकों के योग के रूप में गणना की जाती है, प्रत्येक को उनकी स्थिति (1 से 9) से गुणा किया जाता है, और फिर 11 से माड्यूलो लिया जाता है। यदि परिणाम 10 है, तो चेक अंक 'X' होता है।\n\n  तर्क:\n  - isbn: एक स्ट्रिंग जो एक ISBN नंबर का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग प्रतिक्रिया। यदि ISBN सही है, तो \"Right\" लौटाता है। अन्यथा, सही किया गया ISBN नंबर लौटाता है।\n\n  उदाहरण:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" लौटाता है\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" लौटाता है\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "hu": "/*\n  Ellenőrzi egy adott ISBN szám helyességét.\n\n  Egy ISBN szám egy \"x-xxx-xxxxx-x\" formátumú karakterlánc, ahol 'x' egy számjegyet jelöl, és '-' egy elválasztó. Az utolsó számjegy egy ellenőrző számjegy, amelyet az első 9 számjegy összegének kiszámításával kapunk, mindegyiket megszorozva a pozíciójával (1-től 9-ig), majd az eredményt 11-gyel osztva. Ha az eredmény 10, az ellenőrző számjegy 'X'.\n\n  Argumentumok:\n  - isbn: Egy karakterlánc, amely egy ISBN számot jelöl.\n\n  Visszatér:\n  - Egy karakterlánc válasz. Ha az ISBN helyes, \"Right\"-ot ad vissza. Ellenkező esetben a javított ISBN számot adja vissza.\n\n  Példa:\n  - validate_isbn(\"0-670-82162-4\") visszaadja \"Right\"\n  - validate_isbn(\"0-670-82162-0\") visszaadja \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9965245642230326",
      "hy": "0.9715932733170576",
      "bn": "0.9757361071743021",
      "bg": "0.9870673745211994",
      "zh": "0.9595799092416865",
      "fr": "0.9832528766838055",
      "de": "0.9713672319434399",
      "ha": "0.9739116871244967",
      "hi": "0.9655972180047574",
      "hu": "0.96078400661152"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}",
    "instruction": {
      "en": "Write a Rust function `fn validate_isbn(isbn: &str) -> String` to solve the following problem:\nValidates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"",
      "sq": "Shkruani një funksion Rust `fn validate_isbn(isbn: &str) -> String` për të zgjidhur problemin e mëposhtëm:\nVerifikon saktësinë e një numri të dhënë ISBN.\n\n  Një numër ISBN është një varg i formatuar si \"x-xxx-xxxxx-x\", ku 'x' përfaqëson një shifër, dhe '-' është një ndarës. Shifra e fundit është një shifër kontrolli, e llogaritur si shuma e 9 shifrave të para secila e shumëzuar me pozicionin e tyre (1 deri në 9), modulo 11. Nëse rezultati është 10, shifra e kontrollit është 'X'.\n\n  Argumentet:\n  - isbn: Një varg që përfaqëson një numër ISBN.\n\n  Kthen:\n  - Një përgjigje me varg. Nëse ISBN është i saktë, kthen \"Right\". Përndryshe, kthen numrin e korrigjuar ISBN.\n\n  Shembull:\n  - validate_isbn(\"0-670-82162-4\") kthen \"Right\"\n  - validate_isbn(\"0-670-82162-0\") kthen \"0-670-82162-4\"",
      "hy": "Գրեք Rust ֆունկցիա `fn validate_isbn(isbn: &str) -> String` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է տրված ISBN համարի ճշտությունը:\n\n  ISBN համարը տող է, որը ձևավորված է որպես \"x-xxx-xxxxx-x\", որտեղ 'x'-ը ներկայացնում է թվանշան, իսկ '-' նշանն է: Վերջին թվանշանը ստուգիչ թվանշան է, որը հաշվարկվում է առաջին 9 թվանշանների գումարով, որոնցից յուրաքանչյուրը բազմապատկվում է իրենց դիրքով (1-ից 9), մոդուլո 11: Եթե արդյունքը 10 է, ապա ստուգիչ թվանշանը 'X' է:\n\n  Արգումենտներ:\n  - isbn: Տող, որը ներկայացնում է ISBN համարը:\n\n  Վերադարձնում է:\n  - Տողային պատասխան: Եթե ISBN-ը ճիշտ է, վերադարձնում է \"Right\": Հակառակ դեպքում, վերադարձնում է ուղղված ISBN համարը:\n\n  Օրինակ:\n  - validate_isbn(\"0-670-82162-4\") վերադարձնում է \"Right\"\n  - validate_isbn(\"0-670-82162-0\") վերադարձնում է \"0-670-82162-4\"",
      "bn": "Rust ফাংশন `fn validate_isbn(isbn: &str) -> String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করে।\n\n  একটি ISBN নম্বর একটি স্ট্রিং যা \"x-xxx-xxxxx-x\" আকারে ফরম্যাট করা থাকে, যেখানে 'x' একটি সংখ্যা নির্দেশ করে, এবং '-' একটি বিভাজক। শেষ সংখ্যা একটি চেক সংখ্যা, যা প্রথম 9 সংখ্যার প্রতিটিকে তাদের অবস্থান (1 থেকে 9) দ্বারা গুণ করে যোগফল হিসেবে গণনা করা হয়, মডুলো 11। যদি ফলাফল 10 হয়, তাহলে চেক সংখ্যা 'X' হয়।\n\n  আর্গুমেন্টসমূহ:\n  - isbn: একটি স্ট্রিং যা একটি ISBN নম্বর নির্দেশ করে।\n\n  রিটার্নস:\n  - একটি স্ট্রিং প্রতিক্রিয়া। যদি ISBN সঠিক হয়, \"Right\" রিটার্ন করে। অন্যথায়, সংশোধিত ISBN নম্বর রিটার্ন করে।\n\n  উদাহরণ:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" রিটার্ন করে\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn validate_isbn(isbn: &str) -> String`, за да решите следния проблем:\nПроверява коректността на даден ISBN номер.\n\n  ISBN номерът е низ, форматиран като \"x-xxx-xxxxx-x\", където 'x' представлява цифра, а '-' е разделител. Последната цифра е контролна цифра, изчислена като сумата на първите 9 цифри, всяка умножена по тяхната позиция (от 1 до 9), модуло 11. Ако резултатът е 10, контролната цифра е 'X'.\n\n  Аргументи:\n  - isbn: Низ, представляващ ISBN номер.\n\n  Връща:\n  - Низов отговор. Ако ISBN е коректен, връща \"Right\". В противен случай връща коригирания ISBN номер.\n\n  Пример:\n  - validate_isbn(\"0-670-82162-4\") връща \"Right\"\n  - validate_isbn(\"0-670-82162-0\") връща \"0-670-82162-4\"",
      "zh": "编写一个 Rust 函数 `fn validate_isbn(isbn: &str) -> String` 来解决以下问题：\n验证给定的 ISBN 号码的正确性。\n\nISBN 号码是一个格式为 \"x-xxx-xxxxx-x\" 的字符串，其中 'x' 代表一个数字，'-' 是分隔符。最后一位数字是校验位，计算方法是前 9 位数字分别乘以它们的位置（1 到 9），然后对 11 取模。如果结果是 10，校验位为 'X'。\n\n参数：\n- isbn: 表示 ISBN 号码的字符串。\n\n返回：\n- 一个字符串响应。如果 ISBN 是正确的，返回 \"Right\"。否则，返回更正后的 ISBN 号码。\n\n示例：\n- validate_isbn(\"0-670-82162-4\") 返回 \"Right\"\n- validate_isbn(\"0-670-82162-0\") 返回 \"0-670-82162-4\"",
      "fr": "Écrire une fonction Rust `fn validate_isbn(isbn: &str) -> String` pour résoudre le problème suivant :\nValide la validité d'un numéro ISBN donné.\n\n  Un numéro ISBN est une chaîne formatée comme \"x-xxx-xxxxx-x\", où 'x' représente un chiffre, et '-' est un séparateur. Le dernier chiffre est un chiffre de contrôle, calculé comme la somme des 9 premiers chiffres chacun multiplié par leur position (1 à 9), modulo 11. Si le résultat est 10, le chiffre de contrôle est 'X'.\n\n  Arguments :\n  - isbn : Une chaîne représentant un numéro ISBN.\n\n  Renvoie :\n  - Une réponse sous forme de chaîne. Si l'ISBN est correct, renvoie \"Right\". Sinon, renvoie le numéro ISBN corrigé.\n\n  Exemple :\n  - validate_isbn(\"0-670-82162-4\") renvoie \"Right\"\n  - validate_isbn(\"0-670-82162-0\") renvoie \"0-670-82162-4\"",
      "de": "Schreiben Sie eine Rust-Funktion `fn validate_isbn(isbn: &str) -> String`, um das folgende Problem zu lösen:\nValidiert die Korrektheit einer gegebenen ISBN-Nummer.\n\n  Eine ISBN-Nummer ist eine Zeichenkette im Format \"x-xxx-xxxxx-x\", wobei 'x' eine Ziffer darstellt und '-' ein Trennzeichen ist. Die letzte Ziffer ist eine Prüfziffer, berechnet als die Summe der ersten 9 Ziffern, jeweils multipliziert mit ihrer Position (1 bis 9), modulo 11. Wenn das Ergebnis 10 ist, ist die Prüfziffer 'X'.\n\n  Argumente:\n  - isbn: Eine Zeichenkette, die eine ISBN-Nummer darstellt.\n\n  Rückgabewerte:\n  - Eine Zeichenkette als Antwort. Wenn die ISBN korrekt ist, wird \"Right\" zurückgegeben. Andernfalls wird die korrigierte ISBN-Nummer zurückgegeben.\n\n  Beispiel:\n  - validate_isbn(\"0-670-82162-4\") gibt \"Right\" zurück\n  - validate_isbn(\"0-670-82162-0\") gibt \"0-670-82162-4\" zurück",
      "ha": "Rubuta aikin Rust `fn validate_isbn(isbn: &str) -> String` don warware matsalar mai zuwa:\nTantance ingancin lambar ISBN da aka bayar.\n\n  Lambar ISBN wata igiya ce da aka tsara a matsayin \"x-xxx-xxxxx-x\", inda 'x' ke wakiltar lamba, kuma '-' mai raba ne. Lambar karshe ita ce lambar duba, da aka lasafta a matsayin jumlar lambobi 9 na farko kowanne ninka da matsayinsa (1 zuwa 9), modulo 11. Idan sakamakon ya zama 10, lambar duba ita ce 'X'.\n\n  Huɗoɗi:\n  - isbn: Igiya da ke wakiltar lambar ISBN.\n\n  Komawa:\n  - Martani na igiya. Idan ISBN daidai ne, yana dawowa \"Right\". In ba haka ba, yana dawowa da lambar ISBN da aka gyara.\n\n  Misali:\n  - validate_isbn(\"0-670-82162-4\") yana dawowa \"Right\"\n  - validate_isbn(\"0-670-82162-0\") yana dawowa \"0-670-82162-4\"",
      "hi": "Rust फ़ंक्शन `fn validate_isbn(isbn: &str) -> String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए ISBN नंबर की शुद्धता की जाँच करता है।\n\n  एक ISBN नंबर एक स्ट्रिंग के रूप में स्वरूपित होता है \"x-xxx-xxxxx-x\", जहाँ 'x' एक अंक का प्रतिनिधित्व करता है, और '-' एक विभाजक है। अंतिम अंक एक जाँच अंक है, जो पहले 9 अंकों के योग के रूप में गणना की जाती है, प्रत्येक को उनकी स्थिति (1 से 9) से गुणा किया जाता है, और 11 से माड्यूलो किया जाता है। यदि परिणाम 10 है, तो जाँच अंक 'X' होता है।\n\n  तर्क:\n  - isbn: एक स्ट्रिंग जो एक ISBN नंबर का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग प्रतिक्रिया। यदि ISBN सही है, तो \"Right\" लौटाता है। अन्यथा, सही किया गया ISBN नंबर लौटाता है।\n\n  उदाहरण:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" लौटाता है\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" लौटाता है",
      "hu": "Írj egy Rust függvényt `fn validate_isbn(isbn: &str) -> String` a következő probléma megoldására:\nEllenőrzi egy adott ISBN szám helyességét.\n\n  Egy ISBN szám egy \"x-xxx-xxxxx-x\" formátumú string, ahol az 'x' egy számjegyet jelöl, és a '-' egy elválasztó. Az utolsó számjegy egy ellenőrző számjegy, amelyet az első 9 számjegy összegéből számítanak ki, mindegyiket megszorozva a pozíciójával (1-től 9-ig), majd 11-gyel osztva. Ha az eredmény 10, az ellenőrző számjegy 'X'.\n\n  Argumentumok:\n  - isbn: Egy string, amely egy ISBN számot jelöl.\n\n  Visszatérési érték:\n  - Egy string válasz. Ha az ISBN helyes, \"Right\"-ot ad vissza. Ellenkező esetben a javított ISBN számot adja vissza.\n\n  Példa:\n  - validate_isbn(\"0-670-82162-4\") visszaadja \"Right\"\n  - validate_isbn(\"0-670-82162-0\") visszaadja \"0-670-82162-4\""
    },
    "instruction_bertscore": {
      "sq": "0.9948407744829998",
      "hy": "0.9800094411918868",
      "bn": "0.9784768091718216",
      "bg": "0.9861052089554665",
      "zh": "0.9665013834992282",
      "fr": "0.9869984497789803",
      "de": "0.9773241570706761",
      "ha": "0.9838034801000342",
      "hi": "0.975085791306794",
      "hu": "0.9620135286701259"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(validate_isbn(\"0-670-82162-4\"), \"Right\");\n        assert_eq!(validate_isbn(\"0-670-82162-0\"), \"0-670-82162-4\");\n        assert_eq!(validate_isbn(\"0-123-45678-9\"), \"Right\");\n        assert_eq!(validate_isbn(\"1-234-56789-X\"), \"Right\");\n    }\n    \n\n}",
    "entry_point": "validate_isbn",
    "signature": "fn validate_isbn(isbn: &str) -> String",
    "docstring": {
      "en": "Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"",
      "sq": "Kontrollon saktësinë e një numri të dhënë ISBN.\n\n  Një numër ISBN është një varg i formatuar si \"x-xxx-xxxxx-x\", ku 'x' përfaqëson një shifër, dhe '-' është një ndarës. Shifra e fundit është një shifër kontrolli, e llogaritur si shuma e 9 shifrave të para secila e shumëzuar me pozicionin e tyre (1 deri në 9), modulo 11. Nëse rezultati është 10, shifra kontrolluese është 'X'.\n\n  Argumentet:\n  - isbn: Një varg që përfaqëson një numër ISBN.\n\n  Kthen:\n  - Një përgjigje me varg. Nëse ISBN është i saktë, kthen \"Right\". Përndryshe, kthen numrin e korrigjuar ISBN.\n\n  Shembull:\n  - validate_isbn(\"0-670-82162-4\") kthen \"Right\"\n  - validate_isbn(\"0-670-82162-0\") kthen \"0-670-82162-4\"",
      "hy": "Ստուգում է տրված ISBN համարի ճշտությունը։\n\n  ISBN համարը տող է, որը ձևավորված է որպես \"x-xxx-xxxxx-x\", որտեղ 'x'-ը ներկայացնում է թվանշան, իսկ '-' նշանը բաժանարար է։ Վերջին թվանշանը ստուգիչ թվանշան է, որը հաշվարկվում է առաջին 9 թվանշանների գումարը, որոնցից յուրաքանչյուրը բազմապատկվում է իրենց դիրքով (1-ից 9), և արդյունքում ստացված գումարը բաժանվում է 11-ի։ Եթե արդյունքը 10 է, ապա ստուգիչ թվանշանը 'X' է։\n\n  Արձանագրություններ:\n  - isbn: Տող, որը ներկայացնում է ISBN համարը։\n\n  Վերադարձնում է:\n  - Տողային պատասխան։ Եթե ISBN համարը ճիշտ է, վերադարձնում է \"Right\"։ Հակառակ դեպքում, վերադարձնում է ուղղված ISBN համարը։\n\n  Օրինակ:\n  - validate_isbn(\"0-670-82162-4\") վերադարձնում է \"Right\"\n  - validate_isbn(\"0-670-82162-0\") վերադարձնում է \"0-670-82162-4\"",
      "bn": "একটি প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করে।\n\nএকটি ISBN নম্বর একটি স্ট্রিং যা \"x-xxx-xxxxx-x\" আকারে বিন্যস্ত হয়, যেখানে 'x' একটি সংখ্যা নির্দেশ করে, এবং '-' একটি বিভাজক। শেষ সংখ্যা একটি যাচাইকরণ সংখ্যা, যা প্রথম 9 সংখ্যার প্রতিটি তাদের অবস্থান (1 থেকে 9) দ্বারা গুণ করে, 11 দ্বারা ভাগশেষ হিসাবে গণনা করা হয়। যদি ফলাফল 10 হয়, তাহলে যাচাইকরণ সংখ্যা 'X' হয়।\n\nআর্গুমেন্টস:\n- isbn: একটি স্ট্রিং যা একটি ISBN নম্বর উপস্থাপন করে।\n\nরিটার্নস:\n- একটি স্ট্রিং প্রতিক্রিয়া। যদি ISBN সঠিক হয়, তাহলে \"Right\" রিটার্ন করে। অন্যথায়, সংশোধিত ISBN নম্বর রিটার্ন করে।\n\nউদাহরণ:\n- validate_isbn(\"0-670-82162-4\") \"Right\" রিটার্ন করে\n- validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" রিটার্ন করে",
      "bg": "Проверява коректността на даден ISBN номер.\n\nISBN номерът е низ във формат \"x-xxx-xxxxx-x\", където 'x' представлява цифра, а '-' е разделител. Последната цифра е контролна цифра, изчислена като сумата от първите 9 цифри, всяка умножена по позицията си (от 1 до 9), модул 11. Ако резултатът е 10, контролната цифра е 'X'.\n\nАргументи:\n- isbn: Низ, представляващ ISBN номер.\n\nВръща:\n- Низов отговор. Ако ISBN е коректен, връща \"Right\". В противен случай връща коригирания ISBN номер.\n\nПример:\n- validate_isbn(\"0-670-82162-4\") връща \"Right\"\n- validate_isbn(\"0-670-82162-0\") връща \"0-670-82162-4\"",
      "zh": "验证给定的 ISBN 号码的正确性。\n\nISBN 号码是一个格式为 \"x-xxx-xxxxx-x\" 的字符串，其中 'x' 代表一个数字，'-' 是分隔符。最后一位数字是校验位，计算方法是前 9 位数字分别乘以其位置（1 到 9），然后对 11 取模。如果结果是 10，校验位为 'X'。\n\n参数：\n- isbn: 表示 ISBN 号码的字符串。\n\n返回：\n- 一个字符串响应。如果 ISBN 正确，返回 \"Right\"。否则，返回更正后的 ISBN 号码。\n\n示例：\n- validate_isbn(\"0-670-82162-4\") 返回 \"Right\"\n- validate_isbn(\"0-670-82162-0\") 返回 \"0-670-82162-4\"",
      "fr": "Valide la validité d'un numéro ISBN donné.\n\n  Un numéro ISBN est une chaîne formatée comme \"x-xxx-xxxxx-x\", où 'x' représente un chiffre, et '-' est un séparateur. Le dernier chiffre est un chiffre de contrôle, calculé comme la somme des 9 premiers chiffres chacun multiplié par leur position (1 à 9), modulo 11. Si le résultat est 10, le chiffre de contrôle est 'X'.\n\n  Arguments:\n  - isbn: Une chaîne représentant un numéro ISBN.\n\n  Renvoie:\n  - Une réponse sous forme de chaîne. Si l'ISBN est correct, renvoie \"Right\". Sinon, renvoie le numéro ISBN corrigé.\n\n  Exemple:\n  - validate_isbn(\"0-670-82162-4\") renvoie \"Right\"\n  - validate_isbn(\"0-670-82162-0\") renvoie \"0-670-82162-4\"",
      "de": "Validiert die Korrektheit einer gegebenen ISBN-Nummer.\n\n  Eine ISBN-Nummer ist eine Zeichenkette im Format \"x-xxx-xxxxx-x\", wobei 'x' eine Ziffer darstellt und '-' ein Trennzeichen ist. Die letzte Ziffer ist eine Prüfziffer, die als Summe der ersten 9 Ziffern berechnet wird, wobei jede Ziffer mit ihrer Position (1 bis 9) multipliziert wird, modulo 11. Wenn das Ergebnis 10 ist, ist die Prüfziffer 'X'.\n\n  Argumente:\n  - isbn: Eine Zeichenkette, die eine ISBN-Nummer darstellt.\n\n  Rückgabewerte:\n  - Eine Zeichenkettenantwort. Wenn die ISBN korrekt ist, wird \"Right\" zurückgegeben. Andernfalls wird die korrigierte ISBN-Nummer zurückgegeben.\n\n  Beispiel:\n  - validate_isbn(\"0-670-82162-4\") gibt \"Right\" zurück\n  - validate_isbn(\"0-670-82162-0\") gibt \"0-670-82162-4\" zurück",
      "ha": "Tabbatar da daidaiton lambar ISBN da aka bayar.\n\n  Lambar ISBN wata igiya ce da aka tsara a matsayin \"x-xxx-xxxxx-x\", inda 'x' ke wakiltar wata lamba, kuma '-' yana matsayin mai raba. Lambar karshe ita ce lambar duba, da aka lasafta a matsayin jumlar lambobin farko 9 kowanne an ninka da matsayinsa (1 zuwa 9), modulo 11. Idan sakamakon ya zama 10, lambar duba ita ce 'X'.\n\n  Huɗa:\n  - isbn: Wata igiya da ke wakiltar lambar ISBN.\n\n  Komawa:\n  - Wata amsa ta igiya. Idan ISBN ya yi daidai, yana dawowa \"Right\". In ba haka ba, yana dawowa da lambar ISBN da aka gyara.\n\n  Misali:\n  - validate_isbn(\"0-670-82162-4\") yana dawowa \"Right\"\n  - validate_isbn(\"0-670-82162-0\") yana dawowa \"0-670-82162-4\"",
      "hi": "दिए गए ISBN संख्या की शुद्धता की पुष्टि करता है।\n\n  एक ISBN संख्या \"x-xxx-xxxxx-x\" के रूप में स्वरूपित एक स्ट्रिंग होती है, जहाँ 'x' एक अंक का प्रतिनिधित्व करता है, और '-' एक विभाजक है। अंतिम अंक एक जाँच अंक होता है, जिसे पहले 9 अंकों के योग के रूप में गणना की जाती है, प्रत्येक को उनकी स्थिति (1 से 9) से गुणा किया जाता है, और फिर 11 से माड्यूलो लिया जाता है। यदि परिणाम 10 है, तो जाँच अंक 'X' होता है।\n\n  तर्क:\n  - isbn: एक स्ट्रिंग जो एक ISBN संख्या का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग प्रतिक्रिया। यदि ISBN सही है, तो \"Right\" लौटाता है। अन्यथा, सही किया गया ISBN संख्या लौटाता है।\n\n  उदाहरण:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" लौटाता है\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" लौटाता है",
      "hu": "Egy adott ISBN szám helyességét ellenőrzi.\n\n  Egy ISBN szám egy \"x-xxx-xxxxx-x\" formátumú karakterlánc, ahol az 'x' egy számjegyet jelöl, és a '-' egy elválasztó. Az utolsó számjegy egy ellenőrző számjegy, amelyet az első 9 számjegy és azok pozíciójának (1-től 9-ig) szorzatának összege, modulo 11 alapján számítanak ki. Ha az eredmény 10, az ellenőrző számjegy 'X'.\n\n  Argumentumok:\n  - isbn: Egy karakterlánc, amely egy ISBN számot jelöl.\n\n  Visszatérési érték:\n  - Egy karakterlánc válasz. Ha az ISBN helyes, \"Right\"-ot ad vissza. Ellenkező esetben a javított ISBN számot adja vissza.\n\n  Példa:\n  - validate_isbn(\"0-670-82162-4\") visszaadja \"Right\"\n  - validate_isbn(\"0-670-82162-0\") visszaadja \"0-670-82162-4\""
    },
    "docstring_bertscore": {
      "sq": "0.9900299466543349",
      "hy": "0.9471720652295801",
      "bn": "0.9681468375757212",
      "bg": "0.9768653208904855",
      "zh": "0.9633570645674459",
      "fr": "0.9847567072986206",
      "de": "0.9765520807795935",
      "ha": "0.9791261318874246",
      "hi": "0.9700999701124372",
      "hu": "0.95558644543098"
    }
  },
  {
    "task_id": "Rust/40",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve që qëndrojnë në një rreth, në mënyrë që pas 'm' kalimesh, topi të kthehet te studenti origjinal.\n\n  Argumentet:\n  - n: Numri i studentëve në rreth. Është një numër i plotë ku 3 <= n <= 30.\n  - m: Numri i herëve që topi kalohet. Është një numër i plotë ku 1 <= m <= 30.\n\n  Kthen:\n  - Numri i sekuencave të veçanta të kalimit që kthejnë topin te studenti fillestar pas 'm' kalimesh.\n\n  Shembuj:\n  - count_passing_ways(3, 3) kthen 2\n  - count_passing_ways(4, 2) kthen 4\n  - count_passing_ways(5, 5) kthen 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է տարբեր եղանակների քանակը, որով գնդակը կարող է փոխանցվել 'n' ուսանողների միջև, ովքեր կանգնած են շրջանաձև, այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա սկզբնական ուսանողին:\n\n  Արգումենտներ:\n  - n: Ուսանողների քանակը շրջանաձև: Այն ամբողջ թիվ է, որտեղ 3 <= n <= 30:\n  - m: Գնդակի փոխանցումների քանակը: Այն ամբողջ թիվ է, որտեղ 1 <= m <= 30:\n\n  Վերադարձնում է:\n  - Տարբեր փոխանցումների հաջորդականությունների քանակը, որոնք 'm' փոխանցումներից հետո գնդակը վերադարձնում են սկզբնական ուսանողին:\n\n  Օրինակներ:\n  - count_passing_ways(3, 3) վերադարձնում է 2\n  - count_passing_ways(4, 2) վերադարձնում է 4\n  - count_passing_ways(5, 5) վերադարձնում է 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "bn": "/*\n  'n' জন শিক্ষার্থী একটি বৃত্তে দাঁড়িয়ে আছে, তাদের মধ্যে বলটি পাস করার বিভিন্ন উপায় গণনা করে, যাতে 'm' বার পাস করার পর বলটি মূল শিক্ষার্থীর কাছে ফিরে আসে।\n\n  আর্গুমেন্টসমূহ:\n  - n: বৃত্তে শিক্ষার্থীর সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 3 <= n <= 30।\n  - m: বলটি পাস করার সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 1 <= m <= 30।\n\n  রিটার্ন করে:\n  - আলাদা পাসিং ক্রমের সংখ্যা যা 'm' বার পাস করার পর বলটি শুরু শিক্ষার্থীর কাছে ফিরে আসে।\n\n  উদাহরণসমূহ:\n  - count_passing_ways(3, 3) রিটার্ন করে 2\n  - count_passing_ways(4, 2) রিটার্ন করে 4\n  - count_passing_ways(5, 5) রিটার্ন করে 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32",
      "bg": "/*\n  Изчислява броя на различните начини за предаване на топка между 'n' ученици, стоящи в кръг, така че след 'm' предавания топката да се върне при оригиналния ученик.\n\n  Аргументи:\n  - n: Броят на учениците в кръга. Това е цяло число, където 3 <= n <= 30.\n  - m: Броят на предаванията на топката. Това е цяло число, където 1 <= m <= 30.\n\n  Връща:\n  - Броят на различните последователности на предаване, които връщат топката при началния ученик след 'm' предавания.\n\n  Примери:\n  - count_passing_ways(3, 3) връща 2\n  - count_passing_ways(4, 2) връща 4\n  - count_passing_ways(5, 5) връща 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "zh": "/*\n  计算在一个圆圈中有 'n' 个学生传球的不同方式数量，使得经过 'm' 次传球后，球返回到原来的学生。\n\n  参数:\n  - n: 圆圈中的学生数量。它是一个整数，3 <= n <= 30。\n  - m: 球被传递的次数。它是一个整数，1 <= m <= 30。\n\n  返回:\n  - 在 'm' 次传球后将球返回到起始学生的不同传球序列的数量。\n\n  示例:\n  - count_passing_ways(3, 3) 返回 2\n  - count_passing_ways(4, 2) 返回 4\n  - count_passing_ways(5, 5) 返回 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre de façons différentes de passer un ballon parmi 'n' étudiants debout en cercle, de telle sorte qu'après 'm' passes, le ballon retourne à l'étudiant d'origine.\n\n  Arguments:\n  - n: Le nombre d'étudiants dans le cercle. C'est un entier où 3 <= n <= 30.\n  - m: Le nombre de fois que le ballon est passé. C'est un entier où 1 <= m <= 30.\n\n  Retourne:\n  - Le nombre de séquences de passes distinctes qui ramènent le ballon à l'étudiant de départ après 'm' passes.\n\n  Exemples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, weiterzugeben, sodass nach 'm' Weitergaben der Ball zum ursprünglichen Schüler zurückkehrt.\n\n  Argumente:\n  - n: Die Anzahl der Schüler im Kreis. Es ist eine ganze Zahl, wobei 3 <= n <= 30.\n  - m: Die Anzahl der Weitergaben des Balls. Es ist eine ganze Zahl, wobei 1 <= m <= 30.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Weitergabesequenzen, die den Ball nach 'm' Weitergaben zum Startschüler zurückbringen.\n\n  Beispiele:\n  - count_passing_ways(3, 3) gibt 2 zurück\n  - count_passing_ways(4, 2) gibt 4 zurück\n  - count_passing_ways(5, 5) gibt 6 zurück\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "ha": "/*\n  Lissafa adadin hanyoyi daban-daban don wuce kwallo tsakanin 'n' ɗalibai da ke tsaye a cikin da'ira, ta yadda bayan 'm' wucewa, kwallon ta koma ga ɗalibin asali.\n\n  Huɗɗa:\n  - n: Yawan ɗalibai a cikin da'ira. Yana da lamba inda 3 <= n <= 30.\n  - m: Yawan lokutan da aka wuce kwallon. Yana da lamba inda 1 <= m <= 30.\n\n  Mayarwa:\n  - Adadin jerin wucewa daban-daban da ke mayar da kwallon ga ɗalibin farawa bayan 'm' wucewa.\n\n  Misalai:\n  - count_passing_ways(3, 3) yana mayar da 2\n  - count_passing_ways(4, 2) yana mayar da 4\n  - count_passing_ways(5, 5) yana mayar da 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "hi": "/*\n  'n' छात्रों के बीच एक गोला पास करने के विभिन्न तरीकों की संख्या की गणना करता है, जो एक वृत्त में खड़े होते हैं, ताकि 'm' पास के बाद, गोला मूल छात्र के पास वापस आ जाए।\n\n  तर्क:\n  - n: वृत्त में छात्रों की संख्या। यह एक पूर्णांक है जहाँ 3 <= n <= 30।\n  - m: गोला पास करने की संख्या। यह एक पूर्णांक है जहाँ 1 <= m <= 30।\n\n  लौटाता है:\n  - विशिष्ट पासिंग अनुक्रमों की संख्या जो 'm' पास के बाद गोला को प्रारंभिक छात्र के पास वापस लाते हैं।\n\n  उदाहरण:\n  - count_passing_ways(3, 3) 2 लौटाता है\n  - count_passing_ways(4, 2) 4 लौटाता है\n  - count_passing_ways(5, 5) 6 लौटाता है\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32",
      "hu": "/*\n  Kiszámítja, hányféleképpen lehet egy labdát elpasszolni 'n' diák között, akik körben állnak, úgy, hogy 'm' passz után a labda visszatér az eredeti diákhoz.\n\n  Argumentumok:\n  - n: A körben álló diákok száma. Ez egy egész szám, ahol 3 <= n <= 30.\n  - m: Az elpasszolások száma. Ez egy egész szám, ahol 1 <= m <= 30.\n\n  Visszatér:\n  - Azoknak a különböző passzolási sorozatoknak a száma, amelyek 'm' passz után visszajuttatják a labdát a kezdő diákhoz.\n\n  Példák:\n  - count_passing_ways(3, 3) visszaadja 2\n  - count_passing_ways(4, 2) visszaadja 4\n  - count_passing_ways(5, 5) visszaadja 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9988912452130633",
      "hy": "0.978757871160986",
      "bn": "0.9756840660144711",
      "bg": "0.9781011991212846",
      "zh": "0.9744583179331048",
      "fr": "0.9949655143622897",
      "de": "0.9834173426393024",
      "ha": "0.9786206175676908",
      "hi": "0.9791938648473575",
      "hu": "0.9777986850509685"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_passing_ways(n: i32, m: i32) -> i32` to solve the following problem:\nCalculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "sq": "Shkruani një funksion në Rust `fn count_passing_ways(n: i32, m: i32) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve që qëndrojnë në një rreth, në mënyrë që pas 'm' pasimeve, topi të kthehet te studenti origjinal.\n\n  Argumentet:\n  - n: Numri i studentëve në rreth. Është një numër i plotë ku 3 <= n <= 30.\n  - m: Numri i herëve që topi është kaluar. Është një numër i plotë ku 1 <= m <= 30.\n\n  Kthen:\n  - Numri i sekuencave të dallueshme të pasimeve që kthejnë topin te studenti fillestar pas 'm' pasimeve.\n\n  Shembuj:\n  - count_passing_ways(3, 3) kthen 2\n  - count_passing_ways(4, 2) kthen 4\n  - count_passing_ways(5, 5) kthen 6",
      "hy": "Գրեք Rust ֆունկցիա `fn count_passing_ways(n: i32, m: i32) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է գնդակը 'n' ուսանողների միջև շրջանաձև կանգնած փոխանցելու տարբեր եղանակների քանակը, այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա սկզբնական ուսանողին:\n\n  Արձանագրություններ:\n  - n: Ուսանողների քանակը շրջանի մեջ: Դա ամբողջ թիվ է, որտեղ 3 <= n <= 30:\n  - m: Գնդակը փոխանցելու քանակը: Դա ամբողջ թիվ է, որտեղ 1 <= m <= 30:\n\n  Վերադարձնում է:\n  - Տարբեր փոխանցման հաջորդականությունների քանակը, որոնք վերադարձնում են գնդակը մեկնարկային ուսանողին 'm' փոխանցումներից հետո:\n\n  Օրինակներ:\n  - count_passing_ways(3, 3) վերադարձնում է 2\n  - count_passing_ways(4, 2) վերադարձնում է 4\n  - count_passing_ways(5, 5) վերադարձնում է 6",
      "bn": "Rust ফাংশন `fn count_passing_ways(n: i32, m: i32) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বলকে 'n' জন ছাত্রের মধ্যে একটি বৃত্তে এমনভাবে পাস করার বিভিন্ন পদ্ধতির সংখ্যা গণনা করে, যাতে 'm' বার পাস করার পর বলটি মূল ছাত্রের কাছে ফিরে আসে।\n\n  আর্গুমেন্টসমূহ:\n  - n: বৃত্তে ছাত্রদের সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 3 <= n <= 30।\n  - m: বলটি পাস করার সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 1 <= m <= 30।\n\n  রিটার্ন করে:\n  - স্বতন্ত্র পাসিং সিকোয়েন্সের সংখ্যা যা 'm' বার পাস করার পর বলটি শুরু ছাত্রের কাছে ফিরে আসে।\n\n  উদাহরণসমূহ:\n  - count_passing_ways(3, 3) রিটার্ন করে 2\n  - count_passing_ways(4, 2) রিটার্ন করে 4\n  - count_passing_ways(5, 5) রিটার্ন করে 6",
      "bg": "Напишете функция на Rust `fn count_passing_ways(n: i32, m: i32) -> i32`, за да решите следния проблем:\nИзчислява броя на различните начини за подаване на топка между 'n' ученици, стоящи в кръг, така че след 'm' подавания топката да се върне при оригиналния ученик.\n\n  Аргументи:\n  - n: Броят на учениците в кръга. Това е цяло число, където 3 <= n <= 30.\n  - m: Броят на пъти, когато топката се подава. Това е цяло число, където 1 <= m <= 30.\n\n  Връща:\n  - Броят на различните последователности на подаване, които връщат топката на началния ученик след 'm' подавания.\n\n  Примери:\n  - count_passing_ways(3, 3) връща 2\n  - count_passing_ways(4, 2) връща 4\n  - count_passing_ways(5, 5) връща 6",
      "zh": "编写一个 Rust 函数 `fn count_passing_ways(n: i32, m: i32) -> i32` 来解决以下问题：\n计算在一个圆圈中 'n' 个学生之间传球的不同方式的数量，使得经过 'm' 次传球后，球返回到原来的学生。\n\n  参数:\n  - n: 圆圈中的学生数量。它是一个整数，其中 3 <= n <= 30。\n  - m: 球被传递的次数。它是一个整数，其中 1 <= m <= 30。\n\n  返回:\n  - 返回球经过 'm' 次传递后回到起始学生的不同传球序列的数量。\n\n  示例:\n  - count_passing_ways(3, 3) 返回 2\n  - count_passing_ways(4, 2) 返回 4\n  - count_passing_ways(5, 5) 返回 6",
      "fr": "Écrire une fonction Rust `fn count_passing_ways(n: i32, m: i32) -> i32` pour résoudre le problème suivant :\nCalcule le nombre de façons différentes de passer un ballon parmi 'n' étudiants se tenant en cercle, de telle sorte qu'après 'm' passes, le ballon retourne à l'étudiant d'origine.\n\n  Arguments :\n  - n : Le nombre d'étudiants dans le cercle. C'est un entier où 3 <= n <= 30.\n  - m : Le nombre de fois que le ballon est passé. C'est un entier où 1 <= m <= 30.\n\n  Renvoie :\n  - Le nombre de séquences de passes distinctes qui ramènent le ballon à l'étudiant de départ après 'm' passes.\n\n  Exemples :\n  - count_passing_ways(3, 3) renvoie 2\n  - count_passing_ways(4, 2) renvoie 4\n  - count_passing_ways(5, 5) renvoie 6",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_passing_ways(n: i32, m: i32) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, zu passen, sodass nach 'm' Pässen der Ball zum ursprünglichen Schüler zurückkehrt.\n\n  Argumente:\n  - n: Die Anzahl der Schüler im Kreis. Es ist eine ganze Zahl, wobei 3 <= n <= 30.\n  - m: Die Anzahl der Male, die der Ball gepasst wird. Es ist eine ganze Zahl, wobei 1 <= m <= 30.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Pass-Sequenzen, die den Ball nach 'm' Pässen zum Startschüler zurückbringen.\n\n  Beispiele:\n  - count_passing_ways(3, 3) gibt 2 zurück\n  - count_passing_ways(4, 2) gibt 4 zurück\n  - count_passing_ways(5, 5) gibt 6 zurück",
      "ha": "Rubuta aikin Rust `fn count_passing_ways(n: i32, m: i32) -> i32` don warware matsalar mai zuwa:\nYana ƙididdige yawan hanyoyin daban-daban na wuce kwallo tsakanin 'n' ɗalibai da ke tsaye a cikin da'ira, ta yadda bayan 'm' wucewa, kwallon ta dawo ga ɗalibin asali.\n\n  Huɗɗa:\n  - n: Yawan ɗalibai a cikin da'ira. Yana da tsari inda 3 <= n <= 30.\n  - m: Yawan lokutan da aka wuce kwallon. Yana da tsari inda 1 <= m <= 30.\n\n  Komawa:\n  - Yawan jerin hanyoyin wucewa daban-daban da ke dawo da kwallon ga ɗalibin farawa bayan 'm' wucewa.\n\n  Misalai:\n  - count_passing_ways(3, 3) yana dawowa 2\n  - count_passing_ways(4, 2) yana dawowa 4\n  - count_passing_ways(5, 5) yana dawowa 6",
      "hi": "Rust फ़ंक्शन `fn count_passing_ways(n: i32, m: i32) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n'गणना करें कि 'n' छात्रों के बीच एक गोला पास करने के कितने विभिन्न तरीके हैं जो एक वृत्त में खड़े हैं, ताकि 'm' पास के बाद, गोला मूल छात्र के पास वापस आ जाए।\n\n  तर्क:\n  - n: वृत्त में छात्रों की संख्या। यह एक पूर्णांक है जहाँ 3 <= n <= 30।\n  - m: गोला पास करने की संख्या। यह एक पूर्णांक है जहाँ 1 <= m <= 30।\n\n  लौटाता है:\n  - विशिष्ट पासिंग अनुक्रमों की संख्या जो 'm' पास के बाद गोला को प्रारंभिक छात्र के पास वापस लाते हैं।\n\n  उदाहरण:\n  - count_passing_ways(3, 3) 2 लौटाता है\n  - count_passing_ways(4, 2) 4 लौटाता है\n  - count_passing_ways(5, 5) 6 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_passing_ways(n: i32, m: i32) -> i32` a következő probléma megoldására:\nKiszámítja, hogy hány különböző módon lehet átadni egy labdát 'n' diák között, akik körben állnak, úgy, hogy 'm' passzolás után a labda visszatér az eredeti diákhoz.\n\n  Argumentumok:\n  - n: A körben álló diákok száma. Ez egy egész szám, ahol 3 <= n <= 30.\n  - m: A labda passzolásának száma. Ez egy egész szám, ahol 1 <= m <= 30.\n\n  Visszatérési érték:\n  - Azoknak a különböző passzolási sorozatoknak a száma, amelyek 'm' passzolás után visszajuttatják a labdát a kezdő diákhoz.\n\n  Példák:\n  - count_passing_ways(3, 3) visszaadja 2\n  - count_passing_ways(4, 2) visszaadja 4\n  - count_passing_ways(5, 5) visszaadja 6"
    },
    "instruction_bertscore": {
      "sq": "0.9932076354901309",
      "hy": "0.9784615146324819",
      "bn": "0.9776840753211113",
      "bg": "0.9873923338245726",
      "zh": "0.9789656385395484",
      "fr": "0.995496850631558",
      "de": "0.9822344987202396",
      "ha": "0.964991593972982",
      "hi": "0.9604842733665383",
      "hu": "0.9829646640009239"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_passing_ways(3, 3), 2);\n        assert_eq!(count_passing_ways(4, 2), 2);\n        assert_eq!(count_passing_ways(5, 5), 2);    \n        assert_eq!(count_passing_ways(10, 3), 0);    \n        assert_eq!(count_passing_ways(30, 10), 252);    \n    }\n    \n\n}",
    "entry_point": "count_passing_ways",
    "signature": "fn count_passing_ways(n: i32, m: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "sq": "Llogarit numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve që qëndrojnë në një rreth, në mënyrë që pas 'm' kalimesh, topi të kthehet te studenti origjinal.\n\n  Argumentet:\n  - n: Numri i studentëve në rreth. Është një numër i plotë ku 3 <= n <= 30.\n  - m: Numri i herëve që topi kalohet. Është një numër i plotë ku 1 <= m <= 30.\n\n  Kthen:\n  - Numri i sekuencave të dallueshme të kalimit që kthejnë topin te studenti fillestar pas 'm' kalimesh.\n\n  Shembuj:\n  - count_passing_ways(3, 3) kthen 2\n  - count_passing_ways(4, 2) kthen 4\n  - count_passing_ways(5, 5) kthen 6",
      "hy": "Հաշվում է գնդակը 'n' աշակերտների միջև շրջանաձև փոխանցելու տարբեր եղանակների քանակը, այնպես, որ 'm' փոխանցումից հետո գնդակը վերադառնա սկզբնական աշակերտին:\n\n  Արձանագրումներ:\n  - n: Շրջանում կանգնած աշակերտների քանակը։ Դա ամբողջ թիվ է, որտեղ 3 <= n <= 30։\n  - m: Գնդակի փոխանցումների քանակը։ Դա ամբողջ թիվ է, որտեղ 1 <= m <= 30։\n\n  Վերադարձնում է:\n  - Տարբեր փոխանցման հաջորդականությունների քանակը, որոնք 'm' փոխանցումից հետո գնդակը վերադարձնում են սկզբնական աշակերտին։\n\n  Օրինակներ:\n  - count_passing_ways(3, 3) վերադարձնում է 2\n  - count_passing_ways(4, 2) վերադարձնում է 4\n  - count_passing_ways(5, 5) վերադարձնում է 6",
      "bn": "বলটি একটি বৃত্তে দাঁড়িয়ে থাকা 'n' জন ছাত্রের মধ্যে কতভাবে পাস করা যায় তা গণনা করে, যাতে 'm' বার পাস করার পর বলটি মূল ছাত্রের কাছে ফিরে আসে।\n\n  আর্গুমেন্টসমূহ:\n  - n: বৃত্তে ছাত্রদের সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 3 <= n <= 30।\n  - m: বলটি পাস করার সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 1 <= m <= 30।\n\n  রিটার্নস:\n  - স্বতন্ত্র পাসিং সিকোয়েন্সের সংখ্যা যা 'm' বার পাস করার পর বলটিকে শুরু ছাত্রের কাছে ফিরিয়ে দেয়।\n\n  উদাহরণ:\n  - count_passing_ways(3, 3) রিটার্ন করে 2\n  - count_passing_ways(4, 2) রিটার্ন করে 4\n  - count_passing_ways(5, 5) রিটার্ন করে 6",
      "bg": "Изчислява броя на различните начини за предаване на топка между 'n' ученици, стоящи в кръг, така че след 'm' предавания топката да се върне при първоначалния ученик.\n\n  Аргументи:\n  - n: Броят на учениците в кръга. Това е цяло число, където 3 <= n <= 30.\n  - m: Броят на предаванията на топката. Това е цяло число, където 1 <= m <= 30.\n\n  Връща:\n  - Броят на различните последователности на предаване, които връщат топката на началния ученик след 'm' предавания.\n\n  Примери:\n  - count_passing_ways(3, 3) връща 2\n  - count_passing_ways(4, 2) връща 4\n  - count_passing_ways(5, 5) връща 6",
      "zh": "计算在一个圆圈中有 'n' 个学生传球的不同方式，使得经过 'm' 次传球后，球返回到原来的学生。\n\n  参数:\n  - n: 圆圈中的学生数量。它是一个整数，范围为 3 <= n <= 30。\n  - m: 球被传递的次数。它是一个整数，范围为 1 <= m <= 30。\n\n  返回:\n  - 在 'm' 次传球后，球返回到起始学生的不同传球序列的数量。\n\n  示例:\n  - count_passing_ways(3, 3) 返回 2\n  - count_passing_ways(4, 2) 返回 4\n  - count_passing_ways(5, 5) 返回 6",
      "fr": "Calcule le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants disposés en cercle, de telle sorte qu'après 'm' passes, le ballon revienne à l'étudiant d'origine.\n\n  Arguments:\n  - n: Le nombre d'étudiants dans le cercle. C'est un entier où 3 <= n <= 30.\n  - m: Le nombre de fois que le ballon est passé. C'est un entier où 1 <= m <= 30.\n\n  Retourne:\n  - Le nombre de séquences de passes distinctes qui ramènent le ballon à l'étudiant de départ après 'm' passes.\n\n  Exemples:\n  - count_passing_ways(3, 3) retourne 2\n  - count_passing_ways(4, 2) retourne 4\n  - count_passing_ways(5, 5) retourne 6",
      "de": "Berechnet die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, so weiterzugeben, dass der Ball nach 'm' Weitergaben zum ursprünglichen Schüler zurückkehrt.\n\n  Argumente:\n  - n: Die Anzahl der Schüler im Kreis. Es ist eine ganze Zahl, wobei 3 <= n <= 30.\n  - m: Die Anzahl der Male, die der Ball weitergegeben wird. Es ist eine ganze Zahl, wobei 1 <= m <= 30.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Weitergabesequenzen, die den Ball nach 'm' Weitergaben zum startenden Schüler zurückbringen.\n\n  Beispiele:\n  - count_passing_ways(3, 3) gibt 2 zurück\n  - count_passing_ways(4, 2) gibt 4 zurück\n  - count_passing_ways(5, 5) gibt 6 zurück",
      "ha": "Lissafa adadin hanyoyi daban-daban don wuce kwallo tsakanin 'n' ɗalibai da ke tsaye a cikin da'ira, ta yadda bayan 'm' wucewa, kwallon ta koma ga ɗalibin asali.\n\n  Huɗɗa:\n  - n: Yawan ɗalibai a cikin da'ira. Yana da lamba inda 3 <= n <= 30.\n  - m: Yawan sauyin da ake wuce ƙwallon. Yana da lamba inda 1 <= m <= 30.\n\n  Komawa:\n  - Yawan hanyoyin wucewa daban-daban da ke dawo da ƙwallon ga ɗalibin da ya fara bayan 'm' sauyin.\n\n  Misalai:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "hi": "गेंद को 'n' छात्रों के बीच एक वृत्त में पास करने के विभिन्न तरीकों की गणना करता है, ताकि 'm' पास के बाद, गेंद मूल छात्र के पास लौट आए।\n\n  तर्क:\n  - n: वृत्त में छात्रों की संख्या। यह एक पूर्णांक है जहाँ 3 <= n <= 30।\n  - m: गेंद पास करने की बार की संख्या। यह एक पूर्णांक है जहाँ 1 <= m <= 30।\n\n  वापसी:\n  - विशिष्ट पासिंग अनुक्रमों की संख्या जो 'm' पास के बाद गेंद को प्रारंभिक छात्र के पास लौटाते हैं।\n\n  उदाहरण:\n  - count_passing_ways(3, 3) 2 लौटाता है\n  - count_passing_ways(4, 2) 4 लौटाता है\n  - count_passing_ways(5, 5) 6 लौटाता है",
      "hu": "Kiszámítja, hányféleképpen lehet átadni egy labdát 'n' diák között, akik körben állnak, úgy, hogy 'm' passz után a labda visszatér az eredeti diákhoz.\n\n  Argumentumok:\n  - n: A körben álló diákok száma. Ez egy egész szám, ahol 3 <= n <= 30.\n  - m: A labda átadásának száma. Ez egy egész szám, ahol 1 <= m <= 30.\n\n  Visszatér:\n  - Azoknak a különböző átadási sorozatoknak a száma, amelyek 'm' passz után visszajuttatják a labdát a kiinduló diákhoz.\n\n  Példák:\n  - count_passing_ways(3, 3) visszaadja 2\n  - count_passing_ways(4, 2) visszaadja 4\n  - count_passing_ways(5, 5) visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9966532767099432",
      "hy": "0.9634969003556945",
      "bn": "0.9625329471165321",
      "bg": "0.9775553628342007",
      "zh": "0.9508143505266169",
      "fr": "0.9846800359715412",
      "de": "0.9791986319765024",
      "ha": "0.9687959616609432",
      "hi": "0.9772852255159933",
      "hu": "0.9799579959231988"
    }
  },
  {
    "task_id": "Rust/41",
    "prompt": {
      "en": "/*\n  Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "sq": "/*\n  Llogarit shumën maksimale të mundshme të diferencave absolute midis çifteve të elementeve nga dy vargje.\n  \n  Argumentet:\n  - a: Një varg me numra të plotë.\n  - b: Një varg me numra të plotë, me të njëjtën gjatësi si 'a'.\n  \n  Kthen:\n  - Shuma maksimale e diferencave absolute që mund të merret duke çiftuar secilin element nga 'a' me një nga 'b'.\n\n  Shembuj:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) kthen 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) kthen 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) kthen 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "hy": "/*\n  Հաշվում է զույգերի տարրերի միջև բացարձակ տարբերությունների առավելագույն հնարավոր գումարը երկու զանգվածներից:\n  \n  Արգումենտներ:\n  - a: ամբողջ թվերի զանգված:\n  - b: ամբողջ թվերի զանգված, նույն երկարության, ինչ 'a'-ն:\n  \n  Վերադարձնում է:\n  - Բացարձակ տարբերությունների առավելագույն գումարը, որը կարելի է ստանալ 'a'-ի յուրաքանչյուր տարրը 'b'-ի մեկի հետ զույգավորելով:\n\n  Օրինակներ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) վերադարձնում է 14:\n  - max_pairing_difference(&[1, 2], &[3, 4]) վերադարձնում է 4:\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) վերադարձնում է 60:\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "bn": "/*\n  দুটি অ্যারের উপাদানগুলোর জোড়া থেকে পার্থক্যের সর্বাধিক সম্ভাব্য যোগফল গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - a: পূর্ণসংখ্যার একটি অ্যারে।\n  - b: পূর্ণসংখ্যার একটি অ্যারে, যা 'a' এর সমান দৈর্ঘ্যের।\n\n  রিটার্ন করে:\n  - সর্বাধিক যোগফল যা প্রতিটি উপাদানকে 'a' থেকে 'b' এর একটি উপাদানের সাথে জোড়া করে প্রাপ্ত পার্থক্যের যোগফল হতে পারে।\n\n  উদাহরণসমূহ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 রিটার্ন করে।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 রিটার্ন করে।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 রিটার্ন করে।\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "bg": "/*\n  Изчислява максималната възможна сума на абсолютните разлики между двойки елементи от два масива.\n  \n  Аргументи:\n  - a: Масив от цели числа.\n  - b: Масив от цели числа, със същата дължина като 'a'.\n  \n  Връща:\n  - Максималната сума на абсолютните разлики, която може да бъде получена чрез сдвояване на всеки елемент от 'a' с един от 'b'.\n\n  Примери:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) връща 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) връща 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) връща 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "zh": "/*\n  计算两个数组中元素对之间绝对差的最大可能和。\n  \n  参数:\n  - a: 整数数组。\n  - b: 整数数组，与 'a' 的长度相同。\n  \n  返回:\n  - 通过将 'a' 中的每个元素与 'b' 中的一个元素配对可以获得的绝对差的最大和。\n\n  示例:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 返回 14。\n  - max_pairing_difference(&[1, 2], &[3, 4]) 返回 4。\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 返回 60。\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "fr": "/*\n  Calcule la somme maximale possible des différences absolues entre les paires d'éléments de deux tableaux.\n  \n  Arguments:\n  - a: Un tableau d'entiers.\n  - b: Un tableau d'entiers, de la même longueur que 'a'.\n  \n  Retourne:\n  - La somme maximale des différences absolues qui peut être obtenue en associant chaque élément de 'a' avec un de 'b'.\n\n  Exemples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) retourne 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) retourne 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) retourne 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "de": "/*\n  Berechnet die maximal mögliche Summe der absoluten Unterschiede zwischen Paaren von Elementen aus zwei Arrays.\n  \n  Argumente:\n  - a: Ein Array von Ganzzahlen.\n  - b: Ein Array von Ganzzahlen, von derselben Länge wie 'a'.\n  \n  Rückgabewert:\n  - Die maximale Summe der absoluten Unterschiede, die erzielt werden kann, indem jedes Element aus 'a' mit einem aus 'b' gepaart wird.\n\n  Beispiele:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) gibt 14 zurück.\n  - max_pairing_difference(&[1, 2], &[3, 4]) gibt 4 zurück.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) gibt 60 zurück.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "ha": "/*\n  Lissafin yuwuwar jimillar bambance-bambancen darajar da za a iya samu tsakanin ma'aurata na abubuwa daga jerin abubuwa biyu.\n\n  Huɗɗa:\n  - a: Jerin lambobi na cikakke.\n  - b: Jerin lambobi na cikakke, mai tsawon iri ɗaya da 'a'.\n\n  Komawa:\n  - Mafi girman jimillar bambance-bambancen darajar da za a iya samu ta hanyar haɗa kowane abu daga 'a' da ɗaya daga 'b'.\n\n  Misalai:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "hi": "/*\n  दो ऐरे के तत्वों के जोड़ों के बीच अधिकतम संभव पूर्णांकों के अंतर के योग की गणना करता है।\n\n  तर्क:\n  - a: पूर्णांकों का एक ऐरे।\n  - b: पूर्णांकों का एक ऐरे, जो 'a' के समान लंबाई का है।\n\n  लौटाता है:\n  - पूर्णांकों के अंतर के अधिकतम योग जो 'a' के प्रत्येक तत्व को 'b' के एक तत्व के साथ जोड़ने से प्राप्त किया जा सकता है।\n\n  उदाहरण:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 लौटाता है।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 लौटाता है।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 लौटाता है।\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "hu": "/*\n  Kiszámítja a maximális lehetséges összeget az elemek páronkénti abszolút különbségei között két tömbből.\n  \n  Argumentumok:\n  - a: Egész számok tömbje.\n  - b: Egész számok tömbje, amely ugyanolyan hosszú, mint az 'a'.\n  \n  Visszatér:\n  - Az abszolút különbségek maximális összege, amely elérhető úgy, hogy az 'a' minden elemét párosítjuk a 'b' egyik elemével.\n\n  Példák:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) visszaadja a 14-et.\n  - max_pairing_difference(&[1, 2], &[3, 4]) visszaadja a 4-et.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) visszaadja a 60-at.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 "
    },
    "prompt_bertscore": {
      "sq": "0.997620209404821",
      "hy": "0.9878326973793269",
      "bn": "0.972057472517536",
      "bg": "0.9904097279428735",
      "zh": "0.9676633712282823",
      "fr": "0.9971111197382286",
      "de": "0.9942629587045694",
      "ha": "0.9470951952721196",
      "hi": "0.968851180906871",
      "hu": "0.9836471579901597"
    },
    "canonical_solution": "{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` to solve the following problem:\nCalculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "sq": "Shkruani një funksion Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` për të zgjidhur problemin në vijim:\nLlogarit maksimumin e mundshëm të shumës së diferencave absolute midis çifteve të elementeve nga dy vargje.\n\n  Argumentet:\n  - a: Një varg i numrave të plotë.\n  - b: Një varg i numrave të plotë, me të njëjtën gjatësi si 'a'.\n  \n  Kthen:\n  - Shuma maksimale e diferencave absolute që mund të merret duke çiftuar secilin element nga 'a' me një nga 'b'.\n\n  Shembuj:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) kthen 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) kthen 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) kthen 60.",
      "hy": "Գրեք Rust ֆունկցիա `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է երկու զանգվածների տարրերի զույգերի միջև բացարձակ տարբերությունների առավելագույն հնարավոր գումարը:\n\nԱրգումենտներ:\n- a: Թվերի զանգված:\n- b: Թվերի զանգված, նույն երկարությամբ, ինչ 'a'-ն:\n\nՎերադարձնում է:\n- Բացարձակ տարբերությունների առավելագույն գումարը, որը կարող է ստացվել 'a'-ի յուրաքանչյուր տարրը 'b'-ի մեկ տարրի հետ զույգավորելով:\n\nՕրինակներ:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) վերադարձնում է 14:\n- max_pairing_difference(&[1, 2], &[3, 4]) վերադարձնում է 4:\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) վերադարձնում է 60:",
      "bn": "Rust ফাংশন `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি অ্যারের উপাদানগুলির জোড়ার মধ্যে পরম পার্থক্যের সর্বাধিক সম্ভাব্য যোগফল গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - a: পূর্ণসংখ্যার একটি অ্যারে।\n  - b: পূর্ণসংখ্যার একটি অ্যারে, যা 'a' এর সমান দৈর্ঘ্যের।\n\n  রিটার্নস:\n  - পরম পার্থক্যের সর্বাধিক যোগফল যা 'a' থেকে একটি উপাদান এবং 'b' থেকে একটি উপাদান জোড়া করে প্রাপ্ত করা যেতে পারে।\n\n  উদাহরণসমূহ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 রিটার্ন করে।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 রিটার্ন করে।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 রিটার্ন করে।",
      "bg": "Напишете функция на Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64`, за да решите следния проблем:\nИзчислява максималната възможна сума от абсолютни разлики между двойки елементи от два масива.\n  \n  Аргументи:\n  - a: Масив от цели числа.\n  - b: Масив от цели числа, със същата дължина като 'a'.\n  \n  Връща:\n  - Максималната сума от абсолютни разлики, която може да бъде получена чрез сдвояване на всеки елемент от 'a' с един от 'b'.\n\n  Примери:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) връща 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) връща 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) връща 60.",
      "zh": "编写一个 Rust 函数 `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` 来解决以下问题：\n计算两个数组中元素对之间绝对差的最大可能和。\n\n参数：\n- a: 一个整数数组。\n- b: 一个整数数组，与 'a' 的长度相同。\n\n返回：\n- 通过将 'a' 中的每个元素与 'b' 中的一个元素配对，可以获得的绝对差的最大和。\n\n示例：\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 返回 14。\n- max_pairing_difference(&[1, 2], &[3, 4]) 返回 4。\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 返回 60。",
      "fr": "Écrire une fonction Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` pour résoudre le problème suivant :\nCalcule la somme maximale possible des différences absolues entre les paires d'éléments de deux tableaux.\n  \n  Arguments :\n  - a : Un tableau d'entiers.\n  - b : Un tableau d'entiers, de la même longueur que 'a'.\n  \n  Renvoie :\n  - La somme maximale des différences absolues qui peut être obtenue en associant chaque élément de 'a' avec un de 'b'.\n\n  Exemples :\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) renvoie 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) renvoie 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) renvoie 60.",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64`, um das folgende Problem zu lösen:\nBerechnet die maximale mögliche Summe der absoluten Unterschiede zwischen Paaren von Elementen aus zwei Arrays.\n\nArgumente:\n- a: Ein Array von Ganzzahlen.\n- b: Ein Array von Ganzzahlen, mit der gleichen Länge wie 'a'.\n\nRückgabewert:\n- Die maximale Summe der absoluten Unterschiede, die erzielt werden kann, indem jedes Element aus 'a' mit einem aus 'b' gepaart wird.\n\nBeispiele:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) gibt 14 zurück.\n- max_pairing_difference(&[1, 2], &[3, 4]) gibt 4 zurück.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) gibt 60 zurück.",
      "ha": "Rubuta aikin Rust `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` don magance matsalar mai zuwa:\nLissafa mafi girman yuwuwar jimillar bambance-bambancen darajoji tsakanin ma'aurata na abubuwa daga jerin lambobi biyu.\n\n  Huɗɗa:\n  - a: Jerin lambobi na cikakke.\n  - b: Jerin lambobi na cikakke, mai tsawon iri ɗaya da 'a'.\n\n  Komawa:\n  - Mafi girman jimillar bambance-bambancen darajoji da za a iya samu ta hanyar haɗa kowane abu daga 'a' da ɗaya daga 'b'.\n\n  Misalai:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "hi": "Rust फ़ंक्शन `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो ऐरे के तत्वों के जोड़ों के बीच अधिकतम संभावित पूर्णांकों के अंतर का योग गणना करता है।\n\n  तर्क:\n  - a: पूर्णांकों का एक ऐरे।\n  - b: पूर्णांकों का एक ऐरे, जो 'a' के समान लंबाई का है।\n\n  वापसी मान:\n  - पूर्णांकों के अंतर के अधिकतम योग जो 'a' के प्रत्येक तत्व को 'b' के एक तत्व के साथ जोड़कर प्राप्त किया जा सकता है।\n\n  उदाहरण:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 लौटाता है।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 लौटाता है।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64` a következő probléma megoldására:\nKiszámítja a maximális lehetséges összegét az elemek páronkénti abszolút különbségeinek két tömbből.\n\n  Argumentumok:\n  - a: Egész számok tömbje.\n  - b: Egész számok tömbje, amely ugyanolyan hosszú, mint 'a'.\n  \n  Visszatérési érték:\n  - Az abszolút különbségek maximális összege, amelyet úgy lehet elérni, hogy az 'a' minden elemét párosítjuk a 'b' egy elemével.\n\n  Példák:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) visszatér 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) visszatér 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) visszatér 60."
    },
    "instruction_bertscore": {
      "sq": "0.9982006073782049",
      "hy": "0.9772997255338088",
      "bn": "0.9816938268230626",
      "bg": "0.9919238873375025",
      "zh": "0.9813507921550154",
      "fr": "0.9973117364230738",
      "de": "0.9855081260300755",
      "ha": "0.9668724250510013",
      "hi": "0.9627959337410223",
      "hu": "0.9757925182025161"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]), 14);\n        assert_eq!(max_pairing_difference(&[1, 2], &[3, 4]), 4);\n        assert_eq!(max_pairing_difference(&[10, 20, 30], &[30, 20, 10]), 40);\n    }\n    \n}",
    "entry_point": "max_pairing_difference",
    "signature": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64",
    "docstring": {
      "en": "Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "sq": "Llogarit shumën maksimale të mundshme të diferencave absolute midis çifteve të elementeve nga dy vargje.\n\nArguments:\n- a: Një varg me numra të plotë.\n- b: Një varg me numra të plotë, me të njëjtën gjatësi si 'a'.\n\nReturns:\n- Shuma maksimale e diferencave absolute që mund të merret duke çiftuar secilin element nga 'a' me një nga 'b'.\n\nExamples:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) kthen 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) kthen 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) kthen 60.",
      "hy": "Հաշվում է երկու զանգվածներից տարրերի զույգերի միջև բացարձակ տարբերությունների առավելագույն հնարավոր գումարը։\n\nՓոփոխականներ:\n- a: ամբողջ թվերի զանգված։\n- b: ամբողջ թվերի զանգված, նույն երկարությամբ, ինչ 'a'։\n\nՎերադարձնում է:\n- Բացարձակ տարբերությունների առավելագույն գումարը, որը կարող է ստացվել 'a'-ի յուրաքանչյուր տարրը 'b'-ի մեկ տարրի հետ զուգակցելով։\n\nՕրինակներ:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) վերադարձնում է 14։\n- max_pairing_difference(&[1, 2], &[3, 4]) վերադարձնում է 4։\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) վերադարձնում է 60։",
      "bn": "দুটি অ্যারের উপাদানগুলোর জোড়া থেকে পার্থক্যের সর্বাধিক সম্ভাব্য যোগফল গণনা করে।\n  \n  আর্গুমেন্টসমূহ:\n  - a: পূর্ণসংখ্যার একটি অ্যারে।\n  - b: পূর্ণসংখ্যার একটি অ্যারে, যা 'a' এর সমান দৈর্ঘ্যের।\n\n  রিটার্নস:\n  - সর্বাধিক যোগফল যা প্রতিটি উপাদানকে 'a' থেকে 'b' এর একটি উপাদানের সাথে জোড়া করে প্রাপ্ত হতে পারে।\n\n  উদাহরণসমূহ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 রিটার্ন করে।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 রিটার্ন করে।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 রিটার্ন করে।",
      "bg": "Изчислява максималната възможна сума на абсолютните разлики между двойки елементи от два масива.\n\nАргументи:\n- a: Масив от цели числа.\n- b: Масив от цели числа, със същата дължина като 'a'.\n\nВръща:\n- Максималната сума на абсолютните разлики, която може да бъде получена чрез сдвояване на всеки елемент от 'a' с един от 'b'.\n\nПримери:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) връща 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) връща 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) връща 60.",
      "zh": "计算两个数组中元素对之间绝对差的最大可能和。\n\n  参数:\n  - a: 一个整数数组。\n  - b: 一个整数数组，与 'a' 的长度相同。\n\n  返回:\n  - 通过将 'a' 中的每个元素与 'b' 中的一个元素配对可以获得的绝对差的最大和。\n\n  示例:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 返回 14。\n  - max_pairing_difference(&[1, 2], &[3, 4]) 返回 4。\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 返回 60。",
      "fr": "Calcule la somme maximale possible des différences absolues entre les paires d'éléments de deux tableaux.\n  \n  Arguments:\n  - a: Un tableau d'entiers.\n  - b: Un tableau d'entiers, de la même longueur que 'a'.\n  \n  Retourne:\n  - La somme maximale des différences absolues qui peut être obtenue en associant chaque élément de 'a' avec un de 'b'.\n\n  Exemples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) retourne 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) retourne 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) retourne 60.",
      "de": "Berechnet die maximal mögliche Summe der absoluten Differenzen zwischen Paaren von Elementen aus zwei Arrays.\n\n  Argumente:\n  - a: Ein Array von ganzen Zahlen.\n  - b: Ein Array von ganzen Zahlen, mit der gleichen Länge wie 'a'.\n  \n  Rückgabewerte:\n  - Die maximale Summe der absoluten Differenzen, die durch das Paaren jedes Elements aus 'a' mit einem aus 'b' erzielt werden kann.\n\n  Beispiele:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) gibt 14 zurück.\n  - max_pairing_difference(&[1, 2], &[3, 4]) gibt 4 zurück.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) gibt 60 zurück.",
      "ha": "Lissafin yuwuwar jimillar bambance-bambancen darajar da za a iya samu tsakanin ma'aurata na abubuwa daga jerin abubuwa biyu.\n\n  Huɗɗa:\n  - a: Jeri na lambobin cikakke.\n  - b: Jeri na lambobin cikakke, wanda yake da tsawon iri ɗaya da 'a'.\n\n  Dawowa:\n  - Mafi girman jimillar bambance-bambancen cikakke da za a iya samu ta hanyar haɗa kowane abu daga 'a' da ɗaya daga 'b'.\n\n  Misalai:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "hi": "दो ऐरे के तत्वों के जोड़ों के बीच अधिकतम संभव पूर्णांकों के अंतर के योग की गणना करता है।\n\nArguments:\n- a: पूर्णांकों की एक array।\n- b: पूर्णांकों की एक array, जो 'a' के समान लंबाई की है।\n\nReturns:\n- अधिकतम योग जो कि प्रत्येक तत्व को 'a' से 'b' के एक तत्व के साथ जोड़कर प्राप्त किया जा सकता है।\n\nExamples:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "hu": "Kiszámítja a maximális lehetséges abszolút különbségek összegét két tömb elempárjai között.\n\n  Argumentumok:\n  - a: Egész számokat tartalmazó tömb.\n  - b: Egész számokat tartalmazó tömb, amely ugyanolyan hosszú, mint 'a'.\n\n  Visszatér:\n  - Az abszolút különbségek maximális összege, amelyet úgy lehet elérni, hogy az 'a' minden elemét párosítjuk a 'b' egy elemével.\n\n  Példák:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) visszaadja 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) visszaadja 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) visszaadja 60."
    },
    "docstring_bertscore": {
      "sq": "0.9983072718928206",
      "hy": "0.9831889177011123",
      "bn": "0.9883070267292382",
      "bg": "0.9897818573084223",
      "zh": "0.9872151555246894",
      "fr": "0.9943229450796418",
      "de": "0.9817798337780508",
      "ha": "0.981058408234132",
      "hi": "0.9893544047284352",
      "hu": "0.980904668319211"
    }
  },
  {
    "task_id": "Rust/42",
    "prompt": {
      "en": "/*\n  Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "sq": "/*\n  Gjen numrin me faktor kryesor më të madh në një listë të dhënë numrash.\n\n  Funksioni iteron nëpër secilin numër në listë dhe llogarit faktorin kryesor më të madh të tij.\n  Pastaj krahason këta faktorë për të gjetur numrin me faktorin kryesor më të madh.\n\n  Argumentet:\n  - numbers: Një segment i numrave të plotë.\n\n  Kthen:\n  - Numrin nga lista që ka faktorin kryesor më të madh.\n\n  Shembuj:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) kthen 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) kthen 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) kthen 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "hy": "/*\n  Գտնում է թիվը, որն ունի ամենամեծ պարզ բաժանարարը տրված թվերի ցուցակում:\n\n  Ֆունկցիան անցնում է ցուցակի յուրաքանչյուր թվով և հաշվարկում դրա ամենամեծ պարզ բաժանարարը։ \n  Այնուհետև համեմատում է այս բաժանարարները՝ գտնելու համար թիվը, որն ունի ամենամեծ պարզ բաժանարարը։\n\n  Արգումենտներ:\n  - numbers: ամբողջ թվերի շերտ։\n\n  Վերադարձնում է:\n  - Ցուցակից թիվը, որն ունի ամենամեծ պարզ բաժանարարը։\n\n  Օրինակներ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) վերադարձնում է 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) վերադարձնում է 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) վերադարձնում է 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "bn": "/*\n  প্রদত্ত সংখ্যার তালিকায় সবচেয়ে বড় মৌলিক গুণনীয়ক সহ সংখ্যাটি খুঁজে বের করে।\n\n  ফাংশনটি তালিকার প্রতিটি সংখ্যার মধ্য দিয়ে পুনরাবৃত্তি করে এবং তার সবচেয়ে বড় মৌলিক গুণনীয়ক গণনা করে। \n  তারপর এই গুণনীয়কগুলির তুলনা করে সবচেয়ে বড় মৌলিক গুণনীয়ক সহ সংখ্যাটি খুঁজে বের করে।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্ন করে:\n  - তালিকা থেকে সেই সংখ্যাটি যার সবচেয়ে বড় মৌলিক গুণনীয়ক রয়েছে।\n\n  উদাহরণ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) রিটার্ন করে 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) রিটার্ন করে 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) রিটার্ন করে 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "bg": "/*\n  Намира числото с най-голям прост делител в даден списък от числа.\n\n  Функцията преминава през всяко число в списъка и изчислява неговия най-голям прост делител.\n  След това сравнява тези делители, за да намери числото с най-голям прост делител.\n\n  Аргументи:\n  - numbers: Срез от цели числа.\n\n  Връща:\n  - Числото от списъка, което има най-голям прост делител.\n\n  Примери:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) връща 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) връща 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) връща 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "zh": "/*\n  找到给定数字列表中具有最大素因子的数字。\n\n  该函数遍历列表中的每个数字并计算其最大素因子。\n  然后比较这些因子以找到具有最大素因子的数字。\n\n  参数：\n  - numbers: 一个整数切片。\n\n  返回：\n  - 列表中具有最大素因子的数字。\n\n  示例：\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 返回 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 返回 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 返回 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "fr": "/*\n  Trouve le nombre avec le plus grand facteur premier dans une liste donnée de nombres.\n\n  La fonction parcourt chaque nombre de la liste et calcule son plus grand facteur premier.\n  Elle compare ensuite ces facteurs pour trouver le nombre avec le plus grand facteur premier.\n\n  Arguments:\n  - numbers: Une tranche d'entiers.\n\n  Renvoie:\n  - Le nombre de la liste qui a le plus grand facteur premier.\n\n  Exemples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) renvoie 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) renvoie 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) renvoie 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "de": "/*\n  Findet die Zahl mit dem größten Primfaktor in einer gegebenen Liste von Zahlen.\n\n  Die Funktion iteriert durch jede Zahl in der Liste und berechnet deren größten Primfaktor.\n  Sie vergleicht dann diese Faktoren, um die Zahl mit dem größten Primfaktor zu finden.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen.\n\n  Rückgabewert:\n  - Die Zahl aus der Liste, die den größten Primfaktor hat.\n\n  Beispiele:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) gibt 38 zurück\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) gibt 22 zurück\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) gibt 19 zurück\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "ha": "/*\n  Nemi lambar da ke da mafi girman abin da ke da mahimmanci a cikin jerin lambobi da aka bayar.\n\n  Aikin yana bin kowane lamba a cikin jerin kuma yana ƙididdige mafi girman abin da ke da mahimmanci. \n  Sannan yana kwatanta waɗannan abubuwan don nemo lambar da ke da mafi girman abin da ke da mahimmanci.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobin cikakke.\n\n  Komawa:\n  - Lambar daga jerin da ke da mafi girman abin da ke da mahimmanci.\n\n  Misalai:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "hi": "/*\n  दिए गए संख्याओं की सूची में सबसे बड़े अभाज्य गुणनखंड वाली संख्या खोजता है।\n\n  फ़ंक्शन सूची में प्रत्येक संख्या के माध्यम से इटरेट करता है और उसके सबसे बड़े अभाज्य गुणनखंड की गणना करता है।\n  फिर यह इन गुणनखंडों की तुलना करता है ताकि सबसे बड़े अभाज्य गुणनखंड वाली संख्या मिल सके।\n\n  तर्क:\n  - numbers: पूर्णांकों की एक स्लाइस।\n\n  लौटाता है:\n  - सूची से वह संख्या जिसका सबसे बड़ा अभाज्य गुणनखंड है।\n\n  उदाहरण:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 लौटाता है\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 लौटाता है\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 लौटाता है\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "hu": "/*\n  Megkeresi azt a számot, amelynek a legnagyobb prímtényezője van egy adott számok listájában.\n\n  A függvény végigmegy a lista minden számán, és kiszámítja annak legnagyobb prímtényezőjét. \n  Ezután összehasonlítja ezeket a tényezőket, hogy megtalálja azt a számot, amelynek a legnagyobb prímtényezője van.\n\n  Argumentumok:\n  - numbers: Egész számok egy szelete.\n\n  Visszatér:\n  - A lista azon száma, amelynek a legnagyobb prímtényezője van.\n\n  Példák:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) visszatér 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) visszatér 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) visszatér 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32"
    },
    "prompt_bertscore": {
      "sq": "0.9993695471705952",
      "hy": "0.99595787174594",
      "bn": "0.9792663649364353",
      "bg": "0.9993695471705952",
      "zh": "0.9796936188860413",
      "fr": "0.9923104220589963",
      "de": "0.9956974673164033",
      "ha": "0.9715438143521798",
      "hi": "0.9976098806250072",
      "hu": "0.9940347323967602"
    },
    "canonical_solution": "{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` to solve the following problem:\nFinds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "sq": "Shkruani një funksion Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` për të zgjidhur problemin e mëposhtëm:\nGjen numrin me faktorin më të madh prim në një listë të dhënë numrash.\n\n  Funksioni iteron nëpër secilin numër në listë dhe llogarit faktorin e tij më të madh prim. \n  Pastaj krahason këta faktorë për të gjetur numrin me faktorin më të madh prim.\n\n  Argumentet:\n  - numbers: Një segment i numrave të plotë.\n\n  Kthen:\n  - Numri nga lista që ka faktorin më të madh prim.\n\n  Shembuj:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) kthen 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) kthen 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) kthen 19",
      "hy": "Գրեք Rust ֆունկցիա `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` հետևյալ խնդիրը լուծելու համար:\nԳտնում է այն թիվը, որը ունի ամենամեծ պարզ գործակիցը տրված թվերի ցուցակում:\n\n  Ֆունկցիան անցնում է ցուցակի յուրաքանչյուր թվի միջով և հաշվարկում դրա ամենամեծ պարզ գործակիցը։ \n  Այնուհետև համեմատում է այս գործակիցները՝ գտնելու համար այն թիվը, որը ունի ամենամեծ պարզ գործակիցը։\n\n  Արգումենտներ:\n  - numbers: ամբողջ թվերի հատված։\n\n  Վերադարձնում է:\n  - Ցուցակից այն թիվը, որը ունի ամենամեծ պարզ գործակիցը։\n\n  Օրինակներ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) վերադարձնում է 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) վերադարձնում է 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) վերադարձնում է 19",
      "bn": "Rust ফাংশন `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত সংখ্যার তালিকায় সবচেয়ে বড় মৌলিক গুণক সহ সংখ্যাটি খুঁজে বের করুন।\n\n  ফাংশনটি তালিকার প্রতিটি সংখ্যার মাধ্যমে পুনরাবৃত্তি করে এবং এর সবচেয়ে বড় মৌলিক গুণক গণনা করে। \n  তারপর এই গুণকগুলির তুলনা করে সবচেয়ে বড় মৌলিক গুণক সহ সংখ্যাটি খুঁজে বের করে।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্নস:\n  - তালিকা থেকে সেই সংখ্যা যা সবচেয়ে বড় মৌলিক গুণক ধারণ করে।\n\n  উদাহরণসমূহ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) রিটার্ন করে 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) রিটার্ন করে 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) রিটার্ন করে 19",
      "bg": "Напишете функция на Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32`, за да решите следния проблем:\nНамира числото с най-голям прост множител в даден списък от числа.\n\nФункцията обхожда всяко число в списъка и изчислява неговия най-голям прост множител.\nСлед това сравнява тези множители, за да намери числото с най-голям прост множител.\n\nАргументи:\n- numbers: Срез от цели числа.\n\nВръща:\n- Числото от списъка, което има най-голям прост множител.\n\nПримери:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) връща 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) връща 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) връща 19",
      "zh": "编写一个 Rust 函数 `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` 来解决以下问题：\n在给定的数字列表中，找到具有最大素因子的数字。\n\n该函数遍历列表中的每个数字并计算其最大的素因子。\n然后比较这些因子以找到具有最大素因子的数字。\n\n参数：\n- numbers: 一个整数切片。\n\n返回：\n- 列表中具有最大素因子的数字。\n\n示例：\n- max_prime_factor_in_list(&[36, 38, 40, 42]) 返回 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) 返回 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) 返回 19",
      "fr": "Écrire une fonction Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` pour résoudre le problème suivant :  \nTrouve le nombre avec le plus grand facteur premier dans une liste donnée de nombres.\n\n  La fonction parcourt chaque nombre de la liste et calcule son plus grand facteur premier. \n  Elle compare ensuite ces facteurs pour trouver le nombre avec le plus grand facteur premier.\n\n  Arguments :\n  - numbers : Une tranche d'entiers.\n\n  Renvoie :\n  - Le nombre de la liste qui a le plus grand facteur premier.\n\n  Exemples :\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) renvoie 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) renvoie 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) renvoie 19",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_prime_factor_in_list(numbers: &[i32]) -> i32`, um das folgende Problem zu lösen:\nFindet die Zahl mit dem größten Primfaktor in einer gegebenen Liste von Zahlen.\n\n  Die Funktion iteriert durch jede Zahl in der Liste und berechnet deren größten Primfaktor. \n  Anschließend vergleicht sie diese Faktoren, um die Zahl mit dem größten Primfaktor zu finden.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen.\n\n  Rückgabewert:\n  - Die Zahl aus der Liste, die den größten Primfaktor hat.\n\n  Beispiele:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) gibt 38 zurück\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) gibt 22 zurück\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) gibt 19 zurück",
      "ha": "Rubuta wani aikin Rust `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` don warware matsalar mai zuwa:\nNemo lambar da ke da mafi girman abin da ke da mahimmanci a cikin jerin lambobi da aka bayar.\n\n  Aikin yana zagayawa ta kowace lamba a cikin jerin kuma yana ƙididdige mafi girman abin da ke da mahimmanci. \n  Sannan yana kwatanta waɗannan abubuwan don nemo lambar da ke da mafi girman abin da ke da mahimmanci.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobin cikakke.\n\n  Dawowa:\n  - Lambar daga jerin da ke da mafi girman abin da ke da mahimmanci.\n\n  Misalai:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "hi": "Rust फ़ंक्शन `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में सबसे बड़े अभाज्य गुणनखंड वाली संख्या खोजें।\n\n  फ़ंक्शन सूची में प्रत्येक संख्या के माध्यम से इटररेट करता है और उसके सबसे बड़े अभाज्य गुणनखंड की गणना करता है।\n  फिर यह इन गुणनखंडों की तुलना करता है ताकि सबसे बड़े अभाज्य गुणनखंड वाली संख्या मिल सके।\n\n  तर्क:\n  - numbers: पूर्णांकों का एक स्लाइस।\n\n  लौटाता है:\n  - सूची से वह संख्या जो सबसे बड़े अभाज्य गुणनखंड वाली है।\n\n  उदाहरण:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 38 लौटाता है\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 22 लौटाता है\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 19 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn max_prime_factor_in_list(numbers: &[i32]) -> i32` a következő probléma megoldására:\nMegtalálja azt a számot, amelynek a legnagyobb prímtényezője van egy adott számok listájában.\n\n  A függvény végigmegy a lista minden számán, és kiszámítja annak legnagyobb prímtényezőjét. \n  Ezután összehasonlítja ezeket a tényezőket, hogy megtalálja azt a számot, amelynek a legnagyobb prímtényezője van.\n\n  Argumentumok:\n  - numbers: Egész számok szelete.\n\n  Visszatér:\n  - A lista azon száma, amelynek a legnagyobb prímtényezője van.\n\n  Példák:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) visszatér 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) visszatér 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) visszatér 19"
    },
    "instruction_bertscore": {
      "sq": "0.9962005980715647",
      "hy": "0.9882454513111174",
      "bn": "0.9819063613307699",
      "bg": "0.9952279050956369",
      "zh": "0.9781637676913106",
      "fr": "0.9877061698266076",
      "de": "0.9956543645237187",
      "ha": "0.9755942850822433",
      "hi": "0.9798276943932399",
      "hu": "0.9866258191841589"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_prime_factor_in_list(&[36, 38, 40, 42]), 38);\n        assert_eq!(max_prime_factor_in_list(&[10, 15, 21, 22]), 22);\n        assert_eq!(max_prime_factor_in_list(&[7, 11, 13, 19]), 19);\n        assert_eq!(max_prime_factor_in_list(&[2, 3, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "max_prime_factor_in_list",
    "signature": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32",
    "docstring": {
      "en": "Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "sq": "Gjen numrin me faktor kryesor më të madh në një listë të dhënë numrash.\n\n  Funksioni iteron nëpër secilin numër në listë dhe llogarit faktorin e tij më të madh kryesor. \n  Pastaj krahason këta faktorë për të gjetur numrin me faktor kryesor më të madh.\n\n  Argumentet:\n  - numbers: Një prerje e numrave të plotë.\n\n  Kthen:\n  - Numri nga lista që ka faktorin kryesor më të madh.\n\n  Shembuj:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) kthen 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) kthen 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) kthen 19",
      "hy": "Գտնում է ցուցակում ամենամեծ պարզ բաժանարար ունեցող թիվը:\n\n  Ֆունկցիան անցնում է ցուցակի յուրաքանչյուր թվով և հաշվարկում դրա ամենամեծ պարզ բաժանարարը:\n  Այնուհետև համեմատում է այդ բաժանարարները՝ գտնելու ամենամեծ պարզ բաժանարար ունեցող թիվը:\n\n  Արգումենտներ:\n  - numbers: Թվերի շերտ:\n\n  Վերադարձնում է.\n  - Ցուցակից այն թիվը, որը ունի ամենամեծ պարզ բաժանարարը:\n\n  Օրինակներ.\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) վերադարձնում է 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) վերադարձնում է 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) վերադարձնում է 19",
      "bn": "প্রদত্ত সংখ্যার তালিকায় সবচেয়ে বড় মৌলিক গুণনীয়কযুক্ত সংখ্যা খুঁজে বের করে।\n  এটি তালিকার প্রতিটি সংখ্যার উপর দিয়ে পুনরাবৃত্তি করে এবং তার সবচেয়ে বড় মৌলিক গুণনীয়ক গণনা করে।\n  তারপর এই গুণনীয়কগুলির তুলনা করে সবচেয়ে বড় মৌলিক গুণনীয়কযুক্ত সংখ্যাটি খুঁজে বের করে।\n\n  Arguments:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস।\n\n  Returns:\n  - তালিকা থেকে সেই সংখ্যা যা সবচেয়ে বড় মৌলিক গুণনীয়কযুক্ত।\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "bg": "Намира числото с най-голям прост делител в даден списък от числа.\n\n  Функцията преминава през всяко число в списъка и изчислява неговия най-голям прост делител. \n  След това сравнява тези делители, за да намери числото с най-голям прост делител.\n\n  Аргументи:\n  - numbers: Списък от цели числа.\n\n  Връща:\n  - Числото от списъка, което има най-голям прост делител.\n\n  Примери:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) връща 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) връща 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) връща 19",
      "zh": "找到给定数字列表中具有最大素因子的数字。\n\n该函数遍历列表中的每个数字并计算其最大素因子。然后比较这些因子以找到具有最大素因子的数字。\n\n参数:\n- numbers: 整数切片。\n\n返回:\n- 列表中具有最大素因子的数字。\n\n示例:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) 返回 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) 返回 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) 返回 19",
      "fr": "Trouve le nombre avec le plus grand facteur premier dans une liste donnée de nombres.\n\n  La fonction parcourt chaque nombre de la liste et calcule son plus grand facteur premier.\n  Elle compare ensuite ces facteurs pour trouver le nombre avec le plus grand facteur premier.\n\n  Arguments:\n  - numbers: Une tranche d'entiers.\n\n  Returns:\n  - Le nombre de la liste qui a le plus grand facteur premier.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "de": "Findet die Zahl mit dem größten Primfaktor in einer gegebenen Liste von Zahlen.\n\n  Die Funktion durchläuft jede Zahl in der Liste und berechnet ihren größten Primfaktor. \n  Anschließend vergleicht sie diese Faktoren, um die Zahl mit dem größten Primfaktor zu finden.\n\n  Argumente:\n  - numbers: Ein Ausschnitt von ganzen Zahlen.\n\n  Rückgabewerte:\n  - Die Zahl aus der Liste, die den größten Primfaktor hat.\n\n  Beispiele:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) gibt 38 zurück\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) gibt 22 zurück\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) gibt 19 zurück",
      "ha": "Yana nemo lambar da take da mafi girman abin da ke rarraba ta a cikin jerin lambobi da aka bayar.\n\n  Aikin yana zagayawa ta kowace lamba a cikin jerin kuma yana ƙididdige mafi girman abin da ke rarraba ta. \n  Sannan yana kwatanta waɗannan abubuwan don nemo lambar da take da mafi girman abin da ke rarraba ta.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobin cikakke.\n\n  Dawowa:\n  - Lambar daga jerin da take da mafi girman abin da ke rarraba ta.\n\n  Misalai:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) yana dawowa 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) yana dawowa 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) yana dawowa 19",
      "hi": "दिए गए संख्याओं की सूची में सबसे बड़े अभाज्य गुणनखंड वाले संख्या को खोजता है।\n\n  फ़ंक्शन सूची में प्रत्येक संख्या के माध्यम से पुनरावृत्ति करता है और उसके सबसे बड़े अभाज्य गुणनखंड की गणना करता है।\n  फिर यह इन गुणनखण्डों की तुलना करता है ताकि सबसे बड़े अभाज्य गुणनखंड वाली संख्या को खोजा जा सके।\n\n  तर्क:\n  - numbers: पूर्णांकों की एक सूची।\n\n  वापसी:\n  - सूची से वह संख्या जो सबसे बड़े अभाज्य गुणनखंड वाली है।\n\n  उदाहरण:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "hu": "Megkeresi azt a számot, amelynek a legnagyobb prímtényezője van egy adott számok listájában.\n\n  A függvény végigiterál a lista minden számán, és kiszámítja annak legnagyobb prímtényezőjét. \n  Ezután összehasonlítja ezeket a tényezőket, hogy megtalálja azt a számot, amelynek a legnagyobb prímtényezője van.\n\n  Argumentumok:\n  - numbers: Egész számok szelete.\n\n  Visszatér:\n  - A lista azon száma, amelynek a legnagyobb prímtényezője van.\n\n  Példák:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) visszaadja 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) visszaadja 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) visszaadja 19"
    },
    "docstring_bertscore": {
      "sq": "0.9942208490637899",
      "hy": "0.9618417133905307",
      "bn": "1",
      "bg": "0.9474185655324444",
      "zh": "0.9763174982995914",
      "fr": "0.987469005151652",
      "de": "0.9944844315794232",
      "ha": "0.9843916246582785",
      "hi": "0.9915552293503017",
      "hu": "0.988072046988474"
    }
  },
  {
    "task_id": "Rust/43",
    "prompt": {
      "en": "/*\n  Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "sq": "/*\n  Llogarit gjatësinë e nënpasardhëses më të gjatë jo-zbritëse në një sekuencë të dhënë numrash.\n  \n  Funksioni merr një vektor të numrave të plotë dhe kthen gjatësinë e nënpasardhëses më të gjatë ku secili element nuk është më i vogël se ai i mëparshmi.\n\n  Argumentet:\n  - sequence: Një vektor i numrave të plotë.\n\n  Kthen:\n  - Gjatësinë e nënpasardhëses më të gjatë jo-zbritëse në sekuencën e dhënë.\n\n  Shembuj:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) kthen 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "hy": "/*\n  Հաշվում է տրված թվերի հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n  \n  Ֆունկցիան ընդունում է ամբողջ թվերի վեկտոր և վերադարձնում է ամենաերկար ենթահաջորդականության երկարությունը, որտեղ յուրաքանչյուր տարր չի փոքր քան նախորդը։\n\n  Արգումենտներ:\n  - sequence: Ամբողջ թվերի վեկտոր։\n\n  Վերադարձնում է:\n  - Տրված հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\n  Օրինակներ:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) վերադարձնում է 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) վերադարձնում է 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) վերադարձնում է 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "bn": "/*\n  প্রদত্ত সংখ্যার সিকোয়েন্সের মধ্যে দীর্ঘতম অ-হ্রাসমান উপসিকোয়েন্সের দৈর্ঘ্য গণনা করে।\n\n  ফাংশনটি পূর্ণসংখ্যার একটি ভেক্টর নেয় এবং দীর্ঘতম উপসিকোয়েন্সের দৈর্ঘ্য ফেরত দেয় যেখানে প্রতিটি উপাদান পূর্ববর্তীটির চেয়ে কম নয়।\n\n  আর্গুমেন্টসমূহ:\n  - sequence: পূর্ণসংখ্যার একটি ভেক্টর।\n\n  রিটার্নস:\n  - প্রদত্ত সিকোয়েন্সের মধ্যে দীর্ঘতম অ-হ্রাসমান উপসিকোয়েন্সের দৈর্ঘ্য।\n\n  উদাহরণসমূহ:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 ফেরত দেয়\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 ফেরত দেয়\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 ফেরত দেয়\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "bg": "/*\n  Изчислява дължината на най-дългата не-намаляваща подредица в дадена последователност от числа.\n  \n  Функцията приема вектор от цели числа и връща дължината на най-дългата подредица, в която всеки елемент не е по-малък от предишния.\n\n  Аргументи:\n  - sequence: Вектор от цели числа.\n\n  Връща:\n  - Дължината на най-дългата не-намаляваща подредица в дадената последователност.\n\n  Примери:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) връща 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) връща 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) връща 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "zh": "/*\n  计算给定数字序列中最长非递减子序列的长度。\n  \n  该函数接受一个整数向量，并返回最长子序列的长度，其中每个元素不小于前一个元素。\n\n  参数:\n  - sequence: 一个整数向量。\n\n  返回:\n  - 给定序列中最长非递减子序列的长度。\n\n  示例:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 返回 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 返回 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 返回 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "fr": "/*\n  Calcule la longueur de la plus longue sous-séquence non décroissante dans une séquence donnée de nombres.\n  \n  La fonction prend un vecteur d'entiers et retourne la longueur de la plus longue sous-séquence où chaque élément n'est pas inférieur au précédent.\n\n  Arguments :\n  - sequence : Un vecteur d'entiers.\n\n  Renvoie :\n  - La longueur de la plus longue sous-séquence non décroissante dans la séquence donnée.\n\n  Exemples :\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "de": "/*\n  Berechnet die Länge der längsten nicht abnehmenden Teilfolge in einer gegebenen Zahlenfolge.\n  \n  Die Funktion nimmt einen Vektor von Ganzzahlen und gibt die Länge der längsten Teilfolge zurück, bei der jedes Element nicht kleiner als das vorherige ist.\n\n  Argumente:\n  - sequence: Ein Vektor von Ganzzahlen.\n\n  Rückgabewert:\n  - Die Länge der längsten nicht abnehmenden Teilfolge in der gegebenen Sequenz.\n\n  Beispiele:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) gibt 3 zurück\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) gibt 3 zurück\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) gibt 4 zurück\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "ha": "/*\n  Lissafin tsawon mafi tsawo wanda ba ya raguwa a cikin jerin lambobi da aka bayar.\n\n  Aikin yana karɓar vector na lambobi kuma yana mayar da tsawon mafi tsawon lissafi inda kowanne abu ba ya raguwa daga wanda ya gabata.\n\n  Huɗoɗi:\n  - sequence: Vector na lambobi.\n\n  Mayarwa:\n  - Tsawon mafi tsawon lissafi wanda ba ya raguwa a cikin jerin da aka bayar.\n\n  Misalai:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "hi": "/*\n  दिए गए संख्याओं के अनुक्रम में सबसे लंबी गैर-घटती उप-अनुक्रम की लंबाई की गणना करता है।\n\n  यह फ़ंक्शन पूर्णांकों के एक वेक्टर को लेता है और सबसे लंबे उप-अनुक्रम की लंबाई लौटाता है जहाँ प्रत्येक तत्व पिछले तत्व से कम नहीं होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक वेक्टर।\n\n  लौटाता है:\n  - दिए गए अनुक्रम में सबसे लंबी गैर-घटती उप-अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "hu": "/*\n  Kiszámítja a leghosszabb nem csökkenő részszekvencia hosszát egy adott számokból álló sorozatban.\n  \n  A függvény egy egész számokat tartalmazó vektort vesz át, és visszaadja a leghosszabb részszekvencia hosszát, ahol minden elem nem kisebb az előzőnél.\n\n  Argumentumok:\n  - sequence: Egy egész számokat tartalmazó vektor.\n\n  Visszatér:\n  - A leghosszabb nem csökkenő részszekvencia hossza az adott sorozatban.\n\n  Példák:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) visszaadja 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9977646136918333",
      "hy": "0.9873148679759689",
      "bn": "0.9857637633304674",
      "bg": "0.9925563264707176",
      "zh": "0.9922091205646686",
      "fr": "0.9988471492684735",
      "de": "0.9943058628668728",
      "ha": "0.9547158484709041",
      "hi": "0.9954293163020062",
      "hu": "0.9945031028352405"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}",
    "instruction": {
      "en": "Write a Rust function `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` to solve the following problem:\nCalculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "sq": "Shkruani një funksion në Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` për të zgjidhur problemin e mëposhtëm:\nLlogarit gjatësinë e nënvargut më të gjatë jo-zbritës në një varg të dhënë numrash.\n\nFunksioni merr një vektor të numrave të plotë dhe kthen gjatësinë e nënvargut më të gjatë ku secili element nuk është më i vogël se ai i mëparshmi.\n\nArgumentet:\n- sequence: Një vektor i numrave të plotë.\n\nKthen:\n- Gjatësia e nënvargut më të gjatë jo-zbritës në vargun e dhënë.\n\nShembuj:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) kthen 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) kthen 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) kthen 4",
      "hy": "Գրեք Rust ֆունկցիա `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված թվերի հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը:\n\nՖունկցիան ընդունում է ամբողջ թվերի վեկտոր և վերադարձնում է ամենաերկար ենթահաջորդականության երկարությունը, որտեղ յուրաքանչյուր տարր չի պակասում նախորդից:\n\nԱրգումենտներ:\n- sequence: Ամբողջ թվերի վեկտոր:\n\nՎերադարձնում է:\n- Տրված հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը:\n\nՕրինակներ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) վերադարձնում է 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) վերադարձնում է 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) վերադարձնում է 4",
      "bn": "Rust ফাংশন `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত সংখ্যার ক্রমে দীর্ঘতম অ-হ্রাসমান উপ-ক্রমের দৈর্ঘ্য গণনা করে।\n\nফাংশনটি পূর্ণসংখ্যার একটি ভেক্টর গ্রহণ করে এবং দীর্ঘতম উপ-ক্রমের দৈর্ঘ্য ফেরত দেয় যেখানে প্রতিটি উপাদান পূর্ববর্তীটির চেয়ে কম নয়।\n\nআর্গুমেন্টসমূহ:\n- sequence: পূর্ণসংখ্যার একটি ভেক্টর।\n\nফেরত দেয়:\n- প্রদত্ত ক্রমে দীর্ঘতম অ-হ্রাসমান উপ-ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 ফেরত দেয়\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 ফেরত দেয়\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 ফেরত দেয়",
      "bg": "Напишете функция на Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize`, за да решите следния проблем:\nИзчислява дължината на най-дългата невъзходяща подредица в дадена последователност от числа.\n  \nФункцията приема вектор от цели числа и връща дължината на най-дългата подредица, в която всеки елемент не е по-малък от предишния.\n\nАргументи:\n- sequence: Вектор от цели числа.\n\nВръща:\n- Дължината на най-дългата невъзходяща подредица в дадената последователност.\n\nПримери:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) връща 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) връща 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) връща 4",
      "zh": "编写一个 Rust 函数 `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` 来解决以下问题：\n计算给定数字序列中最长非递减子序列的长度。\n\n该函数接受一个整数向量并返回最长子序列的长度，其中每个元素不小于前一个元素。\n\n参数：\n- sequence: 一个整数向量。\n\n返回值：\n- 给定序列中最长非递减子序列的长度。\n\n示例：\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 返回 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 返回 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 返回 4",
      "fr": "Écrire une fonction Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` pour résoudre le problème suivant :\nCalcule la longueur de la plus longue sous-séquence non décroissante dans une séquence donnée de nombres.\n  \n  La fonction prend un vecteur d'entiers et renvoie la longueur de la plus longue sous-séquence où chaque élément n'est pas inférieur au précédent.\n\n  Arguments :\n  - sequence : Un vecteur d'entiers.\n\n  Renvoie :\n  - La longueur de la plus longue sous-séquence non décroissante dans la séquence donnée.\n\n  Exemples :\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) renvoie 4",
      "de": "Schreiben Sie eine Rust-Funktion `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize`, um das folgende Problem zu lösen:\nBerechnet die Länge der längsten nicht abnehmenden Teilsequenz in einer gegebenen Zahlenfolge.\n\nDie Funktion nimmt einen Vektor von ganzen Zahlen und gibt die Länge der längsten Teilsequenz zurück, bei der jedes Element nicht kleiner als das vorherige ist.\n\nArgumente:\n- sequence: Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\n- Die Länge der längsten nicht abnehmenden Teilsequenz in der gegebenen Sequenz.\n\nBeispiele:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) gibt 3 zurück\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) gibt 3 zurück\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) gibt 4 zurück",
      "ha": "Rubuta aikin Rust `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` don warware matsalar mai zuwa:\nYana ƙididdige tsawon mafi tsawo subsequence mara raguwa a cikin jerin lambobi da aka bayar.\n\n  Aikin yana ɗaukar vector na lambobi kuma yana mayar da tsawon mafi tsawo subsequence inda kowane abu ba ya raguwa daga wanda ya gabace shi.\n\n  Huɗɗa:\n  - sequence: Wani vector na lambobi.\n\n  Mayarwa:\n  - Tsawon mafi tsawo subsequence mara raguwa a cikin jerin da aka bayar.\n\n  Misalai:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) yana mayar da 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) yana mayar da 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) yana mayar da 4",
      "hi": "Rust फ़ंक्शन `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं के अनुक्रम में सबसे लंबी गैर-घटती उप-अनुक्रम की लंबाई की गणना करता है।\n\nयह फ़ंक्शन पूर्णांकों के एक वेक्टर को लेता है और उस सबसे लंबी उप-अनुक्रम की लंबाई लौटाता है जहाँ प्रत्येक तत्व पिछले तत्व से कम नहीं होता।\n\nतर्क:\n- sequence: पूर्णांकों का एक वेक्टर।\n\nवापसी:\n- दिए गए अनुक्रम में सबसे लंबी गैर-घटती उप-अनुक्रम की लंबाई।\n\nउदाहरण:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 लौटाता है\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 लौटाता है\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize` a következő probléma megoldására:\nKiszámítja a leghosszabb nem csökkenő részszekvencia hosszát egy adott számokból álló sorozatban.\n\nA függvény egy egész számokat tartalmazó vektort vesz át, és visszaadja a leghosszabb részszekvencia hosszát, ahol minden elem nem kisebb, mint az előző.\n\nArgumentumok:\n- sequence: Egy egész számokat tartalmazó vektor.\n\nVisszatérési érték:\n- A leghosszabb nem csökkenő részszekvencia hossza az adott sorozatban.\n\nPéldák:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) visszaadja 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) visszaadja 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) visszaadja 4"
    },
    "instruction_bertscore": {
      "sq": "0.9864919423073414",
      "hy": "0.9951053501505382",
      "bn": "0.9886784655417734",
      "bg": "0.998513847489097",
      "zh": "0.9858410305486901",
      "fr": "0.9988217245797011",
      "de": "0.9941570887114777",
      "ha": "0.9679130496172431",
      "hi": "0.9868645729021629",
      "hu": "0.9926653745499057"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![1, 2, 3]), 3);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![]), 0);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![10]), 1);        \n    }\n    \n\n}",
    "entry_point": "longest_non_decreasing_subsequence_length",
    "signature": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize",
    "docstring": {
      "en": "Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "sq": "Llogarit gjatësinë e nënvargut më të gjatë jo-zbritës në një varg të dhënë numrash.\n\n  Funksioni merr një vektor të numrave të plotë dhe kthen gjatësinë e nënvargut më të gjatë ku secili element nuk është më i vogël se ai i mëparshmi.\n\n  Argumentet:\n  - sequence: Një vektor i numrave të plotë.\n\n  Kthen:\n  - Gjatësia e nënvargut më të gjatë jo-zbritës në vargun e dhënë.\n\n  Shembuj:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) kthen 4",
      "hy": "Հաշվում է տրված թվերի հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\nՖունկցիան ընդունում է ամբողջ թվերի վեկտոր և վերադարձնում է ամենաերկար ենթահաջորդականության երկարությունը, որտեղ յուրաքանչյուր տարր չի փոքրանում նախորդից։\n\nԱրգումենտներ:\n- sequence: Ամբողջ թվերի վեկտոր։\n\nՎերադարձնում է:\n- Տրված հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\nՕրինակներ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) վերադարձնում է 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) վերադարձնում է 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) վերադարձնում է 4",
      "bn": "প্রদত্ত সংখ্যার সিকোয়েন্সের মধ্যে দীর্ঘতম অ-হ্রাসমান উপসিকোয়েন্সের দৈর্ঘ্য গণনা করে।\n  \n  ফাংশনটি পূর্ণসংখ্যার একটি ভেক্টর গ্রহণ করে এবং দীর্ঘতম উপধারাটির দৈর্ঘ্য প্রদান করে যেখানে প্রতিটি উপাদান পূর্ববর্তীটির চেয়ে কম নয়।\n\n  Arguments:\n  - sequence: পূর্ণসংখ্যার একটি ভেক্টর।\n\n  Returns:\n  - প্রদত্ত ক্রমের দীর্ঘতম অ-হ্রাসকারী উপধারাটির দৈর্ঘ্য।\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "bg": "Изчислява дължината на най-дългата ненамаляваща подредица в дадена последователност от числа.\n\nФункцията приема вектор от цели числа и връща дължината на най-дългата подредица, в която всеки елемент не е по-малък от предходния.\n\nАргументи:\n- sequence: Вектор от цели числа.\n\nВръща:\n- Дължината на най-дългата ненамаляваща подредица в дадената последователност.\n\nПримери:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) връща 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) връща 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) връща 4",
      "zh": "计算给定数字序列中最长非递减子序列的长度。\n\n该函数接受一个整数向量，并返回最长子序列的长度，其中每个元素都不小于前一个元素。\n\n参数：\n- sequence: 一个整数向量。\n\n返回：\n- 给定序列中最长非递减子序列的长度。\n\n示例：\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 返回 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 返回 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 返回 4",
      "fr": "Calcule la longueur de la plus longue sous-séquence non décroissante dans une séquence donnée de nombres.\n\n  La fonction prend un vecteur d'entiers et renvoie la longueur de la plus longue sous-séquence où chaque élément n'est pas inférieur au précédent.\n\n  Arguments:\n  - sequence: Un vecteur d'entiers.\n\n  Renvoie:\n  - La longueur de la plus longue sous-séquence non décroissante dans la séquence donnée.\n\n  Exemples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) renvoie 4",
      "de": "Berechnet die Länge der längsten nicht abnehmenden Teilfolge in einer gegebenen Zahlenfolge.\n\nDie Funktion nimmt einen Vektor von ganzen Zahlen und gibt die Länge der längsten Teilfolge zurück, bei der jedes Element nicht kleiner als das vorherige ist.\n\nArgumente:\n- sequence: Ein Vektor von ganzen Zahlen.\n\nRückgabewerte:\n- Die Länge der längsten nicht abnehmenden Teilfolge in der gegebenen Folge.\n\nBeispiele:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) gibt 3 zurück\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) gibt 3 zurück\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) gibt 4 zurück",
      "ha": "Lissafin tsawon mafi tsawo wanda ba ya raguwa a cikin jerin lambobi da aka bayar.\n\n  Aikin yana ɗaukar wata vector na lambobi kuma yana mayar da tsawon mafi tsawo subsequence inda kowane abu ba ya raguwa daga wanda ya gabace shi.\n\n  Huɗɗa:\n  - sequence: Wata vector na lambobi.\n\n  Mayarwa:\n  - Tsawon mafi tsawo subsequence wanda ba ya raguwa a cikin jerin da aka bayar.\n\n  Misalai:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "hi": "गणना करता है कि संख्याओं के दिए गए अनुक्रम में सबसे लंबा गैर-घटता उप-अनुक्रम कितना लंबा है।\n\nयह फ़ंक्शन पूर्णांकों के एक वेक्टर को लेता है और सबसे लंबे उप-अनुक्रम की लंबाई लौटाता है जहाँ प्रत्येक तत्व पिछले तत्व से कम नहीं होता।\n\nआर्गुमेंट्स:\n- sequence: पूर्णांकों का एक वेक्टर।\n\nरिटर्न्स:\n- दिए गए अनुक्रम में सबसे लंबे गैर-घटता उप-अनुक्रम की लंबाई।\n\nउदाहरण:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 लौटाता है\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 लौटाता है\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 लौटाता है",
      "hu": "Kiszámítja a leghosszabb nem csökkenő részszekvencia hosszát egy adott számokból álló sorozatban.\n\n  A függvény egy egész számokat tartalmazó vektort vesz át, és visszaadja a leghosszabb részszekvencia hosszát, ahol minden elem nem kisebb, mint az előző.\n\n  Argumentumok:\n  - sequence: Egy egész számokat tartalmazó vektor.\n\n  Visszatérési érték:\n  - A leghosszabb nem csökkenő részszekvencia hossza az adott sorozatban.\n\n  Példák:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) visszaadja 4"
    },
    "docstring_bertscore": {
      "sq": "0.9867722097749816",
      "hy": "0.9928332172218802",
      "bn": "0.9969099071622403",
      "bg": "0.9982429156493654",
      "zh": "0.9855381192176118",
      "fr": "0.9981535319778997",
      "de": "0.9924427098927656",
      "ha": "0.9725099525255335",
      "hi": "0.9898289327087275",
      "hu": "0.9890363974883983"
    }
  },
  {
    "task_id": "Rust/44",
    "prompt": {
      "en": "/*\n  Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "sq": "/*\n  Numëron numrin e çifteve të studentëve, notat e të cilëve në secilin lëndë (Kinezisht, Matematikë, Anglisht) ndryshojnë me jo më shumë se 5 pikë, dhe ndryshimi i totalit të pikëve është jo më shumë se 10 pikë. Të tilla çifte konsiderohen \"të barabarta\".\n\n  Argumentet:\n  - scores: Një vektor tuplesh, secili që përmban tre numra të plotë që përfaqësojnë notat e një studenti në Kinezisht, Matematikë dhe Anglisht, përkatësisht.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e çifteve të studentëve \"të barabarta\".\n\n  Shembull:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) kthen 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "hy": "/*\n  Հաշվում է այն ուսանողների զույգերի քանակը, որոնց յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը չի գերազանցում 5 միավորը, և որոնց ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10 միավորը: Նման զույգերը համարվում են \"հավասարապես համընկնող\":\n\n  Արգումենտներ:\n  - scores: Վեկտոր, որը պարունակում է եռյակներ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի գնահատականները չինարենում, մաթեմատիկայում և անգլերենում համապատասխանաբար:\n\n  Վերադարձնում է:\n  - Թիվ, որը ներկայացնում է \"հավասարապես համընկնող\" ուսանողների զույգերի քանակը:\n\n  Օրինակ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) վերադարձնում է 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "bn": "/*\n  ছাত্রদের জোড়ার সংখ্যা গণনা করে যাদের প্রতিটি বিষয়ে (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ পয়েন্টের বেশি নয়, এবং যাদের মোট স্কোর পার্থক্য ১০ পয়েন্টের বেশি নয়। এমন জোড়াগুলোকে \"সমানভাবে মেলানো\" বলে বিবেচনা করা হয়।\n\n  আর্গুমেন্টস:\n  - scores: একটি টুপলের ভেক্টর, প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা একটি ছাত্রের চীনা, গণিত এবং ইংরেজিতে স্কোর উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা \"সমানভাবে মেলানো\" ছাত্রদের জোড়ার সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) ২ রিটার্ন করে\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "bg": "/*\n  Брои броя на двойките ученици, чиито оценки по всеки предмет (Китайски, Математика, Английски) се различават с не повече от 5 точки, и чиято разлика в общия резултат е не повече от 10 точки. Такива двойки се считат за \"равностойни\".\n\n  Аргументи:\n  - scores: Вектор от кортежи, всеки съдържащ три цели числа, представляващи оценките на ученик по Китайски, Математика и Английски, съответно.\n\n  Връща:\n  - Цяло число, представляващо броя на \"равностойните\" двойки ученици.\n\n  Пример:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) връща 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "zh": "/*\n  计算在每个科目（语文、数学、英语）中分数差不超过5分，且总分差不超过10分的学生对数。这样的对被认为是“旗鼓相当”的。\n\n  参数：\n  - scores: 一个元组的向量，每个元组包含三个整数，分别表示一个学生在语文、数学和英语中的分数。\n\n  返回：\n  - 一个整数，表示“旗鼓相当”的学生对数。\n\n  示例：\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 返回 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "fr": "/*\n  Compte le nombre de paires d'étudiants dont les scores dans chaque matière (Chinois, Mathématiques, Anglais) diffèrent de pas plus de 5 points, et dont la différence de score total est de pas plus de 10 points. De telles paires sont considérées comme \"également assorties\".\n\n  Arguments:\n  - scores: Un vecteur de tuples, chacun contenant trois entiers représentant les scores d'un étudiant en Chinois, Mathématiques et Anglais, respectivement.\n\n  Retourne:\n  - Un entier représentant le nombre de paires d'étudiants \"également assorties\".\n\n  Exemple:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) retourne 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "de": "/*\n  Zählt die Anzahl der Schülerpaare, deren Punktzahlen in jedem Fach (Chinesisch, Mathematik, Englisch) sich um nicht mehr als 5 Punkte unterscheiden und deren Gesamtpunktzahlunterschied nicht mehr als 10 Punkte beträgt. Solche Paare gelten als \"gleichwertig\".\n\n  Argumente:\n  - scores: Ein Vektor von Tupeln, die jeweils drei ganze Zahlen enthalten, die die Punktzahlen eines Schülers in Chinesisch, Mathematik und Englisch darstellen.\n\n  Rückgabe:\n  - Eine ganze Zahl, die die Anzahl der \"gleichwertigen\" Schülerpaare darstellt.\n\n  Beispiel:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) gibt 2 zurück\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "ha": "/*\n  Yana ƙirga yawan ma'aurata ɗalibai waɗanda maki nasu a kowace darasi (Sinanci, Lissafi, Turanci) ba su bambanta da fiye da maki 5 ba, kuma bambancin jimillar maki nasu ba ya wuce maki 10. Ana ɗaukar irin waɗannan ma'auratan a matsayin \"daidai gwargwado\".\n\n  Huɗa:\n  - scores: Wani vector na tuples, kowanne dauke da lambobi guda uku da ke wakiltar maki na ɗalibi a Sinanci, Lissafi, da Turanci, bi da bi.\n\n  Komawa:\n  - Wani lamba da ke wakiltar yawan ma'aurata ɗalibai \"daidai gwargwado\".\n\n  Misali:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "hi": "/*\n  उन छात्र जोड़ों की संख्या गिनता है जिनके प्रत्येक विषय (चीनी, गणित, अंग्रेजी) में अंक 5 अंकों से अधिक नहीं भिन्न होते हैं, और जिनके कुल अंक का अंतर 10 अंकों से अधिक नहीं होता है। ऐसे जोड़े \"समान रूप से मेल खाते\" माने जाते हैं।\n\n  तर्क:\n  - scores: ट्यूपल का एक वेक्टर, प्रत्येक में तीन पूर्णांक होते हैं जो क्रमशः चीनी, गणित, और अंग्रेजी में एक छात्र के अंक दर्शाते हैं।\n\n  लौटाता है:\n  - एक पूर्णांक जो \"समान रूप से मेल खाते\" छात्र जोड़ों की संख्या दर्शाता है।\n\n  उदाहरण:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 लौटाता है\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
      "hu": "/*\n  Megszámolja azon diákpárok számát, akiknek az egyes tantárgyakban (Kínai, Matematika, Angol) elért pontszáma legfeljebb 5 ponttal tér el egymástól, és akiknek az összpontszám különbsége legfeljebb 10 pont. Az ilyen párokat \"egyenlően illeszkedőnek\" tekintjük.\n\n  Argumentumok:\n  - scores: Egy vektor, amely tuple-öket tartalmaz, mindegyik három egész számot tartalmaz, amelyek egy diák pontszámait képviselik Kínai, Matematika és Angol tantárgyakban, ebben a sorrendben.\n\n  Visszatér:\n  - Egy egész szám, amely az \"egyenlően illeszkedő\" diákpárok számát jelenti.\n\n  Példa:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) visszatér 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9744926809890238",
      "hy": "0.9459528719507879",
      "bn": "0.9715440129825609",
      "bg": "0.9687097560755741",
      "zh": "0.941506928132084",
      "fr": "0.9930185393673857",
      "de": "0.9665901712795508",
      "ha": "0.9438092528786595",
      "hi": "0.9788410972906396",
      "hu": "0.9805489213067775"
    },
    "canonical_solution": "{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` to solve the following problem:\nCounts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "sq": "Shkruani një funksion në Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` për të zgjidhur problemin e mëposhtëm:\nNumëron çiftet e studentëve, notat e të cilëve në secilin lëndë (Kinezisht, Matematikë, Anglisht) ndryshojnë me jo më shumë se 5 pikë, dhe ndryshimi i totalit të pikëve është jo më shumë se 10 pikë. Të tilla çifte konsiderohen \"të barabartë\".\n\n  Argumentet:\n  - scores: Një vektor i treshave, secila që përmban tre numra të plotë që përfaqësojnë notat e një studenti në Kinezisht, Matematikë, dhe Anglisht, përkatësisht.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e çifteve të studentëve \"të barabartë\".\n\n  Shembull:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) kthen 2",
      "hy": "Գրեք Rust ֆունկցիա `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ուսանողների զույգերի քանակը, որոնց միավորները յուրաքանչյուր առարկայում (չինարեն, մաթեմատիկա, անգլերեն) տարբերվում են ոչ ավելի, քան 5 միավորով, և որոնց ընդհանուր միավորների տարբերությունը ոչ ավելի է, քան 10 միավոր: Նման զույգերը համարվում են \"հավասարապես համընկնող\":\n\n  Փաստարկներ:\n  - scores: Վեկտոր, որը պարունակում է երեք ամբողջ թվերից կազմված տուփեր, որոնք ներկայացնում են ուսանողի միավորները չինարենում, մաթեմատիկայում և անգլերենում, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է \"հավասարապես համընկնող\" ուսանողների զույգերի քանակը:\n\n  Օրինակ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) վերադարձնում է 2",
      "bn": "Rust ফাংশন `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nগণনা করে কতগুলি ছাত্র জোড়া রয়েছে যাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ পয়েন্টের বেশি নয়, এবং যাদের মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি নয়। এমন জোড়াগুলি \"সমানভাবে মেলানো\" বলে বিবেচিত হয়।\n\n  আর্গুমেন্টসমূহ:\n  - scores: একটি ভেক্টর টাপলগুলির, প্রতিটি টাপল তিনটি পূর্ণসংখ্যা ধারণ করে যা চীনা, গণিত, এবং ইংরেজিতে একটি ছাত্রের স্কোর প্রতিনিধিত্ব করে।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা \"সমানভাবে মেলানো\" ছাত্র জোড়ার সংখ্যা প্রতিনিধিত্ব করে।\n\n  উদাহরণ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 রিটার্ন করে।",
      "bg": "Напишете функция на Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32`, за да решите следния проблем:\nБрои броя на двойките ученици, чиито оценки по всеки предмет (Китайски, Математика, Английски) се различават с не повече от 5 точки и чиято разлика в общия резултат е не повече от 10 точки. Такива двойки се считат за \"равностойни\".\n\n  Аргументи:\n  - scores: Вектор от кортежи, всеки съдържащ три цели числа, представляващи оценките на ученик по Китайски, Математика и Английски, съответно.\n\n  Връща:\n  - Цяло число, представляващо броя на \"равностойните\" двойки ученици.\n\n  Пример:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) връща 2",
      "zh": "编写一个 Rust 函数 `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` 来解决以下问题：\n计算学生对的数量，这些学生在每个科目（语文、数学、英语）的分数差不超过5分，并且总分差不超过10分。这样的学生对被认为是“匹配的”。\n\n参数：\n- scores: 一个元组的向量，每个元组包含三个整数，分别代表一个学生在语文、数学和英语的分数。\n\n返回：\n- 一个整数，表示“匹配的”学生对的数量。\n\n示例：\n- count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 返回 2",
      "fr": "Écrire une fonction Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` pour résoudre le problème suivant :\nCompte le nombre de paires d'étudiants dont les scores dans chaque matière (Chinois, Mathématiques, Anglais) diffèrent de pas plus de 5 points, et dont la différence de score total ne dépasse pas 10 points. De telles paires sont considérées comme \"équitablement appariées\".\n\n  Arguments :\n  - scores : Un vecteur de tuples, chacun contenant trois entiers représentant les scores d'un étudiant en Chinois, Mathématiques et Anglais, respectivement.\n\n  Renvoie :\n  - Un entier représentant le nombre de paires d'étudiants \"équitablement appariées\".\n\n  Exemple :\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) renvoie 2",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32`, um das folgende Problem zu lösen:\nZählt die Anzahl der Schülerpaare, deren Punktzahlen in jedem Fach (Chinesisch, Mathematik, Englisch) um nicht mehr als 5 Punkte differieren und deren Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt. Solche Paare werden als \"gleichwertig\" betrachtet.\n\n  Argumente:\n  - scores: Ein Vektor von Tupeln, die jeweils drei ganze Zahlen enthalten, die die Punktzahlen eines Schülers in Chinesisch, Mathematik und Englisch darstellen.\n\n  Rückgabe:\n  - Eine ganze Zahl, die die Anzahl der \"gleichwertigen\" Schülerpaare darstellt.\n\n  Beispiel:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) gibt 2 zurück",
      "ha": "Rubuta aikin Rust `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` don warware matsalar mai zuwa:\nYana ƙididdige adadin ma'aurata ɗalibai waɗanda maki a kowace darasi (Sinanci, Lissafi, Turanci) suka bambanta da maki ba fiye da 5 ba, kuma bambancin jimlar maki ba fiye da maki 10 ba. Ana ɗaukar irin waɗannan ma'auratan a matsayin \"daidai gwargwado\".\n\n  Huɗɗa:\n  - scores: Wani vector na tuples, kowanne dauke da lambobi uku da ke wakiltar maki na ɗalibi a Sinanci, Lissafi, da Turanci, bi da bi.\n\n  Komawa:\n  - Wani lamba da ke wakiltar adadin ma'aurata ɗalibai \"daidai gwargwado\".\n\n  Misali:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) yana dawowa da 2",
      "hi": "Rust फ़ंक्शन `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन छात्र जोड़ों की संख्या गिनें जिनके प्रत्येक विषय (चीनी, गणित, अंग्रेजी) में अंक 5 अंकों से अधिक नहीं भिन्न होते हैं, और जिनके कुल अंक का अंतर 10 अंकों से अधिक नहीं होता है। ऐसे जोड़े \"समान रूप से मेल खाते\" माने जाते हैं।\n\n  तर्क:\n  - scores: ट्यूपल का एक वेक्टर, जिसमें प्रत्येक छात्र के चीनी, गणित और अंग्रेजी में अंक दर्शाने वाले तीन पूर्णांक होते हैं।\n\n  लौटाता है:\n  - एक पूर्णांक जो \"समान रूप से मेल खाते\" छात्र जोड़ों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32` a következő probléma megoldására:\nSzámolja meg azon diákpárok számát, akiknek az egyes tantárgyakban (kínai, matematika, angol) elért pontszáma legfeljebb 5 ponttal különbözik, és akiknek az összpontszám-különbsége legfeljebb 10 pont. Az ilyen párokat \"egyenlően illeszkedőnek\" tekintjük.\n\n  Argumentumok:\n  - scores: Egy vektor, amely tuple-öket tartalmaz, mindegyik három egész számot tartalmaz, amelyek egy diák pontszámait képviselik kínai, matematika és angol tantárgyakban.\n\n  Visszatérési érték:\n  - Egy egész szám, amely az \"egyenlően illeszkedő\" diákpárok számát képviseli.\n\n  Példa:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9535862374939588",
      "hy": "0.9760374294623321",
      "bn": "0.9474416066566445",
      "bg": "0.9721174588926086",
      "zh": "0.9439467051023356",
      "fr": "0.9772488761562639",
      "de": "0.9671316376982518",
      "ha": "0.9526365856422309",
      "hi": "0.9544995399859572",
      "hu": "0.9814250799175225"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]), 2);\n        assert_eq!(count_comparable_pairs(vec![(100, 100, 100), (95, 95, 95), (90, 90, 90)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 85, 80), (80, 85, 90), (70, 75, 80)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90)]), 0);\n    }\n    \n\n}",
    "entry_point": "count_comparable_pairs",
    "signature": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
    "docstring": {
      "en": "Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "sq": "Numëron numrin e çifteve të studentëve, notat e të cilëve në secilin lëndë (Kinezisht, Matematikë, Anglisht) ndryshojnë me jo më shumë se 5 pikë, dhe ndryshimi i totalit të pikëve është jo më shumë se 10 pikë. Të tilla çifte konsiderohen \"të barabarta\".\n\nArguments:\n- scores: Një vektor tuplesh, secili që përmban tre numra të plotë që përfaqësojnë notat e një studenti në Kinezisht, Matematikë dhe Anglisht, përkatësisht.\n\nReturns:\n- Një numër i plotë që përfaqëson numrin e çifteve të studentëve \"të barabarta\".\n\nExample:\n- count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "hy": "Հաշվում է այն ուսանողական զույգերի քանակը, որոնցից յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) միավորները տարբերվում են ոչ ավելի, քան 5 միավորով, և որոնց ընդհանուր միավորների տարբերությունը ոչ ավելի է, քան 10 միավոր: Նման զույգերը համարվում են \"հավասարապես համընկնող\":\n\n  Արգումենտներ:\n  - scores: Վեկտոր, որը պարունակում է եռյակներ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի միավորները չինարենում, մաթեմատիկայում և անգլերենում, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է \"հավասարապես համընկնող\" ուսանողական զույգերի քանակը:\n\n  Օրինակ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) վերադարձնում է 2",
      "bn": "প্রত্যেক বিষয়ে (চীনা, গণিত, ইংরেজি) ছাত্রদের স্কোরের মধ্যে পার্থক্য ৫ পয়েন্টের বেশি নয় এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি নয় এমন ছাত্র জোড়ার সংখ্যা গণনা করে। এমন জোড়াগুলিকে \"সমানভাবে মেলানো\" বলে বিবেচনা করা হয়।\n\n  আর্গুমেন্টস:\n  - scores: একটি টুপলের ভেক্টর, প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা যথাক্রমে চীনা, গণিত এবং ইংরেজিতে একজন ছাত্রের স্কোর উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা \"সমানভাবে মেলানো\" ছাত্র জোড়ার সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 রিটার্ন করে।",
      "bg": "Брои броя на двойките ученици, чиито резултати по всеки предмет (Китайски, Математика, Английски) се различават с не повече от 5 точки, и чиято разлика в общия резултат е не повече от 10 точки. Такива двойки се считат за \"равностойни\".\n\n  Аргументи:\n  - scores: Вектор от кортежи, всеки съдържащ три цели числа, представляващи резултатите на ученик по Китайски, Математика и Английски, съответно.\n\n  Връща:\n  - Цяло число, представляващо броя на \"равностойните\" двойки ученици.\n\n  Пример:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) връща 2",
      "zh": "计算每对学生在每个科目（语文、数学、英语）中的分数差不超过5分，并且总分差不超过10分的数量。这样的对被认为是“匹配相等”。\n\n  参数:\n  - scores: 一个元组向量，每个元组包含三个整数，分别代表一个学生在语文、数学和英语中的分数。\n\n  返回:\n  - 一个整数，表示“匹配相等”的学生对的数量。\n\n  示例:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 返回 2",
      "fr": "Compte le nombre de paires d'étudiants dont les scores dans chaque matière (Chinois, Mathématiques, Anglais) diffèrent de pas plus de 5 points, et dont la différence de score total est de pas plus de 10 points. De telles paires sont considérées comme \"également assorties\".\n\n  Arguments:\n  - scores: Un vecteur de tuples, chacun contenant trois entiers représentant les scores d'un étudiant en Chinois, Mathématiques et Anglais, respectivement.\n\n  Retourne:\n  - Un entier représentant le nombre de paires d'étudiants \"également assorties\".\n\n  Exemple:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) retourne 2",
      "de": "Zählt die Anzahl der Schülerpaare, deren Punktzahlen in jedem Fach (Chinesisch, Mathematik, Englisch) um nicht mehr als 5 Punkte differieren und deren Gesamtpunktzahlunterschied nicht mehr als 10 Punkte beträgt. Solche Paare werden als \"gleichwertig\" betrachtet.\n\n  Argumente:\n  - scores: Ein Vektor von Tupeln, die jeweils drei ganze Zahlen enthalten, die die Punktzahlen eines Schülers in Chinesisch, Mathematik und Englisch darstellen.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Anzahl der \"gleichwertigen\" Schülerpaare darstellt.\n\n  Beispiel:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) gibt 2 zurück",
      "ha": "Yana ƙirga yawan ma'aurata ɗalibai waɗanda maki nasu a kowace darasi (Sinanci, Lissafi, Turanci) ba su bambanta da fiye da maki 5 ba, kuma bambancin jimillar maki nasu ba ya wuce maki 10. Ana ɗaukar irin waɗannan ma'auratan a matsayin \"daidai gwargwado\".\n\n  Huɗɗa:\n  - scores: Wata vector na tuples, kowanne yana ɗauke da lambobi guda uku da ke wakiltar maki na ɗalibi a cikin Sinanci, Lissafi, da Turanci, bi da bi.\n\n  Komawa:\n  - Wani lamba da ke wakiltar adadin \"daidaitattun\" ma'aurata ɗalibai.\n\n  Misali:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "hi": "प्रत्येक विषय (चीनी, गणित, अंग्रेजी) में जिन छात्र जोड़ों के अंकों में अंतर 5 अंकों से अधिक नहीं है, और जिनके कुल अंक का अंतर 10 अंकों से अधिक नहीं है, उनकी संख्या गिनता है। ऐसे जोड़े \"समान रूप से मेल खाते\" माने जाते हैं।\n\n  तर्क:\n  - scores: ट्यूपल का एक वेक्टर, जिसमें प्रत्येक ट्यूपल तीन पूर्णांक शामिल करता है जो क्रमशः चीनी, गणित, और अंग्रेजी में एक छात्र के अंक का प्रतिनिधित्व करते हैं।\n\n  वापसी:\n  - एक पूर्णांक जो \"समान रूप से मेल खाते\" छात्र जोड़ों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 लौटाता है।",
      "hu": "Számolja meg azon diákpárok számát, akiknek az egyes tantárgyakban (kínai, matematika, angol) elért pontszámai legfeljebb 5 ponttal térnek el egymástól, és akiknek az összpontszám-különbsége legfeljebb 10 pont. Az ilyen párok \"egyenlően illeszkedőnek\" tekinthetők.\n\n  Argumentumok:\n  - scores: Egy vektor, amely tuple-öket tartalmaz, mindegyik három egész számot tartalmaz, amelyek egy diák kínai, matematika és angol pontszámait képviselik.\n\n  Visszatér:\n  - Egy egész szám, amely az \"egyenlően illeszkedő\" diákpárok számát jelenti.\n\n  Példa:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) visszatér 2"
    },
    "docstring_bertscore": {
      "sq": "0.9708235805905473",
      "hy": "0.9629796668434796",
      "bn": "0.9484869983520311",
      "bg": "0.9682977966653077",
      "zh": "0.9338761447838667",
      "fr": "0.9951861927156195",
      "de": "0.9672480351015383",
      "ha": "0.9708317244361698",
      "hi": "0.9544069782283948",
      "hu": "0.9796441599211636"
    }
  },
  {
    "task_id": "Rust/45",
    "prompt": {
      "en": "/*\n  Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare dhe një normë konvertimi të bishtave të cigareve në cigare të reja.\n\n  Argumentet:\n  - initial_cigarettes: Numri fillestar i cigareve që ka Pjetri.\n  - butts_for_new: Numri i bishtave të cigareve të kërkuara për t'i shkëmbyer për një cigare të re.\n\n  Kthen:\n  - Numri total i cigareve që Pjetri mund të pijë duke përfshirë ato të marra duke shkëmbyer bishtat për të reja.\n\n  Shembull:\n  - total_smoked_cigarettes(4, 3) kthen 5\n  - total_smoked_cigarettes(10, 3) kthen 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
      "hy": "/*\n  Հաշվում է ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել տրված սկզբնական քանակով և ծխախոտի մնացորդների փոխանակման հարաբերակցությամբ:\n\n  Արգումենտներ:\n  - initial_cigarettes: Սկզբնական ծխախոտների քանակը, որ Պետերը ունի:\n  - butts_for_new: Ծխախոտի մնացորդների քանակը, որը պահանջվում է մեկ նոր ծխախոտի փոխանակման համար:\n\n  Վերադարձնում է:\n  - Ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել, ներառյալ այն, որոնք ստացվում են մնացորդների փոխանակման միջոցով:\n\n  Օրինակ:\n  - total_smoked_cigarettes(4, 3) վերադարձնում է 5\n  - total_smoked_cigarettes(10, 3) վերադարձնում է 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
      "bn": "/*\n  পিটার মোট কতগুলি সিগারেট খেতে পারবে তা গণনা করে, প্রদত্ত প্রাথমিক পরিমাণ এবং সিগারেটের বাট থেকে নতুন সিগারেট পাওয়ার রূপান্তর হারের ভিত্তিতে।\n\n  আর্গুমেন্টসমূহ:\n  - initial_cigarettes: পিটারের কাছে প্রাথমিকভাবে থাকা সিগারেটের সংখ্যা।\n  - butts_for_new: একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেটের বাটের সংখ্যা।\n\n  রিটার্নস:\n  - পিটার মোট কতগুলি সিগারেট খেতে পারবে, যার মধ্যে বাট বিনিময় করে পাওয়া সিগারেটও অন্তর্ভুক্ত।\n\n  উদাহরণ:\n  - total_smoked_cigarettes(4, 3) 5 রিটার্ন করে\n  - total_smoked_cigarettes(10, 3) 14 রিটার্ন করে\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
      "bg": "/*\n  Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началното количество и курсът на преобразуване на фасове в нови цигари.\n\n  Аргументи:\n  - initial_cigarettes: Началният брой цигари, които Петър има.\n  - butts_for_new: Броят на фасовете, необходими за размяна за една нова цигара.\n\n  Връща:\n  - Общият брой цигари, които Петър може да изпуши, включително тези, получени чрез размяна на фасове за нови.\n\n  Пример:\n  - total_smoked_cigarettes(4, 3) връща 5\n  - total_smoked_cigarettes(10, 3) връща 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "zh": "/*\n  计算彼得可以抽的香烟总数，给定初始数量和烟头换新香烟的兑换率。\n\n  参数:\n  - initial_cigarettes: 彼得拥有的初始香烟数量。\n  - butts_for_new: 需要多少个烟头才能兑换一支新香烟。\n\n  返回:\n  - 彼得可以抽的香烟总数，包括通过兑换烟头获得的新香烟。\n\n  示例:\n  - total_smoked_cigarettes(4, 3) 返回 5\n  - total_smoked_cigarettes(10, 3) 返回 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
      "fr": "/*\n  Calcule le nombre total de cigarettes que Peter peut fumer étant donné une quantité initiale et un taux de conversion de mégots de cigarettes en nouvelles cigarettes.\n\n  Arguments:\n  - initial_cigarettes: Le nombre initial de cigarettes que Peter a.\n  - butts_for_new: Le nombre de mégots de cigarettes requis pour échanger contre une nouvelle cigarette.\n\n  Retourne:\n  - Le nombre total de cigarettes que Peter peut fumer, y compris celles obtenues en échangeant des mégots contre de nouvelles.\n\n  Exemple:\n  - total_smoked_cigarettes(4, 3) retourne 5\n  - total_smoked_cigarettes(10, 3) retourne 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "de": "/*\n  Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine Anfangsmenge und eine Umtauschrate von Zigarettenstummeln zu neuen Zigaretten.\n\n  Argumente:\n  - initial_cigarettes: Die anfängliche Anzahl der Zigaretten, die Peter hat.\n  - butts_for_new: Die Anzahl der Zigarettenstummel, die erforderlich sind, um gegen eine neue Zigarette einzutauschen.\n\n  Rückgabe:\n  - Die Gesamtanzahl der Zigaretten, die Peter rauchen kann, einschließlich derjenigen, die durch den Umtausch von Stummeln gegen neue erhalten werden.\n\n  Beispiel:\n  - total_smoked_cigarettes(4, 3) gibt 5 zurück\n  - total_smoked_cigarettes(10, 3) gibt 14 zurück\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "ha": "/*\n  Lissafa adadin sigari da Peter zai iya sha la'akari da adadin farko da kuma yawan bututun sigari da ake bukata don musayar sabbin sigari.\n\n  Huɗɗa:\n  - initial_cigarettes: Adadin farko na sigari da Peter ke da shi.\n  - butts_for_new: Yawan bututun sigari da ake bukata don musayar sabuwar sigari guda.\n\n  Komawa:\n  - Jimillar adadin sigari da Peter zai iya sha ciki har da waɗanda aka samu ta hanyar musayar bututun don sabbi.\n\n  Misali:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "hi": "/*\n  यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है, दिए गए प्रारंभिक मात्रा और सिगरेट के बट्स को नई सिगरेट में बदलने की दर के आधार पर।\n\n  तर्क:\n  - initial_cigarettes: वह प्रारंभिक सिगरेट की संख्या जो पीटर के पास है।\n  - butts_for_new: नई सिगरेट के लिए विनिमय करने के लिए आवश्यक सिगरेट बट्स की संख्या।\n\n  वापसी:\n  - कुल सिगरेट की संख्या जो पीटर पी सकता है, जिसमें बट्स को नई सिगरेट में बदलकर प्राप्त की गई सिगरेट भी शामिल हैं।\n\n  उदाहरण:\n  - total_smoked_cigarettes(4, 3) 5 लौटाता है\n  - total_smoked_cigarettes(10, 3) 14 लौटाता है\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni egy kezdeti mennyiség és a csikkek új cigarettára való átváltási aránya alapján.\n\n  Argumentumok:\n  - initial_cigarettes: A kezdeti cigaretták száma, amivel Péter rendelkezik.\n  - butts_for_new: Az új cigaretta megszerzéséhez szükséges cigarettacsikkek száma.\n\n  Visszatér:\n  - Az összes cigaretta száma, amit Péter el tud szívni, beleértve azokat is, amelyeket csikkek újra cserélésével szerez meg.\n\n  Példa:\n  - total_smoked_cigarettes(4, 3) visszaadja 5\n  - total_smoked_cigarettes(10, 3) visszaadja 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9836664251371201",
      "hy": "0.9673783366314972",
      "bn": "0.9778882673528152",
      "bg": "0.9806615447328243",
      "zh": "0.9607307736694026",
      "fr": "0.9819363545183062",
      "de": "0.9906228583417239",
      "ha": "0.9688446261042968",
      "hi": "0.9615386034290715",
      "hu": "0.9806520104745347"
    },
    "canonical_solution": "{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}",
    "instruction": {
      "en": "Write a Rust function `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "sq": "Shkruani një funksion Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare dhe një normë konvertimi të bishtave të cigares në cigare të reja.\n\n  Argumentet:\n  - initial_cigarettes: Numri fillestar i cigareve që ka Pjetri.\n  - butts_for_new: Numri i bishtave të cigares që kërkohen për të shkëmbyer për një cigare të re.\n\n  Kthen:\n  - Numri total i cigareve që Pjetri mund të pijë duke përfshirë ato të marra duke shkëmbyer bishtat për të reja.\n\n  Shembull:\n  - total_smoked_cigarettes(4, 3) kthen 5\n  - total_smoked_cigarettes(10, 3) kthen 14",
      "hy": "Գրեք Rust ֆունկցիա `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր ծխած սիգարետների քանակը, որը կարող է ծխել Պետրոսը՝ հաշվի առնելով սկզբնական քանակը և սիգարետի մնացորդների փոխանակման հարաբերակցությունը նոր սիգարետների հետ:\n\n  Փոփոխականներ:\n  - initial_cigarettes: Սիգարետների սկզբնական քանակը, որը ունի Պետրոսը։\n  - butts_for_new: Սիգարետի մնացորդների քանակը, որը պահանջվում է մեկ նոր սիգարետի փոխանակման համար։\n\n  Վերադարձնում է:\n  - Սիգարետների ընդհանուր քանակը, որը կարող է ծխել Պետրոսը, ներառյալ նրանք, որոնք ստացվում են մնացորդների փոխանակման միջոցով։\n\n  Օրինակ:\n  - total_smoked_cigarettes(4, 3) վերադարձնում է 5\n  - total_smoked_cigarettes(10, 3) վերադարձնում է 14",
      "bn": "Rust ফাংশন `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রাথমিক পরিমাণ এবং সিগারেট বাট থেকে নতুন সিগারেটের রূপান্তর হারের ভিত্তিতে পিটার মোট কতগুলি সিগারেট খেতে পারে তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - initial_cigarettes: পিটারের কাছে থাকা প্রাথমিক সিগারেটের সংখ্যা।\n  - butts_for_new: একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n\n  রিটার্নস:\n  - পিটার মোট কতগুলি সিগারেট খেতে পারে, যার মধ্যে বাট বিনিময় করে প্রাপ্ত সিগারেটও অন্তর্ভুক্ত।\n\n  উদাহরণ:\n  - total_smoked_cigarettes(4, 3) রিটার্ন করে 5\n  - total_smoked_cigarettes(10, 3) রিটার্ন করে 14",
      "bg": "Напишете функция на Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32`, за да решите следния проблем:\nИзчислява общия брой цигари, които Петър може да изпуши, като се има предвид началното количество и курсът на обмяна на фасове за нови цигари.\n\n  Аргументи:\n  - initial_cigarettes: Началният брой цигари, които Петър има.\n  - butts_for_new: Броят фасове, необходими за замяна за една нова цигара.\n\n  Връща:\n  - Общият брой цигари, които Петър може да изпуши, включително тези, получени чрез замяна на фасове за нови.\n\n  Пример:\n  - total_smoked_cigarettes(4, 3) връща 5\n  - total_smoked_cigarettes(10, 3) връща 14",
      "zh": "编写一个 Rust 函数 `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` 来解决以下问题：\n计算彼得在给定初始数量和烟蒂兑换新香烟的转换率下可以抽的香烟总数。\n\n参数：\n- initial_cigarettes: 彼得拥有的初始香烟数量。\n- butts_for_new: 兑换一支新香烟所需的烟蒂数量。\n\n返回值：\n- 彼得可以抽的香烟总数，包括通过兑换烟蒂获得的新香烟。\n\n示例：\n- total_smoked_cigarettes(4, 3) 返回 5\n- total_smoked_cigarettes(10, 3) 返回 14",
      "fr": "Écrire une fonction Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` pour résoudre le problème suivant :\nCalcule le nombre total de cigarettes que Pierre peut fumer étant donné un montant initial et un taux de conversion de mégots de cigarettes en nouvelles cigarettes.\n\n  Arguments :\n  - initial_cigarettes : Le nombre initial de cigarettes que Pierre a.\n  - butts_for_new : Le nombre de mégots de cigarettes requis pour échanger contre une nouvelle cigarette.\n\n  Renvoie :\n  - Le nombre total de cigarettes que Pierre peut fumer, y compris celles obtenues en échangeant des mégots contre de nouvelles.\n\n  Exemple :\n  - total_smoked_cigarettes(4, 3) retourne 5\n  - total_smoked_cigarettes(10, 3) retourne 14",
      "de": "Schreiben Sie eine Rust-Funktion `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, basierend auf einer anfänglichen Menge und einer Umtauschrate von Zigarettenstummeln in neue Zigaretten.\n\n  Argumente:\n  - initial_cigarettes: Die anfängliche Anzahl der Zigaretten, die Peter hat.\n  - butts_for_new: Die Anzahl der Zigarettenstummel, die erforderlich sind, um sie gegen eine neue Zigarette einzutauschen.\n\n  Rückgabe:\n  - Die Gesamtanzahl der Zigaretten, die Peter rauchen kann, einschließlich derer, die durch den Umtausch von Stummeln in neue erhalten wurden.\n\n  Beispiel:\n  - total_smoked_cigarettes(4, 3) gibt 5 zurück\n  - total_smoked_cigarettes(10, 3) gibt 14 zurück",
      "ha": "Rubuta aikin Rust `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` don warware matsalar mai zuwa:\nLissafa jimillar adadin sigari da Peter zai iya sha la'akari da adadin farko da kuma tsarin musayar bututun sigari zuwa sabbin sigari.\n\n  Huɗɗa:\n  - initial_cigarettes: Adadin farko na sigari da Peter yake da shi.\n  - butts_for_new: Adadin bututun sigari da ake bukata don musayar sabuwar sigari guda.\n\n  Komawa:\n  - Jimillar adadin sigari da Peter zai iya sha ciki har da waɗanda aka samu ta hanyar musayar bututun don sabbin sigari.\n\n  Misali:\n  - total_smoked_cigarettes(4, 3) yana dawowa 5\n  - total_smoked_cigarettes(10, 3) yana dawowa 14",
      "hi": "Rust फ़ंक्शन `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है, दी गई प्रारंभिक मात्रा और सिगरेट के बचे हुए टुकड़ों को नई सिगरेट में बदलने की दर के आधार पर।\n\n  तर्क:\n  - initial_cigarettes: प्रारंभिक सिगरेटों की संख्या जो पीटर के पास है।\n  - butts_for_new: एक नई सिगरेट के लिए विनिमय करने के लिए आवश्यक सिगरेट के बचे हुए टुकड़ों की संख्या।\n\n  लौटाता है:\n  - कुल सिगरेटों की संख्या जो पीटर पी सकता है, जिसमें वे भी शामिल हैं जो बचे हुए टुकड़ों को नई सिगरेट में बदलकर प्राप्त होती हैं।\n\n  उदाहरण:\n  - total_smoked_cigarettes(4, 3) 5 लौटाता है\n  - total_smoked_cigarettes(10, 3) 14 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32` a következő probléma megoldására:\nKiszámítja, hogy Péter összesen hány cigarettát tud elszívni egy kezdeti mennyiség és a csikkek új cigarettára történő átváltási aránya alapján.\n\n  Argumentumok:\n  - initial_cigarettes: A kezdeti cigaretták száma, amivel Péter rendelkezik.\n  - butts_for_new: Az új cigaretta megszerzéséhez szükséges cigarettacsikkek száma.\n\n  Visszatér:\n  - Az összes cigaretta száma, amit Péter el tud szívni, beleértve azokat is, amelyeket csikkek újra váltásával szerzett.\n\n  Példa:\n  - total_smoked_cigarettes(4, 3) visszaadja 5\n  - total_smoked_cigarettes(10, 3) visszaadja 14"
    },
    "instruction_bertscore": {
      "sq": "0.9885060543710351",
      "hy": "0.9559000828026342",
      "bn": "0.9674526243940043",
      "bg": "0.9779234249302584",
      "zh": "0.9661335200335516",
      "fr": "0.9807270927585658",
      "de": "0.9834930208144766",
      "ha": "0.9715193828153126",
      "hi": "0.9534992373870654",
      "hu": "0.9818338612416923"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(total_smoked_cigarettes(4, 3), 5);\n        assert_eq!(total_smoked_cigarettes(10, 3), 14);\n        assert_eq!(total_smoked_cigarettes(1, 2), 1); // Edge case: Not enough to exchange\n        assert_eq!(total_smoked_cigarettes(100, 5), 124); // Larger numbers\n    }\n    \n\n}",
    "entry_point": "total_smoked_cigarettes",
    "signature": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "sq": "Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare dhe një normë konvertimi të bishtave të cigareve në cigare të reja.\n\n  Argumentet:\n  - initial_cigarettes: Numri fillestar i cigareve që Pjetri ka.\n  - butts_for_new: Numri i bishtave të cigareve të nevojshëm për të shkëmbyer për një cigare të re.\n\n  Kthen:\n  - Numri total i cigareve që Pjetri mund të pijë duke përfshirë ato të marra duke shkëmbyer bishtat për të reja.\n\n  Shembull:\n  - total_smoked_cigarettes(4, 3) kthen 5\n  - total_smoked_cigarettes(10, 3) kthen 14",
      "hy": "Հաշվում է ընդհանուր սիգարետների քանակը, որը կարող է ծխել Պետերը՝ հաշվի առնելով սկզբնական քանակը և սիգարետի մնացորդները նոր սիգարետների փոխանակման փոխարժեքը:\n\n  Արգումենտներ:\n  - initial_cigarettes: Սիգարետների սկզբնական քանակը, որը ունի Պետերը:\n  - butts_for_new: Սիգարետի մնացորդների քանակը, որը պահանջվում է փոխանակելու համար մեկ նոր սիգարետի:\n\n  Վերադարձնում է:\n  - Սիգարետների ընդհանուր քանակը, որը կարող է ծխել Պետերը, ներառյալ այն սիգարետները, որոնք ստացվում են մնացորդները նորերով փոխանակելով:\n\n  Օրինակ:\n  - total_smoked_cigarettes(4, 3) վերադարձնում է 5\n  - total_smoked_cigarettes(10, 3) վերադարձնում է 14",
      "bn": "পিটার কতগুলি সিগারেট খেতে পারে তা গণনা করে, একটি প্রাথমিক পরিমাণ এবং সিগারেটের বাট থেকে নতুন সিগারেটের জন্য একটি রূপান্তর হার দেওয়া হলে।\n\n  আর্গুমেন্টসমূহ:\n  - initial_cigarettes: পিটারের কাছে থাকা প্রাথমিক সিগারেটের সংখ্যা।\n  - butts_for_new: একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n\n  রিটার্নসমূহ:\n  - পিটার মোট কতগুলি সিগারেট খেতে পারে, যার মধ্যে নতুন সিগারেটের জন্য বাট বিনিময় করে প্রাপ্ত সিগারেটও অন্তর্ভুক্ত।\n\n  উদাহরণ:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началното количество и курсът на обмяна на фасове за нови цигари.\n\n  Аргументи:\n  - initial_cigarettes: Началният брой цигари, които Петър има.\n  - butts_for_new: Броят на фасовете, необходими за обмяна за една нова цигара.\n\n  Връща:\n  - Общият брой цигари, които Петър може да изпуши, включително тези, получени чрез обмяна на фасове за нови.\n\n  Пример:\n  - total_smoked_cigarettes(4, 3) връща 5\n  - total_smoked_cigarettes(10, 3) връща 14",
      "zh": "计算彼得在给定初始数量和烟头兑换新香烟的转换率下可以抽的香烟总数。\n\n  参数：\n  - initial_cigarettes: 彼得拥有的初始香烟数量。\n  - butts_for_new: 兑换一支新香烟所需的烟头数量。\n\n  返回：\n  - 彼得可以抽的香烟总数，包括通过兑换烟头获得的新香烟。\n\n  示例：\n  - total_smoked_cigarettes(4, 3) 返回 5\n  - total_smoked_cigarettes(10, 3) 返回 14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer étant donné une quantité initiale et un taux de conversion de mégots de cigarettes en nouvelles cigarettes.\n\n  Arguments:\n  - initial_cigarettes: Le nombre initial de cigarettes que Peter a.\n  - butts_for_new: Le nombre de mégots de cigarettes requis pour échanger contre une nouvelle cigarette.\n\n  Renvoie:\n  - Le nombre total de cigarettes que Peter peut fumer, y compris celles obtenues en échangeant des mégots contre de nouvelles.\n\n  Exemple:\n  - total_smoked_cigarettes(4, 3) renvoie 5\n  - total_smoked_cigarettes(10, 3) renvoie 14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Menge und eine Umwandlungsrate von Zigarettenstummeln zu neuen Zigaretten.\n\n  Argumente:\n  - initial_cigarettes: Die anfängliche Anzahl der Zigaretten, die Peter hat.\n  - butts_for_new: Die Anzahl der Zigarettenstummel, die benötigt werden, um sie gegen eine neue Zigarette einzutauschen.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der Zigaretten, die Peter rauchen kann, einschließlich derjenigen, die durch das Eintauschen von Stummeln gegen neue erhalten werden.\n\n  Beispiel:\n  - total_smoked_cigarettes(4, 3) gibt 5 zurück\n  - total_smoked_cigarettes(10, 3) gibt 14 zurück",
      "ha": "Lissafa adadin sigari da Peter zai iya sha la'akari da adadin farko da kuma yawan bututun sigari da ake bukata don musayar sabbin sigari.\n\n  Huɗa:\n  - initial_cigarettes: Adadin sigari na farko da Peter ke da shi.\n  - butts_for_new: Adadin bututun sigari da ake buƙata don musanya da sabon sigari.\n\n  Komawa:\n  - Jimillar adadin sigari da Peter zai iya sha ciki har da waɗanda aka samu ta hanyar musanya bututun da sababbi.\n\n  Misali:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "hi": "सिगरेट की कुल संख्या की गणना करता है जो पीटर धूम्रपान कर सकता है, दिए गए प्रारंभिक मात्रा और सिगरेट बट्स को नई सिगरेट में बदलने की दर के आधार पर।\n\n  तर्क:\n  - initial_cigarettes: प्रारंभिक सिगरेट की संख्या जो पीटर के पास है।\n  - butts_for_new: एक नई सिगरेट के लिए विनिमय करने के लिए आवश्यक सिगरेट बट्स की संख्या।\n\n  लौटाता है:\n  - सिगरेट की कुल संख्या जो पीटर धूम्रपान कर सकता है, जिसमें बट्स को नई सिगरेट में बदलकर प्राप्त की गई सिगरेट भी शामिल हैं।\n\n  उदाहरण:\n  - total_smoked_cigarettes(4, 3) 5 लौटाता है\n  - total_smoked_cigarettes(10, 3) 14 लौटाता है",
      "hu": "Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni adott kezdeti mennyiség és a cigarettacsikkek új cigarettára váltásának aránya alapján.\n\n  Argumentumok:\n  - initial_cigarettes: A kezdeti cigaretták száma, amivel Péter rendelkezik.\n  - butts_for_new: Az új cigarettára cserélendő cigarettacsikkek száma.\n\n  Visszatér:\n  - Az összes cigaretta száma, amit Péter el tud szívni, beleértve azokat is, amelyeket csikkek újra cserélésével szerzett.\n\n  Példa:\n  - total_smoked_cigarettes(4, 3) visszaadja 5\n  - total_smoked_cigarettes(10, 3) visszaadja 14"
    },
    "docstring_bertscore": {
      "sq": "0.9820692382432186",
      "hy": "0.9712536153654879",
      "bn": "0.9586268806734811",
      "bg": "0.9720040409450377",
      "zh": "0.955563205676399",
      "fr": "0.9795670913333221",
      "de": "0.983848171935767",
      "ha": "0.9833911234290058",
      "hi": "0.9566596453797115",
      "hu": "0.9535473059392758"
    }
  },
  {
    "task_id": "Rust/46",
    "prompt": {
      "en": "/*\n  Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "sq": "/*\n  Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në vargun e dhënë të numrave.\n  Një sekuencë e njëpasnjëshme është e përcaktuar si një sekuencë e numrave të plotë ku çdo numër ndjek atë të mëparshmin me saktësisht një.\n  Kjo funksion nuk kërkon që vargu i hyrjes të jetë i renditur.\n\n  Argumentet:\n  - numbers: Një pjesë e numrave të plotë që përfaqëson sekuencën.\n\n  Kthen:\n  - Gjatësinë e sekuencës më të gjatë të njëpasnjëshme të gjetur në varg.\n\n  Shembull:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) kthen 4 (sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) kthen 5 (sepse sekuenca është 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) kthen 4 (sepse sekuenca është 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "hy": "/*\n  Գտնում է տրված թվերի զանգվածում ամենաերկար հաջորդական հաջորդականության երկարությունը։\n  Հաջորդական հաջորդականությունը սահմանվում է որպես ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր թիվ նախորդին հաջորդում է հենց մեկով։\n  Այս ֆունկցիան չի պահանջում մուտքային զանգվածի դասավորվածություն։\n\n  Արգումենտներ:\n  - numbers: Ամբողջ թվերի կտոր, որը ներկայացնում է հաջորդականությունը։\n\n  Վերադարձնում է:\n  - Ամենաերկար հաջորդական հաջորդականության երկարությունը, որը գտնվել է զանգվածում։\n\n  Օրինակ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) վերադարձնում է 4 (քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) վերադարձնում է 5 (քանի որ հաջորդականությունը 1, 2, 3, 4, 5 է)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) վերադարձնում է 4 (քանի որ հաջորդականությունը 1, 2, 3, 4 է)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "bn": "/*\n  প্রদত্ত সংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n  একটি ধারাবাহিক ক্রমকে এমন একটি পূর্ণসংখ্যার ক্রম হিসাবে সংজ্ঞায়িত করা হয় যেখানে প্রতিটি সংখ্যা পূর্ববর্তী সংখ্যার পর ঠিক এক দ্বারা অনুসরণ করে।\n  এই ফাংশনের জন্য ইনপুট অ্যারে সাজানো থাকা প্রয়োজন হয় না।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস যা ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - অ্যারেতে পাওয়া দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 রিটার্ন করে (কারণ দীর্ঘতম ধারাবাহিক ক্রম হল 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 রিটার্ন করে (কারণ ক্রম হল 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 রিটার্ন করে (কারণ ক্রম হল 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "bg": "/*\n  Намира дължината на най-дългата последователна редица в даден масив от числа.\n  Последователна редица е дефинирана като редица от цели числа, където всяко число следва предишното с точно едно.\n  Тази функция не изисква входният масив да бъде сортиран.\n\n  Аргументи:\n  - numbers: Срез от цели числа, представляващ редицата.\n\n  Връща:\n  - Дължината на най-дългата последователна редица, намерена в масива.\n\n  Пример:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) връща 4 (защото най-дългата последователна редица е 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) връща 5 (защото редицата е 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) връща 4 (защото редицата е 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "zh": "/*\n  查找给定数字数组中最长连续序列的长度。\n  连续序列被定义为一个整数序列，其中每个数字都比前一个大一。\n  此函数不要求输入数组是排序的。\n\n  参数:\n  - numbers: 表示序列的整数切片。\n\n  返回:\n  - 数组中找到的最长连续序列的长度。\n\n  示例:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 返回 4 (因为最长的连续序列是 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 返回 5 (因为序列是 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 返回 4 (因为序列是 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "fr": "/*\n  Trouve la longueur de la plus longue séquence consécutive dans le tableau donné de nombres.\n  Une séquence consécutive est définie comme une séquence d'entiers où chaque nombre suit le précédent par exactement un.\n  Cette fonction ne nécessite pas que le tableau d'entrée soit trié.\n\n  Arguments :\n  - numbers: Une tranche d'entiers représentant la séquence.\n\n  Renvoie :\n  - La longueur de la plus longue séquence consécutive trouvée dans le tableau.\n\n  Exemple :\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) renvoie 4 (car la plus longue séquence consécutive est 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) renvoie 5 (car la séquence est 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) renvoie 4 (car la séquence est 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "de": "/*\n  Findet die Länge der längsten aufeinanderfolgenden Sequenz im gegebenen Array von Zahlen.\n  Eine aufeinanderfolgende Sequenz ist definiert als eine Sequenz von ganzen Zahlen, bei der jede Zahl der vorherigen um genau eins folgt.\n  Diese Funktion erfordert nicht, dass das Eingabearray sortiert ist.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen, das die Sequenz darstellt.\n\n  Rückgabewert:\n  - Die Länge der längsten aufeinanderfolgenden Sequenz, die im Array gefunden wurde.\n\n  Beispiel:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) gibt 4 zurück (weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) gibt 5 zurück (weil die Sequenz 1, 2, 3, 4, 5 ist)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) gibt 4 zurück (weil die Sequenz 1, 2, 3, 4 ist)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "ha": "/*\n  Nemi tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi da aka bayar.\n  Jerin lambobi masu jere ana ayyana su a matsayin jerin lambobi inda kowanne lamba ke biyo bayan wanda ya gabace shi da lamba daya kawai.\n  Wannan aikin ba ya bukatar jerin lambobin da aka bayar su kasance a jere.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobi masu dauke da jerin.\n\n  Komawa:\n  - Tsawon jerin lambobi masu jere mafi tsawo da aka samu a cikin jerin.\n\n  Misali:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (saboda jerin lambobi masu jere mafi tsawo shine 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (saboda jerin shine 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (saboda jerin shine 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "hi": "/*\n  दिए गए संख्याओं के array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n  एक लगातार अनुक्रम को ऐसे पूर्णांकों के अनुक्रम के रूप में परिभाषित किया जाता है जहां प्रत्येक संख्या पिछले वाले के ठीक एक के अंतर से होती है।\n  इस फ़ंक्शन के लिए इनपुट array को क्रमबद्ध होना आवश्यक नहीं है।\n\n  तर्क:\n  - numbers: अनुक्रम का प्रतिनिधित्व करने वाले पूर्णांकों का एक slice।\n\n  लौटाता है:\n  - array में पाए गए सबसे लंबे लगातार अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 लौटाता है (क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 लौटाता है (क्योंकि अनुक्रम 1, 2, 3, 4, 5 है)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 लौटाता है (क्योंकि अनुक्रम 1, 2, 3, 4 है)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "hu": "/*\n  Megkeresi a leghosszabb egymást követő sorozat hosszát a megadott számok tömbjében.\n  Egy egymást követő sorozat olyan egész számok sorozataként van definiálva, ahol minden szám pontosan eggyel követi az előzőt.\n  Ennek a függvénynek nem szükséges, hogy a bemeneti tömb rendezett legyen.\n\n  Argumentumok:\n  - numbers: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatér:\n  - A leghosszabb egymást követő sorozat hossza, amelyet a tömbben talált.\n\n  Példa:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) visszatér 4 (mert a leghosszabb egymást követő sorozat 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) visszatér 5 (mert a sorozat 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) visszatér 4 (mert a sorozat 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9973335857649877",
      "bn": "0.9926421347953246",
      "bg": "0.9987631286172958",
      "zh": "0.9809116203825472",
      "fr": "0.9968274755541108",
      "de": "0.9960047485158643",
      "ha": "0.9465515439192271",
      "hi": "0.9830631846699172",
      "hu": "0.998115593575122"
    },
    "canonical_solution": "{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}",
    "instruction": {
      "en": "Write a Rust function `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` to solve the following problem:\nFinds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)",
      "sq": "Shkruani një funksion në Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` për të zgjidhur problemin në vijim:\nGjen gjatësinë e sekuencës më të gjatë radhazi në vargun e dhënë të numrave.\n  Një sekuencë radhazi është e përcaktuar si një sekuencë e numrave të plotë ku secili numër ndjek atë të mëparshmin me saktësisht një.\n  Ky funksion nuk kërkon që vargu i hyrjes të jetë i renditur.\n\n  Argumentet:\n  - numbers: Një segment i numrave të plotë që përfaqëson sekuencën.\n\n  Kthen:\n  - Gjatësia e sekuencës më të gjatë radhazi të gjetur në varg.\n\n  Shembull:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) kthen 4 (sepse sekuenca më e gjatë radhazi është 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) kthen 5 (sepse sekuenca është 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) kthen 4 (sepse sekuenca është 1, 2, 3, 4)",
      "hy": "Գրեք Rust ֆունկցիա `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` լուծելու համար հետևյալ խնդիրը:\nԳտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը տրված թվերի զանգվածում:\n  Հաջորդական հաջորդականությունը սահմանվում է որպես ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր թիվ հաջորդում է նախորդին հենց մեկով:\n  Այս ֆունկցիան չի պահանջում, որ մուտքային զանգվածը լինի դասավորված:\n\n  Արգումենտներ:\n  - numbers: Թվերի հաջորդականությունը ներկայացնող ամբողջ թվերի կտոր:\n\n  Վերադարձնում է.\n  - Ամենաերկար հաջորդական հաջորդականության երկարությունը, որը գտնվել է զանգվածում:\n\n  Օրինակ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) վերադարձնում է 4 (քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) վերադարձնում է 5 (քանի որ հաջորդականությունը 1, 2, 3, 4, 5 է)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) վերադարձնում է 4 (քանի որ հաջորդականությունը 1, 2, 3, 4 է)",
      "bn": "একটি Rust ফাংশন `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n  একটি ধারাবাহিক ক্রমকে এমন একটি পূর্ণসংখ্যার ক্রম হিসাবে সংজ্ঞায়িত করা হয় যেখানে প্রতিটি সংখ্যা পূর্ববর্তী সংখ্যার ঠিক এক দ্বারা অনুসরণ করে।\n  এই ফাংশনের জন্য ইনপুট অ্যারে সাজানো প্রয়োজন হয় না।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস যা ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - অ্যারেতে পাওয়া দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 রিটার্ন করে (কারণ দীর্ঘতম ধারাবাহিক ক্রম হল 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 রিটার্ন করে (কারণ ক্রম হল 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 রিটার্ন করে (কারণ ক্রম হল 1, 2, 3, 4)",
      "bg": "Напишете функция на Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize`, за да решите следния проблем:\nНамира дължината на най-дългата последователна поредица в дадения масив от числа.\n  Последователна поредица е дефинирана като поредица от цели числа, където всяко число следва предишното с точно едно.\n  Тази функция не изисква входният масив да бъде сортиран.\n\n  Аргументи:\n  - numbers: Срез от цели числа, представляващ поредицата.\n\n  Връща:\n  - Дължината на най-дългата намерена последователна поредица в масива.\n\n  Пример:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) връща 4 (защото най-дългата последователна поредица е 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) връща 5 (защото поредицата е 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) връща 4 (защото поредицата е 1, 2, 3, 4)",
      "zh": "编写一个 Rust 函数 `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` 来解决以下问题：\n在给定的数字数组中找到最长连续序列的长度。\n  连续序列被定义为每个数字紧跟前一个数字增加一的整数序列。\n  此函数不要求输入数组是排序的。\n\n  参数：\n  - numbers: 表示序列的整数切片。\n\n  返回：\n  - 在数组中找到的最长连续序列的长度。\n\n  示例：\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 返回 4 （因为最长的连续序列是 1, 2, 3, 4）\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 返回 5 （因为序列是 1, 2, 3, 4, 5）\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 返回 4 （因为序列是 1, 2, 3, 4）",
      "fr": "Écrire une fonction Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` pour résoudre le problème suivant :\nTrouve la longueur de la plus longue séquence consécutive dans le tableau de nombres donné.\n  Une séquence consécutive est définie comme une séquence d'entiers où chaque nombre suit le précédent d'exactement un.\n  Cette fonction ne nécessite pas que le tableau d'entrée soit trié.\n\n  Arguments :\n  - numbers : Une tranche d'entiers représentant la séquence.\n\n  Renvoie :\n  - La longueur de la plus longue séquence consécutive trouvée dans le tableau.\n\n  Exemple :\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) renvoie 4 (parce que la plus longue séquence consécutive est 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) renvoie 5 (parce que la séquence est 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) renvoie 4 (parce que la séquence est 1, 2, 3, 4)",
      "de": "Schreiben Sie eine Rust-Funktion `fn longest_consecutive_sequence(numbers: &[i32]) -> usize`, um das folgende Problem zu lösen:\nFindet die Länge der längsten aufeinanderfolgenden Sequenz im gegebenen Array von Zahlen.\n  Eine aufeinanderfolgende Sequenz ist definiert als eine Sequenz von ganzen Zahlen, bei der jede Zahl der vorherigen um genau eins folgt.\n  Diese Funktion erfordert nicht, dass das Eingabearray sortiert ist.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen, das die Sequenz darstellt.\n\n  Rückgabewert:\n  - Die Länge der längsten aufeinanderfolgenden Sequenz, die im Array gefunden wurde.\n\n  Beispiel:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) gibt 4 zurück (weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) gibt 5 zurück (weil die Sequenz 1, 2, 3, 4, 5 ist)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) gibt 4 zurück (weil die Sequenz 1, 2, 3, 4 ist)",
      "ha": "Rubuta aikin Rust `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` don warware matsalar mai zuwa:\nNemo tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobin da aka bayar.\n  Ana ayyana jerin lambobi masu jere a matsayin jerin lambobi inda kowanne lamba ke biyo bayan wanda ya gabata daidai da daya.\n  Wannan aikin baya bukatar jerin lambobin da aka bayar ya zama a jere.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobi masu wakiltar jerin.\n\n  Dawowa:\n  - Tsawon jerin lambobi masu jere mafi tsawo da aka samu a cikin jerin.\n\n  Misali:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (saboda jerin lambobi masu jere mafi tsawo shine 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (saboda jerin shine 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (saboda jerin shine 1, 2, 3, 4)",
      "hi": "Rust फ़ंक्शन `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं के array में सबसे लंबी लगातार अनुक्रम की लंबाई खोजें।\n  एक लगातार अनुक्रम को उन पूर्णांकों की अनुक्रम के रूप में परिभाषित किया जाता है जहाँ प्रत्येक संख्या पिछले वाले के बाद ठीक एक से आती है।\n  इस फ़ंक्शन के लिए इनपुट array को sorted होने की आवश्यकता नहीं है।\n\n  तर्क:\n  - numbers: अनुक्रम का प्रतिनिधित्व करने वाले पूर्णांकों का एक slice।\n\n  रिटर्न करता है:\n  - array में पाए गए सबसे लंबे लगातार अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 लौटाता है (क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 लौटाता है (क्योंकि अनुक्रम 1, 2, 3, 4, 5 है)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 लौटाता है (क्योंकि अनुक्रम 1, 2, 3, 4 है)",
      "hu": "Írj egy Rust függvényt `fn longest_consecutive_sequence(numbers: &[i32]) -> usize` a következő probléma megoldására:\nMegtalálja a leghosszabb egymást követő sorozat hosszát a megadott szám tömbben.\n  Egy egymást követő sorozat olyan egész számok sorozataként van definiálva, ahol minden szám pontosan eggyel követi az előzőt.\n  Ennek a függvénynek nem szükséges, hogy a bemeneti tömb rendezett legyen.\n\n  Argumentumok:\n  - numbers: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatér:\n  - A leghosszabb egymást követő sorozat hossza, amelyet a tömbben talált.\n\n  Példa:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) visszatér 4 (mert a leghosszabb egymást követő sorozat 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) visszatér 5 (mert a sorozat 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) visszatér 4 (mert a sorozat 1, 2, 3, 4)"
    },
    "instruction_bertscore": {
      "sq": "0.9952275078348748",
      "hy": "0.9852070023724268",
      "bn": "0.9928578473891285",
      "bg": "1",
      "zh": "0.9865493464874605",
      "fr": "0.9969287770484385",
      "de": "0.9956080836449376",
      "ha": "0.9753984355265429",
      "hi": "0.982737629475401",
      "hu": "0.9981793539274342"
    },
    "level": "hard",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]), 5);\n        assert_eq!(longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[6, 6, 2, 3, 1, 4, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "longest_consecutive_sequence",
    "signature": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në vargun e dhënë të numrave.\n  Një sekuencë radhazi përkufizohet si një sekuencë e numrave të plotë ku secili numër ndjek atë të mëparshmin me saktësisht një.\n  Kjo funksion nuk kërkon që vargu hyrës të jetë i renditur.\n\n  Argumentet:\n  - numbers: Një pjesë e numrave të plotë që përfaqëson sekuencën.\n\n  Kthen:\n  - Gjatësia e sekuencës më të gjatë radhazi të gjetur në varg.\n\n  Shembull:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) kthen 4 (sepse sekuenca më e gjatë radhazi është 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) kthen 5 (sepse sekuenca është 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) kthen 4 (sepse sekuenca është 1, 2, 3, 4)",
      "hy": "Գտնում է տրված թվերի զանգվածում ամենաերկար հաջորդական հաջորդականության երկարությունը:\n  Հաջորդական հաջորդականությունը սահմանվում է որպես ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր թիվ նախորդին հաջորդում է հենց մեկով:\n  Այս ֆունկցիան չի պահանջում, որ մուտքային զանգվածը լինի տեսակավորված:\n\n  Արգումենտներ:\n  - numbers: Ամբողջ թվերի հատված, որը ներկայացնում է հաջորդականությունը:\n\n  Վերադարձնում է.\n  - Ամենաերկար հաջորդական հաջորդականության երկարությունը, որը գտնվել է զանգվածում:\n\n  Օրինակ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) վերադարձնում է 4 (քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) վերադարձնում է 5 (քանի որ հաջորդականությունը 1, 2, 3, 4, 5 է)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) վերադարձնում է 4 (քանի որ հաջորդականությունը 1, 2, 3, 4 է)",
      "bn": "প্রদত্ত সংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n  একটি ক্রমাগত সিকোয়েন্স সংজ্ঞায়িত হয় এমন একটি পূর্ণসংখ্যার সিকোয়েন্স হিসাবে যেখানে প্রতিটি সংখ্যা পূর্ববর্তী সংখ্যার পর ঠিক এক দ্বারা অনুসরণ করে।\n  এই ফাংশনটি ইনপুট অ্যারেকে সাজানো প্রয়োজন হয় না।\n\n  Arguments:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস যা সিকোয়েন্সকে উপস্থাপন করে।\n\n  Returns:\n  - অ্যারেতে পাওয়া দীর্ঘতম ক্রমাগত সিকোয়েন্সের দৈর্ঘ্য।\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (কারণ দীর্ঘতম ক্রমাগত সিকোয়েন্স হল 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (কারণ সিকোয়েন্স হল 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (কারণ সিকোয়েন্স হল 1, 2, 3, 4)",
      "bg": "Намира дължината на най-дългата последователна поредица в дадения масив от числа.\n  Последователна поредица се определя като поредица от цели числа, където всяко число следва предходното с точно едно.\n  Тази функция не изисква входният масив да бъде сортиран.\n\n  Аргументи:\n  - numbers: Срез от цели числа, представляващ поредицата.\n\n  Връща:\n  - Дължината на най-дългата намерена последователна поредица в масива.\n\n  Пример:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) връща 4 (защото най-дългата последователна поредица е 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) връща 5 (защото поредицата е 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) връща 4 (защото поредицата е 1, 2, 3, 4)",
      "zh": "找到给定数字数组中最长连续序列的长度。\n  连续序列被定义为每个数字紧跟前一个数字增加一的整数序列。\n  此函数不要求输入数组是排序的。\n\n  参数:\n  - numbers: 表示序列的整数切片。\n\n  返回:\n  - 数组中找到的最长连续序列的长度。\n\n  示例:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 返回 4 (因为最长的连续序列是 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 返回 5 (因为序列是 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 返回 4 (因为序列是 1, 2, 3, 4)",
      "fr": "Trouve la longueur de la plus longue séquence consécutive dans le tableau de nombres donné.\n  Une séquence consécutive est définie comme une séquence d'entiers où chaque nombre suit le précédent par exactement un.\n  Cette fonction ne nécessite pas que le tableau d'entrée soit trié.\n\n  Arguments:\n  - numbers: Une tranche d'entiers représentant la séquence.\n\n  Retourne:\n  - La longueur de la plus longue séquence consécutive trouvée dans le tableau.\n\n  Exemple:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) retourne 4 (parce que la plus longue séquence consécutive est 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) retourne 5 (parce que la séquence est 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) retourne 4 (parce que la séquence est 1, 2, 3, 4)",
      "de": "Findet die Länge der längsten aufeinanderfolgenden Sequenz im gegebenen Array von Zahlen.\n  Eine aufeinanderfolgende Sequenz ist definiert als eine Sequenz von ganzen Zahlen, bei der jede Zahl der vorherigen um genau eins folgt.\n  Diese Funktion erfordert nicht, dass das Eingabearray sortiert ist.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen, das die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Die Länge der längsten aufeinanderfolgenden Sequenz, die im Array gefunden wurde.\n\n  Beispiel:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) gibt 4 zurück (weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) gibt 5 zurück (weil die Sequenz 1, 2, 3, 4, 5 ist)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) gibt 4 zurück (weil die Sequenz 1, 2, 3, 4 ist)",
      "ha": "Nemi tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi da aka bayar.\n  Ana ayyana jerin lambobi masu jere a matsayin jerin lambobi inda kowanne lamba ke biyo bayan wanda ya gabace shi da lamba daya tak.\n  Wannan aikin baya bukatar a jera lambobin da aka bayar a cikin tsari.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobi masu jere da ke wakiltar jerin.\n\n  Komawa:\n  - Tsawon mafi tsawo jerin lambobi masu jere da aka samu a cikin jerin.\n\n  Misali:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (saboda mafi tsawo jerin lambobi masu jere shine 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (saboda jerin shine 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (saboda jerin shine 1, 2, 3, 4)",
      "hi": "दिए गए संख्याओं के array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n  एक अनुक्रमिक अनुक्रम को उन पूर्णांकों की अनुक्रम के रूप में परिभाषित किया जाता है जहां प्रत्येक संख्या ठीक एक के अंतर से पिछले संख्या का अनुसरण करती है।\n  इस फ़ंक्शन के लिए इनपुट सरणी को क्रमबद्ध होना आवश्यक नहीं है।\n\n  Arguments:\n  - numbers: अनुक्रम का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\n  Returns:\n  - सरणी में पाए गए सबसे लंबे अनुक्रमिक अनुक्रम की लंबाई।\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (क्योंकि सबसे लंबा अनुक्रमिक अनुक्रम 1, 2, 3, 4 है)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (क्योंकि अनुक्रम 1, 2, 3, 4, 5 है)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (क्योंकि अनुक्रम 1, 2, 3, 4 है)",
      "hu": "Megtalálja a leghosszabb egymást követő sorozat hosszát a megadott szám tömbben.\n  Egy egymást követő sorozat olyan egész számok sorozataként van definiálva, ahol minden szám pontosan eggyel követi az előzőt.\n  Ennek a függvénynek nem szükséges, hogy a bemeneti tömb rendezett legyen.\n\n  Argumentumok:\n  - numbers: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatér:\n  - A tömbben talált leghosszabb egymást követő sorozat hossza.\n\n  Példa:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) visszatér 4 (mert a leghosszabb egymást követő sorozat 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) visszatér 5 (mert a sorozat 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) visszatér 4 (mert a sorozat 1, 2, 3, 4)"
    },
    "docstring_bertscore": {
      "sq": "0.9956017274727444",
      "hy": "0.9896301036973116",
      "bn": "1",
      "bg": "1",
      "zh": "0.9834942125967628",
      "fr": "0.9950008705701139",
      "de": "0.9945035000960025",
      "ha": "0.982179478104693",
      "hi": "0.9726414458377787",
      "hu": "0.9974895106141001"
    }
  },
  {
    "task_id": "Rust/47",
    "prompt": {
      "en": "/*\n  Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "sq": "/*\n  Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me dimensione 'b' x 'c'.\n  Kthen një varg që tregon nëse katrori ('Alice') apo drejtkëndëshi ('Bob') ka sipërfaqe më të madhe.\n  \n  Argumentet:\n  - a: Një usize që përfaqëson gjatësinë e brinjës së katrorit.\n  - b: Një usize që përfaqëson gjatësinë e drejtkëndëshit.\n  - c: Një usize që përfaqëson gjerësinë e drejtkëndëshit.\n\n  Kthen:\n  - Një varg që është ose 'Alice' nëse sipërfaqja e katrorit është më e madhe, ose 'Bob' nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\n  Shembull:\n  - compare_area(5, 4, 6) kthen \"Alice\"\n  - compare_area(7, 5, 10) kthen \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "hy": "/*\n  Համեմատում է կողքի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' x 'c' չափերով ուղղանկյան մակերեսի հետ:\n  Վերադարձնում է տող, որը ցույց է տալիս՝ քառակուսին ('Alice') թե ուղղանկյունը ('Bob') ունի ավելի մեծ մակերես:\n  \n  Արգումենտներ:\n  - a: usize, որը ներկայացնում է քառակուսու կողքի երկարությունը:\n  - b: usize, որը ներկայացնում է ուղղանկյան երկարությունը:\n  - c: usize, որը ներկայացնում է ուղղանկյան լայնությունը:\n\n  Վերադարձնում է:\n  - Տող, որը կամ 'Alice' է, եթե քառակուսու մակերեսը ավելի մեծ է, կամ 'Bob', եթե ուղղանկյան մակերեսը ավելի մեծ է:\n\n  Օրինակ:\n  - compare_area(5, 4, 6) վերադարձնում է \"Alice\"\n  - compare_area(7, 5, 10) վերադարձնում է \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "bn": "/*\n  একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফলকে একটি আয়তক্ষেত্রের 'b' x 'c' মাত্রার ক্ষেত্রফলের সাথে তুলনা করে।\n  একটি স্ট্রিং প্রদান করে যা নির্দেশ করে যে বর্গক্ষেত্র ('Alice') বা আয়তক্ষেত্র ('Bob') এর ক্ষেত্রফল বড়।\n\n  আর্গুমেন্টসমূহ:\n  - a: একটি usize যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য উপস্থাপন করে।\n  - b: একটি usize যা আয়তক্ষেত্রের দৈর্ঘ্য উপস্থাপন করে।\n  - c: একটি usize যা আয়তক্ষেত্রের প্রস্থ উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি স্ট্রিং যা হয় 'Alice' যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, অথবা 'Bob' যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\n  উদাহরণ:\n  - compare_area(5, 4, 6) \"Alice\" রিটার্ন করে\n  - compare_area(7, 5, 10) \"Bob\" রিটার্ন করে\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "bg": "/*\n  Сравнява площта на квадрат със страна 'a' с площта на правоъгълник с размери 'b' x 'c'.\n  Връща низ, указващ дали квадратът ('Alice') или правоъгълникът ('Bob') има по-голяма площ.\n  \n  Аргументи:\n  - a: usize, представляващ дължината на страната на квадрата.\n  - b: usize, представляващ дължината на правоъгълника.\n  - c: usize, представляващ ширината на правоъгълника.\n\n  Връща:\n  - Низ, който е или 'Alice', ако площта на квадрата е по-голяма, или 'Bob', ако площта на правоъгълника е по-голяма.\n\n  Пример:\n  - compare_area(5, 4, 6) връща \"Alice\"\n  - compare_area(7, 5, 10) връща \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "zh": "/*\n  比较边长为 'a' 的正方形的面积与尺寸为 'b' x 'c' 的矩形的面积。\n  返回一个字符串，指示正方形（'Alice'）或矩形（'Bob'）哪个面积更大。\n  \n  参数:\n  - a: 一个 usize，表示正方形的边长。\n  - b: 一个 usize，表示矩形的长度。\n  - c: 一个 usize，表示矩形的宽度。\n\n  返回:\n  - 一个字符串，如果正方形的面积更大，则为 'Alice'，如果矩形的面积更大，则为 'Bob'。\n\n  示例:\n  - compare_area(5, 4, 6) 返回 \"Alice\"\n  - compare_area(7, 5, 10) 返回 \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "fr": "/*\n  Compare la surface d'un carré avec une longueur de côté 'a' à la surface d'un rectangle avec des dimensions 'b' x 'c'.\n  Retourne une chaîne indiquant si le carré ('Alice') ou le rectangle ('Bob') a une surface plus grande.\n  \n  Arguments:\n  - a: Un usize représentant la longueur du côté du carré.\n  - b: Un usize représentant la longueur du rectangle.\n  - c: Un usize représentant la largeur du rectangle.\n\n  Retourne:\n  - Une chaîne qui est soit 'Alice' si la surface du carré est plus grande, soit 'Bob' si la surface du rectangle est plus grande.\n\n  Exemple:\n  - compare_area(5, 4, 6) retourne \"Alice\"\n  - compare_area(7, 5, 10) retourne \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "de": "/*\n  Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Abmessungen 'b' x 'c'.\n  Gibt einen String zurück, der angibt, ob das Quadrat ('Alice') oder das Rechteck ('Bob') eine größere Fläche hat.\n  \n  Argumente:\n  - a: Eine usize, die die Seitenlänge des Quadrats darstellt.\n  - b: Eine usize, die die Länge des Rechtecks darstellt.\n  - c: Eine usize, die die Breite des Rechtecks darstellt.\n\n  Rückgabewert:\n  - Ein String, der entweder 'Alice' ist, wenn die Fläche des Quadrats größer ist, oder 'Bob', wenn die Fläche des Rechtecks größer ist.\n\n  Beispiel:\n  - compare_area(5, 4, 6) gibt \"Alice\" zurück\n  - compare_area(7, 5, 10) gibt \"Bob\" zurück\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "ha": "/*\n  Kwatanta girman fili na murabba'i mai gefen tsawo 'a' da girman fili na rectangle mai girma 'b' x 'c'.\n  Yana mayar da kirtani da ke nuna ko murabba'i ('Alice') ko rectangle ('Bob') yana da girman fili mafi girma.\n  \n  Huɗodi:\n  - a: Wani usize da ke wakiltar tsawon gefen murabba'i.\n  - b: Wani usize da ke wakiltar tsawon rectangle.\n  - c: Wani usize da ke wakiltar faɗin rectangle.\n\n  Mayarwa:\n  - Wani kirtani wanda ko dai 'Alice' idan girman murabba'i ya fi girma, ko 'Bob' idan girman rectangle ya fi girma.\n\n  Misali:\n  - compare_area(5, 4, 6) yana mayar da \"Alice\"\n  - compare_area(7, 5, 10) yana mayar da \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "hi": "/*\n  वर्ग के क्षेत्रफल की तुलना 'a' भुजा लंबाई वाले वर्ग के क्षेत्रफल से आयत के क्षेत्रफल से करता है, जिसके आयाम 'b' x 'c' हैं।\n  एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि वर्ग ('Alice') या आयत ('Bob') का क्षेत्रफल बड़ा है।\n\n  तर्क:\n  - a: वर्ग की भुजा लंबाई को दर्शाने वाला usize।\n  - b: आयत की लंबाई को दर्शाने वाला usize।\n  - c: आयत की चौड़ाई को दर्शाने वाला usize।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो या तो 'Alice' होती है यदि वर्ग का क्षेत्रफल बड़ा है, या 'Bob' होती है यदि आयत का क्षेत्रफल बड़ा है।\n\n  उदाहरण:\n  - compare_area(5, 4, 6) \"Alice\" लौटाता है\n  - compare_area(7, 5, 10) \"Bob\" लौटाता है\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "hu": "/*\n  Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' x 'c' méretű téglalap területével.\n  Visszaad egy sztringet, amely jelzi, hogy a négyzetnek ('Alice') vagy a téglalapnak ('Bob') van-e nagyobb területe.\n  \n  Argumentumok:\n  - a: Egy usize, amely a négyzet oldalhosszát jelöli.\n  - b: Egy usize, amely a téglalap hosszát jelöli.\n  - c: Egy usize, amely a téglalap szélességét jelöli.\n\n  Visszatér:\n  - Egy sztring, amely 'Alice', ha a négyzet területe nagyobb, vagy 'Bob', ha a téglalap területe nagyobb.\n\n  Példa:\n  - compare_area(5, 4, 6) visszaadja \"Alice\"\n  - compare_area(7, 5, 10) visszaadja \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9892546922771557",
      "hy": "0.981718655620692",
      "bn": "0.9896451996062703",
      "bg": "0.9677654672441343",
      "zh": "0.9619122271757982",
      "fr": "0.985755420854464",
      "de": "0.9836753635042667",
      "ha": "0.9909950916757834",
      "hi": "0.9760173677938476",
      "hu": "0.9893335485384265"
    },
    "canonical_solution": "{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}",
    "instruction": {
      "en": "Write a Rust function `fn compare_area(a: usize, b: usize, c: usize) -> String` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "sq": "Shkruani një funksion Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` për të zgjidhur problemin e mëposhtëm:\nKrahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me dimensione 'b' x 'c'.\nKthen një varg që tregon nëse katrori ('Alice') apo drejtkëndëshi ('Bob') ka një sipërfaqe më të madhe.\n\nArgumentet:\n- a: Një usize që përfaqëson gjatësinë e brinjës së katrorit.\n- b: Një usize që përfaqëson gjatësinë e drejtkëndëshit.\n- c: Një usize që përfaqëson gjerësinë e drejtkëndëshit.\n\nKthen:\n- Një varg që është ose 'Alice' nëse sipërfaqja e katrorit është më e madhe, ose 'Bob' nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\nShembull:\n- compare_area(5, 4, 6) kthen \"Alice\"\n- compare_area(7, 5, 10) kthen \"Bob\"",
      "hy": "Գրեք Rust ֆունկցիա `fn compare_area(a: usize, b: usize, c: usize) -> String` հետևյալ խնդիրը լուծելու համար:\nՀամեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' x 'c' չափերով ուղղանկյան մակերեսի հետ:\n  Վերադարձնում է տող, որը ցույց է տալիս՝ քառակուսին ('Alice') թե ուղղանկյունը ('Bob') ունի ավելի մեծ մակերես:\n  \n  Արգումենտներ:\n  - a: usize, որը ներկայացնում է քառակուսու կողմի երկարությունը:\n  - b: usize, որը ներկայացնում է ուղղանկյան երկարությունը:\n  - c: usize, որը ներկայացնում է ուղղանկյան լայնությունը:\n\n  Վերադարձնում է:\n  - Տող, որը կա՛մ 'Alice' է, եթե քառակուսու մակերեսը մեծ է, կա՛մ 'Bob', եթե ուղղանկյան մակերեսը մեծ է:\n\n  Օրինակ:\n  - compare_area(5, 4, 6) վերադարձնում է \"Alice\"\n  - compare_area(7, 5, 10) վերադարձնում է \"Bob\"",
      "bn": "Rust ফাংশন `fn compare_area(a: usize, b: usize, c: usize) -> String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফল এবং একটি আয়তক্ষেত্রের দৈর্ঘ্য 'b' এবং প্রস্থ 'c' এর ক্ষেত্রফলের তুলনা করে।\n  একটি স্ট্রিং প্রদান করে যা নির্দেশ করে যে বর্গক্ষেত্র ('Alice') নাকি আয়তক্ষেত্র ('Bob') এর ক্ষেত্রফল বড়।\n\n  আর্গুমেন্টসমূহ:\n  - a: একটি usize যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য নির্দেশ করে।\n  - b: একটি usize যা আয়তক্ষেত্রের দৈর্ঘ্য নির্দেশ করে।\n  - c: একটি usize যা আয়তক্ষেত্রের প্রস্থ নির্দেশ করে।\n\n  রিটার্ন:\n  - একটি স্ট্রিং যা হয় 'Alice' যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, অথবা 'Bob' যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\n  উদাহরণ:\n  - compare_area(5, 4, 6) \"Alice\" রিটার্ন করে\n  - compare_area(7, 5, 10) \"Bob\" রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn compare_area(a: usize, b: usize, c: usize) -> String`, за да решите следния проблем:\nСравнява площта на квадрат със страна 'a' с площта на правоъгълник с размери 'b' x 'c'.\n  Връща низ, указващ дали квадратът ('Alice') или правоъгълникът ('Bob') има по-голяма площ.\n  \n  Аргументи:\n  - a: usize, представляващ дължината на страната на квадрата.\n  - b: usize, представляващ дължината на правоъгълника.\n  - c: usize, представляващ ширината на правоъгълника.\n\n  Връща:\n  - Низ, който е или 'Alice', ако площта на квадрата е по-голяма, или 'Bob', ако площта на правоъгълника е по-голяма.\n\n  Пример:\n  - compare_area(5, 4, 6) връща \"Alice\"\n  - compare_area(7, 5, 10) връща \"Bob\"",
      "zh": "编写一个 Rust 函数 `fn compare_area(a: usize, b: usize, c: usize) -> String` 来解决以下问题：\n比较边长为 'a' 的正方形的面积与尺寸为 'b' x 'c' 的矩形的面积。\n返回一个字符串，指示正方形（'Alice'）或矩形（'Bob'）哪个面积更大。\n\n参数：\n- a: 一个 usize，表示正方形的边长。\n- b: 一个 usize，表示矩形的长度。\n- c: 一个 usize，表示矩形的宽度。\n\n返回：\n- 一个字符串，如果正方形的面积更大则为 'Alice'，如果矩形的面积更大则为 'Bob'。\n\n示例：\n- compare_area(5, 4, 6) 返回 \"Alice\"\n- compare_area(7, 5, 10) 返回 \"Bob\"",
      "fr": "Écrire une fonction Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` pour résoudre le problème suivant :\nCompare l'aire d'un carré de côté 'a' à l'aire d'un rectangle de dimensions 'b' x 'c'.\n  Renvoie une chaîne indiquant si le carré ('Alice') ou le rectangle ('Bob') a une aire plus grande.\n  \n  Arguments :\n  - a : Un usize représentant la longueur du côté du carré.\n  - b : Un usize représentant la longueur du rectangle.\n  - c : Un usize représentant la largeur du rectangle.\n\n  Renvoie :\n  - Une chaîne qui est soit 'Alice' si l'aire du carré est plus grande, soit 'Bob' si l'aire du rectangle est plus grande.\n\n  Exemple :\n  - compare_area(5, 4, 6) renvoie \"Alice\"\n  - compare_area(7, 5, 10) renvoie \"Bob\"",
      "de": "Schreiben Sie eine Rust-Funktion `fn compare_area(a: usize, b: usize, c: usize) -> String`, um das folgende Problem zu lösen:\nVergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Abmessungen 'b' x 'c'.\nGibt einen String zurück, der angibt, ob das Quadrat ('Alice') oder das Rechteck ('Bob') eine größere Fläche hat.\n\nArgumente:\n- a: Ein usize, das die Seitenlänge des Quadrats darstellt.\n- b: Ein usize, das die Länge des Rechtecks darstellt.\n- c: Ein usize, das die Breite des Rechtecks darstellt.\n\nRückgabewert:\n- Ein String, der entweder 'Alice' ist, wenn die Fläche des Quadrats größer ist, oder 'Bob', wenn die Fläche des Rechtecks größer ist.\n\nBeispiel:\n- compare_area(5, 4, 6) gibt \"Alice\" zurück\n- compare_area(7, 5, 10) gibt \"Bob\" zurück",
      "ha": "Rubuta aikin Rust `fn compare_area(a: usize, b: usize, c: usize) -> String` don warware matsalar mai zuwa:\nKwatanta yankin murabba'i tare da tsawon gefen 'a' zuwa yankin murabba'in mai girman 'b' x 'c'.\n  Mayar da kirtani wanda ke nuna ko murabba'in ('Alice') ko murabba'in murabba'i ('Bob') yana da yankin da ya fi girma.\n  \n  Huɗɗa:\n  - a: Wani usize wanda ke wakiltar tsawon gefen murabba'in.\n  - b: Wani usize wanda ke wakiltar tsawon murabba'in.\n  - c: Wani usize wanda ke wakiltar fadin murabba'in.\n\n  Mayarwa:\n  - Kirtani wanda ko dai 'Alice' idan yankin murabba'in ya fi girma, ko 'Bob' idan yankin murabba'in ya fi girma.\n\n  Misali:\n  - compare_area(5, 4, 6) yana mayar da \"Alice\"\n  - compare_area(7, 5, 10) yana mayar da \"Bob\"",
      "hi": "Rust फ़ंक्शन `fn compare_area(a: usize, b: usize, c: usize) -> String` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n  वर्ग के क्षेत्रफल की तुलना करें जिसकी भुजा की लंबाई 'a' है, एक आयत के क्षेत्रफल से जिसकी माप 'b' x 'c' है।\n  एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि वर्ग ('Alice') या आयत ('Bob') का क्षेत्रफल बड़ा है।\n\n  तर्क:\n  - a: वर्ग की भुजा की लंबाई को दर्शाने वाला usize।\n  - b: आयत की लंबाई को दर्शाने वाला usize।\n  - c: आयत की चौड़ाई को दर्शाने वाला usize।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो या तो 'Alice' है यदि वर्ग का क्षेत्रफल बड़ा है, या 'Bob' है यदि आयत का क्षेत्रफल बड़ा है।\n\n  उदाहरण:\n  - compare_area(5, 4, 6) \"Alice\" लौटाता है\n  - compare_area(7, 5, 10) \"Bob\" लौटाता है",
      "hu": "Írj egy Rust függvényt `fn compare_area(a: usize, b: usize, c: usize) -> String` a következő probléma megoldására:\nÖsszehasonlítja az 'a' oldalhosszúságú négyzet területét a 'b' x 'c' méretű téglalap területével.\n  Visszaad egy karakterláncot, amely jelzi, hogy a négyzetnek ('Alice') vagy a téglalapnak ('Bob') van-e nagyobb területe.\n  \n  Argumentumok:\n  - a: Egy usize, amely a négyzet oldalhosszát jelöli.\n  - b: Egy usize, amely a téglalap hosszát jelöli.\n  - c: Egy usize, amely a téglalap szélességét jelöli.\n\n  Visszatérési érték:\n  - Egy karakterlánc, amely 'Alice', ha a négyzet területe nagyobb, vagy 'Bob', ha a téglalap területe nagyobb.\n\n  Példa:\n  - compare_area(5, 4, 6) visszaadja \"Alice\"\n  - compare_area(7, 5, 10) visszaadja \"Bob\""
    },
    "instruction_bertscore": {
      "sq": "0.9886365545313751",
      "hy": "0.9813472168081567",
      "bn": "0.9623519948394094",
      "bg": "0.9607975134774304",
      "zh": "0.9641436408763441",
      "fr": "0.9777158561820769",
      "de": "0.984787495007681",
      "ha": "0.9744857289256875",
      "hi": "0.9579948388010281",
      "hu": "0.9925116346349847"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(compare_area(5, 4, 6), \"Alice\");\n        assert_eq!(compare_area(7, 5, 10), \"Bob\");\n        assert_eq!(compare_area(6, 3, 8), \"Alice\");\n        assert_eq!(compare_area(9, 4, 5), \"Alice\");\n    }\n    \n\n}",
    "entry_point": "compare_area",
    "signature": "fn compare_area(a: usize, b: usize, c: usize) -> String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "sq": "Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me dimensione 'b' x 'c'.\nKthen një varg që tregon nëse katrori ('Alice') apo drejtkëndëshi ('Bob') ka një sipërfaqe më të madhe.\n\nArgumentet:\n- a: Një usize që përfaqëson gjatësinë e brinjës së katrorit.\n- b: Një usize që përfaqëson gjatësinë e drejtkëndëshit.\n- c: Një usize që përfaqëson gjerësinë e drejtkëndëshit.\n\nKthen:\n- Një varg që është ose 'Alice' nëse sipërfaqja e katrorit është më e madhe, ose 'Bob' nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\nShembull:\n- compare_area(5, 4, 6) kthen \"Alice\"\n- compare_area(7, 5, 10) kthen \"Bob\"",
      "hy": "Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' x 'c' չափերով ուղղանկյան մակերեսի հետ։ Վերադարձնում է տող, որը ցույց է տալիս, թե քառակուսին ('Alice') կամ ուղղանկյունը ('Bob') ավելի մեծ մակերես ունի։\n\nՓոփոխականներ:\n- a: usize, որը ներկայացնում է քառակուսու կողմի երկարությունը։\n- b: usize, որը ներկայացնում է ուղղանկյան երկարությունը։\n- c: usize, որը ներկայացնում է ուղղանկյան լայնությունը։\n\nՎերադարձնում է:\n- Տող, որը կամ 'Alice' է, եթե քառակուսու մակերեսը ավելի մեծ է, կամ 'Bob', եթե ուղղանկյան մակերեսը ավելի մեծ է։\n\nՕրինակ:\n- compare_area(5, 4, 6) վերադարձնում է \"Alice\"\n- compare_area(7, 5, 10) վերադարձնում է \"Bob\"",
      "bn": "বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' সহ বর্গক্ষেত্রের ক্ষেত্রফল এবং 'b' x 'c' মাত্রার আয়তক্ষেত্রের ক্ষেত্রফলের তুলনা করে।  \nএকটি স্ট্রিং ফেরত দেয় যা নির্দেশ করে যে বর্গক্ষেত্র ('Alice') বা আয়তক্ষেত্র ('Bob') এর ক্ষেত্রফল বড়।\n\nআর্গুমেন্টসমূহ:\n- a: একটি usize যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য উপস্থাপন করে।\n- b: একটি usize যা আয়তক্ষেত্রের দৈর্ঘ্য উপস্থাপন করে।\n- c: একটি usize যা আয়তক্ষেত্রের প্রস্থ উপস্থাপন করে।\n\nফেরত:\n- একটি স্ট্রিং যা হয় 'Alice' যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, অথবা 'Bob' যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\nউদাহরণ:\n- compare_area(5, 4, 6) \"Alice\" ফেরত দেয়\n- compare_area(7, 5, 10) \"Bob\" ফেরত দেয়",
      "bg": "Сравнява площта на квадрат със страна 'a' с площта на правоъгълник с размери 'b' x 'c'.\n  Връща низ, указващ дали квадратът ('Алис') или правоъгълникът ('Боб') има по-голяма площ.\n  \n  Аргументи:\n  - a: usize, представляваща дължината на страната на квадрата.\n  - b: usize, представляваща дължината на правоъгълника.\n  - c: usize, представляваща ширината на правоъгълника.\n\n  Връща:\n  - Низ, който е или 'Алис', ако площта на квадрата е по-голяма, или 'Боб', ако площта на правоъгълника е по-голяма.\n\n  Пример:\n  - compare_area(5, 4, 6) връща \"Alice\"\n  - compare_area(7, 5, 10) връща \"Bob\"",
      "zh": "比较边长为 'a' 的正方形与尺寸为 'b' x 'c' 的矩形的面积。  \n返回一个字符串，指示正方形（'Alice'）或矩形（'Bob'）哪个面积更大。\n\n参数:\n- a: 一个 usize，表示正方形的边长。\n- b: 一个 usize，表示矩形的长度。\n- c: 一个 usize，表示矩形的宽度。\n\n返回:\n- 一个字符串，如果正方形的面积更大则为 'Alice'，如果矩形的面积更大则为 'Bob'。\n\n示例:\n- compare_area(5, 4, 6) 返回 \"Alice\"\n- compare_area(7, 5, 10) 返回 \"Bob\"",
      "fr": "Compare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec des dimensions 'b' x 'c'.  \nRenvoie une chaîne indiquant si le carré ('Alice') ou le rectangle ('Bob') a une aire plus grande.\n\nArguments:\n- a: Un usize représentant la longueur du côté du carré.\n- b: Un usize représentant la longueur du rectangle.\n- c: Un usize représentant la largeur du rectangle.\n\nReturns:\n- Une chaîne qui est soit 'Alice' si l'aire du carré est plus grande, soit 'Bob' si l'aire du rectangle est plus grande.\n\nExample:\n- compare_area(5, 4, 6) renvoie \"Alice\"\n- compare_area(7, 5, 10) renvoie \"Bob\"",
      "de": "Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Abmessungen 'b' x 'c'.\nGibt einen String zurück, der angibt, ob das Quadrat ('Alice') oder das Rechteck ('Bob') eine größere Fläche hat.\n\nArgumente:\n- a: Eine usize, die die Seitenlänge des Quadrats darstellt.\n- b: Eine usize, die die Länge des Rechtecks darstellt.\n- c: Eine usize, die die Breite des Rechtecks darstellt.\n\nRückgabewert:\n- Ein String, der entweder 'Alice' ist, wenn die Fläche des Quadrats größer ist, oder 'Bob', wenn die Fläche des Rechtecks größer ist.\n\nBeispiel:\n- compare_area(5, 4, 6) gibt \"Alice\" zurück\n- compare_area(7, 5, 10) gibt \"Bob\" zurück",
      "ha": "Kwatanta girman fili na murabba'i mai gefen tsawo 'a' da girman fili na rectangle mai girma 'b' x 'c'.\n  Yana mayar da wata ƙirtani da ke nuna ko murabba'i ('Alice') ko rectangle ('Bob') yana da babbar yanki.\n\n  Arguments:\n  - a: Wani usize da ke wakiltar tsawon gefen murabba'i.\n  - b: Wani usize da ke wakiltar tsawon rectangle.\n  - c: Wani usize da ke wakiltar fadin rectangle.\n\n  Returns:\n  - Wata ƙirtani wadda ko dai 'Alice' idan yankin murabba'i ya fi girma, ko 'Bob' idan yankin rectangle ya fi girma.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "hi": "वर्ग के भुजा की लंबाई 'a' के क्षेत्रफल की तुलना आयत के आयाम 'b' x 'c' के क्षेत्रफल से करता है।\n  एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि वर्ग ('Alice') या आयत ('Bob') का क्षेत्रफल बड़ा है। \n  \n  Arguments:\n  - a: वर्ग की भुजा की लंबाई को दर्शाने वाला एक usize।\n  - b: आयत की लंबाई को दर्शाने वाला एक usize।\n  - c: यत की चौड़ाई को दर्शाने वाला एक usize।\n\n  Returns:\n  - एक स्ट्रिंग जो या तो 'Alice' है यदि वर्ग का क्षेत्रफल बड़ा है, या 'Bob' है यदि आयत का क्षेत्रफल बड़ा है।\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "hu": "Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' x 'c' méretű téglalap területével. \n  Visszaad egy sztringet, amely jelzi, hogy a négyzetnek ('Alice') vagy a téglalapnak ('Bob') van-e nagyobb területe.\n  \n  Argumentumok:\n  - a: Egy usize, amely a négyzet oldalhosszúságát jelenti.\n  - b: Egy usize, amely a téglalap hosszát jelenti.\n  - c: Egy usize, amely a téglalap szélességét jelenti.\n\n  Visszatér:\n  - Egy sztring, amely 'Alice', ha a négyzet területe nagyobb, vagy 'Bob', ha a téglalap területe nagyobb.\n\n  Példa:\n  - compare_area(5, 4, 6) visszaadja \"Alice\"\n  - compare_area(7, 5, 10) visszaadja \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9892397949985781",
      "hy": "0.9750454693394439",
      "bn": "0.97346317972412",
      "bg": "0.9638723117758504",
      "zh": "0.9397250149838201",
      "fr": "0.9827600747084579",
      "de": "0.9836588771826408",
      "ha": "0.9834630276269404",
      "hi": "0.999999801369619",
      "hu": "0.9946095687194753"
    }
  },
  {
    "task_id": "Rust/48",
    "prompt": {
      "en": "/*\n  Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "sq": "/*\n  Gjen M numra të plotë pozitivë, shuma e të cilëve është e barabartë me N dhe produkti i të cilëve është maksimal, duke kthyer sekuencën leksikografikisht më të vogël të këtyre numrave.\n\n  Argumentet:\n  - n: Shuma që M numrat duhet të jenë të barabartë me.\n  - m: Numri i numrave për të gjetur.\n\n  Kthen:\n  - Një vektor me M numra të plotë, shuma e të cilëve është N dhe produkti i të cilëve është maksimal.\n\n  Shembull:\n  - max_product_partition(6, 3) kthen vec![2, 2, 2]\n  - max_product_partition(8, 3) kthen vec![2, 3, 3]\n  - max_product_partition(10, 2) kthen vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "hy": "/*\n  Գտնում է M դրական ամբողջ թվեր, որոնց գումարը հավասար է N-ի և որոնց արտադրյալը առավելագույն է, վերադարձնելով այս թվերի լեքսիկոգրաֆիկորեն փոքրագույն հաջորդականությունը:\n\n  Արգումենտներ:\n  - n: Գումարը, որին պետք է հավասարվեն M թվերը:\n  - m: Գտնվող թվերի քանակը:\n\n  Վերադարձնում է:\n  - M ամբողջ թվերի վեկտոր, որոնց գումարը N է և որոնց արտադրյալը առավելագույն է:\n\n  Օրինակ:\n  - max_product_partition(6, 3) վերադարձնում է vec![2, 2, 2]\n  - max_product_partition(8, 3) վերադարձնում է vec![2, 3, 3]\n  - max_product_partition(10, 2) վերադարձնում է vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "bn": "/*\n  এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক, এবং এই পূর্ণসংখ্যাগুলির লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমটি ফেরত দেয়।\n\n  আর্গুমেন্টসমূহ:\n  - n: যোগফল যা M পূর্ণসংখ্যার সমান হতে হবে।\n  - m: পূর্ণসংখ্যাগুলি খুঁজে বের করার সংখ্যা।\n\n  রিটার্ন:\n  - M পূর্ণসংখ্যার একটি ভেক্টর যার যোগফল N এবং যার গুণফল সর্বাধিক।\n\n  উদাহরণ:\n  - max_product_partition(6, 3) vec![2, 2, 2] ফেরত দেয়\n  - max_product_partition(8, 3) vec![2, 3, 3] ফেরত দেয়\n  - max_product_partition(10, 2) vec![5, 5] ফেরত দেয়\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "bg": "/*\n  Намира M положителни цели числа, чиято сума е равна на N и чийто произведение е максимално, връщайки лексикографски най-малката последователност от тези числа.\n\n  Аргументи:\n  - n: Сумата, на която M числата трябва да са равни.\n  - m: Броят на числата, които трябва да се намерят.\n\n  Връща:\n  - Вектор от M числа, чиято сума е N и чието произведение е максимално.\n\n  Пример:\n  - max_product_partition(6, 3) връща vec![2, 2, 2]\n  - max_product_partition(8, 3) връща vec![2, 3, 3]\n  - max_product_partition(10, 2) връща vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "zh": "/*\n  找到 M 个正整数，其和等于 N 且乘积最大，返回这些整数的字典序最小的序列。\n\n  参数:\n  - n: M 个整数的和必须等于的值。\n  - m: 要找到的整数个数。\n\n  返回:\n  - 一个包含 M 个整数的向量，其和为 N 且乘积最大。\n\n  示例:\n  - max_product_partition(6, 3) 返回 vec![2, 2, 2]\n  - max_product_partition(8, 3) 返回 vec![2, 3, 3]\n  - max_product_partition(10, 2) 返回 vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "fr": "/*\n  Trouve M entiers positifs dont la somme est égale à N et dont le produit est maximisé, en retournant la séquence lexicographiquement la plus petite de ces entiers.\n\n  Arguments:\n  - n: La somme que les M entiers doivent atteindre.\n  - m: Le nombre d'entiers à trouver.\n\n  Retourne:\n  - Un vecteur de M entiers dont la somme est N et dont le produit est maximisé.\n\n  Exemple:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "de": "/*\n  Findet M positive ganze Zahlen, deren Summe N ergibt und deren Produkt maximiert wird, und gibt die lexikografisch kleinste Sequenz dieser Zahlen zurück.\n\n  Argumente:\n  - n: Die Summe, die die M Zahlen ergeben müssen.\n  - m: Die Anzahl der zu findenden Zahlen.\n\n  Rückgabe:\n  - Ein Vektor von M ganzen Zahlen, deren Summe N ergibt und deren Produkt maximiert wird.\n\n  Beispiel:\n  - max_product_partition(6, 3) gibt vec![2, 2, 2] zurück\n  - max_product_partition(8, 3) gibt vec![2, 3, 3] zurück\n  - max_product_partition(10, 2) gibt vec![5, 5] zurück\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "ha": "/*\n  Nemo lambobi M masu kyau waɗanda jimlarsu ta yi daidai da N kuma waɗanda samfurinsu ya fi girma, suna mayar da jerin lambobi mafi ƙarancin lexicographically.\n\n  Huɗɗa:\n  - n: Jimlar da lambobin M dole ne su yi daidai da.\n  - m: Yawan lambobin da za a nema.\n\n  Mayarwa:\n  - Wani vector na lambobi M waɗanda jimlarsu ita ce N kuma samfurinsu ya fi girma.\n\n  Misali:\n  - max_product_partition(6, 3) yana mayar da vec![2, 2, 2]\n  - max_product_partition(8, 3) yana mayar da vec![2, 3, 3]\n  - max_product_partition(10, 2) yana mayar da vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "hi": "/*\n  ऐसे M धनात्मक पूर्णांक खोजता है जिनका योग N के बराबर होता है और जिनका गुणनफल अधिकतम होता है, इन पूर्णांकों के क्रमविन्यास में सबसे छोटे अनुक्रम को लौटाता है।\n\n  तर्क:\n  - n: वह योग जिसके बराबर M पूर्णांकों का योग होना चाहिए।\n  - m: खोजने के लिए पूर्णांकों की संख्या।\n\n  लौटाता है:\n  - M पूर्णांकों का एक वेक्टर जिनका योग N है और जिनका गुणनफल अधिकतम है।\n\n  उदाहरण:\n  - max_product_partition(6, 3) vec![2, 2, 2] लौटाता है\n  - max_product_partition(8, 3) vec![2, 3, 3] लौटाता है\n  - max_product_partition(10, 2) vec![5, 5] लौटाता है\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "hu": "/*\n  Megkeresi azt az M pozitív egész számot, amelyek összege N és szorzatuk maximális, visszaadva ezeknek az egész számoknak a lexikografikusan legkisebb sorozatát.\n\n  Argumentumok:\n  - n: Az összeg, amelynek az M egész számnak meg kell egyeznie.\n  - m: Az egész számok száma, amelyeket meg kell találni.\n\n  Visszatér:\n  - Egy vektor M egész számmal, amelyek összege N és szorzatuk maximális.\n\n  Példa:\n  - max_product_partition(6, 3) visszaadja vec![2, 2, 2]\n  - max_product_partition(8, 3) visszaadja vec![2, 3, 3]\n  - max_product_partition(10, 2) visszaadja vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "sq": "0.9738129678251224",
      "hy": "0.9762088474811652",
      "bn": "0.9761947447241117",
      "bg": "0.9672297611064831",
      "zh": "0.9752429079381926",
      "fr": "0.9862267707486598",
      "de": "0.9859391539569213",
      "ha": "0.9234683100784007",
      "hi": "0.9613224935745055",
      "hu": "0.9666324795507112"
    },
    "canonical_solution": "{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}",
    "instruction": {
      "en": "Write a Rust function `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` to solve the following problem:\nFinds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]",
      "sq": "Shkruani një funksion Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` për të zgjidhur problemin e mëposhtëm:\nGjen M numra të plotë pozitivë, shuma e të cilëve është e barabartë me N dhe produkti i të cilëve është maksimal, duke kthyer sekuencën leksikografikisht më të vogël të këtyre numrave.\n\n  Argumentet:\n  - n: Shuma që M numrat duhet të jenë të barabartë me.\n  - m: Numri i numrave që duhet të gjenden.\n\n  Kthen:\n  - Një vektor i M numrave të plotë, shuma e të cilëve është N dhe produkti i të cilëve është maksimal.\n\n  Shembull:\n  - max_product_partition(6, 3) kthen vec![2, 2, 2]\n  - max_product_partition(8, 3) kthen vec![2, 3, 3]\n  - max_product_partition(10, 2) kthen vec![5, 5]",
      "hy": "Գրեք Rust ֆունկցիա `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է M դրական ամբողջ թվեր, որոնց գումարը հավասար է N-ին և որոնց արտադրյալը առավելագույն է, վերադարձնելով այս թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n\n  Արգումենտներ:\n  - n: Գումարը, որին M թվերը պետք է հավասարվեն:\n  - m: Գտնվելիք թվերի քանակը:\n\n  Վերադարձնում է:\n  - M թվերի վեկտոր, որոնց գումարը N է և որոնց արտադրյալը առավելագույն է:\n\n  Օրինակ:\n  - max_product_partition(6, 3) վերադարձնում է vec![2, 2, 2]\n  - max_product_partition(8, 3) վերադարձնում է vec![2, 3, 3]\n  - max_product_partition(10, 2) վերադարձնում է vec![5, 5]",
      "bn": "Rust ফাংশন `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএমটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল এন এর সমান এবং যাদের গুণফল সর্বাধিক, এই পূর্ণসংখ্যাগুলির লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রম ফেরত দেয়।\n\n  আর্গুমেন্টসমূহ:\n  - n: এমটি পূর্ণসংখ্যার যোগফল যা এন এর সমান হতে হবে।\n  - m: খুঁজে বের করার জন্য পূর্ণসংখ্যার সংখ্যা।\n\n  রিটার্নস:\n  - এমটি পূর্ণসংখ্যার একটি ভেক্টর যার যোগফল এন এবং যার গুণফল সর্বাধিক।\n\n  উদাহরণ:\n  - max_product_partition(6, 3) vec![2, 2, 2] ফেরত দেয়\n  - max_product_partition(8, 3) vec![2, 3, 3] ফেরত দেয়\n  - max_product_partition(10, 2) vec![5, 5] ফেরত দেয়",
      "bg": "Напишете функция на Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` за решаване на следния проблем:\nНамира M положителни цели числа, чиято сума е равна на N и чийто произведение е максимално, връщайки лексикографски най-малката последователност от тези числа.\n\n  Аргументи:\n  - n: Сумата, на която M числата трябва да са равни.\n  - m: Броят на числата, които трябва да се намерят.\n\n  Връща:\n  - Вектор от M числа, чиято сума е N и чието произведение е максимално.\n\n  Пример:\n  - max_product_partition(6, 3) връща vec![2, 2, 2]\n  - max_product_partition(8, 3) връща vec![2, 3, 3]\n  - max_product_partition(10, 2) връща vec![5, 5]",
      "zh": "编写一个 Rust 函数 `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` 来解决以下问题：\n找到 M 个正整数，其和等于 N，并且其乘积最大，返回这些整数的字典序最小的序列。\n\n参数：\n- n: M 个整数的和必须等于的值。\n- m: 要找到的整数个数。\n\n返回值：\n- 一个包含 M 个整数的向量，其和为 N，且乘积最大。\n\n示例：\n- max_product_partition(6, 3) 返回 vec![2, 2, 2]\n- max_product_partition(8, 3) 返回 vec![2, 3, 3]\n- max_product_partition(10, 2) 返回 vec![5, 5]",
      "fr": "Écrire une fonction Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` pour résoudre le problème suivant :\nTrouver M entiers positifs dont la somme est égale à N et dont le produit est maximisé, en retournant la séquence lexicographiquement la plus petite de ces entiers.\n\n  Arguments :\n  - n : La somme que les M entiers doivent atteindre.\n  - m : Le nombre d'entiers à trouver.\n\n  Renvoie :\n  - Un vecteur de M entiers dont la somme est N et dont le produit est maximisé.\n\n  Exemple :\n  - max_product_partition(6, 3) renvoie vec![2, 2, 2]\n  - max_product_partition(8, 3) renvoie vec![2, 3, 3]\n  - max_product_partition(10, 2) renvoie vec![5, 5]",
      "de": "Schreiben Sie eine Rust-Funktion `fn max_product_partition(n: i32, m: i32) -> Vec<i32>`, um das folgende Problem zu lösen:\nFindet M positive ganze Zahlen, deren Summe N entspricht und deren Produkt maximiert wird, und gibt die lexikografisch kleinste Sequenz dieser Zahlen zurück.\n\n  Argumente:\n  - n: Die Summe, die die M Zahlen ergeben müssen.\n  - m: Die Anzahl der zu findenden Zahlen.\n\n  Rückgabewert:\n  - Ein Vektor von M Zahlen, deren Summe N ist und deren Produkt maximiert wird.\n\n  Beispiel:\n  - max_product_partition(6, 3) gibt vec![2, 2, 2] zurück\n  - max_product_partition(8, 3) gibt vec![2, 3, 3] zurück\n  - max_product_partition(10, 2) gibt vec![5, 5] zurück",
      "ha": "Rubuta aikin Rust `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` don warware matsalar mai zuwa:\nNemi lambobi M masu kyau da jimlarsu ta yi daidai da N kuma samfurinsu ya fi girma, ta hanyar dawo da jerin lambobi mafi ƙarancin lexicographically daga cikin waɗannan lambobin.\n\n  Huɗɗa:\n  - n: Jimlar da lambobi M dole ne su yi daidai da ita.\n  - m: Yawan lambobin da za a nema.\n\n  Dawowa:\n  - Wata vector na lambobi M waɗanda jimlarsu ta yi daidai da N kuma samfurinsu ya fi girma.\n\n  Misali:\n  - max_product_partition(6, 3) yana dawowa vec![2, 2, 2]\n  - max_product_partition(8, 3) yana dawowa vec![2, 3, 3]\n  - max_product_partition(10, 2) yana dawowa vec![5, 5]",
      "hi": "Rust फ़ंक्शन `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे M धनात्मक पूर्णांक खोजें जिनका योग N के बराबर हो और जिनका गुणनफल अधिकतम हो, और इन पूर्णांकों का शब्दकोशानुक्रम में सबसे छोटा अनुक्रम लौटाएं।\n\n  तर्क:\n  - n: वह योग जिसे M पूर्णांकों के बराबर होना चाहिए।\n  - m: खोजने के लिए पूर्णांकों की संख्या।\n\n  रिटर्न करता है:\n  - M पूर्णांकों का एक वेक्टर जिनका योग N है और जिनका गुणनफल अधिकतम है।\n\n  उदाहरण:\n  - max_product_partition(6, 3) vec![2, 2, 2] लौटाता है\n  - max_product_partition(8, 3) vec![2, 3, 3] लौटाता है\n  - max_product_partition(10, 2) vec![5, 5] लौटाता है",
      "hu": "Készíts egy Rust függvényt `fn max_product_partition(n: i32, m: i32) -> Vec<i32>` a következő probléma megoldására:\nTalálj M pozitív egész számot, amelyek összege N és amelyek szorzata maximális, visszaadva ezeknek a számoknak a lexikografikusan legkisebb sorozatát.\n\n  Argumentumok:\n  - n: Az összeg, amelyet az M egész számnak ki kell adnia.\n  - m: Az egész számok száma, amelyeket meg kell találni.\n\n  Visszatér:\n  - Egy M egész számot tartalmazó vektor, amelyek összege N és amelyek szorzata maximális.\n\n  Példa:\n  - max_product_partition(6, 3) visszaadja vec![2, 2, 2]\n  - max_product_partition(8, 3) visszaadja vec![2, 3, 3]\n  - max_product_partition(10, 2) visszaadja vec![5, 5]"
    },
    "instruction_bertscore": {
      "sq": "0.9681851732392609",
      "hy": "0.9731717889551418",
      "bn": "0.9604387870092813",
      "bg": "0.9697787847863039",
      "zh": "0.9724986305938146",
      "fr": "0.9904488581279374",
      "de": "0.9802920922240994",
      "ha": "0.9570622691620693",
      "hi": "0.949670438162237",
      "hu": "0.9686291121408739"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_product_partition(6, 3), vec![2, 2, 2]);\n        assert_eq!(max_product_partition(8, 3), vec![2, 3, 3]);\n        assert_eq!(max_product_partition(10, 2), vec![5, 5]);\n        assert_eq!(max_product_partition(7, 3), vec![2, 2, 3]);\n    }\n    \n\n}",
    "entry_point": "max_product_partition",
    "signature": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>",
    "docstring": {
      "en": "Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]",
      "sq": "Gjen M numra të plotë pozitivë, shuma e të cilëve është e barabartë me N dhe produkti i të cilëve është maksimal, duke kthyer vargun leksikografikisht më të vogël të këtyre numrave.\n\n  Argumentet:\n  - n: Shuma që M numrat duhet të jenë të barabartë.\n  - m: Numri i numrave për të gjetur.\n\n  Kthen:\n  - Një vektor prej M numrash, shuma e të cilëve është N dhe produkti i të cilëve është maksimal.\n\n  Shembull:\n  - max_product_partition(6, 3) kthen vec![2, 2, 2]\n  - max_product_partition(8, 3) kthen vec![2, 3, 3]\n  - max_product_partition(10, 2) kthen vec![5, 5]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնց գումարը հավասար է N-ի և որոնց արտադրյալը առավելագույն է, վերադարձնելով այս թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n\n  Արգումենտներ:\n  - n: Գումարը, որին պետք է հավասարվեն M ամբողջ թվերը:\n  - m: Գտնվող ամբողջ թվերի քանակը:\n\n  Վերադարձնում է:\n  - M ամբողջ թվերի վեկտոր, որոնց գումարը N է և որոնց արտադրյալը առավելագույն է:\n\n  Օրինակ:\n  - max_product_partition(6, 3) վերադարձնում է vec![2, 2, 2]\n  - max_product_partition(8, 3) վերադարձնում է vec![2, 3, 3]\n  - max_product_partition(10, 2) վերադարձնում է vec![5, 5]",
      "bn": "এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক, এবং এই পূর্ণসংখ্যাগুলির লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমটি ফেরত দেয়।\n\n  আর্গুমেন্টস:\n  - n: সংখ্যাটি যার সমান M টি পূর্ণসংখ্যার যোগফল হতে হবে।\n  - m: পূর্ণসংখ্যাগুলি খুঁজে বের করার সংখ্যা।\n\n  রিটার্নস:\n  - M পূর্ণসংখ্যার একটি ভেক্টর যার যোগফল N এবং যার গুণফল সর্বাধিক।\n\n  উদাহরণ:\n  - max_product_partition(6, 3) রিটার্ন করে vec![2, 2, 2]\n  - max_product_partition(8, 3) রিটার্ন করে vec![2, 3, 3]\n  - max_product_partition(10, 2) রিটার্ন করে vec![5, 5]",
      "bg": "Намира M положителни цели числа, чиято сума е равна на N и чийто произведение е максимизирано, връщайки лексикографски най-малката последователност от тези числа.\n\nАргументи:\n- n: Сумата, на която M числата трябва да са равни.\n- m: Броят на числата, които трябва да се намерят.\n\nВръща:\n- Вектор от M цели числа, чиято сума е N и чието произведение е максимизирано.\n\nПример:\n- max_product_partition(6, 3) връща vec![2, 2, 2]\n- max_product_partition(8, 3) връща vec![2, 3, 3]\n- max_product_partition(10, 2) връща vec![5, 5]",
      "zh": "找到 M 个正整数，其和等于 N 且乘积最大，返回这些整数的字典序最小序列。\n\n  参数:\n  - n: M 个整数的和必须等于的值。\n  - m: 要找到的整数个数。\n\n  返回:\n  - 一个包含 M 个整数的向量，其和为 N 且乘积最大。\n\n  示例:\n  - max_product_partition(6, 3) 返回 vec![2, 2, 2]\n  - max_product_partition(8, 3) 返回 vec![2, 3, 3]\n  - max_product_partition(10, 2) 返回 vec![5, 5]",
      "fr": "Trouve M entiers positifs dont la somme est égale à N et dont le produit est maximisé, en renvoyant la séquence lexicographiquement la plus petite de ces entiers.\n\n  Arguments:\n  - n: La somme que les M entiers doivent égaler.\n  - m: Le nombre d'entiers à trouver.\n\n  Renvoie:\n  - Un vecteur de M entiers dont la somme est N et dont le produit est maximisé.\n\n  Exemple:\n  - max_product_partition(6, 3) renvoie vec![2, 2, 2]\n  - max_product_partition(8, 3) renvoie vec![2, 3, 3]\n  - max_product_partition(10, 2) renvoie vec![5, 5]",
      "de": "Findet M positive ganze Zahlen, deren Summe N ergibt und deren Produkt maximiert ist, und gibt die lexikografisch kleinste Sequenz dieser Zahlen zurück.\n\n  Argumente:\n  - n: Die Summe, die die M Zahlen ergeben müssen.\n  - m: Die Anzahl der zu findenden Zahlen.\n\n  Rückgabe:\n  - Ein Vektor von M Zahlen, deren Summe N ergibt und deren Produkt maximiert ist.\n\n  Beispiel:\n  - max_product_partition(6, 3) gibt vec![2, 2, 2] zurück\n  - max_product_partition(8, 3) gibt vec![2, 3, 3] zurück\n  - max_product_partition(10, 2) gibt vec![5, 5] zurück",
      "ha": "Nemo lambobi M masu kyau waɗanda jimlarsu ta yi daidai da N kuma samfurin su ya kai matsakaicin daraja, ta dawo da jerin lambobi mafi ƙarancin tsari a cikin waɗannan lambobin.\n\n  Huɗɗa:\n  - n: Jimlar da lambobi M dole ne su yi daidai da ita.\n  - m: Yawan lambobin da za a samu.\n\n  Komawa:\n  - Wani vector na lambobi M waɗanda jimlarsu ta yi daidai da N kuma samfurin su ya kai matsakaicin daraja.\n\n  Misali:\n  - max_product_partition(6, 3) ya dawo da vec![2, 2, 2]\n  - max_product_partition(8, 3) ya dawo da vec![2, 3, 3]\n  - max_product_partition(10, 2) ya dawo da vec![5, 5]",
      "hi": "M धनात्मक पूर्णांकों को खोजता है जिनका योग N के बराबर होता है और जिनका गुणनफल अधिकतम होता है, इन पूर्णांकों के क्रमानुसार सबसे छोटे अनुक्रम को लौटाता है।\n\nArguments:\n- n: वह योग जिसके बराबर M पूर्णांकों को होना चाहिए।\n- m: खोजने के लिए पूर्णांकों की संख्या।\n\nReturns:\n- M पूर्णांकों का एक वेक्टर जिसका योग N है और जिसका गुणनफल अधिकतम है।\n\nExample:\n- max_product_partition(6, 3) vec![2, 2, 2] लौटाता है\n- max_product_partition(8, 3) vec![2, 3, 3] लौटाता है\n- max_product_partition(10, 2) vec![5, 5] लौटाता है",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N és amelyek szorzata maximalizált, visszaadva ezeknek az egész számoknak a lexikografikusan legkisebb sorozatát.\n\n  Argumentumok:\n  - n: Az összeg, amelyre az M egész számnak egyenlőnek kell lennie.\n  - m: A megtalálandó egész számok száma.\n\n  Visszatér:\n  - Egy M egész számot tartalmazó vektor, amelynek összege N és amelynek szorzata maximalizált.\n\n  Példa:\n  - max_product_partition(6, 3) visszaadja: vec![2, 2, 2]\n  - max_product_partition(8, 3) visszaadja: vec![2, 3, 3]\n  - max_product_partition(10, 2) visszaadja: vec![5, 5]"
    },
    "docstring_bertscore": {
      "sq": "0.965088724229308",
      "hy": "0.9698097711257453",
      "bn": "0.9822807795990207",
      "bg": "0.9756713536700848",
      "zh": "0.9745042015511238",
      "fr": "0.9838434048066222",
      "de": "0.9730804189798657",
      "ha": "0.921181478501546",
      "hi": "0.9435812252012314",
      "hu": "0.9685319818845478"
    }
  },
  {
    "task_id": "Rust/49",
    "prompt": {
      "en": "/*\n  Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "sq": "/*\n  Llogarit numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Argumentet:\n  - title: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla angleze, shifra, hapësira dhe karaktere të rreshtave të rinj.\n\n  Kthen:\n  - Numri i karaktereve në titull, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Shembuj:\n  - count_title_chars(\"234\") kthen 3\n  - count_title_chars(\"Ca 45\") kthen 4\n  - count_title_chars(\"Hello\\nWorld\") kthen 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "hy": "/*\n  Հաշվում է տրված վերնագրի տողում գտնվող սիմվոլների քանակը՝ բացի բացատներից և նոր տողի սիմվոլներից։\n\n  Փոփոխականներ:\n  - title: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, թվեր, բացատներ և նոր տողի սիմվոլներ։\n\n  Վերադարձնում է:\n  - Սիմվոլների քանակը վերնագրում՝ բացի բացատներից և նոր տողի սիմվոլներից։\n\n  Օրինակներ:\n  - count_title_chars(\"234\") վերադարձնում է 3\n  - count_title_chars(\"Ca 45\") վերադարձնում է 4\n  - count_title_chars(\"Hello\\nWorld\") վերադարձնում է 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize",
      "bn": "/*\n  প্রদত্ত শিরোনাম স্ট্রিং-এ অক্ষরের সংখ্যা গণনা করে, যেখানে ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দেওয়া হয়।\n\n  আর্গুমেন্টসমূহ:\n  - title: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা, ফাঁকা স্থান এবং নতুন লাইন অক্ষর ধারণ করতে পারে।\n\n  রিটার্নস:\n  - শিরোনামে অক্ষরের সংখ্যা, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n  উদাহরণসমূহ:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "bg": "/*\n  Изчислява броя на символите в даден низ заглавие, изключвайки интервалите и символите за нов ред.\n\n  Аргументи:\n  - title: Низ, който може да съдържа главни и малки английски букви, цифри, интервали и символи за нов ред.\n\n  Връща:\n  - Броят на символите в заглавието, изключвайки интервалите и символите за нов ред.\n\n  Примери:\n  - count_title_chars(\"234\") връща 3\n  - count_title_chars(\"Ca 45\") връща 4\n  - count_title_chars(\"Hello\\nWorld\") връща 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "zh": "/*\n  计算给定标题字符串中的字符数，不包括空格和换行符。\n\n  参数:\n  - title: 一个字符串，可能包含大写和小写的英文字母、数字、空格和换行符。\n\n  返回:\n  - 标题中字符的数量，不包括空格和换行符。\n\n  示例:\n  - count_title_chars(\"234\") 返回 3\n  - count_title_chars(\"Ca 45\") 返回 4\n  - count_title_chars(\"Hello\\nWorld\") 返回 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "fr": "/*\n  Calcule le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Arguments:\n  - title: Une chaîne qui peut contenir des lettres majuscules et minuscules anglaises, des chiffres, des espaces et des caractères de nouvelle ligne.\n\n  Retourne:\n  - Le nombre de caractères dans le titre, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Exemples:\n  - count_title_chars(\"234\") retourne 3\n  - count_title_chars(\"Ca 45\") retourne 4\n  - count_title_chars(\"Hello\\nWorld\") retourne 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "de": "/*\n  Berechnet die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n\n  Argumente:\n  - title: Ein String, der Groß- und Kleinbuchstaben, Ziffern, Leerzeichen und Zeilenumbrüche enthalten kann.\n\n  Rückgabewerte:\n  - Die Anzahl der Zeichen im Titel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiele:\n  - count_title_chars(\"234\") gibt 3 zurück\n  - count_title_chars(\"Ca 45\") gibt 4 zurück\n  - count_title_chars(\"Hello\\nWorld\") gibt 10 zurück\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "ha": "/*\n  Lissafa yawan haruffa a cikin wani take na kirtani, banda sarari da haruffan sabon layi.\n\n  Hujojji:\n  - title: Wani kirtani da zai iya dauke da manyan da kananan haruffan Turanci, lambobi, sarari, da haruffan sabon layi.\n\n  Mai dawowa:\n  - Yawan haruffa a cikin taken, banda sarari da haruffan sabon layi.\n\n  Misalai:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "hi": "/*\n  दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n  तर्क:\n  - title: एक स्ट्रिंग जो बड़े और छोटे अंग्रेजी अक्षरों, अंक, रिक्त स्थान, और नई पंक्ति के वर्णों को शामिल कर सकती है।\n\n  लौटाता है:\n  - शीर्षक में वर्णों की गिनती, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n  उदाहरण:\n  - count_title_chars(\"234\") 3 लौटाता है\n  - count_title_chars(\"Ca 45\") 4 लौटाता है\n  - count_title_chars(\"Hello\\nWorld\") 10 लौटाता है\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "hu": "/*\n  Kiszámítja a karakterek számát egy adott cím sztringben, a szóközök és az új sor karakterek kivételével.\n\n  Argumentumok:\n  - title: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, számjegyeket, szóközöket és új sor karaktereket.\n\n  Visszatér:\n  - A karakterek száma a címben, a szóközök és az új sor karakterek kivételével.\n\n  Példák:\n  - count_title_chars(\"234\") visszaadja 3\n  - count_title_chars(\"Ca 45\") visszaadja 4\n  - count_title_chars(\"Hello\\nWorld\") visszaadja 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9956468165692394",
      "hy": "0.9774796846590265",
      "bn": "0.9852272626712922",
      "bg": "0.9967255781686398",
      "zh": "0.9816197376909366",
      "fr": "0.9914702155472188",
      "de": "0.9540599709527269",
      "ha": "0.9770409101473204",
      "hi": "0.9912235166139735",
      "hu": "0.9967255781686398"
    },
    "canonical_solution": "{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_title_chars(title: &str) -> usize` to solve the following problem:\nCalculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "sq": "Shkruani një funksion Rust `fn count_title_chars(title: &str) -> usize` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Argumentet:\n  - title: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla angleze, shifra, hapësira dhe karaktere të rreshtave të rinj.\n\n  Kthen:\n  - Numri i karaktereve në titull, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Shembuj:\n  - count_title_chars(\"234\") kthen 3\n  - count_title_chars(\"Ca 45\") kthen 4\n  - count_title_chars(\"Hello\\nWorld\") kthen 10",
      "hy": "Rust ֆունկցիա `fn count_title_chars(title: &str) -> usize` գրեք հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված վերնագրի տողում գտնվող սիմվոլների քանակը՝ բացի բացատներից և նոր տողի սիմվոլներից:\n\n  Արգումենտներ:\n  - title: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, թվանշաններ, բացատներ և նոր տողի սիմվոլներ:\n\n  Վերադարձնում է:\n  - Սիմվոլների քանակը վերնագրում՝ բացի բացատներից և նոր տողի սիմվոլներից:\n\n  Օրինակներ:\n  - count_title_chars(\"234\") վերադարձնում է 3\n  - count_title_chars(\"Ca 45\") վերադարձնում է 4\n  - count_title_chars(\"Hello\\nWorld\") վերադարձնում է 10",
      "bn": "Rust ফাংশন `fn count_title_chars(title: &str) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত শিরোনাম স্ট্রিংয়ে কতগুলি অক্ষর রয়েছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n  আর্গুমেন্টসমূহ:\n  - title: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা, ফাঁকা স্থান এবং নতুন লাইন অক্ষর থাকতে পারে।\n\n  রিটার্নস:\n  - শিরোনামে অক্ষরের সংখ্যা, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n  উদাহরণসমূহ:\n  - count_title_chars(\"234\") রিটার্ন করে 3\n  - count_title_chars(\"Ca 45\") রিটার্ন করে 4\n  - count_title_chars(\"Hello\\nWorld\") রিটার্ন করে 10",
      "bg": "Напишете функция на Rust `fn count_title_chars(title: &str) -> usize`, за да решите следния проблем:\nИзчислява броя на символите в даден низ на заглавие, изключвайки интервали и символи за нов ред.\n\n  Аргументи:\n  - title: Низ, който може да съдържа главни и малки английски букви, цифри, интервали и символи за нов ред.\n\n  Връща:\n  - Броят на символите в заглавието, изключвайки интервали и символи за нов ред.\n\n  Примери:\n  - count_title_chars(\"234\") връща 3\n  - count_title_chars(\"Ca 45\") връща 4\n  - count_title_chars(\"Hello\\nWorld\") връща 10",
      "zh": "编写一个 Rust 函数 `fn count_title_chars(title: &str) -> usize` 来解决以下问题：\n计算给定标题字符串中的字符数量，排除空格和换行符。\n\n参数：\n- title: 一个字符串，可能包含大写和小写的英文字母、数字、空格和换行符。\n\n返回：\n- 标题中字符的数量，排除空格和换行符。\n\n示例：\n- count_title_chars(\"234\") 返回 3\n- count_title_chars(\"Ca 45\") 返回 4\n- count_title_chars(\"Hello\\nWorld\") 返回 10",
      "fr": "Écrire une fonction Rust `fn count_title_chars(title: &str) -> usize` pour résoudre le problème suivant :\nCalcule le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Arguments :\n  - title : Une chaîne qui peut contenir des lettres majuscules et minuscules anglaises, des chiffres, des espaces et des caractères de nouvelle ligne.\n\n  Renvoie :\n  - Le nombre de caractères dans le titre, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Exemples :\n  - count_title_chars(\"234\") renvoie 3\n  - count_title_chars(\"Ca 45\") renvoie 4\n  - count_title_chars(\"Hello\\nWorld\") renvoie 10",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_title_chars(title: &str) -> usize`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n\n  Argumente:\n  - title: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, Leerzeichen und Zeilenumbrüche enthalten kann.\n\n  Rückgabewert:\n  - Die Anzahl der Zeichen im Titel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiele:\n  - count_title_chars(\"234\") gibt 3 zurück\n  - count_title_chars(\"Ca 45\") gibt 4 zurück\n  - count_title_chars(\"Hello\\nWorld\") gibt 10 zurück",
      "ha": "Rubuta aikin Rust `fn count_title_chars(title: &str) -> usize` don magance matsalar mai zuwa:\nLissafa yawan haruffa a cikin taken da aka bayar, ba tare da haɗa sarari da haruffan sabon layi ba.\n\n  Huɗɗa:\n  - title: Wani kirtani wanda zai iya ƙunsar manyan da ƙananan haruffan Ingilishi, lambobi, sarari, da haruffan sabon layi.\n\n  Mayarwa:\n  - Yawan haruffa a cikin taken, ba tare da haɗa sarari da haruffan sabon layi ba.\n\n  Misalai:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "hi": "Rust फ़ंक्शन `fn count_title_chars(title: &str) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n  तर्क:\n  - title: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, अंक, रिक्त स्थान, और नई पंक्ति के वर्ण शामिल हो सकते हैं।\n\n  वापसी मान:\n  - शीर्षक में वर्णों की गिनती, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n  उदाहरण:\n  - count_title_chars(\"234\") 3 लौटाता है\n  - count_title_chars(\"Ca 45\") 4 लौटाता है\n  - count_title_chars(\"Hello\\nWorld\") 10 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_title_chars(title: &str) -> usize` a következő probléma megoldására:\nKiszámítja a karakterek számát egy adott cím stringben, kivéve a szóközöket és az új sor karaktereket.\n\n  Argumentumok:\n  - title: Egy string, amely tartalmazhat nagy- és kisbetűs angol betűket, számjegyeket, szóközöket és új sor karaktereket.\n\n  Visszatér:\n  - A karakterek száma a címben, kivéve a szóközöket és az új sor karaktereket.\n\n  Példák:\n  - count_title_chars(\"234\") visszaadja 3\n  - count_title_chars(\"Ca 45\") visszaadja 4\n  - count_title_chars(\"Hello\\nWorld\") visszaadja 10"
    },
    "instruction_bertscore": {
      "sq": "0.9961074404228593",
      "hy": "0.9764334984421157",
      "bn": "0.9751586886566338",
      "bg": "0.9970789416165009",
      "zh": "0.9797710847346449",
      "fr": "0.992114969764058",
      "de": "0.9599632658770838",
      "ha": "0.9622254672866901",
      "hi": "0.970855361451513",
      "hu": "0.9970789416165009"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_title_chars(\"234\"), 3);\n        assert_eq!(count_title_chars(\"Ca 45\"), 4);\n        assert_eq!(count_title_chars(\"Hello\\nWorld\"), 10);\n    }\n    \n\n}",
    "entry_point": "count_title_chars",
    "signature": "fn count_title_chars(title: &str) -> usize",
    "docstring": {
      "en": "Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "sq": "Llogarit numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Argumentet:\n  - title: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla të anglishtes, shifra, hapësira dhe karaktere të rreshtave të rinj.\n\n  Kthen:\n  - Numri i karaktereve në titull, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Shembuj:\n  - count_title_chars(\"234\") kthen 3\n  - count_title_chars(\"Ca 45\") kthen 4\n  - count_title_chars(\"Hello\\nWorld\") kthen 10",
      "hy": "Հաշվում է տրված վերնագրի տողում գտնվող սիմվոլների քանակը՝ բացառելով բացատներն ու նոր տողի սիմվոլները։\n\n  Արգումենտներ:\n  - title: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, թվեր, բացատներ և նոր տողի սիմվոլներ։\n\n  Վերադարձնում է:\n  - Սիմվոլների քանակը վերնագրում՝ բացառելով բացատներն ու նոր տողի սիմվոլները։\n\n  Օրինակներ:\n  - count_title_chars(\"234\") վերադարձնում է 3\n  - count_title_chars(\"Ca 45\") վերադարձնում է 4\n  - count_title_chars(\"Hello\\nWorld\") վերադարձնում է 10",
      "bn": "প্রদত্ত শিরোনাম স্ট্রিং-এ কতগুলি অক্ষর রয়েছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n  আর্গুমেন্টস:\n  - title: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা, ফাঁকা স্থান এবং নতুন লাইন অক্ষর ধারণ করতে পারে।\n\n  রিটার্নস:\n  - শিরোনামে ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে অক্ষরের সংখ্যা।\n\n  উদাহরণ:\n  - count_title_chars(\"234\") রিটার্ন করে 3\n  - count_title_chars(\"Ca 45\") রিটার্ন করে 4\n  - count_title_chars(\"Hello\\nWorld\") রিটার্ন করে 10",
      "bg": "Изчислява броя на символите в даден низ за заглавие, изключвайки интервалите и символите за нов ред.\n\nАргументи:\n- title: Низ, който може да съдържа главни и малки английски букви, цифри, интервали и символи за нов ред.\n\nВръща:\n- Броят на символите в заглавието, изключвайки интервалите и символите за нов ред.\n\nПримери:\n- count_title_chars(\"234\") връща 3\n- count_title_chars(\"Ca 45\") връща 4\n- count_title_chars(\"Hello\\nWorld\") връща 10",
      "zh": "计算给定标题字符串中的字符数，不包括空格和换行符。\n\n  参数:\n  - title: 一个字符串，可能包含大写和小写的英文字母、数字、空格和换行符。\n\n  返回:\n  - 标题中字符的数量，不包括空格和换行符。\n\n  示例:\n  - count_title_chars(\"234\") 返回 3\n  - count_title_chars(\"Ca 45\") 返回 4\n  - count_title_chars(\"Hello\\nWorld\") 返回 10",
      "fr": "Calcule le nombre de caractères dans une chaîne de titre donnée, à l'exclusion des espaces et des caractères de nouvelle ligne.\n\n  Arguments:\n  - title: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, des chiffres, des espaces et des caractères de nouvelle ligne.\n\n  Renvoie:\n  - Le nombre de caractères dans le titre, à l'exclusion des espaces et des caractères de nouvelle ligne.\n\n  Exemples:\n  - count_title_chars(\"234\") renvoie 3\n  - count_title_chars(\"Ca 45\") renvoie 4\n  - count_title_chars(\"Hello\\nWorld\") renvoie 10",
      "de": "Berechnet die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n\n  Argumente:\n  - title: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, Leerzeichen und Zeilenumbrüche enthalten kann.\n\n  Rückgabewerte:\n  - Die Anzahl der Zeichen im Titel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiele:\n  - count_title_chars(\"234\") gibt 3 zurück\n  - count_title_chars(\"Ca 45\") gibt 4 zurück\n  - count_title_chars(\"Hello\\nWorld\") gibt 10 zurück",
      "ha": "Lissafa yawan haruffa a cikin wani take na kirtani, banda sarari da haruffan sabon layi.\n\n  Huɗɗa:\n  - title: Wani kirtani wanda zai iya ƙunsar manyan da ƙananan haruffan Ingilishi, lambobi, sarari, da haruffan sabon layi.\n\n  Komawa:\n  - Adadin haruffa a cikin taken, ban da sarari da haruffan sabon layi.\n\n  Misalai:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "hi": "दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n  तर्क:\n  - title: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, अंक, रिक्त स्थान और नई पंक्ति के वर्ण हो सकते हैं।\n\n  वापसी:\n  - शीर्षक में वर्णों की गिनती, रिक्त स्थान और नई पंक्ति के वर्णों को छोड़कर।\n\n  उदाहरण:\n  - count_title_chars(\"234\") 3 लौटाता है\n  - count_title_chars(\"Ca 45\") 4 लौटाता है\n  - count_title_chars(\"Hello\\nWorld\") 10 लौटाता है",
      "hu": "Számolja ki a megadott cím sztringben található karakterek számát, a szóközök és az új sor karakterek kivételével.\n\n  Argumentumok:\n  - title: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, számjegyeket, szóközöket és új sor karaktereket.\n\n  Visszatérési érték:\n  - A címben található karakterek száma, a szóközök és az új sor karakterek kivételével.\n\n  Példák:\n  - count_title_chars(\"234\") visszaadja 3\n  - count_title_chars(\"Ca 45\") visszaadja 4\n  - count_title_chars(\"Hello\\nWorld\") visszaadja 10"
    },
    "docstring_bertscore": {
      "sq": "0.9929343200858269",
      "hy": "0.9789183645088622",
      "bn": "0.9718137530400063",
      "bg": "0.9954487820793476",
      "zh": "0.9734850290660338",
      "fr": "0.9880692661631394",
      "de": "0.948691190383735",
      "ha": "0.9776797054527285",
      "hi": "0.9957683783624327",
      "hu": "0.9856900714591036"
    }
  },
  {
    "task_id": "Rust/50",
    "prompt": {
      "en": "/*\n  Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "sq": "/*\n  Numëron numrin e studentëve që janë regjistruar në të dy Kursin A dhe Kursin B.\n\n  Argumentet:\n  - n: Numri i studentëve të regjistruar në Kursin A.\n  - m: Numri i studentëve të regjistruar në Kursin B.\n  - a: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin A.\n  - b: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin B.\n\n  Kthen:\n  - Numrin e studentëve që janë regjistruar në të dy kurset.\n\n  Shembull:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) kthen 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) kthen 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "hy": "/*\n  Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Դասընթաց A-ում, և՛ Դասընթաց B-ում:\n\n  Արգումենտներ:\n  - n: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց A-ում:\n  - m: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց B-ում:\n  - a: Վեկտոր, որը պարունակում է Դասընթաց A-ում գրանցված ուսանողների ID-ները:\n  - b: Վեկտոր, որը պարունակում է Դասընթաց B-ում գրանցված ուսանողների ID-ները:\n\n  Վերադարձնում է:\n  - Ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում:\n\n  Օրինակ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) վերադարձնում է 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) վերադարձնում է 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "bn": "/*\n  কতজন শিক্ষার্থী কোর্স A এবং কোর্স B উভয়েই ভর্তি হয়েছে তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n  - m: কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n  - a: কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n  - b: কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n\n  রিটার্নস:\n  - কতজন শিক্ষার্থী উভয় কোর্সেই ভর্তি হয়েছে।\n\n  উদাহরণ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 রিটার্ন করে\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 রিটার্ন করে\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
      "bg": "/*\n  Брои броя на студентите, които са записани както в Курс A, така и в Курс B.\n\n  Аргументи:\n  - n: Броят на студентите, записани в Курс A.\n  - m: Броят на студентите, записани в Курс B.\n  - a: Вектор, съдържащ ID на студентите, записани в Курс A.\n  - b: Вектор, съдържащ ID на студентите, записани в Курс B.\n\n  Връща:\n  - Броят на студентите, които са записани и в двата курса.\n\n  Пример:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) връща 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) връща 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "zh": "/*\n  计算同时注册了课程A和课程B的学生人数。\n\n  参数:\n  - n: 注册课程A的学生人数。\n  - m: 注册课程B的学生人数。\n  - a: 包含注册课程A的学生ID的向量。\n  - b: 包含注册课程B的学生ID的向量。\n\n  返回:\n  - 同时注册了两个课程的学生人数。\n\n  示例:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 返回 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 返回 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "fr": "/*\n  Compte le nombre d'étudiants inscrits à la fois au Cours A et au Cours B.\n\n  Arguments:\n  - n: Le nombre d'étudiants inscrits au Cours A.\n  - m: Le nombre d'étudiants inscrits au Cours B.\n  - a: Un vecteur contenant les identifiants des étudiants inscrits au Cours A.\n  - b: Un vecteur contenant les identifiants des étudiants inscrits au Cours B.\n\n  Retourne:\n  - Le nombre d'étudiants qui sont inscrits aux deux cours.\n\n  Exemple:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "de": "/*\n  Zählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n\n  Argumente:\n  - n: Die Anzahl der Studenten, die in Kurs A eingeschrieben sind.\n  - m: Die Anzahl der Studenten, die in Kurs B eingeschrieben sind.\n  - a: Ein Vektor, der die IDs der Studenten enthält, die in Kurs A eingeschrieben sind.\n  - b: Ein Vektor, der die IDs der Studenten enthält, die in Kurs B eingeschrieben sind.\n\n  Rückgabewert:\n  - Die Anzahl der Studenten, die in beiden Kursen eingeschrieben sind.\n\n  Beispiel:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) gibt 4 zurück\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) gibt 0 zurück\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "ha": "/*\n  Yana ƙididdige adadin ɗaliban da suka yi rijista a duka Course A da Course B.\n\n  Huɗɗa:\n  - n: Adadin ɗaliban da suka yi rijista a Course A.\n  - m: Adadin ɗaliban da suka yi rijista a Course B.\n  - a: Wani vector da ke ɗauke da ID na ɗaliban da suka yi rijista a Course A.\n  - b: Wani vector da ke ɗauke da ID na ɗaliban da suka yi rijista a Course B.\n\n  Komawa:\n  - Adadin ɗaliban da suka yi rijista a duka kwasa-kwasan.\n\n  Misali:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "hi": "/*\n  उन छात्रों की संख्या गिनता है जिन्होंने दोनों कोर्स A और कोर्स B में नामांकन किया है।\n\n  तर्क:\n  - n: कोर्स A में नामांकित छात्रों की संख्या।\n  - m: कोर्स B में नामांकित छात्रों की संख्या।\n  - a: कोर्स A में नामांकित छात्रों के आईडी वाला एक वेक्टर।\n  - b: कोर्स B में नामांकित छात्रों के आईडी वाला एक वेक्टर।\n\n  लौटाता है:\n  - उन छात्रों की संख्या जो दोनों कोर्स में नामांकित हैं।\n\n  उदाहरण:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 लौटाता है\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 लौटाता है\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "hu": "/*\n  Megszámolja azon diákok számát, akik mind a A, mind a B kurzusra beiratkoztak.\n\n  Argumentumok:\n  - n: Az A kurzusra beiratkozott diákok száma.\n  - m: A B kurzusra beiratkozott diákok száma.\n  - a: Egy vektor, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza.\n  - b: Egy vektor, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n\n  Visszatér:\n  - Azon diákok száma, akik mindkét kurzusra beiratkoztak.\n\n  Példa:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) visszaadja 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) visszaadja 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9982671485558516",
      "hy": "0.9982671485558516",
      "bn": "0.9724080551400627",
      "bg": "0.9982671485558516",
      "zh": "0.9656079440453332",
      "fr": "0.9909162354145125",
      "de": "0.9922035589139996",
      "ha": "0.9672820008966952",
      "hi": "0.9793668719092389",
      "hu": "0.9953093435518611"
    },
    "canonical_solution": "{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` to solve the following problem:\nCounts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "sq": "Shkruani një funksion Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e studentëve që janë regjistruar si në Kursin A ashtu edhe në Kursin B.\n\n  Argumentet:\n  - n: Numri i studentëve të regjistruar në Kursin A.\n  - m: Numri i studentëve të regjistruar në Kursin B.\n  - a: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin A.\n  - b: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin B.\n\n  Kthen:\n  - Numri i studentëve që janë regjistruar në të dyja kurset.\n\n  Shembull:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) kthen 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) kthen 0",
      "hy": "Գրեք Rust ֆունկցիա `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն ուսանողների քանակը, ովքեր գրանցված են և՛ Դասընթաց Ա-ում, և՛ Դասընթաց Բ-ում:\n\n  Արգումենտներ:\n  - n: Ուսանողների քանակը, ովքեր գրանցված են Դասընթաց Ա-ում:\n  - m: Ուսանողների քանակը, ովքեր գրանցված են Դասընթաց Բ-ում:\n  - a: Վեկտոր, որը պարունակում է Դասընթաց Ա-ում գրանցված ուսանողների ID-ները:\n  - b: Վեկտոր, որը պարունակում է Դասընթաց Բ-ում գրանցված ուսանողների ID-ները:\n\n  Վերադարձնում է:\n  - Ուսանողների քանակը, ովքեր գրանցված են երկու դասընթացներում:\n\n  Օրինակ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) վերադարձնում է 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) վերադարձնում է 0",
      "bn": "Rust ফাংশন `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nগণনা করে কতজন ছাত্র উভয় কোর্স A এবং কোর্স B-তে ভর্তি হয়েছে।\n\n  আর্গুমেন্টসমূহ:\n  - n: কোর্স A-তে ভর্তি হওয়া ছাত্রদের সংখ্যা।\n  - m: কোর্স B-তে ভর্তি হওয়া ছাত্রদের সংখ্যা।\n  - a: কোর্স A-তে ভর্তি হওয়া ছাত্রদের আইডির একটি ভেক্টর।\n  - b: কোর্স B-তে ভর্তি হওয়া ছাত্রদের আইডির একটি ভেক্টর।\n\n  রিটার্নস:\n  - কতজন ছাত্র উভয় কোর্সে ভর্তি হয়েছে তার সংখ্যা।\n\n  উদাহরণ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 রিটার্ন করে\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 রিটার্ন করে",
      "bg": "Напишете функция на Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize`, за да решите следния проблем:\nБрои броя на студентите, които са записани и в двата курса - Курс A и Курс B.\n\n  Аргументи:\n  - n: Броят на студентите, записани в Курс A.\n  - m: Броят на студентите, записани в Курс B.\n  - a: Вектор, съдържащ ID-тата на студентите, записани в Курс A.\n  - b: Вектор, съдържащ ID-тата на студентите, записани в Курс B.\n\n  Връща:\n  - Броят на студентите, които са записани и в двата курса.\n\n  Пример:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) връща 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) връща 0",
      "zh": "编写一个 Rust 函数 `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` 来解决以下问题：\n计算同时注册了课程 A 和课程 B 的学生人数。\n\n  参数:\n  - n: 注册课程 A 的学生人数。\n  - m: 注册课程 B 的学生人数。\n  - a: 包含注册课程 A 的学生 ID 的向量。\n  - b: 包含注册课程 B 的学生 ID 的向量。\n\n  返回值:\n  - 同时注册了两个课程的学生人数。\n\n  示例:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 返回 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 返回 0",
      "fr": "Écrire une fonction Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` pour résoudre le problème suivant :\nCompte le nombre d'étudiants qui se sont inscrits à la fois au Cours A et au Cours B.\n\n  Arguments:\n  - n: Le nombre d'étudiants inscrits au Cours A.\n  - m: Le nombre d'étudiants inscrits au Cours B.\n  - a: Un vecteur contenant les identifiants des étudiants inscrits au Cours A.\n  - b: Un vecteur contenant les identifiants des étudiants inscrits au Cours B.\n\n  Renvoie:\n  - Le nombre d'étudiants qui sont inscrits aux deux cours.\n\n  Exemple:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) renvoie 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) renvoie 0",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize`, um das folgende Problem zu lösen:\nZählt die Anzahl der Studenten, die sich sowohl für Kurs A als auch für Kurs B eingeschrieben haben.\n\n  Argumente:\n  - n: Die Anzahl der Studenten, die in Kurs A eingeschrieben sind.\n  - m: Die Anzahl der Studenten, die in Kurs B eingeschrieben sind.\n  - a: Ein Vektor, der die IDs der Studenten enthält, die in Kurs A eingeschrieben sind.\n  - b: Ein Vektor, der die IDs der Studenten enthält, die in Kurs B eingeschrieben sind.\n\n  Rückgabe:\n  - Die Anzahl der Studenten, die in beiden Kursen eingeschrieben sind.\n\n  Beispiel:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) gibt 4 zurück\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) gibt 0 zurück",
      "ha": "Rubuta aikin Rust `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` don warware matsalar mai zuwa:\nYana ƙididdige yawan ɗaliban da suka yi rajista a duka Course A da Course B.\n\n  Huɗɗa:\n  - n: Yawan ɗaliban da suka yi rajista a Course A.\n  - m: Yawan ɗaliban da suka yi rajista a Course B.\n  - a: Wani vector da ke ɗauke da ID na ɗaliban da suka yi rajista a Course A.\n  - b: Wani vector da ke ɗauke da ID na ɗaliban da suka yi rajista a Course B.\n\n  Komawa:\n  - Yawan ɗaliban da suka yi rajista a duka darussan.\n\n  Misali:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "hi": "Rust फ़ंक्शन `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन छात्रों की संख्या गिनें जिन्होंने कोर्स A और कोर्स B दोनों में नामांकन किया है।\n\n  तर्क:\n  - n: कोर्स A में नामांकित छात्रों की संख्या।\n  - m: कोर्स B में नामांकित छात्रों की संख्या।\n  - a: कोर्स A में नामांकित छात्रों के आईडी वाली एक वेक्टर।\n  - b: कोर्स B में नामांकित छात्रों के आईडी वाली एक वेक्टर।\n\n  लौटाता है:\n  - उन छात्रों की संख्या जो दोनों कोर्स में नामांकित हैं।\n\n  उदाहरण:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 लौटाता है\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize` a következő probléma megoldására:\nMegszámolja azoknak a diákoknak a számát, akik beiratkoztak mind az A, mind a B kurzusra.\n\n  Argumentumok:\n  - n: Az A kurzusra beiratkozott diákok száma.\n  - m: A B kurzusra beiratkozott diákok száma.\n  - a: Egy vektor, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza.\n  - b: Egy vektor, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n\n  Visszatérési érték:\n  - Azoknak a diákoknak a száma, akik mindkét kurzusra beiratkoztak.\n\n  Példa:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) visszaadja 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.9984669707191728",
      "hy": "0.9984669707191728",
      "bn": "0.9691185373997439",
      "bg": "0.9901705769641075",
      "zh": "0.9630918930087643",
      "fr": "0.9970046538539938",
      "de": "0.9916221677887105",
      "ha": "0.9730730696557675",
      "hi": "0.9728148501604221",
      "hu": "0.9924919702272622"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]), 4);\n        assert_eq!(count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]), 0);\n        assert_eq!(count_students_enrolled_in_both(4, 4, vec![1, 3, 5, 7], vec![2, 4, 1, 3]), 2);\n    \n    }\n\n}",
    "entry_point": "count_students_enrolled_in_both",
    "signature": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "sq": "Numëron numrin e studentëve që janë regjistruar në të dy Kursin A dhe Kursin B.\n\n  Argumentet:\n  - n: Numri i studentëve të regjistruar në Kursin A.\n  - m: Numri i studentëve të regjistruar në Kursin B.\n  - a: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin A.\n  - b: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin B.\n\n  Kthen:\n  - Numri i studentëve që janë regjistruar në të dy kurset.\n\n  Shembull:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) kthen 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) kthen 0",
      "hy": "Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են ինչպես Դասընթաց A-ում, այնպես էլ Դասընթաց B-ում:\n\n  Արձանագրություններ:\n  - n: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց A-ում:\n  - m: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց B-ում:\n  - a: Վեկտոր, որը պարունակում է Դասընթաց A-ում գրանցված ուսանողների ID-ները:\n  - b: Վեկտոր, որը պարունակում է Դասընթաց B-ում գրանցված ուսանողների ID-ները:\n\n  Վերադարձնում է:\n  - Ուսանողների քանակը, ովքեր գրանցված են երկու դասընթացներում:\n\n  Օրինակ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) վերադարձնում է 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) վերադարձնում է 0",
      "bn": "কতজন শিক্ষার্থী কোর্স A এবং কোর্স B উভয়েই ভর্তি হয়েছে তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n  - m: কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n  - a: কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n  - b: কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n\n  রিটার্নস:\n  - উভয় কোর্সে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n\n  উদাহরণ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) রিটার্ন করে 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) রিটার্ন করে 0",
      "bg": "Брои броя на студентите, които са записани както в Курс А, така и в Курс Б.\n\n  Аргументи:\n  - n: Броят на студентите, записани в Курс А.\n  - m: Броят на студентите, записани в Курс Б.\n  - a: Вектор, съдържащ идентификаторите на студентите, записани в Курс А.\n  - b: Вектор, съдържащ идентификаторите на студентите, записани в Курс Б.\n\n  Връща:\n  - Броят на студентите, които са записани и в двата курса.\n\n  Пример:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) връща 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) връща 0",
      "zh": "计算同时注册了课程A和课程B的学生人数。\n\n  参数:\n  - n: 注册课程A的学生人数。\n  - m: 注册课程B的学生人数。\n  - a: 包含注册课程A的学生ID的向量。\n  - b: 包含注册课程B的学生ID的向量。\n\n  返回:\n  - 同时注册了两个课程的学生人数。\n\n  示例:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 返回 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 返回 0",
      "fr": "Compte le nombre d'étudiants qui se sont inscrits à la fois au Cours A et au Cours B.\n\n  Arguments:\n  - n: Le nombre d'étudiants inscrits au Cours A.\n  - m: Le nombre d'étudiants inscrits au Cours B.\n  - a: Un vecteur contenant les identifiants des étudiants inscrits au Cours A.\n  - b: Un vecteur contenant les identifiants des étudiants inscrits au Cours B.\n\n  Renvoie:\n  - Le nombre d'étudiants qui sont inscrits aux deux cours.\n\n  Exemple:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) renvoie 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) renvoie 0",
      "de": "Zählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n\n  Argumente:\n  - n: Die Anzahl der Studenten, die in Kurs A eingeschrieben sind.\n  - m: Die Anzahl der Studenten, die in Kurs B eingeschrieben sind.\n  - a: Ein Vektor, der die IDs der in Kurs A eingeschriebenen Studenten enthält.\n  - b: Ein Vektor, der die IDs der in Kurs B eingeschriebenen Studenten enthält.\n\n  Rückgabewert:\n  - Die Anzahl der Studenten, die in beiden Kursen eingeschrieben sind.\n\n  Beispiel:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) gibt 4 zurück\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) gibt 0 zurück",
      "ha": "Yana ƙididdige adadin ɗaliban da suka yi rijista a duka Course A da Course B.\n\n  Huɗɗa:\n  - n: Yawan ɗaliban da suka yi rajista a Course A.\n  - m: Yawan ɗaliban da suka yi rajista a Course B.\n  - a: Wata vector da ke ɗauke da ID na ɗaliban da suka yi rajista a Course A.\n  - b: Wata vector da ke ɗauke da ID na ɗaliban da suka yi rajista a Course B.\n\n  Komawa:\n  - Yawan ɗaliban da suka yi rajista a duka kwasa-kwasan.\n\n  Misali:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "hi": "उन छात्रों की संख्या गिनता है जिन्होंने दोनों कोर्स A और कोर्स B में नामांकन किया है।\n\n  तर्क:\n  - n: कोर्स A में नामांकित छात्रों की संख्या।\n  - m: कोर्स B में नामांकित छात्रों की संख्या।\n  - a: एक वेक्टर जिसमें कोर्स A में नामांकित छात्रों के आईडी शामिल हैं।\n  - b: एक वेक्टर जिसमें कोर्स B में नामांकित छात्रों के आईडी शामिल हैं।\n\n  प्रत्यावर्तन:\n  - उन छात्रों की संख्या जो दोनों पाठ्यक्रमों में नामांकित हैं।\n\n  उदाहरण:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "hu": "Számolja meg azoknak a diákoknak a számát, akik beiratkoztak mind az A, mind a B kurzusra.\n\n  Argumentumok:\n  - n: Az A kurzusra beiratkozott diákok száma.\n  - m: A B kurzusra beiratkozott diákok száma.\n  - a: Egy vektor, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza.\n  - b: Egy vektor, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n\n  Visszatérési érték:\n  - Azoknak a diákoknak a száma, akik mindkét kurzusra beiratkoztak.\n\n  Példa:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) visszaadja 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9977238944637212",
      "hy": "0.9890912194735639",
      "bn": "0.9814433539125776",
      "bg": "0.993071573679122",
      "zh": "0.9505366652539301",
      "fr": "0.9888818630519531",
      "de": "0.9807374215383796",
      "ha": "0.9578091193947604",
      "hi": "0.9897840422426136",
      "hu": "0.9863366133493721"
    }
  },
  {
    "task_id": "Rust/51",
    "prompt": {
      "en": "/*\n  Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "sq": "/*\n  Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dërgesave të suksesshme dhe të dështuara.\n  Deliv-e-droid fiton 50 njësi parash për çdo dërgesë të suksesshme dhe humbet 10 njësi për çdo dërgesë të dështuar.\n  Për më tepër, nëse numri i dërgesave të suksesshme është më i madh se ai i dërgesave të dështuara, Deliv-e-droid merr një bonus prej 500 njësive.\n\n  Argumentet:\n  - delivered: Numri i pakove të dorëzuara me sukses (0 <= delivered <= 100).\n  - failed: Numri i dërgesave të dështuara (0 <= failed <= 100).\n\n  Kthen:\n  - Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\n  Shembuj:\n  - calculate_droid_earnings(5, 2) kthen 730.\n  - calculate_droid_earnings(0, 10) kthen -100.\n  - calculate_droid_earnings(10, 5) kthen 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32",
      "hy": "/*\n  Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնված հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա:\n  Deliv-e-droid-ը վաստակում է 50 միավոր գումար յուրաքանչյուր հաջող առաքման համար և կորցնում է 10 միավոր յուրաքանչյուր ձախողված առաքման համար:\n  Բացի այդ, եթե հաջող առաքումների քանակը գերազանցում է ձախողվածներին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս:\n\n  Փաստարկներ:\n  - delivered: Հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100):\n  - failed: Ձախողված առաքումների քանակը (0 <= failed <= 100):\n\n  Վերադարձնում է:\n  - Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները:\n\n  Օրինակներ:\n  - calculate_droid_earnings(5, 2) վերադարձնում է 730:\n  - calculate_droid_earnings(0, 10) վերադարձնում է -100:\n  - calculate_droid_earnings(10, 5) վերադարձնում է 950:\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32",
      "bn": "/*\n  Deliv-e-droid এর মোট উপার্জন গণনা করে সফলভাবে বিতরণ এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n  Deliv-e-droid প্রতিটি সফল বিতরণের জন্য 50 ইউনিট অর্থ উপার্জন করে এবং প্রতিটি ব্যর্থ বিতরণের জন্য 10 ইউনিট হারায়।\n  অতিরিক্তভাবে, যদি সফল বিতরণের সংখ্যা ব্যর্থগুলোর চেয়ে বেশি হয়, Deliv-e-droid 500 ইউনিট বোনাস পায়।\n\n  আর্গুমেন্টসমূহ:\n  - delivered: সফলভাবে বিতরণকৃত প্যাকেজের সংখ্যা (0 <= delivered <= 100)।\n  - failed: ব্যর্থ বিতরণের সংখ্যা (0 <= failed <= 100)।\n\n  রিটার্নস:\n  - Deliv-e-droid এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভের চেয়ে বেশি হয়।\n\n  উদাহরণসমূহ:\n  - calculate_droid_earnings(5, 2) 730 রিটার্ন করে।\n  - calculate_droid_earnings(0, 10) -100 রিটার্ন করে।\n  - calculate_droid_earnings(10, 5) 950 রিটার্ন করে।\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "bg": "/*\n  Изчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените и неуспешните доставки.\n  Deliv-e-droid печели 50 единици пари за всяка успешна доставка и губи 10 единици за всяка неуспешна доставка.\n  Освен това, ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\n  Аргументи:\n  - delivered: Броят на успешно доставените пакети (0 <= delivered <= 100).\n  - failed: Броят на неуспешните доставки (0 <= failed <= 100).\n\n  Връща:\n  - Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\n  Примери:\n  - calculate_droid_earnings(5, 2) връща 730.\n  - calculate_droid_earnings(0, 10) връща -100.\n  - calculate_droid_earnings(10, 5) връща 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "zh": "/*\n  计算Deliv-e-droid的总收入，基于成功交付和失败交付的数量。\n  Deliv-e-droid每次成功交付赚取50个单位的钱，每次失败交付损失10个单位的钱。\n  此外，如果成功交付的数量大于失败交付的数量，Deliv-e-droid将获得500个单位的奖金。\n\n  参数:\n  - delivered: 成功交付的包裹数量 (0 <= delivered <= 100)。\n  - failed: 失败交付的数量 (0 <= failed <= 100)。\n\n  返回:\n  - Deliv-e-droid的总收入，如果损失超过收益，可能为负数。\n\n  示例:\n  - calculate_droid_earnings(5, 2) 返回 730。\n  - calculate_droid_earnings(0, 10) 返回 -100。\n  - calculate_droid_earnings(10, 5) 返回 950。\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "fr": "/*\n  Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées.\n  Deliv-e-droid gagne 50 unités d'argent pour chaque livraison réussie et perd 10 unités pour chaque livraison échouée.\n  De plus, si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\n  Arguments:\n  - delivered: Le nombre de colis livrés avec succès (0 <= delivered <= 100).\n  - failed: Le nombre de livraisons échouées (0 <= failed <= 100).\n\n  Retourne:\n  - Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\n  Exemples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "de": "/*\n  Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen.\n  Deliv-e-droid verdient 50 Einheiten Geld für jede erfolgreiche Lieferung und verliert 10 Einheiten für jede fehlgeschlagene Lieferung.\n  Zusätzlich erhält Deliv-e-droid einen Bonus von 500 Einheiten, wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen.\n\n  Argumente:\n  - delivered: Die Anzahl der erfolgreich zugestellten Pakete (0 <= delivered <= 100).\n  - failed: Die Anzahl der fehlgeschlagenen Lieferungen (0 <= failed <= 100).\n\n  Rückgabewert:\n  - Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne übersteigen.\n\n  Beispiele:\n  - calculate_droid_earnings(5, 2) gibt 730 zurück.\n  - calculate_droid_earnings(0, 10) gibt -100 zurück.\n  - calculate_droid_earnings(10, 5) gibt 950 zurück.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "ha": "/*\n  Lissafa jimillar kudaden shiga na Deliv-e-droid bisa ga yawan isar da kayayyaki da aka yi nasara da kuma wadanda suka gaza.\n  Deliv-e-droid yana samun 50 na kudade don kowanne isarwa da aka yi nasara kuma yana rasa 10 na kudade don kowanne isarwa da ya gaza.\n  Bugu da ƙari, idan yawan isar da kayayyaki da aka yi nasara ya fi yawan wadanda suka gaza, Deliv-e-droid yana samun kari na 500 na kudade.\n\n  Huɗa:\n  - delivered: Yawan kayayyaki da aka isar da nasara (0 <= delivered <= 100).\n  - failed: Yawan isar da kayayyaki da suka gaza (0 <= failed <= 100).\n\n  Komawa:\n  - Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi ribar.\n\n  Misalai:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "hi": "/*\n  Deliv-e-droid की कुल कमाई की गणना करता है जो सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या पर आधारित है।\n  Deliv-e-droid प्रत्येक सफल डिलीवरी के लिए 50 यूनिट पैसा कमाता है और प्रत्येक असफल डिलीवरी के लिए 10 यूनिट खोता है।\n  इसके अतिरिक्त, यदि सफल डिलीवरी की संख्या असफल डिलीवरी से अधिक है, तो Deliv-e-droid को 500 यूनिट का बोनस मिलता है।\n\n  तर्क:\n  - delivered: सफलतापूर्वक वितरित पैकेजों की संख्या (0 <= delivered <= 100)।\n  - failed: असफल डिलीवरी की संख्या (0 <= failed <= 100)।\n\n  लौटाता है:\n  - Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\n  उदाहरण:\n  - calculate_droid_earnings(5, 2) 730 लौटाता है।\n  - calculate_droid_earnings(0, 10) -100 लौटाता है।\n  - calculate_droid_earnings(10, 5) 950 लौटाता है।\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések számának alapján.\n  A Deliv-e-droid 50 egység pénzt keres minden sikeres kézbesítésért, és 10 egységet veszít minden sikertelen kézbesítésért.\n  Továbbá, ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egység bónuszt kap.\n\n  Argumentumok:\n  - delivered: A sikeresen kézbesített csomagok száma (0 <= delivered <= 100).\n  - failed: A sikertelen kézbesítések száma (0 <= failed <= 100).\n\n  Visszatérési érték:\n  - A Deliv-e-droid összes bevétele, amely lehet negatív is, ha a veszteségek meghaladják a nyereségeket.\n\n  Példák:\n  - calculate_droid_earnings(5, 2) visszaadja a 730-at.\n  - calculate_droid_earnings(0, 10) visszaadja a -100-at.\n  - calculate_droid_earnings(10, 5) visszaadja a 950-et.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9729264804345638",
      "hy": "0.9792272347513714",
      "bn": "0.9824353140354659",
      "bg": "0.9927156280363075",
      "zh": "0.9709733478978476",
      "fr": "0.9946989523909409",
      "de": "0.9856610714234725",
      "ha": "0.9658701361482993",
      "hi": "0.9778511234715617",
      "hu": "0.9958571661427553"
    },
    "canonical_solution": "{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}",
    "instruction": {
      "en": "Write a Rust function `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.",
      "sq": "Shkruani një funksion në Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` për të zgjidhur problemin e mëposhtëm:\nLlogarit fitimet totale të Deliv-e-droid bazuar në numrin e dërgesave të suksesshme dhe të dështuara.\n  Deliv-e-droid fiton 50 njësi parash për çdo dërgesë të suksesshme dhe humbet 10 njësi për çdo dërgesë të dështuar.\n  Për më tepër, nëse numri i dërgesave të suksesshme është më i madh se ai i dërgesave të dështuara, Deliv-e-droid merr një bonus prej 500 njësish.\n\n  Argumentet:\n  - delivered: Numri i pakove të dërguara me sukses (0 <= delivered <= 100).\n  - failed: Numri i dërgesave të dështuara (0 <= failed <= 100).\n\n  Kthen:\n  - Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\n  Shembuj:\n  - calculate_droid_earnings(5, 2) kthen 730.\n  - calculate_droid_earnings(0, 10) kthen -100.\n  - calculate_droid_earnings(10, 5) kthen 950.",
      "hy": "Գրեք Rust ֆունկցիա `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնվելով հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա:\n  Deliv-e-droid-ը վաստակում է 50 միավոր գումար յուրաքանչյուր հաջողված առաքման համար և կորցնում է 10 միավոր յուրաքանչյուր ձախողված առաքման համար:\n  Բացի այդ, եթե հաջողված առաքումների քանակը գերազանցում է ձախողվածներին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս:\n\n  Փոփոխականներ:\n  - delivered: Հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100):\n  - failed: Ձախողված առաքումների քանակը (0 <= failed <= 100):\n\n  Վերադարձնում է:\n  - Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները:\n\n  Օրինակներ:\n  - calculate_droid_earnings(5, 2) վերադարձնում է 730:\n  - calculate_droid_earnings(0, 10) վերադարձնում է -100:\n  - calculate_droid_earnings(10, 5) վերադարձնում է 950:",
      "bn": "Rust ফাংশন `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nDeliv-e-droid এর মোট আয় হিসাব করে, সফলভাবে বিতরণ এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n  Deliv-e-droid প্রতিটি সফল বিতরণের জন্য 50 ইউনিট অর্থ উপার্জন করে এবং প্রতিটি ব্যর্থ বিতরণের জন্য 10 ইউনিট হারায়।\n  অতিরিক্তভাবে, যদি সফল বিতরণের সংখ্যা ব্যর্থগুলোর চেয়ে বেশি হয়, তবে Deliv-e-droid 500 ইউনিট বোনাস পায়।\n\n  আর্গুমেন্টসমূহ:\n  - delivered: সফলভাবে বিতরণকৃত প্যাকেজের সংখ্যা (0 <= delivered <= 100)।\n  - failed: ব্যর্থ বিতরণের সংখ্যা (0 <= failed <= 100)।\n\n  রিটার্নস:\n  - Deliv-e-droid এর মোট আয়, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভকে ছাড়িয়ে যায়।\n\n  উদাহরণসমূহ:\n  - calculate_droid_earnings(5, 2) 730 রিটার্ন করে।\n  - calculate_droid_earnings(0, 10) -100 রিটার্ন করে।\n  - calculate_droid_earnings(10, 5) 950 রিটার্ন করে।",
      "bg": "Напишете функция на Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32`, за да решите следния проблем:\nИзчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените и неуспешните доставки.\n  Deliv-e-droid печели 50 единици пари за всяка успешна доставка и губи 10 единици за всяка неуспешна доставка.\n  Освен това, ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\n  Аргументи:\n  - delivered: Броят на успешно доставените пакети (0 <= delivered <= 100).\n  - failed: Броят на неуспешните доставки (0 <= failed <= 100).\n\n  Връща:\n  - Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\n  Примери:\n  - calculate_droid_earnings(5, 2) връща 730.\n  - calculate_droid_earnings(0, 10) връща -100.\n  - calculate_droid_earnings(10, 5) връща 950.",
      "zh": "编写一个 Rust 函数 `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` 来解决以下问题：\n计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。\nDeliv-e-droid 每成功交付一个包裹赚取 50 单位的金钱，每失败一个包裹损失 10 单位的金钱。\n另外，如果成功交付的数量大于失败的数量，Deliv-e-droid 将获得 500 单位的奖金。\n\n参数：\n- delivered: 成功交付的包裹数量 (0 <= delivered <= 100)。\n- failed: 失败交付的数量 (0 <= failed <= 100)。\n\n返回：\n- Deliv-e-droid 的总收入，如果损失超过收益，可能为负数。\n\n示例：\n- calculate_droid_earnings(5, 2) 返回 730。\n- calculate_droid_earnings(0, 10) 返回 -100。\n- calculate_droid_earnings(10, 5) 返回 950。",
      "fr": "Écrire une fonction Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` pour résoudre le problème suivant :\nCalcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées.\n  Deliv-e-droid gagne 50 unités d'argent pour chaque livraison réussie et perd 10 unités pour chaque livraison échouée.\n  De plus, si le nombre de livraisons réussies est supérieur au nombre d'échecs, Deliv-e-droid reçoit un bonus de 500 unités.\n\n  Arguments :\n  - delivered : Le nombre de colis livrés avec succès (0 <= delivered <= 100).\n  - failed : Le nombre de livraisons échouées (0 <= failed <= 100).\n\n  Renvoie :\n  - Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\n  Exemples :\n  - calculate_droid_earnings(5, 2) renvoie 730.\n  - calculate_droid_earnings(0, 10) renvoie -100.\n  - calculate_droid_earnings(10, 5) renvoie 950.",
      "de": "Schreiben Sie eine Rust-Funktion `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32`, um das folgende Problem zu lösen:\nBerechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen.\n  Deliv-e-droid verdient 50 Einheiten Geld für jede erfolgreiche Lieferung und verliert 10 Einheiten für jede fehlgeschlagene Lieferung.\n  Zusätzlich erhält Deliv-e-droid einen Bonus von 500 Einheiten, wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen.\n\n  Argumente:\n  - delivered: Die Anzahl der erfolgreich zugestellten Pakete (0 <= delivered <= 100).\n  - failed: Die Anzahl der fehlgeschlagenen Lieferungen (0 <= failed <= 100).\n\n  Rückgabewert:\n  - Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne übersteigen.\n\n  Beispiele:\n  - calculate_droid_earnings(5, 2) gibt 730 zurück.\n  - calculate_droid_earnings(0, 10) gibt -100 zurück.\n  - calculate_droid_earnings(10, 5) gibt 950 zurück.",
      "ha": "Rubuta aikin Rust `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` don warware matsalar mai zuwa:\nLissafa jimillar kudaden shiga na Deliv-e-droid bisa ga adadin nasarorin da aka kai da kuma wadanda suka kasa.\n  Deliv-e-droid yana samun 50 raka'a na kudi don kowane nasarar da aka kai kuma yana rasa 10 raka'a don kowane rashin nasara.\n  Bugu da ƙari, idan adadin nasarorin da aka kai ya fi yawan wadanda suka kasa, Deliv-e-droid yana samun kari na 500 raka'a.\n\n  Huɗɗa:\n  - delivered: Adadin fakitin da aka kai nasara (0 <= delivered <= 100).\n  - failed: Adadin rashin nasarorin da aka yi (0 <= failed <= 100).\n\n  Dawowa:\n  - Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi riba.\n\n  Misalai:\n  - calculate_droid_earnings(5, 2) yana dawowa 730.\n  - calculate_droid_earnings(0, 10) yana dawowa -100.\n  - calculate_droid_earnings(10, 5) yana dawowa 950.",
      "hi": "Rust फ़ंक्शन `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nDeliv-e-droid की कुल कमाई की गणना करें जो सफलतापूर्वक डिलीवर किए गए और असफल डिलीवरी की संख्या पर आधारित है।\n  Deliv-e-droid प्रत्येक सफल डिलीवरी के लिए 50 यूनिट पैसे कमाता है और प्रत्येक असफल डिलीवरी के लिए 10 यूनिट खोता है।\n  इसके अतिरिक्त, यदि सफल डिलीवरी की संख्या असफल डिलीवरी से अधिक है, तो Deliv-e-droid को 500 यूनिट का बोनस मिलता है।\n\n  तर्क:\n  - delivered: सफलतापूर्वक डिलीवर किए गए पैकेजों की संख्या (0 <= delivered <= 100)।\n  - failed: असफल डिलीवरी की संख्या (0 <= failed <= 100)।\n\n  रिटर्न:\n  - Deliv-e-droid की कुल कमाई, जो नकारात्मक भी हो सकती है यदि घाटा लाभ से अधिक हो।\n\n  उदाहरण:\n  - calculate_droid_earnings(5, 2) 730 लौटाता है।\n  - calculate_droid_earnings(0, 10) -100 लौटाता है।\n  - calculate_droid_earnings(10, 5) 950 लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32` a következő probléma megoldására:\nKiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján.\n  A Deliv-e-droid 50 egységnyi pénzt keres minden sikeres kézbesítésért, és 10 egységet veszít minden sikertelen kézbesítésért.\n  Továbbá, ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egységnyi bónuszt kap.\n\n  Argumentumok:\n  - delivered: A sikeresen kézbesített csomagok száma (0 <= delivered <= 100).\n  - failed: A sikertelen kézbesítések száma (0 <= failed <= 100).\n\n  Visszatér:\n  - A Deliv-e-droid összes bevétele, amely lehet negatív is, ha a veszteségek meghaladják a nyereséget.\n\n  Példák:\n  - calculate_droid_earnings(5, 2) visszatér 730.\n  - calculate_droid_earnings(0, 10) visszatér -100.\n  - calculate_droid_earnings(10, 5) visszatér 950."
    },
    "instruction_bertscore": {
      "sq": "0.9774272462384332",
      "hy": "0.9635207360014186",
      "bn": "0.9765250670477728",
      "bg": "0.9954042888739958",
      "zh": "0.9708362929349336",
      "fr": "0.9906029953036205",
      "de": "0.9865104149327777",
      "ha": "0.9679207962021035",
      "hi": "0.9701698880065616",
      "hu": "0.990981783440254"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_droid_earnings(5, 2), 730);\n        assert_eq!(calculate_droid_earnings(0, 10), -100);\n        assert_eq!(calculate_droid_earnings(10, 5), 950);\n        assert_eq!(calculate_droid_earnings(3, 3), 120);\n    }\n    \n\n}",
    "entry_point": "calculate_droid_earnings",
    "signature": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.",
      "sq": "Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dorëzimeve të suksesshme dhe të dështuara.\n  Deliv-e-droid fiton 50 njësi parash për çdo dorëzim të suksesshëm dhe humb 10 njësi për çdo dorëzim të dështuar.\n  Për më tepër, nëse numri i dorëzimeve të suksesshme është më i madh se ai i dështimeve, Deliv-e-droid merr një bonus prej 500 njësish.\n\n  Argumentet:\n  - delivered: Numri i pakove të dorëzuara me sukses (0 <= delivered <= 100).\n  - failed: Numri i dorëzimeve të dështuara (0 <= failed <= 100).\n\n  Kthen:\n  - Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\n  Shembuj:\n  - calculate_droid_earnings(5, 2) kthen 730.\n  - calculate_droid_earnings(0, 10) kthen -100.\n  - calculate_droid_earnings(10, 5) kthen 950.",
      "hy": "Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնվելով հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա։  \nDeliv-e-droid-ը վաստակում է 50 միավոր գումար յուրաքանչյուր հաջողված առաքման համար և կորցնում է 10 միավոր յուրաքանչյուր ձախողված առաքման համար։  \nԲացի այդ, եթե հաջողությամբ առաքումների քանակը գերազանցում է ձախողվածներին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n\nԱրձանագրություններ:\n- delivered: Հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100)։\n- failed: Ձախողված առաքումների քանակը (0 <= failed <= 100)։\n\nՎերադարձնում է:\n- Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n\nՕրինակներ:\n- calculate_droid_earnings(5, 2) վերադարձնում է 730։\n- calculate_droid_earnings(0, 10) վերադարձնում է -100։\n- calculate_droid_earnings(10, 5) վերադարձնում է 950։",
      "bn": "Deliv-e-droid-এর মোট উপার্জন গণনা করে সফলভাবে বিতরণকৃত এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n  Deliv-e-droid প্রতিটি সফল বিতরণের জন্য ৫০ ইউনিট অর্থ উপার্জন করে এবং প্রতিটি ব্যর্থ বিতরণের জন্য ১০ ইউনিট হারায়।\n  অতিরিক্তভাবে, যদি সফল বিতরণের সংখ্যা ব্যর্থগুলোর চেয়ে বেশি হয়, তাহলে Deliv-e-droid ৫০০ ইউনিট বোনাস পায়।\n\n  Arguments:\n  - delivered: সফলভাবে বিতরণকৃত প্যাকেজের সংখ্যা (0 <= delivered <= 100)।\n  - failed: ব্যর্থ বিতরণের সংখ্যা (0 <= failed <= 100)।\n\n  Returns:\n  - Deliv-e-droid-এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভের চেয়ে বেশি হয়।\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730।\n  - calculate_droid_earnings(0, 10) returns -100।\n  - calculate_droid_earnings(10, 5) returns 950।",
      "bg": "Изчислява общите приходи на Deliv-e-droid въз основа на броя успешно доставени и неуспешни доставки.\n  Deliv-e-droid печели 50 единици пари за всяка успешна доставка и губи 10 единици за всяка неуспешна доставка.\n  Освен това, ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\n  Аргументи:\n  - delivered: Броят на успешно доставените пакети (0 <= delivered <= 100).\n  - failed: Броят на неуспешните доставки (0 <= failed <= 100).\n\n  Връща:\n  - Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\n  Примери:\n  - calculate_droid_earnings(5, 2) връща 730.\n  - calculate_droid_earnings(0, 10) връща -100.\n  - calculate_droid_earnings(10, 5) връща 950.",
      "zh": "计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。\nDeliv-e-droid 每成功交付一个包裹赚取 50 单位的钱，每失败交付一个包裹损失 10 单位的钱。\n另外，如果成功交付的数量大于失败交付的数量，Deliv-e-droid 将获得 500 单位的奖金。\n\n参数:\n- delivered: 成功交付的包裹数量 (0 <= delivered <= 100)。\n- failed: 失败交付的数量 (0 <= failed <= 100)。\n\n返回:\n- Deliv-e-droid 的总收入，如果损失超过收益，则可能为负数。\n\n示例:\n- calculate_droid_earnings(5, 2) 返回 730。\n- calculate_droid_earnings(0, 10) 返回 -100。\n- calculate_droid_earnings(10, 5) 返回 950。",
      "fr": "Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées.\n  Deliv-e-droid gagne 50 unités d'argent pour chaque livraison réussie et perd 10 unités pour chaque livraison échouée.\n  De plus, si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\n  Arguments:\n  - delivered: Le nombre de colis livrés avec succès (0 <= delivered <= 100).\n  - failed: Le nombre de livraisons échouées (0 <= failed <= 100).\n\n  Retourne:\n  - Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\n  Exemples:\n  - calculate_droid_earnings(5, 2) retourne 730.\n  - calculate_droid_earnings(0, 10) retourne -100.\n  - calculate_droid_earnings(10, 5) retourne 950.",
      "de": "Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen.\n  Deliv-e-droid verdient 50 Geldeinheiten für jede erfolgreiche Lieferung und verliert 10 Einheiten für jede fehlgeschlagene Lieferung.\n  Zusätzlich erhält Deliv-e-droid einen Bonus von 500 Einheiten, wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen.\n\n  Argumente:\n  - delivered: Die Anzahl der erfolgreich zugestellten Pakete (0 <= delivered <= 100).\n  - failed: Die Anzahl der fehlgeschlagenen Lieferungen (0 <= failed <= 100).\n\n  Rückgabewerte:\n  - Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne übersteigen.\n\n  Beispiele:\n  - calculate_droid_earnings(5, 2) gibt 730 zurück.\n  - calculate_droid_earnings(0, 10) gibt -100 zurück.\n  - calculate_droid_earnings(10, 5) gibt 950 zurück.",
      "ha": "Lissafa jimillar kudaden shiga na Deliv-e-droid bisa ga adadin nasarorin da aka kai da kuma wadanda suka kasa.\n  Deliv-e-droid yana samun 50 raka'a na kudi don kowane nasarar da aka kai kuma yana rasa 10 raka'a don kowane rashin nasara.\n  Bugu da ƙari, idan adadin nasarorin da aka kai ya fi yawan wadanda suka kasa, Deliv-e-droid yana samun kari na 500 raka'a.\n\n  Huɗɗa:\n  - delivered: Adadin fakitin da aka kai nasara (0 <= delivered <= 100).\n  - failed: Adadin rashin nasarorin da aka yi (0 <= failed <= 100).\n\n  Dawowa:\n  - Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi riba.\n\n  Misalai:\n  - calculate_droid_earnings(5, 2) yana dawowa 730.\n  - calculate_droid_earnings(0, 10) yana dawowa -100.\n  - calculate_droid_earnings(10, 5) yana dawowa 950.",
      "hi": "Deliv-e-droid की कुल कमाई की गणना करता है जो सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या पर आधारित है। \nDeliv-e-droid प्रत्येक सफल डिलीवरी के लिए 50 इकाइयों की कमाई करता है और प्रत्येक असफल डिलीवरी के लिए 10 इकाइयाँ खोता है। \nअतिरिक्त रूप से, यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 इकाइयों का बोनस मिलता है।\n\nतर्क:\n- delivered: सफलतापूर्वक वितरित पैकेजों की संख्या (0 <= delivered <= 100)।\n- failed: असफल डिलीवरी की संख्या (0 <= failed <= 100)।\n\nवापसी:\n- Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\nउदाहरण:\n- calculate_droid_earnings(5, 2) 730 लौटाता है।\n- calculate_droid_earnings(0, 10) -100 लौटाता है।\n- calculate_droid_earnings(10, 5) 950 लौटाता है।",
      "hu": "Számítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján. \nA Deliv-e-droid 50 pénzegységet keres minden sikeres kézbesítésért, és 10 pénzegységet veszít minden sikertelen kézbesítésért. \nTovábbá, ha a sikeres kézbesítések száma meghaladja a sikertelenek számát, a Deliv-e-droid 500 egység bónuszt kap.\n\nÉrvek:\n- delivered: A sikeresen kézbesített csomagok száma (0 <= delivered <= 100).\n- failed: A sikertelen kézbesítések száma (0 <= failed <= 100).\n\nVisszatér:\n- A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereségeket.\n\nPéldák:\n- calculate_droid_earnings(5, 2) visszatér 730.\n- calculate_droid_earnings(0, 10) visszatér -100.\n- calculate_droid_earnings(10, 5) visszatér 950."
    },
    "docstring_bertscore": {
      "sq": "0.9711411905698222",
      "hy": "0.9753152093968893",
      "bn": "0.9801228591394577",
      "bg": "0.9924321824825708",
      "zh": "0.97534798340976",
      "fr": "0.9927680664569007",
      "de": "0.9752029832316046",
      "ha": "0.9762316899749842",
      "hi": "0.9745699482072464",
      "hu": "0.983392116580911"
    }
  },
  {
    "task_id": "Rust/52",
    "prompt": {
      "en": "/*\n  Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "sq": "/*\n  Gjen numrat e ID-ve që mungojnë dhe janë të dyfishuar nga një seri sekuencash ID.\n  Çdo sekuencë e ID-ve përfaqësohet si një vektor brenda një vektori më të madh, duke simuluar formatin e hyrjes të përshkruar.\n  ID-të supozohet të jenë pjesë e një vargu të vazhdueshëm por me një ID që mungon dhe një ID të dyfishuar.\n  Funksioni identifikon dhe kthen si ID-në që mungon (që është anashkaluar) ashtu edhe ID-në e dyfishuar (që shfaqet më shumë se një herë).\n\n  Argumentet:\n  - data: Një vektor vektorësh, ku çdo vektor i brendshëm përmban një sekuencë numrash ID.\n\n  Kthen:\n  - Një dyshe që përmban dy vlera usize: e para është ID-ja që mungon, dhe e dyta është ID-ja e dyfishuar.\n\n  Shembull:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) kthen (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "hy": "/*\n  Գտնում է բացակայող և կրկնվող ID համարները ID հաջորդականությունների շարքից:\n  ID-ների յուրաքանչյուր հաջորդականություն ներկայացված է որպես վեկտոր ավելի մեծ վեկտորի ներսում, որը նմանեցնում է նկարագրված մուտքային ձևաչափը:\n  Ենթադրվում է, որ ID-ները մաս են կազմում շարունակական միջակայքի, բայց մեկ բացակայող ID-ով և մեկ կրկնվող ID-ով:\n  Ֆունկցիան հայտնաբերում և վերադարձնում է ինչպես բացակայող ID-ն (որը բաց է թողնվել), այնպես էլ կրկնվող ID-ն (որը հայտնվում է մեկից ավելի անգամ):\n\n  Արգումենտներ:\n  - data: Վեկտոր վեկտորների, որտեղ յուրաքանչյուր ներքին վեկտոր պարունակում է ID համարների հաջորդականություն:\n\n  Վերադարձնում է:\n  - Զույգ, որը պարունակում է երկու usize արժեքներ. առաջինը բացակայող ID-ն է, իսկ երկրորդը կրկնվող ID-ն:\n\n  Օրինակ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) վերադարձնում է (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "bn": "/*\n  ID নম্বরগুলির একটি সিরিজ থেকে অনুপস্থিত এবং সদৃশ ID নম্বরগুলি খুঁজে বের করে।\n  IDগুলির প্রতিটি সিরিজ একটি বড় ভেক্টরের মধ্যে একটি ভেক্টর হিসাবে উপস্থাপিত হয়, বর্ণিত ইনপুট বিন্যাসকে অনুকরণ করে।\n  IDগুলি একটি ধারাবাহিক পরিসরের অংশ হিসাবে অনুমান করা হয় তবে একটি অনুপস্থিত ID এবং একটি সদৃশ ID সহ।\n  ফাংশনটি উভয় অনুপস্থিত ID (যা বাদ দেওয়া হয়েছে) এবং সদৃশ ID (যা একাধিকবার উপস্থিত হয়) সনাক্ত করে এবং ফেরত দেয়।\n\n  আর্গুমেন্ট:\n  - data: একটি ভেক্টরের ভেক্টর, যেখানে প্রতিটি অভ্যন্তরীণ ভেক্টর একটি ID নম্বরের সিরিজ ধারণ করে।\n\n  রিটার্নস:\n  - একটি টিউপল যা দুটি usize মান ধারণ করে: প্রথমটি অনুপস্থিত ID এবং দ্বিতীয়টি সদৃশ ID।\n\n  উদাহরণ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) ফেরত দেয়\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "bg": "/*\n  Намира липсващите и дублиращите се ID номера от серия от ID последователности.\n  Всяка последователност от ID-та е представена като вектор в по-голям вектор, симулирайки описания формат на входните данни.\n  Предполага се, че ID-тата са част от непрекъснат диапазон, но с едно липсващо ID и едно дублирано ID.\n  Функцията идентифицира и връща както липсващото ID (което е пропуснато), така и дублираното ID (което се появява повече от веднъж).\n\n  Аргументи:\n  - data: Вектор от вектори, където всеки вътрешен вектор съдържа последователност от ID номера.\n\n  Връща:\n  - Кортеж, съдържащ две стойности от тип usize: първата е липсващото ID, а втората е дублираното ID.\n\n  Пример:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) връща (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "zh": "/*\n  查找缺失和重复的ID号从一系列ID序列中。\n  每个ID序列被表示为一个更大向量中的一个向量，模拟所描述的输入格式。\n  假设这些ID是连续范围的一部分，但有一个缺失的ID和一个重复的ID。\n  该函数识别并返回缺失的ID（被跳过的）和重复的ID（出现多次的）。\n\n  参数:\n  - data: 一个向量的向量，其中每个内部向量包含一系列ID号。\n\n  返回:\n  - 一个包含两个usize值的元组：第一个是缺失的ID，第二个是重复的ID。\n\n  示例:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "fr": "/*\n  Trouve les numéros d'identification manquants et en double à partir d'une série de séquences d'identification.\n  Chaque séquence d'identifiants est représentée comme un vecteur dans un vecteur plus grand, simulant le format d'entrée décrit.\n  Les identifiants sont supposés faire partie d'une plage continue mais avec un identifiant manquant et un identifiant en double.\n  La fonction identifie et retourne à la fois l'identifiant manquant (qui a été sauté) et l'identifiant en double (qui apparaît plus d'une fois).\n\n  Arguments:\n  - data: Un vecteur de vecteurs, où chaque vecteur interne contient une séquence de numéros d'identification.\n\n  Retourne:\n  - Un tuple contenant deux valeurs usize : la première est l'identifiant manquant, et la seconde est l'identifiant en double.\n\n  Exemple:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "de": "/*\n  Findet die fehlenden und doppelten ID-Nummern aus einer Reihe von ID-Sequenzen.\n  Jede Sequenz von IDs wird als ein Vektor innerhalb eines größeren Vektors dargestellt, der das beschriebene Eingabeformat simuliert.\n  Es wird angenommen, dass die IDs Teil eines kontinuierlichen Bereichs sind, jedoch mit einer fehlenden ID und einer doppelten ID.\n  Die Funktion identifiziert und gibt sowohl die fehlende ID (die übersprungen wurde) als auch die doppelte ID (die mehr als einmal erscheint) zurück.\n\n  Argumente:\n  - data: Ein Vektor von Vektoren, wobei jeder innere Vektor eine Sequenz von ID-Nummern enthält.\n\n  Rückgabewerte:\n  - Ein Tupel, das zwei usize-Werte enthält: der erste ist die fehlende ID, und der zweite ist die doppelte ID.\n\n  Beispiel:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) gibt (7, 9) zurück\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "ha": "/*\n  Nemi lambobin ID da suka ɓace da kuma lambobin ID masu maimaitawa daga jerin lambobin ID.\n  Kowace jeri na lambobin ID ana wakilta ta a matsayin vector a cikin babban vector, yana kwaikwayon tsarin shigarwa da aka bayyana.\n  Ana ɗauka cewa lambobin ID suna cikin kewayon ci gaba amma tare da ID ɗaya da ya ɓace da kuma ID ɗaya mai maimaitawa.\n  Aikin yana gano kuma yana dawowa tare da ID ɗin da ya ɓace (wanda aka tsallake) da kuma ID ɗin da aka maimaita (wanda ya bayyana fiye da sau ɗaya).\n\n  Huɗɗa:\n  - data: Wani vector na vectors, inda kowane vector na ciki ke ɗauke da jerin lambobin ID.\n\n  Komawa:\n  - Wani tuple mai ɗauke da ƙimar usize biyu: na farko shine ID ɗin da ya ɓace, na biyu kuma shine ID ɗin da aka maimaita.\n\n  Misali:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "hi": "/*\n  ID संख्याओं की श्रृंखला से गायब और डुप्लिकेट ID नंबर खोजता है।\n  ID की प्रत्येक श्रृंखला को एक बड़े वेक्टर के भीतर एक वेक्टर के रूप में दर्शाया गया है, जैसा कि इनपुट प्रारूप में वर्णित है।\n  यह माना जाता है कि ID एक सतत श्रेणी का हिस्सा हैं लेकिन एक गायब ID और एक डुप्लिकेट ID के साथ।\n  फ़ंक्शन दोनों को पहचानता है और लौटाता है: गायब ID (जो छोड़ दी गई है) और डुप्लिकेट ID (जो एक से अधिक बार प्रकट होती है)।\n\n  तर्क:\n  - data: वेक्टर का एक वेक्टर, जहां प्रत्येक आंतरिक वेक्टर में ID संख्याओं की एक श्रृंखला होती है।\n\n  लौटाता है:\n  - एक युग्म जिसमें दो usize मान होते हैं: पहला गायब ID है, और दूसरा डुप्लिकेट ID है।\n\n  उदाहरण:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "hu": "/*\n  Megkeresi a hiányzó és duplikált azonosító számokat egy sorozat azonosítószámból.\n  Minden azonosítószám-sorozat egy vektorként van ábrázolva egy nagyobb vektoron belül, szimulálva a leírt bemeneti formátumot.\n  Feltételezzük, hogy az azonosítók egy folyamatos tartomány részét képezik, de egy hiányzó és egy duplikált azonosítóval.\n  A függvény azonosítja és visszaadja mind a hiányzó azonosítót (amelyet kihagytak), mind a duplikált azonosítót (amely többször is megjelenik).\n\n  Argumentumok:\n  - data: Egy vektor vektorokkal, ahol minden belső vektor egy azonosítószám-sorozatot tartalmaz.\n\n  Visszatér:\n  - Egy tuple, amely két usize értéket tartalmaz: az első a hiányzó azonosító, a második a duplikált azonosító.\n\n  Példa:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) visszaadja (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) "
    },
    "prompt_bertscore": {
      "sq": "0.9827624582730303",
      "hy": "0.9772347733992104",
      "bn": "0.974026694115116",
      "bg": "0.9771656500266103",
      "zh": "0.9618474736715807",
      "fr": "0.9741782490958456",
      "de": "0.9757571619946919",
      "ha": "0.9400078646464137",
      "hi": "0.967451035350956",
      "hu": "0.9622576454084177"
    },
    "canonical_solution": "{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}",
    "instruction": {
      "en": "Write a Rust function `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` to solve the following problem:\nFinds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "sq": "Shkruani një funksion Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` për të zgjidhur problemin e mëposhtëm:\nGjen numrat e ID-ve që mungojnë dhe janë të dyfishta nga një seri sekuencash ID.\n  Çdo sekuencë ID-sh përfaqësohet si një vektor brenda një vektori më të madh, duke simuluar formatin e hyrjes të përshkruar.\n  ID-të supozohet të jenë pjesë e një diapazoni të vazhdueshëm, por me një ID që mungon dhe një ID të dyfishtë.\n  Funksioni identifikon dhe kthen si ID-në që mungon (që është anashkaluar) ashtu edhe ID-në e dyfishtë (që shfaqet më shumë se një herë).\n\n  Argumentet:\n  - data: Një vektor vektorësh, ku çdo vektor i brendshëm përmban një sekuencë numrash ID.\n\n  Kthen:\n  - Një dyshe që përmban dy vlera usize: e para është ID-ja që mungon, dhe e dyta është ID-ja e dyfishtë.\n\n  Shembull:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) kthen (7, 9)",
      "hy": "Գրեք Rust ֆունկցիա `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բացակայող և կրկնվող ID համարները ID հաջորդականությունների շարքից:\n  ID-ների յուրաքանչյուր հաջորդականություն ներկայացված է որպես վեկտոր ավելի մեծ վեկտորի ներսում, որը նկարագրում է մուտքային ձևաչափը:\n  Ենթադրվում է, որ ID-ները շարունակական տիրույթի մաս են, բայց մեկ բացակայող ID-ով և մեկ կրկնվող ID-ով:\n  Ֆունկցիան հայտնաբերում և վերադարձնում է ինչպես բացակայող ID-ն (որը բաց է թողնվել), այնպես էլ կրկնվող ID-ն (որը հայտնվում է մեկից ավելի անգամ):\n\n  Փաստարկներ:\n  - data: Վեկտոր վեկտորների, որտեղ յուրաքանչյուր ներքին վեկտոր պարունակում է ID համարների հաջորդականություն:\n\n  Վերադարձնում է:\n  - Զույգ, որը պարունակում է երկու usize արժեքներ: առաջինը բացակայող ID-ն է, իսկ երկրորդը կրկնվող ID-ն:\n\n  Օրինակ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) վերադարձնում է (7, 9)",
      "bn": "Rust ফাংশন `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nID নম্বরের একটি সিরিজ থেকে অনুপস্থিত এবং সদৃশ ID নম্বরগুলি খুঁজে বের করে।\n  ID গুলির প্রতিটি সিরিজ একটি বৃহত্তর ভেক্টরের মধ্যে একটি ভেক্টর হিসাবে উপস্থাপিত হয়, বর্ণিত ইনপুট ফরম্যাটের অনুকরণ করে।\n  ID গুলি একটি ধারাবাহিক পরিসরের অংশ বলে মনে করা হয় কিন্তু একটি অনুপস্থিত ID এবং একটি সদৃশ ID সহ।\n  ফাংশনটি উভয় অনুপস্থিত ID (যা বাদ দেওয়া হয়েছে) এবং সদৃশ ID (যা একাধিকবার উপস্থিত হয়) সনাক্ত করে এবং ফেরত দেয়।\n\n  আর্গুমেন্ট:\n  - data: একটি ভেক্টরের ভেক্টর, যেখানে প্রতিটি অভ্যন্তরীণ ভেক্টর ID নম্বরের একটি সিরিজ ধারণ করে।\n\n  রিটার্নস:\n  - একটি টিউপল যা দুটি usize মান ধারণ করে: প্রথমটি অনুপস্থিত ID এবং দ্বিতীয়টি সদৃশ ID।\n\n  উদাহরণ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) ফেরত দেয়।",
      "bg": "Напишете функция на Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)`, за да решите следния проблем:\nНамира липсващите и дублиращите се ID номера от серия от ID последователности.\n  Всяка последователност от ID-та е представена като вектор в по-голям вектор, симулиращ описания формат на входа.\n  Предполага се, че ID-тата са част от непрекъснат диапазон, но с едно липсващо ID и едно дублирано ID.\n  Функцията идентифицира и връща както липсващото ID (което е пропуснато), така и дублираното ID (което се появява повече от веднъж).\n\n  Аргументи:\n  - data: Вектор от вектори, където всеки вътрешен вектор съдържа последователност от ID номера.\n\n  Връща:\n  - Кортеж, съдържащ две стойности от тип usize: първата е липсващото ID, а втората е дублираното ID.\n\n  Пример:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) връща (7, 9)",
      "zh": "编写一个 Rust 函数 `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` 来解决以下问题：\n找出一系列 ID 序列中缺失和重复的 ID 号码。\n每个 ID 序列表示为一个更大向量中的一个向量，模拟所描述的输入格式。\n假设这些 ID 是一个连续范围的一部分，但有一个缺失的 ID 和一个重复的 ID。\n该函数识别并返回缺失的 ID（被跳过的）和重复的 ID（出现多次的）。\n\n参数：\n- data: 一个向量的向量，其中每个内部向量包含一系列 ID 号码。\n\n返回：\n- 一个包含两个 usize 值的元组：第一个是缺失的 ID，第二个是重复的 ID。\n\n示例：\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) 返回 (7, 9)",
      "fr": "Écrire une fonction Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` pour résoudre le problème suivant :\nTrouve les numéros d'identification manquants et en double à partir d'une série de séquences d'identification.\n  Chaque séquence d'identifiants est représentée comme un vecteur à l'intérieur d'un vecteur plus grand, simulant le format d'entrée décrit.\n  Les identifiants sont supposés faire partie d'une plage continue mais avec un identifiant manquant et un identifiant en double.\n  La fonction identifie et retourne à la fois l'identifiant manquant (qui a été sauté) et l'identifiant en double (qui apparaît plus d'une fois).\n\n  Arguments :\n  - data : Un vecteur de vecteurs, où chaque vecteur interne contient une séquence de numéros d'identification.\n\n  Renvoie :\n  - Un tuple contenant deux valeurs usize : la première est l'identifiant manquant, et la seconde est l'identifiant en double.\n\n  Exemple :\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) renvoie (7, 9)",
      "de": "Schreiben Sie eine Rust-Funktion `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)`, um das folgende Problem zu lösen:\nFindet die fehlenden und doppelten ID-Nummern aus einer Reihe von ID-Sequenzen.\n  Jede Sequenz von IDs wird als Vektor innerhalb eines größeren Vektors dargestellt, der das beschriebene Eingabeformat simuliert.\n  Es wird angenommen, dass die IDs Teil eines kontinuierlichen Bereichs sind, jedoch mit einer fehlenden ID und einer doppelten ID.\n  Die Funktion identifiziert und gibt sowohl die fehlende ID (die übersprungen wurde) als auch die doppelte ID (die mehr als einmal erscheint) zurück.\n\n  Argumente:\n  - data: Ein Vektor von Vektoren, wobei jeder innere Vektor eine Sequenz von ID-Nummern enthält.\n\n  Rückgabewerte:\n  - Ein Tupel, das zwei usize-Werte enthält: der erste ist die fehlende ID, und der zweite ist die doppelte ID.\n\n  Beispiel:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) gibt (7, 9) zurück.",
      "ha": "Rubuta aikin Rust `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` don warware matsalar mai zuwa:\nNemo lambobin ID da suka ɓace da kuma lambobin ID masu maimaitawa daga jerin lambobin ID.\n  Kowace jerin lambobin ID an wakilta ta hanyar vector a cikin babban vector, yana kwaikwayon tsarin shigarwa da aka bayyana.\n  Ana ɗauka cewa lambobin ID suna cikin kewayon ci gaba amma tare da ID ɗaya da ya ɓace da kuma ID ɗaya da ya maimaita.\n  Aikin yana gano kuma yana dawowa duka ID ɗin da ya ɓace (wanda aka tsallake) da ID ɗin da ya maimaita (wanda ya bayyana fiye da sau ɗaya).\n\n  Huɗɗa:\n  - data: Vector na vectors, inda kowace vector ta ciki ta ƙunshi jerin lambobin ID.\n\n  Dawowa:\n  - Tuple mai ɗauke da ƙimomi biyu na usize: na farko shine ID ɗin da ya ɓace, na biyu shine ID ɗin da ya maimaita.\n\n  Misali:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "hi": "Rust फ़ंक्शन `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nID संख्याओं की श्रृंखलाओं से गायब और डुप्लिकेट ID नंबर खोजें।\n  ID की प्रत्येक श्रृंखला को एक बड़े वेक्टर के भीतर एक वेक्टर के रूप में दर्शाया गया है, जो वर्णित इनपुट प्रारूप का अनुकरण करता है।\n  ID को एक निरंतर श्रेणी का हिस्सा माना जाता है लेकिन एक गायब ID और एक डुप्लिकेट ID के साथ।\n  फ़ंक्शन दोनों गायब ID (जो छोड़ी गई है) और डुप्लिकेट ID (जो एक से अधिक बार प्रकट होती है) की पहचान करता है और लौटाता है।\n\n  तर्क:\n  - data: वेक्टर का एक वेक्टर, जहाँ प्रत्येक आंतरिक वेक्टर में ID संख्याओं की एक श्रृंखला होती है।\n\n  लौटाता है:\n  - एक टपल जिसमें दो usize मान होते हैं: पहला गायब ID है, और दूसरा डुप्लिकेट ID है।\n\n  उदाहरण:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) लौटाता है।",
      "hu": "Írj egy Rust függvényt `fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)` a következő probléma megoldására:\nMegkeresi a hiányzó és duplikált azonosító számokat egy sorozat azonosító sorozatból.\n  Minden azonosító sorozat egy vektorként van ábrázolva egy nagyobb vektoron belül, szimulálva a leírt bemeneti formátumot.\n  Feltételezzük, hogy az azonosítók egy folytonos tartomány részét képezik, de egy hiányzó azonosítóval és egy duplikált azonosítóval.\n  A függvény azonosítja és visszaadja mind a hiányzó azonosítót (amely kimaradt), mind a duplikált azonosítót (amely többször szerepel).\n\n  Argumentumok:\n  - data: Egy vektor vektorokkal, ahol minden belső vektor egy azonosító számok sorozatát tartalmazza.\n\n  Visszatérési érték:\n  - Egy tuple, amely két usize értéket tartalmaz: az első a hiányzó azonosító, a második a duplikált azonosító.\n\n  Példa:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) visszaadja (7, 9)"
    },
    "instruction_bertscore": {
      "sq": "0.9847791525316776",
      "hy": "0.9775458285759111",
      "bn": "0.9648875116533198",
      "bg": "0.9776501095259544",
      "zh": "0.9621783918863849",
      "fr": "0.9749556884072161",
      "de": "0.9791136181734195",
      "ha": "0.9489897318464303",
      "hi": "0.9658371635050476",
      "hu": "0.9815782239413003"
    },
    "level": "middle",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]), (7, 9));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 2, 4, 7], vec![5, 3, 3]]), (6, 3));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 1, 3, 4, 5]]), (2, 1)); // Edge case with minimal input\n    \n    }\n    \n\n}",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)",
    "docstring": {
      "en": "Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "sq": "Gjen numrat e ID-ve që mungojnë dhe janë të dyfishuar nga një seri sekuencash ID-sh.\n  Çdo sekuencë ID-sh përfaqësohet si një vektor brenda një vektori më të madh, duke simuluar formatin e hyrjes të përshkruar.\n  ID-të supozohet të jenë pjesë e një diapazoni të vazhdueshëm, por me një ID që mungon dhe një ID të dyfishuar.\n  Funksioni identifikon dhe kthen si ID-në që mungon (që është anashkaluar) ashtu edhe ID-në e dyfishuar (që shfaqet më shumë se një herë).\n\n  Argumentet:\n  - data: Një vektor vektorësh, ku çdo vektor i brendshëm përmban një sekuencë numrash ID.\n\n  Kthen:\n  - Një dyshe që përmban dy vlera usize: e para është ID-ja që mungon, dhe e dyta është ID-ja e dyfishuar.\n\n  Shembull:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) kthen (7, 9)",
      "hy": "Գտնում է բացակայող և կրկնվող ID համարները ID հաջորդականությունների շարքից:\n  ID-ների յուրաքանչյուր հաջորդականություն ներկայացված է որպես վեկտոր ավելի մեծ վեկտորի ներսում, մուտքի ձևաչափը նկարագրված է:\n  Ենթադրվում է, որ ID-ները շարունակական տիրույթի մաս են կազմում, բայց մեկ բացակայող ID-ով և մեկ կրկնվող ID-ով:\n  Ֆունկցիան հայտնաբերում և վերադարձնում է ինչպես բացակայող ID-ն (որը բաց է թողնվել), այնպես էլ կրկնվող ID-ն (որը հայտնվում է մեկից ավելի անգամ):\n\n  Արգումենտներ:\n  - data: Վեկտոր վեկտորների, որտեղ յուրաքանչյուր ներքին վեկտոր պարունակում է ID համարների հաջորդականություն:\n\n  Վերադարձնում է.\n  - Զույգ, որը պարունակում է երկու usize արժեքներ. առաջինը բացակայող ID-ն է, իսկ երկրորդը կրկնվող ID-ն է:\n\n  Օրինակ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) վերադարձնում է (7, 9)",
      "bn": "অনুপস্থিত এবং সদৃশ আইডি নম্বরগুলি একটি আইডি সিকোয়েন্সের সিরিজ থেকে খুঁজে বের করে। \nপ্রতিটি আইডি সিকোয়েন্স একটি বড় ভেক্টরের মধ্যে একটি ভেক্টর হিসাবে উপস্থাপিত হয়, বর্ণিত ইনপুট ফর্ম্যাটকে অনুকরণ করে। \nআইডিগুলি একটি ধারাবাহিক পরিসরের অংশ হিসেবে বিবেচিত হয় তবে একটি অনুপস্থিত আইডি এবং একটি সদৃশ আইডি সহ। \nফাংশনটি উভয় অনুপস্থিত আইডি (যা বাদ দেওয়া হয়েছে) এবং সদৃশ আইডি (যা একাধিকবার উপস্থিত হয়) সনাক্ত করে এবং ফেরত দেয়।\n\nআর্গুমেন্টস:\n- data: একটি ভেক্টরের ভেক্টর, যেখানে প্রতিটি অভ্যন্তরীণ ভেক্টর একটি আইডি নম্বরের সিকোয়েন্স ধারণ করে।\n\nরিটার্নস:\n- একটি টিউপল যা দুটি usize মান ধারণ করে: প্রথমটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n\nউদাহরণ:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "bg": "Намира липсващите и дублиращите се ID номера от поредица ID последователности.\n  Всяка последователност от ID-та е представена като вектор в по-голям вектор, симулирайки описания формат на входа.\n  Предполага се, че ID-тата са част от непрекъснат диапазон, но с едно липсващо ID и едно дублирано ID.\n  Функцията идентифицира и връща както липсващото ID (което е пропуснато), така и дублираното ID (което се появява повече от веднъж).\n\n  Аргументи:\n  - data: Вектор от вектори, където всеки вътрешен вектор съдържа последователност от ID номера.\n\n  Връща:\n  - Кортеж, съдържащ две стойности от тип usize: първата е липсващото ID, а втората е дублираното ID.\n\n  Пример:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) връща (7, 9)",
      "zh": "查找一系列ID序列中缺失和重复的ID号。\n每个ID序列表示为一个较大向量中的向量，模拟所描述的输入格式。\n假设这些ID是一个连续范围的一部分，但其中有一个缺失的ID和一个重复的ID。\n该函数识别并返回缺失的ID（被跳过的）和重复的ID（出现多次的）。\n\n参数:\n- data: 一个向量的向量，其中每个内部向量包含一系列ID号。\n\n返回:\n- 一个包含两个usize值的元组：第一个是缺失的ID，第二个是重复的ID。\n\n示例:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) 返回 (7, 9)",
      "fr": "Trouve les numéros d'identification manquants et en double à partir d'une série de séquences d'ID.\n  Chaque séquence d'ID est représentée comme un vecteur à l'intérieur d'un vecteur plus grand, simulant le format d'entrée décrit.\n  Les ID sont supposés faire partie d'une plage continue mais avec un ID manquant et un ID en double.\n  La fonction identifie et renvoie à la fois l'ID manquant (qui a été sauté) et l'ID en double (qui apparaît plus d'une fois).\n\n  Arguments:\n  - data: Un vecteur de vecteurs, où chaque vecteur interne contient une séquence de numéros d'identification.\n\n  Renvoie:\n  - Un tuple contenant deux valeurs usize : la première est l'ID manquant, et la seconde est l'ID en double.\n\n  Exemple:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "de": "Findet die fehlenden und doppelten ID-Nummern aus einer Reihe von ID-Sequenzen.\n  Jede Sequenz von IDs wird als Vektor innerhalb eines größeren Vektors dargestellt, was das beschriebene Eingabeformat simuliert.\n  Es wird angenommen, dass die IDs Teil eines kontinuierlichen Bereichs sind, jedoch mit einer fehlenden ID und einer doppelten ID.\n  Die Funktion identifiziert und gibt sowohl die fehlende ID (die übersprungen wurde) als auch die doppelte ID (die mehr als einmal erscheint) zurück.\n\n  Argumente:\n  - data: Ein Vektor von Vektoren, wobei jeder innere Vektor eine Sequenz von ID-Nummern enthält.\n\n  Rückgabewerte:\n  - Ein Tupel, das zwei usize-Werte enthält: der erste ist die fehlende ID, und der zweite ist die doppelte ID.\n\n  Beispiel:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) gibt (7, 9) zurück.",
      "ha": "Yana gano lambobin ID da suka ɓace da kuma lambobin ID masu maimaitawa daga jerin lambobin ID.\n  Kowace jerin lambobin ID ana wakilta ta hanyar vector a cikin babban vector, yana kwaikwayon tsarin shigarwa da aka bayyana.\n  Ana ɗaukar lambobin ID a matsayin wani ɓangare na kewayon ci gaba amma tare da ID ɗaya da ya ɓace da kuma ID ɗaya da aka maimaita.\n  Ayyukan yana gano kuma yana dawowa duka ID ɗin da ya ɓace (wanda aka tsallake) da ID ɗin da aka maimaita (wanda ya bayyana fiye da sau ɗaya).\n\n  Huɗa:\n  - data: Wani vector na vectors, inda kowanne vector na ciki ya ƙunshi jerin lambobin ID.\n\n  Dawowa:\n  - Wani tuple mai ɗauke da ƙimomin usize guda biyu: na farko shine ID ɗin da ya ɓace, na biyu kuma shine ID ɗin da aka maimaita.\n\n  Misali:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "hi": "लापता और डुप्लिकेट आईडी नंबरों को आईडी अनुक्रमों की एक श्रृंखला से खोजता है।\n  आईडी का प्रत्येक अनुक्रम एक बड़े वेक्टर के भीतर एक वेक्टर के रूप में दर्शाया गया है, जो वर्णित इनपुट प्रारूप का अनुकरण करता है।\n  आईडी को एक सतत श्रेणी का हिस्सा माना जाता है लेकिन एक लापता आईडी और एक डुप्लिकेट आईडी के साथ।\n  फ़ंक्शन दोनों लापता आईडी (जो छोड़ दी गई है) और डुप्लिकेट आईडी (जो एक से अधिक बार प्रकट होती है) की पहचान करता है और लौटाता है।\n\n  तर्क:\n  - data: वेक्टर का एक वेक्टर, जहाँ प्रत्येक आंतरिक वेक्टर में आईडी नंबरों का एक अनुक्रम होता है।\n\n  रिटर्न:\n  - एक युग्म जिसमें दो usize मान होते हैं: पहला लापता आईडी है, और दूसरा डुप्लिकेट आईडी है।\n\n  उदाहरण:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "hu": "Megkeresi a hiányzó és duplikált azonosító számokat egy azonosítósorozatokból álló sorozatból.\n  Minden azonosítósorozat egy nagyobb vektoron belüli vektorként van ábrázolva, szimulálva a leírt bemeneti formátumot.\n  Feltételezzük, hogy az azonosítók egy folyamatos tartomány részét képezik, de egy hiányzó és egy duplikált azonosítóval.\n  A függvény azonosítja és visszaadja mind a hiányzó azonosítót (amelyet kihagytak), mind a duplikált azonosítót (amely többször is megjelenik).\n\n  Argumentumok:\n  - data: Vektorok vektora, ahol minden belső vektor egy azonosítószámokból álló sorozatot tartalmaz.\n\n  Visszatérési érték:\n  - Egy tuple, amely két usize értéket tartalmaz: az első a hiányzó azonosító, a második a duplikált azonosító.\n\n  Példa:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) visszaadja (7, 9)"
    },
    "docstring_bertscore": {
      "sq": "0.978530638005082",
      "hy": "0.9662578626520794",
      "bn": "0.960624903676311",
      "bg": "0.9762493680788964",
      "zh": "0.9523644620202131",
      "fr": "0.9799713041587281",
      "de": "0.9847142003970791",
      "ha": "0.9335166237941936",
      "hi": "0.9704348609348621",
      "hu": "0.9620353780120398"
    }
  },
  {
    "task_id": "Rust/53",
    "prompt": {
      "en": "/*\n  Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "sq": "/*\n  Numëron numrin e karaktereve shifrore, shkronjave të vogla, dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n  \n  Argumentet:\n  - s: Një varg me saktësisht 8 karaktere që mund të përfshijë shifra, shkronja të vogla, dhe shkronja të mëdha.\n\n  Kthen:\n  - Një tuple që përmban tre vlera usize: numri i karaktereve shifrore, numri i shkronjave të vogla, dhe numri i shkronjave të mëdha në varg.\n\n  Shembuj:\n  - count_chars_types(\"yLOI2022\") kthen (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") kthen (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") kthen (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "hy": "/*\n  Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողի մեջ:\n  \n  Արգումենտներ:\n  - s: Ճիշտ 8 նիշից բաղկացած տող, որը կարող է ներառել թվանշաններ, փոքրատառեր և մեծատառեր:\n\n  Վերադարձնում է:\n  - Տրիա, որը պարունակում է երեք usize արժեքներ՝ թվանշանների քանակը, փոքրատառերի քանակը և մեծատառերի քանակը տողի մեջ:\n\n  Օրինակներ:\n  - count_chars_types(\"yLOI2022\") վերադարձնում է (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") վերադարձնում է (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") վերադարձնում է (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "bn": "/*\n  একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা অক্ষর, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - s: একটি স্ট্রিং যা ঠিক ৮ অক্ষরের এবং এতে সংখ্যা অক্ষর, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর থাকতে পারে।\n\n  রিটার্ন করে:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে: স্ট্রিং-এ সংখ্যা অক্ষরের সংখ্যা, ছোট হাতের অক্ষরের সংখ্যা, এবং বড় হাতের অক্ষরের সংখ্যা।\n\n  উদাহরণসমূহ:\n  - count_chars_types(\"yLOI2022\") রিটার্ন করে (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") রিটার্ন করে (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") রিটার্ন করে (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "bg": "/*\n  Брои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n  \n  Аргументи:\n  - s: Низ с точно 8 символа, който може да включва цифри, малки букви и главни букви.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize: броят на цифрите, броят на малките букви и броят на главните букви в низа.\n\n  Примери:\n  - count_chars_types(\"yLOI2022\") връща (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") връща (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") връща (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "zh": "/*\n  统计给定长度为8的字符串中的数字字符、小写字母和大写字母的数量。\n  \n  参数:\n  - s: 一个恰好包含8个字符的字符串，可能包括数字字符、小写字母和大写字母。\n\n  返回:\n  - 一个包含三个usize值的元组：字符串中数字字符的数量、小写字母的数量和大写字母的数量。\n\n  示例:\n  - count_chars_types(\"yLOI2022\") 返回 (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") 返回 (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") 返回 (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "fr": "/*\n  Compte le nombre de caractères numériques, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n  \n  Arguments:\n  - s: Une chaîne de exactement 8 caractères qui peut inclure des chiffres, des lettres minuscules et des lettres majuscules.\n\n  Returns:\n  - Un tuple contenant trois valeurs usize : le nombre de caractères numériques, le nombre de lettres minuscules et le nombre de lettres majuscules dans la chaîne.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "de": "/*\n  Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n  \n  Argumente:\n  - s: Ein String mit genau 8 Zeichen, der Ziffern, Kleinbuchstaben und Großbuchstaben enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält: die Anzahl der Ziffern, die Anzahl der Kleinbuchstaben und die Anzahl der Großbuchstaben im String.\n\n  Beispiele:\n  - count_chars_types(\"yLOI2022\") gibt (4, 1, 3) zurück\n  - count_chars_types(\"IAKIOIOI\") gibt (0, 0, 8) zurück\n  - count_chars_types(\"1n2s0e1s\") gibt (4, 4, 0) zurück\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "ha": "/*\n  Yana ƙidaya adadin haruffan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu mai tsawon haruffa 8.\n\n  Huɗɗa:\n  - s: Wani igiyar rubutu na haruffa 8 daidai wanda zai iya haɗawa da lambobi, ƙananan haruffa, da manyan haruffa.\n\n  Komawa:\n  - Wani tuple mai ɗauke da ƙimomi uku na usize: adadin haruffan lambobi, adadin ƙananan haruffa, da adadin manyan haruffa a cikin igiyar rubutu.\n\n  Misalai:\n  - count_chars_types(\"yLOI2022\") yana dawowa (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") yana dawowa (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") yana dawowa (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "hi": "/*\n  एक दिए गए 8 वर्णों की लंबाई वाले स्ट्रिंग में अंक वर्णों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n\n  तर्क:\n  - s: एक स्ट्रिंग जो ठीक 8 वर्णों की होती है और जिसमें अंक, छोटे अक्षर, और बड़े अक्षर शामिल हो सकते हैं।\n\n  लौटाता है:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं: स्ट्रिंग में अंक वर्णों की गिनती, छोटे अक्षरों की गिनती, और बड़े अक्षरों की गिनती।\n\n  उदाहरण:\n  - count_chars_types(\"yLOI2022\") लौटाता है (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") लौटाता है (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") लौटाता है (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "hu": "/*\n  Megszámolja a számjegy karakterek, kisbetűk és nagybetűk számát egy adott, 8 karakter hosszú sztringben.\n  \n  Argumentumok:\n  - s: Egy pontosan 8 karakter hosszú sztring, amely számjegyeket, kisbetűket és nagybetűket tartalmazhat.\n\n  Visszatér:\n  - Egy hármas, amely három usize értéket tartalmaz: a számjegy karakterek számát, a kisbetűk számát és a nagybetűk számát a sztringben.\n\n  Példák:\n  - count_chars_types(\"yLOI2022\") visszaadja (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") visszaadja (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") visszaadja (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) "
    },
    "prompt_bertscore": {
      "sq": "0.9901358166474264",
      "hy": "0.9752601887813426",
      "bn": "0.9701420797532166",
      "bg": "0.9830532531508654",
      "zh": "0.9740825092521868",
      "fr": "0.9848542348157088",
      "de": "0.9802116469197802",
      "ha": "0.9792983444277819",
      "hi": "0.988995280999524",
      "hu": "0.9761689227745772"
    },
    "canonical_solution": "{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}",
    "instruction": {
      "en": "Write a Rust function `fn count_chars_types(s: &str) -> (usize, usize, usize)` to solve the following problem:\nCounts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "sq": "Shkruani një funksion Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e karaktereve shifrore, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\nArgumentet:\n- s: Një varg me saktësisht 8 karaktere që mund të përfshijë shifra, shkronja të vogla dhe shkronja të mëdha.\n\nKthen:\n- Një tuple që përmban tre vlera usize: numri i karaktereve shifrore, numri i shkronjave të vogla dhe numri i shkronjave të mëdha në varg.\n\nShembuj:\n- count_chars_types(\"yLOI2022\") kthen (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") kthen (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") kthen (4, 4, 0)",
      "hy": "Գրեք Rust ֆունկցիա `fn count_chars_types(s: &str) -> (usize, usize, usize)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարության տողում։\n  \n  Փոփոխականներ:\n  - s: Ճիշտ 8 նիշից բաղկացած տող, որը կարող է պարունակել թվանշաններ, փոքրատառեր և մեծատառեր։\n\n  Վերադարձնում է:\n  - Թվային երեք usize արժեքներից բաղկացած կորտեժ՝ թվանշանների քանակը, փոքրատառերի քանակը և մեծատառերի քանակը տողի մեջ։\n\n  Օրինակներ:\n  - count_chars_types(\"yLOI2022\") վերադարձնում է (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") վերադարձնում է (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") վերադարձնում է (4, 4, 0)",
      "bn": "Rust ফাংশন `fn count_chars_types(s: &str) -> (usize, usize, usize)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত 8 অক্ষরের দৈর্ঘ্যের স্ট্রিং-এ সংখ্যা অক্ষর, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n\nআর্গুমেন্টসমূহ:\n- s: একটি স্ট্রিং যা ঠিক 8 অক্ষরের এবং এতে সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর থাকতে পারে।\n\nরিটার্নস:\n- একটি টিউপল যা তিনটি usize মান ধারণ করে: স্ট্রিং-এ সংখ্যা অক্ষরের সংখ্যা, ছোট হাতের অক্ষরের সংখ্যা, এবং বড় হাতের অক্ষরের সংখ্যা।\n\nউদাহরণসমূহ:\n- count_chars_types(\"yLOI2022\") রিটার্ন করে (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") রিটার্ন করে (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") রিটার্ন করে (4, 4, 0)",
      "bg": "Напишете функция на Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)`, за да решите следния проблем:\nБрои броя на цифровите символи, малките букви и главните букви в даден низ с дължина 8.\n  \n  Аргументи:\n  - s: Низ от точно 8 символа, който може да включва цифри, малки букви и главни букви.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize: броя на цифровите символи, броя на малките букви и броя на главните букви в низа.\n\n  Примери:\n  - count_chars_types(\"yLOI2022\") връща (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") връща (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") връща (4, 4, 0)",
      "zh": "编写一个 Rust 函数 `fn count_chars_types(s: &str) -> (usize, usize, usize)` 来解决以下问题：\n计算给定长度为 8 的字符串中数字字符、小写字母和大写字母的数量。\n\n参数：\n- s: 一个正好包含 8 个字符的字符串，可能包括数字、小写字母和大写字母。\n\n返回：\n- 一个包含三个 usize 值的元组：字符串中数字字符的数量、小写字母的数量和大写字母的数量。\n\n示例：\n- count_chars_types(\"yLOI2022\") 返回 (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") 返回 (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") 返回 (4, 4, 0)",
      "fr": "Écrire une fonction Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` pour résoudre le problème suivant :\nCompte le nombre de caractères chiffres, de lettres minuscules, et de lettres majuscules dans une chaîne de caractères donnée de longueur 8.\n  \n  Arguments :\n  - s : Une chaîne de caractères de exactement 8 caractères qui peut inclure des chiffres, des lettres minuscules, et des lettres majuscules.\n\n  Renvoie :\n  - Un tuple contenant trois valeurs usize : le compte des caractères chiffres, le compte des lettres minuscules, et le compte des lettres majuscules dans la chaîne.\n\n  Exemples :\n  - count_chars_types(\"yLOI2022\") renvoie (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") renvoie (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") renvoie (4, 4, 0)",
      "de": "Schreiben Sie eine Rust-Funktion `fn count_chars_types(s: &str) -> (usize, usize, usize)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n\n  Argumente:\n  - s: Ein String mit genau 8 Zeichen, der Ziffern, Kleinbuchstaben und Großbuchstaben enthalten kann.\n\n  Rückgabewert:\n  - Ein Tupel, das drei usize-Werte enthält: die Anzahl der Ziffern, die Anzahl der Kleinbuchstaben und die Anzahl der Großbuchstaben im String.\n\n  Beispiele:\n  - count_chars_types(\"yLOI2022\") gibt (4, 1, 3) zurück\n  - count_chars_types(\"IAKIOIOI\") gibt (0, 0, 8) zurück\n  - count_chars_types(\"1n2s0e1s\") gibt (4, 4, 0) zurück",
      "ha": "Rubuta aikin Rust `fn count_chars_types(s: &str) -> (usize, usize, usize)` don warware matsalar mai zuwa:\nƘididdige adadin haruffan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu mai tsawon haruffa 8.\n\n  Huɗɗa:\n  - s: Wani igiyar rubutu na ainihin haruffa 8 wanda zai iya haɗawa da lambobi, ƙananan haruffa, da manyan haruffa.\n\n  Dawowa:\n  - Wani tuple mai ɗauke da ƙimar uku na usize: adadin haruffan lambobi, adadin ƙananan haruffa, da adadin manyan haruffa a cikin igiyar rubutu.\n\n  Misalai:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "hi": "Rust फ़ंक्शन `fn count_chars_types(s: &str) -> (usize, usize, usize)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए 8 अक्षरों की लंबाई वाले स्ट्रिंग में अंक वर्णों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनें।\n\n  तर्क:\n  - s: ठीक 8 वर्णों वाला एक स्ट्रिंग जिसमें अंक, छोटे अक्षर, और बड़े अक्षर शामिल हो सकते हैं।\n\n  प्रत्यावर्तन:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं: स्ट्रिंग में अंक वर्णों की गिनती, छोटे अक्षरों की गिनती, और बड़े अक्षरों की गिनती।\n\n  उदाहरण:\n  - count_chars_types(\"yLOI2022\") (4, 1, 3) लौटाता है\n  - count_chars_types(\"IAKIOIOI\") (0, 0, 8) लौटाता है\n  - count_chars_types(\"1n2s0e1s\") (4, 4, 0) लौटाता है",
      "hu": "Írj egy Rust függvényt `fn count_chars_types(s: &str) -> (usize, usize, usize)` a következő probléma megoldására:\nSzámolja meg a számjegy karakterek, kisbetűk és nagybetűk számát egy adott, 8 hosszúságú sztringben.\n  \n  Argumentumok:\n  - s: Egy pontosan 8 karakter hosszú sztring, amely tartalmazhat számjegyeket, kisbetűket és nagybetűket.\n\n  Visszatérési érték:\n  - Egy hármas, amely három usize értéket tartalmaz: a számjegy karakterek száma, a kisbetűk száma és a nagybetűk száma a sztringben.\n\n  Példák:\n  - count_chars_types(\"yLOI2022\") visszatér (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") visszatér (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") visszatér (4, 4, 0)"
    },
    "instruction_bertscore": {
      "sq": "0.9892467470619143",
      "hy": "0.9695263255720085",
      "bn": "0.9744005164922236",
      "bg": "0.9701889565231409",
      "zh": "0.9738149541289327",
      "fr": "0.9954515629046821",
      "de": "0.9803997498906203",
      "ha": "0.9764372724193554",
      "hi": "0.9845862824316927",
      "hu": "0.9856737837678586"
    },
    "level": "easy",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_chars_types(\"yLOI2022\"), (4, 1, 3));\n        assert_eq!(count_chars_types(\"IAKIOIOI\"), (0, 0, 8));\n        assert_eq!(count_chars_types(\"1n2s0e1s\"), (4, 4, 0));\n    }\n    \n\n}",
    "entry_point": "count_chars_types",
    "signature": "fn count_chars_types(s: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "sq": "Numëron numrin e karaktereve shifrore, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\nArguments:\n- s: Një varg me saktësisht 8 karaktere që mund të përfshijë shifra, shkronja të vogla dhe shkronja të mëdha.\n\nReturns:\n- Një tuple që përmban tre vlera usize: numri i karaktereve shifrore, numri i shkronjave të vogla dhe numri i shkronjave të mëdha në varg.\n\nExamples:\n- count_chars_types(\"yLOI2022\") kthen (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") kthen (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") kthen (4, 4, 0)",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 նիշ երկարությամբ տողում:\n\n  Արգումենտներ:\n  - s: Ճիշտ 8 նիշ երկարությամբ տող, որը կարող է ներառել թվանշաններ, փոքրատառեր և մեծատառեր:\n\n  Վերադարձնում է:\n  - Եռյակ, որը պարունակում է երեք usize արժեքներ՝ թվանշանների քանակը, փոքրատառերի քանակը և մեծատառերի քանակը տողում:\n\n  Օրինակներ:\n  - count_chars_types(\"yLOI2022\") վերադարձնում է (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") վերադարձնում է (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") վերադարձնում է (4, 4, 0)",
      "bn": "একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা অক্ষর, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n\n  যুক্তি:\n  - s: একটি স্ট্রিং যা ঠিক 8 অক্ষরের এবং এতে সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে: সংখ্যার অক্ষরের সংখ্যা, ছোট হাতের অক্ষরের সংখ্যা, এবং বড় হাতের অক্ষরের সংখ্যা স্ট্রিংয়ে।\n\n  উদাহরণ:\n  - count_chars_types(\"yLOI2022\") রিটার্ন করে (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") রিটার্ন করে (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") রিটার্ন করে (4, 4, 0)",
      "bg": "Брои броя на цифровите символи, малките букви и главните букви в даден низ с дължина 8.\n\n  Аргументи:\n  - s: Низ с точно 8 символа, който може да включва цифри, малки букви и главни букви.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize: броя на цифровите символи, броя на малките букви и броя на главните букви в низа.\n\n  Примери:\n  - count_chars_types(\"yLOI2022\") връща (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") връща (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") връща (4, 4, 0)",
      "zh": "计算给定长度为8的字符串中数字字符、小写字母和大写字母的数量。\n\n  参数:\n  - s: 一个正好包含8个字符的字符串，可能包括数字、小写字母和大写字母。\n\n  返回:\n  - 一个包含三个usize值的元组：字符串中数字字符的数量、小写字母的数量和大写字母的数量。\n\n  示例:\n  - count_chars_types(\"yLOI2022\") 返回 (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") 返回 (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") 返回 (4, 4, 0)",
      "fr": "Compte le nombre de caractères numériques, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n\n  Arguments:\n  - s: Une chaîne de exactement 8 caractères qui peut inclure des chiffres, des lettres minuscules et des lettres majuscules.\n\n  Retourne:\n  - Un tuple contenant trois valeurs usize : le nombre de caractères numériques, le nombre de lettres minuscules et le nombre de lettres majuscules dans la chaîne.\n\n  Exemples:\n  - count_chars_types(\"yLOI2022\") retourne (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") retourne (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") retourne (4, 4, 0)",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n\n  Argumente:\n  - s: Ein String mit genau 8 Zeichen, der Ziffern, Kleinbuchstaben und Großbuchstaben enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält: die Anzahl der Ziffern, die Anzahl der Kleinbuchstaben und die Anzahl der Großbuchstaben im String.\n\n  Beispiele:\n  - count_chars_types(\"yLOI2022\") gibt (4, 1, 3) zurück\n  - count_chars_types(\"IAKIOIOI\") gibt (0, 0, 8) zurück\n  - count_chars_types(\"1n2s0e1s\") gibt (4, 4, 0) zurück",
      "ha": "Yana ƙididdige adadin haruffan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu mai tsawon haruffa 8.\n\nArguments:\n- s: Wani igiyar rubutu na haruffa 8 daidai wanda zai iya ƙunsar lambobi, ƙananan haruffa, da manyan haruffa.\n\nReturns:\n- Wani tuple da ke ƙunshe da ƙimar usize guda uku: adadin haruffan lambobi, adadin ƙananan haruffa, da adadin manyan haruffa a cikin igiyar rubutu.\n\nExamples:\n- count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "hi": "8 वर्णों की लंबाई वाले दिए गए स्ट्रिंग में अंक वर्णों, छोटे अक्षरों और बड़े अक्षरों की संख्या गिनता है।\n\nArguments:\n- s: एक स्ट्रिंग जो ठीक 8 वर्णों की होती है और इसमें अंक, छोटे अक्षर और बड़े अक्षर शामिल हो सकते हैं।\n\nReturns:\n- एक टपल जिसमें तीन usize मान होते हैं: स्ट्रिंग में अंक वर्णों की गिनती, छोटे अक्षरों की गिनती, और बड़े अक्षरों की गिनती।\n\nExamples:\n- count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "hu": "Számolja meg a számjegy karakterek, kisbetűk és nagybetűk számát egy adott, 8 hosszúságú karakterláncban.\n\n  Argumentumok:\n  - s: Egy pontosan 8 karakter hosszú karakterlánc, amely tartalmazhat számjegyeket, kisbetűket és nagybetűket.\n\n  Visszatér:\n  - Egy hármas, amely három usize értéket tartalmaz: a számjegy karakterek száma, a kisbetűk száma és a nagybetűk száma a karakterláncban.\n\n  Példák:\n  - count_chars_types(\"yLOI2022\") visszaadja (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") visszaadja (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") visszaadja (4, 4, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9886198695793682",
      "hy": "0.9663512189311658",
      "bn": "0.9743089478865665",
      "bg": "0.9867851207497489",
      "zh": "0.9645093194078292",
      "fr": "0.9774671709450212",
      "de": "0.9771263212111654",
      "ha": "0.9693078321528701",
      "hi": "0.9875953340739902",
      "hu": "0.9852097831977612"
    }
  }
]