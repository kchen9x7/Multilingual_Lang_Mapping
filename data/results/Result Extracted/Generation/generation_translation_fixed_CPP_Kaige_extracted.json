[
  {
    "task_id": "CPP/1",
    "prompt": {
      "en": "#include <bits/stdc++.h>\nusing namespace std;\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "sq": "#include <bits/stdc++.h>\nusing namespace std;\n// Kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "hy": "#include <bits/stdc++.h>\nusing namespace std;\n// Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "bn": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nstring hello_mmcodeeval()",
      "bg": "#include <bits/stdc++.h>\nusing namespace std;\n// Връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "zh": "#include <bits/stdc++.h>\nusing namespace std;\n// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "fr": "#include <bits/stdc++.h>\nusing namespace std;\n// Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "de": "#include <bits/stdc++.h>\nusing namespace std;\n// Gibt \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück\nstring hello_mmcodeeval()",
      "ha": "#include <bits/stdc++.h>\nusing namespace std;\n// Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "hi": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nstring hello_mmcodeeval()",
      "hu": "#include <bits/stdc++.h>\nusing namespace std;\n// Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget\nstring hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "sq": "0.9343600083920678",
      "hy": "0.936928895109992",
      "bn": "0.936928895109992",
      "bg": "0.9980399153999477",
      "zh": "0.9343600083920678",
      "fr": "0.9343600083920678",
      "de": "0.9980399153999477",
      "ha": "0.936928895109992",
      "hi": "0.936928895109992",
      "hu": "0.9231534809244604"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "Write a CPP function `string hello_mmcodeeval()` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Shkruani një funksion CPP `string hello_mmcodeeval()` për të zgjidhur problemin e mëposhtëm: Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Գրեք CPP ֆունկցիա `string hello_mmcodeeval()` հետևյալ խնդիրը լուծելու համար: Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "একটি CPP ফাংশন `string hello_mmcodeeval()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" রিটার্ন করুন",
      "bg": "Напишете CPP функция `string hello_mmcodeeval()` за решаване на следния проблем:  \nВърнете \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "编写一个 CPP 函数 `string hello_mmcodeeval()` 来解决以下问题：  \n返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Écrire une fonction CPP `string hello_mmcodeeval()` pour résoudre le problème suivant :  \nRetourner \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Schreiben Sie eine CPP-Funktion `string hello_mmcodeeval()`, um das folgende Problem zu lösen:  \nGeben Sie \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück.",
      "ha": "Rubuta aikin CPP `string hello_mmcodeeval()` don warware matsalar mai zuwa: Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "एक CPP फ़ंक्शन `string hello_mmcodeeval()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं",
      "hu": "Írj egy CPP függvényt `string hello_mmcodeeval()` a következő probléma megoldására:  \nAdja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.9878025055614096",
      "ha": "0.9759047443678008",
      "hi": "1",
      "hu": "0.9802777908366649"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(hello_mmcodeeval() ==  \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "string hello_mmcodeeval()",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন",
      "bg": "Върни \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Gibt \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं",
      "hu": "Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget."
    },
    "docstring_bertscore": {
      "sq": "0.9081203391662159",
      "hy": "0.956679111157053",
      "bn": "0.8965616400330337",
      "bg": "0.9420164150594386",
      "zh": "0.956679111157053",
      "fr": "0.9560623638239396",
      "de": "0.9441356025946998",
      "ha": "0.8862938397461972",
      "hi": "0.9449897132331498",
      "hu": "0.886144271069278"
    }
  },
  {
    "task_id": "CPP/2",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the area of a triangle given its three sides.\n *\n * @param a (double): Length of side 'a'.\n * @param b (double): Length of side 'b'.\n * @param c (double): Length of side 'c'.\n *\n * @return (double): If the provided sides form a triangle, return the\n *                   calculated area rounded to 2 decimal places.\n *                   Otherwise, return -1 as an indicator.\n *\n * Example usage:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n *\n * @param a (double): Gjatësia e anës 'a'.\n * @param b (double): Gjatësia e anës 'b'.\n * @param c (double): Gjatësia e anës 'c'.\n *\n * @return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen\n *                   sipërfaqen e llogaritur të rrumbullakosur në 2 vende dhjetore.\n *                   Përndryshe, kthen -1 si tregues.\n *\n * Shembull përdorimi:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվարկել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n *\n * @param a (double): Կողմ 'a'-ի երկարությունը:\n * @param b (double): Կողմ 'b'-ի երկարությունը:\n * @param c (double): Կողմ 'c'-ի երկարությունը:\n *\n * @return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել\n *                   հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական նշան:\n *                   Հակառակ դեպքում վերադարձնել -1 որպես ցուցիչ:\n *\n * Օրինակ օգտագործում:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտ լինի 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n *\n * @param a (double): বাহু 'a' এর দৈর্ঘ্য।\n * @param b (double): বাহু 'b' এর দৈর্ঘ্য।\n * @param c (double): বাহু 'c' এর দৈর্ঘ্য।\n *\n * @return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তাহলে\n *                   গণনা করা ক্ষেত্রফল 2 দশমিক স্থান পর্যন্ত রাউন্ড করে ফেরত দিন।\n *                   অন্যথায়, নির্দেশক হিসেবে -1 ফেরত দিন।\n *\n * উদাহরণ ব্যবহার:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল প্রায় 6 হওয়া উচিত\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява площта на триъгълник, дадени неговите три страни.\n *\n * @param a (double): Дължина на страна 'a'.\n * @param b (double): Дължина на страна 'b'.\n * @param c (double): Дължина на страна 'c'.\n *\n * @return (double): Ако предоставените страни образуват триъгълник, връща\n *                   изчислената площ, закръглена до 2 десетични знака.\n *                   В противен случай връща -1 като индикатор.\n *\n * Пример за използване:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算给定三边的三角形面积。\n *\n * @param a (double): 边 'a' 的长度。\n * @param b (double): 边 'b' 的长度。\n * @param c (double): 边 'c' 的长度。\n *\n * @return (double): 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n *                   否则，返回 -1 作为指示。\n *\n * 使用示例:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 面积应约为 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer l'aire d'un triangle donné ses trois côtés.\n *\n * @param a (double): Longueur du côté 'a'.\n * @param b (double): Longueur du côté 'b'.\n * @param c (double): Longueur du côté 'c'.\n *\n * @return (double): Si les côtés fournis forment un triangle, retourne\n *                   l'aire calculée arrondie à 2 décimales.\n *                   Sinon, retourne -1 comme indicateur.\n *\n * Exemple d'utilisation :\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n *\n * @param a (double): Länge der Seite 'a'.\n * @param b (double): Länge der Seite 'b'.\n * @param c (double): Länge der Seite 'c'.\n *\n * @return (double): Wenn die angegebenen Seiten ein Dreieck bilden, gib die\n *                   berechnete Fläche gerundet auf 2 Dezimalstellen zurück.\n *                   Andernfalls gib -1 als Indikator zurück.\n *\n * Beispielverwendung:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Fläche sollte ungefähr 6 sein\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafin yankin wani kusurwar kusurwa idan aka ba shi bangarorinsa guda uku.\n *\n * @param a (double): Tsawon gefen 'a'.\n * @param b (double): Tsawon gefen 'b'.\n * @param c (double): Tsawon gefen 'c'.\n *\n * @return (double): Idan bangarorin da aka bayar sun kafa kusurwa, dawo da\n *                   yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na goma.\n *                   In ba haka ba, dawo da -1 a matsayin alama.\n *\n * Misalin amfani:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Yankin ya kamata ya kusan zama 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए तीन भुजाओं के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n *\n * @param a (double): भुजा 'a' की लंबाई।\n * @param b (double): भुजा 'b' की लंबाई।\n * @param c (double): भुजा 'c' की लंबाई।\n *\n * @return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया\n *                   क्षेत्रफल 2 दशमलव स्थानों तक गोल करके लौटाएं।\n *                   अन्यथा, संकेतक के रूप में -1 लौटाएं।\n *\n * उदाहरण उपयोग:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki egy háromszög területét a három oldalának ismeretében.\n *\n * @param a (double): Az 'a' oldal hossza.\n * @param b (double): A 'b' oldal hossza.\n * @param c (double): A 'c' oldal hossza.\n *\n * @return (double): Ha a megadott oldalak háromszöget alkotnak, adja vissza a\n *                   kiszámított területet 2 tizedesjegyre kerekítve.\n *                   Ellenkező esetben adja vissza a -1 értéket jelzésként.\n *\n * Példa használat:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie\n */\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "sq": "0.9916112431177536",
      "hy": "0.9951025693252038",
      "bn": "0.9960379197894971",
      "bg": "0.9912215303101631",
      "zh": "0.9878742111289632",
      "fr": "0.9907517694590156",
      "de": "0.9900609329937763",
      "ha": "0.9960379197894971",
      "hi": "0.9875381285242522",
      "hu": "0.9768299646826614"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `double calculate_triangle_area(double a, double b, double c)` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6",
      "sq": "Shkruani një funksion CPP `double calculate_triangle_area(double a, double b, double c)` për të zgjidhur problemin në vijim:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a (double): Gjatësia e anës 'a'.\n@param b (double): Gjatësia e anës 'b'.\n@param c (double): Gjatësia e anës 'c'.\n\n@return (double): Nëse anët e dhëna formojnë një trekëndësh, kthejeni sipërfaqen e llogaritur të rrumbullakosur në 2 vende dhjetore. Përndryshe, kthejeni -1 si një tregues.\n\nShembull përdorimi:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6",
      "hy": "Գրեք CPP ֆունկցիա `double calculate_triangle_area(double a, double b, double c)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\n\n@param a (double): Կողմ 'a'-ի երկարությունը։\n@param b (double): Կողմ 'b'-ի երկարությունը։\n@param c (double): Կողմ 'c'-ի երկարությունը։\n\n@return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական նշան։ Հակառակ դեպքում, վերադարձնել -1 որպես ցուցիչ։\n\nՕրինակ օգտագործում:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտ լինի 6",
      "bn": "একটি CPP ফাংশন `double calculate_triangle_area(double a, double b, double c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n\n@param a (double): বাহু 'a' এর দৈর্ঘ্য।\n@param b (double): বাহু 'b' এর দৈর্ঘ্য।\n@param c (double): বাহু 'c' এর দৈর্ঘ্য।\n\n@return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে গণনা করা ক্ষেত্রফল 2 দশমিক স্থানে রাউন্ড করে ফেরত দিন। অন্যথায়, নির্দেশক হিসাবে -1 ফেরত দিন।\n\nউদাহরণ ব্যবহার:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল আনুমানিক 6 হওয়া উচিত",
      "bg": "Напишете CPP функция `double calculate_triangle_area(double a, double b, double c)`, за да решите следния проблем:  \nИзчислете площта на триъгълник, като са дадени трите му страни.\n\n@param a (double): Дължина на страна 'a'.  \n@param b (double): Дължина на страна 'b'.  \n@param c (double): Дължина на страна 'c'.  \n\n@return (double): Ако предоставените страни образуват триъгълник, върнете изчислената площ закръглена до 2 знака след десетичната запетая. В противен случай върнете -1 като индикатор.\n\nПример за използване:  \n    double area = calculate_triangle_area(3, 5, 4);  \n    assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6",
      "zh": "编写一个 CPP 函数 `double calculate_triangle_area(double a, double b, double c)` 来解决以下问题：\n计算给定三边的三角形面积。\n\n@param a (double): 边 'a' 的长度。\n@param b (double): 边 'b' 的长度。\n@param c (double): 边 'c' 的长度。\n\n@return (double): 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。否则，返回 -1 作为指示。\n\n示例用法：\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面积应约为 6",
      "fr": "Écrire une fonction CPP `double calculate_triangle_area(double a, double b, double c)` pour résoudre le problème suivant :\nCalculer l'aire d'un triangle donné ses trois côtés.\n\n@param a (double): Longueur du côté 'a'.\n@param b (double): Longueur du côté 'b'.\n@param c (double): Longueur du côté 'c'.\n\n@return (double): Si les côtés fournis forment un triangle, retourner l'aire calculée arrondie à 2 décimales. Sinon, retourner -1 comme indicateur.\n\nExemple d'utilisation :\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6",
      "de": "Schreiben Sie eine CPP-Funktion `double calculate_triangle_area(double a, double b, double c)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n\n@param a (double): Länge der Seite 'a'.\n@param b (double): Länge der Seite 'b'.\n@param c (double): Länge der Seite 'c'.\n\n@return (double): Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche gerundet auf 2 Dezimalstellen zurück. Andernfalls geben Sie -1 als Indikator zurück.\n\nBeispielverwendung:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Die Fläche sollte ungefähr 6 sein",
      "ha": "Rubuta aikin CPP `double calculate_triangle_area(double a, double b, double c)` don warware matsalar mai zuwa:\nƘididdige yanki na alwatika da aka ba shi ta gefen sa guda uku.\n\n@param a (double): Tsawon gefen 'a'.\n@param b (double): Tsawon gefen 'b'.\n@param c (double): Tsawon gefen 'c'.\n\n@return (double): Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige wanda aka zagaye zuwa wurare 2 na goma. In ba haka ba, dawo da -1 a matsayin alamar.\n\nMisalin amfani:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Yankin yakamata ya zama kusan 6",
      "hi": "एक CPP फ़ंक्शन `double calculate_triangle_area(double a, double b, double c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन भुजाओं के आधार पर एक त्रिभुज का क्षेत्रफल ज्ञात करें।\n\n@param a (double): भुजा 'a' की लंबाई।\n@param b (double): भुजा 'b' की लंबाई।\n@param c (double): भुजा 'c' की लंबाई।\n\n@return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक गोल कर लौटाएँ। अन्यथा, संकेतक के रूप में -1 लौटाएँ।\n\nउदाहरण उपयोग:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए",
      "hu": "Írj egy CPP függvényt `double calculate_triangle_area(double a, double b, double c)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n\n@param a (double): Az 'a' oldal hossza.\n@param b (double): A 'b' oldal hossza.\n@param c (double): A 'c' oldal hossza.\n\n@return (double): Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel, 2 tizedesjegyre kerekítve. Ellenkező esetben térj vissza -1 értékkel, mint jelző.\n\nPélda használat:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie"
    },
    "instruction_bertscore": {
      "sq": "0.9825791224313352",
      "hy": "0.9954146176538096",
      "bn": "0.9954146176538096",
      "bg": "0.9966495027327035",
      "zh": "0.9886611846986234",
      "fr": "0.9947448360089599",
      "de": "0.9907897078617933",
      "ha": "0.9954146176538096",
      "hi": "0.9786182340031184",
      "hu": "0.9825791224313352"
    },
    "level": "easy",
    "test": "int main() {\n    // Test cases for the calculate_triangle_area function\n    assert(fabs(calculate_triangle_area(3, 5, 4) - 6.00) < 1e-6); // Expected area is 6\n    assert(calculate_triangle_area(1, 1, 4) == -1);  // Not a triangle, should return -1\n    assert(fabs(calculate_triangle_area(7, 24, 25) - 84.00) < 1e-6); // Expected area is 84\n    assert(fabs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-2); // Expected area is approx 22.15\n\n    // All tests passed\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a (double): Gjatësia e anës 'a'.\n@param b (double): Gjatësia e anës 'b'.\n@param c (double): Gjatësia e anës 'c'.\n\n@return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur të rrumbullakosur në 2 shifra dhjetore. Përndryshe, kthen -1 si një tregues.\n\nShembull përdorimi:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6",
      "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\n@param a (double): Կողմ 'a'-ի երկարությունը։\n@param b (double): Կողմ 'b'-ի երկարությունը։\n@param c (double): Կողմ 'c'-ի երկարությունը։\n\n@return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական։ Հակառակ դեպքում, վերադարձնել -1 որպես ցուցիչ։\n\nՕրինակ օգտագործում:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտավորապես լինի 6",
      "bn": "একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n\n@param a (double): বাহু 'a' এর দৈর্ঘ্য।\n@param b (double): বাহু 'b' এর দৈর্ঘ্য।\n@param c (double): বাহু 'c' এর দৈর্ঘ্য।\n\n@return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান পর্যন্ত গোলাকার গণনা করা ক্ষেত্রফল প্রদান করুন। অন্যথায়, সূচক হিসাবে -1 প্রদান করুন।\n\nব্যবহারের উদাহরণ:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল আনুমানিক 6 হওয়া উচিত",
      "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\n\n@param a (double): Дължина на страна 'a'.\n@param b (double): Дължина на страна 'b'.\n@param c (double): Дължина на страна 'c'.\n\n@return (double): Ако предоставените страни образуват триъгълник, връща изчислената площ, закръглена до 2 знака след десетичната запетая. В противен случай връща -1 като индикатор.\n\nПример за използване:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6",
      "zh": "计算给定三边的三角形面积。\n\n@param a (double): 边 'a' 的长度。\n@param b (double): 边 'b' 的长度。\n@param c (double): 边 'c' 的长度。\n\n@return (double): 如果提供的边长可以构成一个三角形，返回计算出的面积并四舍五入到小数点后两位。否则，返回 -1 作为指示。\n\n示例用法:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面积应大约为 6",
      "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\n@param a (double): Longueur du côté 'a'.\n@param b (double): Longueur du côté 'b'.\n@param c (double): Longueur du côté 'c'.\n\n@return (double): Si les côtés fournis forment un triangle, retourner l'aire calculée arrondie à 2 décimales. Sinon, retourner -1 comme indicateur.\n\nExemple d'utilisation :\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\n@param a (double): Länge der Seite 'a'.\n@param b (double): Länge der Seite 'b'.\n@param c (double): Länge der Seite 'c'.\n\n@return (double): Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche auf 2 Dezimalstellen gerundet zurück. Andernfalls geben Sie -1 als Indikator zurück.\n\nBeispielverwendung:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Die Fläche sollte ungefähr 6 betragen",
      "ha": "Lissafin yankin wani kusurwar kusurwa idan aka ba shi bangarorinsa guda uku.\n\n@param a (double): Tsawon gefen 'a'.\n@param b (double): Tsawon gefen 'b'.\n@param c (double): Tsawon gefen 'c'.\n\n@return (double): Idan gefen da aka bayar sun ƙirƙiri alwatika, dawo da yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na adadi. In ba haka ba, dawo da -1 a matsayin alamar.\n\nExample usage:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Ya kamata yankin ya kasance kusan 6",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\n@param a (double): भुजा 'a' की लंबाई।\n@param b (double): भुजा 'b' की लंबाई।\n@param c (double): भुजा 'c' की लंबाई।\n\n@return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक गोल कर लौटाएं। अन्यथा, संकेतक के रूप में -1 लौटाएं।\n\nउदाहरण उपयोग:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए",
      "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n\n@param a (double): Az 'a' oldal hossza.\n@param b (double): A 'b' oldal hossza.\n@param c (double): A 'c' oldal hossza.\n\n@return (double): Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegyre kerekítve. Ellenkező esetben adja vissza a -1 értéket jelzésként.\n\nPélda használat:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie"
    },
    "docstring_bertscore": {
      "sq": "0.9780563086551707",
      "hy": "0.9804583458530256",
      "bn": "0.9920823943815683",
      "bg": "0.9939008555199427",
      "zh": "0.9827485541463579",
      "fr": "0.9934346700156539",
      "de": "0.9881644101156551",
      "ha": "0.9941429859544243",
      "hi": "0.9874999914910935",
      "hu": "0.9683764542961976"
    }
  },
  {
    "task_id": "CPP/3",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculate the value of the function for a given input.\n * Parameters:\n * - x (int): Input value for the function.\n * Returns:\n * - std::string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n *\n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * Example:\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * Parametra:\n * - x (int): Vlera e hyrjes për funksionin.\n * Kthen:\n * - std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n *   Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n *\n * Përkufizimet e Funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * Shembull:\n *   calculate_function_value(40) kthen \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Հաշվել ֆունկցիայի արժեքը տրված մուտքի համար։\n * Պարամետրեր:\n * - x (int): Մուտքային արժեք ֆունկցիայի համար։\n * Վերադարձնում է:\n * - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\n *   Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական նիշ։\n *\n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * Օրինակ:\n *   calculate_function_value(40) վերադարձնում է \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * প্যারামিটার:\n * - x (int): ফাংশনের জন্য ইনপুট মান।\n * রিটার্নস:\n * - std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, \"Not define\" রিটার্ন করে।\n *   অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n *\n * ফাংশন সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * উদাহরণ:\n *   calculate_function_value(40) \"Not define\" রিটার্ন করে\n */\nstd::string calculate_function_value(int x)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Изчислява стойността на функцията за даден вход.\n * Параметри:\n * - x (int): Входна стойност за функцията.\n * Връща:\n * - std::string: Ако x не е в определения домейн, връща \"Not define\".\n *   В противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n *\n * Дефиниции на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * Пример:\n *   calculate_function_value(40) връща \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 计算给定输入的函数值。\n * 参数：\n * - x (int): 函数的输入值。\n * 返回：\n * - std::string: 如果 x 不在定义域内，返回 \"Not define\"。\n *   否则，返回计算后的函数值，四舍五入到小数点后5位。\n *\n * 函数定义：\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * 示例：\n *   calculate_function_value(40) 返回 \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * Paramètres:\n * - x (int): Valeur d'entrée pour la fonction.\n * Renvoie:\n * - std::string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n *   Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n *\n * Définitions de la fonction:\n * - Pour 0 <= x < 10: y = cos(x + 3.0)\n * - Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n * Exemple:\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * Parameter:\n * - x (int): Eingabewert für die Funktion.\n * Rückgabewert:\n * - std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n *   Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n *\n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * Beispiel:\n *   calculate_function_value(40) gibt \"Not define\" zurück\n */\nstd::string calculate_function_value(int x)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n * Sigogi:\n * - x (int): Ƙimar shigarwa don aikin.\n * Komawa:\n * - std::string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\n *   In ba haka ba, yana mayar da ƙimar aikin da aka lissafa an zagaye zuwa wurare 5 na ɗigo.\n *\n * Ma'anar Aiki:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * Misali:\n *   calculate_function_value(40) yana mayar da \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * पैरामीटर्स:\n * - x (int): फ़ंक्शन के लिए इनपुट मान।\n * रिटर्न करता है:\n * - std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n *   अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n *\n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * उदाहरण:\n *   calculate_function_value(40) \"Not define\" लौटाता है\n */\nstd::string calculate_function_value(int x)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * Paraméterek:\n * - x (int): A függvény bemeneti értéke.\n * Visszatér:\n * - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n *   Egyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n *\n * Függvénydefiníciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * Példa:\n *   calculate_function_value(40) visszaadja \"Not define\"\n */\nstd::string calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "sq": "0.9886876025393011",
      "hy": "0.9697082710010364",
      "bn": "0.9838799527967326",
      "bg": "0.9887968492488702",
      "zh": "0.9849879130621452",
      "fr": "0.9827940405036149",
      "de": "0.9756701618877986",
      "ha": "0.9842942957715713",
      "hi": "0.9896446037151272",
      "hu": "0.9816773405014367"
    },
    "canonical_solution": "{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}",
    "instruction": {
      "en": "Write a CPP function `std::string calculate_function_value(int x)` to solve the following problem:\nCalculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: calculate_function_value(40) returns \"Not define\"",
      "sq": "Shkruani një funksion CPP `std::string calculate_function_value(int x)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni vlerën e funksionit për një hyrje të dhënë. Parametrat: - x (int): Vlera e hyrjes për funksionin. Kthen: - std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\". Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore. Përkufizimet e funksionit: - Për 0 <= x < 10: y = cos(x + 3.0) - Për 10 <= x < 20: y = (cos(x + 7.5))^2 - Për 20 <= x < 30: y = (cos(x + 4.0))^4 Shembull: calculate_function_value(40) kthen \"Not define\"",
      "hy": "Գրեք CPP ֆունկցիա `std::string calculate_function_value(int x)` հետևյալ խնդիրը լուծելու համար: Հաշվարկել ֆունկցիայի արժեքը տրված մուտքի համար: Պարամետրեր: - x (int): Մուտքային արժեք ֆունկցիայի համար: Վերադարձնում է: - std::string: Եթե x-ը սահմանված դոմենում չէ, վերադարձնում է \"Not define\": Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական: Ֆունկցիայի սահմանումներ: - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 Օրինակ: calculate_function_value(40) վերադարձնում է \"Not define\"",
      "bn": "একটি CPP ফাংশন `std::string calculate_function_value(int x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন। প্যারামিটারসমূহ: - x (int): ফাংশনের জন্য ইনপুট মান। রিটার্নস: - std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে রিটার্ন করে। ফাংশনের সংজ্ঞা: - 0 <= x < 10 এর জন্য: y = cos(x + 3.0) - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2 - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4 উদাহরণ: calculate_function_value(40) \"Not define\" রিটার্ন করে",
      "bg": "Напишете CPP функция `std::string calculate_function_value(int x)`, за да решите следния проблем:  \nИзчислете стойността на функцията за даден вход.  \nПараметри:  \n- x (int): Входна стойност за функцията.  \nВръща:  \n- std::string: Ако x не е в определения домейн, връща \"Not define\". В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.  \nДефиниции на функцията:  \n- За 0 <= x < 10: y = cos(x + 3.0)  \n- За 10 <= x < 20: y = (cos(x + 7.5))^2  \n- За 20 <= x < 30: y = (cos(x + 4.0))^4  \nПример: calculate_function_value(40) връща \"Not define\"",
      "zh": "编写一个 CPP 函数 `std::string calculate_function_value(int x)` 来解决以下问题：\n计算给定输入的函数值。  \n参数：  \n- x (int): 函数的输入值。  \n返回：  \n- std::string: 如果 x 不在定义域内，返回 \"Not define\"。否则，返回计算的函数值，四舍五入到小数点后 5 位。  \n函数定义：  \n- 对于 0 <= x < 10: y = cos(x + 3.0)  \n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2  \n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4  \n示例：calculate_function_value(40) 返回 \"Not define\"  ",
      "fr": "Écrire une fonction CPP `std::string calculate_function_value(int x)` pour résoudre le problème suivant :  \nCalculer la valeur de la fonction pour une entrée donnée.  \nParamètres :  \n- x (int) : Valeur d'entrée pour la fonction.  \nRenvoie :  \n- std::string : Si x n'est pas dans le domaine défini, renvoie \"Not define\". Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.  \nDéfinitions de la fonction :  \n- Pour 0 <= x < 10 : y = cos(x + 3.0)  \n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2  \n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4  \nExemple : calculate_function_value(40) renvoie \"Not define\"",
      "de": "Schreiben Sie eine CPP-Funktion `std::string calculate_function_value(int x)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe. Parameter: - x (int): Eingabewert für die Funktion. Rückgabewerte: - std::string: Wenn x nicht im definierten Bereich liegt, gibt \"Not define\" zurück. Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben. Funktionsdefinitionen: - Für 0 <= x < 10: y = cos(x + 3.0) - Für 10 <= x < 20: y = (cos(x + 7.5))^2 - Für 20 <= x < 30: y = (cos(x + 4.0))^4 Beispiel: calculate_function_value(40) gibt \"Not define\" zurück",
      "ha": "Rubuta aikin CPP `std::string calculate_function_value(int x)` don warware matsalar mai zuwa: \nƘididdige ƙimar aikin don wani shigarwa da aka bayar. Sigogi: - x (int): Ƙimar shigarwa don aikin. Yana dawowa: - std::string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\". In ba haka ba, yana dawowa ƙimar aikin da aka ƙididdige tare da zagaye zuwa wurare 5 na ƙidaya. Ma'anar Aiki: - Don 0 <= x < 10: y = cos(x + 3.0) - Don 10 <= x < 20: y = (cos(x + 7.5))^2 - Don 20 <= x < 30: y = (cos(x + 4.0))^4 Misali: calculate_function_value(40) yana dawowa \"Not define\"",
      "hi": "एक CPP फ़ंक्शन `std::string calculate_function_value(int x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें। पैरामीटर्स: - x (int): फ़ंक्शन के लिए इनपुट मान। रिटर्न्स: - std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है। अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है। फ़ंक्शन परिभाषाएँ: - 0 <= x < 10 के लिए: y = cos(x + 3.0) - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2 - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4 उदाहरण: calculate_function_value(40) \"Not define\" लौटाता है।",
      "hu": "Írj egy CPP függvényt `std::string calculate_function_value(int x)` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre. Paraméterek: - x (int): A függvény bemeneti értéke. Visszatérési érték: - std::string: Ha x nincs a meghatározott tartományban, akkor \"Not define\" értéket ad vissza. Ellenkező esetben a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve. Függvénydefiníciók: - Ha 0 <= x < 10: y = cos(x + 3.0) - Ha 10 <= x < 20: y = (cos(x + 7.5))^2 - Ha 20 <= x < 30: y = (cos(x + 4.0))^4 Példa: calculate_function_value(40) visszaadja \"Not define\""
    },
    "instruction_bertscore": {
      "sq": "0.9841079804741607",
      "hy": "0.9489227934080217",
      "bn": "0.9822291356999516",
      "bg": "0.9856203521953603",
      "zh": "0.9790470769957728",
      "fr": "0.9927162239274506",
      "de": "0.98038624302471",
      "ha": "0.9802928867456235",
      "hi": "0.9803391676244047",
      "hu": "0.9640717366784094"
    },
    "level": "easy",
    "test": "int main() {\n    assert(calculate_function_value(40) == \"Not define\");\n\n    // Additional test cases based on provided function definitions\n    assert(calculate_function_value(5) == \"-0.14550\");\n    assert(calculate_function_value(15) == \"0.76266\");\n    assert(calculate_function_value(25) == \"0.31314\");\n    assert(calculate_function_value(-1) == \"Not define\");\n\n    // std::cout << \"All tests passed successfully.\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "std::string calculate_function_value(int x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: calculate_function_value(40) returns \"Not define\"",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat: - x (int): Vlera e hyrjes për funksionin.\n\nKthen:\n- std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\". Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërcaktimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembull:\ncalculate_function_value(40) kthen \"Not define\"",
      "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։ Պարամետրեր՝ - x (int): Մուտքագրված արժեք ֆունկցիայի համար։ Վերադարձնում է՝ - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական։ Ֆունկցիայի սահմանումներ՝ - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 Օրինակ՝ calculate_function_value(40) վերադարձնում է \"Not define\"",
      "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nParameters: - x (int): ফাংশনের জন্য ইনপুট মান।\n\nReturns:\n- std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\ncalculate_function_value(40) returns \"Not define\"",
      "bg": "Изчислява стойността на функцията за даден вход. \n\nПараметри: - x (int): Входна стойност за функцията.\n\nВръща:\n- std::string: Ако x не е в определения домейн, връща \"Not define\". В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПример:\ncalculate_function_value(40) връща \"Not define\"",
      "zh": "计算给定输入的函数值。\n\n参数: - x (int): 函数的输入值。\n\n返回:\n- std::string: 如果 x 不在定义域内，返回 \"Not define\"。否则，返回计算后的函数值，保留小数点后 5 位。\n\n函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例:\ncalculate_function_value(40) 返回 \"Not define\"",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée. \n\nParamètres: - x (int): Valeur d'entrée pour la fonction. \n\nRenvoie: \n- std::string: Si x n'est pas dans le domaine défini, renvoie \"Not define\". Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales. \n\nDéfinitions de fonction: \n- Pour 0 <= x < 10: y = cos(x + 3.0) \n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2 \n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4 \n\nExemple: calculate_function_value(40) renvoie \"Not define\"",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n\nParameter: - x (int): Eingabewert für die Funktion.\n\nRückgabewerte:\n- std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben. Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiel:\ncalculate_function_value(40) gibt \"Not define\" zurück.",
      "ha": "Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi: - x (int): Ƙimar shigarwa don aikin.\n\nReturns:\n    - std::string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\". In ba haka ba, yana dawowa da ƙimar aikin da aka lissafa tare da zagaye zuwa wurare 5 na ƙidaya.\n\nFunction Definitions:\n    - Don 0 <= x < 10: y = cos(x + 3.0)\n    - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n    - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\n    calculate_function_value(40) returns \"Not define\"",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स: - x (int): फ़ंक्शन के लिए इनपुट मान।\n\nReturns:\n- std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है। अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\ncalculate_function_value(40) returns \"Not define\"",
      "hu": "Számítsa ki a függvény értékét egy adott bemenethez. Paraméterek: - x (int): A függvény bemeneti értéke. Visszatér: - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza. Ellenkező esetben a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve. Függvénydefiníciók: - Ha 0 <= x < 10: y = cos(x + 3.0) - Ha 10 <= x < 20: y = (cos(x + 7.5))^2 - Ha 20 <= x < 30: y = (cos(x + 4.0))^4 Példa: calculate_function_value(40) visszatér \"Not define\""
    },
    "docstring_bertscore": {
      "sq": "0.9863854764231067",
      "hy": "0.9418521477343227",
      "bn": "0.9868957578719854",
      "bg": "0.9846454742852411",
      "zh": "0.9732464739784109",
      "fr": "0.991067591764861",
      "de": "0.967200562440471",
      "ha": "0.970451347256488",
      "hi": "0.9894604733519078",
      "hu": "0.968630105292779"
    }
  },
  {
    "task_id": "CPP/4",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sq": "#include <cassert>\n#include <cstdio>\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Shembull thirrjeje: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hy": "#include <cassert>\n#include <cstdio>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնն ու նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը, մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bn": "#include <cassert>\n#include <cstdio>\n/*\nতিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা রিটার্ন করব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bg": "#include <cassert>\n#include <cstdio>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще връщаме чрез референция.\n\n>>> Примерно извикване: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "zh": "#include <cassert>\n#include <cstdio>\n/*\n找到三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 元组不是C语言中的概念，因此我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "fr": "#include <cassert>\n#include <cstdio>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "de": "#include <cassert>\n#include <cstdio>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabe:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "ha": "#include <cassert>\n#include <cstdio>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a samun ra'ayin tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hi": "#include <cassert>\n#include <cstdio>\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: C में एक ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hu": "#include <cassert>\n#include <cstdio>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "sq": "0.9974640859253275",
      "hy": "0.9927400595731748",
      "bn": "0.9858889004705195",
      "bg": "0.9918148392583144",
      "zh": "0.9833861576694799",
      "fr": "1",
      "de": "0.990845324368483",
      "ha": "0.957009632111095",
      "hi": "0.9800179822982713",
      "hu": "0.9931178545579032"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `void find_max_min(int a, int b, int c, int *max, int *min)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n",
      "sq": "Shkruani një funksion CPP `void find_max_min(int a, int b, int c, int *max, int *min)` për të zgjidhur problemin e mëposhtëm:  \nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.  \nParametrat:  \na (int): Numri i parë i plotë.  \nb (int): Numri i dytë i plotë.  \nc (int): Numri i tretë i plotë.  \n\nKthen:  \nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.  \n\n>>> Shembull thirrjeje:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "hy": "Գրեք CPP ֆունկցիա `void find_max_min(int a, int b, int c, int *max, int *min)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը C-ում հասկացություն չէ; փոխարենը մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bn": "একটি CPP ফাংশন `void find_max_min(int a, int b, int c, int *max, int *min)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bg": "Напишете CPP функция `void find_max_min(int a, int b, int c, int *max, int *min)`, за да решите следния проблем:\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "zh": "编写一个 CPP 函数 `void find_max_min(int a, int b, int c, int *max, int *min)` 来解决以下问题：\n找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在 C 中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "fr": "Écrire une fonction CPP `void find_max_min(int a, int b, int c, int *max, int *min)` pour résoudre le problème suivant :  \nTrouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel :  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "de": "Schreiben Sie eine CPP-Funktion `void find_max_min(int a, int b, int c, int *max, int *min)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabe:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir per Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "ha": "Rubuta aikin CPP `void find_max_min(int a, int b, int c, int *max, int *min)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a san ma'anar tuple a cikin C; maimakon haka, za mu dawo ta hanyar tunani.\n\n>>> Misalin kira:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hi": "एक CPP फ़ंक्शन `void find_max_min(int a, int b, int c, int *max, int *min)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों में से अधिकतम और न्यूनतम खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: C में एक ट्यूपल एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hu": "Írjon egy CPP függvényt `void find_max_min(int a, int b, int c, int *max, int *min)` a következő probléma megoldására:\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C-ben; ehelyett referencia alapján fogunk visszatérni.\n\n>>> Példa hívás:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);"
    },
    "instruction_bertscore": {
      "sq": "0.9973437159144204",
      "hy": "0.9923976207962707",
      "bn": "0.9836368292103459",
      "bg": "0.991021509516461",
      "zh": "0.9730331449491795",
      "fr": "1",
      "de": "0.9891533907828278",
      "ha": "0.9543519576128482",
      "hi": "0.9836368292103459",
      "hu": "0.9932410053941448"
    },
    "level": "easy",
    "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të dallueshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrje shembull:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Կապ չի հանդիսանում C-ում հասկացություն; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\nParameters:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nReturns:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортежът не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "zh": "找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous renverrons par référence.  \n\n>>> Exemple d'appel :  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.  \nSigogi:  \na (int): Lamba ta farko.  \nb (int): Lamba ta biyu.  \nc (int): Lamba ta uku.  \n\nDawowa:  \nTuple[int, int]: Tuple ba wani abu bane a cikin C; maimakon haka, za mu dawo ta hanyar tunani.  \n\n>>> Misalin kira:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nमापदंड:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: एक ट्यूपल C में एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hu": "Keresse meg három különböző egész szám maximumát és minimumát.  \nParaméterek:  \na (int): Az első egész szám.  \nb (int): A második egész szám.  \nc (int): A harmadik egész szám.  \n\nVisszatér:  \nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia alapján térünk vissza.  \n\n>>> Példa hívás:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  "
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9898650834380759",
      "bn": "0.9836650347244529",
      "bg": "0.9898650834380759",
      "zh": "0.9501900552390242",
      "fr": "1",
      "de": "0.9890338152934448",
      "ha": "0.980602750140038",
      "hi": "0.9748770307763263",
      "hu": "0.9903125976865474"
    }
  },
  {
    "task_id": "CPP/5",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n * \n * Parametrat:\n * - xa (double): koordinata x e pikës A.\n * - ya (double): koordinata y e pikës A.\n * - xb (double): koordinata x e pikës B.\n * - yb (double): koordinata y e pikës B.\n * \n * Kthen:\n * double: Distanca midis pikave A dhe B.\n * \n * Shembuj:\n * calculate_distance(0, 0, 3, 4) kthen 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n * \n * Պարամետրեր:\n * - xa (double): A կետի x-կոորդինատը։\n * - ya (double): A կետի y-կոորդինատը։\n * - xb (double): B կետի x-կոորդինատը։\n * - yb (double): B կետի y-կոորդինատը։\n * \n * Վերադարձնում է:\n * double: Հեռավորությունը A և B կետերի միջև։\n * \n * Օրինակներ:\n * calculate_distance(0, 0, 3, 4) վերադարձնում է 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n * \n * প্যারামিটার:\n * - xa (double): বিন্দু A এর x-অক্ষাংশ।\n * - ya (double): বিন্দু A এর y-অক্ষাংশ।\n * - xb (double): বিন্দু B এর x-অক্ষাংশ।\n * - yb (double): বিন্দু B এর y-অক্ষাংশ।\n * \n * রিটার্নস:\n * double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n * \n * উদাহরণ:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Изчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n * \n * Параметри:\n * - xa (double): x-координата на точка A.\n * - ya (double): y-координата на точка A.\n * - xb (double): x-координата на точка B.\n * - yb (double): y-координата на точка B.\n * \n * Връща:\n * double: Разстоянието между точките A и B.\n * \n * Примери:\n * calculate_distance(0, 0, 3, 4) връща 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 计算两个点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n * \n * 参数:\n * - xa (double): 点 A 的 x 坐标。\n * - ya (double): 点 A 的 y 坐标。\n * - xb (double): 点 B 的 x 坐标。\n * - yb (double): 点 B 的 y 坐标。\n * \n * 返回:\n * double: 点 A 和 B 之间的距离。\n * \n * 示例:\n * calculate_distance(0, 0, 3, 4) 返回 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n * \n * Paramètres :\n * - xa (double) : coordonnée x du point A.\n * - ya (double) : coordonnée y du point A.\n * - xb (double) : coordonnée x du point B.\n * - yb (double) : coordonnée y du point B.\n * \n * Renvoie :\n * double : La distance entre les points A et B.\n * \n * Exemples :\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n * \n * Parameter:\n * - xa (double): x-Koordinate des Punktes A.\n * - ya (double): y-Koordinate des Punktes A.\n * - xb (double): x-Koordinate des Punktes B.\n * - yb (double): y-Koordinate des Punktes B.\n * \n * Rückgabewert:\n * double: Die Entfernung zwischen den Punkten A und B.\n * \n * Beispiele:\n * calculate_distance(0, 0, 3, 4) gibt 5 zurück\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Lissafi nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n * \n * Sigogi:\n * - xa (double): x-daidaici na maki A.\n * - ya (double): y-daidaici na maki A.\n * - xb (double): x-daidaici na maki B.\n * - yb (double): y-daidaici na maki B.\n * \n * Komawa:\n * double: Nisan tsakanin maki A da B.\n * \n * Misalai:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n * \n * पैरामीटर्स:\n * - xa (double): बिंदु A का x-निर्देशांक।\n * - ya (double): बिंदु A का y-निर्देशांक।\n * - xb (double): बिंदु B का x-निर्देशांक।\n * - yb (double): बिंदु B का y-निर्देशांक।\n * \n * रिटर्न करता है:\n * double: बिंदुओं A और B के बीच की दूरी।\n * \n * उदाहरण:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n * \n * Paraméterek:\n * - xa (double): A pont x-koordinátája.\n * - ya (double): A pont y-koordinátája.\n * - xb (double): B pont x-koordinátája.\n * - yb (double): B pont y-koordinátája.\n * \n * Visszatérési érték:\n * double: A távolság A és B pontok között.\n * \n * Példák:\n * calculate_distance(0, 0, 3, 4) visszaadja 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "sq": "0.9752379421786667",
      "hy": "0.999999801369619",
      "bn": "0.9959058305861089",
      "bg": "0.9988942246687788",
      "zh": "0.9762146077622152",
      "fr": "0.999999801369619",
      "de": "0.9957727482308155",
      "ha": "0.999999801369619",
      "hi": "0.9959058305861089",
      "hu": "0.9708944916365768"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "en": "Write a CPP function `double calculate_distance(double xa, double ya, double xb, double yb)` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "sq": "Shkruani një funksion CPP `double calculate_distance(double xa, double ya, double xb, double yb)` për të zgjidhur problemin në vijim:\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n\nKthen:\ndouble: Distanca midis pikave A dhe B.\n\nShembuj:\ncalculate_distance(0, 0, 3, 4) kthen 5",
      "hy": "Գրեք CPP ֆունկցիա `double calculate_distance(double xa, double ya, double xb, double yb)` հետևյալ խնդիրը լուծելու համար:\nՀաշվել հեռավորությունը A (xa, ya) և B (xb, yb) կետերի միջև:\n\nՊարամետրեր:\n- xa (double): A կետի x-կոորդինատը:\n- ya (double): A կետի y-կոորդինատը:\n- xb (double): B կետի x-կոորդինատը:\n- yb (double): B կետի y-կոորդինատը:\n\nՎերադարձնում է:\ndouble: A և B կետերի միջև հեռավորությունը:\n\nՕրինակներ:\ncalculate_distance(0, 0, 3, 4) վերադարձնում է 5",
      "bn": "একটি CPP ফাংশন `double calculate_distance(double xa, double ya, double xb, double yb)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n\nরিটার্নস:\ndouble: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n\nউদাহরণসমূহ:\ncalculate_distance(0, 0, 3, 4) 5 রিটার্ন করে।",
      "bg": "Напишете CPP функция `double calculate_distance(double xa, double ya, double xb, double yb)` за решаване на следния проблем:  \nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n\nВръща:\ndouble: Разстоянието между точките A и B.\n\nПримери:\ncalculate_distance(0, 0, 3, 4) връща 5",
      "zh": "编写一个 CPP 函数 `double calculate_distance(double xa, double ya, double xb, double yb)` 来解决以下问题：\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n\n返回：\ndouble: 点 A 和 B 之间的距离。\n\n示例：\ncalculate_distance(0, 0, 3, 4) 返回 5",
      "fr": "Écrire une fonction CPP `double calculate_distance(double xa, double ya, double xb, double yb)` pour résoudre le problème suivant :\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n\nRenvoie :\ndouble : La distance entre les points A et B.\n\nExemples :\ncalculate_distance(0, 0, 3, 4) renvoie 5",
      "de": "Schreiben Sie eine CPP-Funktion `double calculate_distance(double xa, double ya, double xb, double yb)`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n\nRückgabewert:\ndouble: Die Entfernung zwischen den Punkten A und B.\n\nBeispiele:\ncalculate_distance(0, 0, 3, 4) gibt 5 zurück.",
      "ha": "Rubuta aikin CPP `double calculate_distance(double xa, double ya, double xb, double yb)` don warware matsalar mai zuwa:\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (double): x-ƙudurin maki A.\n- ya (double): y-ƙudurin maki A.\n- xb (double): x-ƙudurin maki B.\n- yb (double): y-ƙudurin maki B.\n\nDawowa:\ndouble: Nisan tsakanin maki A da B.\n\nMisalai:\ncalculate_distance(0, 0, 3, 4) yana dawowa 5",
      "hi": "एक CPP फ़ंक्शन `double calculate_distance(double xa, double ya, double xb, double yb)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n\nवापसी मान:\ndouble: बिंदु A और B के बीच की दूरी।\n\nउदाहरण:\ncalculate_distance(0, 0, 3, 4) 5 लौटाता है।",
      "hu": "Írj egy CPP függvényt `double calculate_distance(double xa, double ya, double xb, double yb)` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n\nVisszatérési érték:\ndouble: A távolság A és B pontok között.\n\nPéldák:\ncalculate_distance(0, 0, 3, 4) visszaadja 5"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9927776007151904",
      "bn": "0.9959930293233832",
      "bg": "1",
      "zh": "0.9770867937653395",
      "fr": "1",
      "de": "0.993680574427375",
      "ha": "1",
      "hi": "0.9919004489525404",
      "hu": "0.9718995613646133"
    },
    "level": "easy",
    "test": "int main() \n{\n    assert(fabs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n\nKthen:\ndouble: Distanca midis pikave A dhe B.\n\nShembuj:\ncalculate_distance(0, 0, 3, 4) kthen 5",
      "hy": "Հաշվարկել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n\nՊարամետրեր՝\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n\nՎերադարձնում է՝\ndouble: Հեռավորությունը A և B կետերի միջև։\n\nՕրինակներ՝\ncalculate_distance(0, 0, 3, 4) վերադարձնում է 5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n\nরিটার্নস:\ndouble: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n\nউদাহরণ:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "bg": "Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n\nВръща:\ndouble: Разстоянието между точките A и B.\n\nПримери:\ncalculate_distance(0, 0, 3, 4) връща 5",
      "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n\n返回：\ndouble: 点 A 和 B 之间的距离。\n\n示例：\ncalculate_distance(0, 0, 3, 4) 返回 5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n\nRenvoie :\ndouble : La distance entre les points A et B.\n\nExemples :\ncalculate_distance(0, 0, 3, 4) renvoie 5",
      "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n\nRückgabewert:\ndouble: Die Entfernung zwischen den Punkten A und B.\n\nBeispiele:\ncalculate_distance(0, 0, 3, 4) gibt 5 zurück",
      "ha": "Lissafi nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (double): x-kwatance na aya A.\n- ya (double): y-kwatance na aya A.\n- xb (double): x-kwatance na aya B.\n- yb (double): y-kwatance na aya B.\n\nDawowa:\ndouble: Nisan tsakanin wurare A da B.\n\nMisalai:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n\nवापसी:\ndouble: बिंदु A और B के बीच की दूरी।\n\nउदाहरण:\ncalculate_distance(0, 0, 3, 4) 5 लौटाता है।",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n\nVisszatérési érték:\ndouble: A távolság A és B pontok között.\n\nPéldák:\ncalculate_distance(0, 0, 3, 4) visszaadja 5"
    },
    "docstring_bertscore": {
      "sq": "0.9646743812544692",
      "hy": "1",
      "bn": "0.9939262802087152",
      "bg": "0.998234970434124",
      "zh": "0.968692276602043",
      "fr": "1",
      "de": "0.9948177333587997",
      "ha": "0.9969617496916904",
      "hi": "0.9935057796920643",
      "hu": "0.9604320335763261"
    }
  },
  {
    "task_id": "CPP/6",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n * \n * Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit faktorielin e N modulo 10007.\n * \n * Parametrat:\n * - N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n * \n * Kthen:\n * int: Rezultati pas llogaritjes së faktorielit të N dhe\n * marrjes së modulo 10007.\n * \n * Shembuj:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվարկում է N-ի ֆակտորիալը 10007 մոդուլով։\n * \n * Պարամետրեր:\n * - N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքագրված արժեքը (N <= 10000)։\n * \n * Վերադարձնում է:\n * int: Արդյունքը՝ N-ի ֆակտորիալը հաշվելուց և\n * 10007 մոդուլով վերցնելուց հետո։\n * \n * Օրինակներ:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N এর ফ্যাক্টরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n * \n * প্যারামিটার:\n * - N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n * \n * রিটার্নস:\n * int: N এর ফ্যাক্টরিয়াল হিসাব করার পর এবং 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n * \n * উদাহরণ:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява факториела на N по модул 10007.\n * \n * Параметри:\n * - N (int): Цяло число, представляващо входната стойност (N <= 10000).\n * \n * Връща:\n * int: Резултатът след изчисляване на факториела на N и\n * вземане на модул 10007.\n * \n * Примери:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算 N 的阶乘模 10007。\n * \n * 参数:\n * - N (int): 表示输入值的整数 (N <= 10000)。\n * \n * 返回:\n * int: 计算 N 的阶乘并取模 10007 后的结果。\n * \n * 示例:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcule la factorielle de N modulo 10007.\n * \n * Paramètres :\n * - N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n * \n * Renvoie :\n * int : Le résultat après avoir calculé la factorielle de N et\n * pris le modulo 10007.\n * \n * Exemples :\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Fakultät von N modulo 10007.\n * \n * Parameter:\n * - N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n * \n * Rückgabewert:\n * int: Das Ergebnis nach der Berechnung der Fakultät von N und\n * der Modulo-Operation mit 10007.\n * \n * Beispiele:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi na factorial na N modulo 10007.\n * \n * Sigogi:\n * - N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n * \n * Komawa:\n * int: Sakamakon bayan lissafin factorial na N da\n * ɗaukar modulo 10007.\n * \n * Misalai:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N का फैक्टोरियल 10007 से मोड्यूलो के साथ गणना करता है।\n * \n * पैरामीटर्स:\n * - N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n * \n * रिटर्न्स:\n * int: N का फैक्टोरियल गणना करने के बाद और\n * 10007 से मोड्यूलो लेने के बाद का परिणाम।\n * \n * उदाहरण:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Kiszámítja N faktoriálisát modulo 10007.\n * \n * Paraméterek:\n * - N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n * \n * Visszatér:\n * int: Az eredmény, miután kiszámítottuk N faktoriálisát és\n * vettük a modulo 10007-et.\n * \n * Példák:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.8538370395939534",
      "hy": "0.9945021096833353",
      "bn": "0.9905465842754065",
      "bg": "0.9945021096833353",
      "zh": "0.9848792622437191",
      "fr": "1",
      "de": "0.9804652979163618",
      "ha": "0.9918766133068162",
      "hi": "0.9893752609184439",
      "hu": "0.9945021096833353"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "Write a CPP function `int process_request(int n)` to solve the following problem:\nCalculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "sq": "Shkruani një funksion CPP `int process_request(int n)` për të zgjidhur problemin e mëposhtëm:  \nLlogarit faktorialin e N modulo 10007.\n\nParametrat:  \n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:  \nint: Rezultati pas llogaritjes së faktorialit të N dhe marrjes së modulo 10007.\n\nShembuj:  \n>>> process_request(1)  \n1  \n>>> process_request(10)  \n6266",
      "hy": "Գրեք CPP ֆունկցիա `int process_request(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է N-ի ֆակտորիալը մոդուլո 10007-ով։\n\nՊարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\nint: Արդյունքը N-ի ֆակտորիալը հաշվելուց հետո և\nմոդուլո 10007 վերցնելուց հետո։",
      "bn": "একটি CPP ফাংশন `int process_request(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল গণনা করে 10007 দ্বারা মডুলো করে।\n\nপ্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: N এর ফ্যাক্টোরিয়াল গণনা করে এবং 10007 দ্বারা মডুলো করার পর ফলাফল।\n\nউদাহরণ:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "bg": "Напишете CPP функция `int process_request(int n)`, за да решите следния проблем:\nИзчислява факториела на N по модул 10007.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след изчисляване на факториела на N и\nвземане на модул 10007.\n\nПримери:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "zh": "编写一个 CPP 函数 `int process_request(int n)` 来解决以下问题：\n计算 N 的阶乘对 10007 取模。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 计算 N 的阶乘并对 10007 取模后的结果。\n\n示例：\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "fr": "Écrire une fonction CPP `int process_request(int n)` pour résoudre le problème suivant :\nCalcule le factoriel de N modulo 10007.\n\nParamètres :\n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie :\nint : Le résultat après avoir calculé le factoriel de N et\nappliqué le modulo 10007.\n\nExemples :\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "de": "Schreiben Sie eine CPP-Funktion `int process_request(int n)`, um das folgende Problem zu lösen:\nBerechnet das Fakultät von N modulo 10007.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach der Berechnung des Fakultäts von N und\nder Modulo-Operation mit 10007.\n\nBeispiele:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "ha": "Rubuta aikin CPP `int process_request(int n)` don warware matsalar mai zuwa:\nLissafa factorial na N modulo 10007.\n\nSigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n\nMayarwa:\nint: Sakamakon bayan lissafin factorial na N da\ndaukar modulo 10007.\n\nMisalai:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hi": "`int process_request(int n)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nN का फैक्टोरियल 10007 से मोड्यूलो के रूप में गणना करता है।\n\nपैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n\nवापसी:\nint: N का फैक्टोरियल गणना करने के बाद और\n10007 से मोड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hu": "Írj egy CPP függvényt `int process_request(int n)` a következő probléma megoldására:\nKiszámítja N faktoriálisát modulo 10007.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket képviseli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután kiszámítottuk N faktoriálisát és\nvettük a modulo 10007-et.\n\nPéldák:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266"
    },
    "instruction_bertscore": {
      "sq": "0.9937151361136751",
      "hy": "0.9362064764141681",
      "bn": "0.9785435489798493",
      "bg": "0.9932839095564484",
      "zh": "0.9893597677487231",
      "fr": "0.9894529253974285",
      "de": "0.9614806033578093",
      "ha": "0.9838376445255722",
      "hi": "0.9878031014525527",
      "hu": "0.994431595898068"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "en": "Calculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "sq": "Llogarit faktorielin e N modulo 10007.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\nint: Rezultati pas llogaritjes së faktorielit të N dhe\nmarrjes së modulo 10007.\n\nShembuj:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hy": "Հաշվում է N-ի ֆակտորիալը մոդուլո 10007-ով։\n\nՊարամետրեր՝\n- N (int): Ընդհանուր թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է՝\nint: Արդյունքը՝ N-ի ֆակտորիալը հաշվելուց հետո և\nմոդուլո 10007 վերցնելուց հետո։\n\nՕրինակներ՝\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "bn": "N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n\nপ্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: N এর ফ্যাক্টোরিয়াল গণনা করার পর এবং 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "bg": "Изчислява факториела на N по модул 10007.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след изчисляване на факториела на N и\nвземане на модул 10007.\n\nПримери:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "zh": "计算 N 的阶乘并取模 10007。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 计算 N 的阶乘并取模 10007 后的结果。\n\n示例：\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "fr": "Calcule la factorielle de N modulo 10007.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir calculé la factorielle de N et\nappliqué le modulo 10007.\n\nExemples:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "de": "Berechnet die Fakultät von N modulo 10007.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewerte:\nint: Das Ergebnis nach der Berechnung der Fakultät von N und\nder Modulo-Operation mit 10007.\n\nBeispiele:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "ha": "Lissafi na factorial na N modulo 10007.\n\nSigogi:\n- N (int): Wani cikakken lamba wanda ke wakiltar darajar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan lissafin factorial na N da\ndaukar modulo 10007.\n\nMisalai:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hi": "N का फैक्टोरियल 10007 से मॉड्यूलो निकालता है।\n\nपैरामीटर्स:\n- N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी:\nint: N का फैक्टोरियल निकालने और 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hu": "Kiszámítja N faktoriálisát modulo 10007.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután kiszámítottuk N faktoriálisát és\nvettük a modulo 10007-et.\n\nPéldák:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266"
    },
    "docstring_bertscore": {
      "sq": "0.9910789136965801",
      "hy": "0.9769116017692666",
      "bn": "0.9640812709366992",
      "bg": "0.9939064171706117",
      "zh": "0.9453333437923401",
      "fr": "0.9869142304974216",
      "de": "0.9670776102346104",
      "ha": "0.9939064171706117",
      "hi": "0.9636087292602171",
      "hu": "0.9932588821284379"
    }
  },
  {
    "task_id": "CPP/7",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sq": "#include <bits/stdc++.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n​    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hy": "#include <bits/stdc++.h>\n/*\nՀաշվել եռանկյան մակերեսը, տրված են նրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bn": "#include <bits/stdc++.h>\n/*\nত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে এর ক্ষেত্রফল গণনা করুন।\n​    প্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n​    রিটার্নস:\n​    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bg": "#include <bits/stdc++.h>\n/*\nИзчисляване на лицето на триъгълник, дадени неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "zh": "#include <bits/stdc++.h>\n/*\n计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算的三角形面积，四舍五入到小数点后一位。\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "fr": "#include <bits/stdc++.h>\n/*\nCalculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à une décimale.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "de": "#include <bits/stdc++.h>\n/*\nBerechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "ha": "#include <bits/stdc++.h>\n/*\nƘididdige yanki na alwatika da aka ba da ginshiƙi da tsawo.\n​    Sigogi:\n- base (int): Tsawon ginshiƙin alwatika.\n- height (int): Tsawon alwatika.\n​    Mayar da:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hi": "#include <bits/stdc++.h>\n/*\nत्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n​    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​    Visszatér:\n​    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "sq": "0.9780082401029603",
      "hy": "0.9725689457487009",
      "bn": "0.9780082401029603",
      "bg": "0.9770456772764652",
      "zh": "0.9757798058581298",
      "fr": "0.9780082401029603",
      "de": "0.9759192443856164",
      "ha": "0.9757798058581298",
      "hi": "0.9753118326804117",
      "hu": "0.9689071946743227"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "en": "Write a CPP function `float calculate_triangle_area(int base, int height)` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "sq": "Shkruani një funksion CPP `float calculate_triangle_area(int base, int height)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.  \n    Parametrat:  \n- base (int): Gjatësia e bazës së trekëndëshit.  \n- height (int): Lartësia e trekëndëshit.  \n​    Kthen:  \n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.  \n    >>> calculate_triangle_area(1,2)  \n    1.0  ",
      "hy": "Գրեք CPP ֆունկցիա `float calculate_triangle_area(int base, int height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ հաշվի առնելով նրա հիմքը և բարձրությունը:\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական:\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bn": "একটি CPP ফাংশন `float calculate_triangle_area(int base, int height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n    প্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    রিটার্নস:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bg": "Напишете CPP функция `float calculate_triangle_area(int base, int height)` за решаване на следния проблем:\nИзчислете лицето на триъгълник, дадени неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до едно десетично място.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "zh": "编写一个 CPP 函数 `float calculate_triangle_area(int base, int height)` 来解决以下问题：\n计算给定底边和高的三角形面积。\n    参数：\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回：\n    float: 计算出的三角形面积，保留一位小数。\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "fr": "Écrire une fonction CPP `float calculate_triangle_area(int base, int height)` pour résoudre le problème suivant :  \nCalculer l'aire d'un triangle donné sa base et sa hauteur.  \n    Paramètres :  \n- base (int) : La longueur de la base du triangle.  \n- height (int) : La hauteur du triangle.  \n    Renvoie :  \n    float : L'aire calculée du triangle, arrondie à une décimale.  \n    >>> calculate_triangle_area(1,2)  \n    1.0  ",
      "de": "Schreiben Sie eine CPP-Funktion `float calculate_triangle_area(int base, int height)`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n​    Rückgabewert:\n​    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "ha": "Rubuta aikin CPP `float calculate_triangle_area(int base, int height)` don warware matsalar mai zuwa: \nƘididdige yanki na alwatika da aka ba da tushen sa da tsawo.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon alwatika.\n​    Dawowa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na goma.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hi": "एक CPP फ़ंक्शन `float calculate_triangle_area(int base, int height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए आधार और ऊँचाई के साथ एक त्रिभुज का क्षेत्रफल गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n​    रिटर्न्स:\n​    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hu": "Írj egy CPP függvényt `float calculate_triangle_area(int base, int height)` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatérési érték:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "instruction_bertscore": {
      "sq": "0.9812429358581134",
      "hy": "0.9812429358581134",
      "bn": "0.9738026390453086",
      "bg": "0.9844263849749596",
      "zh": "0.9796584613085981",
      "fr": "0.9844263849749596",
      "de": "0.9808671271771954",
      "ha": "0.9799142972393711",
      "hi": "0.9792028032145041",
      "hu": "0.9689693659835866"
    },
    "level": "easy",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n    Kthen:\n    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hy": "Հաշվել եռանկյան մակերեսը, տրված նրա հիմքը և բարձրությունը:\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը:\n- height (int): Եռանկյան բարձրությունը:\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական:\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bg": "Изчисляване на лицето на триъгълник, като се дадат неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，四舍五入到小数点后一位。\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n​    Renvoie:\n​    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n​    Rückgabewert:\n​    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "ha": "Ƙididdige yanki na alwatika da aka ba da ginshiƙi da tsawo.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsawo na alwatika.\n​    Komawa:\n​    float: Yankin da aka lissafa na alwatika, an zagaye zuwa wuri daya na goma.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hi": "त्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9749854829643714",
      "hy": "0.9749854829643714",
      "bn": "0.9800815440202024",
      "bg": "0.9800815440202024",
      "zh": "0.9759810184341182",
      "fr": "0.9800815440202024",
      "de": "0.9795335227989271",
      "ha": "0.9800815440202024",
      "hi": "0.9767703755683509",
      "hu": "0.970035812499363"
    }
  },
  {
    "task_id": "CPP/8",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sq": "#include <bits/stdc++.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hy": "#include <bits/stdc++.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայական ներկայացման մեջ։\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն\n​         x-ը y-ի վերածելու համար երկբայականում։\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bn": "#include <bits/stdc++.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    পরামিতি:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে\n         তার সংখ্যা।\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bg": "#include <bits/stdc++.h>\n/*\nИзчислете разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се трансформира x в y в двоична форма.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "zh": "#include <bits/stdc++.h>\n/*\n计算两个整数在二进制表示中的汉明距离。\n​    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n​    返回:\n​    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "fr": "#include <bits/stdc++.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n​    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n​    Renvoie:\n​    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n​         pour transformer x en y en binaire.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "de": "#include <bits/stdc++.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n​    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n​    Rückgabewert:\n​    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen,\n​         um x in y in binärer Form zu transformieren.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "ha": "#include <bits/stdc++.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Mayar da:\n​    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar a jujjuya\n​         don canza x zuwa y a cikin binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hi": "#include <bits/stdc++.h>\n/*\nदो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, बाइनरी में x को y में बदलने के लिए कितने बिट्स को फ्लिप करने की आवश्यकता है।\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám között bináris ábrázolásban.\n​    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n​    Visszatér:\n​    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n​         ahhoz, hogy x-et y-ra alakítsuk binárisan.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "sq": "0.9654762521027072",
      "hy": "0.9688102630483777",
      "bn": "0.9573866325742992",
      "bg": "0.9702080250397203",
      "zh": "0.9749576747110265",
      "fr": "0.9773545475189744",
      "de": "0.9733934604603768",
      "ha": "0.9639636817511265",
      "hi": "0.9588092233632711",
      "hu": "0.9695267228327705"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "en": "Write a CPP function `int hamming_distance(int x, int y)` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "sq": "Shkruani një funksion CPP `int hamming_distance(int x, int y)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth., numri i bitëve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> hamming_distance(1,2)\n    2",
      "hy": "Գրեք CPP ֆունկցիա `int hamming_distance(int x, int y)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացման մեջ։\n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ այն բիթերի քանակը, որոնք պետք է փոխվեն x-ը y-ի վերածելու համար երկբայն համակարգում։\n    >>> hamming_distance(1,2)\n    2",
      "bn": "একটি CPP ফাংশন `int hamming_distance(int x, int y)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    প্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    রিটার্নস:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> hamming_distance(1,2)\n    2",
      "bg": "Напишете CPP функция `int hamming_distance(int x, int y)`, за да решите следния проблем:\nИзчислете разстоянието на Хаминг между две цели числа в двоично представяне.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се трансформира x в y в двоична форма.\n    >>> hamming_distance(1,2)\n    2",
      "zh": "编写一个 CPP 函数 `int hamming_distance(int x, int y)` 来解决以下问题：\n计算两个整数在二进制表示中的汉明距离。\n参数：\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n返回：\nint: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n>>> hamming_distance(1,2)\n2",
      "fr": "Écrire une fonction CPP `int hamming_distance(int x, int y)` pour résoudre le problème suivant :\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres :\n- x (int) : Le premier entier positif (x <= 1,000,000,000).\n- y (int) : Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie :\n    int : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> hamming_distance(1,2)\n    2",
      "de": "Schreiben Sie eine CPP-Funktion `int hamming_distance(int x, int y)`, um das folgende Problem zu lösen:\nBerechnen Sie die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binärer Form zu transformieren.\n    >>> hamming_distance(1,2)\n    2",
      "ha": "Rubuta aikin CPP `int hamming_distance(int x, int y)` don warware matsalar mai zuwa:\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Mayarwa:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don sauya x zuwa y a cikin binary.\n    >>> hamming_distance(1,2)\n    2",
      "hi": "एक CPP फ़ंक्शन `int hamming_distance(int x, int y)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के बीच बाइनरी रूप में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच की हैमिंग दूरी, अर्थात्, बाइनरी में x को y में बदलने के लिए जितने बिट्स को फ्लिप करने की आवश्यकता है।\n    >>> hamming_distance(1,2)\n    2",
      "hu": "Írj egy CPP függvényt `int hamming_distance(int x, int y)` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni, hogy x-ből y-t kapjunk binárisan.\n    >>> hamming_distance(1,2)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9859282292859644",
      "hy": "0.9798018724437053",
      "bn": "0.9775823765660215",
      "bg": "0.9953842272055112",
      "zh": "0.9930747517652186",
      "fr": "0.9961084335747644",
      "de": "0.9922073328912393",
      "ha": "0.9847803443139638",
      "hi": "0.983579822290989",
      "hu": "0.9769948278989203"
    },
    "level": "middle",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> hamming_distance(1,2)\n    2",
      "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկուական ներկայացմամբ։ \n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք անհրաժեշտ է փոխել, որպեսզի x-ը վերածվի y-ի երկուականում։\n    >>> hamming_distance(1,2)\n    2",
      "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    Parameters:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    Returns:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> hamming_distance(1,2)\n    2",
      "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y в двоична форма.\n    >>> hamming_distance(1,2)\n    2",
      "zh": "计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转多少个位才能将 x 转换为 y。\n    >>> hamming_distance(1,2)\n    2",
      "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> hamming_distance(1,2)\n    2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binär zu transformieren.\n    >>> hamming_distance(1,2)\n    2",
      "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Dawowa:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\n    >>> hamming_distance(1,2)\n    2",
      "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जितने बिट्स को उलटना आवश्यक है।\n    >>> hamming_distance(1,2)\n    2",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-et y-ra alakítsuk binárisan.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9839339802603742",
      "hy": "0.9893726787234903",
      "bn": "0.974049735239316",
      "bg": "0.9827469651033096",
      "zh": "0.9879560468459495",
      "fr": "0.9946975619782736",
      "de": "0.9941390133468035",
      "ha": "0.988055163406086",
      "hi": "0.9802150236362579",
      "hu": "0.9730160627364104"
    }
  },
  {
    "task_id": "CPP/9",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.\n * Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3\n */\nint count_odd_numbers(int count, ...)",
      "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n * Parametrat:\n * - count (int): Numri i numrave për të vlerësuar.\n * - ... (int): Një sekuencë numrash.\n * Kthen:\n *   int: Numri i numrave tek në listën e hyrjes.\n * Përdorimi:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) duhet të kthejë 3\n */\nint count_odd_numbers(int count, ...)",
      "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n * Պարամետրեր:\n * - count (int): Գնահատվող ամբողջ թվերի քանակը։\n * - ... (int): Ամբողջ թվերի հաջորդականություն։\n * Վերադարձնում է:\n *   int: Մուտքային ցուցակի կենտ թվերի քանակը։\n * Օգտագործում:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3\n */\nint count_odd_numbers(int count, ...)",
      "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n * প্যারামিটারসমূহ:\n * - count (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার সংখ্যা।\n * - ... (int): পূর্ণসংখ্যার একটি ক্রম।\n * রিটার্ন করে:\n *   int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n * ব্যবহার:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) 3 রিটার্ন করা উচিত\n */\nint count_odd_numbers(int count, ...)",
      "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Преброява броя на нечетните цели числа в даден списък от числа.\n * Параметри:\n * - count (int): Броят на целите числа за оценка.\n * - ... (int): Последователност от цели числа.\n * Връща:\n *   int: Броят на нечетните числа в входния списък.\n * Употреба:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) трябва да върне 3\n */\nint count_odd_numbers(int count, ...)",
      "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 计算给定数字列表中奇数的数量。\n * 参数:\n * - count (int): 要评估的整数数量。\n * - ... (int): 一系列整数。\n * 返回:\n *   int: 输入列表中奇数的数量。\n * 用法:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) 应返回 3\n */\nint count_odd_numbers(int count, ...)",
      "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n * Paramètres :\n * - count (int) : Le nombre d'entiers à évaluer.\n * - ... (int) : Une séquence d'entiers.\n * Retourne :\n *   int : Le nombre d'entiers impairs dans la liste d'entrée.\n * Utilisation :\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) devrait retourner 3\n */\nint count_odd_numbers(int count, ...)",
      "de": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Zählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n * Parameter:\n * - count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n * - ... (int): Eine Sequenz von Ganzzahlen.\n * Rückgabewert:\n *   int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n * Verwendung:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben\n */\nint count_odd_numbers(int count, ...)",
      "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n * Sigogi:\n * - count (int): Yawan lambobin da za a tantance.\n * - ... (int): Jerin lambobi.\n * Komawa:\n *   int: Adadin lambobin da ba su da ma'aurata a cikin jerin shigarwa.\n * Amfani:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3\n */\nint count_odd_numbers(int count, ...)",
      "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * दी गई संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n * पैरामीटर्स:\n * - count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।\n * - ... (int): पूर्णांकों की एक अनुक्रम।\n * रिटर्न करता है:\n *   int: इनपुट सूची में विषम संख्याओं की गिनती।\n * उपयोग:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए\n */\nint count_odd_numbers(int count, ...)",
      "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Számolja meg a páratlan egész számok számát egy adott számok listájában.\n * Paraméterek:\n * - count (int): Az értékelendő egész számok száma.\n * - ... (int): Egy egész számok sorozata.\n * Visszatér:\n *   int: A páratlan számok száma a bemeneti listában.\n * Használat:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) vissza kell adja a 3-at\n */\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9814411689783863",
      "hy": "0.9945495823444027",
      "bn": "0.9945495823444027",
      "bg": "0.9924609838878208",
      "zh": "0.983551815407263",
      "fr": "0.995115083039209",
      "de": "0.9853867628672632",
      "ha": "0.9756393741787383",
      "hi": "0.9980093263212684",
      "hu": "0.9896964462445772"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `int count_odd_numbers(int count, ...)` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3",
      "sq": "Shkruani një funksion CPP `int count_odd_numbers(int count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e numrave tek në një listë të dhënë numrash.\nParametrat:\n- count (int): Numri i numrave për të vlerësuar.\n- ... (int): Një sekuencë numrash të plotë.\nKthen:\n  int: Numri i numrave tek në listën e dhënë.\nPërdorimi:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) duhet të kthejë 3",
      "hy": "Գրեք CPP ֆունկցիա `int count_odd_numbers(int count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք կենտ ամբողջ թվերի քանակը տրված թվերի ցուցակում:\nՊարամետրեր:\n- count (int): Ամբողջ թվերի քանակը, որոնք պետք է գնահատել:\n- ... (int): Ամբողջ թվերի հաջորդականություն:\nՎերադարձնում է:\n  int: Կենտ թվերի քանակը մուտքագրված ցուցակում:\nՕգտագործում:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3",
      "bn": "একটি CPP ফাংশন `int count_odd_numbers(int count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া সংখ্যার একটি তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\nরিটার্নস:\n  int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\nব্যবহার:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 রিটার্ন করা উচিত।",
      "bg": "Напишете CPP функция `int count_odd_numbers(int count, ...)`, за да решите следния проблем:  \nПребройте броя на нечетните цели числа в даден списък от числа.  \nПараметри:  \n- count (int): Броят на целите числа за оценка.  \n- ... (int): Последователност от цели числа.  \nВръща:  \n  int: Броят на нечетните числа в списъка с входни данни.  \nУпотреба:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) трябва да върне 3",
      "zh": "编写一个 CPP 函数 `int count_odd_numbers(int count, ...)` 来解决以下问题：\n统计给定数字列表中奇数的数量。\n参数：\n- count (int): 要评估的整数数量。\n- ... (int): 一系列整数。\n返回：\n  int: 输入列表中奇数的数量。\n用法：\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 应返回 3。",
      "fr": "Écrire une fonction CPP `int count_odd_numbers(int count, ...)` pour résoudre le problème suivant :  \nCompter le nombre d'entiers impairs dans une liste donnée de nombres.  \nParamètres :  \n- count (int) : Le nombre d'entiers à évaluer.  \n- ... (int) : Une séquence d'entiers.  \nRenvoie :  \n  int : Le nombre d'entiers impairs dans la liste d'entrée.  \nUtilisation :  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) devrait retourner 3",
      "de": "Schreiben Sie eine CPP-Funktion `int count_odd_numbers(int count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\nParameter:\n- count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\nGibt zurück:\n  int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\nVerwendung:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben.",
      "ha": "Rubuta aikin CPP `int count_odd_numbers(int count, ...)` don warware matsalar mai zuwa:\nƘididdige adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\nSigogi:\n- count (int): Yawan lambobin da za a tantance.\n- ... (int): Jeri na lambobi.\nYa dawo:\n  int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\nAmfani:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3",
      "hi": "एक CPP फ़ंक्शन `int count_odd_numbers(int count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।\n- ... (int): पूर्णांकों का अनुक्रम।\nरिटर्न करता है:\n  int: इनपुट सूची में विषम संख्याओं की गिनती।\nउपयोग:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 लौटाना चाहिए।",
      "hu": "Írj egy CPP függvényt `int count_odd_numbers(int count, ...)` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\nParaméterek:\n- count (int): Az értékelendő egész számok száma.\n- ... (int): Egy egész számok sorozata.\nVisszatérési érték:\n  int: A bemeneti listában található páratlan számok száma.\nHasználat:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) vissza kell adja a 3-at."
    },
    "instruction_bertscore": {
      "sq": "0.9824591496811901",
      "hy": "0.9963028927177976",
      "bn": "0.9955387616419564",
      "bg": "0.9963028927177976",
      "zh": "0.9903400086791303",
      "fr": "0.9946683633122615",
      "de": "0.9913808318757531",
      "ha": "0.976782492021594",
      "hi": "0.9948326306373774",
      "hu": "0.9860646883577353"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.  \nParametrat:  \n- count (int): Numri i numrave për të vlerësuar.  \n- ... (int): Një sekuencë numrash të plotë.  \nKthen:  \n  int: Numri i numrave tek në listën e dhënë.  \nPërdorimi:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) duhet të kthejë 3  ",
      "hy": "Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\nՊարամետրեր՝\n- count (int): Ամբողջ թվերի քանակը գնահատելու համար։\n- ... (int): Ամբողջ թվերի հաջորդականություն։\nՎերադարձնում է՝\n  int: Կենտ թվերի քանակը մուտքագրված ցուցակում։\nՕգտագործում՝\n  count_odd_numbers(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3",
      "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার পূর্ণসংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\nফেরত দেয়:\n  int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\nব্যবহার:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 ফেরত দেবে।",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\nПараметри:\n- count (int): Броят на целите числа за оценка.\n- ... (int): Последователност от цели числа.\nВръща:\n  int: Броят на нечетните числа в входния списък.\nИзползване:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) трябва да върне 3",
      "zh": "计算给定数字列表中奇数的数量。\n参数：\n- count (int): 要评估的整数数量。\n- ... (int): 一系列整数。\n返回：\n  int: 输入列表中奇数的数量。\n用法：\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 应返回 3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\nParamètres:\n- count (int): Le nombre d'entiers à évaluer.\n- ... (int): Une séquence d'entiers.\nRenvoie:\n  int: Le nombre d'entiers impairs dans la liste d'entrée.\nUtilisation:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) devrait renvoyer 3",
      "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\nParameter:\n- count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\nRückgabe:\n  int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\nVerwendung:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben.",
      "ha": "Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\nParameters:  \n- count (int): Yawan lambobin da za a tantance.  \n- ... (int): Jerin lambobi.  \nReturns:  \n  int: Yawan lambobin da ba su da ma'ana a cikin jerin shigarwa.  \nUsage:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3",
      "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।  \nपैरामीटर्स:  \n- count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।  \n- ... (int): पूर्णांकों का अनुक्रम।  \nरिटर्न्स:  \n  int: इनपुट सूची में विषम संख्याओं की गिनती।  \nउपयोग:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए।",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\nParaméterek:\n- count (int): Az értékelendő egész számok száma.\n- ... (int): Egy egész számok sorozata.\nVisszatér:\n  int: A páratlan számok száma a bemeneti listában.\nHasználat:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) esetén az eredmény 3 kell legyen."
    },
    "docstring_bertscore": {
      "sq": "0.9775881368470715",
      "hy": "0.9482208336414443",
      "bn": "0.9642040245121787",
      "bg": "0.9885126091736093",
      "zh": "0.9755086753880172",
      "fr": "0.9930342311674875",
      "de": "0.9876040738107558",
      "ha": "0.9651310325004685",
      "hi": "0.9515852350354133",
      "hu": "0.9647399292802108"
    }
  },
  {
    "task_id": "CPP/10",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculate the sum of even numbers in a given array.\n * \n * Parameters:\n * - numbers (vector<int>): A vector of integers.\n * - size (int): The size of the array.\n * \n * Returns:\n * int: The sum of even numbers in the input array.\n * \n * Examples:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Llogarit shumën e numrave çift në një varg të dhënë.\n * \n * Parametrat:\n * - numbers (vector<int>): Një vektor i numrave të plotë.\n * - size (int): Madhësia e vargut.\n * \n * Kthen:\n * int: Shuma e numrave çift në vargun hyrës.\n * \n * Shembuj:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Հաշվել տրված զանգվածի զույգ թվերի գումարը։\n * \n * Պարամետրեր:\n * - numbers (vector<int>): Թվերի վեկտոր։\n * - size (int): Զանգվածի չափը։\n * \n * Վերադարձնում է:\n * int: Մուտքային զանգվածի զույգ թվերի գումարը։\n * \n * Օրինակներ:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * প্রদত্ত অ্যারেতে জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n * \n * প্যারামিটার:\n * - numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n * - size (int): অ্যারের আকার।\n * \n * রিটার্নস:\n * int: ইনপুট অ্যারেতে জোড় সংখ্যাগুলির যোগফল।\n * \n * উদাহরণ:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Изчислява сумата на четните числа в даден масив.\n * \n * Параметри:\n * - numbers (vector<int>): Вектор от цели числа.\n * - size (int): Размерът на масива.\n * \n * Връща:\n * int: Сумата на четните числа в входния масив.\n * \n * Примери:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 计算给定数组中偶数的和。\n * \n * 参数:\n * - numbers (vector<int>): 整数向量。\n * - size (int): 数组的大小。\n * \n * 返回:\n * int: 输入数组中偶数的和。\n * \n * 示例:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculer la somme des nombres pairs dans un tableau donné.\n * \n * Paramètres :\n * - numbers (vector<int>): Un vecteur d'entiers.\n * - size (int): La taille du tableau.\n * \n * Renvoie :\n * int : La somme des nombres pairs dans le tableau d'entrée.\n * \n * Exemples :\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Berechnet die Summe der geraden Zahlen in einem gegebenen Array.\n * \n * Parameter:\n * - numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n * - size (int): Die Größe des Arrays.\n * \n * Rückgabewert:\n * int: Die Summe der geraden Zahlen im Eingabearray.\n * \n * Beispiele:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Lissafa jimillar lambobin da suka zama lamba biyu a cikin jerin da aka bayar.\n * \n * Sigogi:\n * - numbers (vector<int>): Wani vector na lambobi.\n * - size (int): Girman jerin.\n * \n * Komawa:\n * int: Jimillar lambobin da suka zama lamba biyu a cikin jerin shigarwa.\n * \n * Misalai:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए array में सम संख्याओं का योग गणना करें।\n * \n * पैरामीटर्स:\n * - numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n * - size (int): array का आकार।\n * \n * रिटर्न करता है:\n * int: इनपुट array में सम संख्याओं का योग।\n * \n * उदाहरण:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Számolja ki a páros számok összegét egy adott tömbben.\n * \n * Paraméterek:\n * - numbers (vector<int>): Egész számokat tartalmazó vektor.\n * - size (int): A tömb mérete.\n * \n * Visszatérési érték:\n * int: A bemeneti tömbben lévő páros számok összege.\n * \n * Példák:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)"
    },
    "prompt_bertscore": {
      "sq": "0.9987657108122492",
      "hy": "0.9773835475546055",
      "bn": "0.9966910164823398",
      "bg": "0.9840036995241174",
      "zh": "0.9731995972084867",
      "fr": "0.9977868602945092",
      "de": "0.9861949898876943",
      "ha": "0.9610265343067635",
      "hi": "0.9872896419175775",
      "hu": "0.98817493752585"
    },
    "canonical_solution": "{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `int calculate_even_sum(const std::vector<int>& numbers)` to solve the following problem:\nCalculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6\n",
      "sq": "Shkruani një funksion CPP `int calculate_even_sum(const std::vector<int>& numbers)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni shumën e numrave çift në një varg të dhënë.\n\nParametrat:  \n- numbers (vector<int>): Një vektor i numrave të plotë.\n\nKthen:  \nint: Shuma e numrave çift në vargun e dhënë.\n\nShembuj:  \n>>> calculate_even_sum({1,4,3,2,5}, 5)  \n6  ",
      "hy": "Գրեք CPP ֆունկցիա `int calculate_even_sum(const std::vector<int>& numbers)` հետևյալ խնդիրը լուծելու համար:\nՀաշվել տրված զանգվածում զույգ թվերի գումարը:\n\nՊարամետրեր:\n- numbers (vector<int>): Թվերի վեկտոր:\n\nՎերադարձնում է:\nint: Մուտքային զանգվածի զույգ թվերի գումարը:\n\nՕրինակներ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "bn": "একটি CPP ফাংশন `int calculate_even_sum(const std::vector<int>& numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অ্যারের জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n\nরিটার্নস:\nint: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\n\nউদাহরণসমূহ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "bg": "Напишете CPP функция `int calculate_even_sum(const std::vector<int>& numbers)`, за да решите следния проблем:\nИзчислете сумата на четните числа в даден масив.\n\nПараметри:\n- numbers (vector<int>): Вектор от цели числа.\n\nВръща:\nint: Сумата на четните числа в входния масив.\n\nПримери:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "zh": "编写一个 CPP 函数 `int calculate_even_sum(const std::vector<int>& numbers)` 来解决以下问题：\n计算给定数组中偶数的和。\n\n参数：\n- numbers (vector<int>): 整数向量。\n\n返回：\nint: 输入数组中偶数的和。\n\n示例：\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "fr": "Écrire une fonction CPP `int calculate_even_sum(const std::vector<int>& numbers)` pour résoudre le problème suivant :  \nCalculer la somme des nombres pairs dans un tableau donné.\n\nParamètres :  \n- numbers (vector<int>) : Un vecteur d'entiers.\n\nRenvoie :  \nint : La somme des nombres pairs dans le tableau d'entrée.\n\nExemples :  \n>>> calculate_even_sum({1,4,3,2,5}, 5)  \n6  ",
      "de": "Schreiben Sie eine CPP-Funktion `int calculate_even_sum(const std::vector<int>& numbers)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einem gegebenen Array.\n\nParameter:\n- numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "ha": "Rubuta aikin CPP `int calculate_even_sum(const std::vector<int>& numbers)` don warware matsalar mai zuwa:  \nƘididdige jumlar lambobin da suka yi maiko a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- numbers (vector<int>): Wani vector na lambobi.\n\nDawowa:\nint: Jumlar lambobin da suka yi maiko a cikin jerin lambobi da aka shigar.\n\nMisalai:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hi": "एक CPP फ़ंक्शन `int calculate_even_sum(const std::vector<int>& numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए array में सम संख्याओं का योग गणना करें।\n\nParameters:\n- numbers (vector<int>): पूर्णांकों का एक vector।\n\nReturns:\nint: इनपुट array में सम संख्याओं का योग।\n\nExamples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hu": "Írj egy CPP függvényt `int calculate_even_sum(const std::vector<int>& numbers)` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott tömbben.\n\nParaméterek:\n- numbers (vector<int>): Egész számokat tartalmazó vektor.\n\nVisszatérési érték:\nint: A bemeneti tömbben található páros számok összege.\n\nPéldák:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6"
    },
    "instruction_bertscore": {
      "sq": "0.9920015518164871",
      "hy": "0.9594722515751656",
      "bn": "0.9964262421844203",
      "bg": "0.9860104622637128",
      "zh": "0.9858392428752607",
      "fr": "0.9936527661740302",
      "de": "0.9851797900102249",
      "ha": "0.9697388600797158",
      "hi": "0.9969551948891162",
      "hu": "0.9867479768684954"
    },
    "level": "easy",
    "test": "int main() {\n    std::vector<int> sample1 = {1, 4, 3, 2, 5};\n    std::vector<int> sample2 = {2, 2, 0, 0};\n    std::vector<int> sample3 = {7, 11, 19}; // Additional test with no even numbers\n    std::vector<int> sample4 = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1) == 6);\n    assert(calculate_even_sum(sample2) == 4);\n    assert(calculate_even_sum(sample3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4) == 12 + 14 + 16 + 18 + 20);\n\n    // std::cout << \"All tests passed successfully.\\n\";\n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(const std::vector<int>& numbers)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6\n",
      "sq": "Llogarit shumën e numrave çift në një varg të dhënë.\n\nParametrat:\n- numbers (vector<int>): Një vektor i numrave të plotë.\n\nKthen:\nint: Shuma e numrave çift në vargun hyrës.\n\nShembuj:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hy": "Հաշվել տրված զանգվածում զույգ թվերի գումարը։\n\nՊարամետրեր:\n- numbers (vector<int>): Ամբողջ թվերի վեկտոր։\n\nՎերադարձնում է:\nint: Մուտքագրված զանգվածի զույգ թվերի գումարը։\n\nՕրինակներ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "bn": "দেওয়া অ্যারেতে জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n\nফেরত দেয়:\nint: ইনপুট অ্যারেতে জোড় সংখ্যাগুলোর যোগফল।\n\nউদাহরণ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "bg": "Изчисляване на сумата от четни числа в даден масив.\n\nПараметри:\n- numbers (vector<int>): Вектор от цели числа.\n\nВръща:\nint: Сумата от четните числа в входния масив.\n\nПримери:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "zh": "计算给定数组中偶数的和。\n\n参数：\n- numbers (vector<int>): 一个整数向量。\n\n返回：\nint: 输入数组中偶数的和。\n\n示例：\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "fr": "Calculer la somme des nombres pairs dans un tableau donné.\n\nParamètres:\n- numbers (vector<int>): Un vecteur d'entiers.\n\nRenvoie:\nint: La somme des nombres pairs dans le tableau d'entrée.\n\nExemples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "de": "Berechnen Sie die Summe der geraden Zahlen in einem gegebenen Array.\n\nParameter:\n- numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "ha": "Lissafa jimillar lambobin da suka zama lamba biyu a cikin jerin da aka bayar.\n\nMa'auni:\n- numbers (vector<int>): Wata vector na lambobi.\n\nDawowa:\nint: Jimillar lambobin da suka kasance ma'aurata a cikin jerin lambobin shigarwa.\n\nMisalai:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hi": "दिए गए ऐरे में सम संख्या का योग गणना करें।\n\nपैरामीटर्स:\n- numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n\nरिटर्न्स:\nint: इनपुट ऐरे में सम संख्याओं का योग।\n\nउदाहरण:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hu": "Számítsa ki a páros számok összegét egy adott tömbben.\n\nParaméterek:\n- numbers (vector<int>): Egész számok vektora.\n\nVisszatérési érték:\nint: A bemeneti tömbben lévő páros számok összege.\n\nPéldák:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9954779807453598",
      "bn": "0.9930731627221704",
      "bg": "0.9888043972033496",
      "zh": "0.9975447298600277",
      "fr": "1",
      "de": "0.9813990593376068",
      "ha": "0.9602117524837585",
      "hi": "0.9864371203221758",
      "hu": "0.9925769840303452"
    }
  },
  {
    "task_id": "CPP/11",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Determines if two closed intervals intersect.\n *\n * @param a The lower bound of the first closed interval [a,b].\n * @param b The upper bound of the first closed interval [a,b].\n * @param c The lower bound of the second closed interval [c,d].\n * @param d The upper bound of the second closed interval [c,d].\n *\n * @return 1 if the intervals intersect, 0 otherwise.\n *\n * Examples:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Përcakton nëse dy intervale të mbyllura ndërpriten.\n *\n * @param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n * @param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n * @param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n * @param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n *\n * @return 1 nëse intervalet ndërpriten, 0 përndryshe.\n *\n * Shembuj:\n * are_intervals_intersecting(1, 1, 1, 2) kthen 1\n * are_intervals_intersecting(3, 5, 2, 6) kthen 1\n * are_intervals_intersecting(3, 5, 4, 7) kthen 1\n * are_intervals_intersecting(3, 5, 6, 7) kthen 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Սահմանում է՝ արդյոք երկու փակ միջակայքերը հատվում են։\n *\n * @param a Առաջին փակ միջակայքի ստորին սահմանը [a,b]։\n * @param b Առաջին փակ միջակայքի վերին սահմանը [a,b]։\n * @param c Երկրորդ փակ միջակայքի ստորին սահմանը [c,d]։\n * @param d Երկրորդ փակ միջակայքի վերին սահմանը [c,d]։\n *\n * @return 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n *\n * Օրինակներ:\n * are_intervals_intersecting(1, 1, 1, 2) վերադարձնում է 1\n * are_intervals_intersecting(3, 5, 2, 6) վերադարձնում է 1\n * are_intervals_intersecting(3, 5, 4, 7) վերադարձնում է 1\n * are_intervals_intersecting(3, 5, 6, 7) վերադարձնում է 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n *\n * @param a প্রথম বন্ধ ইন্টারভাল [a,b] এর নিম্ন সীমা।\n * @param b প্রথম বন্ধ ইন্টারভাল [a,b] এর উপরের সীমা।\n * @param c দ্বিতীয় বন্ধ ইন্টারভাল [c,d] এর নিম্ন সীমা।\n * @param d দ্বিতীয় বন্ধ ইন্টারভাল [c,d] এর উপরের সীমা।\n *\n * @return ইন্টারভালগুলি অতিক্রম করলে 1, অন্যথায় 0।\n *\n * উদাহরণ:\n * are_intervals_intersecting(1, 1, 1, 2) 1 প্রদান করে\n * are_intervals_intersecting(3, 5, 2, 6) 1 প্রদান করে\n * are_intervals_intersecting(3, 5, 4, 7) 1 প্রদান করে\n * are_intervals_intersecting(3, 5, 6, 7) 0 প্রদান করে\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Определя дали два затворени интервала се пресичат.\n *\n * @param a Долна граница на първия затворен интервал [a,b].\n * @param b Горна граница на първия затворен интервал [a,b].\n * @param c Долна граница на втория затворен интервал [c,d].\n * @param d Горна граница на втория затворен интервал [c,d].\n *\n * @return 1 ако интервалите се пресичат, 0 в противен случай.\n *\n * Примери:\n * are_intervals_intersecting(1, 1, 1, 2) връща 1\n * are_intervals_intersecting(3, 5, 2, 6) връща 1\n * are_intervals_intersecting(3, 5, 4, 7) връща 1\n * are_intervals_intersecting(3, 5, 6, 7) връща 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 确定两个闭区间是否相交。\n *\n * @param a 第一个闭区间 [a,b] 的下界。\n * @param b 第一个闭区间 [a,b] 的上界。\n * @param c 第二个闭区间 [c,d] 的下界。\n * @param d 第二个闭区间 [c,d] 的上界。\n *\n * @return 如果区间相交返回 1，否则返回 0。\n *\n * 示例:\n * are_intervals_intersecting(1, 1, 1, 2) 返回 1\n * are_intervals_intersecting(3, 5, 2, 6) 返回 1\n * are_intervals_intersecting(3, 5, 4, 7) 返回 1\n * are_intervals_intersecting(3, 5, 6, 7) 返回 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Détermine si deux intervalles fermés s'intersectent.\n *\n * @param a La borne inférieure du premier intervalle fermé [a,b].\n * @param b La borne supérieure du premier intervalle fermé [a,b].\n * @param c La borne inférieure du second intervalle fermé [c,d].\n * @param d La borne supérieure du second intervalle fermé [c,d].\n *\n * @return 1 si les intervalles s'intersectent, 0 sinon.\n *\n * Exemples :\n * are_intervals_intersecting(1, 1, 1, 2) retourne 1\n * are_intervals_intersecting(3, 5, 2, 6) retourne 1\n * are_intervals_intersecting(3, 5, 4, 7) retourne 1\n * are_intervals_intersecting(3, 5, 6, 7) retourne 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Bestimmt, ob zwei geschlossene Intervalle sich überschneiden.\n *\n * @param a Die Untergrenze des ersten geschlossenen Intervalls [a,b].\n * @param b Die Obergrenze des ersten geschlossenen Intervalls [a,b].\n * @param c Die Untergrenze des zweiten geschlossenen Intervalls [c,d].\n * @param d Die Obergrenze des zweiten geschlossenen Intervalls [c,d].\n *\n * @return 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n *\n * Beispiele:\n * are_intervals_intersecting(1, 1, 1, 2) gibt 1 zurück\n * are_intervals_intersecting(3, 5, 2, 6) gibt 1 zurück\n * are_intervals_intersecting(3, 5, 4, 7) gibt 1 zurück\n * are_intervals_intersecting(3, 5, 6, 7) gibt 0 zurück\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Yana tantance idan tazara biyu masu rufe suna hade.\n *\n * @param a Iyakacin kasa na tazara na farko mai rufe [a,b].\n * @param b Iyakacin sama na tazara na farko mai rufe [a,b].\n * @param c Iyakacin kasa na tazara na biyu mai rufe [c,d].\n * @param d Iyakacin sama na tazara na biyu mai rufe [c,d].\n *\n * @return 1 idan tazaran suna hade, 0 in ba haka ba.\n *\n * Misalai:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह निर्धारित करता है कि दो बंद अंतराल एक-दूसरे से मिलते हैं या नहीं।\n *\n * @param a पहले बंद अंतराल [a,b] की निचली सीमा।\n * @param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n * @param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n * @param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n *\n * @return 1 यदि अंतराल मिलते हैं, अन्यथा 0।\n *\n * उदाहरण:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Meghatározza, hogy két zárt intervallum metszi-e egymást.\n *\n * @param a Az első zárt intervallum alsó határa [a,b].\n * @param b Az első zárt intervallum felső határa [a,b].\n * @param c A második zárt intervallum alsó határa [c,d].\n * @param d A második zárt intervallum felső határa [c,d].\n *\n * @return 1, ha az intervallumok metszik egymást, különben 0.\n *\n * Példák:\n * are_intervals_intersecting(1, 1, 1, 2) visszaadja 1\n * are_intervals_intersecting(3, 5, 2, 6) visszaadja 1\n * are_intervals_intersecting(3, 5, 4, 7) visszaadja 1\n * are_intervals_intersecting(3, 5, 6, 7) visszaadja 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9753777779669153",
      "hy": "0.9748899417510936",
      "bn": "0.9711537042838273",
      "bg": "0.9748899417510936",
      "zh": "0.9671516993667364",
      "fr": "1",
      "de": "0.9993643827806884",
      "ha": "0.9753777779669153",
      "hi": "0.9773122392478141",
      "hu": "0.9978240041757628"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `int are_intervals_intersecting(int a, int b, int c, int d)` to solve the following problem:\nDetermines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0\n",
      "sq": "Shkruani një funksion CPP `int are_intervals_intersecting(int a, int b, int c, int d)` për të zgjidhur problemin e mëposhtëm:  \nPërcakton nëse dy intervale të mbyllura ndërpriten.\n\n@param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].  \n@param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].  \n@param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].  \n@param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n\n@return 1 nëse intervalet ndërpriten, 0 përndryshe.\n\nShembuj:  \nare_intervals_intersecting(1, 1, 1, 2) kthen 1  \nare_intervals_intersecting(3, 5, 2, 6) kthen 1  \nare_intervals_intersecting(3, 5, 4, 7) kthen 1  \nare_intervals_intersecting(3, 5, 6, 7) kthen 0  ",
      "hy": "Գրեք CPP ֆունկցիա `int are_intervals_intersecting(int a, int b, int c, int d)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է՝ արդյոք երկու փակ միջակայքերը հատվում են:\n\n@param a Առաջին փակ միջակայքի [a,b] ստորին սահմանը:\n@param b Առաջին փակ միջակայքի [a,b] վերին սահմանը:\n@param c Երկրորդ փակ միջակայքի [c,d] ստորին սահմանը:\n@param d Երկրորդ փակ միջակայքի [c,d] վերին սահմանը:\n\n@return 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:\n\nՕրինակներ:\nare_intervals_intersecting(1, 1, 1, 2) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 2, 6) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 4, 7) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 6, 7) վերադարձնում է 0",
      "bn": "একটি CPP ফাংশন `int are_intervals_intersecting(int a, int b, int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nদুটি বন্ধ অন্তরাল পরস্পর ছেদ করে কিনা তা নির্ধারণ করে।\n\n@param a প্রথম বন্ধ অন্তরাল [a,b] এর নিম্ন সীমা।\n@param b প্রথম বন্ধ অন্তরাল [a,b] এর ঊর্ধ্ব সীমা।\n@param c দ্বিতীয় বন্ধ অন্তরাল [c,d] এর নিম্ন সীমা।\n@param d দ্বিতীয় বন্ধ অন্তরাল [c,d] এর ঊর্ধ্ব সীমা।\n\n@return 1 যদি অন্তরালগুলি ছেদ করে, অন্যথায় 0।\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "bg": "Напишете CPP функция `int are_intervals_intersecting(int a, int b, int c, int d)`, за да решите следния проблем:\nОпределя дали два затворени интервала се пресичат.\n\n@param a Долна граница на първия затворен интервал [a,b].\n@param b Горна граница на първия затворен интервал [a,b].\n@param c Долна граница на втория затворен интервал [c,d].\n@param d Горна граница на втория затворен интервал [c,d].\n\n@return 1 ако интервалите се пресичат, 0 в противен случай.\n\nПримери:\nare_intervals_intersecting(1, 1, 1, 2) връща 1\nare_intervals_intersecting(3, 5, 2, 6) връща 1\nare_intervals_intersecting(3, 5, 4, 7) връща 1\nare_intervals_intersecting(3, 5, 6, 7) връща 0",
      "zh": "编写一个 CPP 函数 `int are_intervals_intersecting(int a, int b, int c, int d)` 来解决以下问题：\n确定两个闭区间是否相交。\n\n@param a 第一个闭区间 [a,b] 的下界。\n@param b 第一个闭区间 [a,b] 的上界。\n@param c 第二个闭区间 [c,d] 的下界。\n@param d 第二个闭区间 [c,d] 的上界。\n\n@return 如果区间相交则返回 1，否则返回 0。\n\n示例：\nare_intervals_intersecting(1, 1, 1, 2) 返回 1\nare_intervals_intersecting(3, 5, 2, 6) 返回 1\nare_intervals_intersecting(3, 5, 4, 7) 返回 1\nare_intervals_intersecting(3, 5, 6, 7) 返回 0",
      "fr": "Écrire une fonction CPP `int are_intervals_intersecting(int a, int b, int c, int d)` pour résoudre le problème suivant :  \nDétermine si deux intervalles fermés s'intersectent.\n\n@param a La borne inférieure du premier intervalle fermé [a,b].  \n@param b La borne supérieure du premier intervalle fermé [a,b].  \n@param c La borne inférieure du second intervalle fermé [c,d].  \n@param d La borne supérieure du second intervalle fermé [c,d].\n\n@return 1 si les intervalles s'intersectent, 0 sinon.\n\nExemples :  \nare_intervals_intersecting(1, 1, 1, 2) retourne 1  \nare_intervals_intersecting(3, 5, 2, 6) retourne 1  \nare_intervals_intersecting(3, 5, 4, 7) retourne 1  \nare_intervals_intersecting(3, 5, 6, 7) retourne 0  ",
      "de": "Schreiben Sie eine CPP-Funktion `int are_intervals_intersecting(int a, int b, int c, int d)`, um das folgende Problem zu lösen:\nBestimmt, ob zwei geschlossene Intervalle sich überschneiden.\n\n@param a Die untere Grenze des ersten geschlossenen Intervalls [a,b].\n@param b Die obere Grenze des ersten geschlossenen Intervalls [a,b].\n@param c Die untere Grenze des zweiten geschlossenen Intervalls [c,d].\n@param d Die obere Grenze des zweiten geschlossenen Intervalls [c,d].\n\n@return 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n\nBeispiele:\nare_intervals_intersecting(1, 1, 1, 2) gibt 1 zurück\nare_intervals_intersecting(3, 5, 2, 6) gibt 1 zurück\nare_intervals_intersecting(3, 5, 4, 7) gibt 1 zurück\nare_intervals_intersecting(3, 5, 6, 7) gibt 0 zurück",
      "ha": "Rubuta aikin CPP `int are_intervals_intersecting(int a, int b, int c, int d)` don warware matsalar mai zuwa:\nYana tantance idan tazara biyu masu rufe suna haduwa.\n\n@param a Ƙananan iyaka na tazara na farko mai rufe [a,b].\n@param b Babban iyaka na tazara na farko mai rufe [a,b].\n@param c Ƙananan iyaka na tazara na biyu mai rufe [c,d].\n@param d Babban iyaka na tazara na biyu mai rufe [c,d].\n\n@return 1 idan tazarar suna haduwa, 0 in ba haka ba.\n\nMisalai:\nare_intervals_intersecting(1, 1, 1, 2) yana dawowa 1\nare_intervals_intersecting(3, 5, 2, 6) yana dawowa 1\nare_intervals_intersecting(3, 5, 4, 7) yana dawowa 1\nare_intervals_intersecting(3, 5, 6, 7) yana dawowa 0",
      "hi": "एक CPP फ़ंक्शन `int are_intervals_intersecting(int a, int b, int c, int d)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करता है कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n\n@param a पहले बंद अंतराल [a,b] की निचली सीमा।\n@param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n@param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n@param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n\n@return 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n\nउदाहरण:\nare_intervals_intersecting(1, 1, 1, 2) 1 लौटाता है\nare_intervals_intersecting(3, 5, 2, 6) 1 लौटाता है\nare_intervals_intersecting(3, 5, 4, 7) 1 लौटाता है\nare_intervals_intersecting(3, 5, 6, 7) 0 लौटाता है",
      "hu": "Írj egy CPP függvényt `int are_intervals_intersecting(int a, int b, int c, int d)` a következő probléma megoldására:\nMeghatározza, hogy két zárt intervallum metszi-e egymást.\n\n@param a Az első zárt intervallum [a,b] alsó határa.\n@param b Az első zárt intervallum [a,b] felső határa.\n@param c A második zárt intervallum [c,d] alsó határa.\n@param d A második zárt intervallum [c,d] felső határa.\n\n@return 1, ha az intervallumok metszik egymást, 0 különben.\n\nPéldák:\nare_intervals_intersecting(1, 1, 1, 2) visszatér 1\nare_intervals_intersecting(3, 5, 2, 6) visszatér 1\nare_intervals_intersecting(3, 5, 4, 7) visszatér 1\nare_intervals_intersecting(3, 5, 6, 7) visszatér 0"
    },
    "instruction_bertscore": {
      "sq": "0.9687339889820603",
      "hy": "0.9733227480447283",
      "bn": "0.966403657351759",
      "bg": "0.967309014628516",
      "zh": "0.9657930675604578",
      "fr": "0.9931295737503842",
      "de": "0.9978629357304456",
      "ha": "0.9682270842496593",
      "hi": "0.9770117114813083",
      "hu": "0.9993039991448538"
    },
    "level": "easy",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "en": "Determines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0\n",
      "sq": "Determinon nëse dy intervale të mbyllura ndërpriten.\n\n@param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n@param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n@param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n@param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n\n@return 1 nëse intervalet ndërpriten, 0 përndryshe.\n\nShembuj:\nare_intervals_intersecting(1, 1, 1, 2) kthen 1\nare_intervals_intersecting(3, 5, 2, 6) kthen 1\nare_intervals_intersecting(3, 5, 4, 7) kthen 1\nare_intervals_intersecting(3, 5, 6, 7) kthen 0",
      "hy": "Որոշում է՝ արդյոք երկու փակ միջակայքերը հատվում են։\n\n@param a Առաջին փակ միջակայքի ստորին սահմանը [a,b]։\n@param b Առաջին փակ միջակայքի վերին սահմանը [a,b]։\n@param c Երկրորդ փակ միջակայքի ստորին սահմանը [c,d]։\n@param d Երկրորդ փակ միջակայքի վերին սահմանը [c,d]։\n\n@return 1՝ եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n\nՕրինակներ:\nare_intervals_intersecting(1, 1, 1, 2) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 2, 6) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 4, 7) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 6, 7) վերադարձնում է 0",
      "bn": "দুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n\n@param a প্রথম বন্ধ ইন্টারভালের [a,b] নিম্ন সীমা।\n@param b প্রথম বন্ধ ইন্টারভালের [a,b] উপরের সীমা।\n@param c দ্বিতীয় বন্ধ ইন্টারভালের [c,d] নিম্ন সীমা।\n@param d দ্বিতীয় বন্ধ ইন্টারভালের [c,d] উপরের সীমা।\n\n@return 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।\n\nউদাহরণ:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "bg": "Определя дали два затворени интервала се пресичат.\n\n@param a Долна граница на първия затворен интервал [a,b].\n@param b Горна граница на първия затворен интервал [a,b].\n@param c Долна граница на втория затворен интервал [c,d].\n@param d Горна граница на втория затворен интервал [c,d].\n\n@return 1 ако интервалите се пресичат, 0 в противен случай.\n\nПримери:\nare_intervals_intersecting(1, 1, 1, 2) връща 1\nare_intervals_intersecting(3, 5, 2, 6) връща 1\nare_intervals_intersecting(3, 5, 4, 7) връща 1\nare_intervals_intersecting(3, 5, 6, 7) връща 0",
      "zh": "确定两个闭区间是否相交。\n\n@param a 第一个闭区间 [a,b] 的下界。\n@param b 第一个闭区间 [a,b] 的上界。\n@param c 第二个闭区间 [c,d] 的下界。\n@param d 第二个闭区间 [c,d] 的上界。\n\n@return 如果区间相交返回 1，否则返回 0。\n\n示例：\nare_intervals_intersecting(1, 1, 1, 2) 返回 1\nare_intervals_intersecting(3, 5, 2, 6) 返回 1\nare_intervals_intersecting(3, 5, 4, 7) 返回 1\nare_intervals_intersecting(3, 5, 6, 7) 返回 0",
      "fr": "Détermine si deux intervalles fermés s'intersectent.\n\n@param a La borne inférieure du premier intervalle fermé [a,b].\n@param b La borne supérieure du premier intervalle fermé [a,b].\n@param c La borne inférieure du second intervalle fermé [c,d].\n@param d La borne supérieure du second intervalle fermé [c,d].\n\n@return 1 si les intervalles s'intersectent, 0 sinon.\n\nExemples:\nare_intervals_intersecting(1, 1, 1, 2) retourne 1\nare_intervals_intersecting(3, 5, 2, 6) retourne 1\nare_intervals_intersecting(3, 5, 4, 7) retourne 1\nare_intervals_intersecting(3, 5, 6, 7) retourne 0",
      "de": "Bestimmt, ob zwei abgeschlossene Intervalle sich überschneiden.\n\n@param a Die untere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param b Die obere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param c Die untere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n@param d Die obere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n\n@return 1, wenn sich die Intervalle überschneiden, 0 andernfalls.\n\nBeispiele:\nare_intervals_intersecting(1, 1, 1, 2) gibt 1 zurück\nare_intervals_intersecting(3, 5, 2, 6) gibt 1 zurück\nare_intervals_intersecting(3, 5, 4, 7) gibt 1 zurück\nare_intervals_intersecting(3, 5, 6, 7) gibt 0 zurück",
      "ha": "Yana tantance idan tazara biyu masu rufe suna hade.\n\n@param a Ƙananan iyaka na farkon rufaffiyar tazara [a,b].\n@param b Babban iyaka na farkon rufaffiyar tazara [a,b].\n@param c Ƙananan iyaka na na biyun rufaffiyar tazara [c,d].\n@param d Babban iyaka na na biyun rufaffiyar tazara [c,d].\n\n@return 1 idan tazarorin sun haɗu, 0 in ba haka ba.\n\nMisalai:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "hi": "दो बंद अंतरालों के प्रतिच्छेदन की जाँच करता है।\n\n@param a पहले बंद अंतराल [a,b] की निचली सीमा।\n@param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n@param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n@param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n\n@return 1 यदि अंतराल प्रतिच्छेदित होते हैं, अन्यथा 0।\n\nउदाहरण:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "hu": "Meghatározza, hogy két zárt intervallum metszi-e egymást.\n\n@param a Az első zárt intervallum [a,b] alsó határa.\n@param b Az első zárt intervallum [a,b] felső határa.\n@param c A második zárt intervallum [c,d] alsó határa.\n@param d A második zárt intervallum [c,d] felső határa.\n\n@return 1, ha az intervallumok metszik egymást, különben 0.\n\nPéldák:\nare_intervals_intersecting(1, 1, 1, 2) visszaadja 1\nare_intervals_intersecting(3, 5, 2, 6) visszaadja 1\nare_intervals_intersecting(3, 5, 4, 7) visszaadja 1\nare_intervals_intersecting(3, 5, 6, 7) visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9709507040344096",
      "hy": "0.9991939579137604",
      "bn": "0.9621650836508555",
      "bg": "0.9704871007250743",
      "zh": "0.96029458135265",
      "fr": "1",
      "de": "0.9948205141841343",
      "ha": "0.9709507040344096",
      "hi": "0.9552261299197827",
      "hu": "0.9875538203243539"
    }
  },
  {
    "task_id": "CPP/12",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * You are given three integers a, b, c, where two of them are equal, and the\n * third is different from the other two. Your task is to find the value that\n * occurs exactly once.\n *\n * Examples:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe\n * i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që\n * ndodh saktësisht një herë.\n *\n * Shembuj:\n *   extraNumber(0, 0, 1) kthen 1\n *   extraNumber(4, 3, 4) kthen 3\n */\nint extraNumber(int a, int b, int c)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ձեզ տրված են երեք ամբողջ թվեր a, b, c, որտեղ երկուսը հավասար են, և\n * երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրը գտնել այն արժեքը,\n * որը հանդիպում է հենց մեկ անգամ։\n *\n * Օրինակներ:\n *   extraNumber(0, 0, 1) վերադարձնում է 1\n *   extraNumber(4, 3, 4) վերադարձնում է 3\n */\nint extraNumber(int a, int b, int c)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * আপনাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে এদের মধ্যে দুটি সমান, এবং\n * তৃতীয়টি অন্য দুটি থেকে আলাদা। আপনার কাজ হল যে মানটি ঠিক একবার ঘটে তা খুঁজে বের করা।\n *\n * উদাহরণ:\n *   extraNumber(0, 0, 1) 1 প্রদান করে\n *   extraNumber(4, 3, 4) 3 প্রদান করে\n */\nint extraNumber(int a, int b, int c)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Дадени са ви три цели числа a, b, c, където две от тях са равни, а\n * третото е различно от другите две. Вашата задача е да намерите стойността,\n * която се среща точно веднъж.\n *\n * Примери:\n *   extraNumber(0, 0, 1) връща 1\n *   extraNumber(4, 3, 4) връща 3\n */\nint extraNumber(int a, int b, int c)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * 给定三个整数 a, b, c，其中两个是相等的，第三个与其他两个不同。你的任务是找到那个只出现一次的值。\n *\n * 示例:\n *   extraNumber(0, 0, 1) 返回 1\n *   extraNumber(4, 3, 4) 返回 3\n */\nint extraNumber(int a, int b, int c)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * On vous donne trois entiers a, b, c, où deux d'entre eux sont égaux, et le\n * troisième est différent des deux autres. Votre tâche est de trouver la valeur qui\n * apparaît exactement une fois.\n *\n * Exemples :\n *   extraNumber(0, 0, 1) retourne 1\n *   extraNumber(4, 3, 4) retourne 3\n */\nint extraNumber(int a, int b, int c)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Sie haben drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die\n * dritte sich von den anderen beiden unterscheidet. Ihre Aufgabe ist es, den Wert zu finden,\n * der genau einmal vorkommt.\n *\n * Beispiele:\n *   extraNumber(0, 0, 1) gibt 1 zurück\n *   extraNumber(4, 3, 4) gibt 3 zurück\n */\nint extraNumber(int a, int b, int c)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, \n * kuma na ukun ya bambanta da sauran biyun. Ayyukanku shine ku nemo \n * ƙimar da ta bayyana sau ɗaya kawai.\n *\n * Misalai:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * आपको तीन पूर्णांक a, b, c दिए गए हैं, जहाँ इनमें से दो समान हैं, और\n * तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो\n * केवल एक बार आता है।\n *\n * उदाहरण:\n *   extraNumber(0, 0, 1) 1 लौटाता है\n *   extraNumber(4, 3, 4) 3 लौटाता है\n */\nint extraNumber(int a, int b, int c)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a\n * harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket,\n * amely pontosan egyszer fordul elő.\n *\n * Példák:\n *   extraNumber(0, 0, 1) visszaadja 1\n *   extraNumber(4, 3, 4) visszaadja 3\n */\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "sq": "0.9985778064717902",
      "hy": "0.9897157133915376",
      "bn": "0.9926584224865695",
      "bg": "0.9971657430930132",
      "zh": "0.9660614172052359",
      "fr": "0.9972060650603632",
      "de": "0.9873901488903811",
      "ha": "0.975888655306937",
      "hi": "0.9807930380450695",
      "hu": "0.9862470310475254"
    },
    "canonical_solution": "{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `int extraNumber(int a, int b, int c)` to solve the following problem:\nYou are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3\n",
      "sq": "Shkruani një funksion CPP `int extraNumber(int a, int b, int c)` për të zgjidhur problemin e mëposhtëm:\nJu jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\n  extraNumber(0, 0, 1) kthen 1\n  extraNumber(4, 3, 4) kthen 3",
      "hy": "Գրեք CPP ֆունկցիա `int extraNumber(int a, int b, int c)` հետևյալ խնդիրը լուծելու համար:  \nՁեզ տրված են երեք ամբողջ թիվ a, b, c, որտեղ երկուսը հավասար են, իսկ երրորդը տարբերվում է մյուս երկուսից: Ձեր խնդիրն է գտնել այն արժեքը, որը հանդիպում է միայն մեկ անգամ:\n\nՕրինակներ:\n  extraNumber(0, 0, 1) վերադարձնում է 1\n  extraNumber(4, 3, 4) վերադարձնում է 3",
      "bn": "একটি CPP ফাংশন `int extraNumber(int a, int b, int c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে তিনটি পূর্ণসংখ্যা a, b, c দেওয়া হয়েছে, যেখানে তাদের মধ্যে দুটি সমান এবং তৃতীয়টি অন্য দুটি থেকে ভিন্ন। আপনার কাজ হল সেই মানটি খুঁজে বের করা যা ঠিক একবার ঘটে।\n\nউদাহরণসমূহ:\n  extraNumber(0, 0, 1) 1 প্রদান করে\n  extraNumber(4, 3, 4) 3 প্রদান করে",
      "bg": "Напишете CPP функция `int extraNumber(int a, int b, int c)`, за да решите следния проблем:  \nДадени са ви три цели числа a, b, c, където две от тях са равни, а третото е различно от другите две. Вашата задача е да намерите стойността, която се среща точно веднъж.\n\nПримери:  \n  extraNumber(0, 0, 1) връща 1  \n  extraNumber(4, 3, 4) връща 3  ",
      "zh": "编写一个 CPP 函数 `int extraNumber(int a, int b, int c)` 来解决以下问题：  \n给定三个整数 a, b, c，其中两个相等，第三个与其他两个不同。你的任务是找到只出现一次的值。\n\n示例：  \nextraNumber(0, 0, 1) 返回 1  \nextraNumber(4, 3, 4) 返回 3  ",
      "fr": "Écrire une fonction CPP `int extraNumber(int a, int b, int c)` pour résoudre le problème suivant :  \nOn vous donne trois entiers a, b, c, dont deux sont égaux, et le troisième est différent des deux autres. Votre tâche est de trouver la valeur qui apparaît exactement une fois.\n\nExemples :\n  extraNumber(0, 0, 1) renvoie 1\n  extraNumber(4, 3, 4) renvoie 3",
      "de": "Schreiben Sie eine CPP-Funktion `int extraNumber(int a, int b, int c)`, um das folgende Problem zu lösen:\nSie haben drei ganze Zahlen a, b, c, von denen zwei gleich sind und die dritte sich von den anderen beiden unterscheidet. Ihre Aufgabe ist es, den Wert zu finden, der genau einmal vorkommt.\n\nBeispiele:\n  extraNumber(0, 0, 1) gibt 1 zurück\n  extraNumber(4, 3, 4) gibt 3 zurück",
      "ha": "Rubuta aikin CPP `int extraNumber(int a, int b, int c)` don warware matsalar mai zuwa:\nAn ba ka lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, kuma na uku ya bambanta daga sauran biyun. Ayyukanka shine gano ƙimar da ta bayyana sau ɗaya kawai.\n\nMisalai:\n  extraNumber(0, 0, 1) yana dawowa 1\n  extraNumber(4, 3, 4) yana dawowa 3",
      "hi": "एक CPP फ़ंक्शन `int extraNumber(int a, int b, int c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको तीन पूर्णांक a, b, c दिए गए हैं, जिनमें से दो समान हैं, और तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो केवल एक बार आता है।\n\nउदाहरण:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3",
      "hu": "Írj egy CPP függvényt `int extraNumber(int a, int b, int c)` a következő probléma megoldására:\nHárom egész számot kapsz, a, b, c, ahol kettő közülük egyenlő, és a harmadik eltér a másik kettőtől. A feladatod az, hogy megtaláld azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\n  extraNumber(0, 0, 1) visszaadja 1\n  extraNumber(4, 3, 4) visszaadja 3"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9836370278407269",
      "bn": "0.9953343709798715",
      "bg": "0.9980113126250787",
      "zh": "0.9682374130294731",
      "fr": "0.9896124255933995",
      "de": "0.9784877338427785",
      "ha": "0.9662681914318932",
      "hi": "0.9747364004665536",
      "hu": "0.9918877366081541"
    },
    "level": "easy",
    "test": "int main() {\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n\n    \n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "en": "You are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3\n",
      "sq": "Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\n  extraNumber(0, 0, 1) kthen 1\n  extraNumber(4, 3, 4) kthen 3",
      "hy": "Դուք տրված եք երեք ամբողջ թվերով `a`, `b`, `c`, որտեղ երկուսը հավասար են, իսկ երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրն է գտնել այն արժեքը, որը հանդիպում է հենց մեկ անգամ։\n\nՕրինակներ:\n  extraNumber(0, 0, 1) վերադարձնում է 1\n  extraNumber(4, 3, 4) վերադարձնում է 3",
      "bn": "তোমাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে এদের মধ্যে দুটি সমান এবং তৃতীয়টি অন্য দুটি থেকে ভিন্ন। তোমার কাজ হল সেই মানটি খুঁজে বের করা যা ঠিক একবার ঘটে।\n\nউদাহরণসমূহ:\n  extraNumber(0, 0, 1) ১ ফেরত দেয়\n  extraNumber(4, 3, 4) ৩ ফেরত দেয়",
      "bg": "Дадени са ви три цели числа a, b, c, където две от тях са равни, а третото е различно от другите две. Вашата задача е да намерите стойността, която се среща точно веднъж.\n\nПримери:\n  extraNumber(0, 0, 1) връща 1\n  extraNumber(4, 3, 4) връща 3",
      "zh": "你有三个整数 a, b, c，其中两个是相等的，第三个与其他两个不同。你的任务是找出只出现一次的值。\n\n示例：\n  extraNumber(0, 0, 1) 返回 1\n  extraNumber(4, 3, 4) 返回 3",
      "fr": "Vous avez trois entiers a, b, c, où deux d'entre eux sont égaux, et le troisième est différent des deux autres. Votre tâche est de trouver la valeur qui apparaît exactement une fois.\n\nExemples :\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3",
      "de": "Du hast drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die dritte sich von den anderen beiden unterscheidet. Deine Aufgabe ist es, den Wert zu finden, der genau einmal vorkommt.\n\nBeispiele:\n  extraNumber(0, 0, 1) gibt 1 zurück\n  extraNumber(4, 3, 4) gibt 3 zurück",
      "ha": "An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, kuma na uku ya bambanta da sauran biyun. Aikin ku shine nemo darajar da ta bayyana sau daya kawai.\n\nMisalai:\n  extraNumber(0, 0, 1) yana dawowa 1\n  extraNumber(4, 3, 4) yana dawowa 3",
      "hi": "आपको तीन पूर्णांक a, b, c दिए गए हैं, जिनमें से दो समान हैं, और तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो केवल एक बार आता है।\n\nउदाहरण:\n  extraNumber(0, 0, 1) 1 लौटाता है\n  extraNumber(4, 3, 4) 3 लौटाता है",
      "hu": "Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\n  extraNumber(0, 0, 1) visszaadja 1\n  extraNumber(4, 3, 4) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9586191340886208",
      "bn": "0.9933359507162794",
      "bg": "0.9770560060562791",
      "zh": "0.9567017550204909",
      "fr": "0.9829211639474772",
      "de": "0.9835019591816232",
      "ha": "0.9668507743394685",
      "hi": "0.964262620474584",
      "hu": "0.9869251551683785"
    }
  },
  {
    "task_id": "CPP/13",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n *\n * Parameters:\n * - subject_scores (list): A list containing the scores for each subject.\n *\n * Returns:\n *   int: The total score obtained by summing up the scores in all subjects.\n *\n * Examples:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n *\n * Parametrat:\n * - subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n *\n * Kthen:\n *   int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n *\n * Shembuj:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n *\n * Պարամետրեր:\n * - subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n *\n * Վերադարձնում է:\n *   int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n *\n * Օրինակներ:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n *\n * প্যারামিটার:\n * - subject_scores (list): প্রতিটি বিষয়ের নম্বর ধারণকারী একটি তালিকা।\n *\n * রিটার্নস:\n *   int: সমস্ত বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n *\n * উদাহরণ:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява общия резултат за студент въз основа на оценките в различни предмети.\n *\n * Параметри:\n * - subject_scores (list): Списък, съдържащ оценките за всеки предмет.\n *\n * Връща:\n *   int: Общият резултат, получен чрез сумиране на оценките във всички предмети.\n *\n * Примери:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 根据不同科目的分数计算学生的总分。\n *\n * 参数:\n * - subject_scores (list): 包含每个科目分数的列表。\n *\n * 返回:\n *   int: 通过将所有科目的分数相加获得的总分。\n *\n * 示例:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n *\n * Paramètres :\n * - subject_scores (list): Une liste contenant les scores pour chaque matière.\n *\n * Renvoie :\n *   int : Le score total obtenu en additionnant les scores de toutes les matières.\n *\n * Exemples :\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n *\n * Parameter:\n * - subject_scores (list): Eine Liste, die die Punkte für jedes Fach enthält.\n *\n * Rückgabe:\n *   int: Die Gesamtpunktzahl, die durch das Summieren der Punkte in allen Fächern erzielt wird.\n *\n * Beispiele:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n *\n * Sigogi:\n * - subject_scores (list): Jerin da ke ɗauke da maki na kowane fanni.\n *\n * Komawa:\n *   int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n *\n * Misalai:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n *\n * पैरामीटर्स:\n * - subject_scores (list): प्रत्येक विषय के लिए अंकों की सूची।\n *\n * रिटर्न करता है:\n *   int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल स्कोर।\n *\n * उदाहरण:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n *\n * Paraméterek:\n * - subject_scores (list): Egy lista, amely tartalmazza az egyes tantárgyak pontszámait.\n *\n * Visszatér:\n *   int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n *\n * Példák:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "sq": "0.9917179076323693",
      "hy": "0.988852863016322",
      "bn": "0.9750953255650836",
      "bg": "0.9784555557210508",
      "zh": "0.9800737974353421",
      "fr": "0.9847384333035654",
      "de": "0.9933436973011399",
      "ha": "0.9927462171149869",
      "hi": "0.9652804025470068",
      "hu": "0.9883751569499332"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "Write a CPP function `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> calculate_total_score(100,100,100,100,100)\n  500\n",
      "sq": "Shkruani një funksion CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n\nParametrat:\n- score1 (int): Pikët për lëndën e parë.\n- score2 (int): Pikët për lëndën e dytë.\n- score3 (int): Pikët për lëndën e tretë.\n- score4 (int): Pikët për lëndën e katërt.\n- score5 (int): Pikët për lëndën e pestë.\n\nKthen:\n  int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n\nShembuj:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hy": "Գրեք CPP ֆունկցիա `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n\nՊարամետրեր:\n- score1 (int): Առաջին առարկայի միավորը:\n- score2 (int): Երկրորդ առարկայի միավորը:\n- score3 (int): Երրորդ առարկայի միավորը:\n- score4 (int): Չորրորդ առարկայի միավորը:\n- score5 (int): Հինգերորդ առարկայի միավորը:\n\nՎերադարձնում է:\n  int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n\nՕրինակներ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "bn": "একটি CPP ফাংশন `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n\nপ্যারামিটার:\n- score1 (int): প্রথম বিষয়ের জন্য স্কোর।\n- score2 (int): দ্বিতীয় বিষয়ের জন্য স্কোর।\n- score3 (int): তৃতীয় বিষয়ের জন্য স্কোর।\n- score4 (int): চতুর্থ বিষয়ের জন্য স্কোর।\n- score5 (int): পঞ্চম বিষয়ের জন্য স্কোর।\n\nরিটার্নস:\n  int: সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "bg": "Напишете CPP функция `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` за решаване на следния проблем:\nИзчислете общия резултат за студент въз основа на резултатите в различни предмети.\n\nПараметри:\n- score1 (int): Резултатът за първия предмет.\n- score2 (int): Резултатът за втория предмет.\n- score3 (int): Резултатът за третия предмет.\n- score4 (int): Резултатът за четвъртия предмет.\n- score5 (int): Резултатът за петия предмет.\n\nВръща:\n  int: Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n\nПримери:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "zh": "编写一个 CPP 函数 `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` 来解决以下问题：\n计算学生在不同科目中的总分。\n\n参数：\n- score1 (int): 第一科目的分数。\n- score2 (int): 第二科目的分数。\n- score3 (int): 第三科目的分数。\n- score4 (int): 第四科目的分数。\n- score5 (int): 第五科目的分数。\n\n返回：\n  int: 通过将所有科目的分数相加得到的总分。\n\n例子：\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "fr": "Écrire une fonction CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` pour résoudre le problème suivant :  \nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.\n\nParamètres :\n- score1 (int) : Le score pour la première matière.\n- score2 (int) : Le score pour la deuxième matière.\n- score3 (int) : Le score pour la troisième matière.\n- score4 (int) : Le score pour la quatrième matière.\n- score5 (int) : Le score pour la cinquième matière.\n\nRenvoie :\n  int : Le score total obtenu en additionnant les scores dans toutes les matières.\n\nExemples :\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "de": "Schreiben Sie eine CPP-Funktion `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- score1 (int): Die Punktzahl für das erste Fach.\n- score2 (int): Die Punktzahl für das zweite Fach.\n- score3 (int): Die Punktzahl für das dritte Fach.\n- score4 (int): Die Punktzahl für das vierte Fach.\n- score5 (int): Die Punktzahl für das fünfte Fach.\n\nRückgabewert:\n  int: Die Gesamtpunktzahl, die durch das Summieren der Punktzahlen in allen Fächern erhalten wird.\n\nBeispiele:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "ha": "Rubuta aikin CPP `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` don warware matsalar mai zuwa:\nƘididdige jimlar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n\nSigogi:\n- score1 (int): Makin fanni na farko.\n- score2 (int): Makin fanni na biyu.\n- score3 (int): Makin fanni na uku.\n- score4 (int): Makin fanni na huɗu.\n- score5 (int): Makin fanni na biyar.\n\nMayarwa:\n  int: Jimlar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n\nMisalai:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hi": "एक CPP फ़ंक्शन `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n\nपैरामीटर्स:\n- score1 (int): पहले विषय के लिए अंक।\n- score2 (int): दूसरे विषय के लिए अंक।\n- score3 (int): तीसरे विषय के लिए अंक।\n- score4 (int): चौथे विषय के लिए अंक।\n- score5 (int): पांचवें विषय के लिए अंक।\n\nवापसी मान:\n  int: सभी विषयों के अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hu": "Írj egy CPP függvényt `int calculate_total_score(int score1, int score2, int score3, int score4, int score5)` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n\nParaméterek:\n- score1 (int): Az első tantárgy pontszáma.\n- score2 (int): A második tantárgy pontszáma.\n- score3 (int): A harmadik tantárgy pontszáma.\n- score4 (int): A negyedik tantárgy pontszáma.\n- score5 (int): Az ötödik tantárgy pontszáma.\n\nVisszatérési érték:\n  int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n\nPéldák:\n  >>> calculate_total_score(100,100,100,100,100)\n  500"
    },
    "instruction_bertscore": {
      "sq": "0.9979739701134441",
      "hy": "0.9836926443474168",
      "bn": "0.9711102042303806",
      "bg": "0.9979739701134441",
      "zh": "0.9601213756603876",
      "fr": "0.9930123818255737",
      "de": "0.9931498340492498",
      "ha": "0.9770544170132307",
      "hi": "0.9559906582563861",
      "hu": "0.9799206534115642"
    },
    "level": "easy",
    "test": "int main() {\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> calculate_total_score(100,100,100,100,100)\n  500\n",
      "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n\nParametrat:\n- score1 (int): Rezultati për lëndën e parë.\n- score2 (int): Rezultati për lëndën e dytë.\n- score3 (int): Rezultati për lëndën e tretë.\n- score4 (int): Rezultati për lëndën e katërt.\n- score5 (int): Rezultati për lëndën e pestë.\n\nKthen:\n  int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n\nShembuj:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n\nՊարամետրեր:\n- score1 (int): Առաջին առարկայի միավորը:\n- score2 (int): Երկրորդ առարկայի միավորը:\n- score3 (int): Երրորդ առարկայի միավորը:\n- score4 (int): Չորրորդ առարկայի միավորը:\n- score5 (int): Հինգերորդ առարկայի միավորը:\n\nՎերադարձնում է:\n  int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n\nՕրինակներ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "bn": "একজন শিক্ষার্থীর বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে মোট স্কোর গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- score1 (int): প্রথম বিষয়ের নম্বর।\n- score2 (int): দ্বিতীয় বিষয়ের নম্বর।\n- score3 (int): তৃতীয় বিষয়ের নম্বর।\n- score4 (int): চতুর্থ বিষয়ের নম্বর।\n- score5 (int): পঞ্চম বিষয়ের নম্বর।\n\nফেরত দেয়:\n  int: সব বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "bg": "Изчислява общия резултат за студент въз основа на резултатите по различни предмети.\n\nПараметри:\n- score1 (int): Резултатът за първия предмет.\n- score2 (int): Резултатът за втория предмет.\n- score3 (int): Резултатът за третия предмет.\n- score4 (int): Резултатът за четвъртия предмет.\n- score5 (int): Резултатът за петия предмет.\n\nВръща:\n  int: Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n\nПримери:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "zh": "计算学生在不同科目中的总分。\n\n参数：\n- score1 (int): 第一科目的分数。\n- score2 (int): 第二科目的分数。\n- score3 (int): 第三科目的分数。\n- score4 (int): 第四科目的分数。\n- score5 (int): 第五科目的分数。\n\n返回：\n  int: 通过将所有科目的分数相加得到的总分。\n\n示例：\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n\nParamètres:\n- score1 (int): Le score pour la première matière.\n- score2 (int): Le score pour la deuxième matière.\n- score3 (int): Le score pour la troisième matière.\n- score4 (int): Le score pour la quatrième matière.\n- score5 (int): Le score pour la cinquième matière.\n\nRenvoie:\n  int: Le score total obtenu en additionnant les scores dans toutes les matières.\n\nExemples:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n\nParameter:\n- score1 (int): Die Punktzahl für das erste Fach.\n- score2 (int): Die Punktzahl für das zweite Fach.\n- score3 (int): Die Punktzahl für das dritte Fach.\n- score4 (int): Die Punktzahl für das vierte Fach.\n- score5 (int): Die Punktzahl für das fünfte Fach.\n\nRückgabewert:\n  int: Die Gesamtpunktzahl, die durch das Aufsummieren der Punkte in allen Fächern erzielt wird.\n\nBeispiele:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "ha": "Ƙididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n\nSigogi:\n- score1 (int): Makin fanni na farko.\n- score2 (int): Makin fanni na biyu.\n- score3 (int): Makin fanni na uku.\n- score4 (int): Makin fanni na huɗu.\n- score5 (int): Makin fanni na biyar.\n\nDawowa:\n  int: Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n\nMisalai:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hi": "विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n\nमापदंड:\n- score1 (int): पहले विषय के लिए अंक।\n- score2 (int): दूसरे विषय के लिए अंक।\n- score3 (int): तीसरे विषय के लिए अंक।\n- score4 (int): चौथे विषय के लिए अंक।\n- score5 (int): पांचवें विषय के लिए अंक।\n\nवापसी:\n  int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n\nParaméterek:\n- score1 (int): Az első tantárgy pontszáma.\n- score2 (int): A második tantárgy pontszáma.\n- score3 (int): A harmadik tantárgy pontszáma.\n- score4 (int): A negyedik tantárgy pontszáma.\n- score5 (int): Az ötödik tantárgy pontszáma.\n\nVisszatér:\n  int: Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n\nPéldák:\n  >>> calculate_total_score(100,100,100,100,100)\n  500"
    },
    "docstring_bertscore": {
      "sq": "0.9774345955625315",
      "hy": "0.9697960656294539",
      "bn": "0.9324195881997379",
      "bg": "0.9959459539230779",
      "zh": "0.9557288634141821",
      "fr": "0.9884798351607386",
      "de": "0.9919767230188578",
      "ha": "0.9749219212424401",
      "hi": "0.9401324058953227",
      "hu": "0.9758141689140489"
    }
  },
  {
    "task_id": "CPP/14",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk e tejkalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում\nյուրաքանչյուր թվանշան:\n\nՀաշվարկները տրամադրված են հղման համար:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Կոնստանտ սիմվոլային զանգված (C-ոճի տող), որը ներկայացնում է թվերի շարք: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալների տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին:\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্ন উন্মোচন করুন এবং প্রতিটি অঙ্ক আসলে কোন মানগুলি উপস্থাপন করে তা বুঝুন।\n\nতুলনামূলক সমীকরণগুলি রেফারেন্সের জন্য প্রদান করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুবক ক্যারেক্টার অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডান দিকের সাথে মিলে যায়।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности,\nкоито всяка цифра представлява.\n\nПредоставени уравнения за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (низ в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nAn bayar da daidaito don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Tsayayyen jerin haruffa (salo na C) wanda ke wakiltar jerin lambobi. Tsawon bai wuce 100 ba.\n\nDawo:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na daidaito.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए दिए गए समीकरण:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली की स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित होता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek milyen valós értékeket képviselnek.\n\nAz egyenletek referenciaként szolgálnak:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy konstans karaktertömb (C-stílusú string), amely egy számsorozatot képvisel. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatstringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "sq": "0.9743786671503097",
      "hy": "0.9746031194808792",
      "bn": "0.9665730890667817",
      "bg": "0.9792089607563161",
      "zh": "0.9751124077778527",
      "fr": "0.9854977972502618",
      "de": "0.9781878019674158",
      "ha": "0.9436666362650764",
      "hi": "0.9762308954534601",
      "hu": "0.9665730890667817"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `int decode_numbers(const char* data_str)` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);",
      "sq": "Shkruani një funksion CPP `int decode_numbers(const char* data_str)` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);",
      "hy": "Գրեք CPP ֆունկցիա `int decode_numbers(const char* data_str)` հետևյալ խնդիրը լուծելու համար:\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ է ներկայացնում յուրաքանչյուր թիվ:\n\nՀավասարումներ՝ հղման համար:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C-ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);",
      "bn": "একটি CPP ফাংশন `int decode_numbers(const char* data_str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন যাতে প্যাটার্নটি প্রকাশ পায় এবং প্রতিটি অঙ্কের প্রকৃত মান বোঝা যায়।\n\nতুলনামূলক সূত্রগুলি রেফারেন্সের জন্য প্রদান করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুবক চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিং এর সমতুল্য সমীকরণের ডানপাশের ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);",
      "bg": "Напишете CPP функция `int decode_numbers(const char* data_str)`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n\nПредоставени уравнения за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (низ в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);",
      "zh": "编写一个 CPP 函数 `int decode_numbers(const char* data_str)` 来解决以下问题：  \n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：  \n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：  \n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：  \nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：  \nassert(decode_numbers(\"0000\") == 4);",
      "fr": "Écrire une fonction CPP `int decode_numbers(const char* data_str)` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);",
      "de": "Schreiben Sie eine CPP-Funktion `int decode_numbers(const char* data_str)`, um das folgende Problem zu lösen:\nDekodieren Sie eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);",
      "ha": "Rubuta aikin CPP `int decode_numbers(const char* data_str)` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nLissafai da aka bayar don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Tsayayyen jerin haruffa (C-style string) wanda ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);",
      "hi": "एक CPP फ़ंक्शन `int decode_numbers(const char* data_str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण दिए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली की स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nरिटर्न करता है:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर मेल खाता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);",
      "hu": "Írj egy CPP függvényt `int decode_numbers(const char* data_str)` a következő probléma megoldására:\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, milyen valós értékeket képviselnek az egyes számjegyek.\n\nEgyenletek hivatkozásként:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy konstans karaktertömb (C-stílusú string), amely egy számsorozatot képvisel. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "instruction_bertscore": {
      "sq": "0.9821864301680292",
      "hy": "0.9723093358406883",
      "bn": "0.9628275159716069",
      "bg": "0.9766500055574437",
      "zh": "0.9763663613733259",
      "fr": "0.9841004325196814",
      "de": "0.9815923266983538",
      "ha": "0.9371606967646596",
      "hi": "0.9789414056330622",
      "hu": "0.9778511234715617"
    },
    "level": "easy",
    "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);",
      "sq": "Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk tejkalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);",
      "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան։\n\nՀաշվարկները տրված են հղման համար.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալների տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);",
      "bn": "সংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্কের প্রকৃত মানগুলি বোঝার জন্য।\n\nতুলনার জন্য প্রদত্ত সমীকরণ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুব চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডানপাশের সাথে মিলে যায়।\n\nব্যবহারের উদাহরণ:\nassert(decode_numbers(\"0000\") == 4);",
      "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n\nУравнения, предоставени за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (стринг в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);",
      "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);",
      "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);",
      "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenkette, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);",
      "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nLissafin da aka bayar don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wata madaidaiciyar jerin haruffa (C-style string) da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nAbubuwan da ake dawowa da su:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);",
      "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण दिए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हिस्से से मेल खाता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);",
      "hu": "Dekódoljon egy számok sorozatát, hogy felfedje a mintát, és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n\nAz egyenletek referenciaként szolgálnak:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy állandó karaktertömb (C-stílusú string), amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "sq": "0.9759206347982836",
      "hy": "0.9674242202495162",
      "bn": "0.9573576325386681",
      "bg": "0.9816171554959832",
      "zh": "0.9669490963780808",
      "fr": "0.9803441333839306",
      "de": "0.9797812148840777",
      "ha": "0.9286313095726405",
      "hi": "0.9735557414816822",
      "hu": "0.9655459713664504"
    }
  },
  {
    "task_id": "CPP/15",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *\n * Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "sq": "#include <cassert>\n#include <iostream>\n/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\n * duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * \n * @param n Numri i katrorëve.\n * @param m Numri i ngjyrave.\n * @return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n *         Rezultati është modulo 1000003.\n *\n * Shembuj:\n * count_coloring_methods(1,1) kthen 1\n * count_coloring_methods(2,2) kthen 2\n */\nint count_coloring_methods(int n, int m)",
      "hy": "#include <cassert>\n#include <iostream>\n/**\n * Հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների թիվը m գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ:\n * \n * @param n Քառակուսիների քանակը:\n * @param m Գույների քանակը:\n * @return Տարբեր գունավորման մեթոդների թիվը, որը բավարարում է նշված պայմաններին:\n *         Արդյունքը վերադարձվում է 1000003 մոդուլով:\n *\n * Օրինակներ:\n * count_coloring_methods(1,1) վերադարձնում է 1\n * count_coloring_methods(2,2) վերադարձնում է 2\n */\nint count_coloring_methods(int n, int m)",
      "bn": "#include <cassert>\n#include <iostream>\n/**\n * n টি বর্গক্ষেত্রের জন্য m টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n * \n * @param n বর্গক্ষেত্রের সংখ্যা।\n * @param m রঙের সংখ্যা।\n * @return নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা প্রদান করে।\n *         ফলাফলটি 1000003 দ্বারা মডুলো করা হয়।\n *\n * উদাহরণ:\n * count_coloring_methods(1,1) 1 প্রদান করে\n * count_coloring_methods(2,2) 2 প্রদান করে\n */\nint count_coloring_methods(int n, int m)",
      "bg": "#include <cassert>\n#include <iostream>\n/**\n * Брои броя на различните методи за оцветяване на n квадрата с m цвята,\n * като се взема предвид изискването съседните квадрати и първият/последният квадрат\n * да имат различни цветове.\n * \n * @param n Броят на квадратите.\n * @param m Броят на цветовете.\n * @return Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n *         Резултатът е по модул 1000003.\n *\n * Примери:\n * count_coloring_methods(1,1) връща 1\n * count_coloring_methods(2,2) връща 2\n */\nint count_coloring_methods(int n, int m)",
      "zh": "#include <cassert>\n#include <iostream>\n/**\n * 计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n * 考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n * \n * @param n 方块的数量。\n * @param m 颜色的数量。\n * @return 满足指定条件的不同着色方法的计数。\n *         结果取模 1000003。\n *\n * 示例:\n * count_coloring_methods(1,1) 返回 1\n * count_coloring_methods(2,2) 返回 2\n */\nint count_coloring_methods(int n, int m)",
      "fr": "#include <cassert>\n#include <iostream>\n/**\n * Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * \n * @param n Le nombre de carrés.\n * @param m Le nombre de couleurs.\n * @return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées.\n *         Le résultat est modulo 1000003.\n *\n * Exemples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "de": "#include <cassert>\n#include <iostream>\n/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * \n * @param n Die Anzahl der Quadrate.\n * @param m Die Anzahl der Farben.\n * @return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n *         Das Ergebnis ist modulo 1000003.\n *\n * Beispiele:\n * count_coloring_methods(1,1) gibt 1 zurück\n * count_coloring_methods(2,2) gibt 2 zurück\n */\nint count_coloring_methods(int n, int m)",
      "ha": "#include <cassert>\n#include <iostream>\n/**\n * Yana ƙidaya adadin hanyoyin launin daban-daban don murabba'i n tare da launuka m,\n * la'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'ai na farko/na ƙarshe\n * dole ne su sami launuka daban-daban.\n * \n * @param n Yawan murabba'ai.\n * @param m Yawan launuka.\n * @return Adadin hanyoyin launin daban-daban da suka cika sharuɗɗan da aka fayyace.\n *         Sakamakon yana cikin modulo 1000003.\n *\n * Misalai:\n * count_coloring_methods(1,1) yana dawowa 1\n * count_coloring_methods(2,2) yana dawowa 2\n */\nint count_coloring_methods(int n, int m)",
      "hi": "#include <cassert>\n#include <iostream>\n/**\n * n वर्गों के लिए m रंगों के विभिन्न रंगाई विधियों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के\n * रंग अलग-अलग होने चाहिए।\n * \n * @param n वर्गों की संख्या।\n * @param m रंगों की संख्या।\n * @return विभिन्न रंगाई विधियों की संख्या जो निर्दिष्ट शर्तों को पूरा करती हैं।\n *         परिणाम 1000003 से मॉड्यूलो है।\n *\n * उदाहरण:\n * count_coloring_methods(1,1) 1 लौटाता है\n * count_coloring_methods(2,2) 2 लौटाता है\n */\nint count_coloring_methods(int n, int m)",
      "hu": "#include <cassert>\n#include <iostream>\n/**\n * Megszámolja az n négyzet m színnel való különböző színezési módszereit,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * \n * @param n A négyzetek száma.\n * @param m A színek száma.\n * @return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n *         Az eredmény modulo 1000003.\n *\n * Példák:\n * count_coloring_methods(1,1) visszaadja 1\n * count_coloring_methods(2,2) visszaadja 2\n */\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9845717824138771",
      "hy": "0.9734168988453389",
      "bn": "0.9659754102502478",
      "bg": "0.978621809349977",
      "zh": "0.9587391068387657",
      "fr": "1",
      "de": "0.9911680987376648",
      "ha": "0.978769391723086",
      "hi": "0.9856368385169862",
      "hu": "0.9848544334460898"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "Write a CPP function `int count_coloring_methods(int n, int m)` to solve the following problem:\nCounts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2\n",
      "sq": "Shkruani një funksion CPP `int count_coloring_methods(int n, int m)` për të zgjidhur problemin e mëposhtëm: Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/të fundit duhet të kenë ngjyra të ndryshme.\n\n@param n Numri i katrorëve.\n@param m Numri i ngjyrave.\n@return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj:\ncount_coloring_methods(1,1) kthen 1\ncount_coloring_methods(2,2) kthen 2",
      "hy": "Գրեք CPP ֆունկցիա `int count_coloring_methods(int n, int m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։\n\n@param n Քառակուսիների քանակը։\n@param m Գույների քանակը։\n@return Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակներ:\ncount_coloring_methods(1,1) վերադարձնում է 1\ncount_coloring_methods(2,2) վերադարձնում է 2",
      "bn": "একটি CPP ফাংশন `int count_coloring_methods(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বর্গক্ষেত্রের জন্য m রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, এই শর্তটি বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\n@param n বর্গক্ষেত্রের সংখ্যা।\n@param m রঙের সংখ্যা।\n@return নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণসমূহ:\ncount_coloring_methods(1,1) 1 প্রদান করে\ncount_coloring_methods(2,2) 2 প্রদান করে",
      "bg": "Напишете CPP функция `int count_coloring_methods(int n, int m)`, за да решите следния проблем:\nБрои броя на различните методи за оцветяване на n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\n@param n Броят на квадратите.\n@param m Броят на цветовете.\n@return Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е по модул 1000003.\n\nПримери:\ncount_coloring_methods(1,1) връща 1\ncount_coloring_methods(2,2) връща 2",
      "zh": "编写一个 CPP 函数 `int count_coloring_methods(int n, int m)` 来解决以下问题：\n计算使用 m 种颜色为 n 个方块着色的不同方法数，考虑到相邻方块以及第一个和最后一个方块必须具有不同颜色的要求。\n\n@param n 方块的数量。\n@param m 颜色的数量。\n@return 满足指定条件的不同着色方法的数量。结果取模 1000003。\n\n示例：\ncount_coloring_methods(1,1) 返回 1\ncount_coloring_methods(2,2) 返回 2",
      "fr": "Écrire une fonction CPP `int count_coloring_methods(int n, int m)` pour résoudre le problème suivant :  \nCompte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\n@param n Le nombre de carrés.\n@param m Le nombre de couleurs.\n@return Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples :  \ncount_coloring_methods(1,1) retourne 1  \ncount_coloring_methods(2,2) retourne 2  ",
      "de": "Schreiben Sie eine CPP-Funktion `int count_coloring_methods(int n, int m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\n@param n Die Anzahl der Quadrate.\n@param m Die Anzahl der Farben.\n@return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\nBeispiele:\ncount_coloring_methods(1,1) gibt 1 zurück\ncount_coloring_methods(2,2) gibt 2 zurück",
      "ha": "Rubuta aikin CPP `int count_coloring_methods(int n, int m)` don warware matsalar mai zuwa:  \nYana ƙididdige adadin hanyoyin launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n\n@param n Adadin murabba'ai.  \n@param m Adadin launuka.  \n@return Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalai:  \ncount_coloring_methods(1,1) yana dawowa 1  \ncount_coloring_methods(2,2) yana dawowa 2  ",
      "hi": "एक CPP फ़ंक्शन `int count_coloring_methods(int n, int m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn वर्गों के लिए m रंगों के विभिन्न रंगाई विधियों की संख्या गिनें, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\n@param n वर्गों की संख्या।\n@param m रंगों की संख्या।\n@return निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की गिनती। परिणाम 1000003 के मोड्यूलो में है।\n\nउदाहरण:\ncount_coloring_methods(1,1) 1 लौटाता है\ncount_coloring_methods(2,2) 2 लौटाता है",
      "hu": "Írj egy CPP függvényt `int count_coloring_methods(int n, int m)` a következő probléma megoldására:\nSzámolja meg az n négyzet m színnel való különböző színezési módszereit, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\n@param n A négyzetek száma.\n@param m A színek száma.\n@return A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény 1000003-mal modulozva van.\n\nPéldák:\ncount_coloring_methods(1,1) visszaadja 1\ncount_coloring_methods(2,2) visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9772927734704726",
      "hy": "0.9939517048974876",
      "bn": "0.9700735522717596",
      "bg": "0.9849541458973693",
      "zh": "0.9524004141191804",
      "fr": "0.9935919852774334",
      "de": "0.9866631616957935",
      "ha": "0.9756058056443433",
      "hi": "0.9791805566118282",
      "hu": "0.9769709922531961"
    },
    "level": "hard",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2\n",
      "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\n@param n Numri i katrorëve.\n@param m Numri i ngjyrave.\n@return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj:\ncount_coloring_methods(1,1) kthen 1\ncount_coloring_methods(2,2) kthen 2",
      "hy": "Հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\n@param n Քառակուսիների քանակը։\n@param m Գույների քանակը։\n@return Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակներ:\ncount_coloring_methods(1,1) վերադարձնում է 1\ncount_coloring_methods(2,2) վերադարձնում է 2",
      "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\n@param n বর্গক্ষেত্রের সংখ্যা।\n@param m রঙের সংখ্যা।\n@return নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণসমূহ:\ncount_coloring_methods(1,1) 1 ফেরত দেয়\ncount_coloring_methods(2,2) 2 ফেরত দেয়",
      "bg": "Брои броя на различните методи за оцветяване за n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\n@param n Броят на квадратите.\n@param m Броят на цветовете.\n@return Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n\nПримери:\ncount_coloring_methods(1,1) връща 1\ncount_coloring_methods(2,2) връща 2",
      "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及首尾方块必须具有不同颜色的要求。\n\n@param n 方块的数量。\n@param m 颜色的数量。\n@return 满足指定条件的不同着色方法的计数。结果取模 1000003。\n\n示例:\ncount_coloring_methods(1,1) 返回 1\ncount_coloring_methods(2,2) 返回 2",
      "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence selon laquelle les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\n@param n Le nombre de carrés.\n@param m Le nombre de couleurs.\n@return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples :\ncount_coloring_methods(1,1) renvoie 1\ncount_coloring_methods(2,2) renvoie 2",
      "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\n@param n Die Anzahl der Quadrate.\n@param m Die Anzahl der Farben.\n@return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\nBeispiele:\ncount_coloring_methods(1,1) gibt 1 zurück\ncount_coloring_methods(2,2) gibt 2 zurück",
      "ha": "Yana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban.\n\n@param n Yawan murabba'ai.\n@param m Yawan launuka.\n@return Adadin hanyoyin canza launi daban-daban da suka cika yanayin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalai:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2",
      "hi": "n वर्गों के लिए m रंगों के साथ विभिन्न रंगाई विधियों की संख्या की गणना करता है, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\n@param n वर्गों की संख्या।\n@param m रंगों की संख्या।\n@return निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की गणना। परिणाम 1000003 के माड्यूलो में है।\n\nउदाहरण:\ncount_coloring_methods(1,1) 1 लौटाता है\ncount_coloring_methods(2,2) 2 लौटाता है",
      "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\n@param n A négyzetek száma.\n@param m A színek száma.\n@return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek. Az eredmény modulo 1000003.\n\nPéldák:\ncount_coloring_methods(1,1) visszaadja 1\ncount_coloring_methods(2,2) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9741993039162352",
      "hy": "0.972689117129227",
      "bn": "0.9471333323052783",
      "bg": "0.9801121330988818",
      "zh": "0.9128360230423652",
      "fr": "0.9906675501774568",
      "de": "0.9907972558162726",
      "ha": "0.9400914880368294",
      "hi": "0.9558726718100513",
      "hu": "0.9821417383322963"
    }
  },
  {
    "task_id": "CPP/16",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *\n * Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n *\n * Parametrat:\n * - n (int): Numri i hedhjeve të monedhës.\n *\n * Kthen:\n * - unsigned long long: Numri i sekuencave të vlefshme.\n *\n * Shembuj:\n *   count_valid_coin_toss_sequences(1) kthen 2\n *   count_valid_coin_toss_sequences(2) kthen 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետման դեպքում:\n *\n * Պարամետրեր:\n * - n (int): Մետաղադրամի նետումների քանակը:\n *\n * Վերադարձնում է:\n * - unsigned long long: Վավեր հաջորդականությունների քանակը:\n *\n * Օրինակներ:\n *   count_valid_coin_toss_sequences(1) վերադարձնում է 2\n *   count_valid_coin_toss_sequences(2) վերադարձնում է 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n *\n * প্যারামিটার:\n * - n (int): কয়েন টসের সংখ্যা।\n *\n * রিটার্নস:\n * - unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n *\n * উদাহরণ:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Пребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n *\n * Параметри:\n * - n (int): Броят на хвърлянията на монетата.\n *\n * Връща:\n * - unsigned long long: Броят на валидните последователности.\n *\n * Примери:\n *   count_valid_coin_toss_sequences(1) връща 2\n *   count_valid_coin_toss_sequences(2) връща 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n *\n * 参数:\n * - n (int): 投掷硬币的次数。\n *\n * 返回:\n * - unsigned long long: 有效序列的数量。\n *\n * 示例:\n *   count_valid_coin_toss_sequences(1) 返回 2\n *   count_valid_coin_toss_sequences(2) 返回 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de séquences de lancers de pièces valides sans têtes consécutives en n lancers.\n *\n * Paramètres:\n * - n (int): Le nombre de lancers de pièces.\n *\n * Renvoie:\n * - unsigned long long: Le nombre de séquences valides.\n *\n * Exemples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n *\n * Parameter:\n * - n (int): Die Anzahl der Münzwürfe.\n *\n * Rückgabewert:\n * - unsigned long long: Die Anzahl der gültigen Sequenzen.\n *\n * Beispiele:\n *   count_valid_coin_toss_sequences(1) gibt 2 zurück\n *   count_valid_coin_toss_sequences(2) gibt 3 zurück\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙirga adadin jerin jefa tsabar kudi masu inganci tare da babu kawunan da ke jere a cikin jefa tsabar kudi n.\n *\n * Sigogi:\n * - n (int): Yawan jefa tsabar kudi.\n *\n * Komawa:\n * - unsigned long long: Adadin jerin masu inganci.\n *\n * Misalai:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n *\n * पैरामीटर्स:\n * - n (int): सिक्का उछालों की संख्या।\n *\n * रिटर्न्स:\n * - unsigned long long: वैध अनुक्रमों की गिनती।\n *\n * उदाहरण:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincsenek egymást követő fej dobások n dobás esetén.\n *\n * Paraméterek:\n * - n (int): A pénzfeldobások száma.\n *\n * Visszatérési érték:\n * - unsigned long long: Az érvényes sorozatok száma.\n *\n * Példák:\n *   count_valid_coin_toss_sequences(1) visszaadja 2\n *   count_valid_coin_toss_sequences(2) visszaadja 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9872423678868912",
      "hy": "0.987030230639946",
      "bn": "0.9899886315350795",
      "bg": "0.9940887598604017",
      "zh": "0.9771644582443241",
      "fr": "0.9940887598604017",
      "de": "0.9868635797502576",
      "ha": "0.990747995481776",
      "hi": "0.9876855122669801",
      "hu": "0.9727924049273652"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "Write a CPP function `unsigned long long count_valid_coin_toss_sequences(int n)` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3\n",
      "sq": "Shkruani një funksion CPP `unsigned long long count_valid_coin_toss_sequences(int n)` për të zgjidhur problemin e mëposhtëm: Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhave pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhave.\n\nKthen:\n- unsigned long long: Numri i sekuencave të vlefshme.\n\nShembuj:\n  count_valid_coin_toss_sequences(1) kthen 2\n  count_valid_coin_toss_sequences(2) kthen 3",
      "hy": "Գրեք CPP ֆունկցիա `unsigned long long count_valid_coin_toss_sequences(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ժամանակ չկան հաջորդական գլուխներ:\n\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\n\nՎերադարձնում է:\n- unsigned long long: Վավեր հաջորդականությունների քանակը։\n\nՕրինակներ:\n  count_valid_coin_toss_sequences(1) վերադարձնում է 2\n  count_valid_coin_toss_sequences(2) վերադարձնում է 3",
      "bn": "একটি CPP ফাংশন `unsigned long long count_valid_coin_toss_sequences(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বার টসের মধ্যে কোন ধারাবাহিক হেড ছাড়া বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nরিটার্নস:\n- unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n  count_valid_coin_toss_sequences(1) রিটার্ন করে 2\n  count_valid_coin_toss_sequences(2) রিটার্ন করে 3",
      "bg": "Напишете CPP функция `unsigned long long count_valid_coin_toss_sequences(int n)`, за да решите следния проблем:  \nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n- unsigned long long: Броят на валидните последователности.\n\nПримери:\n  count_valid_coin_toss_sequences(1) връща 2\n  count_valid_coin_toss_sequences(2) връща 3",
      "zh": "编写一个 CPP 函数 `unsigned long long count_valid_coin_toss_sequences(int n)` 来解决以下问题：\n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n\n参数：\n- n (int): 投掷硬币的次数。\n\n返回：\n- unsigned long long: 有效序列的数量。\n\n示例：\n  count_valid_coin_toss_sequences(1) 返回 2\n  count_valid_coin_toss_sequences(2) 返回 3",
      "fr": "Écrire une fonction CPP `unsigned long long count_valid_coin_toss_sequences(int n)` pour résoudre le problème suivant :  \nCompter le nombre de séquences valides de lancers de pièce sans têtes consécutives dans n lancers.\n\nParamètres :  \n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :  \n- unsigned long long : Le compte des séquences valides.\n\nExemples :  \n  count_valid_coin_toss_sequences(1) renvoie 2  \n  count_valid_coin_toss_sequences(2) renvoie 3  ",
      "de": "Schreiben Sie eine CPP-Funktion `unsigned long long count_valid_coin_toss_sequences(int n)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nRückgabewert:\n- unsigned long long: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n  count_valid_coin_toss_sequences(1) gibt 2 zurück\n  count_valid_coin_toss_sequences(2) gibt 3 zurück",
      "ha": "Rubuta aikin CPP `unsigned long long count_valid_coin_toss_sequences(int n)` don warware matsalar mai zuwa:\nƘididdige adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin n jefa.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n- unsigned long long: Adadin sahihan jerin.\n\nMisalai:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "hi": "एक CPP फ़ंक्शन `unsigned long long count_valid_coin_toss_sequences(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn उछालों में बिना लगातार हेड्स के मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n\nवापसी:\n- unsigned long long: मान्य अनुक्रमों की गिनती।\n\nउदाहरण:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "hu": "Írj egy CPP függvényt `unsigned long long count_valid_coin_toss_sequences(int n)` a következő probléma megoldására:\nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatérési érték:\n- unsigned long long: Az érvényes sorozatok száma.\n\nPéldák:\n  count_valid_coin_toss_sequences(1) visszaadja 2\n  count_valid_coin_toss_sequences(2) visszaadja 3"
    },
    "instruction_bertscore": {
      "sq": "0.9929567653188839",
      "hy": "0.9885614722473439",
      "bn": "0.9907964612947484",
      "bg": "0.9901129741536074",
      "zh": "0.9838604870193912",
      "fr": "0.9962450912769165",
      "de": "0.9795073035886306",
      "ha": "0.986103024021275",
      "hi": "0.9859453114987334",
      "hu": "0.9804615239391222"
    },
    "level": "easy",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n- unsigned long long: Numri i sekuencave të vlefshme.\n\nShembuj:\n  count_valid_coin_toss_sequences(1) kthen 2\n  count_valid_coin_toss_sequences(2) kthen 3",
      "hy": "Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետման դեպքում:\n\nՊարամետրեր:\n- n (int): Նետումների քանակը:\n\nՎերադարձնում է:\n- unsigned long long: Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\n  count_valid_coin_toss_sequences(1) վերադարձնում է 2\n  count_valid_coin_toss_sequences(2) վերադարձնում է 3",
      "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nফেরত দেয়:\n- unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n  count_valid_coin_toss_sequences(1) ফেরত দেয় 2\n  count_valid_coin_toss_sequences(2) ফেরত দেয় 3",
      "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n- unsigned long long: Броят на валидните последователности.\n\nПримери:\n  count_valid_coin_toss_sequences(1) връща 2\n  count_valid_coin_toss_sequences(2) връща 3",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n参数：\n- n (int): 硬币投掷的次数。\n\n返回：\n- unsigned long long: 有效序列的数量。\n\n示例：\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n\nParamètres :\n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :\n- unsigned long long : Le compte des séquences valides.\n\nExemples :\n  count_valid_coin_toss_sequences(1) renvoie 2\n  count_valid_coin_toss_sequences(2) renvoie 3",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nGibt zurück:\n- unsigned long long: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n  count_valid_coin_toss_sequences(1) gibt 2 zurück\n  count_valid_coin_toss_sequences(2) gibt 3 zurück",
      "ha": "Ƙirga adadin jerin jefa tsabar kudi masu inganci tare da babu kawunan da ke jere a cikin jefa tsabar kudi n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n- unsigned long long: Adadin sahihan jerin.\n\nMisalai:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "hi": "n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n\nवापसी:\n- unsigned long long: वैध अनुक्रमों की गिनती।\n\nउदाहरण:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "hu": "Számolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n- unsigned long long: Az érvényes sorozatok száma.\n\nPéldák:\n  count_valid_coin_toss_sequences(1) visszaadja 2\n  count_valid_coin_toss_sequences(2) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9792717279567232",
      "hy": "0.9826953212042405",
      "bn": "0.9814987717888863",
      "bg": "0.9851025227920024",
      "zh": "0.9806579693859657",
      "fr": "0.9953651586889319",
      "de": "0.9872671966845206",
      "ha": "0.9722181644957933",
      "hi": "0.9611500824037672",
      "hu": "0.9685429065555048"
    }
  },
  {
    "task_id": "CPP/17",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *\n * Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n * binare të një numri të plotë jo-negativ.\n *\n * Parametrat:\n * - n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n *\n * Kthen:\n * - int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n *        binare të numrit të dhënë.\n *\n * Shembuj:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Գտնել 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի \n * երկբայնական ներկայացման մեջ:\n *\n * Պարամետրեր:\n * - n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n *\n * Վերադարձնում է:\n * - int: 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը տրված թվի \n *        երկբայնական ներկայացման մեջ:\n *\n * Օրինակներ:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n *\n * প্যারামিটার:\n * - n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n *\n * রিটার্নস:\n * - int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n *\n * উদাহরণ:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното \n * представяне на неотрицателно цяло число.\n *\n * Параметри:\n * - n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n *\n * Връща:\n * - int: Дължината на най-дългата последователна поредица от 1-ци в двоичното \n *        представяне на даденото число.\n *\n * Примери:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 找到非负整数的二进制表示中最长连续1序列的长度。\n *\n * 参数:\n * - n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 返回:\n * - int: 给定整数的二进制表示中最长连续1序列的长度。\n *\n * 示例:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Trouver la longueur de la plus longue séquence consécutive de 1 dans la \n * représentation binaire d'un entier non négatif.\n *\n * Paramètres :\n * - n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Renvoie :\n * - int : La longueur de la plus longue séquence consécutive de 1 dans la \n *        représentation binaire de l'entier donné.\n *\n * Exemples :\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n * Binärdarstellung einer nicht-negativen ganzen Zahl.\n *\n * Parameter:\n * - n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n *\n * Rückgabe:\n * - int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n *        Binärdarstellung der gegebenen Zahl.\n *\n * Beispiele:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary \n * na lamba mara kyau.\n *\n * Sigogi:\n * - n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n *\n * Komawa:\n * - int: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary \n *        na lambar da aka bayar.\n *\n * Misalai:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक गैर-ऋणात्मक पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे लगातार अनुक्रम की लंबाई खोजें।\n *\n * पैरामीटर:\n * - n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n *\n * रिटर्न करता है:\n * - int: दिए गए पूर्णांक के द्विआधारी रूप में 1s के सबसे लंबे लगातार अनुक्रम की लंबाई।\n *\n * उदाहरण:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris \n * ábrázolásában.\n *\n * Paraméterek:\n * - n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n *\n * Visszatérési érték:\n * - int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris \n *        ábrázolásában.\n *\n * Példák:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "sq": "0.9803560512067927",
      "hy": "0.9837860006265031",
      "bn": "0.9881542799662224",
      "bg": "0.9931154709933308",
      "zh": "0.9855460644328533",
      "fr": "0.9952159872727747",
      "de": "0.9915272224665758",
      "ha": "0.9489080947598251",
      "hi": "0.9765828684886539",
      "hu": "0.9846744743208722"
    },
    "canonical_solution": "{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}",
    "instruction": {
      "en": "Write a CPP function `int find_longest_consecutive_ones_length(unsigned long long n)` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "sq": "Shkruani një funksion CPP `int find_longest_consecutive_ones_length(unsigned long long n)` për të zgjidhur problemin e mëposhtëm:\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të një numri të plotë jo-negativ.\n\nParametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen binare të numrit të dhënë.\n\nShembuj:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hy": "Գրեք CPP ֆունկցիա `int find_longest_consecutive_ones_length(unsigned long long n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- int: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n\nՕրինակներ:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "bn": "একটি CPP ফাংশন `int find_longest_consecutive_ones_length(unsigned long long n)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nরিটার্নস:\n- int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "bg": "Напишете CPP функция `int find_longest_consecutive_ones_length(unsigned long long n)`, за да решите следния проблем:  \nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- int: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "zh": "编写一个 CPP 函数 `int find_longest_consecutive_ones_length(unsigned long long n)` 来解决以下问题：\n找到一个非负整数的二进制表示中最长连续 1 的序列长度。\n\n参数：\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\n- int: 给定整数的二进制表示中最长连续 1 的序列长度。\n\n示例：\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "fr": "Écrire une fonction CPP `int find_longest_consecutive_ones_length(unsigned long long n)` pour résoudre le problème suivant :  \nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :  \n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :  \n- int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :  \n  >>> find_longest_consecutive_ones_length(7)  \n  3  ",
      "de": "Schreiben Sie eine CPP-Funktion `int find_longest_consecutive_ones_length(unsigned long long n)`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "ha": "Rubuta aikin CPP `int find_longest_consecutive_ones_length(unsigned long long n)` don warware matsalar mai zuwa:\nNemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- int: Tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hi": "एक CPP फ़ंक्शन `int find_longest_consecutive_ones_length(unsigned long long n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nParameters:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nReturns:\n- int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nExamples:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hu": "Írj egy CPP függvényt `int find_longest_consecutive_ones_length(unsigned long long n)` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem-negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (unsigned long long): Egy nem-negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n  >>> find_longest_consecutive_ones_length(7)\n  3"
    },
    "instruction_bertscore": {
      "sq": "0.9760517308497666",
      "hy": "0.9864599628159948",
      "bn": "0.999999801369619",
      "bg": "0.98966049414561",
      "zh": "0.9950177541525019",
      "fr": "0.999999801369619",
      "de": "0.9807221269990399",
      "ha": "0.9720975958545052",
      "hi": "0.9923134015147119",
      "hu": "0.9953748915776026"
    },
    "level": "hard",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hy": "Բացահայտեք 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի երկբայնի ներկայացման մեջ:\n\nՊարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- int: Տրված ամբողջ թվի երկբայնի ներկայացման մեջ 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը:\n\nՕրինակներ:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n- int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "bg": "Намерете дължината на най-дългата последователна поредица от 1 в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- int: Дължината на най-дългата последователна поредица от 1 в двоичното представяне на даденото число.\n\nПримери:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数:\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回:\n- int: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\n- int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "de": "Finden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "ha": "Nemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (unsigned long long): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n- int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hu": "Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n  >>> find_longest_consecutive_ones_length(7)\n  3"
    },
    "docstring_bertscore": {
      "sq": "0.9678433303534999",
      "hy": "0.9864547984260879",
      "bn": "0.999999801369619",
      "bg": "0.9892745553152591",
      "zh": "0.9937016292477647",
      "fr": "0.999999801369619",
      "de": "0.9849052828236347",
      "ha": "0.9884836091379782",
      "hi": "0.9954231587601942",
      "hu": "0.9939540884620601"
    }
  },
  {
    "task_id": "CPP/18",
    "prompt": {
      "en": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.\n * Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "sq": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Gjeneron një identifikues unik duke ndërthurur dy fjalë në një model të specifikuar.\n * @param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n * @param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n * @return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë,\n *         e kthyer mbrapsht, me karaktere nga fjala e parë.\n * Shembull Përdorimi:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "hy": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի ձևով միահյուսելով:\n * @param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի հակադարձված\n *         տառերը հերթագայելով առաջին բառի տառերի հետ:\n * Օրինակային օգտագործում:\n * \n * create_id(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\n * create_id(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "bn": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * একটি অনন্য শনাক্তকারী তৈরি করে দুটি শব্দকে একটি নির্দিষ্ট প্যাটার্নে আন্তঃপ্রবাহিত করে।\n * @param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n * @param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n * @return একটি অনন্য শনাক্তকারী যা দ্বিতীয় শব্দের অক্ষরগুলি, বিপরীতক্রমে, প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে গঠিত।\n * উদাহরণ ব্যবহার:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "bg": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n * @param word1 Първата дума, която ще се използва в процеса на създаване на идентификатора.\n * @param word2 Втората дума, която ще се използва в процеса на създаване на идентификатора.\n * @return Уникален идентификатор, образуван чрез редуване на символи от втората дума,\n *         обърната, със символи от първата дума.\n * Пример за използване:\n * \n * create_id(\"fish\", \"cat\") връща \"ftiasch\"\n * create_id(\"icpc\", \"acm\") връща \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "zh": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 通过以指定模式交织两个单词生成唯一标识符。\n * @param word1 在ID创建过程中使用的第一个单词。\n * @param word2 在ID创建过程中使用的第二个单词。\n * @return 一个唯一标识符，由第二个单词的字符反转后与第一个单词的字符交替形成。\n * 示例用法：\n * \n * create_id(\"fish\", \"cat\") 返回 \"ftiasch\"\n * create_id(\"icpc\", \"acm\") 返回 \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "fr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Génère un identifiant unique en entrelaçant deux mots selon un schéma spécifié.\n * @param word1 Le premier mot à utiliser dans le processus de création de l'identifiant.\n * @param word2 Le deuxième mot à utiliser dans le processus de création de l'identifiant.\n * @return Un identifiant unique formé en alternant les caractères du deuxième mot,\n *         inversé, avec les caractères du premier mot.\n * Exemple d'utilisation :\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "de": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generiert eine eindeutige Kennung, indem zwei Wörter in einem bestimmten Muster verflochten werden.\n * @param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n * @param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n * @return Eine eindeutige Kennung, die durch abwechselnde Zeichen aus dem zweiten Wort,\n *         rückwärts, mit Zeichen aus dem ersten Wort gebildet wird.\n * Beispielverwendung:\n * \n * create_id(\"fish\", \"cat\") gibt \"ftiasch\" zurück\n * create_id(\"icpc\", \"acm\") gibt \"imccpac\" zurück\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "ha": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Yana samar da mai ganowa na musamman ta hanyar haɗa kalmomi biyu a cikin tsari da aka fayyace.\n * @param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @return Mai ganowa na musamman da aka samar ta hanyar musanya haruffa daga kalma ta biyu,\n *         a juye, tare da haruffa daga kalma ta farko.\n * Misalin Amfani:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "hi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n * @param word1 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए पहला शब्द।\n * @param word2 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए दूसरा शब्द।\n * @return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के अक्षरों को उल्टा करके,\n *         पहले शब्द के अक्षरों के साथ बारी-बारी से बनता है।\n * उदाहरण उपयोग:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "hu": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Egyedi azonosítót generál két szó megadott mintázat szerinti összefűzésével.\n * @param word1 Az első szó, amelyet az azonosító létrehozásához használunk.\n * @param word2 A második szó, amelyet az azonosító létrehozásához használunk.\n * @return Egy egyedi azonosító, amely a második szó karaktereiből, fordítva,\n *         és az első szó karaktereiből váltakozva áll.\n * Példa használat:\n * \n * create_id(\"fish\", \"cat\") visszaadja \"ftiasch\"\n * create_id(\"icpc\", \"acm\") visszaadja \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9708003408359662",
      "bn": "0.9498559589381235",
      "bg": "0.9729568708828621",
      "zh": "0.9628171871917931",
      "fr": "0.9709644095307011",
      "de": "0.9774437325600591",
      "ha": "0.9676294054331253",
      "hi": "0.9659507800829995",
      "hu": "0.9427426077325021"
    },
    "canonical_solution": "{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}",
    "instruction": {
      "en": "Write a CPP function `std::string create_id(const std::string& word1, const std::string& word2)` to solve the following problem:\nGenerates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"\n\n",
      "sq": "Shkruani një funksion CPP `std::string create_id(const std::string& word1, const std::string& word2)` për të zgjidhur problemin e mëposhtëm:\nGjeneron një identifikues unik duke ndërthurur dy fjalë në një model të specifikuar.\n@param word1 Fjalë e parë që do të përdoret në procesin e krijimit të ID-së.\n@param word2 Fjalë e dytë që do të përdoret në procesin e krijimit të ID-së.\n@return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë, e përmbysur, me karakteret nga fjala e parë.\nShembull Përdorimi:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hy": "Գրեք CPP ֆունկցիա `std::string create_id(const std::string& word1, const std::string& word2)` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի նախշով փոխկապակցելով:\n@param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի, շրջված, և առաջին բառի տառերը հերթափոխելով:\nՕրինակ օգտագործում:\n\ncreate_id(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"",
      "bn": "একটি CPP ফাংশন `std::string create_id(const std::string& word1, const std::string& word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি শব্দকে একটি নির্দিষ্ট প্যাটার্নে একত্রিত করে একটি অনন্য শনাক্তকারী তৈরি করে।\n@param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n@param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n@return দ্বিতীয় শব্দের বিপরীত অক্ষরগুলি প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে ব্যবহার করে গঠিত একটি অনন্য শনাক্তকারী।\nউদাহরণ ব্যবহার:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "bg": "Напишете CPP функция `std::string create_id(const std::string& word1, const std::string& word2)`, за да решите следния проблем:\nГенерира уникален идентификатор, като преплита две думи по определен модел.\n@param word1 Първата дума, която ще се използва в процеса на създаване на идентификатор.\n@param word2 Втората дума, която ще се използва в процеса на създаване на идентификатор.\n@return Уникален идентификатор, образуван чрез редуване на символи от втората дума, обърната, със символи от първата дума.\nПример за използване:\n\ncreate_id(\"fish\", \"cat\") връща \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") връща \"imccpac\"",
      "zh": "编写一个 CPP 函数 `std::string create_id(const std::string& word1, const std::string& word2)` 来解决以下问题：\n生成一个通过以指定模式交织两个单词的唯一标识符。\n@param word1 在 ID 创建过程中使用的第一个单词。\n@param word2 在 ID 创建过程中使用的第二个单词。\n@return 一个通过从第二个单词反向交替字符与第一个单词字符形成的唯一标识符。\n示例用法：\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "fr": "Écrire une fonction CPP `std::string create_id(const std::string& word1, const std::string& word2)` pour résoudre le problème suivant :\nGénère un identifiant unique en entrelaçant deux mots selon un modèle spécifié.\n@param word1 Le premier mot à utiliser dans le processus de création de l'identifiant.\n@param word2 Le deuxième mot à utiliser dans le processus de création de l'identifiant.\n@return Un identifiant unique formé en alternant les caractères du deuxième mot, inversé, avec les caractères du premier mot.\nExemple d'utilisation :\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "de": "Schreiben Sie eine CPP-Funktion `std::string create_id(const std::string& word1, const std::string& word2)`, um das folgende Problem zu lösen:\nErzeugt einen eindeutigen Bezeichner, indem zwei Wörter in einem bestimmten Muster verflochten werden.\n@param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n@param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n@return Ein eindeutiger Bezeichner, der durch abwechselnde Zeichen aus dem zweiten Wort, umgekehrt, mit Zeichen aus dem ersten Wort gebildet wird.\nBeispielverwendung:\n\ncreate_id(\"fish\", \"cat\") gibt \"ftiasch\" zurück\ncreate_id(\"icpc\", \"acm\") gibt \"imccpac\" zurück",
      "ha": "Rubuta aikin CPP `std::string create_id(const std::string& word1, const std::string& word2)` don warware matsalar mai zuwa:\nƘirƙirar mai ganowa na musamman ta hanyar haɗa kalmomi biyu a cikin wata tsari da aka fayyace.\n@param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@return Mai ganowa na musamman da aka samar ta hanyar madadin haruffa daga kalma ta biyu, a juye, tare da haruffa daga kalma ta farko.\nMisalin Amfani:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hi": "एक CPP फ़ंक्शन `std::string create_id(const std::string& word1, const std::string& word2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n@param word1 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला पहला शब्द।\n@param word2 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला दूसरा शब्द।\n@return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के उल्टे वर्णों को पहले शब्द के वर्णों के साथ वैकल्पिक करके बनता है।\nउदाहरण उपयोग:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hu": "Írj egy CPP függvényt `std::string create_id(const std::string& word1, const std::string& word2)` a következő probléma megoldására:\nEgyedi azonosító generálása két szó összefonásával egy meghatározott mintában.\n@param word1 Az első szó, amelyet az azonosító létrehozási folyamatában használnak.\n@param word2 A második szó, amelyet az azonosító létrehozási folyamatában használnak.\n@return Egy egyedi azonosító, amelyet a második szó visszafelé váltakozó karakterei és az első szó karakterei alkotnak.\nPélda használat:\n\ncreate_id(\"fish\", \"cat\") visszaadja \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") visszaadja \"imccpac\""
    },
    "instruction_bertscore": {
      "sq": "0.9845910495608375",
      "hy": "0.9673024598259419",
      "bn": "0.9442152533774948",
      "bg": "0.9805276678560068",
      "zh": "0.969557709172212",
      "fr": "0.9666120206214646",
      "de": "0.9784273502069439",
      "ha": "0.9696250448713828",
      "hi": "0.9599070534792509",
      "hu": "0.9665875890845973"
    },
    "level": "hard",
    "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "std::string create_id(const std::string& word1, const std::string& word2)",
    "docstring": {
      "en": "Generates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"\n\n",
      "sq": "Gjeneron një identifikues unik duke ndërthurur dy fjalë sipas një modeli të specifikuar.\n@param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n@param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n@return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë, e kthyer mbrapsht, me karakteret nga fjala e parë.\nShembull i Përdorimit:\n\ncreate_id(\"fish\", \"cat\") kthen \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") kthen \"imccpac\"",
      "hy": "Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի նախշով միահյուսելով:\n@param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի, հակադարձված, և առաջին բառի տառերը հերթագայելով:\nՕրինակ օգտագործում:\n\ncreate_id(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"",
      "bn": "একটি নির্দিষ্ট প্যাটার্নে দুটি শব্দ একত্রিত করে একটি অনন্য শনাক্তকারী তৈরি করে।\n@param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n@param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n@return দ্বিতীয় শব্দের অক্ষরগুলি, উল্টো করে, প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে মিলিয়ে গঠিত একটি অনন্য শনাক্তকারী।\nব্যবহারের উদাহরণ:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "bg": "Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n@param word1 Първата дума, която ще се използва в процеса на създаване на идентификатора.\n@param word2 Втората дума, която ще се използва в процеса на създаване на идентификатора.\n@return Уникален идентификатор, образуван чрез редуване на символи от втората дума, обърната, със символи от първата дума.\nПример за използване:\n\ncreate_id(\"fish\", \"cat\") връща \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") връща \"imccpac\"",
      "zh": "生成一个唯一标识符，通过以指定模式交织两个单词来实现。\n@param word1 用于创建ID的第一个单词。\n@param word2 用于创建ID的第二个单词。\n@return 一个唯一标识符，通过从第二个单词反向交替字符与第一个单词的字符形成。\n示例用法：\n\ncreate_id(\"fish\", \"cat\") 返回 \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") 返回 \"imccpac\"",
      "fr": "Génère un identifiant unique en entrelaçant deux mots selon un modèle spécifié.\n@param word1 Le premier mot à utiliser dans le processus de création de l'ID.\n@param word2 Le deuxième mot à utiliser dans le processus de création de l'ID.\n@return Un identifiant unique formé en alternant des caractères du deuxième mot, inversé, avec des caractères du premier mot.\nExemple d'utilisation :\n\ncreate_id(\"fish\", \"cat\") retourne \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") retourne \"imccpac\"",
      "de": "Erzeugt einen eindeutigen Bezeichner, indem zwei Wörter in einem bestimmten Muster miteinander verflochten werden.\n@param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n@param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n@return Ein eindeutiger Bezeichner, der durch abwechselnde Zeichen aus dem zweiten Wort, umgekehrt, mit Zeichen aus dem ersten Wort gebildet wird.\nBeispielverwendung:\n\ncreate_id(\"fish\", \"cat\") gibt \"ftiasch\" zurück\ncreate_id(\"icpc\", \"acm\") gibt \"imccpac\" zurück",
      "ha": "Yana haifar da mai gano na musamman ta hanyar haɗa kalmomi biyu a cikin tsari da aka fayyace.\n@param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@return Mai gano na musamman da aka samar ta hanyar madadin haruffa daga kalma ta biyu, da aka juya, tare da haruffa daga kalma ta farko.\nMisalin Amfani:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hi": "दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n@param word1 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला पहला शब्द।\n@param word2 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला दूसरा शब्द।\n@return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के अक्षरों को उलट कर, पहले शब्द के अक्षरों के साथ बारी-बारी से बनता है।\nउदाहरण उपयोग:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hu": "Egyedi azonosítót generál két szó meghatározott mintázat szerinti összefonásával.\n@param word1 Az első szó, amelyet az azonosító létrehozási folyamatában használunk.\n@param word2 A második szó, amelyet az azonosító létrehozási folyamatában használunk.\n@return Egyedi azonosító, amelyet a második szó visszafelé vett karaktereinek és az első szó karaktereinek váltakozásával hozunk létre.\nPélda használat:\n\ncreate_id(\"fish\", \"cat\") visszaadja \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") visszaadja \"imccpac\""
    },
    "docstring_bertscore": {
      "sq": "0.9900692754697797",
      "hy": "0.9553967534170917",
      "bn": "0.92513223678033",
      "bg": "0.9784946859061148",
      "zh": "0.9350641530928364",
      "fr": "0.976930273025084",
      "de": "0.9757114770070539",
      "ha": "0.9526747226753897",
      "hi": "0.9171119392549032",
      "hu": "0.9416400104873774"
    }
  },
  {
    "task_id": "CPP/19",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n * \n * Parameters:\n * - n (int): Length of the binary string.\n * - m (int): Number of '1's in the binary string.\n * \n * Returns:\n * - int: The total number of different permutation schemes.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\n * ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n * \n * Parametrat:\n * - n (int): Gjatësia e vargut binar.\n * - m (int): Numri i '1'-ve në vargun binar.\n * \n * Kthen:\n * - int: Numri total i skemave të ndryshme të permutimit.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել տարբեր տեղափոխման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է,\n * որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է:\n * \n * Պարամետրեր:\n * - n (int): Երկբայնային տողի երկարությունը:\n * - m (int): '1'-երի քանակը երկբայնային տողում:\n * \n * Վերադարձնում է:\n * - int: Տարբեր տեղափոխման սխեմաների ընդհանուր քանակը:\n */\nint count_permutations_of_binary_string(int n, int m)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস পরিকল্পনার সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\n * যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n * \n * প্যারামিটার:\n * - n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n * - m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n * \n * রিটার্নস:\n * - int: বিভিন্ন বিন্যাস পরিকল্পনার মোট সংখ্যা।\n */\nint count_permutations_of_binary_string(int n, int m)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Пребройте броя на различните схеми на пермутации за двоична редица с дължина n,\n * където броят на '1'-ците е m, а броят на '0'-ците е n - m.\n * \n * Параметри:\n * - n (int): Дължина на двоичната редица.\n * - m (int): Брой на '1'-ците в двоичната редица.\n * \n * Връща:\n * - int: Общият брой на различните схеми на пермутации.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算长度为 n 的二进制字符串的不同排列方案的数量，\n * 其中 '1' 的数量为 m，'0' 的数量为 n - m。\n * \n * 参数：\n * - n (int): 二进制字符串的长度。\n * - m (int): 二进制字符串中 '1' 的数量。\n * \n * 返回：\n * - int: 不同排列方案的总数量。\n */\nint count_permutations_of_binary_string(int n, int m)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\n * où le nombre de '1' est m et le nombre de '0' est n - m.\n * \n * Paramètres :\n * - n (int) : Longueur de la chaîne binaire.\n * - m (int) : Nombre de '1' dans la chaîne binaire.\n * \n * Renvoie :\n * - int : Le nombre total de différents schémas de permutation.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\n * wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n * \n * Parameter:\n * - n (int): Länge des Binärstrings.\n * - m (int): Anzahl der '1's im Binärstring.\n * \n * Rückgabewert:\n * - int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙididdige adadin tsarin permutation daban-daban don igiyar binary mai tsawon n,\n * inda adadin '1's shine m kuma adadin '0's shine n - m.\n * \n * Sigogi:\n * - n (int): Tsawon igiyar binary.\n * - m (int): Adadin '1's a cikin igiyar binary.\n * \n * Komawa:\n * - int: Jimlar adadin tsarin permutation daban-daban.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक बाइनरी स्ट्रिंग की विभिन्न क्रमचय योजनाओं की संख्या गिनें जिसकी लंबाई n है,\n * जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n * \n * पैरामीटर:\n * - n (int): बाइनरी स्ट्रिंग की लंबाई।\n * - m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n * \n * लौटाता है:\n * - int: विभिन्न क्रमचय योजनाओं की कुल संख्या।\n */\nint count_permutations_of_binary_string(int n, int m)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\n * ahol az '1'-ek száma m és a '0'-k száma n - m.\n * \n * Paraméterek:\n * - n (int): A bináris karakterlánc hossza.\n * - m (int): Az '1'-ek száma a bináris karakterláncban.\n * \n * Visszatérési érték:\n * - int: A különböző permutációs sémák összes száma.\n */\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9965646875600016",
      "hy": "0.9847664401872913",
      "bn": "0.9813192099244309",
      "bg": "0.9854910438173066",
      "zh": "0.9502897676903037",
      "fr": "0.9907583242615897",
      "de": "0.9958627277934243",
      "ha": "0.9805650103676413",
      "hi": "0.9956809809947774",
      "hu": "0.9891682880614054"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `int count_permutations_of_binary_string(int n, int m)` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.",
      "sq": "Shkruani një funksion CPP `int count_permutations_of_binary_string(int n, int m)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\n- int: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Գրեք CPP ֆունկցիա `int count_permutations_of_binary_string(int n, int m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տարբեր փոխատեղման սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբանական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբանական տողում։\n\nՎերադարձնում է:\n- int: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։",
      "bn": "একটি CPP ফাংশন `int count_permutations_of_binary_string(int n, int m)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন যার দৈর্ঘ্য n, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n- int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Напишете CPP функция `int count_permutations_of_binary_string(int n, int m)`, за да решите следния проблем:\nПребройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ите е n - m.\n\nПараметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n\nВръща:\n- int: Общият брой на различните схеми на пермутации.",
      "zh": "编写一个 CPP 函数 `int count_permutations_of_binary_string(int n, int m)` 来解决以下问题：\n计算长度为 n 的二进制字符串的不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\n- int: 不同排列方案的总数。",
      "fr": "Écrire une fonction CPP `int count_permutations_of_binary_string(int n, int m)` pour résoudre le problème suivant :\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\n- int : Le nombre total de différents schémas de permutation.",
      "de": "Schreiben Sie eine CPP-Funktion `int count_permutations_of_binary_string(int n, int m)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Rubuta aikin CPP `int count_permutations_of_binary_string(int n, int m)` don warware matsalar mai zuwa:\nƘididdige adadin tsarin permutation daban-daban don wani binary string mai tsawon n, inda adadin '1's yake m kuma adadin '0's yake n - m.\n\nSigogi:\n- n (int): Tsawon binary string.\n- m (int): Adadin '1's a cikin binary string.\n\nDawowa:\n- int: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "`int count_permutations_of_binary_string(int n, int m)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n के एक बाइनरी स्ट्रिंग के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\n- int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Írj egy CPP függvényt `int count_permutations_of_binary_string(int n, int m)` a következő probléma megoldására:\nSzámold meg, hány különböző permutációs séma létezik egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatérési érték:\n- int: A különböző permutációs sémák teljes száma."
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9880525812111325",
      "bn": "0.9951587817230366",
      "bg": "0.9889350959940705",
      "zh": "0.9723228427065986",
      "fr": "0.9889350959940705",
      "de": "0.9847161867008895",
      "ha": "0.9837476649629634",
      "hi": "0.9848226525851242",
      "hu": "0.9815410800600468"
    },
    "level": "hard",
    "test": "int main() {\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\n- int: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր փոխարկման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n\nՎերադարձնում է:\n- int: Տարբեր փոխարկման սխեմաների ընդհանուր քանակը։",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n- int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната низ.\n- m (int): Брой '1'-ци в двоичната низ.\n\nВръща:\n- int: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回:\n- int: 不同排列方案的总数量。",
      "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRetourne :\n- int : Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙididdige adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n, inda adadin '1's yake m kuma adadin '0's yake n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawowa:\n- int: Jimlar adadin tsarin juyawa daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nवापसी:\n- int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\n- int: A különböző permutációs sémák teljes száma."
    },
    "docstring_bertscore": {
      "sq": "0.9963597010067736",
      "hy": "0.9674786449739198",
      "bn": "0.9649989432970802",
      "bg": "1",
      "zh": "0.9610938700059344",
      "fr": "0.9854634341943428",
      "de": "0.9940009652319843",
      "ha": "0.978057897698219",
      "hi": "0.9963597010067736",
      "hu": "0.9829547324818722"
    }
  },
  {
    "task_id": "CPP/20",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Answer a series of questions by providing choices A, B, C, or D for each question.\n *  \n *  Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n *  \n *  Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n *  \n *  Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n *  \n *  Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n *  \n *  You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nconst char* answer_questions()",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Përgjigju një serie pyetjesh duke ofruar zgjedhjet A, B, C, ose D për secilën pyetje.\n *  \n *  Pyetja 1:\n *  Konstantet si 1e6 i përkasin cilit tip të dhënash?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pyetja 2:\n *  Duke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i dhënash mund të përdoret për të ruajtur këtë vlerë?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Asnjë nga më sipër\n *  \n *  Pyetja 3:\n *  Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n *      A. Shprehjet me emra variablash janë vlera të majta.\n *      B. Operacioni i inkrementimit kërkon që operandi të jetë vlerë e majtë.\n *      C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n *      D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n *  \n *  Pyetja 4:\n *  Cila deklaratë për funksionet është e pasaktë?\n *      A. Parametrat formalë të një funksioni janë variabla lokale.\n *      B. Variablat lokale kanë hapësirë të caktuar në stack.\n *      C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n *      D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n *  \n *  Pyetja 5:\n *  Cila deklaratë për treguesit është e pasaktë?\n *      A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n *      B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n *      C. int *p[4], p është një varg treguesish int.\n *      D. Emrat e funksioneve mund të caktohen në tregues të funksioneve.\n *  \n *  Duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n */",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Պատասխանել մի շարք հարցերի՝ տրամադրելով ընտրանքներ A, B, C կամ D յուրաքանչյուր հարցի համար:\n *  \n *  Հարց 1:\n *  1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Հարց 2:\n *  Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Վերը նշվածներից ոչ մեկը\n *  \n *  Հարց 3:\n *  Որ հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n *      A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n *      B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *      C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n *      D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n *  \n *  Հարց 4:\n *  Որ հայտարարությունը ֆունկցիաների մասին սխալ է?\n *      A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *      B. Տեղական փոփոխականները հատկացվում են ստեկում:\n *      C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *      D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n *  \n *  Հարց 5:\n *  Որ հայտարարությունը ցուցիչների մասին սխալ է?\n *      A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *      B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *      C. int *p[4], p-ն int ցուցիչների զանգված է:\n *      D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n *  \n *  Դուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:\n */\nconst char* answer_questions()",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলোর উত্তর দিন।\n *  \n *  প্রশ্ন ১:\n *  1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  প্রশ্ন ২:\n *  প্রদত্ত 21! = 51,090,942,171,709,440,000, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *      A. int\n *      B. long long\n *      C. double\n *      D. উপরোক্ত কোনোটিই নয়\n *  \n *  প্রশ্ন ৩:\n *  এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n *      A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *      B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *      C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *      D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n *  \n *  প্রশ্ন ৪:\n *  ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n *      A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *      B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n *      C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n *      D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n *  \n *  প্রশ্ন ৫:\n *  পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n *      A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n *      B. পয়েন্টার ডেরেফারেন্সের জন্য পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n *      C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n *      D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n *  \n *  আপনি শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলোর জন্য দাঁড়ায়।\n */\nconst char* answer_questions()",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n *  \n *  Въпрос 1:\n *  Константи като 1e6 принадлежат към кой тип данни?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Въпрос 2:\n *  Дадено 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Нито едно от горните\n *  \n *  Въпрос 3:\n *  Кое твърдение за левите стойности в изразите е неправилно?\n *      A. Изразите с имена на променливи са леви стойности.\n *      B. Операцията за инкремент изисква операндът да е лява стойност.\n *      C. Изразите за дереференция на указатели са леви стойности.\n *      D. Изразите за префиксен инкремент са леви стойности.\n *  \n *  Въпрос 4:\n *  Кое твърдение за функциите е неправилно?\n *      A. Формалните параметри на функцията са локални променливи.\n *      B. Локалните променливи се разпределят в стека.\n *      C. Типът на функцията е същият като типа на връщаната стойност.\n *      D. Функцията може да извика себе си от своето тяло.\n *  \n *  Въпрос 5:\n *  Кое твърдение за указателите е неправилно?\n *      A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n *      B. Дереференцията на указател включва разрешаване на базата на типа на указателя.\n *      C. int *p[4], p е масив от указатели към int.\n *      D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n *  \n *  Предполага се, че трябва да върнете само низове, подобни на \"AAAAA\", които означават изборите на въпросите.\n */\nconst char* answer_questions()",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n *  \n *  问题 1:\n *  常量如 1e6 属于哪种数据类型？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  问题 2:\n *  给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 以上都不是\n *  \n *  问题 3:\n *  关于表达式中的左值，哪个说法是不正确的？\n *      A. 变量名表达式是左值。\n *      B. 增量操作要求操作数是左值。\n *      C. 指针解引用表达式是左值。\n *      D. 前缀增量操作表达式是左值。\n *  \n *  问题 4:\n *  关于函数，哪个说法是不正确的？\n *      A. 函数的形式参数是局部变量。\n *      B. 局部变量在栈中分配空间。\n *      C. 函数类型与返回值类型相同。\n *      D. 函数可以在其主体内调用自身。\n *  \n *  问题 5:\n *  关于指针，哪个说法是不正确的？\n *      A. 两个指针相减等于它们地址值的差。\n *      B. 指针解引用涉及基于指针的类型进行解析。\n *      C. int *p[4], p 是一个 int 指针的数组。\n *      D. 函数名可以赋值给函数指针。\n *  \n *  你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。\n */\nconst char* answer_questions()",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Répondre à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n *  \n *  Question 1 :\n *  Les constantes comme 1e6 appartiennent à quel type de données ?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2 :\n *  Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Aucun des précédents\n *  \n *  Question 3 :\n *  Quelle affirmation sur les valeurs à gauche dans les expressions est incorrecte ?\n *      A. Les expressions de nom de variable sont des valeurs à gauche.\n *      B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n *      C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *      D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n *  \n *  Question 4 :\n *  Quelle affirmation sur les fonctions est incorrecte ?\n *      A. Les paramètres formels d'une fonction sont des variables locales.\n *      B. Les variables locales sont allouées dans la pile.\n *      C. Le type de la fonction est le même que le type de la valeur de retour.\n *      D. Une fonction peut s'appeler elle-même depuis son corps.\n *  \n *  Question 5 :\n *  Quelle affirmation sur les pointeurs est incorrecte ?\n *      A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *      B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *      C. int *p[4], p est un tableau de pointeurs int.\n *      D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n *  \n *  Vous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n */\nconst char* answer_questions()",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n *  \n *  Frage 1:\n *  Konstanten wie 1e6 gehören zu welchem Datentyp?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Frage 2:\n *  Angenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Keine der oben genannten\n *  \n *  Frage 3:\n *  Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *      A. Variablennamenausdrücke sind linke Werte.\n *      B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n *      C. Zeiger-Dereferenzierungsausdrücke sind linke Werte.\n *      D. Präfix-Inkrementierungsoperationen sind linke Werte.\n *  \n *  Frage 4:\n *  Welche Aussage über Funktionen ist falsch?\n *      A. Formale Parameter einer Funktion sind lokale Variablen.\n *      B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n *      C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *      D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n *  \n *  Frage 5:\n *  Welche Aussage über Zeiger ist falsch?\n *      A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n *      B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n *      C. int *p[4], p ist ein Array von int-Zeigern.\n *      D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n *  \n *  Sie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nconst char* answer_questions()",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n *  \n *  Tambaya ta 1:\n *  Kwatankwacin kamar 1e6 suna cikin wane nau'in bayanai?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Tambaya ta 2:\n *  An ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Babu ɗaya daga cikin waɗanda ke sama\n *  \n *  Tambaya ta 3:\n *  Wane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n *      A. Bayanan sunan canji suna ƙimar hagu.\n *      B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n *      C. Bayanan cire alamar mai nuna suna ƙimar hagu.\n *      D. Bayanan aikin ƙaruwa na farko suna ƙimar hagu.\n *  \n *  Tambaya ta 4:\n *  Wane bayani game da ayyuka ba daidai ba ne?\n *      A. Sigogin tsari na aiki su ne canje-canje na gida.\n *      B. Ana ware sarari ga canje-canje na gida a cikin tsari.\n *      C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n *      D. Aiki na iya kiran kansa daga cikin jikinsa.\n *  \n *  Tambaya ta 5:\n *  Wane bayani game da masu nuna ba daidai ba ne?\n *      A. Rarrabe masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n *      B. Cire alamar mai nuna yana da alaƙa da warwarewa bisa nau'in mai nuna.\n *      C. int *p[4], p tsari ne na masu nuna int.\n *      D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka.\n *  \n *  Ana tsammanin ku dawo da kirtani kamar \"AAAAA\" kawai, wanda ke wakiltar zaɓuɓɓukan tambayar.\n */",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n *  \n *  प्रश्न 1:\n *  1e6 जैसे स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  प्रश्न 2:\n *  दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n *      A. int\n *      B. long long\n *      C. double\n *      D. उपरोक्त में से कोई नहीं\n *  \n *  प्रश्न 3:\n *  अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *      A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *      B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *      C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *      D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n *  \n *  प्रश्न 4:\n *  कार्यों के बारे में कौन सा कथन गलत है?\n *      A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल हैं।\n *      B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n *      C. फ़ंक्शन प्रकार और रिटर्न मान प्रकार समान होते हैं।\n *      D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n *  \n *  प्रश्न 5:\n *  पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *      A. दो पॉइंटर्स को घटाने से उनके पते के मानों का अंतर प्राप्त होता है।\n *      B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *      C. int *p[4], p एक int पॉइंटर्स की एक सरणी है।\n *      D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n *  \n *  आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े हैं।\n */\nconst char* answer_questions()",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n *  \n *  1. kérdés:\n *  Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  2. kérdés:\n *  Adott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Egyik sem a fentiek közül\n *  \n *  3. kérdés:\n *  Melyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n *      A. A változónév kifejezések balértékek.\n *      B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n *      C. A mutatódereferálás kifejezések balértékek.\n *      D. A prefix inkrementáló művelet kifejezések balértékek.\n *  \n *  4. kérdés:\n *  Melyik állítás helytelen a függvényekkel kapcsolatban?\n *      A. A függvény formális paraméterei lokális változók.\n *      B. A lokális változók a veremben kapnak helyet.\n *      C. A függvény típusa megegyezik a visszatérési érték típusával.\n *      D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n *  \n *  5. kérdés:\n *  Melyik állítás helytelen a mutatókkal kapcsolatban?\n *      A. Két mutató kivonása az címértékeik különbségével egyenlő.\n *      B. A mutatódereferálás a mutató típusának megfelelő feloldást igényel.\n *      C. int *p[4], p egy int mutatók tömbje.\n *      D. A függvénynevek hozzárendelhetők függvénymutatókhoz.\n *  \n *  Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik.\n */\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "sq": "0.882865280739154",
      "hy": "0.9406361325416271",
      "bn": "0.9445425962454402",
      "bg": "0.9536474156513175",
      "zh": "0.9467970510701862",
      "fr": "0.958455264024267",
      "de": "0.8764538893001099",
      "ha": "0.8424142036413991",
      "hi": "0.873072802954134",
      "hu": "0.9365240863934429"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "Write a CPP function `const char* answer_questions()` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Shkruani një funksion CPP `const char* answer_questions()` për të zgjidhur problemin e mëposhtëm:\nPërgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund t'u caktohen treguesve të funksioneve.\n\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Գրեք C++ ֆունկցիա `const char* answer_questions()`՝ հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրություններից մեկը:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nԵնթադրելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\n\nՀարց 3:\nՈ՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապասահմանման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապասահմանումը ներառում է լուծում ըստ ցուցիչի տիպի:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրությունները:",
      "bn": "একটি CPP ফাংশন `const char* answer_questions()` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি প্রশ্নের জন্য পছন্দ A, B, C, বা D প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\n\nপ্রশ্ন ১:\n১e৬ এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\n২১! = ৫১,০৯০,৯৪২,১৭১,৭০৯,৪৪০,০০০ দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করা তাদের ঠিকানা মানের পার্থক্যের সমান।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।",
      "bg": "Напишете CPP функция `const char* answer_questions()` за решаване на следния проблем:\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика сама себе си в тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпроса.",
      "zh": "编写一个 CPP 函数 `const char* answer_questions()` 来解决以下问题：  \n通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n\n问题 1：  \n像 1e6 这样的常量属于哪种数据类型？  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \n\n问题 2：  \n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？  \n    A. int  \n    B. long long  \n    C. double  \n    D. 以上都不是  \n\n问题 3：  \n关于表达式中的左值，哪项说法不正确？  \n    A. 变量名表达式是左值。  \n    B. 自增操作要求操作数是左值。  \n    C. 指针解引用表达式是左值。  \n    D. 前缀自增操作表达式是左值。  \n\n问题 4：  \n关于函数，哪项说法不正确？  \n    A. 函数的形式参数是局部变量。  \n    B. 局部变量在栈中分配空间。  \n    C. 函数类型与返回值类型相同。  \n    D. 函数可以在其主体内调用自身。  \n\n问题 5：  \n关于指针，哪项说法不正确？  \n    A. 两个指针相减等于它们地址值的差。  \n    B. 指针解引用涉及根据指针类型进行解析。  \n    C. int *p[4]，p 是一个 int 指针的数组。  \n    D. 函数名可以赋值给函数指针。  \n\n你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。",
      "fr": "Écrire une fonction CPP `const char* answer_questions()` pour résoudre le problème suivant :\nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Schreiben Sie eine CPP-Funktion `const char* answer_questions()`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Optionen A, B, C oder D angeben.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Bei der Inkrementoperation muss der Operand ein linker Wert sein.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Ausdrucksoperationen sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren zweier Zeiger ergibt die Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahl der Frage stehen.",
      "ha": "Rubuta aikin CPP `const char* answer_questions()` don warware matsalar mai zuwa: \n\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 yana cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n    A. Maganganun sunayen canji ƙimar hagu ne.\n    B. Aikin ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Maganganun cirewa na alamar suna ƙimar hagu ne.\n    D. Maganganun aikin ƙaruwa na farkon suna ƙimar hagu ne.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin hukuma na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin faifai.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da alamar ba daidai ba ne?\n    A. Cirewa alamar biyu yana daidai da bambanci a cikin ƙimar adireshin su.\n    B. Cire alamar yana buƙatar warwarewa bisa nau'in alamar.\n    C. int *p[4], p tsari ne na alamomin int.\n    D. Ana iya sanya sunayen ayyuka ga alamomin ayyuka.\n\nDole ne ka dawo da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "एक CPP फ़ंक्शन `const char* answer_questions()` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nफंक्शनों के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नाम को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Írj egy CPP függvényt `const char* answer_questions()` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nTekintettel arra, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a bal értékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések bal értékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus bal érték legyen.\n    C. A pointer dereferálási kifejezések bal értékek.\n    D. A prefix inkrementáló műveleti kifejezések bal értékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók számára a veremben van hely lefoglalva.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálása a pointer típusának alapján történő feloldást jelenti.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvény pointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "instruction_bertscore": {
      "sq": "0.949027670249208",
      "hy": "0.922451123897121",
      "bn": "0.935414735715363",
      "bg": "0.9423554771198651",
      "zh": "0.9474394217224531",
      "fr": "0.9582151198935958",
      "de": "0.9396648299783665",
      "ha": "0.9360940516185023",
      "hi": "0.9489186221700199",
      "hu": "0.9386933287847249"
    },
    "level": "easy",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale alokohen hapësirë në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունն է սխալ ձախ արժեքների վերաբերյալ արտահայտություններում?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահանում արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր հայտարարությունն է սխալ ֆունկցիաների վերաբերյալ?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են տարածքում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր հայտարարությունն է սխալ ցուցիչների վերաբերյալ?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "প্রশ্নগুলির প্রতিটি প্রশ্নের জন্য পছন্দগুলি A, B, C, বা D প্রদান করে একটি সিরিজ প্রশ্নের উত্তর দিন।\n\nপ্রশ্ন ১:\n1e6 এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশন টাইপটি রিটার্ন মানের টাইপের সমান।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মত স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика сама себе си в тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.",
      "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1：\n像1e6这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题2：\n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题3：\n关于表达式中的左值，哪个说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题4：\n关于函数，哪个说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题5：\n关于指针，哪个说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4]，p是一个int指针的数组。\n    D. 函数名可以赋值给函数指针。\n\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operationen-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nDu sollst nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nConstant kamar 1e6 na cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWace magana game da ƙimar hagu a cikin magana ba daidai ba ce?\n    A. Maganganun sunayen canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar operand ya zama ƙimar hagu.\n    C. Maganganun cirewa na pointer ƙimar hagu ne.\n    D. Maganganun aiki na ƙaruwa na prefix ƙimar hagu ne.\n\nTambaya ta 4:\nWace magana game da ayyuka ba daidai ba ce?\n    A. Sigogi na zahiri na aiki canje-canje na gida ne.\n    B. Canje-canje na gida suna samun sarari a cikin stack.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWace magana game da pointers ba daidai ba ce?\n    A. Rage pointers biyu yana daidai da bambancin a cikin ƙimar adireshinsu.\n    B. Cirewa pointer yana buƙatar warwarewa bisa nau'in pointer.\n    C. int *p[4], p tsari ne na pointers int.\n    D. Ana iya sanya sunayen ayyuka ga pointers ayyuka.\n\nDole ne ka dawo da kirtani kamar \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डीरिफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4:\nफंक्शनों के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मूल्यों में अंतर होता है।\n    B. पॉइंटर डीरिफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszoljon egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n\n3. kérdés:\nMelyik állítás helytelen a balértékekről kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementálás művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementálás művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekről?\n    A. Egy függvény formális paraméterei lokális változók.\n    B. A lokális változók helyet kapnak a veremben.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekről?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusának megfelelően történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnia, mint például \"AAAAA\", amelyek a kérdés választási lehetőségeit jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9584240790544445",
      "hy": "0.9377798276623455",
      "bn": "0.9455357481506147",
      "bg": "0.9342150082139122",
      "zh": "0.934908426874105",
      "fr": "0.9520671123398039",
      "de": "0.9456632688552391",
      "ha": "0.9433696838454292",
      "hi": "0.9467601058193137",
      "hu": "0.9368248127903297"
    }
  },
  {
    "task_id": "CPP/21",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool Is_Square(std::vector<int> squares)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Përcakton nëse është e mundur të montohet sheshi prej druri nga n kovë\n * në një shesh më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n * \n * Hyrja: vektor numrash\n * Shembull:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n * @return True nëse është e mundur të formohet një shesh më i madh, False përndryshe.\n */\nbool Is_Square(std::vector<int> squares)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Որոշում է՝ արդյոք հնարավոր է n դույլերից փայտե քառակուսիներ հավաքել մեկ մեծ քառակուսի մեջ,\n * որտեղ յուրաքանչյուր դույլ պարունակում է կողքի երկարությամբ 1 քառակուսիներ:\n * \n * Մուտք: թվերի վեկտոր\n * Օրինակ:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը:\n * @return true եթե հնարավոր է ձևավորել մեծ քառակուսի, false հակառակ դեպքում:\n */\nbool Is_Square(std::vector<int> squares)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একটি বড় বর্গক্ষেত্রে সংযুক্ত করা সম্ভব কিনা,\n * যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র থাকে।\n * \n * ইনপুট: সংখ্যার ভেক্টর\n * উদাহরণ:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares প্রতিটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n * @return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।\n */\nbool Is_Square(std::vector<int> squares)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Определя дали е възможно да се сглобят дървените квадрати от n кофи\n * в един по-голям квадрат, където всяка кофа съдържа квадрати със страна с дължина 1.\n * \n * Вход: вектор от числа\n * Пример:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n * @return Връща True, ако е възможно да се образува по-голям квадрат, False в противен случай.\n */\nbool Is_Square(std::vector<int> squares)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * 确定是否可以将 n 个桶中的木方块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n * \n * 输入: 数字向量\n * 例子:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares 包含每个桶中正方形数量的向量。\n * @return 如果可以形成更大的正方形则返回 True，否则返回 False。\n */\nbool Is_Square(std::vector<int> squares)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Détermine s'il est possible d'assembler les carrés en bois provenant de n seaux\n * en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n * \n * Entrée : vecteur de nombres\n * Exemple :\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vecteur contenant le nombre de carrés dans chaque seau.\n * @return True s'il est possible de former un carré plus grand, False sinon.\n */\nbool Is_Square(std::vector<int> squares)",
      "de": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern\n * zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n * \n * Eingabe: Vektor von Zahlen\n * Beispiel:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n * @return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.\n */\nbool Is_Square(std::vector<int> squares)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Yana tantancewa idan yana yiwuwa a tara murabba'ai na katako daga guga n\n * cikin murabba'i guda mafi girma, inda kowanne guga yana dauke da murabba'ai tare da tsawon gefe na 1.\n * \n * Shigarwa: vector na lambobi\n * Misali:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector wanda ke dauke da adadin murabba'ai a kowanne guga.\n * @return True idan yana yiwuwa a samar da murabba'i mafi girma, False idan ba haka ba.\n */\nbool Is_Square(std::vector<int> squares)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है,\n * जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n * \n * इनपुट: संख्याओं का वेक्टर\n * उदाहरण:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares प्रत्येक बाल्टी में वर्गों की संख्या वाला वेक्टर।\n * @return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।\n */\nbool Is_Square(std::vector<int> squares)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből egyetlen nagyobb négyzetté összeállítani,\n * ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n * \n * Bemenet: számok vektora\n * Példa:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vektor, amely tartalmazza az egyes vödrökben lévő négyzetek számát.\n * @return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, hamis különben.\n */\nbool Is_Square(std::vector<int> squares)"
    },
    "prompt_bertscore": {
      "sq": "0.9875699093852177",
      "hy": "0.9752732983864909",
      "bn": "0.9712113070943275",
      "bg": "0.9821417383322963",
      "zh": "0.9373994504826636",
      "fr": "0.992433374264857",
      "de": "0.9934032864154503",
      "ha": "0.9747024346713966",
      "hi": "0.9703220388784343",
      "hu": "0.9826724787104215"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}",
    "instruction": {
      "en": "Write a CPP function `bool Is_Square(std::vector<int> squares)` to solve the following problem:\nDetermines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n",
      "sq": "Shkruani një funksion CPP `bool Is_Square(std::vector<int> squares)` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse është e mundur të montohen katrorët prej druri nga n kovë\nnë një katror më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n\nHyrja: vektor numrash\nShembull:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n@return True nëse është e mundur të formohet një katror më i madh, False përndryshe.",
      "hy": "Գրեք CPP ֆունկցիա `bool Is_Square(std::vector<int> squares)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից\nմի մեծ քառակուսի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է 1 կողմի երկարությամբ քառակուսիներ:\n\nՄուտք: թվերի վեկտոր\nՕրինակ:\n   >>> Is_Square({9})\n   true\n\n@param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը:\n@return True, եթե հնարավոր է ձևավորել ավելի մեծ քառակուսի, False՝ հակառակ դեպքում.",
      "bn": "একটি CPP ফাংশন `bool Is_Square(std::vector<int> squares)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে যে এটি সম্ভব কিনা কাঠের বর্গক্ষেত্রগুলি n বালতি থেকে একটি বড় বর্গক্ষেত্রে একত্রিত করা,\nযেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n\nইনপুট: সংখ্যার ভেক্টর\nউদাহরণ:\n   >>> Is_Square({9})\n   true\n\n@param squares প্রতিটি বালতিতে বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n@return True যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয়, False অন্যথায়।",
      "bg": "Напишете CPP функция `bool Is_Square(std::vector<int> squares)`, за да решите следния проблем:\nОпределя дали е възможно да се сглобят дървените квадрати от n кофи в един по-голям квадрат, където всяка кофа съдържа квадрати със страна с дължина 1.\n\nВход: вектор от числа\nПример:\n   >>> Is_Square({9})\n   true\n\n@param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n@return True, ако е възможно да се образува по-голям квадрат, False в противен случай.",
      "zh": "编写一个 CPP 函数 `bool Is_Square(std::vector<int> squares)` 来解决以下问题：\n确定是否可以将 n 个桶中的木块正方形组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n\n输入：数字向量\n示例：\n   >>> Is_Square({9})\n   true\n\n@param squares 向量，包含每个桶中的正方形数量。\n@return 如果可以形成一个更大的正方形，则返回 True，否则返回 False。",
      "fr": "Écrire une fonction CPP `bool Is_Square(std::vector<int> squares)` pour résoudre le problème suivant :\nDétermine s'il est possible d'assembler les carrés en bois de n seaux en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n\nEntrée : vecteur de nombres\nExemple :\n   >>> Is_Square({9})\n   true\n\n@param squares Vecteur contenant le nombre de carrés dans chaque seau.\n@return True s'il est possible de former un carré plus grand, False sinon.",
      "de": "Schreiben Sie eine CPP-Funktion `bool Is_Square(std::vector<int> squares)`, um das folgende Problem zu lösen:\nBestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n\nEingabe: Vektor von Zahlen\nBeispiel:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n@return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.",
      "ha": "Rubuta aikin CPP `bool Is_Square(std::vector<int> squares)` don warware matsalar mai zuwa: \n\nYana tantancewa idan zai yiwu a tara katako murabba'i daga kwandunan n cikin murabba'i mafi girma guda ɗaya, inda kowanne kwando ke ɗauke da murabba'i masu tsawon gefe 1.\n\nShigarwa: vector na lambobi\nMisali:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector mai ɗauke da adadin murabba'i a kowanne kwando.\n@return True idan zai yiwu a samar da murabba'i mafi girma, False in ba haka ba.",
      "hi": "एक CPP फ़ंक्शन `bool Is_Square(std::vector<int> squares)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में 1 की साइड लंबाई वाले वर्ग होते हैं।\n\nइनपुट: संख्याओं का वेक्टर\nउदाहरण:\n   >>> Is_Square({9})\n   true\n\n@param squares प्रत्येक बाल्टी में वर्गों की गिनती वाला वेक्टर।\n@return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।",
      "hu": "Írj egy CPP függvényt `bool Is_Square(std::vector<int> squares)` a következő probléma megoldására:\nMegállapítja, hogy lehetséges-e a fa négyzeteket n vödörből egyetlen nagyobb négyzetté összeállítani, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n\nBemenet: számokat tartalmazó vektor\nPélda:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor, amely minden vödörben található négyzetek számát tartalmazza.\n@return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, különben hamis."
    },
    "instruction_bertscore": {
      "sq": "0.9828585953774512",
      "hy": "0.983381390540335",
      "bn": "0.9610007123572291",
      "bg": "0.9724664524720869",
      "zh": "0.9462138722714678",
      "fr": "0.987571697058647",
      "de": "0.9924478742826726",
      "ha": "0.953257504213346",
      "hi": "0.9694480652018808",
      "hu": "0.9789229330076259"
    },
    "level": "easy",
    "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "bool Is_Square(std::vector<int> squares)",
    "docstring": {
      "en": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n",
      "sq": "Përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë\nnë një katror më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n\nHyrja: vektor numrash\nShembull:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n@return True nëse është e mundur të formohet një katror më i madh, False përndryshe.",
      "hy": "Որոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից մեկ մեծ քառակուսիի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է կողմի երկարությամբ 1 քառակուսիներ:\n\nՄուտք: թվերի վեկտոր\nՕրինակ:\n   >>> Is_Square({9})\n   true\n\n@param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլի քառակուսիների քանակը:\n@return Ճիշտ է, եթե հնարավոր է ձևավորել մեծ քառակուսի, Հակառակ դեպքում՝ սխալ:",
      "bn": "বর্ণনা করে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা, যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n\nইনপুট: সংখ্যার ভেক্টর\nউদাহরণ:\n   >>> Is_Square({9})\n   true\n\n@param squares প্রতিটি বালতিতে বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n@return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।",
      "bg": "Определя дали е възможно да се сглобят дървените квадрати от n кофи в един по-голям квадрат, където всяка кофа съдържа квадрати със страна с дължина 1.\n\nВход: вектор от числа\nПример:\n   >>> Is_Square({9})\n   true\n\n@param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n@return True ако е възможно да се формира по-голям квадрат, False в противен случай.",
      "zh": "确定是否可以将 n 个桶中的木方块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n\n输入：数字向量\n示例：\n   >>> Is_Square({9})\n   true\n\n@param squares 向量，包含每个桶中正方形的数量。\n@return 如果可以形成一个更大的正方形，则返回 True，否则返回 False。",
      "fr": "Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n\nEntrée : vecteur de nombres\nExemple :\n   >>> Is_Square({9})\n   true\n\n@param squares Vecteur contenant le nombre de carrés dans chaque seau.\n@return True s'il est possible de former un carré plus grand, False sinon.",
      "de": "Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n\nEingabe: Vektor von Zahlen\nBeispiel:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n@return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.",
      "ha": "Yana tantance ko zai yiwu a tara murabba'ai na katako daga guga n zuwa murabba'i mafi girma guda ɗaya, inda kowanne guga yana dauke da murabba'ai masu tsawon gefe 1.\n\nShigarwa: vector na lambobi\nMisali:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector mai dauke da adadin murabba'ai a kowanne guga.\n@return True idan zai yiwu a samar da murabba'i mafi girma, False in ba haka ba.",
      "hi": "यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n\nइनपुट: संख्याओं का वेक्टर\nउदाहरण:\n   >>> Is_Square({9})\n   true\n\n@param squares प्रत्येक बाल्टी में वर्गों की गिनती वाला वेक्टर।\n@return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।",
      "hu": "Meghatározza, hogy lehetséges-e az n vödörből származó fa négyzeteket egyetlen nagyobb négyzetté összeszerelni, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n\nBemenet: számok vektora\nPélda:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor, amely tartalmazza az egyes vödrökben lévő négyzetek számát.\n@return True, ha lehetséges egy nagyobb négyzetet kialakítani, különben False."
    },
    "docstring_bertscore": {
      "sq": "0.9834628289965593",
      "hy": "0.9583843529782374",
      "bn": "0.91418432606883",
      "bg": "0.9716127390943989",
      "zh": "0.9063110150253691",
      "fr": "0.9834374043077869",
      "de": "0.9873160597582551",
      "ha": "0.9534505729437119",
      "hi": "0.946806585328476",
      "hu": "0.971880492848034"
    }
  },
  {
    "task_id": "CPP/22",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Given integers c and d, where a + b = c and a * b = d, this function\n * finds the possible value of a with the condition a <= b. When multiple \n * pairs (a, b) are possible, it returns the pair with the smallest a.\n * If no valid pair exists, it returns -1.\n *\n * Parameters:\n *  - c (int): The sum of a and b.\n *  - d (int): The product of a and b.\n *\n * Returns:\n *  - int: A possible value of a or -1 if no valid values exist.\n *\n * Examples:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\n * gjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme disa \n * çifte (a, b), kthen çiftin me a më të vogël.\n * Nëse nuk ekziston asnjë çift i vlefshëm, kthen -1.\n *\n * Parametrat:\n *  - c (int): Shuma e a dhe b.\n *  - d (int): Produkti i a dhe b.\n *\n * Kthen:\n *  - int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n *\n * Shembuj:\n *  find_integers(7, 11) kthen -1\n *  find_integers(5, 6) kthen 2\n */\nint find_integers(int c, int d)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\n * գտնում է a-ի հնարավոր արժեքը պայմանով a <= b: Երբ հնարավոր են բազմաթիվ \n * զույգեր (a, b), այն վերադարձնում է ամենափոքր a ունեցող զույգը:\n * Եթե վավեր զույգ չի գոյություն ունենում, այն վերադարձնում է -1:\n *\n * Պարամետրեր:\n *  - c (int): a և b-ի գումարը:\n *  - d (int): a և b-ի արտադրյալը:\n *\n * Վերադարձնում է:\n *  - int: a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չեն գոյություն ունենում:\n *\n * Օրինակներ:\n *  find_integers(7, 11) վերադարձնում է -1\n *  find_integers(5, 6) վերադարձնում է 2\n */\nint find_integers(int c, int d)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি\n * a এর সম্ভাব্য মান খুঁজে বের করে শর্ত a <= b এর সাথে। যখন একাধিক \n * জোড়া (a, b) সম্ভব, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়।\n * যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n *\n * প্যারামিটার:\n *  - c (int): a এবং b এর যোগফল।\n *  - d (int): a এবং b এর গুণফল।\n *\n * ফেরত দেয়:\n *  - int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n *\n * উদাহরণ:\n *  find_integers(7, 11) -1 ফেরত দেয়\n *  find_integers(5, 6) 2 ফেরত দেয়\n */\nint find_integers(int c, int d)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\n * намира възможната стойност на a при условие, че a <= b. Когато са възможни \n * множество двойки (a, b), тя връща двойката с най-малко a.\n * Ако не съществува валидна двойка, връща -1.\n *\n * Параметри:\n *  - c (int): Сумата на a и b.\n *  - d (int): Произведението на a и b.\n *\n * Връща:\n *  - int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n *\n * Примери:\n *  find_integers(7, 11) връща -1\n *  find_integers(5, 6) връща 2\n */\nint find_integers(int c, int d)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数\n * 找出满足条件 a <= b 的 a 的可能值。当存在多个\n * (a, b) 对时，返回具有最小 a 的对。\n * 如果不存在有效对，则返回 -1。\n *\n * 参数:\n *  - c (int): a 和 b 的和。\n *  - d (int): a 和 b 的积。\n *\n * 返回:\n *  - int: a 的可能值或如果不存在有效值则返回 -1。\n *\n * 示例:\n *  find_integers(7, 11) 返回 -1\n *  find_integers(5, 6) 返回 2\n */\nint find_integers(int c, int d)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Étant donnés les entiers c et d, où a + b = c et a * b = d, cette fonction\n * trouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe \n * plusieurs paires (a, b) possibles, elle retourne la paire avec le plus petit a.\n * Si aucune paire valide n'existe, elle retourne -1.\n *\n * Paramètres:\n *  - c (int): La somme de a et b.\n *  - d (int): Le produit de a et b.\n *\n * Renvoie:\n *  - int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n *\n * Exemples:\n *  find_integers(7, 11) retourne -1\n *  find_integers(5, 6) retourne 2\n */\nint find_integers(int c, int d)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d, \n * diese Funktion findet den möglichen Wert von a mit der Bedingung a <= b. \n * Wenn mehrere Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück.\n * Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n *\n * Parameter:\n *  - c (int): Die Summe von a und b.\n *  - d (int): Das Produkt von a und b.\n *\n * Rückgabewerte:\n *  - int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n *\n * Beispiele:\n *  find_integers(7, 11) gibt -1 zurück\n *  find_integers(5, 6) gibt 2 zurück\n */\nint find_integers(int c, int d)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin\n * yana nemo yiwuwar darajar a tare da yanayin a <= b. Idan akwai ma'aurata \n * (a, b) da dama, yana dawo da ma'auratan da ke da ƙaramar a.\n * Idan babu ma'aurata masu inganci, yana dawo da -1.\n *\n * Sigogi:\n *  - c (int): Jimillar a da b.\n *  - d (int): Samfurin a da b.\n *\n * Yana dawowa:\n *  - int: Yiwuwar darajar a ko -1 idan babu ƙimar da ta dace.\n *\n * Misalai:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, यह फ़ंक्शन\n * a के संभावित मान को ढूंढता है इस शर्त के साथ कि a <= b। जब कई \n * जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है।\n * यदि कोई मान्य जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n *\n * पैरामीटर्स:\n *  - c (int): a और b का योग।\n *  - d (int): a और b का गुणनफल।\n *\n * रिटर्न्स:\n *  - int: a का एक संभावित मान या -1 यदि कोई मान्य मान मौजूद नहीं है।\n *\n * उदाहरण:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, ez a függvény\n * megtalálja a lehetséges a értéket azzal a feltétellel, hogy a <= b. Ha több\n * (a, b) pár lehetséges, akkor a legkisebb a értékkel rendelkező párt adja vissza.\n * Ha nem létezik érvényes pár, akkor -1-et ad vissza.\n *\n * Paraméterek:\n *  - c (int): Az a és b összege.\n *  - d (int): Az a és b szorzata.\n *\n * Visszatérési érték:\n *  - int: Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n *\n * Példák:\n *  find_integers(7, 11) visszaadja -1\n *  find_integers(5, 6) visszaadja 2\n */\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9954829465048856",
      "hy": "0.9739937214718641",
      "bn": "0.99793285362457",
      "bg": "0.9922214356482928",
      "zh": "0.9788746658250345",
      "fr": "0.993389978179921",
      "de": "0.987912944053265",
      "ha": "0.9866001958650054",
      "hi": "0.9858968456857609",
      "hu": "0.9753227573513686"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a CPP function `int find_integers(int c, int d)` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2\n",
      "sq": "Shkruani një funksion CPP `int find_integers(int c, int d)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, ky funksion\ngjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme disa\nçifte (a, b), ai kthen çiftin me vlerën më të vogël të a.\nNëse nuk ekziston asnjë çift i vlefshëm, ai kthen -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n\nShembuj:\nfind_integers(7, 11) kthen -1\nfind_integers(5, 6) kthen 2",
      "hy": "Գրեք CPP ֆունկցիա `int find_integers(int c, int d)` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\nգտնում է a-ի հնարավոր արժեքը պայմանով a <= b: Երբ հնարավոր են բազմաթիվ\nզույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով:\nԵթե ոչ մի վավեր զույգ չկա, այն վերադարձնում է -1:\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը:\n- d (int): a և b-ի արտադրյալը:\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան:\n\nՕրինակներ:\nfind_integers(7, 11) վերադարձնում է -1\nfind_integers(5, 6) վերադարձնում է 2",
      "bn": "একটি CPP ফাংশন `int find_integers(int c, int d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সহ a <= b। যখন একাধিক জোড়া (a, b) সম্ভব, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়। যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n- int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n\nউদাহরণসমূহ:\nfind_integers(7, 11) -1 ফেরত দেয়\nfind_integers(5, 6) 2 ফেরত দেয়",
      "bg": "Напишете CPP функция `int find_integers(int c, int d)` за решаване на следния проблем:  \nДадени са цели числа c и d, където a + b = c и a * b = d, тази функция намира възможната стойност на a с условието a <= b. Когато са възможни няколко двойки (a, b), тя връща двойката с най-малката a. Ако не съществува валидна двойка, тя връща -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\nfind_integers(7, 11) връща -1  \nfind_integers(5, 6) връща 2",
      "zh": "编写一个 CPP 函数 `int find_integers(int c, int d)` 来解决以下问题：  \n给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数找到满足条件 a <= b 的 a 的可能值。当存在多个 (a, b) 对时，返回具有最小 a 的对。如果不存在有效对，则返回 -1。\n\n参数：\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回：\n- int: a 的可能值，如果不存在有效值则返回 -1。\n\n示例：\nfind_integers(7, 11) 返回 -1  \nfind_integers(5, 6) 返回 2  ",
      "fr": "Écrire une fonction CPP `int find_integers(int c, int d)` pour résoudre le problème suivant :  \nÉtant donnés les entiers c et d, où a + b = c et a * b = d, cette fonction trouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe plusieurs paires (a, b) possibles, elle retourne la paire avec le plus petit a. Si aucune paire valide n'existe, elle retourne -1.\n\nParamètres :\n- c (int) : La somme de a et b.\n- d (int) : Le produit de a et b.\n\nRenvoie :\n- int : Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n\nExemples :\nfind_integers(7, 11) retourne -1  \nfind_integers(5, 6) retourne 2  ",
      "de": "Schreiben Sie eine CPP-Funktion `int find_integers(int c, int d)`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, diese Funktion\nfindet den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere\nPaare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück.\nWenn kein gültiges Paar existiert, gibt sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\nfind_integers(7, 11) gibt -1 zurück\nfind_integers(5, 6) gibt 2 zurück",
      "ha": "Rubuta aikin CPP `int find_integers(int c, int d)` don warware matsalar mai zuwa:\nAn ba da lambobi c da d, inda a + b = c da a * b = d, wannan aikin\nyana nemo yiwuwar darajar a tare da yanayin a <= b. Idan akwai\nma'aurata da dama (a, b) masu yiwuwa, yana dawo da ma'aurata tare da ƙaramar a.\nIdan babu wata ma'aurata mai inganci, yana dawo da -1.\n\nSigogi:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nDawowa:\n- int: Yiwuwar darajar a ko -1 idan babu wasu ƙimar da suka dace.\n\nMisalai:\nfind_integers(7, 11) yana dawowa -1\nfind_integers(5, 6) yana dawowa 2",
      "hi": "`int find_integers(int c, int d)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, यह फ़ंक्शन a के संभावित मान को उस शर्त के साथ खोजता है कि a <= b। जब कई जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है। यदि कोई मान्य जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान या -1 यदि कोई मान्य मान मौजूद नहीं है।\n\nउदाहरण:\nfind_integers(7, 11) -1 लौटाता है\nfind_integers(5, 6) 2 लौटाता है",
      "hu": "Írj egy CPP függvényt `int find_integers(int c, int d)` a következő probléma megoldására:\nAdottak az egész számok c és d, ahol a + b = c és a * b = d, ez a függvény\nmegtalálja a lehetséges a értéket azzal a feltétellel, hogy a <= b. Ha több\n(a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\nHa nem létezik érvényes pár, akkor -1-et ad vissza.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\n- int: a lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\nfind_integers(7, 11) visszaadja -1\nfind_integers(5, 6) visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9932660328221552",
      "hy": "0.9958672962921881",
      "bn": "0.9989488480235633",
      "bg": "0.9969031537292851",
      "zh": "0.9769320606985132",
      "fr": "0.993646211371456",
      "de": "0.9901193303258006",
      "ha": "0.9800654549593386",
      "hi": "0.9894481582682836",
      "hu": "0.9743721123477356"
    },
    "level": "easy",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\ngjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme shumë\nçifte (a, b), ajo kthen çiftin me a më të vogël.\nNëse nuk ekziston asnjë çift i vlefshëm, ajo kthen -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n\nShembuj:\nfind_integers(7, 11) kthen -1\nfind_integers(5, 6) kthen 2",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\nգտնում է a-ի հնարավոր արժեքը պայմանով a <= b։ Երբ հնարավոր են մի քանի\nզույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով։\nԵթե վավեր զույգ գոյություն չունի, այն վերադարձնում է -1։\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը։\n- d (int): a և b-ի արտադրյալը։\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան։\n\nՕրինակներ:\nfind_integers(7, 11) վերադարձնում է -1\nfind_integers(5, 6) վերադարձնում է 2",
      "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সহ a <= b। যখন একাধিক জোড়া (a, b) সম্ভব হয়, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়। যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত:\n- int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n\nউদাহরণ:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\nнамира възможната стойност на a с условието a <= b. Когато са възможни множество\nдвойки (a, b), тя връща двойката с най-малко a.\nАко не съществува валидна двойка, тя връща -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\nfind_integers(7, 11) връща -1\nfind_integers(5, 6) връща 2",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数在 a <= b 的条件下找到 a 的可能值。当存在多个 (a, b) 对时，返回具有最小 a 的对。如果不存在有效对，则返回 -1。\n\n参数:\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回:\n- int: a 的可能值，如果不存在有效值则返回 -1。\n\n示例:\nfind_integers(7, 11) 返回 -1\nfind_integers(5, 6) 返回 2",
      "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, cette fonction\ntrouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe plusieurs\npaires (a, b) possibles, elle renvoie la paire avec le plus petit a.\nSi aucune paire valide n'existe, elle renvoie -1.\n\nParamètres:\n- c (int): La somme de a et b.\n- d (int): Le produit de a et b.\n\nRenvoie:\n- int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n\nExemples:\nfind_integers(7, 11) renvoie -1\nfind_integers(5, 6) renvoie 2",
      "de": "Gegeben ganze Zahlen c und d, wobei a + b = c und a * b = d, findet diese Funktion den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück. Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\nfind_integers(7, 11) gibt -1 zurück\nfind_integers(5, 6) gibt 2 zurück",
      "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin yana nemo yiwuwar ƙimar a tare da yanayin a <= b. Lokacin da dama-dama (a, b) suna yiwuwa, yana dawo da ma'aurata tare da ƙaramin a. Idan babu ma'aurata masu inganci, yana dawo da -1.\n\nParameters:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nReturns:\n- int: Yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n\nExamples:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2",
      "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, यह फ़ंक्शन a के संभावित मान को ढूंढता है जिसमें शर्त a <= b होती है। जब कई जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है। यदि कोई वैध जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान या -1 यदि कोई वैध मान मौजूद नहीं है।\n\nउदाहरण:\nfind_integers(7, 11) -1 लौटाता है\nfind_integers(5, 6) 2 लौटाता है",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, ez a függvény\nmegtalálja a lehetséges a értékét azzal a feltétellel, hogy a <= b. Ha több\n(a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\nHa nem létezik érvényes pár, akkor -1-et ad vissza.\n\nParaméterek:\n- c (int): Az a és b összege.\n- d (int): Az a és b szorzata.\n\nVisszatérési érték:\n- int: Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\nfind_integers(7, 11) visszaadja -1\nfind_integers(5, 6) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9928431487409319",
      "hy": "0.9946983564997978",
      "bn": "0.997534401080214",
      "bg": "0.9965958725298241",
      "zh": "0.974436865851953",
      "fr": "0.9926375662965609",
      "de": "0.9944190821840627",
      "ha": "0.9794769131403323",
      "hi": "0.9925563264707176",
      "hu": "0.9809110244914041"
    }
  },
  {
    "task_id": "CPP/23",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nNumëron numrin e trekëndëshave kënddrejtë që mund të formohen duke zgjedhur çdo 3 brinjë nga\nnjë grup i dhënë brinjësh.\n  \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n  \nKthen:\nint: Numri i trekëndëshave të veçantë kënddrejtë që mund të formohen.\n  \nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nՀաշվել սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից\nտրված կողերի բազմությունից:\n  \nԱրգումենտներ:\n- edges_count: Անցկացվող կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n  \nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել:\n  \nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোন 3 প্রান্ত নির্বাচন করে গঠিত তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা গণনা করুন।\n  \nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী একটি স্বেচ্ছামূলক সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n  \nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n  \nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на\nвсякакви 3 ръба от даден набор от ръбове.\n  \nАргументи:\n- edges_count: Броят на подадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n  \nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n  \nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n  \n参数:\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n  \n返回:\nint: 可以形成的不同锐角三角形的数量。\n  \n示例:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCompte le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi\nun ensemble donné d'arêtes.\n  \nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n  \nReturns:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n  \nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n  \nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n  \nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane gefuna 3 daga\nwani saiti na gefuna da aka bayar.\n  \nArgs:\n- edges_count: Adadin gefuna da aka wuce.\n- Yawan hujjojin lamba masu zaman kansu suna wakiltar tsayin gefuna.\n  \nReturns:\nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n  \nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nकिसी दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले कई पूर्णांक तर्क।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्र कोण त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nSzámolja meg a hegyesszögű háromszögek számát, amelyek kialakíthatók a megadott élek közül bármely 3 él kiválasztásával.\n\nArgs:\n- edges_count: A megadott élek száma.\n- Tetszőleges számú egész számú argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az egyedi hegyesszögű háromszögek száma, amelyek kialakíthatók.\n\nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9568982004673344",
      "hy": "0.9412469209633094",
      "bn": "0.9768690948677252",
      "bg": "0.9717337049964492",
      "zh": "0.94121057160358",
      "fr": "0.9623257756291128",
      "de": "0.9573784887286768",
      "ha": "0.9512312756964091",
      "hi": "0.979475324097284",
      "hu": "0.9674385216369508"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "en": "Write a CPP function `int count_acute_triangles(int edges_count, ...)` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "sq": "Shkruani një funksion CPP `int count_acute_triangles(int edges_count, ...)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënde të mprehta që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar i argumenteve të plotë që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënde të mprehta që mund të formohen.\n\nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hy": "Գրեք CPP ֆունկցիա `int count_acute_triangles(int edges_count, ...)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել տրված կողերի հավաքածուից ցանկացած 3 կող ընտրելով:\n\nԱրգումենտներ:\n- edges_count: Փոխանցված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bn": "একটি CPP ফাংশন `int count_acute_triangles(int edges_count, ...)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges_count: পাস করা প্রান্তগুলির সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী অসীম সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bg": "Напишете CPP функция `int count_acute_triangles(int edges_count, ...)`, за да решите следния проблем:  \nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на подадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "zh": "编写一个 CPP 函数 `int count_acute_triangles(int edges_count, ...)` 来解决以下问题：  \n计算可以通过从给定的一组边中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。 \n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "fr": "Écrire une fonction CPP `int count_acute_triangles(int edges_count, ...)` pour résoudre le problème suivant :  \nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArgs:\n- edges_count: Le nombre de côtés passés.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des côtés.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "de": "Schreiben Sie eine CPP-Funktion `int count_acute_triangles(int edges_count, ...)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie beliebige 3 Kanten aus einer gegebenen Menge von Kanten auswählen.\n\nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "ha": "Rubuta aikin CPP `int count_acute_triangles(int edges_count, ...)` don warware matsalar mai zuwa:\nƘididdige adadin kusurwoyin triangles masu kaifi da za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin saiti na gefuna da aka bayar.\n\nArgs:\n- edges_count: Yawan gefuna da aka bayar.\n- Yawan hujjojin lamba masu zaman kansu da ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin triangles masu kaifi da za a iya samarwa.\n\nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hi": "एक CPP फ़ंक्शन `int count_acute_triangles(int edges_count, ...)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों को चुनकर बनने वाले तीव्र कोणीय त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nरिटर्न:\nint: बनने वाले भिन्न तीव्र कोणीय त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hu": "Írj egy CPP függvényt `int count_acute_triangles(int edges_count, ...)` a következő probléma megoldására:\nSzámold meg, hogy hány hegyesszögű háromszög alakítható ki a megadott élek halmazából tetszőleges 3 él kiválasztásával.\n\nArgok:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nVisszatér:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9641198052306199",
      "hy": "0.9609097396427151",
      "bn": "0.9646145935097777",
      "bg": "0.9529972984141902",
      "zh": "0.9467473934749275",
      "fr": "0.9634081125753718",
      "de": "0.9570012896350916",
      "ha": "0.9458237622031153",
      "hi": "0.9873643269408466",
      "hu": "0.9476509630782552"
    },
    "level": "middle",
    "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër i pacaktuar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hy": "Հաշվեք սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել՝ ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից։\n\nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը։\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ։\n\nՎերադարձնում է:\nint: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել։\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bn": "তীক্ষ্ণ-কোণবিশিষ্ট ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো 3টি প্রান্ত নির্বাচন করে গঠন করা যেতে পারে।\n\nআর্গস:\n- edges_count: পাস করা প্রান্তের সংখ্যা।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি নির্বিচারে সংখ্যক পূর্ণসংখ্যা আর্গুমেন্ট।\n\nরিটার্নস:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণবিশিষ্ট ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "zh": "计算可以通过从给定的边集中选择任意3条边形成的锐角三角形的数量。\n\n参数:\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回:\nint: 可以形成的不同锐角三角形的数量。\n\n示例:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "fr": "Compter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n\nReturns:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgs:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nReturns:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "ha": "Ƙididdige adadin kusurwoyin triangles masu kaifi da za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin saiti na gefuna da aka bayar.\n\nArgs:\n- edges_count: Yawan gefuna da aka bayar.\n- Wani adadi na hujjojin lamba masu wakiltar tsawon gefuna.\n\nReturns:\nint: Yawan kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nवापसी:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hu": "Számolja meg azokat a hegyesszögű háromszögeket, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n\nArgs:\n- edges_count: A megadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9453988918180817",
      "hy": "0.9072509339884262",
      "bn": "0.988880869900048",
      "bg": "0.9407402148612893",
      "zh": "0.9322825332368239",
      "fr": "0.9632996603873268",
      "de": "0.9560264117249723",
      "ha": "0.9443117877426778",
      "hi": "0.9855001808148341",
      "hu": "0.9523990237065132"
    }
  },
  {
    "task_id": "CPP/24",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * \n * Parameters:\n * - integer_value (int): The input integer.\n * - char_value (char): The input character.\n * \n * Returns:\n * - char*: A string containing the integer and character separated by a comma.\n * \n * Example:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sq": "#include <bits/stdc++.h>\n/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n * \n * Parametrat:\n * - integer_value (int): Numri i plotë i dhënë si hyrje.\n * - char_value (char): Karakteri i dhënë si hyrje.\n * \n * Kthen:\n * - char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n * \n * Shembull:\n * process_integer_and_char(234, 'H') kthen \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hy": "#include <bits/stdc++.h>\n/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, բաժանված ստորակետով։\n * \n * Պարամետրեր:\n * - integer_value (int): Մուտքային ամբողջ թիվը։\n * - char_value (char): Մուտքային սիմվոլը։\n * \n * Վերադարձնում է:\n * - char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n * \n * Օրինակ:\n * process_integer_and_char(234, 'H') վերադարձնում է \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bn": "#include <bits/stdc++.h>\n/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে কমা দ্বারা পৃথক একটি ফরম্যাটেড স্ট্রিং হিসাবে ফেরত দেয়।\n * \n * প্যারামিটার:\n * - integer_value (int): ইনপুট পূর্ণসংখ্যা।\n * - char_value (char): ইনপুট অক্ষর।\n * \n * ফেরত দেয়:\n * - char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।\n * \n * উদাহরণ:\n * process_integer_and_char(234, 'H') \"234,H\" ফেরত দেয়\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bg": "#include <bits/stdc++.h>\n/**\n * Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n * \n * Параметри:\n * - integer_value (int): Входното цяло число.\n * - char_value (char): Входният символ.\n * \n * Връща:\n * - char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n * \n * Пример:\n * process_integer_and_char(234, 'H') връща \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "zh": "#include <bits/stdc++.h>\n/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * \n * 参数:\n * - integer_value (int): 输入的整数。\n * - char_value (char): 输入的字符。\n * \n * 返回:\n * - char*: 包含整数和字符并用逗号分隔的字符串。\n * \n * 示例:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "fr": "#include <bits/stdc++.h>\n/**\n * Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n * \n * Paramètres :\n * - integer_value (int) : L'entier d'entrée.\n * - char_value (char) : Le caractère d'entrée.\n * \n * Renvoie :\n * - char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * \n * Exemple :\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "de": "#include <bits/stdc++.h>\n/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\n * \n * Parameter:\n * - integer_value (int): Die Eingabeganzzahl.\n * - char_value (char): Das Eingabezeichen.\n * \n * Rückgabe:\n * - char*: Eine Zeichenkette, die die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\n * \n * Beispiel:\n * process_integer_and_char(234, 'H') gibt \"234,H\" zurück\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "ha": "#include <bits/stdc++.h>\n/**\n * Karanta lamba da harafi, sannan ya mayar da su a matsayin jeren rubutu da aka raba da alamar kwafi.\n * \n * Sigogi:\n * - integer_value (int): Lambar da aka shigar.\n * - char_value (char): Harafin da aka shigar.\n * \n * Komawa:\n * - char*: Jeren rubutu da ke dauke da lambar da harafin da aka raba da alamar kwafi.\n * \n * Misali:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hi": "#include <bits/stdc++.h>\n/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * \n * पैरामीटर्स:\n * - integer_value (int): इनपुट पूर्णांक।\n * - char_value (char): इनपुट वर्ण।\n * \n * रिटर्न्स:\n * - char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए होते हैं।\n * \n * उदाहरण:\n * process_integer_and_char(234, 'H') \"234,H\" लौटाता है\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hu": "#include <bits/stdc++.h>\n/**\n * Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\n * \n * Paraméterek:\n * - integer_value (int): A bemeneti egész szám.\n * - char_value (char): A bemeneti karakter.\n * \n * Visszatérési érték:\n * - char*: Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n * \n * Példa:\n * process_integer_and_char(234, 'H') visszaadja \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "sq": "0.9798292834362882",
      "hy": "0.985806866123152",
      "bn": "0.982378903007252",
      "bg": "0.9918051063696436",
      "zh": "1",
      "fr": "0.9969414893928248",
      "de": "0.9852159407395733",
      "ha": "0.977124136276974",
      "hi": "0.9843145560704369",
      "hu": "0.979863050601064"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "en": "Write a CPP function `char* process_integer_and_char(int integer_value, char char_value)` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "sq": "Shkruani një funksion CPP `char* process_integer_and_char(int integer_value, char char_value)` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\n\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\n\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n\nShembull:\nprocess_integer_and_char(234, 'H') kthen \"234,H\"",
      "hy": "Գրեք CPP ֆունկցիա `char* process_integer_and_char(int integer_value, char char_value)` հետևյալ խնդիրը լուծելու համար:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, որը բաժանված է ստորակետով։\n\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\n\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակ:\nprocess_integer_and_char(234, 'H') վերադարձնում է \"234,H\"",
      "bn": "একটি CPP ফাংশন `char* process_integer_and_char(int integer_value, char char_value)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলি একটি ফরম্যাট করা স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট অক্ষর।\n\nফেরত দেয়:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\nprocess_integer_and_char(234, 'H') \"234,H\" ফেরত দেয়।",
      "bg": "Напишете CPP функция `char* process_integer_and_char(int integer_value, char char_value)`, за да решите следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\n\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПример:\nprocess_integer_and_char(234, 'H') връща \"234,H\"",
      "zh": "编写一个 CPP 函数 `char* process_integer_and_char(int integer_value, char char_value)` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为一个格式化的字符串返回，字符串以逗号分隔。\n\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n\n返回：\n- char*: 一个包含整数和字符并以逗号分隔的字符串。\n\n示例：\nprocess_integer_and_char(234, 'H') 返回 \"234,H\"",
      "fr": "Écrire une fonction CPP `char* process_integer_and_char(int integer_value, char char_value)` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\n\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemple :\nprocess_integer_and_char(234, 'H') renvoie \"234,H\"",
      "de": "Schreiben Sie eine CPP-Funktion `char* process_integer_and_char(int integer_value, char char_value)`, um das folgende Problem zu lösen:\nLiest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierten String, getrennt durch ein Komma, zurück.\n\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\n\nRückgabewert:\n- char*: Ein String, der die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\n\nBeispiel:\nprocess_integer_and_char(234, 'H') gibt \"234,H\" zurück.",
      "ha": "Rubuta aikin CPP `char* process_integer_and_char(int integer_value, char char_value)` don warware matsalar mai zuwa: \n\nKaranta lamba da harafi, sannan ya mayar da su azaman jeren rubutu da aka tsara wanda aka raba su da alamar rubutu.\n\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Harafin shigarwa.\n\nMayarwa:\n- char*: Jeren rubutu da ke dauke da lamba da harafi da aka raba su da alamar rubutu.\n\nMisali:\nprocess_integer_and_char(234, 'H') yana mayar da \"234,H\"",
      "hi": "`char* process_integer_and_char(int integer_value, char char_value)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nएक पूर्णांक और एक अक्षर पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके लौटाता है।\n\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट अक्षर।\n\nरिटर्न्स:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और अक्षर अल्पविराम द्वारा अलग किए गए होते हैं।\n\nउदाहरण:\nprocess_integer_and_char(234, 'H') \"234,H\" लौटाता है।",
      "hu": "Írj egy CPP függvényt `char* process_integer_and_char(int integer_value, char char_value)` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\n\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\n\nVisszatérési érték:\n- char*: Egy karakterlánc, amely tartalmazza az egész számot és a karaktert vesszővel elválasztva.\n\nPélda:\nprocess_integer_and_char(234, 'H') visszaadja \"234,H\""
    },
    "instruction_bertscore": {
      "sq": "0.9781736992103623",
      "hy": "0.993264841039869",
      "bn": "0.9840428297091812",
      "bg": "0.9901888509591628",
      "zh": "0.9951697063939936",
      "fr": "0.9971995102577891",
      "de": "0.9797214271393861",
      "ha": "0.9813366893979619",
      "hi": "0.9546719511566955",
      "hu": "0.9881618279207017"
    },
    "level": "middle",
    "test": "int main() {\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\n\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembull:\nprocess_integer_and_char(234, 'H') kthen \"234,H\"",
      "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով։\n\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\n\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակ:\nprocess_integer_and_char(234, 'H') վերադարձնում է \"234,H\"",
      "bn": "একটি পূর্ণসংখ্যা এবং একটি চরিত্র পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট চরিত্র।\n\nফেরত:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং চরিত্রকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\nprocess_integer_and_char(234, 'H') \"234,H\" ফেরত দেয়।",
      "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\n\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПример:\nprocess_integer_and_char(234, 'H') връща \"234,H\"",
      "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。\n\n示例：\nprocess_integer_and_char(234, 'H') 返回 \"234,H\"",
      "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\n\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemple :\nprocess_integer_and_char(234, 'H') renvoie \"234,H\"",
      "de": "Liest eine ganze Zahl und ein Zeichen ein und gibt sie als formatierten String getrennt durch ein Komma zurück.\n\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\n\nRückgabe:\n- char*: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n\nBeispiel:\nprocess_integer_and_char(234, 'H') gibt \"234,H\" zurück.",
      "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alamar kwafa.\n\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Alamar shigarwa.\n\nDawowa:\n- char*: Wani rubutu da ke dauke da lambar da alamar da aka raba su da alamar kwafa.\n\nMisali:\nprocess_integer_and_char(234, 'H') yana dawowa \"234,H\"",
      "hi": "एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n\nमापदंड:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\n\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए हैं।\n\nउदाहरण:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\n\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\n\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n\nPélda:\nprocess_integer_and_char(234, 'H') visszaadja \"234,H\""
    },
    "docstring_bertscore": {
      "sq": "0.974778907368095",
      "hy": "0.9911516124160389",
      "bn": "0.9756564563915072",
      "bg": "1",
      "zh": "0.9924095386191328",
      "fr": "0.9961120089216231",
      "de": "0.9901820975262076",
      "ha": "0.9765489026934969",
      "hi": "0.9757271688071556",
      "hu": "0.9768873688627804"
    }
  },
  {
    "task_id": "CPP/25",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "sq": "#include <bits/stdc++.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen,\ndhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "hy": "#include <bits/stdc++.h>\n/*\nՏեղաշարժում է բոլոր սիմվոլները 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում,\nև բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որի սիմվոլները տեղաշարժված են 5 դիրքով:\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "bn": "#include <bits/stdc++.h>\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫ পজিশন সরানো হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়,\nএবং সমস্ত অক্ষর বড় হাতের অক্ষরে থাকে।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানেই পরিবর্তিত হয়।\n\nফেরত দেয়:\nstd::string&: রূপান্তরিত টেক্সট যার অক্ষরগুলি ৫ পজিশন সরানো হয়েছে।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "bg": "#include <bits/stdc++.h>\n/*\nИзмества всички символи с 5 позиции в азбучен ред. Само букви се заменят,\nи всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Трансформираният текст с изместени символи с 5 позиции.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "zh": "#include <bits/stdc++.h>\n/*\n将所有字符在字母表中移动5个位置。只有字母被替换，并且所有字母都是大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符移动5个位置后的转换文本。\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "fr": "#include <bits/stdc++.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées,\net toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&): Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :\nstd::string&: Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "de": "#include <bits/stdc++.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt,\nund alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der Eingabetext, der verarbeitet und an Ort und Stelle modifiziert wird.\n\nRückgabe:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "ha": "#include <bits/stdc++.h>\n/*\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu,\nkuma duk haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (std::string&): Rubutun shigarwa da za a sarrafa, ana gyara shi a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da wurare 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "hi": "#include <bits/stdc++.h>\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है,\nऔर सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): वह इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर ही संशोधित किया गया।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "hu": "#include <bits/stdc++.h>\n/*\nEltolja az összes karaktert 5 pozícióval az ábécében. Csak a betűk kerülnek cserére,\nés minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatér:\nstd::string&: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)"
    },
    "prompt_bertscore": {
      "sq": "0.990600611739048",
      "hy": "0.9954549396211597",
      "bn": "0.967707268542491",
      "bg": "0.9907233653145276",
      "zh": "0.9522007905862404",
      "fr": "0.9940142734675137",
      "de": "0.9929897379621357",
      "ha": "0.9758966005221784",
      "hi": "0.9947533771153445",
      "hu": "0.9774695545095937"
    },
    "canonical_solution": "{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "en": "Write a CPP function `std::string& shift_characters(std::string& text)` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "sq": "Shkruani një funksion CPP `std::string& shift_characters(std::string& text)` për të zgjidhur problemin e mëposhtëm:\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karakteret e zhvendosura me 5 pozicione.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "hy": "Գրեք CPP ֆունկցիա `std::string& shift_characters(std::string& text)` հետևյալ խնդիրը լուծելու համար:\nՏառերը 5 դիրքով տեղափոխում է այբբենական կարգով: Միայն տառերը են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "bn": "`std::string& shift_characters(std::string& text)` ফাংশনটি লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫ অবস্থানে সরানো হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকৃত হওয়ার জন্য ইনপুট টেক্সট, স্থানেই পরিবর্তিত হয়।\n\nফেরত দেয়:\nstd::string&: রূপান্তরিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে সরানো হয়েছে।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "bg": "Напишете CPP функция `std::string& shift_characters(std::string& text)`, за да решите следния проблем:\nПремества всички символи с 5 позиции в азбучен ред. Само буквите се заменят, и всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Преобразуваният текст с преместени с 5 позиции символи.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "zh": "编写一个 CPP 函数 `std::string& shift_characters(std::string& text)` 来解决以下问题：\n将所有字符按字母顺序移动5个位置。只有字母被替换，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符被移动5个位置后的转换文本。\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "fr": "Écrire une fonction CPP `std::string& shift_characters(std::string& text)` pour résoudre le problème suivant :  \nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :  \ntext (std::string&) : Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :  \nstd::string& : Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "de": "Schreiben Sie eine CPP-Funktion `std::string& shift_characters(std::string& text)`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der zu verarbeitende Eingabetext, der vor Ort modifiziert wird.\n\nRückgabe:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "ha": "Rubuta aikin CPP `std::string& shift_characters(std::string& text)` don warware matsalar mai zuwa:\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (std::string&): Rubutun shigar da za a sarrafa, a gyara a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "hi": "`std::string& shift_characters(std::string& text)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर संशोधित किया गया।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "hu": "Írj egy CPP függvényt `std::string& shift_characters(std::string& text)` a következő probléma megoldására:\nEltol minden karaktert 5 pozícióval az ábécé sorrendjében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amelyet helyben módosítanak.\n\nVisszatér:\nstd::string&: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n"
    },
    "instruction_bertscore": {
      "sq": "0.990987146460542",
      "hy": "0.9834576646066524",
      "bn": "0.9677289817419001",
      "bg": "0.9396838894544701",
      "zh": "0.9912656887426291",
      "fr": "0.9906685433293619",
      "de": "0.9003250217912493",
      "ha": "0.9721847945917794",
      "hi": "0.9932563624213608",
      "hu": "0.965452615087364"
    },
    "level": "easy",
    "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}",
    "entry_point": "shift_characters",
    "signature": "std::string& shift_characters(std::string& text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Տեղաշարժում է բոլոր տառերը 5 դիրքով այբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որտեղ տառերը տեղաշարժված են 5 դիրքով:\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তর করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানে পরিবর্তিত হয়।\n\nরিটার্নস:\nstd::string&: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে স্থানান্তরিত হয়েছে।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Измества всички знаци с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Преобразуваният текст със знаци, изместени с 5 позиции.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "将所有字符在字母表中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符移动5个位置后的转换文本。\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&) : Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :\nstd::string& : Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der zu verarbeitende Eingabetext, der vor Ort modifiziert wird.\n\nRückgabewert:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (std::string&): Rubutun shigar da za a sarrafa, a gyara a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर ही संशोधित किया जाता है।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें अक्षर 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatérési érték:\nstd::string&: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.9926145251723608",
      "hy": "0.9914741881548395",
      "bn": "0.9522172769078663",
      "bg": "0.9905080499814858",
      "zh": "0.9477474974434382",
      "fr": "0.9872560733831827",
      "de": "0.9736747210799221",
      "ha": "0.956696590630584",
      "hi": "0.9718095818020045",
      "hu": "0.9471589556244318"
    }
  },
  {
    "task_id": "CPP/26",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until \n * the class is determined.\n *\n * Parameters:\n * - x (const char*): The integer to be classified in string form.\n *\n * Returns:\n * int: The class to which the integer x belongs.\n *\n * Usage:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\n * Nëse x është një numër njëshifror, x i përket klasës së vet.\n * Përndryshe, mblidhni shifrat e x, merrni një x të ri, dhe përsëritni derisa \n * klasa të përcaktohet.\n *\n * Parametrat:\n * - x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n *\n * Kthen:\n * int: Klasa së cilës i përket numri i plotë x.\n *\n * Përdorimi:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Դասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով.\n * Եթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\n * Հակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև \n * դասը որոշվի:\n *\n * Պարամետրեր:\n * - x (const char*): Դասակարգման ենթակա ամբողջ թիվը տողային ձևով:\n *\n * Վերադարձնում է:\n * int: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n *\n * Օգտագործում:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * নিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\n * যদি x এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীর অন্তর্ভুক্ত।\n * অন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না \n * শ্রেণী নির্ধারণ করা হয়।\n *\n * প্যারামিটার:\n * - x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n *\n * রিটার্নস:\n * int: শ্রেণী যা পূর্ণসংখ্যা x এর অন্তর্ভুক্ত।\n *\n * ব্যবহার:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Класифицирайте цялото число x въз основа на следния метод:\n * Ако x е едноцифрено число, x принадлежи към своя собствен клас.\n * В противен случай, съберете цифрите на x, получете ново x и \n * итерайте, докато класът бъде определен.\n *\n * Параметри:\n * - x (const char*): Цялото число, което трябва да бъде класифицирано, в стрингова форма.\n *\n * Връща:\n * int: Класът, към който принадлежи цялото число x.\n *\n * Употреба:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 根据以下方法对整数 x 进行分类：\n * 如果 x 是一位数，x 属于它自己的类。\n * 否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n *\n * 参数：\n * - x (const char*): 要分类的整数，以字符串形式表示。\n *\n * 返回：\n * int: 整数 x 所属的类。\n *\n * 用法：\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classifier l'entier x basé sur la méthode suivante :\n * Si x est un nombre à un chiffre, x appartient à sa propre classe.\n * Sinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à \n * ce que la classe soit déterminée.\n *\n * Paramètres :\n * - x (const char*): L'entier à classifier sous forme de chaîne.\n *\n * Renvoie :\n * int : La classe à laquelle appartient l'entier x.\n *\n * Utilisation :\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klassifiziere die ganze Zahl x basierend auf der folgenden Methode:\n * Wenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\n * Andernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, \n * bis die Klasse bestimmt ist.\n *\n * Parameter:\n * - x (const char*): Die zu klassifizierende ganze Zahl in Stringform.\n *\n * Rückgabewert:\n * int: Die Klasse, zu der die ganze Zahl x gehört.\n *\n * Verwendung:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Rarraba lambar x bisa ga hanyar da ke biye:\n * Idan x lamba ce mai lamba guda, x na cikin ajin kansa.\n * In ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har \n * aji ya ƙaddara.\n *\n * Sigogi:\n * - x (const char*): Lambar da za a rarraba a cikin tsarin kirtani.\n *\n * Komawa:\n * int: Aji da lambar x take ciki.\n *\n * Amfani:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\n * यदि x एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\n * अन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \n * जब तक वर्ग निर्धारित न हो जाए।\n *\n * पैरामीटर:\n * - x (const char*): पूर्णांक को स्ट्रिंग रूप में वर्गीकृत किया जाना है।\n *\n * लौटाता है:\n * int: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n *\n * उपयोग:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Osztályozza az x egész számot az alábbi módszer alapján:\n * Ha x egyjegyű szám, akkor x a saját osztályába tartozik.\n * Ellenkező esetben összeadja x számjegyeit, kap egy új x-et, és iterál, amíg \n * az osztály meg nem határozódik.\n *\n * Paraméterek:\n * - x (const char*): Az osztályozandó egész szám sztring formában.\n *\n * Visszatér:\n * int: Az osztály, amelyhez az x egész szám tartozik.\n *\n * Használat:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)"
    },
    "prompt_bertscore": {
      "sq": "0.9913166742626788",
      "hy": "0.9869372716216216",
      "bn": "0.9795637146168444",
      "bg": "0.9935031974971109",
      "zh": "0.9715763897346695",
      "fr": "0.9835488359515474",
      "de": "0.9687560369543552",
      "ha": "0.9715128280127384",
      "hi": "0.9825034442561609",
      "hu": "0.9842098778596315"
    },
    "canonical_solution": "{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "Write a CPP function `int classify_integer(const char *x)` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "sq": "Shkruani një funksion CPP `int classify_integer(const char *x)` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa klasa të përcaktohet.\n\nParametrat:\n- x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nPërdorimi:\n>>> classify_integer(\"24\")\n6",
      "hy": "Գրեք CPP ֆունկցիա `int classify_integer(const char *x)` հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (const char*): Դասակարգվող ամբողջ թիվը տողային ձևով:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x:\n\nՕգտագործում:\n>>> classify_integer(\"24\")\n6",
      "bn": "একটি CPP ফাংশন `int classify_integer(const char *x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারণ করা হয়।\n\nপ্যারামিটার:\n- x (const char*): পূর্ণসংখ্যাটি স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য।\n\nরিটার্নস:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\nব্যবহার:\n>>> classify_integer(\"24\")\n6",
      "bg": "Напишете CPP функция `int classify_integer(const char *x)`, за да решите следния проблем:\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\n\nПараметри:\n- x (const char*): Цялото число, което трябва да бъде класифицирано в стринг форма.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nУпотреба:\n>>> classify_integer(\"24\")\n6",
      "zh": "编写一个 CPP 函数 `int classify_integer(const char *x)` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，则 x 属于其自身的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (const char*): 要分类的整数，字符串形式。\n\n返回：\nint: 整数 x 所属的类别。\n\n用法：\n>>> classify_integer(\"24\")\n6",
      "fr": "Écrire une fonction CPP `int classify_integer(const char *x)` pour résoudre le problème suivant :\nClasser l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (const char*): L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nUtilisation :\n>>> classify_integer(\"24\")\n6",
      "de": "Schreiben Sie eine CPP-Funktion `int classify_integer(const char *x)`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen den Vorgang, bis die Klasse bestimmt ist.\n\nParameter:\n- x (const char*): Die zu klassifizierende ganze Zahl in String-Form.\n\nRückgabewert:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nVerwendung:\n>>> classify_integer(\"24\")\n6",
      "ha": "Rubuta aikin CPP `int classify_integer(const char *x)` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai lamba daya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nSigogi:\n- x (const char*): Lambar da za a rarraba a cikin tsarin kirtani.\n\nDawowa:\nint: Aji wanda lambar x ta ke ciki.\n\nAmfani:\n>>> classify_integer(\"24\")\n6",
      "hi": "`int classify_integer(const char *x)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंकीय संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक दोहराएं जब तक वर्ग निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (const char*): पूर्णांक जो स्ट्रिंग रूप में वर्गीकृत किया जाना है।\n\nवापसी:\nint: वह वर्ग जिसमें पूर्णांक x संबंधित है।",
      "hu": "Írj egy CPP függvényt `int classify_integer(const char *x)` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (const char*): Az osztályozandó egész szám szöveges formában.\n\nVisszatérési érték:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nHasználat:\n>>> classify_integer(\"24\")\n6"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.983831089722998",
      "bn": "0.9719706710410239",
      "bg": "0.9966796945506208",
      "zh": "0.9638476816086021",
      "fr": "0.9784837612351578",
      "de": "0.974807311512583",
      "ha": "0.9627705090522499",
      "hi": "0.9417836202528657",
      "hu": "0.9807477503181935"
    },
    "level": "easy",
    "test": "int main() {\n    assert(classify_integer(\"24\") == 6);\n    assert(classify_integer(\"39\") == 3);\n    assert(classify_integer(\"123456789\") == 9);\n    assert(classify_integer(\"123456789012345678901234567890\") == 9);\n    assert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    // std::printf(\"All tests passed successfully!\\n\");\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(const char *x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nPërdorimi:\n>>> classify_integer(\"24\")\n6",
      "hy": "Դասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x, և կրկնեք մինչև դասը որոշվի։\n\nՊարամետրեր:  \n- x (const char*): Թիվը, որը պետք է դասակարգվի տողի ձևով։\n\nՎերադարձնում է:  \nint: Դասը, որին պատկանում է թիվ x-ը։\n\nՕգտագործում:  \n>>> classify_integer(\"24\")  \n6",
      "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\nরিটার্নস:\nint: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\nব্যবহার:\n>>> classify_integer(\"24\")\n6",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:\n- x (const char*): Цялото число, което трябва да бъде класифицирано, във вид на низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nУпотреба:\n>>> classify_integer(\"24\")\n6",
      "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (const char*): 以字符串形式表示的要分类的整数。\n\n返回：\nint: 整数 x 所属的类。\n\n用法：\n>>> classify_integer(\"24\")\n6",
      "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (const char*): L'entier à classer sous forme de chaîne de caractères.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nUtilisation :\n>>> classify_integer(\"24\")\n6",
      "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n\n- x (const char*): The integer to be classified in string form.  \n  - x (const char*): Die ganze Zahl, die in String-Form klassifiziert werden soll.\n\nGibt zurück:\n\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nVerwendung:\n\n>>> classify_integer(\"24\")\n6",
      "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗigo ɗaya, x na cikin aji nasa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nParameters:\n- x (const char*): Lambar da za a tantance a cikin tsarin kirtani.\n\nReturns:\nint: Ajin da lambar x ta ke ciki.\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "hi": "निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक एकल अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nParameters:\n- x (const char*): स्ट्रिंग रूप में वर्गीकृत की जाने वाली पूर्णांक।\n\nReturns:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "hu": "Osztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összegezze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (const char*): Az osztályozandó egész szám sztring formában.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nHasználat:\n>>> classify_integer(\"24\")\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9869517716394371",
      "hy": "0.972586623852613",
      "bn": "0.9317001489596296",
      "bg": "0.9928590391714147",
      "zh": "0.9472463529920871",
      "fr": "0.9758012579392816",
      "de": "0.8552683701196908",
      "ha": "0.9733044740496731",
      "hi": "0.9576996740548102",
      "hu": "0.9877399369913836"
    }
  },
  {
    "task_id": "CPP/27",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Transforms the case of a given letter.\n * \n * If the input is a lowercase letter, it returns the uppercase version,\n * and if the input is an uppercase letter, it returns the lowercase version.\n * Non-alphabetic characters are returned unchanged.\n *\n * Usage:\n *   char result = transform_letter_case('b'); // result will be 'B'\n *   char result = transform_letter_case('B'); // result will be 'b'\n *\n * @param letter The input letter to be transformed.\n * @return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n */\nchar transform_letter_case(char letter)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Transformon shkronjën e dhënë në rast tjetër.\n * \n * Nëse hyrja është një shkronjë e vogël, kthen versionin e madh,\n * dhe nëse hyrja është një shkronjë e madhe, kthen versionin e vogël.\n * Karakteret jo-alfabetike kthehen të pandryshuara.\n *\n * Përdorimi:\n *   char result = transform_letter_case('b'); // rezultati do të jetë 'B'\n *   char result = transform_letter_case('B'); // rezultati do të jetë 'b'\n *\n * @param letter Shkronja e hyrjes që do të transformohet.\n * @return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.\n */\nchar transform_letter_case(char letter)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Փոխակերպում է տրված տառի ռեգիստրը։\n * \n * Եթե մուտքագրումը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n * իսկ եթե մուտքագրումը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n * Այլ ոչ այբբենական նիշերը վերադարձվում են անփոփոխ։\n *\n * Օգտագործում:\n *   char result = transform_letter_case('b'); // result-ը կլինի 'B'\n *   char result = transform_letter_case('B'); // result-ը կլինի 'b'\n *\n * @param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n * @return Տառը իր ռեգիստրը փոխված, եթե այն այբբենական է, հակառակ դեպքում՝ սկզբնական տառը։\n */\nchar transform_letter_case(char letter)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি প্রদত্ত অক্ষরের ক্ষেত্রে পরিবর্তন করে।\n * \n * যদি ইনপুট একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণটি ফেরত দেয়,\n * এবং যদি ইনপুট একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণটি ফেরত দেয়।\n * অক্ষর ব্যতীত অন্যান্য অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেয়।\n *\n * ব্যবহার:\n *   char result = transform_letter_case('b'); // result হবে 'B'\n *   char result = transform_letter_case('B'); // result হবে 'b'\n *\n * @param letter পরিবর্তন করার জন্য ইনপুট অক্ষর।\n * @return অক্ষরটি যদি বর্ণমালা হয় তবে তার ক্ষেত্রে বিপরীত অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি ফেরত দেয়।\n */\nchar transform_letter_case(char letter)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Преобразува регистъра на дадена буква.\n * \n * Ако входът е малка буква, връща главната версия,\n * и ако входът е главна буква, връща малката версия.\n * Неалфабетните символи се връщат непроменени.\n *\n * Употреба:\n *   char result = transform_letter_case('b'); // result ще бъде 'B'\n *   char result = transform_letter_case('B'); // result ще бъде 'b'\n *\n * @param letter Входната буква, която ще бъде преобразувана.\n * @return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.\n */\nchar transform_letter_case(char letter)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 转换给定字母的大小写。\n * \n * 如果输入是小写字母，则返回大写版本，\n * 如果输入是大写字母，则返回小写版本。\n * 非字母字符将保持不变。\n *\n * 用法:\n *   char result = transform_letter_case('b'); // result 将是 'B'\n *   char result = transform_letter_case('B'); // result 将是 'b'\n *\n * @param letter 要转换的输入字母。\n * @return 如果是字母则返回大小写反转的字母，否则返回原始字母。\n */\nchar transform_letter_case(char letter)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Transforme la casse d'une lettre donnée.\n * \n * Si l'entrée est une lettre minuscule, elle renvoie la version majuscule,\n * et si l'entrée est une lettre majuscule, elle renvoie la version minuscule.\n * Les caractères non alphabétiques sont renvoyés inchangés.\n *\n * Utilisation :\n *   char result = transform_letter_case('b'); // result sera 'B'\n *   char result = transform_letter_case('B'); // result sera 'b'\n *\n * @param letter La lettre d'entrée à transformer.\n * @return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.\n */\nchar transform_letter_case(char letter)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Transformiert den Fall eines gegebenen Buchstabens.\n * \n * Wenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\n * und wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\n * Nicht-alphabetische Zeichen werden unverändert zurückgegeben.\n *\n * Verwendung:\n *   char result = transform_letter_case('b'); // result wird 'B' sein\n *   char result = transform_letter_case('B'); // result wird 'b' sein\n *\n * @param letter Der Eingabebuchstabe, der transformiert werden soll.\n * @return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, ansonsten der ursprüngliche Buchstabe.\n */\nchar transform_letter_case(char letter)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Canza yanayin harafin da aka bayar.\n * \n * Idan shigarwar harafi ne ƙarami, zai dawo da babbar sigar,\n * kuma idan shigarwar harafi ne babba, zai dawo da ƙaramin sigar.\n * Haruffan da ba na haruffa ba za a dawo da su ba tare da canji ba.\n *\n * Amfani:\n *   char result = transform_letter_case('b'); // sakamakon zai zama 'B'\n *   char result = transform_letter_case('B'); // sakamakon zai zama 'b'\n *\n * @param letter Harafin shigarwa da za a canza.\n * @return Harafin da aka juya yanayinsa idan harafi ne, in ba haka ba harafin asali.\n */\nchar transform_letter_case(char letter)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए अक्षर का केस बदलता है।\n * \n * यदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\n * और यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\n * गैर-अक्षरीय वर्ण अपरिवर्तित लौटाए जाते हैं।\n *\n * उपयोग:\n *   char result = transform_letter_case('b'); // result होगा 'B'\n *   char result = transform_letter_case('B'); // result होगा 'b'\n *\n * @param letter इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n * @return अक्षर जिसका केस उलट दिया गया है यदि यह अक्षरीय है, अन्यथा मूल अक्षर।\n */\nchar transform_letter_case(char letter)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Egy adott betű esetét alakítja át.\n * \n * Ha a bemenet kisbetű, akkor a nagybetűs változatot adja vissza,\n * és ha a bemenet nagybetű, akkor a kisbetűs változatot adja vissza.\n * Nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n *\n * Használat:\n *   char result = transform_letter_case('b'); // result 'B' lesz\n *   char result = transform_letter_case('B'); // result 'b' lesz\n *\n * @param letter Az átalakítandó bemeneti betű.\n * @return A betű ellentétes esetben, ha alfabetikus, különben az eredeti betű.\n */\nchar transform_letter_case(char letter)"
    },
    "prompt_bertscore": {
      "sq": "0.9858714209969884",
      "hy": "0.9767431632061491",
      "bn": "0.9397895698576564",
      "bg": "0.9826003758821059",
      "zh": "0.938899109859477",
      "fr": "0.993002847567284",
      "de": "0.9888208835249754",
      "ha": "0.9651759229665824",
      "hi": "0.9816983953218265",
      "hu": "0.984348720495975"
    },
    "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `char transform_letter_case(char letter)` to solve the following problem:\nTransforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = transform_letter_case('b'); // result will be 'B'\n  char result = transform_letter_case('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n",
      "sq": "Shkruani një funksion CPP `char transform_letter_case(char letter)` për të zgjidhur problemin e mëposhtëm:\nTransformon rastin e një shkronje të dhënë.\n\nNëse hyrja është një shkronjë e vogël, ajo kthen versionin e madh,\ndhe nëse hyrja është një shkronjë e madhe, ajo kthen versionin e vogël.\nKarakteret jo-alfabetike kthehen të pandryshuara.\n\nPërdorimi:\n  char result = transform_letter_case('b'); // rezultati do të jetë 'B'\n  char result = transform_letter_case('B'); // rezultati do të jetë 'b'\n\n@param letter Shkronja hyrëse që do të transformohet.\n@return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.",
      "hy": "Գրեք CPP ֆունկցիա `char transform_letter_case(char letter)` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը։\n\nԵթե մուտքագրումը փոքրատառ տառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքագրումը մեծատառ տառ է, վերադարձնում է փոքրատառ տարբերակը։\nԱյլ ոչ այբբենական նիշերը վերադարձվում են անփոփոխ։\n\nՕգտագործում:\n  char result = transform_letter_case('b'); // result-ը կլինի 'B'\n  char result = transform_letter_case('B'); // result-ը կլինի 'b'\n\n@param letter Մուտքային տառը, որը պետք է փոխակերպվի։\n@return Տառը, որի ռեգիստրը փոխված է, եթե այն այբբենական է, հակառակ դեպքում՝ սկզբնական տառը։",
      "bn": "একটি CPP ফাংশন `char transform_letter_case(char letter)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nযদি ইনপুট একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\nএবং যদি ইনপুট একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\nঅ-আক্ষরিক অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n\nব্যবহার:\n  char result = transform_letter_case('b'); // result হবে 'B'\n  char result = transform_letter_case('B'); // result হবে 'b'\n\n@param letter পরিবর্তন করার জন্য ইনপুট অক্ষর।\n@return অক্ষরটি যদি আক্ষরিক হয় তবে তার কেস বিপরীত অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।",
      "bg": "Напишете CPP функция `char transform_letter_case(char letter)`, за да решите следния проблем:\nПреобразува регистъра на дадена буква.\n\nАко входът е малка буква, връща голямата версия,\nи ако входът е голяма буква, връща малката версия.\nНеалфабетните символи се връщат непроменени.\n\nУпотреба:\n  char result = transform_letter_case('b'); // result ще бъде 'B'\n  char result = transform_letter_case('B'); // result ще бъде 'b'\n\n@param letter Входната буква, която ще бъде преобразувана.\n@return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.",
      "zh": "编写一个 CPP 函数 `char transform_letter_case(char letter)` 来解决以下问题：\n转换给定字母的大小写。\n\n如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n非字母字符将保持不变。\n\n用法:\n  char result = transform_letter_case('b'); // result 将是 'B'\n  char result = transform_letter_case('B'); // result 将是 'b'\n\n@param letter 要转换的输入字母。\n@return 如果是字母，则返回大小写转换后的字母，否则返回原始字母。",
      "fr": "Écrire une fonction CPP `char transform_letter_case(char letter)` pour résoudre le problème suivant :\nTransforme la casse d'une lettre donnée.\n\nSi l'entrée est une lettre minuscule, elle renvoie la version majuscule,\net si l'entrée est une lettre majuscule, elle renvoie la version minuscule.\nLes caractères non alphabétiques sont renvoyés inchangés.\n\nUtilisation :\n  char result = transform_letter_case('b'); // result sera 'B'\n  char result = transform_letter_case('B'); // result sera 'b'\n\n@param letter La lettre d'entrée à transformer.\n@return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.",
      "de": "Schreiben Sie eine CPP-Funktion `char transform_letter_case(char letter)`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nWenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\nNicht-alphabetische Zeichen werden unverändert zurückgegeben.\n\nVerwendung:\n  char result = transform_letter_case('b'); // result wird 'B' sein\n  char result = transform_letter_case('B'); // result wird 'b' sein\n\n@param letter Der Eingabebuchstabe, der transformiert werden soll.\n@return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, andernfalls der ursprüngliche Buchstabe.",
      "ha": "Rubuta aikin CPP `char transform_letter_case(char letter)` don warware matsalar mai zuwa:\nCanza harafin da aka bayar daga babba zuwa ƙanana ko daga ƙanana zuwa babba.\n\nIdan shigarwar harafi ne ƙanana, zai dawo da sigar babba,\nkuma idan shigarwar harafi ne babba, zai dawo da sigar ƙanana.\nHaruffan da ba na alfabiti ba za a dawo da su ba tare da canji ba.\n\nAmfani:\n  char result = transform_letter_case('b'); // sakamakon zai zama 'B'\n  char result = transform_letter_case('B'); // sakamakon zai zama 'b'\n\n@param letter Harafin shigarwa da za a canza.\n@return Harafin da aka juya idan harafi ne na alfabiti, in ba haka ba harafin asali.",
      "hi": "एक CPP फ़ंक्शन `char transform_letter_case(char letter)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के मामले को बदलता है।\n\nयदि इनपुट एक छोटे अक्षर का है, तो यह बड़े अक्षर का संस्करण लौटाता है,\nऔर यदि इनपुट एक बड़े अक्षर का है, तो यह छोटे अक्षर का संस्करण लौटाता है।\nगैर-वर्णमाला वर्ण अपरिवर्तित लौटाए जाते हैं।\n\nउपयोग:\n  char result = transform_letter_case('b'); // result will be 'B'\n  char result = transform_letter_case('B'); // result will be 'b'\n\n@param letter इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n@return अक्षर जिसका मामला उलटा हो जाता है यदि यह वर्णमाला है, अन्यथा मूल अक्षर।",
      "hu": "Írj egy CPP függvényt `char transform_letter_case(char letter)` a következő probléma megoldására:\nÁtalakítja egy adott betű kis- és nagybetűs formáját.\n\nHa a bemenet kisbetűs, akkor a nagybetűs változatát adja vissza,\nés ha a bemenet nagybetűs, akkor a kisbetűs változatát adja vissza.\nNem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n\nHasználat:\n  char result = transform_letter_case('b'); // result 'B' lesz\n  char result = transform_letter_case('B'); // result 'b' lesz\n\n@param letter Az átalakítandó bemeneti betű.\n@return A betű megfordított kis- és nagybetűs formája, ha alfabetikus, egyébként az eredeti betű."
    },
    "instruction_bertscore": {
      "sq": "0.9850065843179625",
      "hy": "0.9861234829505217",
      "bn": "0.9719168422077634",
      "bg": "0.9846422961991446",
      "zh": "0.9309517096838901",
      "fr": "0.9920970930297649",
      "de": "0.9847402209769948",
      "ha": "0.9315722309942431",
      "hi": "0.9745423385842825",
      "hu": "0.9720954109203137"
    },
    "level": "easy",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to print a success message (optional)\n    \n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = transform_letter_case('b'); // result will be 'B'\n  char result = transform_letter_case('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n",
      "sq": "Transformon shkronjën e dhënë në rast tjetër.\n\nNëse hyrja është një shkronjë e vogël, kthen versionin e saj me shkronja të mëdha,\ndhe nëse hyrja është një shkronjë e madhe, kthen versionin e saj me shkronja të vogla.\nKarakteret jo-alfabetike kthehen të pandryshuara.\n\nPërdorimi:\n  char result = transform_letter_case('b'); // rezultati do të jetë 'B'\n  char result = transform_letter_case('B'); // rezultati do të jetë 'b'\n\n@param letter Shkronja hyrëse që do të transformohet.\n@return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.",
      "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n\nԵթե մուտքագրվածը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքագրվածը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\nԱյլ ոչ այբբենական նշանները վերադարձվում են առանց փոփոխության։\n\nՕգտագործում:\n  char result = transform_letter_case('b'); // result-ը կլինի 'B'\n  char result = transform_letter_case('B'); // result-ը կլինի 'b'\n\n@param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n@return Տառը՝ իր ռեգիստրով փոխված, եթե այն այբբենական է, հակառակ դեպքում՝ բնօրինակ տառը։",
      "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nযদি ইনপুটটি একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণটি ফেরত দেয়,\nএবং যদি ইনপুটটি একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণটি ফেরত দেয়।\nঅ্যালফাবেটিক নয় এমন অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n\nব্যবহার:\n  char result = transform_letter_case('b'); // result হবে 'B'\n  char result = transform_letter_case('B'); // result হবে 'b'\n\n@param letter রূপান্তর করার জন্য ইনপুট অক্ষর।\n@return অক্ষরটি যদি অ্যালফাবেটিক হয় তবে তার কেস উল্টানো অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।",
      "bg": "Преобразува регистъра на дадена буква.\n\nАко входът е малка буква, връща главната версия,\nа ако входът е главна буква, връща малката версия.\nНеалфабетните символи се връщат непроменени.\n\nУпотреба:\n  char result = transform_letter_case('b'); // result ще бъде 'B'\n  char result = transform_letter_case('B'); // result ще бъде 'b'\n\n@param letter Входната буква, която ще бъде преобразувана.\n@return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.",
      "zh": "将给定字母的大小写转换。\n\n如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n非字母字符将保持不变。\n\n用法:\n  char result = transform_letter_case('b'); // result 将是 'B'\n  char result = transform_letter_case('B'); // result 将是 'b'\n\n@param letter 要转换的输入字母。\n@return 如果是字母，则返回大小写反转的字母，否则返回原始字母。",
      "fr": "Transforme la casse d'une lettre donnée.\n\nSi l'entrée est une lettre minuscule, elle retourne la version majuscule,\net si l'entrée est une lettre majuscule, elle retourne la version minuscule.\nLes caractères non alphabétiques sont retournés inchangés.\n\nUtilisation :\n  char result = transform_letter_case('b'); // result sera 'B'\n  char result = transform_letter_case('B'); // result sera 'b'\n\n@param letter La lettre d'entrée à transformer.\n@return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.",
      "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nWenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\nNicht-alphabetische Zeichen werden unverändert zurückgegeben.\n\nVerwendung:\n  char result = transform_letter_case('b'); // result wird 'B' sein\n  char result = transform_letter_case('B'); // result wird 'b' sein\n\n@param letter Der Eingabebuchstabe, der umgewandelt werden soll.\n@return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, andernfalls der ursprüngliche Buchstabe.",
      "ha": "Canza harafin da aka bayar daga babba zuwa ƙanana ko daga ƙanana zuwa babba.\n\nIdan harafin da aka shigar harafi ne ƙarami, zai mayar da shi babba,\nkuma idan harafin da aka shigar babba ne, zai mayar da shi ƙarami.\nHaruffan da ba na haruffa ba za a mayar da su ba tare da canji ba.\n\nAmfani:\n  char result = transform_letter_case('b'); // sakamakon zai zama 'B'\n  char result = transform_letter_case('B'); // sakamakon zai zama 'b'\n\n@param letter Harafin da aka shigar da za a canza.\n@return Harafin da aka juya yanayin idan harafi ne, in ba haka ba asalin harafin.",
      "hi": "दिए गए अक्षर के मामले को बदलता है।\n\nयदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\nगैर-अक्षरीय वर्ण अपरिवर्तित लौटाए जाते हैं।\n\nउपयोग:\n  char result = transform_letter_case('b'); // result होगा 'B'\n  char result = transform_letter_case('B'); // result होगा 'b'\n\n@param letter वह इनपुट अक्षर जिसे बदला जाना है।\n@return अक्षर जिसका मामला उलटा गया है यदि यह अक्षरीय है, अन्यथा मूल अक्षर।",
      "hu": "Átalakítja egy adott betű kis- és nagybetűs formáját.\n\nHa a bemenet kisbetű, akkor a nagybetűs változatát adja vissza,\nés ha a bemenet nagybetű, akkor a kisbetűs változatát adja vissza.\nA nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n\nHasználat:\n  char result = transform_letter_case('b'); // result 'B' lesz\n  char result = transform_letter_case('B'); // result 'b' lesz\n\n@param letter Az átalakítandó bemeneti betű.\n@return A betű megfordított kis- és nagybetűs változata, ha alfabetikus, különben az eredeti betű."
    },
    "docstring_bertscore": {
      "sq": "0.9670090827531533",
      "hy": "0.9691906402280596",
      "bn": "0.9588334562697574",
      "bg": "0.9818571009962733",
      "zh": "0.9229747135815289",
      "fr": "0.9796276735995377",
      "de": "0.9712049509221343",
      "ha": "0.9309072164785382",
      "hi": "0.9679791935341278",
      "hu": "0.9750947296739405"
    }
  },
  {
    "task_id": "CPP/28",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n * \n * @param character Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n * @return Kodi përkatës ASCII.\n * \n * Shembull:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ցուցադրում է տրված սիմվոլի ASCII տեղեկատվությունը։\n * \n * @param character Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n * @return Համապատասխանող ASCII կոդը։\n * \n * Օրինակ:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n * \n * @param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n * @return সংশ্লিষ্ট ASCII কোড।\n * \n * উদাহরণ:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Показва ASCII информацията за даден символ.\n * \n * @param character Входният символ, за който ще се покаже ASCII информацията.\n * @return Съответният ASCII код.\n * \n * Пример:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 显示给定字符的ASCII信息。\n * \n * @param character 要显示ASCII信息的输入字符。\n * @return 对应的ASCII码。\n * \n * 示例:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // 输出: 65\n * ```\n */\nint display_ascii_info(char character)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Affiche les informations ASCII pour un caractère donné.\n * \n * @param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n * @return Le code ASCII correspondant.\n * \n * Exemple:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n * \n * @param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n * @return Der entsprechende ASCII-Code.\n * \n * Beispiel:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Ausgabe: 65\n * ```\n */\nint display_ascii_info(char character)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n * \n * @param character Alamar shigarwa wanda za a nuna bayanin ASCII.\n * @return Lambar ASCII da ta dace.\n * \n * Misali:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करता है।\n * \n * @param character वह इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n * @return संबंधित ASCII कोड।\n * \n * Example:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Megjeleníti az ASCII információt egy adott karakterhez.\n * \n * @param character Az input karakter, amelyhez az ASCII információt meg kell jeleníteni.\n * @return A megfelelő ASCII kód.\n * \n * Példa:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)"
    },
    "prompt_bertscore": {
      "sq": "0.9842501998269817",
      "hy": "0.9890064043008621",
      "bn": "0.9680046182229002",
      "bg": "0.9939854720622636",
      "zh": "0.9537032307883883",
      "fr": "0.990065104231778",
      "de": "0.9940005679712223",
      "ha": "0.9696163051346173",
      "hi": "0.9862551748931478",
      "hu": "0.9940005679712223"
    },
    "canonical_solution": "{\n    return character;\n}",
    "instruction": {
      "en": "Write a CPP function `int display_ascii_info(char character)` to solve the following problem:\nDisplays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "sq": "Shkruani një funksion CPP `int display_ascii_info(char character)` për të zgjidhur problemin në vijim:\nShfaq informacionin ASCII për një karakter të dhënë.\n\n@param character Karakteri i hyrjes për të cilin informacioni ASCII do të shfaqet.\n@return Kodi përkatës ASCII.\n\nShembull:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hy": "Գրեք CPP ֆունկցիա `int display_ascii_info(char character)` հետևյալ խնդիրը լուծելու համար:\nՑուցադրում է տրված սիմվոլի ASCII տեղեկատվությունը։\n\n@param character Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n@return Համապատասխան ASCII կոդը։\n\nՕրինակ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "bn": "একটি CPP ফাংশন `int display_ascii_info(char character)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n\n@param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n@return সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // আউটপুট: 65\n```",
      "bg": "Напишете CPP функция `int display_ascii_info(char character)` за решаване на следния проблем:  \nПоказва ASCII информацията за даден символ.\n\n@param character Входният символ, за който ще се покаже ASCII информацията.  \n@return Съответният ASCII код.\n\nПример:  \n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "zh": "编写一个 CPP 函数 `int display_ascii_info(char character)` 来解决以下问题：\n显示给定字符的 ASCII 信息。\n\n@param character 要显示其 ASCII 信息的输入字符。\n@return 对应的 ASCII 代码。\n\n示例:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // 输出: 65\n```",
      "fr": "Écrire une fonction CPP `int display_ascii_info(char character)` pour résoudre le problème suivant :  \nAffiche les informations ASCII pour un caractère donné.\n\n@param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.  \n@return Le code ASCII correspondant.\n\nExemple:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "de": "Schreiben Sie eine CPP-Funktion `int display_ascii_info(char character)`, um das folgende Problem zu lösen:\nZeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\n@param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n@return Der entsprechende ASCII-Code.\n\nBeispiel:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Ausgabe: 65\n```",
      "ha": "Rubuta aikin CPP `int display_ascii_info(char character)` don warware matsalar mai zuwa:  \nNuna bayanin ASCII don wata alama da aka bayar.\n\n@param character Alamar shigarwa wadda za a nuna bayanin ASCII dinta.  \n@return Lambar ASCII da ta dace.\n\nMisali:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hi": "एक CPP फ़ंक्शन `int display_ascii_info(char character)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के लिए ASCII जानकारी प्रदर्शित करता है।\n\n@param character वह इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n@return संबंधित ASCII कोड।\n\nउदाहरण:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hu": "Írj egy CPP függvényt `int display_ascii_info(char character)` a következő probléma megoldására:\nMegjeleníti a megadott karakter ASCII információit.\n\n@param character Az a bemeneti karakter, amelynek ASCII információit meg kell jeleníteni.\n@return A megfelelő ASCII kód.\n\nPélda:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Kimenet: 65\n```"
    },
    "instruction_bertscore": {
      "sq": "0.8729681247433286",
      "hy": "0.9857689277203744",
      "bn": "0.9612491989639037",
      "bg": "0.9929514022985959",
      "zh": "0.9581857225972026",
      "fr": "0.8781239735438512",
      "de": "0.9931025600185636",
      "ha": "0.9875327655039642",
      "hi": "0.9835645277516493",
      "hu": "0.9808768600658662"
    },
    "level": "easy",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "en": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n@param character Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n@return Kodi përkatës ASCII.\n\nShembull:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hy": "Տպում է ASCII տեղեկատվությունը տրված սիմվոլի համար։\n\n@param character Մուտքային սիմվոլը, որի համար պետք է տպել ASCII տեղեկատվությունը։\n@return Համապատասխանող ASCII կոդը։\n\nՕրինակ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n\n@param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n@return সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "bg": "Показва ASCII информацията за даден символ.\n\n@param character Входният символ, за който трябва да се покаже ASCII информацията.\n@return Съответният ASCII код.\n\nПример:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Изход: 65\n```",
      "zh": "显示给定字符的ASCII信息。\n\n@param character 要显示ASCII信息的输入字符。\n@return 对应的ASCII代码。\n\n示例：\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // 输出: 65\n```",
      "fr": "Affiche les informations ASCII pour un caractère donné.\n\n@param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n@return Le code ASCII correspondant.\n\nExemple :\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Sortie : 65\n```",
      "de": "Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\n@param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n@return Der entsprechende ASCII-Code.\n\nBeispiel:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Ausgabe: 65\n```",
      "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n@param character Harafin shigarwa wanda za a nuna bayanin ASCII.\n@return Lambar ASCII da ta dace.\n\nMisali:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hi": "दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करता है।\n\n@param character वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n@return संबंधित ASCII कोड।\n\nउदाहरण:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // आउटपुट: 65\n```",
      "hu": "Megjeleníti a megadott karakter ASCII információját.\n\n@param character A bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n@return A megfelelő ASCII kód.\n\nPélda:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Kimenet: 65\n```"
    },
    "docstring_bertscore": {
      "sq": "0.9819649572931752",
      "hy": "0.9665891781276456",
      "bn": "0.9477184974078071",
      "bg": "0.9813809839729327",
      "zh": "0.9666525412191957",
      "fr": "0.976605909612854",
      "de": "0.9813809839729327",
      "ha": "0.9614913293983852",
      "hi": "0.9902782346306285",
      "hu": "0.9758101963064282"
    }
  },
  {
    "task_id": "CPP/29",
    "prompt": {
      "en": "#include <cassert> // Used for making assertions in test cases\n/**\n * @brief Evaluate the grade for an input integer.\n * \n * @param score The integer score to be evaluated.\n * @return char The grade corresponding to the input score.\n *              If the score is between 90 and 100 (inclusive), returns 'A'.\n *              Otherwise, returns 'B'.\n * \n * Examples:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "sq": "#include <cassert> // Përdoret për të bërë pohime në rastet e testimit\n/**\n * @brief Vlerëson notën për një numër të plotë hyrës.\n * \n * @param score Nota e plotë që do të vlerësohet.\n * @return char Nota që korrespondon me notën hyrëse.\n *              Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n *              Përndryshe, kthen 'B'.\n * \n * Shembuj:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "hy": "#include <cassert> // Օգտագործվում է թեստային դեպքերում հաստատումներ կատարելու համար\n/**\n * @brief Գնահատել մուտքային ամբողջ թվի գնահատականը։\n * \n * @param score Գնահատման ենթակա ամբողջ թիվը։\n * @return char Մուտքային գնահատականին համապատասխանող գնահատականը։\n *              Եթե գնահատականը 90-ից 100-ի (ներառյալ) միջև է, վերադարձնում է 'A'։\n *              Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * Օրինակներ:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "bn": "#include <cassert> // টেস্ট কেসে অ্যাসারশন করার জন্য ব্যবহৃত হয়\n/**\n * @brief একটি পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n * \n * @param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * @return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n *              যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' রিটার্ন করে।\n *              অন্যথায়, 'B' রিটার্ন করে।\n * \n * উদাহরণ:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "bg": "#include <cassert> // Използва се за извършване на твърдения в тестови случаи\n/**\n * @brief Оценява оценката за входно цяло число.\n * \n * @param score Цялочислената оценка, която трябва да бъде оценена.\n * @return char Оценката, съответстваща на входната оценка.\n *              Ако оценката е между 90 и 100 (включително), връща 'A'.\n *              В противен случай връща 'B'.\n * \n * Примери:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "zh": "#include <cassert> // 用于在测试用例中进行断言\n/**\n * @brief 评估输入整数的等级。\n * \n * @param score 要评估的整数分数。\n * @return char 与输入分数对应的等级。\n *              如果分数在90到100之间（包括90和100），返回'A'。\n *              否则，返回'B'。\n * \n * 示例:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "fr": "#include <cassert> // Utilisé pour faire des assertions dans les cas de test\n/**\n * @brief Évaluer la note pour un entier en entrée.\n * \n * @param score Le score entier à évaluer.\n * @return char La note correspondant au score en entrée.\n *              Si le score est entre 90 et 100 (inclus), retourne 'A'.\n *              Sinon, retourne 'B'.\n * \n * Exemples :\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "de": "#include <cassert> // Wird für Assertions in Testfällen verwendet\n/**\n * @brief Bewertet die Note für eine Eingabezahl.\n * \n * @param score Die zu bewertende ganze Zahl.\n * @return char Die Note, die der Eingabezahl entspricht.\n *              Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n *              Andernfalls wird 'B' zurückgegeben.\n * \n * Beispiele:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "ha": "#include <cassert> // Ana amfani da wannan don yin tabbaci a gwaje-gwaje\n\n/**\n * @brief Kimanta darajar maki don wani lamba.\n * \n * @param score Makin lamba da za a kimanta.\n * @return char Darajar da ta dace da makin da aka shigar.\n *              Idan makin yana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n *              In ba haka ba, zai dawo da 'B'.\n * \n * Misalai:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "hi": "#include <cassert> // परीक्षण मामलों में अभिकथन करने के लिए उपयोग किया जाता है\n/**\n * @brief किसी इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * \n * @param score मूल्यांकन के लिए पूर्णांक स्कोर।\n * @return char इनपुट स्कोर के अनुरूप ग्रेड।\n *              यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n *              अन्यथा, 'B' लौटाता है।\n * \n * उदाहरण:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "hu": "#include <cassert> // Használva az állítások megfogalmazására a tesztesetekben\n/**\n * @brief Értékeli a jegyet egy bemeneti egész számhoz.\n * \n * @param score Az értékelendő egész szám pontszám.\n * @return char A bemeneti pontszámhoz tartozó jegy.\n *              Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n *              Ellenkező esetben 'B'-t ad vissza.\n * \n * Példák:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "sq": "0.9968765372582263",
      "hy": "0.9926514704232333",
      "bn": "0.9772876090805657",
      "bg": "0.9866587918274107",
      "zh": "0.9745872290503964",
      "fr": "0.9949381033697069",
      "de": "0.9688273452611467",
      "ha": "0.963807359641252",
      "hi": "0.9584916133839964",
      "hu": "0.9880283483046463"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "en": "Write a CPP function `char evaluate_integer_grade(int score)` to solve the following problem:\nEvaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'\n",
      "sq": "Shkruani një funksion CPP `char evaluate_integer_grade(int score)` për të zgjidhur problemin e mëposhtëm:\nVlerësoni notën për një numër të plotë të dhënë.\n\n@param score Numri i plotë i pikëve që do të vlerësohet.\n@return char Nota që korrespondon me pikët e dhëna.\n             Nëse pikët janë midis 90 dhe 100 (përfshirë), kthen 'A'.\n             Përndryshe, kthen 'B'.\n\nShembuj:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hy": "Գրեք CPP ֆունկցիա `char evaluate_integer_grade(int score)` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվային գնահատականը:\n\n@param score Գնահատման ենթակա ամբողջ թվային միավորը:\n@return char Մուտքային գնահատականին համապատասխանող գնահատականը:\n             Եթե գնահատականը 90-ից 100-ի (ներառյալ) միջակայքում է, վերադարձնում է 'A':\n             Հակառակ դեպքում, վերադարձնում է 'B':\n\nՕրինակներ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "bn": "একটি CPP ফাংশন `char evaluate_integer_grade(int score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n\n@param score মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।\n@return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n             যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' প্রদান করে।\n             অন্যথায়, 'B' প্রদান করে।\n\nউদাহরণ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "bg": "Напишете CPP функция `char evaluate_integer_grade(int score)`, за да решите следния проблем:\nОценете оценката за входно цяло число.\n\n@param score Цялото число, което трябва да бъде оценено.\n@return char Оценката, съответстваща на входното число.\n             Ако числото е между 90 и 100 (включително), връща 'A'.\n             В противен случай връща 'B'.\n\nПримери:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "zh": "编写一个 CPP 函数 `char evaluate_integer_grade(int score)` 来解决以下问题：\n评估输入整数的等级。\n\n@param score 要评估的整数分数。\n@return char 与输入分数对应的等级。\n             如果分数在 90 到 100 之间（包括 90 和 100），返回 'A'。\n             否则，返回 'B'。\n\n示例：\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "fr": "Écrire une fonction CPP `char evaluate_integer_grade(int score)` pour résoudre le problème suivant :\nÉvaluer la note pour un entier en entrée.\n\n@param score L'entier à évaluer.\n@return char La note correspondant au score en entrée.\n             Si le score est entre 90 et 100 (inclus), retourne 'A'.\n             Sinon, retourne 'B'.\n\nExemples :\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "de": "Schreiben Sie eine CPP-Funktion `char evaluate_integer_grade(int score)`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine Eingabezahl.\n\n@param score Die zu bewertende ganze Zahl.\n@return char Die Note, die der Eingabezahl entspricht.\n             Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n             Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "ha": "Rubuta aikin CPP `char evaluate_integer_grade(int score)` don warware matsalar mai zuwa:\nKimanta darajar don shigar da cikakken lamba.\n\n@param score Cikakken lambar da za a kimanta.\n@return char Darajar da ta dace da lambar da aka shigar.\n             Idan lambar tana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n             In ba haka ba, zai dawo da 'B'.\n\nMisalai:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hi": "`char evaluate_integer_grade(int score)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nइनपुट पूर्णांक का ग्रेड मूल्यांकन करें।\n\n@param score मूल्यांकन के लिए पूर्णांक स्कोर।\n@return char इनपुट स्कोर के अनुरूप ग्रेड।\n             यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n             अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hu": "Írj egy CPP függvényt `char evaluate_integer_grade(int score)` a következő probléma megoldására:\nÉrtékeld ki a jegyet egy egész számú bemenet alapján.\n\n@param score Az egész számú pontszám, amelyet ki kell értékelni.\n@return char A bemeneti pontszámnak megfelelő jegy.\n             Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n             Egyébként 'B'-t ad vissza.\n\nPéldák:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'"
    },
    "instruction_bertscore": {
      "sq": "0.9560860008392827",
      "hy": "0.9810915795077648",
      "bn": "0.984502460410896",
      "bg": "0.9787165560417307",
      "zh": "0.972968192814581",
      "fr": "0.9874507311565968",
      "de": "0.9665448835526749",
      "ha": "0.9717062940038664",
      "hi": "0.9351148038400003",
      "hu": "0.9807932366754505"
    },
    "level": "easy",
    "test": "int main() {\n    assert(evaluate_integer_grade(90) == 'A'); // Test for lower bound of 'A' grade\n    assert(evaluate_integer_grade(89) == 'B'); // Test for score just below 'A' grade\n    assert(evaluate_integer_grade(95) == 'A'); // Test for a score well within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Test for upper boundary of 'A' grade\n    assert(evaluate_integer_grade(101) == 'B'); // Test for score above 'A' grade range\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // std::cout << \"All tests passed\\n\";\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'\n",
      "sq": "Vlerësoni notën për një numër të plotë hyrës.\n\n@param score Numri i plotë i pikëve që do të vlerësohet.\n@return char Nota që korrespondon me pikët hyrëse.\n             Nëse pikët janë midis 90 dhe 100 (përfshirë), kthen 'A'.\n             Përndryshe, kthen 'B'.\n\nShembuj:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hy": "Հաշվարկել գնահատականը մուտքային ամբողջ թվի համար։\n\n@param score Գնահատվող ամբողջ թվային միավորը։\n@return char Մուտքային միավորին համապատասխան գնահատականը։\n             Եթե միավորը 90-ից 100-ի (ներառյալ) միջև է, վերադարձնում է 'A'։\n             Հակառակ դեպքում, վերադարձնում է 'B'։\n\nՕրինակներ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "bn": "একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n\n@param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n@return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n             যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তবে 'A' ফেরত দেয়।\n             অন্যথায়, 'B' ফেরত দেয়।\n\nউদাহরণ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "bg": "Оценете оценката за входящо цяло число.\n\n@param score Цялото число, което трябва да бъде оценено.\n@return char Оценката, съответстваща на входящия резултат.\n             Ако резултатът е между 90 и 100 (включително), връща 'A'.\n             В противен случай връща 'B'.\n\nПримери:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "zh": "评估输入整数的等级。\n\n@param score 要评估的整数分数。\n@return char 与输入分数对应的等级。\n如果分数在90到100之间（包括90和100），返回'A'。\n             否则，返回'B'。\n\n示例：\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "fr": "Évaluer la note pour un entier en entrée.\n\n@param score L'entier score à évaluer.\n@return char La note correspondant au score d'entrée.\n             Si le score est entre 90 et 100 (inclus), retourne 'A'.\n             Sinon, retourne 'B'.\n\nExemples :\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n\n@param score Die ganzzahlige Punktzahl, die bewertet werden soll.\n@return char Die Note, die der eingegebenen Punktzahl entspricht.\n             Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n             Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "ha": "Kimanta darajar don shigar da cikakken lamba.\n\n@param score Lambar da za a tantance.\n@return char Darajar da ta dace da lambar shigarwa.\n             Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n             In ba haka ba, yana dawowa 'B'.\n\nMisalai:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\n@param score मूल्यांकन के लिए पूर्णांक स्कोर।\n@return char इनपुट स्कोर के अनुरूप ग्रेड।\n             यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n             अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hu": "Értékelje egy bemeneti egész szám osztályzatát.\n\n@param score Az értékelendő egész szám pontszám.\n@return char Az osztályzat, amely megfelel a bemeneti pontszámnak.\n             Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n             Egyébként 'B'-t ad vissza.\n\nPéldák:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'"
    },
    "docstring_bertscore": {
      "sq": "0.9657807524768336",
      "hy": "0.9772200747510138",
      "bn": "0.9538686898957903",
      "bg": "0.9736206936162807",
      "zh": "0.9644461549466602",
      "fr": "0.9885207530192317",
      "de": "0.9628408242071362",
      "ha": "0.9533570180342444",
      "hi": "0.9453808164534074",
      "hu": "0.9959644265485141"
    }
  },
  {
    "task_id": "CPP/30",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n * \n * @param s A three-character string to be checked.\n * \n * @return Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n * Examples:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "sq": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n * \n * @param s Një varg me tre karaktere që do të kontrollohet.\n * \n * @return Kthen \"Yes\" nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe \"No\".\n * Shembuj:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "hy": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ ճիշտ երկու նույն նիշ։\n * \n * @param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի։\n * \n * @return Վերադարձնում է \"Yes\", եթե մուտքում կա ճիշտ երկու հավասար նիշ, հակառակ դեպքում՝ \"No\"։\n * Օրինակներ:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "bn": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই আছে কিনা।\n * \n * @param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n * \n * @return \"Yes\" প্রদান করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n * উদাহরণ:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "bg": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Проверява дали низ от три знака има точно два еднакви знака.\n * \n * @param s Низ от три знака, който трябва да бъде проверен.\n * \n * @return Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n * Примери:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "zh": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 检查一个三字符的字符串是否有且仅有两个字符相同。\n * \n * @param s 要检查的三字符字符串。\n * \n * @return 如果输入有且仅有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n * 例子:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "fr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n * \n * @param s Une chaîne de trois caractères à vérifier.\n * \n * @return Retourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n * Exemples :\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "de": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n * \n * @param s Ein dreistelliger String, der überprüft werden soll.\n * \n * @return Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n * Beispiele:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "ha": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Duba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n * \n * @param s Kirtani mai haruffa uku da za a duba.\n * \n * @return Yana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu da suke daidai, in ba haka ba \"No\".\n * Misalai:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "hi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * जांचता है कि क्या एक तीन-अक्षर वाली स्ट्रिंग में ठीक दो अक्षर समान हैं।\n * \n * @param s एक तीन-अक्षर वाली स्ट्रिंग जिसे जांचा जाना है।\n * \n * @return \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n * उदाहरण:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "hu": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ellenőrzi, hogy egy három karakterből álló string pontosan két azonos karaktert tartalmaz-e.\n * \n * @param s Egy három karakterből álló string, amelyet ellenőrizni kell.\n * \n * @return \"Yes\"-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben \"No\"-t.\n * Példák:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "sq": "0.9894145897338887",
      "hy": "0.9845771454341651",
      "bn": "0.9753448053236635",
      "bg": "0.9730798230887227",
      "zh": "0.9709544780116494",
      "fr": "0.971561889716854",
      "de": "0.9743200711879045",
      "ha": "0.9743953521023168",
      "hi": "0.9794794953352857",
      "hu": "0.9746827702636742"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "Write a CPP function `const char* check_two_equal_digits(const char s[4])` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n \nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"\n",
      "sq": "Shkruani një funksion CPP `const char* check_two_equal_digits(const char s[4])` për të zgjidhur problemin në vijim:  \nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:  \n@param s Një varg me tre karaktere që do të kontrollohet.\n\nKthen:  \nKthen \"Yes\" nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe \"No\".  \nShembuj:  \n  >>> check_two_equal_digits(\"112\")  \n  \"Yes\"  \n  >>> check_two_equal_digits(\"123\")  \n  \"No\"  ",
      "hy": "Գրեք CPP ֆունկցիա `const char* check_two_equal_digits(const char s[4])` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է՝ արդյոք երեք նիշից բաղկացած տողում կա՞ն ճիշտ երկու նույն նիշեր։\n\nՊարամետրեր:\n@param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի։\n\nՎերադարձնում է:\nՎերադարձնում է \"Yes\", եթե մուտքում կա ճիշտ երկու նույն նիշ, հակառակ դեպքում՝ \"No\":\nՕրինակներ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "bn": "একটি CPP ফাংশন `const char* check_two_equal_digits(const char s[4])` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nপরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nParameters:\n@param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nReturns:\nযদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে \"Yes\" রিটার্ন করে, অন্যথায় \"No\"।\nExamples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "bg": "Напишете CPP функция `const char* check_two_equal_digits(const char s[4])`, за да решите следния проблем:\nПроверява дали низ с три символа има точно два еднакви символа.\n\nПараметри:\n@param s Низ с три символа, който трябва да бъде проверен.\n\nВръща:\nВръща \"Yes\", ако входът има точно два еднакви символа, в противен случай \"No\".\nПримери:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "zh": "编写一个 CPP 函数 `const char* check_two_equal_digits(const char s[4])` 来解决以下问题：\n检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n@param s 要检查的三字符字符串。\n\n返回：\n如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n示例：\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "fr": "Écrire une fonction CPP `const char* check_two_equal_digits(const char s[4])` pour résoudre le problème suivant :  \nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres :  \n@param s Une chaîne de trois caractères à vérifier.\n\nRenvoie :  \nRenvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".  \nExemples :  \n  >>> check_two_equal_digits(\"112\")  \n  \"Yes\"  \n  >>> check_two_equal_digits(\"123\")  \n  \"No\"  ",
      "de": "Schreiben Sie eine CPP-Funktion `const char* check_two_equal_digits(const char s[4])`, um das folgende Problem zu lösen:\nPrüft, ob ein dreistelliger Zeichenfolgen genau zwei gleiche Zeichen hat.\n\nParameter:\n@param s Eine dreistellige Zeichenfolge, die überprüft werden soll.\n\nRückgabewerte:\nGibt \"Yes\" zurück, wenn die Eingabe genau zwei gleiche Zeichen hat, andernfalls \"No\".\nBeispiele:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "ha": "Rubuta aikin CPP `const char* check_two_equal_digits(const char s[4])` don warware matsalar mai zuwa:  \nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke iri ɗaya.\n\nSigogi:  \n@param s Kirtani mai haruffa uku da za a duba.\n\nDawowa:  \nDawo da \"Yes\" idan shigarwar tana da daidai haruffa biyu da suke iri ɗaya, in ba haka ba \"No\".  \nMisalai:  \n  >>> check_two_equal_digits(\"112\")  \n  \"Yes\"  \n  >>> check_two_equal_digits(\"123\")  \n  \"No\"",
      "hi": "एक CPP फ़ंक्शन `const char* check_two_equal_digits(const char s[4])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nParameters:\n@param s एक तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n\nReturns:\n\"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\nExamples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "hu": "Írj egy CPP függvényt `const char* check_two_equal_digits(const char s[4])` a következő probléma megoldására:\nEllenőrzi, hogy egy három karakterből álló stringben pontosan két karakter azonos-e.\n\nParaméterek:\n@param s Egy három karakterből álló string, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n\"Yes\"-t ad vissza, ha a bemenetben pontosan két azonos karakter van, különben \"No\"-t.\nPéldák:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\""
    },
    "instruction_bertscore": {
      "sq": "0.9888399520415548",
      "hy": "0.9529804148318023",
      "bn": "0.9814622237987759",
      "bg": "0.9698016272801229",
      "zh": "0.9585434559134464",
      "fr": "0.9709755328320391",
      "de": "0.9711672111497377",
      "ha": "0.9775462258366732",
      "hi": "0.977123739016212",
      "hu": "0.9535987512079639"
    },
    "level": "easy",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"\n",
      "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:\n@param s Një varg me tre karaktere që do të kontrollohet.\n\nKthen:\nKthen \"Po\" nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe \"Jo\".\nShembuj:\n  >>> check_two_equal_digits(\"112\")\n  \"Po\"\n  >>> check_two_equal_digits(\"123\")\n  \"Jo\"",
      "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n\nՊարամետրեր:\n@param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի:\n\nՎերադարձնում է:\nՎերադարձնում է \"Yes\", եթե մուտքագրվածը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ \"No\":\nՕրինակներ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "bn": "পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই আছে কিনা।\n\nপ্যারামিটারসমূহ:\n@param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\nযদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে \"Yes\" ফেরত দেয়, অন্যথায় \"No\"।\n\nউদাহরণসমূহ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "bg": "Проверява дали низ с три знака има точно два еднакви знака.\n\nПараметри:\n@param s Низ с три знака, който да бъде проверен.\n\nВръща:\nВръща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\nПримери:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n@param s 要检查的三字符字符串。\n\n返回：\n如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\n示例：\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres:\n@param s Une chaîne de trois caractères à vérifier.\n\nRetourne:\nRetourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\nExemples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nParameter:\n@param s Ein dreistelliger String, der überprüft werden soll.\n\nRückgabe:\nGibt \"Ja\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"Nein\".\nBeispiele:\n  >>> check_two_equal_digits(\"112\")\n  \"Ja\"\n  >>> check_two_equal_digits(\"123\")\n  \"Nein\"",
      "ha": "Duba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n\nSigogi:\n@param s Wani kirtani mai haruffa uku da za a duba.\n\nDawowa:\nYana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba \"No\".\n\nMisalai:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "hi": "तीन-अक्षरों की स्ट्रिंग में जांच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nपैरामीटर्स:\n@param s एक तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nवापसी:\nयदि इनपुट में ठीक दो समान अक्षर हैं तो \"Yes\" लौटाता है, अन्यथा \"No\"।\n\nउदाहरण:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "hu": "Ellenőrzi, hogy egy három karakter hosszú stringben pontosan két azonos karakter van-e.\n\nParaméterek:\n@param s Egy három karakter hosszú string, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n\"Yes\"-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-t.\n\nPéldák:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\""
    },
    "docstring_bertscore": {
      "sq": "0.984314754700818",
      "hy": "0.9798948314620296",
      "bn": "0.9862629214780082",
      "bg": "0.9726225759515803",
      "zh": "0.9543612932407568",
      "fr": "0.9578269961290535",
      "de": "0.9507366860476322",
      "ha": "0.9915703252592604",
      "hi": "0.9345338099754733",
      "hu": "0.9473111064963046"
    }
  },
  {
    "task_id": "CPP/31",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni\n * një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal\n * i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n * \n * Shembuj:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Տրված է փոքրատառ անգլերեն տառերից կազմված լար, յուրաքանչյուր փուլում դուք կարող եք փոխել\n * տառերից մեկը մեկ այլ տառի: Հարցն այն է՝ որն է նվազագույն\n * փուլերի քանակը, որը անհրաժեշտ է լարը նույն տառից կազմված դարձնելու համար?\n * \n * Օրինակներ:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি\n * একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর\n * দিয়ে গঠিত করতে ন্যূনতম কতগুলি রাউন্ড প্রয়োজন?\n * \n * উদাহরণ:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените\n * един от символите на друг символ. Въпросът е: какъв е минималният\n * брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n * \n * Примери:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。\n * 问题是：需要多少轮才能使字符串由相同的字符组成？\n * \n * 示例：\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer\n * l'un des caractères en un autre caractère. La question est : quel est le nombre minimum\n * de tours nécessaires pour que la chaîne soit composée du même caractère ?\n * \n * Exemples :\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann man\n * eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale\n * Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\n * \n * Beispiele:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * An ba da wani kirtani da ya ƙunshi ƙananan haruffan Turanci, a kowace zagaye za ka iya canza\n * ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin\n * adadin zagaye da ake buƙata don sanya kirtanin ya ƙunshi harafi ɗaya?\n * \n * Misalai:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * दिए गए एक स्ट्रिंग जिसमें छोटे अंग्रेजी अक्षर होते हैं, प्रत्येक राउंड में आप \n * एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही \n * अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n * \n * उदाहरण:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Adott egy, kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod\n * az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális\n * körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n * \n * Példák:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "sq": "0.9964113449058427",
      "hy": "0.9877417246648129",
      "bn": "0.9805477295244913",
      "bg": "1",
      "zh": "0.9660443349924669",
      "fr": "0.9875077380759538",
      "de": "0.9655928481363746",
      "ha": "0.9838171855963256",
      "hi": "0.9740129886188246",
      "hu": "0.9881342182977378"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n",
    "instruction": {
      "en": "Write a CPP function `int minRoundsToSameChar(const char* s)` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "sq": "Shkruani një funksion CPP `int minRoundsToSameChar(const char* s)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni\nnjë nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal\ni raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nShembuj:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hy": "Գրեք CPP ֆունկցիա `int minRoundsToSameChar(const char* s)` լուծելու համար հետևյալ խնդիրը:  \nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում դուք կարող եք փոխել  \nտողերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն  \nփուլերի քանակը, որը անհրաժեշտ է տողը նույն տառից կազմված դարձնելու համար:  \n\nՕրինակներ:  \n>>> minRoundsToSameChar(\"aab\")  \n1  \n>>> minRoundsToSameChar(\"abc\")  \n2  \n>>> minRoundsToSameChar(\"aaa\")  \n0",
      "bn": "একটি CPP ফাংশন `int minRoundsToSameChar(const char* s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণসমূহ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "bg": "Напишете CPP функция `int minRoundsToSameChar(const char* s)` за решаване на следния проблем:  \nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nПримери:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "zh": "编写一个 CPP 函数 `int minRoundsToSameChar(const char* s)` 来解决以下问题：  \n给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？  \n\n示例：  \n>>> minRoundsToSameChar(\"aab\")  \n1  \n>>> minRoundsToSameChar(\"abc\")  \n2  \n>>> minRoundsToSameChar(\"aaa\")  \n0  ",
      "fr": "Écrire une fonction CPP `int minRoundsToSameChar(const char* s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nExemples :  \n>>> minRoundsToSameChar(\"aab\")  \n1  \n>>> minRoundsToSameChar(\"abc\")  \n2  \n>>> minRoundsToSameChar(\"aaa\")  \n0  ",
      "de": "Schreiben Sie eine CPP-Funktion `int minRoundsToSameChar(const char* s)`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl an Runden, die benötigt wird, um den String aus demselben Zeichen zusammengesetzt zu machen?\n\nBeispiele:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "ha": "Rubuta aikin CPP `int minRoundsToSameChar(const char* s)` don warware matsalar mai zuwa:  \n\nAn ba da wata igiya da ke kunshe da ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar ta ƙunshi harafi ɗaya?  \n\nMisalai:  \n>>> minRoundsToSameChar(\"aab\")  \n1  \n>>> minRoundsToSameChar(\"abc\")  \n2  \n>>> minRoundsToSameChar(\"aaa\")  \n0  ",
      "hi": "`int minRoundsToSameChar(const char* s)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?",
      "hu": "Írj egy CPP függvényt `int minRoundsToSameChar(const char* s)` a következő probléma megoldására:  \nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldák:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9942730888540021",
      "hy": "0.9943710136318523",
      "bn": "0.9788367274222568",
      "bg": "0.9963177899963752",
      "zh": "0.9883755542106952",
      "fr": "0.9888620000138497",
      "de": "0.9813734360184534",
      "ha": "0.988043841474367",
      "hi": "0.8519224413511581",
      "hu": "0.9884275953705264"
    },
    "level": "middle",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund ju mund të ndryshoni një nga karakteret në një karakter tjetër. Pyetja është: cila është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nShembuj:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում կարող եք փոխել\nմեկ նիշը մեկ այլ նիշով: Հարցն այն է՝ ինչքա՞ն է նվազագույն\nփուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն նիշից:\n\nՕրինակներ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "bn": "প্রদত্ত একটি স্ট্রিং যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণসমূহ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nПримери:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n\n示例：\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nExemples :\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "de": "Angenommen, ein String besteht aus Kleinbuchstaben des englischen Alphabets. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen zusammengesetzt zu machen?\n\nBeispiele:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "ha": "An ba da wata igiyar rubutu da ke kunshe da ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi daban. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar rubutu ta ƙunshi harafi ɗaya?\n\nMisalai:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldák:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9941958216357796",
      "hy": "0.9594033268329465",
      "bn": "0.9834826920346629",
      "bg": "1",
      "zh": "0.9799317767129021",
      "fr": "0.969130852483368",
      "de": "0.9376000671675089",
      "ha": "0.9490989785559996",
      "hi": "0.9486375601808555",
      "hu": "0.9839153090045568"
    }
  },
  {
    "task_id": "CPP/32",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\n * the year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\n * immediately following the occurrence of event i.\n * Example usage:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjejmë\n * vitin Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin\n * menjëherë pas ndodhjes së ngjarjes i.\n * Shembull përdorimi:\n *     apocalypseYear(6, {3,2,4,5,9,18}) kthen 36\n */\nint apocalypseYear(int n, int signs[])",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնելն է\n * Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը։ Իրադարձություն i+1-ի համար հաշվարկը սկսվում է միայն այն տարում,\n * որը անմիջապես հաջորդում է իրադարձություն i-ի տեղի ունենալուն։\n * Օրինակ օգտագործում:\n *     apocalypseYear(6, {3,2,4,5,9,18}) վերադարձնում է 36\n */\nint apocalypseYear(int n, int signs[])",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * nটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, কাজটি হল n-তম ঘটনা যখন ঘটে সেই বছর Y_n খুঁজে বের করা।\n * ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর থেকে শুরু হয়।\n * উদাহরণ ব্যবহার:\n *     apocalypseYear(6, {3,2,4,5,9,18}) 36 প্রদান করে\n */\nint apocalypseYear(int n, int signs[])",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери\n * годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва само в годината\n * непосредствено след настъпването на събитие i.\n * Пример за използване:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。\n * 事件 i+1 的倒计时仅在事件 i 发生后的年份开始。\n * 示例用法：\n *     apocalypseYear(6, {3,2,4,5,9,18}) 返回 36\n */\nint apocalypseYear(int n, int signs[])",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver\n * l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année\n * suivant immédiatement l'occurrence de l'événement i.\n * Exemple d'utilisation :\n *     apocalypseYear(6, {3,2,4,5,9,18}) renvoie 36\n */\nint apocalypseYear(int n, int signs[])",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin,\n * das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für das Ereignis i+1 beginnt erst im Jahr\n * unmittelbar nach dem Eintreten des Ereignisses i.\n * Beispielverwendung:\n *     apocalypseYear(6, {3,2,4,5,9,18}) gibt 36 zurück\n */\nint apocalypseYear(int n, int signs[])",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da jerin abubuwan n, kowanne yana faruwa da tsawon lokaci na a_i shekaru, aikin shine a gano\n * shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar\n * nan take bayan faruwar abin i.\n * Misalin amfani:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * n घटनाओं के अनुक्रम को दिया गया है, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, कार्य यह है कि\n * वर्ष Y_n का पता लगाएं जब n-वीं घटना होती है। घटना i+1 के लिए उलटी गिनती केवल उसी वर्ष में शुरू होती है\n * जब घटना i होती है।\n * उदाहरण उपयोग:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n eseményből álló sorozat, amelyek mindegyike a_i évenként fordul elő, a feladat az,\n * hogy megtaláljuk az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1-edik esemény\n * visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődik.\n * Példa használat:\n *     apocalypseYear(6, {3,2,4,5,9,18}) visszaadja 36\n */\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "sq": "0.9961163787900059",
      "hy": "0.9666153973379422",
      "bn": "0.9484057585261878",
      "bg": "0.9981604840412359",
      "zh": "0.9567379057498393",
      "fr": "0.9890012399109551",
      "de": "0.9909503998400505",
      "ha": "0.9691956059875854",
      "hi": "0.9681490225099125",
      "hu": "0.9602272456534792"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}",
    "instruction": {
      "en": "Write a CPP function `int apocalypseYear(int n, int signs[])` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "sq": "Shkruani një funksion CPP `int apocalypseYear(int n, int signs[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjendet\nviti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin\nmenjëherë pas ndodhjes së ngjarjes i.\nShembull përdorimi:\napocalypseYear(6, {3,2,4,5,9,18}) kthen 36",
      "hy": "Գրեք CPP ֆունկցիա `int apocalypseYear(int n, int signs[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրն ունի a_i տարիների պարբերականություն, խնդիրը գտնելն է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը: Իրադարձություն i+1-ի հետհաշվարկը սկսվում է միայն i իրադարձության տեղի ունենալուց անմիջապես հետո:\nՕրինակ օգտագործում:\napocalypseYear(6, {3,2,4,5,9,18}) վերադարձնում է 36",
      "bn": "একটি CPP ফাংশন `int apocalypseYear(int n, int signs[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nnটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, কাজটি হল Y_n বছরটি খুঁজে বের করা যখন n-তম ঘটনা ঘটে। ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর থেকে শুরু হয়।\nউদাহরণ ব্যবহার:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "bg": "Напишете CPP функция `int apocalypseYear(int n, int signs[])`, за да решите следния проблем: Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва само в годината непосредствено след настъпването на събитие i. Пример за използване: apocalypseYear(6, {3,2,4,5,9,18}) връща 36",
      "zh": "编写一个 CPP 函数 `int apocalypseYear(int n, int signs[])` 来解决以下问题：  \n给定一个包含 n 个事件的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。事件 i+1 的倒计时仅在事件 i 发生后的年份开始。  \n示例用法：  \napocalypseYear(6, {3,2,4,5,9,18}) 返回 36",
      "fr": "Écrire une fonction CPP `int apocalypseYear(int n, int signs[])` pour résoudre le problème suivant :  \nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année suivant immédiatement la survenue de l'événement i.  \nExemple d'utilisation :  \napocalypseYear(6, {3,2,4,5,9,18}) retourne 36",
      "de": "Schreiben Sie eine CPP-Funktion `int apocalypseYear(int n, int signs[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten. Die Aufgabe besteht darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für das Ereignis i+1 beginnt erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i.\nBeispielverwendung:\napocalypseYear(6, {3,2,4,5,9,18}) gibt 36 zurück.",
      "ha": "Rubuta aikin CPP `int apocalypseYear(int n, int signs[])` don magance matsalar mai zuwa:\nAn ba da jerin abubuwan n, kowannensu yana faruwa tare da maimaita shekaru a_i, aikin shine gano shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar da ke biye da faruwar abin i.\nMisalin amfani:\napocalypseYear(6, {3,2,4,5,9,18}) yana dawowa 36",
      "hi": "`int apocalypseYear(int n, int signs[])` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, कार्य यह है कि वर्ष Y_n का पता लगाएं जब n-वां घटना होती है। घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद वाले वर्ष में शुरू होती है।\nउदाहरण उपयोग:\napocalypseYear(6, {3,2,4,5,9,18}) 36 लौटाता है",
      "hu": "Írj egy CPP függvényt `int apocalypseYear(int n, int signs[])` a következő probléma megoldására:\nAdott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évek periodicitással fordul elő, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik. Az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődik.\nPélda használat:\napocalypseYear(6, {3,2,4,5,9,18}) visszaadja a 36-ot"
    },
    "instruction_bertscore": {
      "sq": "0.9982016005301101",
      "hy": "0.9710905398226582",
      "bn": "0.9497749177426613",
      "bg": "0.9933003958780743",
      "zh": "0.9645180591445948",
      "fr": "0.98987163824065",
      "de": "0.9776238903156578",
      "ha": "0.9660568487064721",
      "hi": "0.9484135051110482",
      "hu": "0.9772673487817002"
    },
    "level": "easy",
    "test": "int main() {\n    int arr1[] = {3,2,4,5,9,18};\n    assert(apocalypseYear(6, arr1) == 36);\n    int arr2[] = {1, 2,3,4,5};\n    assert(apocalypseYear(5, arr2) == 5);\n    int arr3[] = {1,1,1,1,1};\n    assert(apocalypseYear(5, arr3) == 5);\n    int arr4[] = {50,30,711,200,503,1006};\n    assert(apocalypseYear(6, arr4) == 2012);\n    int arr5[] = {1, 2};\n    assert(apocalypseYear(2, arr5) == 2);\n    int arr6[] = {3, 1, 2};\n    assert(apocalypseYear(3, arr6) == 6);\n    int arr7[] = {2, 3, 4};\n    assert(apocalypseYear(3, arr7) == 4);\n    int arr8[] = {1, 2, 3, 4};\n    assert(apocalypseYear(4, arr8) == 4);\n    int arr9[] = {5, 7, 11, 13};\n    assert(apocalypseYear(4, arr9) == 13);\n    int arr10[] = {2, 2, 2, 2, 2};\n    assert(apocalypseYear(5, arr10) == 10);\n    int arr11[] = {6, 10, 15};\n    assert(apocalypseYear(3, arr11) == 15);\n    int arr12[] = {4, 6, 14};\n    assert(apocalypseYear(3, arr12) == 14);\n    int arr13[] = {50, 30, 711, 200};\n    assert(apocalypseYear(4, arr13) == 800);\n    int arr14[] = {1, 1, 1, 1, 1, 1};\n    assert(apocalypseYear(6, arr14) == 6);\n    int arr15[] = {1000000, 999999};\n    assert(apocalypseYear(2, arr15) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periudhë prej a_i vitesh, detyra është të gjendet viti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\nShembull përdorimi:\napocalypseYear(6, {3,2,4,5,9,18}) kthen 36",
      "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրն է գտնել Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը: i+1 իրադարձության հաշվարկը սկսվում է միայն այն տարում, որը անմիջապես հաջորդում է i իրադարձության տեղի ունենալուն:\nՕրինակ օգտագործում:\napocalypseYear(6, {3,2,4,5,9,18}) վերադարձնում է 36",
      "bn": "প্রদত্ত nটি ঘটনার একটি ক্রমে, প্রতিটি ঘটনা a_i বছর পরপর ঘটে, কাজটি হল n-তম ঘটনা যখন ঘটে সেই বছর Y_n খুঁজে বের করা। ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছর থেকে শুরু হয়।\n\nউদাহরণ ব্যবহার:\napocalypseYear(6, {3,2,4,5,9,18}) 36 প্রদান করে",
      "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва едва в годината, непосредствено следваща събитието i.\nПример за използване:\napocalypseYear(6, {3,2,4,5,9,18}) връща 36",
      "zh": "给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。事件 i+1 的倒计时仅在事件 i 发生后的年份开始。\n\n示例用法：\napocalypseYear(6, {3,2,4,5,9,18}) 返回 36",
      "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année suivant immédiatement l'occurrence de l'événement i.\nExemple d'utilisation :\napocalypseYear(6, {3,2,4,5,9,18}) retourne 36",
      "de": "Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für Ereignis i+1 beginnt erst im Jahr unmittelbar nach dem Auftreten von Ereignis i.\n\nBeispielverwendung:\napocalypseYear(6, {3,2,4,5,9,18}) gibt 36 zurück",
      "ha": "An ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawar a_i shekaru, aikin shine nemo shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar da ke biye da faruwar abin i.\n\nMisalin amfani:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "hi": "n घटनाओं के अनुक्रम को देखते हुए, जिनमें से प्रत्येक a_i वर्षों की आवधिकता के साथ होता है, कार्य यह है कि n-वीं घटना के घटित होने वाले वर्ष Y_n को खोजा जाए। घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में शुरू होती है। \n\nउदाहरण उपयोग:\napocalypseYear(6, {3,2,4,5,9,18}) 36 लौटाता है",
      "hu": "Egy n eseményből álló sorozat esetén, ahol mindegyik esemény a_i évek periodicitással következik be, a feladat megtalálni az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődik.\nPélda használat:\napocalypseYear(6, {3,2,4,5,9,18}) visszaadja 36"
    },
    "docstring_bertscore": {
      "sq": "0.9874213338602036",
      "hy": "0.9614237950688334",
      "bn": "0.9415144760865634",
      "bg": "0.9864299696284585",
      "zh": "0.9466713180389912",
      "fr": "0.9866371411158779",
      "de": "0.9870620115009116",
      "ha": "0.9545533688192176",
      "hi": "0.959400744637993",
      "hu": "0.9586346272583415"
    }
  },
  {
    "task_id": "CPP/33",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    newModuloFactorial(3, 7) returns 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".\n * Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.\n * Nëse x është shumëfish i y, ndaj x me y vazhdimisht derisa x të mos jetë më\n * shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Atëherë rezultati është x' % y.\n * Për shembull:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Duke pasur një numër të thjeshtë p, ju duhet të trajtoni disa pyetje ku ju jepet\n * një numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.\n * Shembull:\n *    newModuloFactorial(3, 7) kthen 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Այս խնդիրը ներկայացնում է հատուկ մնացորդային գործողություն, որը նշված է \"⊕\" նշանով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n * Եթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս\n * y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշեք որպես x': Ապա արդյունքը x' % y է:\n * Օրինակ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4:\n * Տրված է p պարզ թիվը, դուք պետք է մշակեք մի քանի հարցումներ, որտեղ ձեզ տրված է\n * n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p: Այստեղ, n! նշանակում է n-ի ֆակտորիալը:\n * Օրինակ:\n *    newModuloFactorial(3, 7) վերադարձնում է 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" দ্বারা চিহ্নিত।\n * যখন x ⊕ y গণনা করা হয়, যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y।\n * যদি x, y এর গুণিতক হয়, তাহলে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে,\n * এই চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' % y।\n * উদাহরণস্বরূপ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হবে\n * এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\n * উদাহরণ:\n *    newModuloFactorial(3, 7) 6 প্রদান করে\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Този проблем въвежда персонализирана операция за модуло, обозначена с \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е x % y.\n * Ако x е кратно на y, разделете x на y многократно, докато x вече не е\n * кратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.\n * Например:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Дадено е просто число p, трябва да обработите няколко заявки, където ви е дадено\n * цяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.\n * Пример:\n *    newModuloFactorial(3, 7) връща 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 这个问题引入了一个自定义的取模运算，记作“⊕”。\n * 当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。\n * 如果 x 是 y 的倍数，反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。\n * 例如：\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4。\n * 给定一个质数 p，你需要处理若干查询，每个查询给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。\n * 示例：\n *    newModuloFactorial(3, 7) 返回 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Ce problème introduit une opération modulo personnalisée, notée par \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\n * Si x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un\n * multiple de y, en notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\n * Par exemple :\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Étant donné un nombre premier p, vous devez traiter plusieurs requêtes où un\n * entier n est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\n * Exemple :\n *    newModuloFactorial(3, 7) retourne 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, die durch \"⊕\" bezeichnet wird.\n * Beim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n * Wenn x ein Vielfaches von y ist, teile x wiederholt durch y, bis x kein\n * Vielfaches von y mehr ist, und bezeichne diesen Endwert als x'. Dann ist das Ergebnis x' % y.\n * Zum Beispiel:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Gegeben ist eine Primzahl p, Sie müssen mehrere Abfragen bearbeiten, bei denen Ihnen\n * eine ganze Zahl n gegeben ist und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.\n * Beispiel:\n *    newModuloFactorial(3, 7) gibt 6 zurück\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Wannan matsalar tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba shi ne sau na y ba, sakamakon shi ne x % y.\n * Idan x sau na y ne, raba x da y akai-akai har sai x ba shi ne sau na y ba,\n * ana nuna wannan ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne x' % y.\n * Alal misali:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * An ba da lamba mai lamba p, kuna buƙatar sarrafa tambayoyi da yawa inda aka ba ku\n * wani cikakken lamba n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.\n * Misali:\n *    newModuloFactorial(3, 7) yana dawowa 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह समस्या एक कस्टम माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा दर्शाया गया है।\n * जब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x % y होता है।\n * यदि x, y का गुणज है, तो x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे,\n * इस अंतिम मान को x' के रूप में दर्शाया जाता है। फिर परिणाम x' % y होता है।\n * उदाहरण के लिए:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, आपको कई प्रश्नों को संभालना होगा जहाँ आपको एक पूर्णांक n दिया जाता है\n * और आपको n! ⊕ p की गणना करनी होगी। यहाँ, n! n का फैक्टरियल है।\n * उदाहरण:\n *    newModuloFactorial(3, 7) 6 लौटाता है\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.\n * Amikor x ⊕ y-t számítunk, ha x nem osztható maradék nélkül y-nal, az eredmény x % y.\n * Ha x osztható maradék nélkül y-nal, akkor osszuk el x-et y-nal ismételten, amíg x már nem\n * osztható maradék nélkül y-nal, és jelöljük ezt a végső értéket x'-vel. Ekkor az eredmény x' % y.\n * Például:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Adott egy prímszám p, több lekérdezést kell kezelnie, ahol egy egész számot n kap, és ki kell számítania n! ⊕ p-t. Itt n! az n faktoriálisa.\n * Példa:\n *    newModuloFactorial(3, 7) visszaadja 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "sq": "0.989160144215783",
      "hy": "0.9547188279266197",
      "bn": "0.9828490611191616",
      "bg": "0.9906645707217413",
      "zh": "0.9782322951727677",
      "fr": "0.9875985121600868",
      "de": "0.9889523768372206",
      "ha": "0.9794777076618564",
      "hi": "0.9783417405127178",
      "hu": "0.9434592661472759"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` to solve the following problem:\nThis problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   newModuloFactorial(3, 7) returns 6\n",
      "sq": "Shkruani një funksion CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` për të zgjidhur problemin në vijim:\nKy problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".\nKur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.\nNëse x është shumëfish i y, ndani x me y vazhdimisht derisa x të mos jetë më\nshumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Pastaj rezultati është x' % y.\nPër shembull:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nDuke pasur një numër të plotë p, ju duhet të trajtoni disa kërkesa ku ju jepet\nnjë numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.\nShembull:\n   newModuloFactorial(3, 7) kthen 6",
      "hy": "Գրեք CPP ֆունկցիա `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)`՝ հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներկայացնում է հատուկ մոդուլո գործողություն, որը նշվում է \"⊕\" նշանով:\nԵրբ հաշվարկվում է x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\nԵթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա բազմիցս, մինչև x-ը այլևս\nչլինի y-ի բազմապատիկ, և այս վերջնական արժեքը նշեք որպես x': Ապա արդյունքը x' % y է:\nՕրինակ՝\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4:\nՏրված է պարզ թիվ p, և դուք պետք է մշակեք մի քանի հարցումներ, որտեղ տրված է\nամբողջ թիվ n, և դուք պետք է հաշվարկեք n! ⊕ p: Այստեղ n! նշում է n-ի ֆակտորիալը:\nՕրինակ՝\n   newModuloFactorial(3, 7) վերադարձնում է 6:",
      "bn": "একটি CPP ফাংশন `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" দ্বারা চিহ্নিত।\nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y।\nযদি x y এর গুণিতক হয়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, এই চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' % y।\nউদাহরণস্বরূপ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\nউদাহরণ:\n   newModuloFactorial(3, 7) ফলাফল দেয় 6",
      "bg": "Напишете функция на C++ `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)`, за да решите следния проблем:\nТози проблем въвежда персонализирана операция за модуло, обозначена с \"⊕\".\nКогато изчислявате x ⊕ y, ако x не е кратно на y, резултатът е x % y.\nАко x е кратно на y, разделете x на y многократно, докато x вече не е\nкратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.\nНапример:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nДадено е просто число p, трябва да обработите няколко заявки, където ви е дадено\nцяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.\nПример:\n   newModuloFactorial(3, 7) връща 6",
      "zh": "编写一个 CPP 函数 `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` 来解决以下问题：\n此问题引入了一个自定义模运算，记为 \"⊕\"。\n当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。\n如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。\n例如：\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4。\n给定一个素数 p，你需要处理若干查询，其中给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。\n示例：\n   newModuloFactorial(3, 7) 返回 6",
      "fr": "Écrire une fonction CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` pour résoudre le problème suivant :\nCe problème introduit une opération modulo personnalisée, notée par \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\nSi x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\nPar exemple :\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nÉtant donné un nombre premier p, vous devez traiter plusieurs requêtes où un entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\nExemple :\n   newModuloFactorial(3, 7) retourne 6",
      "de": "Schreiben Sie eine CPP-Funktion `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)`, um das folgende Problem zu lösen:\nDieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".\nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\nWenn x ein Vielfaches von y ist, teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen Sie diesen Endwert als x'. Dann ist das Ergebnis x' % y.\nZum Beispiel:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine ganze Zahl n gegeben wird und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.\nBeispiel:\n   newModuloFactorial(3, 7) gibt 6 zurück",
      "ha": "Rubuta aikin CPP `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\".\nLokacin da ake lissafin x ⊕ y, idan x ba ya rabo da y, sakamakon shi ne x % y.\nIdan x ya rabo da y, raba x da y akai-akai har sai x ba ya rabo da y,\nsannan a nuna wannan ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne x' % y.\nMisali:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nAn ba da lambar farko p, kuna buƙatar magance tambayoyi da yawa inda aka ba ku\nwani adadi n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.\nMisali:\n   newModuloFactorial(3, 7) yana dawowa 6",
      "hi": "एक CPP फ़ंक्शन `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह समस्या एक कस्टम मॉड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा दर्शाया गया है।\nजब x ⊕ y की गणना की जाती है, अगर x y का गुणज नहीं है, तो परिणाम x % y होता है।\nयदि x y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे, इस अंतिम मान को x' के रूप में दर्शाया जाता है। फिर परिणाम x' % y होता है।\nउदाहरण के लिए:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, आपको कई क्वेरीज़ को संभालना है जहाँ आपको एक पूर्णांक n दिया जाता है और आपको n! ⊕ p की गणना करनी होती है। यहाँ, n! n का फैक्टोरियल है।\nउदाहरण:\n   newModuloFactorial(3, 7) 6 लौटाता है",
      "hu": "Írj egy CPP függvényt `unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)` a következő probléma megoldására:\nEz a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.\nAmikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x % y.\nHa x osztható y-nal, oszd el x-et y-nal ismételten, amíg x már nem osztható\ny-nal, ezt a végső értéket jelölve x'-ként. Ekkor az eredmény x' % y.\nPéldául:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nAdott egy prímszám p, több lekérdezést kell kezelni, ahol egy\negész számot n kapsz, és ki kell számítanod n! ⊕ p-t. Itt n! az n faktoriálisa.\nPélda:\n   newModuloFactorial(3, 7) visszaadja 6"
    },
    "instruction_bertscore": {
      "sq": "0.9837911650164101",
      "hy": "0.9471402843686145",
      "bn": "0.9819198681966803",
      "bg": "0.98426906971318",
      "zh": "0.9857214550593071",
      "fr": "0.9872278678690757",
      "de": "0.991516695056381",
      "ha": "0.9556456372845284",
      "hi": "0.9844263849749596",
      "hu": "0.9651538749942875"
    },
    "level": "easy",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "en": "This problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   newModuloFactorial(3, 7) returns 6\n",
      "sq": "Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".  \nKur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.  \nNëse x është një shumëfish i y, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më një shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Pastaj rezultati është x' % y.  \nPër shembull:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDuke pasur një numër të thjeshtë p, ju duhet të trajtoni disa pyetje ku ju jepet një numër i plotë n dhe ju duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.  \nShembull:  \n   newModuloFactorial(3, 7) kthen 6  ",
      "hy": "Այս խնդիրն առաջարկում է հատուկ մնացորդային գործողություն, որը նշվում է \"⊕\" նշանով։  \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է։  \nԵթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշեք որպես x'։ Այնուհետև արդյունքը x' % y է։  \nՕրինակ՝  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4։  \nՏրված է p պարզ թիվը, դուք պետք է մշակեք մի քանի հարցումներ, որտեղ ձեզ տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p։ Այստեղ, n! նշանակում է n-ի ֆակտորիալը։  \nՕրինակ՝  \n   newModuloFactorial(3, 7) վերադարձնում է 6  ",
      "bn": "এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" দ্বারা চিহ্নিত। \nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y। \nযদি x y এর গুণিতক হয়, তাহলে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, এই চূড়ান্ত মানটিকে x' দ্বারা চিহ্নিত করুন। তারপর ফলাফল হয় x' % y। \nউদাহরণস্বরূপ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\nউদাহরণ:\n   newModuloFactorial(3, 7) 6 প্রদান করে।",
      "bg": "Този проблем въвежда персонализирана операция модуло, обозначена с \"⊕\".  \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е x % y.  \nАко x е кратно на y, разделете x на y многократно, докато x вече не е  \nкратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.  \nНапример:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nДадено е просто число p, трябва да обработите няколко заявки, при които ви е дадено  \nцяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.  \nПример:  \n   newModuloFactorial(3, 7) връща 6  ",
      "zh": "这个问题介绍了一种自定义的模运算，用“⊕”表示。  \n在计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。  \n如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。  \n例如：  \n- 4⊕5=4，  \n- 20⊕5=4，  \n- 100⊕5=4。  \n给定一个质数 p，你需要处理几个查询，每个查询给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。  \n例子：  \n   newModuloFactorial(3, 7) 返回 6  ",
      "fr": "Ce problème introduit une opération modulo personnalisée, notée par \"⊕\".\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\nSi x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\nPar exemple :\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nÉtant donné un nombre premier p, vous devez traiter plusieurs requêtes où un entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\nExemple :\n   newModuloFactorial(3, 7) retourne 6",
      "de": "Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".  \nBei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.  \nWenn x ein Vielfaches von y ist, teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen Sie diesen Endwert als x'. Dann ist das Ergebnis x' % y.  \nZum Beispiel:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nGegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine ganze Zahl n gegeben wird und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.  \nBeispiel:  \n   newModuloFactorial(3, 7) gibt 6 zurück  ",
      "ha": "Wannan matsala tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\".  \nLokacin da ake lissafin x ⊕ y, idan x ba ya rabo da y, sakamakon shi ne x % y.  \nIdan x yana rabo da y, raba x da y akai-akai har sai x ya daina zama rabo da y, ana nuna wannan ƙimar ƙarshe a matsayin x'. Sannan sakamakon shi ne x' % y.  \nMisali:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nAn ba da lambar farko p, kuna buƙatar sarrafa tambayoyi da yawa inda aka ba ku  \nwani cikakken lamba n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.  \nMisali:  \n   newModuloFactorial(3, 7) yana dawowa 6  ",
      "hi": "यह समस्या एक कस्टम मोड्यूलो ऑपरेशन का परिचय देती है, जिसे \"⊕\" द्वारा निरूपित किया गया है।  \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x % y होता है।  \nयदि x, y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे, इस अंतिम मान को x' के रूप में निरूपित करें। फिर परिणाम x' % y होता है।  \nउदाहरण के लिए:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4।  \nदिए गए एक अभाज्य संख्या p के लिए, आपको कई क्वेरीज़ को संभालना है जहाँ आपको एक पूर्णांक n दिया जाता है और आपको n! ⊕ p की गणना करनी होती है। यहाँ, n! n का फैक्टोरियल है।  \nउदाहरण:  \n   newModuloFactorial(3, 7) 6 लौटाता है।  ",
      "hu": "Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.  \nAmikor az x ⊕ y értéket számítjuk, ha x nem osztható y-nal, az eredmény x % y.  \nHa x osztható y-nal, osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, ezt a végső értéket jelöljük x'-ként. Ezután az eredmény x' % y.  \nPéldául:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nAdott egy prímszám p, több lekérdezést kell kezelnie, ahol egy n egész számot kap, és ki kell számítania n! ⊕ p értékét. Itt n! az n faktoriálisa.  \nPélda:  \n   newModuloFactorial(3, 7) visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9906888036282275",
      "hy": "0.9585815929466052",
      "bn": "0.9798972150266021",
      "bg": "0.9906204747771515",
      "zh": "0.9791030907632245",
      "fr": "0.9843101862020541",
      "de": "0.9883249034635313",
      "ha": "0.963619852561555",
      "hi": "0.9813061003192826",
      "hu": "0.9515453103288253"
    }
  },
  {
    "task_id": "CPP/34",
    "prompt": {
      "en": "#include <cstdio>\n#include <cassert>\n/**\n * You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *\n * Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "sq": "#include <cstdio>\n#include <cassert>\n/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x,\n * me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n *\n * Shembuj:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "hy": "#include <cstdio>\n#include <cassert>\n/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը x-ով,\n * արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n *\n * Օրինակներ:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "bn": "#include <cstdio>\n#include <cassert>\n/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি\n * তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন,\n * (j - i + 1) খরচে। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।\n *\n * উদাহরণ:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "bg": "#include <cstdio>\n#include <cassert>\n/**\n * Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x,\n * на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n *\n * Примери:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "zh": "#include <cstdio>\n#include <cassert>\n/**\n * 给定一个由 n 个整数组成的数组 a。你可以执行最多一次操作，选择三个整数 i, j, x (1 <= i <= j <= n)，\n * 并将所有从 a[i] 到 a[j] 的元素替换为 x，代价为 (j - i + 1)。找到使数组中所有元素相等的最小代价。\n *\n * 例子:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "fr": "#include <cstdio>\n#include <cassert>\n/**\n * Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous\n * sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x,\n * à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n *\n * Exemples :\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "de": "#include <cstdio>\n#include <cassert>\n/**\n * Sie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie\n * drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen,\n * zu Kosten von (j - i + 1). Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n *\n * Beispiele:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "ha": "#include <cstdio>\n#include <cassert>\n/**\n * An ba ku wani jerin a na lambobin n. Kuna iya aiwatar da akalla aiki guda ɗaya inda za ku\n * zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x,\n * a farashin (j - i + 1). Nemo mafi ƙarancin kuɗi don sanya duk abubuwan cikin jerin su zama daidai.\n *\n * Misalai:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "hi": "#include <cstdio>\n#include <cassert>\n/**\n * आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप\n * तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं,\n * जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n *\n * उदाहरण:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "hu": "#include <cstdio>\n#include <cassert>\n/**\n * Adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-szel helyettesíted, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n *\n * Példák:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "sq": "0.9961608719953576",
      "hy": "0.9735593168285409",
      "bn": "0.9923664358264482",
      "bg": "0.9943195683631643",
      "zh": "0.9728408707403376",
      "fr": "0.9939262802087152",
      "de": "0.989143062003014",
      "ha": "0.9739168515144037",
      "hi": "0.9944180890321576",
      "hu": "0.9683011733817853"
    },
    "canonical_solution": "{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "Write a CPP function `int makeEqualAgain(int n, int a[])` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1\n",
      "sq": "Shkruani një funksion CPP `int makeEqualAgain(int n, int a[])` për të zgjidhur problemin në vijim:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n\nShembuj:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hy": "Գրեք CPP ֆունկցիա `int makeEqualAgain(int n, int a[])` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1): Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն:\n\nՕրինակներ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "bn": "একটি CPP ফাংশন `int makeEqualAgain(int n, int a[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)। অ্যারের সমস্ত উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের করুন।\n\nউদাহরণসমূহ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "bg": "Напишете CPP функция `int makeEqualAgain(int n, int a[])`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n\nПримери:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "zh": "编写一个 CPP 函数 `int makeEqualAgain(int n, int a[])` 来解决以下问题：\n给定一个包含 n 个整数的数组 a。你可以最多执行一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将所有从 a[i] 到 a[j] 的元素替换为 x，代价为 (j - i + 1)。找出使数组中所有元素相等的最小代价。\n\n示例:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "fr": "Écrire une fonction CPP `int makeEqualAgain(int n, int a[])` pour résoudre le problème suivant :  \nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n\nExemples :\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "de": "Schreiben Sie eine CPP-Funktion `int makeEqualAgain(int n, int a[])`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu einem Kostenaufwand von (j - i + 1). Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n\nBeispiele:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "ha": "Rubuta aikin CPP `int makeEqualAgain(int n, int a[])` don warware matsalar mai zuwa:\nAn ba ku wani tsari a na lambobi n. Kuna iya aiwatar da aƙalla aiki ɗaya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin duk abubuwan daga a[i] zuwa a[j] da x, a farashin (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n\nMisalai:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hi": "एक CPP फ़ंक्शन `int makeEqualAgain(int n, int a[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।\n\nउदाहरण:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hu": "Írj egy CPP függvényt `int makeEqualAgain(int n, int a[])` a következő probléma megoldására:\nAdott egy a tömb n egész számmal. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n\nPéldák:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1"
    },
    "instruction_bertscore": {
      "sq": "0.9936323072447836",
      "hy": "0.9714423142274711",
      "bn": "0.9959735635460418",
      "bg": "0.9989289849854599",
      "zh": "0.9846806318626843",
      "fr": "0.9982250389150722",
      "de": "0.988891993201386",
      "ha": "0.9789068439467621",
      "hi": "0.9952042680802936",
      "hu": "0.9796604476124084"
    },
    "level": "middle",
    "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1\n",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjithë elementet në varg të barabartë.\n\nShembuj:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hy": "Դուք տրված եք n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք բոլոր տարրերը a[i]-ից մինչև a[j] x-ով, արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n\nՕրինակներ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n\nউদাহরণ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена от (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n\nПримери:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "zh": "您有一个由 n 个整数组成的数组 a。您最多可以执行一次操作，在该操作中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。找出使数组中所有元素相等的最小代价。\n\n示例：\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "fr": "Vous disposez d'un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n\nExemples :\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu einem Kostenaufwand von (j - i + 1). Finde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n\nBeispiele:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "ha": "An ba ku wani tsari a na lambobi n. Kuna iya aiwatar da akalla aiki ɗaya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a farashin (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan cikin tsari su zama daidai.\n\nMisalai:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hi": "आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n\nउदाहरण:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hu": "Meg van adva egy `a` tömb `n` egész számmal. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot `i`, `j`, `x` (1 <= i <= j <= n), és az `a[i]`-től `a[j]`-ig terjedő összes elemet `x`-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n\nPéldák:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1"
    },
    "docstring_bertscore": {
      "sq": "0.9962148994589992",
      "hy": "0.959794032792442",
      "bn": "0.9964109476450806",
      "bg": "0.9849763925000452",
      "zh": "0.9802529620390356",
      "fr": "0.9929313406301115",
      "de": "0.9901975906959283",
      "ha": "0.975649702958552",
      "hi": "0.9969532085853059",
      "hu": "0.92834905580119"
    }
  },
  {
    "task_id": "CPP/35",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner\n * of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile\n * to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "sq": "#include <cassert>\n#include <iostream>\n/**\n * Duke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin\n * të një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan për të lëvizur gurët nga grumbulli më i majtë jo bosh\n * te grumbulli ngjitur në të djathtë. Ai që mund të lëvizë gurët vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përkryer, gjeni fituesin.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "hy": "#include <cassert>\n#include <iostream>\n/**\n * Տրված է N քանակությամբ քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուրում կա քարերի դրական քանակություն, որոշել խաղի հաղթողին,\n * որը խաղում են Չարլին և Դենը: Չարլին սկսում է, հերթափոխով Դենի հետ տեղափոխելով քարերը ձախից աջ հարակից կույտ: Այն, ով կարող է տեղափոխել քարերը միայն վերջին կույտում, պարտվում է:\n * Ենթադրելով կատարյալ խաղ, գտնել հաղթողին:\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "bn": "#include <cassert>\n#include <iostream>\n/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত N পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, একটি গেমের বিজয়ী নির্ধারণ করুন\n * যা চার্লি এবং ড্যান দ্বারা খেলা হয়। চার্লি শুরু করে, ড্যানের সাথে পালাক্রমে বাম দিকের প্রথম খালি না হওয়া স্তূপ থেকে\n * ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নিয়ে যায়। যে ব্যক্তি শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার অনুমান করে, বিজয়ী খুঁজে বের করুন।\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "bg": "#include <cassert>\n#include <iostream>\n/**\n * Дадена е последователност от N купчини с камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя\n * в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да преместват камъни от най-лявата непразна купчина\n * към съседната дясна купчина. Този, който може да премести камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "zh": "#include <cassert>\n#include <iostream>\n/**\n * 给定一个编号从1到N的石堆序列，每堆包含正数个石头，确定Charlie和Dan玩的游戏的赢家。\n * Charlie开始，与Dan轮流从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。\n * 假设完美游戏，找出赢家。\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "fr": "#include <cassert>\n#include <iostream>\n/**\n * Étant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres, déterminer le gagnant\n * d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres de la pile la plus à gauche non vide\n * vers la pile adjacente à droite. Celui qui ne peut déplacer des pierres que dans la dernière pile perd. En supposant un jeu parfait, trouver le gagnant.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "de": "#include <cassert>\n#include <iostream>\n/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält,\n * bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab,\n * indem sie Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen. Derjenige, der nur noch Steine im\n * letzten Haufen bewegen kann, verliert. Angenommen, beide spielen perfekt, finden Sie den Gewinner.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "ha": "#include <cassert>\n#include <iostream>\n/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadi mai kyau na duwatsu, tantance wanda ya ci\n * wasa da Charlie da Dan suka buga. Charlie yana farawa, suna juyawa da Dan suna motsa duwatsu daga mafi hagu da ba komai ba\n * zuwa tarin da ke kusa da dama. Wanda zai iya motsa duwatsu a cikin tarin karshe kawai ya yi rashin nasara. Ana tsammanin wasa mai kyau, gano wanda ya ci.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "hi": "#include <cassert>\n#include <iostream>\n/**\n * दिए गए पत्थरों के N ढेरों की एक अनुक्रमणिका, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, \n * चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं \n * सबसे पहले गैर-खाली ढेर से पत्थरों को दाएं सटे ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। \n * पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "hu": "#include <cassert>\n#include <iostream>\n/**\n * Adott egy N halomból álló kőhalmaz, amelyeket 1-től N-ig számoztak, mindegyik halom pozitív számú követ tartalmaz. Határozza meg a győztest\n * egy játékban, amelyet Charlie és Dan játszik. Charlie kezd, felváltva Dan-nel, köveket mozgatva a bal szélső nem üres halomból\n * a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve, találja meg a győztest.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])"
    },
    "prompt_bertscore": {
      "sq": "0.9853448518568649",
      "hy": "0.9615433705582164",
      "bn": "0.9676796589195271",
      "bg": "0.9875935464005609",
      "zh": "0.9398285014123392",
      "fr": "0.9796560777440257",
      "de": "0.9406049475718047",
      "ha": "0.9624566730502148",
      "hi": "0.949705397109299",
      "hu": "0.9428947586043748"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "Write a CPP function `const char* gameWinner(int n, const int piles[])` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"\n",
      "sq": "Shkruani një funksion CPP `const char* gameWinner(int n, const int piles[])` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan duke lëvizur gurë nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hy": "Գրեք CPP ֆունկցիա `const char* gameWinner(int n, const int piles[])` հետևյալ խնդիրը լուծելու համար:\nՈւնենալով N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրում կա քարերի դրական քանակ, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին սկսում է, հերթափոխով Դենի հետ տեղափոխելով քարերը ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "bn": "একটি CPP ফাংশন `const char* gameWinner(int n, const int piles[])` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে: \nএকটি N পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি শুরু করে, ড্যানের সাথে পালাক্রমে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নেয়। যে ব্যক্তি কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার ধরণ ধরে, বিজয়ী নির্ধারণ করুন।\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "bg": "Напишете функция на CPP `const char* gameWinner(int n, const int piles[])`, за да решите следния проблем:  \nДадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни. Определете победителя в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан, премествайки камъни от най-лявата непразна купчина към съседната дясна купчина. Този, който може да премести камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n\n>>> gameWinner(3, {1, 2, 2})  \n\"Dan\"",
      "zh": "编写一个 CPP 函数 `const char* gameWinner(int n, const int piles[])` 来解决以下问题：  \n给定一个由 N 堆石头组成的序列，从 1 到 N 编号，每堆包含一个正数的石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，与 Dan 轮流从最左边的非空堆中移动石头到相邻的右边堆。只能在最后一堆中移动石头的人输掉比赛。在假设完美游戏的情况下，找出获胜者。",
      "fr": "Écrire une fonction CPP `const char* gameWinner(int n, const int piles[])` pour résoudre le problème suivant :  \nÉtant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres, déterminer le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan en déplaçant des pierres de la pile la plus à gauche non vide vers la pile adjacente à droite. Celui qui ne peut déplacer des pierres que dans la dernière pile perd. En supposant un jeu parfait, trouver le gagnant.",
      "de": "Schreiben Sie eine CPP-Funktion `const char* gameWinner(int n, const int piles[])`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab, indem er Steine vom linken, nicht leeren Haufen zum angrenzenden rechten Haufen bewegt. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Bei perfektem Spiel finden Sie den Gewinner.",
      "ha": "Rubuta aikin CPP `const char* gameWinner(int n, const int piles[])` don warware matsalar mai zuwa:  \nAn ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, gano wanda ya lashe wasan da Charlie da Dan suka buga. Charlie yana farawa, yana daukar matakai tare da Dan suna motsa duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa. Wanda zai iya motsa duwatsu kawai a cikin tarin karshe ya rasa. Ana tsammanin wasa mai kyau, gano wanda ya lashe.",
      "hi": "एक CPP फ़ंक्शन `const char* gameWinner(int n, const int piles[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पत्थरों के N ढेरों की एक अनुक्रमिक श्रृंखला, जो 1 से N तक क्रमांकित हैं, प्रत्येक में सकारात्मक संख्या में पत्थर हैं, यह निर्धारित करें कि चार्ली और डैन द्वारा खेले गए खेल का विजेता कौन है। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं सबसे पहले गैर-खाली ढेर से पत्थरों को पास के दाएं ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hu": "Írj egy CPP függvényt `const char* gameWinner(int n, const int piles[])` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozd meg a nyertesét egy játéknak, amelyet Charlie és Dan játszanak. Charlie kezd, felváltva Dan-nel köveket mozgatva a bal szélső nem üres halomból a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve, találd meg a nyertest.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\""
    },
    "instruction_bertscore": {
      "sq": "0.9931138819502825",
      "hy": "0.9894358431846595",
      "bn": "0.9161301092814478",
      "bg": "0.9738499130759949",
      "zh": "0.9163523766778258",
      "fr": "0.9531371342024388",
      "de": "0.9243957153274526",
      "ha": "0.9376215192486607",
      "hi": "0.924107899905333",
      "hu": "0.9797629408890225"
    },
    "level": "middle",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(std::string(gameWinner(3, test1)) == \"Dan\");\n    assert(std::string(gameWinner(5, test2)) == \"Charlie\");\n    assert(std::string(gameWinner(3, test3)) == \"Charlie\");\n    assert(std::string(gameWinner(4, test4)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test5)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test6)) == \"Charlie\");\n    assert(std::string(gameWinner(11, test7)) == \"Dan\");\n    assert(std::string(gameWinner(10, test8)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test9)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test10)) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, const int piles[])",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"\n",
      "sq": "Duke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhë me Dan për të lëvizur gurët nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hy": "Տրված է N քանակությամբ քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուրում կա քարերի դրական քանակ: Պարզեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին սկսում է, հերթով Դենի հետ տեղափոխելով քարերը ձախից ամենահեռու չդատարկ կույտից դեպի հարևան աջ կույտը: Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে। চার্লি এবং ড্যানের মধ্যে একটি খেলা খেলে বিজয়ী নির্ধারণ করুন। চার্লি শুরু করে, ড্যানের সাথে পালাক্রমে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নেয়। যে ব্যক্তি কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার অনুমান করে, বিজয়ী নির্ধারণ করুন।\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да мести камъни от най-лявата непразна купчина към съседната дясна купчина. Този, който може да мести камъни само в последната купчина, губи. Предполага се перфектна игра, намерете победителя.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的获胜者。Charlie开始，与Dan轮流从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。假设完美游戏，找出获胜者。\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Celui qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant un jeu parfait, trouvez le gagnant.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "de": "Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und zieht abwechselnd mit Dan Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, es wird perfekt gespielt, finden Sie den Gewinner.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "ha": "An ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, a tantance wanda zai ci wasa da Charlie da Dan suka buga. Charlie yana farawa, yana juyawa tare da Dan suna motsa duwatsu daga tarin da ba komai a hagu zuwa tarin da ke makwabta a dama. Wanda zai iya motsa duwatsu a cikin tarin karshe kadai zai sha kaye. Ana tsammanin wasa mai kyau, gano wanda zai ci.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hi": "N पत्थरों के ढेरों की एक अनुक्रमणिका दी गई है, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है। चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं सबसे निकटतम गैर-खाली ढेर से पत्थरों को दाएं सटे हुए ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozza meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, felváltva Dan-nel, köveket mozgatva a bal szélső nem üres halomból a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve, találja meg a győztest.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.983500966029718",
      "hy": "0.9710383000324461",
      "bn": "0.9426828199878106",
      "bg": "0.986894367459318",
      "zh": "0.9454340493955248",
      "fr": "0.9773183967896261",
      "de": "0.9674208435330387",
      "ha": "0.9127061187731684",
      "hi": "0.9167651306096163",
      "hu": "0.9637257225546466"
    }
  },
  {
    "task_id": "CPP/36",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right\n * and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë\n * dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n *\n * Shembull:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից։\n * Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու համար\n * և ապա բացել այդ դիրքում գտնվող դուռը։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n համար։\n * Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը։\n *\n * Օրինակ:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * একটি বৃত্তে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে\n * এবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} 1 <= i < n এর জন্য।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n *\n * উদাহরণ:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно\n * и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n *\n * Пример:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 给定 n 个门按圆形排列，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，\n * 然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总成本。\n *\n * 示例:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite\n * puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n *\n * Exemple:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1.\n * In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen\n * und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n *\n * Beispiel:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * An ba wa ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.\n * Kowanne juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama\n * sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shi ne tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofin.\n *\n * Misali:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\n * प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है\n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n *\n * उदाहरण:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy i számot, és fizet egy C_i költséget, hogy i lépést tegyen jobbra,\n * majd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat meghatározni a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n *\n * Példa:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)"
    },
    "prompt_bertscore": {
      "sq": "0.99778507262108",
      "hy": "0.986045619841156",
      "bn": "0.9690132632977954",
      "bg": "0.9928159363787301",
      "zh": "0.9650360871783338",
      "fr": "0.99778507262108",
      "de": "0.9797321531799621",
      "ha": "0.9966207013274534",
      "hi": "0.952984188809042",
      "hu": "0.9797295709850087"
    },
    "canonical_solution": "{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}",
    "instruction": {
      "en": "Write a CPP function `long long minTotalCost(int n, const std::vector<int>& C)` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "sq": "Shkruani një funksion CPP `long long minTotalCost(int n, const std::vector<int>& C)` për të zgjidhur problemin në vijim:\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1.\nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas\ndhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hy": "Գրեք CPP ֆունկցիա `long long minTotalCost(int n, const std::vector<int>& C)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\nՅուրաքանչյուր քայլի ժամանակ, խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու համար\nև ապա բացել այդ դիրքի դուռը: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bn": "একটি CPP ফাংশন `long long minTotalCost(int n, const std::vector<int>& C)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn টি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে।\nপ্রতি টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে\nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} 1 <= i < n এর জন্য।\nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bg": "Напишете CPP функция `long long minTotalCost(int n, const std::vector<int>& C)`, за да решите следния проблем:  \nДадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.  \n\nПример:  \n    >>> minTotalCost(3, (1, 1, 1))  \n    3  ",
      "zh": "编写一个 CPP 函数 `long long minTotalCost(int n, const std::vector<int>& C)` 来解决以下问题：\n给定 n 扇门按圆形排列，玩家从门 1 前面开始。\n每一轮，玩家可以选择一个数字 i 并支付费用 C_i 向右移动 i 步\n然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总费用。\n\n示例:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "fr": "Écrire une fonction CPP `long long minTotalCost(int n, const std::vector<int>& C)` pour résoudre le problème suivant :  \nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite  \net ensuite ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.  \n\nExemple :  \n    >>> minTotalCost(3, (1, 1, 1))  \n    3  ",
      "de": "Schreiben Sie eine CPP-Funktion `long long minTotalCost(int n, const std::vector<int>& C)`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1.\nIn jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen\nund dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "ha": "Rubuta aikin CPP `long long minTotalCost(int n, const std::vector<int>& C)` don warware matsalar mai zuwa:\nAn ba da ƙofofi n da aka shirya a cikin madauwari, ɗan wasan yana farawa a gaban ƙofa ta 1.\nKowane juyi, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i zuwa dama\nsannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne ƙayyade mafi ƙarancin jimillar kuɗin da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hi": "एक CPP फ़ंक्शन `long long minTotalCost(int n, const std::vector<int>& C)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है\nऔर फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह है कि सभी दरवाजे खोलने के लिए आवश्यक न्यूनतम कुल लागत का निर्धारण करें।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hu": "Írj egy CPP függvényt `long long minTotalCost(int n, const std::vector<int>& C)` a következő probléma megoldására:\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizethet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9979652303766786",
      "hy": "0.9731984054262005",
      "bn": "0.9742143998251939",
      "bg": "0.9960081252323418",
      "zh": "0.9912699961231356",
      "fr": "0.9979652303766786",
      "de": "0.9833510000920367",
      "ha": "0.9822970672902656",
      "hi": "0.9823648002501985",
      "hu": "0.98261269096573"
    },
    "level": "easy",
    "test": "int main() {\n    std::vector<int> costs1 = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    std::vector<int> costs2 = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    std::vector<int> costs3 = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    std::vector<int> costs4 = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    std::vector<int> costs5 = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    std::vector<int> costs6 = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    std::vector<int> costs7 = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    std::vector<int> costs8 = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    std::vector<int> costs9 = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    std::vector<int> costs10 = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, const std::vector<int>& C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1.\nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë\ndhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja minimale totale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:  \nՅուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու  \nև այնուհետև այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:  \nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।  \nপ্রতি টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যাওয়ার জন্য একটি খরচ C_i প্রদান করে  \nএবং তারপর সেই অবস্থানের দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।  \nসমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "zh": "给定 n 个门排列成一个圆圈，玩家从门 1 前面开始。  \n每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，然后打开该位置的门。  \n保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite  \net ensuite ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. \nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen \nund dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n. \nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "ha": "An ba wa ƙofa n da aka shirya a cikin da'ira, ɗan wasan yana farawa a gaban ƙofa ta 1. A kowane juyi, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hi": "n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।  \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है  \nऔर फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen,\nmajd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9972789624102031",
      "hy": "0.982925732446241",
      "bn": "0.9652573614228067",
      "bg": "0.9946057947422355",
      "zh": "0.9951814255864746",
      "fr": "0.9928052103381543",
      "de": "0.9929990735900444",
      "ha": "0.9764394573535468",
      "hi": "0.9550841091973428",
      "hu": "0.9775791984799249"
    }
  },
  {
    "task_id": "CPP/37",
    "prompt": {
      "en": "#include <cassert>\n#include <vector>\n/**\n * Computes the total number of handshakes in a classroom scenario given\n * the sequence of student IDs as they enter the classroom. It assumes\n * that students have IDs ranging from 0 to N-1 and that each student\n * will shake hands only with students already in the classroom with a\n * smaller ID.\n *\n * Examples:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "sq": "#include <cassert>\n#include <vector>\n/**\n * Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur\n * parasysh sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet\n * që studentët kanë ID që variojnë nga 0 deri në N-1 dhe që secili student\n * do të shtrëngojë duart vetëm me studentët që janë tashmë në klasë me një\n * ID më të vogël.\n *\n * Shembuj:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "hy": "#include <cassert>\n#include <vector>\n/**\n * Հաշվում է ձեռքսեղմումների ընդհանուր քանակը դասարանում, \n * տրված է ուսանողների ID-ների հաջորդականությունը, ինչպես նրանք մտնում են դասարան: \n * Ենթադրվում է, որ ուսանողները ունեն ID-ներ 0-ից մինչև N-1, \n * և որ յուրաքանչյուր ուսանող ձեռք կսեղմի միայն այն ուսանողների հետ, \n * ովքեր արդեն դասարանում են ավելի փոքր ID-ով:\n *\n * Օրինակներ:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "bn": "#include <cassert>\n#include <vector>\n/**\n * একটি শ্রেণীকক্ষের পরিস্থিতিতে মোট কতগুলি করমর্দন হয় তা গণনা করে\n * যখন ছাত্রদের আইডির ক্রমটি দেওয়া হয় যেভাবে তারা শ্রেণীকক্ষে প্রবেশ করে। এটি ধরে নেয়\n * যে ছাত্রদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি ছাত্র\n * শুধুমাত্র তাদের চেয়ে ছোট আইডি সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা ছাত্রদের সাথে করমর্দন করবে।\n *\n * উদাহরণ:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "bg": "#include <cassert>\n#include <vector>\n/**\n * Изчислява общия брой ръкостискания в класна стая, като се дава\n * последователността от идентификатори на учениците, когато влизат в класната стая. Предполага се,\n * че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик\n * ще се ръкува само с ученици, които вече са в класната стая с\n * по-малък идентификатор.\n *\n * Примери:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "zh": "#include <cassert>\n#include <vector>\n/**\n * 计算在一个教室场景中握手的总次数，给定学生进入教室的顺序。\n * 假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID更小的学生握手。\n *\n * 示例:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "fr": "#include <cassert>\n#include <vector>\n/**\n * Calcule le nombre total de poignées de main dans un scénario de classe donné\n * la séquence des identifiants des étudiants à mesure qu'ils entrent dans la classe. Il suppose\n * que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant\n * serrera la main uniquement avec les étudiants déjà dans la classe avec un\n * identifiant plus petit.\n *\n * Exemples :\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "de": "#include <cassert>\n#include <vector>\n/**\n * Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmerszenario, gegeben\n * die Sequenz der Schüler-IDs, während sie das Klassenzimmer betreten. Es wird angenommen,\n * dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler\n * nur mit Schülern Händedrucke austauscht, die bereits im Klassenzimmer sind und eine\n * kleinere ID haben.\n *\n * Beispiele:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "ha": "#include <cassert>\n#include <vector>\n/**\n * Yana lissafin jimillar yawan gaisuwar hannu a cikin yanayin aji da aka bayar\n * jerin lambobin ID na ɗalibai yayin da suke shiga ajin. Yana ɗauka\n * cewa ɗalibai suna da ID daga 0 zuwa N-1 kuma cewa kowane ɗalibi\n * zai gaisa da hannu ne kawai da ɗalibai da suke cikin ajin tuni da\n * ke da ID mafi ƙanƙanta.\n *\n * Misalai:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "hi": "#include <cassert>\n#include <vector>\n/**\n * एक कक्षा परिदृश्य में कुल हैंडशेक की संख्या की गणना करता है, \n * जब छात्र आईडी के अनुक्रम के रूप में कक्षा में प्रवेश करते हैं। यह मानता है \n * कि छात्रों की आईडी 0 से N-1 तक होती है और प्रत्येक छात्र केवल उन छात्रों \n * के साथ हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनकी आईडी छोटी है।\n *\n * उदाहरण:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "hu": "#include <cassert>\n#include <vector>\n/**\n * Kiszámítja a kézfogások teljes számát egy osztálytermi szituációban,\n * figyelembe véve a diákok azonosítóinak sorrendjét, ahogy belépnek az osztályterembe.\n * Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák\n * csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak, és kisebb azonosítóval rendelkeznek.\n *\n * Példák:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)"
    },
    "prompt_bertscore": {
      "sq": "0.9783421377734799",
      "hy": "0.9610527535170602",
      "bn": "0.9639356748674005",
      "bg": "0.9598089300710196",
      "zh": "0.9371803611723821",
      "fr": "0.9758749498106456",
      "de": "0.9592209841431564",
      "ha": "0.9770808348539084",
      "hi": "0.9556043221652731",
      "hu": "0.9423846757858773"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `long long countHandshakes(int n, const std::vector<int>& order)` to solve the following problem:\nComputes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> countHandshakes(3, {2, 1, 0})\n0\n",
      "sq": "Shkruani një funksion CPP `long long countHandshakes(int n, const std::vector<int>& order)` për të zgjidhur problemin në vijim:  \nLlogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur parasysh sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet që studentët kanë ID që variojnë nga 0 deri në N-1 dhe që secili student do të shtrëngojë duart vetëm me studentët që janë tashmë në klasë me një ID më të vogël.\n\nShembuj:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hy": "Գրեք CPP ֆունկցիա `long long countHandshakes(int n, const std::vector<int>& order)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր ձեռքսեղմումների քանակը դասարանում սցենարի մեջ՝ հաշվի առնելով ուսանողների ID-ների հաջորդականությունը, երբ նրանք մտնում են դասարան։ Ենթադրվում է, որ ուսանողները ունեն ID-ներ 0-ից N-1 միջակայքում և որ յուրաքանչյուր ուսանող ձեռք կսեղմի միայն այն ուսանողների հետ, որոնք արդեն դասարանում են ավելի փոքր ID-ով։\n\nՕրինակներ:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "bn": "`long long countHandshakes(int n, const std::vector<int>& order)` ফাংশনটি লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nশ্রেণীকক্ষের দৃশ্যে শিক্ষার্থীদের প্রবেশের ক্রম অনুযায়ী মোট হ্যান্ডশেকের সংখ্যা গণনা করে। এটি ধরে নেয় যে শিক্ষার্থীদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি শিক্ষার্থী শুধুমাত্র শ্রেণীকক্ষে ইতিমধ্যে উপস্থিত ছোট আইডি বিশিষ্ট শিক্ষার্থীদের সাথে হ্যান্ডশেক করবে।\n\nউদাহরণসমূহ:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "bg": "Напишете CPP функция `long long countHandshakes(int n, const std::vector<int>& order)`, за да решите следния проблем:  \nИзчислява общия брой ръкостискания в класна стая, като се има предвид последователността на идентификаторите на учениците, когато влизат в класната стая. Предполага се, че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик ще се ръкува само с ученици, които вече са в класната стая с по-малък идентификатор.\n\nПримери:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "zh": "编写一个 CPP 函数 `long long countHandshakes(int n, const std::vector<int>& order)` 来解决以下问题：\n计算在一个教室场景中，根据学生进入教室的顺序，总握手次数。假设学生的 ID 范围是从 0 到 N-1，并且每个学生只会与已经在教室中且 ID 较小的学生握手。",
      "fr": "Écrire une fonction CPP `long long countHandshakes(int n, const std::vector<int>& order)` pour résoudre le problème suivant :\nCalcule le nombre total de poignées de main dans un scénario de classe donné la séquence des identifiants des étudiants lorsqu'ils entrent dans la classe. Il est supposé que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant serrera la main uniquement avec les étudiants déjà présents dans la classe avec un identifiant plus petit.\n\nExemples:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "de": "Schreiben Sie eine CPP-Funktion `long long countHandshakes(int n, const std::vector<int>& order)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer-Szenario, gegeben die Reihenfolge der Schüler-IDs, wie sie das Klassenzimmer betreten. Es wird angenommen, dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler nur mit Schülern Händeschütteln wird, die bereits im Klassenzimmer sind und eine kleinere ID haben.\n\nBeispiele:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "ha": "Rubuta aikin CPP `long long countHandshakes(int n, const std::vector<int>& order)` don warware matsalar mai zuwa:\nYana ƙididdige jimlar yawan gaisuwar hannu a cikin yanayin aji la'akari da jerin lambobin ID na ɗalibai yayin da suke shiga aji. Ana ɗauka cewa ɗalibai suna da lambobin ID daga 0 zuwa N-1 kuma kowanne ɗalibi zai gaisa da hannu kawai da ɗaliban da suka riga sun shiga aji da ƙananan ID.",
      "hi": "एक CPP फ़ंक्शन `long long countHandshakes(int n, const std::vector<int>& order)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकक्षा परिदृश्य में कुल हैंडशेक्स की गणना करता है, जिसमें छात्रों के आईडी के अनुक्रम को दिया गया है जैसे वे कक्षा में प्रवेश करते हैं। यह मानता है कि छात्रों के आईडी 0 से N-1 तक होते हैं और प्रत्येक छात्र केवल उन छात्रों के साथ हैंडशेक करेगा जो पहले से ही कक्षा में छोटे आईडी के साथ मौजूद हैं।\n\nउदाहरण:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hu": "Írj egy CPP függvényt `long long countHandshakes(int n, const std::vector<int>& order)` a következő probléma megoldására:\nKiszámítja a kézfogások teljes számát egy osztálytermi szituációban, figyelembe véve a diákok azonosítóinak sorrendjét, ahogy belépnek az osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak kisebb azonosítóval.\n\nPéldák:\n>>> countHandshakes(3, {2, 1, 0})\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9750111062835248",
      "hy": "0.9662922257079984",
      "bn": "0.9155602387182586",
      "bg": "0.9686646669790792",
      "zh": "0.9029553533681657",
      "fr": "0.9848603923575209",
      "de": "0.9642316341351425",
      "ha": "0.9008709261495856",
      "hi": "0.9546234853437229",
      "hu": "0.9524798662715944"
    },
    "level": "middle",
    "test": "int main() {\n    assert(countHandshakes(4, {2, 1, 3, 0}) == 2);\n    assert(countHandshakes(6, {0, 1, 2, 3, 4, 5}) == 15);\n    assert(countHandshakes(3, {1, 2, 0}) == 1);\n    assert(countHandshakes(4, {3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 1, 2, 3}) == 6);\n    assert(countHandshakes(6, {5, 4, 3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 2, 1, 3}) == 5);\n    assert(countHandshakes(5, {3, 1, 4, 2, 0}) == 3);\n    assert(countHandshakes(4, {1, 0, 3, 2}) == 4);\n    assert(countHandshakes(3, {2, 0, 1}) == 1);\n    assert(countHandshakes(5, {1, 3, 0, 2, 4}) == 7);\n    assert(countHandshakes(5, {4, 3, 2, 1, 0}) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, const std::vector<int>& order)",
    "docstring": {
      "en": "Computes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> countHandshakes(3, {2, 1, 0})\n0\n",
      "sq": "Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke dhënë sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet se studentët kanë ID që variojnë nga 0 deri në N-1 dhe se çdo student do të shtrëngojë duart vetëm me studentët që tashmë janë në klasë me një ID më të vogël.\n\nShembuj:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hy": "Հաշվում է դասարանում ողջույնի ձեռքսեղմումների ընդհանուր քանակը՝ հաշվի առնելով ուսանողների ID-ների հաջորդականությունը, երբ նրանք մտնում են դասարան: Ենթադրվում է, որ ուսանողների ID-ները տատանվում են 0-ից մինչև N-1, և որ յուրաքանչյուր ուսանող ձեռքսեղմում է միայն այն ուսանողների հետ, ովքեր արդեն դասարանում են ավելի փոքր ID-ով:\n\nՕրինակներ:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "bn": "শ্রেণীকক্ষের পরিস্থিতিতে শিক্ষার্থীদের আইডির ক্রম অনুযায়ী শ্রেণীকক্ষে প্রবেশের সময় মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে। এটি ধরে নেয় যে শিক্ষার্থীদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি শিক্ষার্থী শুধুমাত্র তার চেয়ে ছোট আইডি সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা শিক্ষার্থীদের সাথে হ্যান্ডশেক করবে।\n\nউদাহরণ:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "bg": "Изчислява общия брой ръкостискания в класна стая, като се даде последователността от идентификатори на ученици, когато влизат в класната стая. Предполага се, че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик ще се ръкува само с ученици, които вече са в класната стая с по-малък идентификатор.\n\nПримери:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "zh": "计算在教室场景中，给定学生进入教室的顺序后，总共的握手次数。假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID较小的学生握手。\n\n示例：\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "fr": "Calcule le nombre total de poignées de main dans un scénario de classe donné la séquence des identifiants des étudiants à mesure qu'ils entrent dans la classe. Il suppose que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant serrera la main uniquement avec les étudiants déjà présents dans la classe avec un identifiant plus petit.\n\nExemples :\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "de": "Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer-Szenario, gegeben die Sequenz der Schüler-IDs, während sie das Klassenzimmer betreten. Es wird angenommen, dass die Schüler IDs von 0 bis N-1 haben und dass jeder Schüler nur mit Schülern Händeschütteln wird, die bereits im Klassenzimmer sind und eine kleinere ID haben.\n\nBeispiele:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "ha": "Yana ƙididdige adadin gaisuwar hannu a cikin yanayin aji idan aka ba da jerin lambobin ID na ɗalibai yayin da suke shiga aji. Yana ɗauka cewa ɗalibai suna da lambobin ID daga 0 zuwa N-1 kuma cewa kowanne ɗalibi zai yi gaisuwar hannu ne kawai da ɗaliban da suka riga sun shiga aji da ƙaramin ID.\n\nMisalai:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hi": "कक्षा परिदृश्य में कुल हैंडशेक की संख्या की गणना करता है, जब छात्रों के आईडी के अनुक्रम के अनुसार वे कक्षा में प्रवेश करते हैं। यह मानता है कि छात्रों के आईडी 0 से N-1 तक होते हैं और प्रत्येक छात्र केवल उन छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी के साथ हैं।\n\nउदाहरण:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hu": "Számítja az összes kézfogás számát egy osztálytermi szituációban, adott a diákok azonosítóinak sorrendje, ahogy belépnek az osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak és kisebb azonosítóval rendelkeznek.\n\nPéldák:\n>>> countHandshakes(3, {2, 1, 0})\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9476912850456053",
      "hy": "0.935522790642646",
      "bn": "0.9104699379434776",
      "bg": "0.9376169507498968",
      "zh": "0.9240926053659934",
      "fr": "0.9729068160268413",
      "de": "0.9547935129498888",
      "ha": "0.9387247123849284",
      "hi": "0.9381345815228738",
      "hu": "0.9311463674573043"
    }
  },
  {
    "task_id": "CPP/38",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët\n * më të shpeshtë në një sekuencë.\n * \n * Shembull:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\n * գտնել մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար\n * հաջորդականության, որը կառուցված է այս թվերից։ Մոդը հաջորդականության ամենահաճախ հանդիպող\n * տարրերի մեջ ամենամեծ թիվն է։\n * \n * Օրինակ:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։\n */\nlong long maxModeSum(int n, const int* counts)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\n * একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন\n * যা এই সংখ্যাগুলি থেকে নির্মিত। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * \n * উদাহরণ:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n */\nlong long maxModeSum(int n, const int* counts)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на модата (най-често срещания елемент) за всички префикси на\n * последователност, конструирана от тези числа. Модата е най-голямото число сред\n * най-често срещаните елементи в последователност.\n * \n * Пример:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中的最大数字。\n * \n * 示例:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * 达到其最大值的序列是 (3,2,3,1,2,2)。\n */\nlong long maxModeSum(int n, const int* counts)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\n * trouver la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes\n * d'une séquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\n * les éléments les plus fréquents dans une séquence.\n * \n * Exemple :\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * \n * Beispiel:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\n * nemo mafi girman jimlar yanayin (abu mafi yawa) don dukkanin farkon\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\n * abubuwan da suka fi yawa a cikin jerin.\n * \n * Misali:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\n * जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n * \n * उदाहरण:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n */\nlong long maxModeSum(int n, const int* counts)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\n * keresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az összes prefixumra\n * egy ezekből a számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat\n * leggyakrabban előforduló elemei között.\n * \n * Példa:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "sq": "0.9871551691496169",
      "hy": "0.9502452744849519",
      "bn": "0.992171778053034",
      "bg": "0.990776598256645",
      "zh": "0.9809275108130301",
      "fr": "0.9976760245418919",
      "de": "0.9960186526425368",
      "ha": "0.9419351752335953",
      "hi": "0.9708754231199974",
      "hu": "0.955034054341322"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `long long maxModeSum(int n, const int* counts)` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> maxModeSum(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "sq": "Shkruani një funksion CPP `long long maxModeSum(int n, const int* counts)` për të zgjidhur problemin në vijim:\nDuke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n\nShembull:\n>>> maxModeSum(3, {1, 2, 3})\n17\nNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Գրեք CPP ֆունկցիա `long long maxModeSum(int n, const int* counts)` հետևյալ խնդիրը լուծելու համար: \nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, \nգտեք մոդի (ամենահաճախ հանդիպող տարրը) առավելագույն գումարը բոլոր նախածանցների համար \nայս թվերից կազմված հաջորդականության: Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ \nամենամեծ թիվն է:\n\nՕրինակ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nՀաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է:",
      "bn": "একটি CPP ফাংশন `long long maxModeSum(int n, const int* counts)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nপ্রতিটি সংখ্যা 1 থেকে n পর্যন্ত গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে, \nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। \nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\nউদাহরণ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Напишете CPP функция `long long maxModeSum(int n, const int* counts)`, за да решите следния проблем:\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, конструирана от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n\nПример:\n>>> maxModeSum(3, {1, 2, 3})\n17\nПоследователност, която достига максималната си стойност, е (3,2,3,1,2,2).",
      "zh": "编写一个 CPP 函数 `long long maxModeSum(int n, const int* counts)` 来解决以下问题：\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是在序列中最频繁元素中最大的数字。\n\n示例：\n>>> maxModeSum(3, {1, 2, 3})\n17\n一个达到其最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Écrire une fonction CPP `long long maxModeSum(int n, const int* counts)` pour résoudre le problème suivant :\nÉtant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\ntrouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\nExemple:\n>>> maxModeSum(3, {1, 2, 3})\n17\nUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Schreiben Sie eine CPP-Funktion `long long maxModeSum(int n, const int* counts)`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\nSequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl unter\nden häufigsten Elementen in einer Sequenz.\n\nBeispiel:\n>>> maxModeSum(3, {1, 2, 3})\n17\nEine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).",
      "ha": "Rubuta aikin CPP `long long maxModeSum(int n, const int* counts)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n da ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (mafi yawan abu) don dukkan farkon\njerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nmafi yawan abubuwa a cikin jerin.\n\nMisali:\n>>> maxModeSum(3, {1, 2, 3})\n17\nJerin da ke kaiwa ga darajarsa mafi girma shine (3,2,3,1,2,2).",
      "hi": "एक CPP फ़ंक्शन `long long maxModeSum(int n, const int* counts)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या होती है।\n\nउदाहरण:\n>>> maxModeSum(3, {1, 2, 3})\n17\nएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Írj egy CPP függvényt `long long maxModeSum(int n, const int* counts)` a következő probléma megoldására:\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét az\nezekből a számokból felépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n\nPélda:\n>>> maxModeSum(3, {1, 2, 3})\n17\nEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "instruction_bertscore": {
      "sq": "0.9868502715147284",
      "hy": "0.9731380217903659",
      "bn": "0.9932815259918759",
      "bg": "0.9891706716259779",
      "zh": "0.989677973619141",
      "fr": "1",
      "de": "1",
      "ha": "0.9469996540588418",
      "hi": "0.9702338469892547",
      "hu": "0.9604685815664366"
    },
    "level": "middle",
    "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> maxModeSum(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "sq": "Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementet më të shpeshta në një sekuencë.\n\nShembull:\n>>> maxModeSum(3, {1, 2, 3})\n17\nNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\nգտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների\nհամար, որոնք կազմված են այս թվերից։ Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի մեջ հաջորդականության։\n\nՕրինակ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nՀաջորդականությունը, որը հասնում է իր մաքսիմալ արժեքին, (3,2,3,1,2,2) է։",
      "bn": "n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রম থেকে সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\nউদাহরণ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n\nПример:\n>>> maxModeSum(3, {1, 2, 3})\n17\nПоследователност, която достига своята максимална стойност, е (3,2,3,1,2,2).",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n\n示例：\n>>> maxModeSum(3, {1, 2, 3})\n17\n达到其最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\nExemple :\n>>> maxModeSum(3, {1, 2, 3})\n17\nUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen, finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n\nBeispiel:\n>>> maxModeSum(3, {1, 2, 3})\n17\nEine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).",
      "ha": "An ba n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (abin da ya fi yawa) don dukkan gabanin jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin abubuwan da suka fi yawa a cikin jerin.\n\nMisali:\n>>> maxModeSum(3, {1, 2, 3})\n17\nJerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या होता है।\n\nउदाहरण:\n>>> maxModeSum(3, {1, 2, 3})\n17\nएक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelzik, \nkeresse meg a módusz (leggyakrabban előforduló elem) maximális összegét egy \nezekből a számokból felépített sorozat minden prefixére. A módusz a sorozat \nleggyakrabban előforduló elemei közül a legnagyobb szám.\n\nPélda:\n>>> maxModeSum(3, {1, 2, 3})\n17\nEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "sq": "0.9883421843066814",
      "hy": "0.9582739144863821",
      "bn": "0.9582743117471442",
      "bg": "0.9826001772517249",
      "zh": "0.9798441807148658",
      "fr": "1",
      "de": "1",
      "ha": "0.9014968104802266",
      "hi": "0.9772419240929276",
      "hu": "0.9454837069907835"
    }
  },
  {
    "task_id": "CPP/39",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example cases:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\n * Shuma XOR e një nënvargu është rezultati i XOR-it të të gjitha elementeve nga L në R.\n * Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n *\n * Shembuj të rasteve:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը:\n * Ենթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\n * Ենթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n *\n * Օրինակներ:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * একটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n *\n * উদাহরণ কেস:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\n * Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n *\n * Примерни случаи:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n * 子数组的异或和是从L到R的所有元素的异或结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例案例:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemples de cas :\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel-Fälle:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * An ba da wani tsari A na lambobin cikakke, aikin shi ne a lissafa jimillar XOR na dukkan ƙananan tsaruka.\n * Ana ayyana ƙananan tsari ta hanyar ma'aurata na alamomin (L, R) ta yadda 1 <= L <= R <= n, inda n shine girman tsari.\n * Jimillar XOR na ƙananan tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan tsaruka.\n *\n * Misalan lokuta:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी उप-श्रृंखलाओं के XOR का योग गणना करें।\n * एक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\n * एक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों के XOR का परिणाम है।\n * अंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n *\n * उदाहरण मामले:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámoljuk az összes részhalmaz XOR összegét.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa esetek:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)"
    },
    "prompt_bertscore": {
      "sq": "0.993520875601023",
      "hy": "0.9741716942932714",
      "bn": "0.9810766822291872",
      "bg": "0.9900627206672056",
      "zh": "0.9740705914293246",
      "fr": "0.993520875601023",
      "de": "0.993520875601023",
      "ha": "0.9810838329229045",
      "hi": "0.9840386584711794",
      "hu": "0.9800185781894144"
    },
    "canonical_solution": "{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `long long sumOfXorSubarrays(const std::vector<int>& A)` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "sq": "Shkruani një funksion CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hy": "Գրեք CPP ֆունկցիա `long long sumOfXorSubarrays(const std::vector<int>& A)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի A զանգվածը, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bn": "একটি CPP ফাংশন `long long sumOfXorSubarrays(const std::vector<int>& A)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bg": "Напишете CPP функция `long long sumOfXorSubarrays(const std::vector<int>& A)`, за да решите следния проблем:\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се дефинира от двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "zh": "编写一个 CPP 函数 `long long sumOfXorSubarrays(const std::vector<int>& A)` 来解决以下问题：\n给定一个整数数组 A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "fr": "Écrire une fonction CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` pour résoudre le problème suivant :\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "de": "Schreiben Sie eine CPP-Funktion `long long sumOfXorSubarrays(const std::vector<int>& A)`, um das folgende Problem zu lösen:\nGegeben ist ein Array A von ganzen Zahlen. Die Aufgabe besteht darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, sodass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielfälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "ha": "Rubuta aikin CPP `long long sumOfXorSubarrays(const std::vector<int>& A)` don warware matsalar mai zuwa:  \nAn ba da wani tsari A na lambobi, aikin shine a ƙididdige jimlar XOR na dukkan ƙananan tsaruka.  \nAna ayyana ƙaramar tsari ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.  \nJimlar XOR na ƙaramar tsari shine sakamakon XORing dukkan abubuwa daga L zuwa R.  \nSakamakon ƙarshe shine jimlar XOR na dukkan yiwuwar ƙananan tsaruka.  \n\nMisalan lamura:  \n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)  \n    39  ",
      "hi": "एक CPP फ़ंक्शन `long long sumOfXorSubarrays(const std::vector<int>& A)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी subarrays के XOR का योग गणना करें।\nएक subarray को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\nएक subarray का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित subarrays के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hu": "Írj egy CPP függvényt `long long sumOfXorSubarrays(const std::vector<int>& A)` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámoljuk az összes részhalmaz XOR összegének összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "instruction_bertscore": {
      "sq": "0.9943847191281437",
      "hy": "0.9937520813645476",
      "bn": "0.9879349920255599",
      "bg": "0.9947976716903152",
      "zh": "0.9795049200240582",
      "fr": "0.9934606905955694",
      "de": "0.9896888982900979",
      "ha": "0.97839398030293",
      "hi": "0.981661847331716",
      "hu": "0.9853708724367805"
    },
    "level": "middle",
    "test": "int main() {\n    assert(sumOfXorSubarrays({1, 2, 3, 4, 5}) == 39);\n    assert(sumOfXorSubarrays({1, 1, 1}) == 4);\n    assert(sumOfXorSubarrays({2, 3, 1}) == 9);\n    assert(sumOfXorSubarrays({4, 5, 7, 9}) == 74);\n    assert(sumOfXorSubarrays({0, 0, 0, 0}) == 0);\n    assert(sumOfXorSubarrays({8, 8, 8, 8, 8}) == 72);\n    assert(sumOfXorSubarrays({3, 6, 9, 12, 15}) == 125);\n    assert(sumOfXorSubarrays({10, 20, 30, 40, 50}) == 390);\n    assert(sumOfXorSubarrays({16, 16, 16, 16, 16, 16}) == 192);\n    assert(sumOfXorSubarrays({1, 3, 5, 7, 9, 11, 13}) == 192);\n    assert(sumOfXorSubarrays({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218);\n\n\n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(const std::vector<int>& A)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve. Një nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut. Shuma e XOR-it të një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave të XOR-it për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hy": "Տրված է A ամբողջ թվերի զանգված, խնդիրն է հաշվել բոլոր ենթազանգվածների XOR-ի գումարը։  \nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է։  \nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է։  \nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է։  \n\nՕրինակներ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bn": "ইন্টিজার সম্বলিত একটি অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত সাবঅ্যারের XOR এর যোগফল গণনা করা। \nএকটি সাবঅ্যারে একটি ইন্ডেক্সের জোড়া (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি সাবঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য সাবঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "zh": "给定一个整数数组A，任务是计算所有子数组的异或和的总和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和的总和。  \n\n示例案例:  \n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)  \n    39  ",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.  \n\nCas d'exemple:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XOR aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "ha": "An ba da jerin A na lambobin cikakke, aikin shi ne a lissafa jimillar XOR na dukkan ƙananan jerin.\nƘaramar jeri ana ayyana ta ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramar jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.\n\nMisalan lokuta:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hi": "दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उप-सरणियों के XOR का योग गणना करना है। एक उप-सरणी को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n सरणी का आकार है। एक उप-सरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। अंतिम परिणाम सभी संभावित उप-सरणियों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "sq": "0.9923926550367448",
      "hy": "0.9823379851487588",
      "bn": "0.9745004275738841",
      "bg": "0.9876823341808835",
      "zh": "0.9557080072241734",
      "fr": "0.9907644818034018",
      "de": "0.9924031824469397",
      "ha": "0.9452946108680383",
      "hi": "0.9796648174807913",
      "hu": "0.9676045766354959"
    }
  },
  {
    "task_id": "CPP/40",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being\n * positive integers and b >= k. Different legal representations of x are counted\n * only once. For example:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë\n * numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen\n * vetëm një herë. Për shembull:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Տրված են երկու դրական ամբողջ թվեր n և k, գտնել դրական ամբողջ թվերի քանակը x,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b\n * դրական ամբողջ թվեր են և b >= k: x-ի տարբեր թույլատրելի ներկայացումները հաշվում են\n * միայն մեկ անգամ: Օրինակ:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\n * যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b\n * ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়। উদাহরণস্বরূপ:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са\n * положителни цели числа и b >= k. Различните легални представяния на x се броят\n * само веднъж. Например:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 给定两个正整数 n 和 k，找到满足 1 <= x <= n 的正整数 x 的数量，\n * 其中 x 可以表示为 x = a^b，a 和 b 是正整数且 b >= k。\n * x 的不同合法表示仅计数一次。例如：\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Étant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant\n * des entiers positifs et b >= k. Les différentes représentations légales de x sont comptées\n * une seule fois. Par exemple :\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b\n * positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen von x werden\n * nur einmal gezählt. Zum Beispiel:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * An ba da lambobi biyu masu kyau n da k, nemo adadin lambobi masu kyau x,\n * inda 1 <= x <= n, wanda za a iya bayyana shi azaman x = a^b tare da a da b suna\n * zama lambobi masu kyau kuma b >= k. Ana kirga wakilci daban-daban na doka na x\n * sau daya kawai. Misali:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * दिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b\n * धनात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध प्रतिनिधित्व केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Két pozitív egész szám, n és k megadása esetén találjuk meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok és b >= k. \n * Az x különböző legális ábrázolásai csak egyszer számítanak. Például:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "sq": "0.9946373769728201",
      "hy": "0.9863397914354687",
      "bn": "0.9836187538456718",
      "bg": "0.9902847894332026",
      "zh": "0.9631155300241074",
      "fr": "1",
      "de": "0.9849473924644141",
      "ha": "0.9772284172270174",
      "hi": "0.9791549332926747",
      "hu": "0.9740570845634143"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "en": "Write a CPP function `int countPowerNumbers(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Shkruani një funksion CPP `int countPowerNumbers(int n, int k)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen vetëm një herë. Për shembull:  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "hy": "Գրեք CPP ֆունկցիա `int countPowerNumbers(int n, int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: x-ի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ: Օրինակ՝\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "একটি CPP ফাংশন `int countPowerNumbers(int n, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b হিসাবে প্রকাশ করা যেতে পারে যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়। উদাহরণস্বরূপ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Напишете CPP функция `int countPowerNumbers(int n, int k)` за решаване на следния проблем:\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на x се броят само веднъж. Например:\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "编写一个 CPP 函数 `int countPowerNumbers(int n, int k)` 来解决以下问题：  \n给定两个正整数 n 和 k，找出有多少个正整数 x，满足 1 <= x <= n，并且可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。x 的不同合法表示仅计数一次。例如：  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "fr": "Écrire une fonction CPP `int countPowerNumbers(int n, int k)` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales de x sont comptées une seule fois. Par exemple :  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "de": "Schreiben Sie eine CPP-Funktion `int countPowerNumbers(int n, int k)`, um das folgende Problem zu lösen:\nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen von x werden nur einmal gezählt. Zum Beispiel:\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "Rubuta aikin CPP `int countPowerNumbers(int n, int k)` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana kirga daban-daban halattattun wakilcin x sau ɗaya kawai. Alal misali:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "एक CPP फ़ंक्शन `int countPowerNumbers(int n, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध प्रतिनिधित्व केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Írj egy CPP függvényt `int countPowerNumbers(int n, int k)` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "instruction_bertscore": {
      "sq": "0.9928395733940734",
      "hy": "0.9811543467081719",
      "bn": "0.9289715634153533",
      "bg": "0.9908806805763073",
      "zh": "0.9596708819562004",
      "fr": "1",
      "de": "0.9767195261908059",
      "ha": "0.9602296292180516",
      "hi": "0.9850250569433987",
      "hu": "0.9706328954247538"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme legale të x numërohen vetëm një herë. Për shembull:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hy": "Երկու դրական ամբողջ թիվ n և k ունենալով, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են, և b >= k: x-ի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ: Օրինակ՝\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, এমন ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x-এর বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়। উদাহরণস্বরূপ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на x се броят само веднъж. Например:\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。x 的不同合法表示仅计算一次。例如：\n    >>> countPowerNumbers(99, 1)\n    99",
      "fr": "Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Les différentes représentations légales de x sont comptées une seule fois. Par exemple :\n    >>> countPowerNumbers(99, 1)\n    99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene gültige Darstellungen von x werden nur einmal gezählt. Zum Beispiel:\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "An ba da lambobi biyu masu kyau n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su azaman x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na x sau ɗaya kawai. Alal misali:\n\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Két pozitív egész szám, n és k esetén találja meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "sq": "0.9990227385253083",
      "hy": "0.9766629165322109",
      "bn": "0.9510650220674829",
      "bg": "0.9965227765496032",
      "zh": "0.9551655476535671",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9824937113674901",
      "hi": "0.9526115582142205",
      "hu": "0.9441286505313635"
    }
  },
  {
    "task_id": "CPP/41",
    "prompt": {
      "en": "#include <cassert>\n/* Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sq": "#include <cassert>\n/* Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hy": "#include <cassert>\n/* Երեք ամբողջ թիվ n, m և k տրված են, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')',\nայնպիսին, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bn": "#include <cassert>\n/* তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n '(' এবং m ')' নিয়ে গঠিত কতগুলি ক্রম রয়েছে তা খুঁজে বের করুন,\nযেমন দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো হিসাবে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bg": "#include <cassert>\n/* Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "zh": "#include <cassert>\n/* 给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "fr": "#include <cassert>\n/* Étant donné trois entiers n, m, et k, trouvez le nombre de séquences consistant en n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "de": "#include <cassert>\n/* Gegeben sind drei ganze Zahlen n, m und k. Finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "ha": "#include <cassert>\n/* An ba integers guda uku n, m, da k, nemo yawan jerin abubuwa da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jere mai daidaituwa yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nAlal misali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hi": "#include <cassert>\n/* तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित किया जाना चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hu": "#include <cassert>\n/* Adott három egész szám: n, m és k. Találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.988283191083514",
      "bn": "0.969147736065756",
      "bg": "0.9860388664082008",
      "zh": "0.9790015906385158",
      "fr": "0.9974746133355225",
      "de": "0.9762237447597428",
      "ha": "0.9899961794895589",
      "hi": "0.9874453681363089",
      "hu": "0.9593759158403636"
    },
    "canonical_solution": "{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "Write a CPP function `long long countBalancedSubsequences(long long n, long long m, long long k)` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Shkruani një funksion CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` për të zgjidhur problemin në vijim:\nDuke pasur parasysh tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që subsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Գրեք CPP ֆունկցիա `long long countBalancedSubsequences(long long n, long long m, long long k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երեք ամբողջ թիվ n, m և k, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը,\nայնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։",
      "bn": "একটি CPP ফাংশন `long long countBalancedSubsequences(long long n, long long m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত এমন সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালান্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Напишете CPP функция `long long countBalancedSubsequences(long long n, long long m, long long k)`, за да решите следния проблем:\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредица е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "编写一个 CPP 函数 `long long countBalancedSubsequences(long long n, long long m, long long k)` 来解决以下问题：\n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Écrire une fonction CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` pour résoudre le problème suivant :\nÉtant donné trois entiers n, m, et k, trouver le nombre de séquences composées de n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Schreiben Sie eine CPP-Funktion `long long countBalancedSubsequences(long long n, long long m, long long k)`, um das folgende Problem zu lösen:\nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\nso dass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "Rubuta aikin CPP `long long countBalancedSubsequences(long long n, long long m, long long k)` don warware matsalar mai zuwa:  \nAn ba da lambobi guda uku n, m, da k, nemo adadin jerin da suka ƙunshi n '(' da m ')',  \nta yadda mafi tsawon jerin da aka daidaita yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).  \n\nAlal misali:  \n    >>> countBalancedSubsequences(2, 2, 2)  \n    2  ",
      "hi": "एक CPP फ़ंक्शन `long long countBalancedSubsequences(long long n, long long m, long long k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित किया जाना चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Írj egy CPP függvényt `long long countBalancedSubsequences(long long n, long long m, long long k)` a következő probléma megoldására:\nAdott három egész szám: n, m és k, találd meg azon sorozatok számát, amelyek n '(' és m ')' jelekből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9500903427877447",
      "bn": "0.9568811182545655",
      "bg": "0.9965331053294171",
      "zh": "0.9873379091001689",
      "fr": "0.9955844466295944",
      "de": "0.9819605874247925",
      "ha": "0.9687711328633138",
      "hi": "0.9593628062352153",
      "hu": "0.9697930861737384"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')' նշաններից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ: Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով:\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на редиците, състоящи се от n '(' и m ')',\nтакива, че най-дългата балансирана подредица е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应取模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Étant donné trois entiers n, m et k, trouvez le nombre de séquences consistant en n '(' et m ')', \ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen bestehend aus n '(' und m ')', \nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "An ba da lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')', \nta yadda mafi tsawon jeri mai daidaituwa yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon tare da modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k legyen. Az eredményt 1,000,000,007 (10^9 + 7) maradékával kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9996007529341199",
      "hy": "0.960277101879119",
      "bn": "0.9629850298637675",
      "bg": "0.9903314675727458",
      "zh": "0.9623327276924489",
      "fr": "0.9964647764783411",
      "de": "0.9910693794382904",
      "ha": "0.973064925810145",
      "hi": "0.969699928525033",
      "hu": "0.9635034551582686"
    }
  },
  {
    "task_id": "CPP/42",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem \n * koordinativ Kartezian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin \n * e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve \n * për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo \n * operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër \n * pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme \n * ose e djathtë e letrës përgjatë kësaj vije më pas hidhet. Përgjigja duhet të jetë modulo 10^9+7.\n *\n * Për shembull:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է դեկարտյան հարթության վրա՝ \n * իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \n * անհրաժեշտ է հաշվել գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, \n * որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է \n * մի գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով, \n * և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը \n * ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n *\n * Օրինակ:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি আয়তাকার কাগজ n x m আকারের একটি সমতল কার্টেসিয়ান স্থানাঙ্ক \n * ব্যবস্থায় রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ, \n * আপনাকে কাগজ কাটার প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে \n * অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে \n * নির্বাচিত হয় যা অক্ষগুলোর সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ পয়েন্টগুলোর \n * মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ নয়)। \n * এই লাইনের সাথে কাগজের নিচের বা ডান অংশটি তখন বাতিল করা হয়। \n * উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна \n * декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). \n * Трябва да изчислите очаквания брой операции за рязане на хартията така, че \n * оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, \n * която е успоредна на осите, преминава през точки с цели координати и \n * пресича (не само докосва ръба) хартията. Долната или дясната част на хартията \n * по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n *\n * Например:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，\n * 其左下角在 (0,0)，右上角在 (n,m)，\n * 需要计算切割纸张的期望操作次数，使得剩余面积小于 k。\n * 在每次操作中，随机选择一条平行于坐标轴的线，\n * 该线通过整数坐标的点，并且切割（不仅仅是接触边缘）纸张。\n * 然后丢弃沿着这条线的底部或右侧部分。\n * 答案应对 10^9+7 取模。\n *\n * 例如：\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées \n * cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \n * vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \n * la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \n * qui est parallèle aux axes, passe par des points avec des coordonnées entières, \n * et coupe (ne se contente pas de toucher le bord) le papier. La partie inférieure ou droite \n * du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen \n * Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) \n * und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen \n * berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. \n * Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, \n * durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet \n * (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie \n * wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin da'ira \n * na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \n * kana buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda \n * yankin da ya rage ya kasance ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar \n * wanda yake daidai da ginshiƙai, ya wuce ta wurare tare da daidaitattun lambobi, \n * kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama \n * na takardar tare da wannan layin. Amsar ya kamata ta kasance modulo 10^9+7.\n *\n * Alal misali:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * एक आयताकार कागज जिसका आकार n x m है, को एक समतल कार्टेशियन निर्देशांक \n * प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर और ऊपरी-दायां कोना (n,m) पर है, \n * आपको कागज को इस तरह काटने के लिए अपेक्षित ऑपरेशनों की संख्या की गणना करनी है कि \n * शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है \n * जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, \n * और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज का निचला \n * या दायां हिस्सा फिर हटा दिया जाता है। उत्तर को 10^9+7 के मापांक में दिया जाना चाहिए।\n *\n * उदाहरण के लिए:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n x m méretű téglalap alakú papír, amely a síkbeli derékszögű koordináta-\n * rendszerben helyezkedik el úgy, hogy az alsó-bal sarka a (0,0) pontban, a felső-jobb \n * sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát, hogy \n * a papírt úgy vágjuk, hogy a megmaradt terület kisebb legyen, mint k. Minden műveletben \n * véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú \n * pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén \n * lévő alsó vagy jobb részét eldobja. Az eredménynek modulo 10^9+7 kell lennie.\n *\n * Például:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "0.9660014308301633",
      "hy": "0.9624952073441355",
      "bn": "0.9584687708901773",
      "bg": "0.9411152290206832",
      "zh": "0.9361250379579438",
      "fr": "0.9695155995314326",
      "de": "0.9548989856822183",
      "ha": "0.9457600018508031",
      "hi": "0.9516193994609512",
      "hu": "0.9309519083142711"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `long long expectedCuts(int n, int m, long long k)` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "sq": "Shkruani një funksion CPP `long long expectedCuts(int n, int m, long long k)` për të zgjidhur problemin në vijim:\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije më pas hidhet. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hy": "Գրեք CPP ֆունկցիա `long long expectedCuts(int n, int m, long long k)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային \nհամակարգում՝ իր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, \nպետք է հաշվարկել գործողությունների սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, \nորը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով, \nև կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը \nապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bn": "একটি CPP ফাংশন `long long expectedCuts(int n, int m, long long k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি আয়তাকার কাগজ যার আকার n x m, একটি সমতল কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে স্থাপন করা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, \nআপনাকে এমনভাবে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় \nযা অক্ষের সমান্তরাল, পূর্ণসংখ্যা কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্তকে স্পর্শ না করে)। এই লাইনের বরাবর কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোর সাথে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bg": "Напишете CPP функция `long long expectedCuts(int n, int m, long long k)`, за да решите следния проблем:\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "zh": "编写一个 CPP 函数 `long long expectedCuts(int n, int m, long long k)` 来解决以下问题：  \n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，  \n你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。每次操作中，随机选择一条与坐标轴平行的线，  \n该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。  \n答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "fr": "Écrire une fonction CPP `long long expectedCuts(int n, int m, long long k)` pour résoudre le problème suivant :  \nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes \navec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \nla surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \nqui est parallèle aux axes, passe par des points avec des coordonnées entières, \net coupe (ne se contentant pas de toucher le bord) le papier. La partie inférieure ou droite \ndu papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "de": "Schreiben Sie eine CPP-Funktion `long long expectedCuts(int n, int m, long long k)`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "ha": "Rubuta aikin CPP `long long expectedCuts(int n, int m, long long k)` don warware matsalar mai zuwa:\nAn ba da takarda murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian \ntare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), \ndole ne ka ƙididdige yawan ayyukan da ake tsammanin za a yanke takardar ta yadda \nyankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar \nwanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, \nkuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama \nna takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hi": "`long long expectedCuts(int n, int m, long long k)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \nजिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है। \nआपको कागज को इस प्रकार काटने के लिए आवश्यक ऑपरेशनों की अपेक्षित संख्या की गणना करनी है कि \nशेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है \nजो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, \nऔर कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां हिस्सा \nफिर त्याग दिया जाता है। उत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hu": "Írjon egy CPP függvényt `long long expectedCuts(int n, int m, long long k)` a következő probléma megoldására:\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordináta \nrendszerben van elhelyezve, alsó-bal sarkával a (0,0) pontban és a jobb-felső sarkával az (n,m) pontban. \nKi kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk, hogy a \nmegmaradó terület kisebb legyen, mint k. Minden művelet során egy véletlenszerűen választott vonal \npárhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. \nA papírnak a vonal mentén lévő alsó vagy jobb oldali része ezután eldobásra kerül. A válasznak modulo 10^9+7 formában kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9628102351284569",
      "hy": "0.9406675161418306",
      "bn": "0.9614951033756248",
      "bg": "0.9511957208582038",
      "zh": "0.9559547061574187",
      "fr": "0.9767644166569198",
      "de": "0.9612144386472226",
      "ha": "0.9631590300775541",
      "hi": "0.9534686483083861",
      "hu": "0.9383995544511743"
    },
    "level": "hard",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota, dhe e pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերին աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվարկել սպասվող գործողությունների քանակը թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այս գծի երկայնքով ստորին կամ աջ մասը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bn": "একটি আয়তাকার কাগজের টুকরো যার আকার n x m, একটি সমতল কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে রাখা আছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, তোমাকে সেই কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যার কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ করে না)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 এর মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触碰边缘）纸张。沿着这条线的纸张的底部或右侧部分将被丢弃。答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard qui est parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "de": "Angenommen, ein rechteckiges Papier der Größe n x m liegt auf einem kartesischen Koordinatensystem, wobei sich die untere linke Ecke bei (0,0) und die obere rechte Ecke bei (n,m) befindet. Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "ha": "An ba da takarda mai kusurwa huɗu mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, ya wuce ta wuraren da ke da daidaitawa na lamba, kuma ya yanke ta cikin (ba kawai taɓa gefen ba) takardar. Sashin ƙasa ko dama na takardar tare da wannan layin sai a yar da shi. Amsar ya kamata ta kasance modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hi": "दिए गए n x m आकार के आयताकार कागज को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसमें इसका निचला-बायाँ कोना (0,0) पर और ऊपरी-दायाँ कोना (n,m) पर है। आपको कागज को इस प्रकार काटने के लिए अपेक्षित ऑपरेशनों की संख्या की गणना करने की आवश्यकता है कि शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से होकर गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। इस रेखा के साथ कागज का निचला या दायाँ भाग फिर त्याग दिया जाता है। उत्तर 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hu": "Egy n x m méretű téglalap alakú papírt helyezünk el egy derékszögű koordináta-rendszerben úgy, hogy az alsó-bal sarok a (0,0) pontban van, a felső-jobb sarok pedig az (n,m) pontban. Számítsd ki a várható műveletek számát, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során egy véletlenszerűen kiválasztott vonal párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. Az eredményt a 10^9+7 modullal kell megadni.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9625287758785304",
      "hy": "0.9522115166268162",
      "bn": "0.9534382578600877",
      "bg": "0.9484625668151637",
      "zh": "0.9396827067126596",
      "fr": "0.9732246246364971",
      "de": "0.9553423286926882",
      "ha": "0.9429567312832577",
      "hi": "0.949767568418563",
      "hu": "0.9186471534699219"
    }
  },
  {
    "task_id": "CPP/43",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sq": "#include <bits/stdc++.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandryshueshme dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarjeje 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni atë në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hy": "#include <bits/stdc++.h>\n/*\nՈւնենալով n տարրերի q փոխատեղում և k ամբողջ թիվ, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն բաժանելով ճիշտ k չդատարկ հարակից հատվածների և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bn": "#include <bits/stdc++.h>\n/*\nn উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা ঠিক k টি খালি নয় এমন সংলগ্ন segment এ p কে ভাগ করে এবং প্রতিটি segment কে sort করে পাওয়া যেতে পারে (অর্থাৎ, k-1 টি breakpoint 1 <= x_1 < x_2 < ... < x_{k-1} < n বেছে নিন, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bg": "#include <bits/stdc++.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегменти и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "zh": "#include <bits/stdc++.h>\n/*\n给定一个 n 个元素的排列 q 和一个整数 k，找出有多少个 n 个元素的排列 p 满足 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序可以得到的字典序最小的排列（即，选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对 998244353 取模。\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "fr": "#include <bits/stdc++.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et divisez-le en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "de": "#include <bits/stdc++.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h., wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "ha": "#include <bits/stdc++.h>\n/*\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n da suke sa f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin lexicographically wanda za'a iya samu ta hanyar raba p zuwa daidai k sassa masu cike kuma masu ci gaba da juna sannan a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsayawa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma a raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya kasance modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hi": "#include <bits/stdc++.h>\n/*\nदी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें p ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hu": "#include <bits/stdc++.h>\n/*\nAdott egy q permutáció n elemről és egy egész szám k, meg kell találni azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek 998244353-mal vett maradéka kell legyen.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "sq": "0.9750853940460319",
      "hy": "0.9900476247582469",
      "bn": "0.989649370844272",
      "bg": "0.9964997354254032",
      "zh": "0.981296963321755",
      "fr": "0.9965146327039808",
      "de": "0.9946488975349201",
      "ha": "0.9540953271605511",
      "hi": "0.9935544441354178",
      "hu": "0.9556420619376698"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a CPP function `int countPermutations(int n, int k, int qq[])` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n",
      "sq": "Shkruani një funksion CPP `int countPermutations(int n, int k, int qq[])` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarjeje 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni atë në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hy": "Գրեք CPP ֆունկցիա `int countPermutations(int n, int k, int qq[])` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերի q փոխատեղում և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարող է ստացվել p-ն ճիշտ k չդատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bn": "একটি CPP ফাংশন `int countPermutations(int n, int k, int qq[])` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা ঠিক k টি খালি নয় এমন সংলগ্ন সেগমেন্টে p কে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে প্রাপ্ত হয় (অর্থাৎ, k-1 টি ব্রেকপয়েন্ট 1 <= x_1 < x_2 < ... < x_{k-1} < n নির্বাচন করুন, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bg": "Напишете CPP функция `int countPermutations(int n, int k, int qq[])`, за да решите следния проблем:  \nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "zh": "编写一个CPP函数 `int countPermutations(int n, int k, int qq[])` 来解决以下问题：  \n给定一个由n个元素组成的排列q和一个整数k，找到n个元素的排列p的数量，使得f(p) = q，其中f(p)是可以通过将p精确地划分为k个非空连续段并对每个段进行排序而获得的字典序最小的排列（即，选择k-1个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其划分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对998244353取模。\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "fr": "Écrire une fonction CPP `int countPermutations(int n, int k, int qq[])` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et le diviser en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "de": "Schreiben Sie eine CPP-Funktion `int countPermutations(int n, int k, int qq[])`, um das folgende Problem zu lösen:\nGegeben ist eine Permutation q von n Elementen und eine ganze Zahl k. Finden Sie die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wählen Sie k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teilen Sie es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "ha": "Rubuta aikin CPP `int countPermutations(int n, int k, int qq[])` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma cikakken lamba k, nemo yawan permutations p na abubuwa n irin waɗanda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba marasa komai kuma a tsara kowane sashe (wato, zaɓi k-1 wuraren tsagewa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya zama modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hi": "एक CPP फ़ंक्शन `int countPermutations(int n, int k, int qq[])` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों p की संख्या खोजें ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटा क्रमचय है जिसे p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात्, k-1 ब्रेकपॉइंट्स चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hu": "Írj egy CPP függvényt `int countPermutations(int n, int k, int qq[])` a következő probléma megoldására:\nAdott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kaphatunk meg, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válassz k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és oszd fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] szegmensekre). Az eredményt 998244353-mal vett maradékként kell megadni.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.985430660181472",
      "hy": "0.9907901051225554",
      "bn": "0.9841759120644746",
      "bg": "0.9975353942321191",
      "zh": "0.9980575935038598",
      "fr": "0.9975719422222296",
      "de": "0.9927642924796611",
      "ha": "0.9700463399095578",
      "hi": "0.9954720218339287",
      "hu": "0.97230198651659"
    },
    "level": "hard",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n",
      "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarëse 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն ճիշտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրում կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশন p-এর সংখ্যা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা p-কে ঠিক kটি খালি নয় এমন ক্রমাগত সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে প্রাপ্ত করা যায় (অর্থাৎ, k-1টি ব্রেকপয়েন্ট নির্বাচন করুন 1 <= x_1 < x_2 < ... < x_{k-1} < n, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো হবে।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序后可以得到的字典序最小的排列（即，选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对 998244353 取模。\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et le diviser en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "ha": "An ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n da suke cika f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba ba tare da komai ba kuma a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsayawa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya kasance modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hi": "दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के उन क्रमचयों की संख्या खोजें p, ताकि f(p) = q, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम को 998244353 से मापांकित किया जाना चाहिए।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hu": "Adott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek 998244353-mal vett maradéka kell legyen.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.972945548951143",
      "hy": "0.9905410226247376",
      "bn": "0.9842490080446954",
      "bg": "0.999999801369619",
      "zh": "0.9945108494201008",
      "fr": "0.9943724040445195",
      "de": "0.999999801369619",
      "ha": "0.9526790925437724",
      "hi": "0.999999801369619",
      "hu": "0.9602769032487379"
    }
  },
  {
    "task_id": "CPP/44",
    "prompt": {
      "en": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Given an array of n distinct integers representing the heights of Kira's friends, \n * find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \n * of the maximum and minimum values of the triplet is 1.\n * \n * Example usage:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "sq": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Duke pasur një varg me n numra të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës,\n * gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi\n * i tresheve të kenë përbashkët vetëm numrin 1 si pjesëtues të përbashkët më të madh (GCD).\n * \n * Shembull përdorimi:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "hy": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Տրված է n տարբեր ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\n * գտնել եղանակների քանակը, որոնցով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \n * ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n * \n * Օրինակ օգտագործում:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "bn": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * কিরার বন্ধুদের উচ্চতা উপস্থাপনকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\n * কত উপায়ে একটি ত্রয়ী (a, b, c) নির্বাচন করা যায় তা খুঁজে বের করুন যাতে ত্রয়ীর সর্বাধিক এবং ন্যূনতম মানের \n * সর্বাধিক সাধারণ গুণনীয়ক (GCD) 1 হয়।\n * \n * উদাহরণ ব্যবহার:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "bg": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\n * намерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД)\n * на максималната и минималната стойност на тройката да е 1.\n * \n * Пример за използване:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "zh": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * 给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，\n * 找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n * \n * 示例用法：\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "fr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\n * trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\n * des valeurs maximale et minimale du triplet soit 1.\n * \n * Exemple d'utilisation :\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "de": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen,\n * finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) auszuwählen, so dass der größte gemeinsame Teiler (GCD)\n * der maximalen und minimalen Werte des Tripels 1 ist.\n * \n * Beispielverwendung:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "ha": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * An ba da wani tsararren jerin lambobi na n waɗanda ke wakiltar tsayin abokan Kira,\n * nemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ke raba su (GCD)\n * na mafi girma da mafi ƙanƙanta na triplet ɗin ya zama 1.\n * \n * Misalin amfani:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "hi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * दिए गए n भिन्न पूर्णांकों की एक array, जो कि किरा के दोस्तों की ऊँचाईयों का प्रतिनिधित्व करती है, \n * में ऐसे triplet (a, b, c) चुनने के तरीकों की संख्या ज्ञात करें कि triplet के अधिकतम और न्यूनतम \n * मानों का महत्तम समापवर्तक (GCD) 1 हो।\n * \n * उदाहरण उपयोग:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "hu": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik, \n * meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas \n * maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n * \n * Példa használat:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)"
    },
    "prompt_bertscore": {
      "sq": "0.9563815628462627",
      "hy": "1",
      "bn": "0.9774808764413127",
      "bg": "0.9963424201636236",
      "zh": "0.9920412778926941",
      "fr": "0.9954972478923201",
      "de": "0.998394470630095",
      "ha": "0.9476185863261465",
      "hi": "0.951299207286723",
      "hu": "0.9653209231447378"
    },
    "canonical_solution": "{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a CPP function `int countTriplets(const std::vector<int>& heights)` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> countTriplets({1, 5, 7})\n1",
      "sq": "Shkruani një funksion CPP `int countTriplets(const std::vector<int>& heights)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg prej n numrash të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i vlerave të treshes të kenë përbashkëtësin më të madh (GCD) 1.\n\nShembull përdorimi:\n>>> countTriplets({1, 5, 7})\n1",
      "hy": "Գրեք CPP ֆունկցիա `int countTriplets(const std::vector<int>& heights)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարբեր ամբողջ թվերի զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները, գտնել եռյակ (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\nՕրինակ օգտագործում:\n>>> countTriplets({1, 5, 7})\n1",
      "bn": "একটি CPP ফাংশন `int countTriplets(const std::vector<int>& heights)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nকিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া আছে, ট্রিপলেট (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজে বের করুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইজর (GCD) 1 হয়।\n\nউদাহরণ ব্যবহার:\n>>> countTriplets({1, 5, 7})\n1",
      "bg": "Напишете CPP функция `int countTriplets(const std::vector<int>& heights)`, за да решите следния проблем:  \nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.",
      "zh": "编写一个 CPP 函数 `int countTriplets(const std::vector<int>& heights)` 来解决以下问题：  \n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n示例用法：\n>>> countTriplets({1, 5, 7})\n1",
      "fr": "Écrire une fonction CPP `int countTriplets(const std::vector<int>& heights)` pour résoudre le problème suivant :  \nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\nExemple d'utilisation :  \n>>> countTriplets({1, 5, 7})  \n1",
      "de": "Schreiben Sie eine CPP-Funktion `int countTriplets(const std::vector<int>& heights)`, um das folgende Problem zu lösen:\nGegeben ist ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen. Finden Sie die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\nBeispielverwendung:\n>>> countTriplets({1, 5, 7})\n1",
      "ha": "Rubuta aikin CPP `int countTriplets(const std::vector<int>& heights)` don warware matsalar mai zuwa:\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira, nemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ya raba su (GCD) na mafi girma da mafi ƙanƙanta ƙimomin triplet ɗin ya zama 1.\n\nMisalin amfani:\n>>> countTriplets({1, 5, 7})\n1",
      "hi": "`int countTriplets(const std::vector<int>& heights)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिरा के दोस्तों की ऊँचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है, ऐसे triplet (a, b, c) चुनने के तरीकों की संख्या ज्ञात करें ताकि triplet के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\nउदाहरण उपयोग:\n>>> countTriplets({1, 5, 7})\n1",
      "hu": "Írj egy CPP függvényt `int countTriplets(const std::vector<int>& heights)` a következő probléma megoldására:  \nAdott egy n különböző egész számot tartalmazó tömb, amely Kira barátainak magasságát jelképezi. Találd meg, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas legnagyobb és legkisebb értékének legnagyobb közös osztója (GCD) 1 legyen.\n\nPélda használat:\n>>> countTriplets({1, 5, 7})\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9762239433901239",
      "hy": "0.9953099394430042",
      "bn": "0.999999801369619",
      "bg": "0.9518297490344672",
      "zh": "0.988744212197896",
      "fr": "0.999999801369619",
      "de": "0.9875395189369194",
      "ha": "0.9717543625560768",
      "hi": "0.9883241089420072",
      "hu": "0.9775843628698319"
    },
    "level": "hard",
    "test": "int main() {\n    assert(countTriplets({1, 5, 7}) == 1);\n    assert(countTriplets({1, 6, 2, 3}) == 3);\n    assert(countTriplets({16, 4, 8, 2}) == 0);\n    assert(countTriplets({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77);\n    assert(countTriplets({4, 5, 9, 11, 14}) == 7);\n    assert(countTriplets({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104);\n    assert(countTriplets({3, 7, 11, 13}) == 4);\n    assert(countTriplets({5, 12, 13, 17, 19}) == 10);\n    assert(countTriplets({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87);\n    assert(countTriplets({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(const std::vector<int>& heights)",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> countTriplets({1, 5, 7})\n1",
      "sq": "Jepet një varg me n numra të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n\nShembull përdorimi:\n>>> countTriplets({1, 5, 7})\n1",
      "hy": "Տրված է n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները, գտնել եղանակների քանակը, որպեսզի ընտրել եռյակ (a, b, c), այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\nՕրինակ օգտագործում:\n>>> countTriplets({1, 5, 7})\n1",
      "bn": "একটি n ভিন্ন পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, ট্রিপলেট (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসার (GCD) 1 হয়।\n\nব্যবহারের উদাহরণ:\n>>> countTriplets({1, 5, 7})\n1",
      "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\nПример за използване:\n>>> countTriplets({1, 5, 7})\n1",
      "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n示例用法：\n>>> countTriplets({1, 5, 7})\n1",
      "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\nExemple d'utilisation :\n>>> countTriplets({1, 5, 7})\n1",
      "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\nBeispielverwendung:\n>>> countTriplets({1, 5, 7})\n1",
      "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokai na Kira, nemo adadin hanyoyin da za a zaɓi triplet (a, b, c) ta yadda mafi girman raba mai yawa (GCD) na mafi girma da ƙananan ƙimomi na triplet ɗin ya zama 1.\n\nMisalin amfani:\n>>> countTriplets({1, 5, 7})\n1",
      "hi": "n अद्वितीय पूर्णांकों की एक array दी गई है जो कि किरा के दोस्तों की ऊँचाई का प्रतिनिधित्व करती है, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\nउदाहरण उपयोग:\n>>> countTriplets({1, 5, 7})\n1",
      "hu": "Egy n különböző egész számot tartalmazó tömböt kapunk, amely Kira barátainak magasságát jelképezi. Meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\nPélda használat:\n>>> countTriplets({1, 5, 7})\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9864287778461723",
      "hy": "0.9869609086369647",
      "bn": "0.9806724694037813",
      "bg": "0.9964902011671135",
      "zh": "1",
      "fr": "0.993190751907743",
      "de": "0.9949095005948378",
      "ha": "0.9590922716562458",
      "hi": "0.9411891195224282",
      "hu": "0.9300709825743814"
    }
  },
  {
    "task_id": "CPP/45",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë\n * të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku\n * zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë\n * në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur\n * dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve\n * të kërkuara për t'i bërë të gjithë pikselët të së njëjtës ngjyrë.\n *\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n *\n * Shembuj:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ձեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, \n * որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, \n * որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները \n * ընտրված գույնով: Երկու պիքսելները միացված են, եթե նրանք հարակից են \n * և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, \n * որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n *\n * Նշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n *\n * Օրինակներ:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * আপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ \n * একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি \n * একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি \n * নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় \n * এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে করতে \n * প্রয়োজনীয় সর্বনিম্ন অপারেশন সংখ্যা খুঁজুন।\n *\n * নোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n *\n * উদাহরণ:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят,\n * представен чрез цяло число. Можете да извършите операция, при която \n * избирате цвят и променяте всички свързани пиксели със същия цвят на \n * избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят.\n * Намерете минималния брой операции, необходими, за да направите всички \n * пиксели с един и същ цвят.\n *\n * Забележка: За всеки цвят има най-много 20 пиксела с този цвят.\n *\n * Примери:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有相同颜色的相连像素更改为所选颜色。如果两个像素相邻并且具有相同的颜色，则它们是相连的。找出使所有像素颜色相同所需的最小操作次数。\n *\n * 注意：对于每种颜色，最多有 20 个该颜色的像素。\n *\n * 示例:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous avez une image de 1 par n pixels, où chaque pixel a une couleur \n * représentée par un entier. Vous pouvez effectuer une opération où vous \n * choisissez une couleur et changez tous les pixels connectés de la même \n * couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents \n * et ont la même couleur. Trouvez le nombre minimum d'opérations \n * nécessaires pour que tous les pixels aient la même couleur.\n *\n * Remarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n *\n * Exemples :\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Sie haben ein 1x n Pixel-Bild, wobei jedes Pixel eine Farbe hat, \n * die durch eine ganze Zahl dargestellt wird. Sie können eine \n * Operation durchführen, bei der Sie eine Farbe auswählen und alle \n * verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. \n * Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe \n * Farbe haben. Finden Sie die minimale Anzahl von Operationen, die \n * erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n *\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n *\n * Beispiele:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba ku hoto na pixel 1 ta n, inda kowanne pixel yana da launi \n * wanda aka wakilta da lamba. Kuna iya aiwatar da aiki inda za ku \n * zaɓi launi kuma ku canza duk pixels masu haɗin kai na wannan launi \n * zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna makwabtaka \n * kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake \n * buƙata don sanya duk pixels su zama launi ɗaya.\n *\n * Lura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.\n *\n * Misalai:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आपको एक 1 बाय n पिक्सल छवि दी गई है, जहां प्रत्येक पिक्सल का रंग \n * एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहां आप \n * एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल्स को चुने गए रंग में \n * बदल देते हैं। दो पिक्सल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और \n * उनका रंग समान होता है। सभी पिक्सल्स को एक ही रंग में बदलने के लिए \n * आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n *\n * ध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n *\n * उदाहरण:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy 1 x n pixeles kép, ahol minden pixel színe egy egész \n * számmal van ábrázolva. Végrehajthatsz egy műveletet, amely során \n * kiválasztasz egy színt, és az összes összekapcsolt, azonos színű \n * pixelt megváltoztatod a választott színre. Két pixel akkor \n * kapcsolódik egymáshoz, ha szomszédosak és azonos színűek. Találd \n * meg a minimális műveletek számát, amely szükséges ahhoz, hogy \n * minden pixel azonos színű legyen.\n *\n * Megjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n *\n * Példák:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "sq": "0.9872590528388981",
      "hy": "0.9784589324375285",
      "bn": "0.9881880471309983",
      "bg": "0.9753495724528083",
      "zh": "0.9466776742111843",
      "fr": "0.9841475079199866",
      "de": "0.9808428942707091",
      "ha": "0.971458999179478",
      "hi": "0.9668116441544047",
      "hu": "0.9507569463464978"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "en": "Write a CPP function `int minOperations(int n, int* pixels)` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2\n",
      "sq": "Shkruani një funksion CPP `int minOperations(int n, int* pixels)` për të zgjidhur problemin e mëposhtëm:\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hy": "Գրեք CPP ֆունկցիա `int minOperations(int n, int* pixels)`՝ լուծելու հետևյալ խնդիրը:\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսել միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "bn": "একটি CPP ফাংশন `int minOperations(int n, int* pixels)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সংযুক্ত সমস্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেল একই রঙের করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nদ্রষ্টব্য: প্রতিটি রঙের জন্য, সর্বাধিক 20টি পিক্সেল সেই রঙের হতে পারে।\n\nউদাহরণ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "bg": "Напишете CPP функция `int minOperations(int n, int* pixels)`, за да решите следния проблем:\nДадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели от същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "zh": "编写一个 CPP 函数 `int minOperations(int n, int* pixels)` 来解决以下问题：  \n给定一个 1 x n 的像素图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有相同颜色的连接像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "fr": "Écrire une fonction CPP `int minOperations(int n, int* pixels)` pour résoudre le problème suivant :  \nOn vous donne une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour rendre tous les pixels de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "de": "Schreiben Sie eine CPP-Funktion `int minOperations(int n, int* pixels)`, um das folgende Problem zu lösen:\nSie haben ein 1 mal n Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "ha": "Rubuta aikin CPP `int minOperations(int n, int* pixels)` don warware matsalar mai zuwa:  \nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyukan da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai aƙalla pixels 20 na wannan launi.\n\nMisalai:  \n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hi": "एक CPP फ़ंक्शन `int minOperations(int n, int* pixels)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको 1 बाई n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सलों को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सलों को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hu": "Írj egy CPP függvényt `int minOperations(int n, int* pixels)` a következő probléma megoldására:\nAdott egy 1 x n pixeles kép, ahol minden pixel színe egy egész számmal van reprezentálva. Végrehajthatsz egy műveletet, amely során kiválasztasz egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatod a kiválasztott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Találd meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel van abból a színből.\n\nPéldák:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2"
    },
    "instruction_bertscore": {
      "sq": "0.9782275280436228",
      "hy": "0.9826887664016664",
      "bn": "0.9636317703844172",
      "bg": "0.9852604339449251",
      "zh": "0.9652676902026205",
      "fr": "0.9923155864489033",
      "de": "0.9883064308380951",
      "ha": "0.9751960311682684",
      "hi": "0.9737605294045292",
      "hu": "0.9692913458312442"
    },
    "level": "hard",
    "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2\n",
      "sq": "Ju jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hy": "Դուք տրված եք 1 x n պիքսել պատկերի հետ, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում բոլոր միացված պիքսելները նույն գույնով դեպի ընտրված գույնը։ Երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը։ Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը։\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել այդ գույնով։\n\nՕրինակներ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ রয়েছে যা একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং তাদের একই রঙ থাকে। সমস্ত পিক্সেলকে একই রঙে করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nনোট: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "bg": "Дадено е изображение с размери 1 на n пиксела, където всеки пиксел има цвят, представен чрез цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "zh": "你有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，即选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "de": "Du hast ein 1x n Pixel-Bild, wobei jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "ha": "An ba ku hoto mai pixel 1 ta n, inda kowane pixel yana da launi da aka wakilta da lamba. Kuna iya aiwatar da aiki inda kuke ɗaukar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launi da aka zaɓa. Pixels biyu suna da alaƙa idan suna kusa da juna kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Ga kowane launi, akwai mafi yawan pixels 20 na wannan launi.\n\nMisalai:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hi": "आपको 1 बाई n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहां आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या खोजें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hu": "Egy 1 x n pixel méretű képet kapunk, ahol minden pixel színét egy egész szám képviseli. Végrehajthatunk egy olyan műveletet, amely során kiválasztunk egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatjuk a választott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. Határozzuk meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színből legfeljebb 20 pixel található.\n\nPéldák:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2"
    },
    "docstring_bertscore": {
      "sq": "0.9799133040874659",
      "hy": "0.9832069930657864",
      "bn": "0.9965915026614414",
      "bg": "0.9757792099669867",
      "zh": "0.9481751486538063",
      "fr": "0.9795674885940842",
      "de": "0.9793372759824647",
      "ha": "0.993378854878583",
      "hi": "0.9770285950636962",
      "hu": "0.9496577258178507"
    }
  },
  {
    "task_id": "CPP/46",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * @brief Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n *\n * Counts each number only once even if it is a multiple of both 3 and 5.\n * For example:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n The upper bound of the range to check for multiples.\n * @return The sum of the multiples of either 3 or 5 within the range.\n */\nint sumOfMultiples(int n)",
      "sq": "#include <cassert>\n#include <iostream>\n/**\n * @brief Llogarit shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n *\n * Numëron secilin numër vetëm një herë edhe nëse është shumëfish i të dyve, 3 dhe 5.\n * Për shembull:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n * @return Shuma e shumëfishave të 3 ose 5 brenda intervalit.\n */\nint sumOfMultiples(int n)",
      "hy": "#include <cassert>\n#include <iostream>\n/**\n * @brief Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։\n *\n * Յուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\n * Օրինակ:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Բազմապատիկների ստուգման միջակայքի վերին սահմանը։\n * @return 3-ի կամ 5-ի բազմապատիկների գումարը տվյալ միջակայքում։\n */\nint sumOfMultiples(int n)",
      "bn": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n *\n * প্রতিটি সংখ্যাকে কেবল একবার গণনা করা হয়, এমনকি যদি এটি 3 এবং 5 উভয়ের গুণিতক হয়।\n * উদাহরণস্বরূপ:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n গুণিতক পরীক্ষা করার জন্য সীমার উপরের সীমানা।\n * @return সীমার মধ্যে 3 বা 5 এর গুণিতকের যোগফল।\n */\nint sumOfMultiples(int n)",
      "bg": "#include <cassert>\n#include <iostream>\n/**\n * @brief Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n *\n * Всяко число се брои само веднъж, дори ако е кратно и на 3, и на 5.\n * Например:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Горната граница на диапазона за проверка на кратни.\n * @return Сумата на кратните на 3 или 5 в диапазона.\n */\nint sumOfMultiples(int n)",
      "zh": "#include <cassert>\n#include <iostream>\n/**\n * @brief 计算从 1 到 n 的所有 3 或 5 的倍数的和。\n *\n * 每个数字只计算一次，即使它是 3 和 5 的倍数。\n * 例如:\n *     @code\n *     std::cout << sumOfMultiples(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 要检查倍数的范围上限。\n * @return 范围内 3 或 5 的倍数的和。\n */\nint sumOfMultiples(int n)",
      "fr": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n *\n * Compte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\n * Par exemple :\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n La limite supérieure de la plage à vérifier pour les multiples.\n * @return La somme des multiples de 3 ou 5 dans la plage.\n */\nint sumOfMultiples(int n)",
      "de": "#include <cassert>\n#include <iostream>\n/**\n * @brief Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n *\n * Zählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\n * Zum Beispiel:\n *     @code\n *     std::cout << sumOfMultiples(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n * @return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.\n */\nint sumOfMultiples(int n)",
      "ha": "#include <cassert>\n#include <iostream>\n/**\n * @brief Lissafi jimillar dukkan lambobi daga 1 zuwa n waɗanda suke lambobi masu yawa na 3 ko 5.\n *\n * Yana ƙidaya kowace lamba sau ɗaya kawai ko da kuwa tana lambobi masu yawa na 3 da 5 duka.\n * Alal misali:\n *     @code\n *     std::cout << sumOfMultiples(10); // Fitarwa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Ƙarshen iyaka na zangon da za a duba lambobi masu yawa.\n * @return Jimillar lambobi masu yawa na 3 ko 5 a cikin zangon.\n */\nint sumOfMultiples(int n)",
      "hi": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n *\n * प्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\n * उदाहरण के लिए:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n गुणजों की जांच के लिए सीमा का ऊपरी बिंदु।\n * @return 3 या 5 के गुणजों का सीमा के भीतर योग।\n */\nint sumOfMultiples(int n)",
      "hu": "#include <cassert>\n#include <iostream>\n/**\n * @brief Kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei.\n *\n * Minden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\n * Például:\n *     @code\n *     std::cout << sumOfMultiples(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n A tartomány felső határa, amelyet ellenőrizni kell a többszörösök szempontjából.\n * @return A 3 vagy 5 többszöröseinek összege a tartományon belül.\n */\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9810802575760459",
      "hy": "0.9731991999477246",
      "bn": "0.981274120827936",
      "bg": "0.9794622144921357",
      "zh": "0.956725193405453",
      "fr": "0.9823475194070485",
      "de": "0.9785753298408149",
      "ha": "0.97703892384351",
      "hi": "0.9737355019765188",
      "hu": "0.9769751634911978"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a CPP function `int sumOfMultiples(int n)` to solve the following problem:\nComputes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.",
      "sq": "Shkruani një funksion CPP `int sumOfMultiples(int n)` për të zgjidhur problemin e mëposhtëm:\nLlogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n\nNumëroni çdo numër vetëm një herë edhe nëse është shumëfish i të dyjave 3 dhe 5.\nPër shembull:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n@return Shuma e shumëfishave të 3 ose 5 brenda intervalit.",
      "hy": "Գրեք CPP ֆունկցիա `int sumOfMultiples(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի:\n\nՅուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի:\nՕրինակ:\n    std::cout << sumOfMultiples(10); // Արդյունք: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Շրջանակի վերին սահմանը, որտեղ պետք է ստուգել բազմապատիկները:\n@return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջանակում:",
      "bn": "একটি CPP ফাংশন `int sumOfMultiples(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা ৩ বা ৫ এর গুণিতক।\n\nপ্রতিটি সংখ্যাকে কেবল একবার গণনা করে, এমনকি যদি এটি ৩ এবং ৫ উভয়ের গুণিতক হয়।\nউদাহরণস্বরূপ:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n গুণিতক চেক করার জন্য পরিসরের উপরের সীমা।\n@return পরিসরের মধ্যে ৩ বা ৫ এর গুণিতকগুলোর যোগফল।",
      "bg": "Напишете CPP функция `int sumOfMultiples(int n)`, за да решите следния проблем:\nИзчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n\nБрои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\nНапример:\n    std::cout << sumOfMultiples(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Горната граница на диапазона за проверка на кратни.\n@return Сумата на кратните на 3 или 5 в рамките на диапазона.",
      "zh": "编写一个 CPP 函数 `int sumOfMultiples(int n)` 来解决以下问题：\n\n计算从 1 到 n 的所有数字中是 3 或 5 的倍数的总和。\n\n即使一个数字同时是 3 和 5 的倍数，也只计算一次。\n例如：\n    std::cout << sumOfMultiples(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 要检查倍数的范围上限。\n@return 范围内 3 或 5 的倍数的总和。",
      "fr": "Écrire une fonction CPP `int sumOfMultiples(int n)` pour résoudre le problème suivant :\nCalcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou de 5.\n\nCompte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\nPar exemple :\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n La limite supérieure de la plage à vérifier pour les multiples.\n@return La somme des multiples de 3 ou 5 dans la plage.",
      "de": "Schreiben Sie eine CPP-Funktion `int sumOfMultiples(int n)`, um das folgende Problem zu lösen:\nBerechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n\nZählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\nZum Beispiel:\n    std::cout << sumOfMultiples(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n@return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.",
      "ha": "Rubuta aikin CPP `int sumOfMultiples(int n)` don warware matsalar mai zuwa:  \nLissafa jimillar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5.\n\nKirga kowace lamba sau ɗaya kawai ko da kuwa tana mai yawa ne na 3 da 5 duka.  \nAlal misali:  \n    std::cout << sumOfMultiples(10); // Yana fitarwa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Ƙarshen iyaka na zangon da za a duba don masu yawa.  \n@return Jimillar masu yawa na ko dai 3 ko 5 a cikin zangon.",
      "hi": "`int sumOfMultiples(int n)` नामक एक CPP फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन सभी संख्याओं का योग गणना करता है जो 1 से n तक हैं और 3 या 5 के गुणज हैं।\n\nप्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\nउदाहरण के लिए:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n वह ऊपरी सीमा है जिसकी सीमा में गुणजों की जांच की जानी है।\n@return 3 या 5 के गुणजों का सीमा के भीतर योग।",
      "hu": "Írj egy CPP függvényt `int sumOfMultiples(int n)` a következő probléma megoldására:\nKiszámítja az összes szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei.\n\nMinden számot csak egyszer számol, még akkor is, ha mind 3, mind 5 többszöröse.\nPéldául:\n    std::cout << sumOfMultiples(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n A tartomány felső határa, amelyben a többszörösöket ellenőrizzük.\n@return A 3 vagy 5 többszöröseinek összege a tartományon belül."
    },
    "instruction_bertscore": {
      "sq": "0.9715193828153126",
      "hy": "0.9521829138519472",
      "bn": "0.9610650686006843",
      "bg": "0.9795027350898667",
      "zh": "0.9535153264479292",
      "fr": "0.9716780884897595",
      "de": "0.974573920814867",
      "ha": "0.9782495760159177",
      "hi": "0.9471980858094957",
      "hu": "0.9691699826684319"
    },
    "level": "easy",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "en": "Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.",
      "sq": "Llogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n\nNumëron secilin numër vetëm një herë edhe nëse është shumëfish i të dyjave, 3 dhe 5.\nPër shembull:\n    std::cout << sumOfMultiples(10); // Shfaq: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n@return Shuma e shumëfishëve të 3 ose 5 brenda intervalit.",
      "hy": "Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են կամ 3-ի, կամ 5-ի։\n\nՅուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\nՕրինակ՝\n    std::cout << sumOfMultiples(10); // Արդյունք՝ 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Շրջանակի վերին սահմանը բազմապատիկների ստուգման համար։\n@return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջանակում։",
      "bn": "1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n\nপ্রতিটি সংখ্যাকে কেবল একবার গণনা করা হয়, এমনকি যদি এটি 3 এবং 5 উভয়ের গুণিতক হয়।\nউদাহরণস্বরূপ:\n    std::cout << sumOfMultiples(10); // আউটপুট: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n গুণিতক চেক করার জন্য পরিসরের উপরের সীমা।\n@return পরিসরের মধ্যে 3 বা 5 এর গুণিতকের যোগফল।",
      "bg": "Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n\nБрои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\nНапример:\n    std::cout << sumOfMultiples(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Горната граница на диапазона за проверка на кратни.\n@return Сумата на кратните на 3 или 5 в рамките на диапазона.",
      "zh": "计算从 1 到 n 的所有 3 或 5 的倍数的和。\n\n即使一个数字同时是 3 和 5 的倍数，也只计算一次。\n例如：\n    std::cout << sumOfMultiples(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 要检查倍数的范围上限。\n@return 范围内 3 或 5 的倍数之和。",
      "fr": "Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n\nCompte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\nPar exemple :\n    std::cout << sumOfMultiples(10); // Affiche : 33 (3 + 5 + 6 + 9 + 10)\n\n@param n La limite supérieure de la plage à vérifier pour les multiples.\n@return La somme des multiples de 3 ou 5 dans la plage.",
      "de": "Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n\nZählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\nZum Beispiel:\n    std::cout << sumOfMultiples(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n@return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.",
      "ha": "Lissafi jimillar dukkan lambobi daga 1 zuwa n waɗanda suke lambobi masu yawa na 3 ko 5.\n\nYana ƙididdige kowanne lamba sau ɗaya kawai ko da kuwa yana ninkawa ne na 3 da 5.\nMisali:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Babban iyaka na zangon da za a duba don ninkawa.\n@return Jimillar lambobin da suke ninkawa na ko dai 3 ko 5 a cikin zangon.",
      "hi": "1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n\nप्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\nउदाहरण के लिए:\n    std::cout << sumOfMultiples(10); // आउटपुट: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n वह ऊपरी सीमा है जिस रेंज में गुणजों की जांच की जानी है।\n@return उस रेंज के भीतर 3 या 5 के गुणजों का योग।",
      "hu": "Számítja az 1-től n-ig terjedő összes szám összegét, amelyek 3 vagy 5 többszörösei.\n\nMinden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\nPéldául:\n    std::cout << sumOfMultiples(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n A tartomány felső határa, amelyet a többszörösök ellenőrzésére használunk.\n@return A 3 vagy 5 többszöröseinek összege a tartományon belül."
    },
    "docstring_bertscore": {
      "sq": "0.9538182377790074",
      "hy": "0.9603253690617104",
      "bn": "0.4126509564317408",
      "bg": "0.9722012809134053",
      "zh": "0.9278127537723958",
      "fr": "0.9562345763642969",
      "de": "0.9651296420878013",
      "ha": "0.9217157942265298",
      "hi": "0.9357802156164672",
      "hu": "0.9591453059679821"
    }
  },
  {
    "task_id": "CPP/47",
    "prompt": {
      "en": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).\n * Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "sq": "#include <cassert>\n#include <cctype> // Për isalnum dhe tolower\n#include <cstring> // Për strlen\n/**\n * Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë,\n * numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe\n * prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\n * Shembuj:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "hy": "#include <cassert>\n#include <cctype> // isalnum և tolower-ի համար\n#include <cstring> // strlen-ի համար\n/**\n * Սահմանել, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ, արտահայտություն,\n * թիվ կամ այլ նիշերի հաջորդականություն է, որը կարդացվում է նույն կերպ առաջ\n * և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը)։\n * Օրինակներ:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "bn": "#include <cassert>\n#include <cctype> // isalnum এবং tolower এর জন্য\n#include <cstring> // strlen এর জন্য\n/**\n * নির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ,\n * সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং\n * পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * উদাহরণ:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "bg": "#include <cassert>\n#include <cctype> // За isalnum и tolower\n#include <cstring> // За strlen\n/**\n * Определя дали даден низ е палиндром. Палиндром е дума, фраза,\n * число или друга последователност от символи, която се чете еднакво напред и\n * назад (като се игнорират интервали, пунктуация и главни букви).\n * Примери:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "zh": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 确定给定字符串是否为回文。回文是指正反读都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n * 示例:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "fr": "#include <cassert>\n#include <cctype> // Pour isalnum et tolower\n#include <cstring> // Pour strlen\n/**\n * Détermine si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase,\n * un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et\n * à l'envers (en ignorant les espaces, la ponctuation et les majuscules).\n * Exemples :\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "de": "#include <cassert>\n#include <cctype> // Für isalnum und tolower\n#include <cstring> // Für strlen\n/**\n * Bestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz,\n * eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird\n * (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n * Beispiele:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "ha": "#include <cassert>\n#include <cctype> // Don amfani da isalnum da tolower\n#include <cstring> // Don amfani da strlen\n/**\n * Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla,\n * lamba, ko wata jerin haruffa da ake karantawa iri ɗaya a gaba da baya\n * (ba tare da la'akari da sarari, rubutun alama, da manyan ba).\n * Misalai:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "hi": "#include <cassert>\n#include <cctype> // isalnum और tolower के लिए\n#include <cstring> // strlen के लिए\n/**\n * यह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश,\n * संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ता है \n * (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n * उदाहरण:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "hu": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Határozza meg, hogy egy adott string palindróm-e. Egy palindróm egy szó, kifejezés,\n * szám vagy más karakterek sorozata, amely előre és hátrafelé olvasva is ugyanaz\n * (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n * Példák:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9913937428505204",
      "bn": "0.9944304041157818",
      "bg": "0.9936791840147078",
      "zh": "0.9820269299720581",
      "fr": "0.9943644588292782",
      "de": "0.9843109807235784",
      "ha": "0.9825006634308263",
      "hi": "0.9647949498957574",
      "hu": "0.997050736102394"
    },
    "canonical_solution": "{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "en": "Write a CPP function `bool isPalindrome(const char* str)` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "sq": "Shkruani një funksion CPP `bool isPalindrome(const char* str)` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).  \nShembuj:  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false",
      "hy": "Գրեք CPP ֆունկցիա `bool isPalindrome(const char* str)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է, որը նույն կերպ է կարդացվում առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\nՕրինակներ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "bn": "একটি CPP ফাংশন `bool isPalindrome(const char* str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরগুলির ক্রম যা সামনের দিক থেকে এবং পিছনের দিক থেকে একইভাবে পড়া যায় (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\nউদাহরণ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "bg": "Напишете CPP функция `bool isPalindrome(const char* str)` за решаване на следния проблем:  \nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).  \nПримери:  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false",
      "zh": "编写一个 CPP 函数 `bool isPalindrome(const char* str)` 来解决以下问题：  \n确定给定的字符串是否是回文。回文是一个单词、短语、数字或其他字符序列，正向和反向读取时相同（忽略空格、标点和大小写）。  \n示例：  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false",
      "fr": "Écrire une fonction CPP `bool isPalindrome(const char* str)` pour résoudre le problème suivant :  \nDéterminer si une chaîne de caractères donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).  \nExemples :  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false  ",
      "de": "Schreiben Sie eine CPP-Funktion `bool isPalindrome(const char* str)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\nBeispiele:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "ha": "Rubuta aikin CPP `bool isPalindrome(const char* str)` don warware matsalar mai zuwa: Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karanta iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\nMisalai:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hi": "एक CPP फ़ंक्शन `bool isPalindrome(const char* str)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ा जाता है (स्पेस, विराम चिह्न और बड़े अक्षरों को नजरअंदाज करते हुए)।\nउदाहरण:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hu": "Írj egy CPP függvényt `bool isPalindrome(const char* str)` a következő probléma megoldására:  \nHatározd meg, hogy egy adott string palindróm-e. Egy palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).  \nPéldák:  \n  >>> isPalindrome(\"racecar\")  \n  true  \n  >>> isPalindrome(\"hello\")  \n  false"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9969466537827317",
      "bn": "0.9977123739016212",
      "bg": "0.9991323824956396",
      "zh": "0.984867344420857",
      "fr": "1",
      "de": "0.9944907877516164",
      "ha": "1",
      "hi": "0.959132990884358",
      "hu": "1"
    },
    "level": "middle",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\nShembuj:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hy": "Սահմանել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույնը առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\nՕրինակներ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\nПримери:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "zh": "确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n\n示例：\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\nExemples :\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorieren von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\nBeispiele:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "ha": "Gano idan wata kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\nMisalai:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्थान, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm egy olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és visszafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n\nPéldák:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9955097616063253",
      "bn": "0.9971901746298805",
      "bg": "1",
      "zh": "0.9971901746298805",
      "fr": "1",
      "de": "0.9926339909497022",
      "ha": "0.9862764283439185",
      "hi": "0.9585901340529897",
      "hu": "0.9990139987885428"
    }
  },
  {
    "task_id": "CPP/48",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/*\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n*/\nint addDigits(int num)",
      "sq": "#include <cassert>\n#include <cstdio>\n/*\nDuke pasur një numër jo-negativ, kjo funksion e redukton atë në një shifër të vetme duke shtuar vazhdimisht të gjitha shifrat e tij.\nPër shembull:\n    >>> addDigits(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.\n*/\nint addDigits(int num)",
      "hy": "#include <cassert>\n#include <cstdio>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն կրճատում է մինչև մեկանիշ թվի՝ բազմիցս գումարելով նրա բոլոր թվանշանները:\nՕրինակ:\n    >>> addDigits(38)\n    2\nՀաշվարկը հետևյալն է, քանի որ 3 + 8 = 11, և հետագա 1 + 1 = 2։ 2-ը վերադարձվում է, քանի որ այն մեկանիշ թիվ է:\n*/\nint addDigits(int num)",
      "bn": "#include <cassert>\n#include <cstdio>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি তার সমস্ত অঙ্ক যোগ করে একক অঙ্কে কমিয়ে দেয়।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\nগণনা করা হয় কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় কারণ এটি একটি একক অঙ্কের সংখ্যা।\n*/\nint addDigits(int num)",
      "bg": "#include <cassert>\n#include <cstdio>\n/*\nДадено е неотрицателно цяло число num, тази функция го свежда до едноцифрено число, като многократно събира всичките му цифри.\nНапример:\n    >>> addDigits(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. 2 се връща, тъй като е едноцифрено число.\n*/\nint addDigits(int num)",
      "zh": "#include <cassert>\n#include <cstdio>\n/*\n给定一个非负整数 num，此函数通过反复相加其所有数字将其减少到一位数字。\n例如：\n    >>> addDigits(38)\n    2\n计算过程是因为 3 + 8 = 11，进一步 1 + 1 = 2。返回 2，因为它是一个一位数。\n*/\nint addDigits(int num)",
      "fr": "#include <cassert>\n#include <cstdio>\n/*\nÉtant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> addDigits(38)\n    2\nLe calcul est parce que 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.\n*/\nint addDigits(int num)",
      "de": "#include <cassert>\n#include <cstdio>\n/*\nGegeben eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einstellige Zahl, indem sie wiederholt alle ihre Ziffern addiert.\nZum Beispiel:\n    >>> addDigits(38)\n    2\nDie Berechnung erfolgt, weil 3 + 8 = 11, und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.\n*/\nint addDigits(int num)",
      "ha": "#include <cassert>\n#include <cstdio>\n/*\nAn ba da wani lamba mara kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar ci gaba da ƙara duk lambobinsa.\nMisali:\n    >>> addDigits(38)\n    2\nLissafin yana nufin 3 + 8 = 11, kuma gaba 1 + 1 = 2. 2 an dawo da shi tunda lamba guda ce.\n*/\nint addDigits(int num)",
      "hi": "#include <cassert>\n#include <cstdio>\n/*\nदिए गए गैर-ऋणात्मक पूर्णांक num को इस फ़ंक्शन के माध्यम से एकल अंक में घटाया जाता है, इसके सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\nगणना इस प्रकार है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2. 2 लौटाया जाता है क्योंकि यह एकल अंक संख्या है।\n*/\nint addDigits(int num)",
      "hu": "#include <cassert>\n#include <cstdio>\n/*\nEgy nem negatív egész számot megadva, ez a függvény egyetlen számjegyre redukálja azáltal, hogy ismételten összeadja az összes számjegyét.\nPéldául:\n    >>> addDigits(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "sq": "0.9852636120310216",
      "hy": "0.9711368207014394",
      "bn": "0.9850566391739833",
      "bg": "0.9792623923288146",
      "zh": "0.9736939882268825",
      "fr": "0.9892721717506867",
      "de": "0.982663540343275",
      "ha": "0.9629228585545037",
      "hi": "0.9708196079829267",
      "hu": "0.9946854455250306"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "Write a CPP function `int addDigits(int num)` to solve the following problem:\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n",
      "sq": "Shkruani një funksion CPP `int addDigits(int num)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër jo-negativ num, ky funksion e redukton atë në një shifër të vetme duke mbledhur përsëri të gjitha shifrat e tij.  \nPër shembull:  \n    >>> addDigits(38)  \n    2  \nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.  ",
      "hy": "Գրեք CPP ֆունկցիա `int addDigits(int num)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև մեկանիշ թիվ՝ անընդհատ գումարելով դրա բոլոր թվանշանները:\nՕրինակ:\n    >>> addDigits(38)\n    2\nՀաշվարկը հետևյալն է՝ 3 + 8 = 11, և հետագայում 1 + 1 = 2։ 2-ը վերադարձվում է, քանի որ այն մեկանիշ թիվ է։",
      "bn": "একটি CPP ফাংশন `int addDigits(int num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি এর সমস্ত অঙ্ক যোগ করে বারবার একটি একক অঙ্কে হ্রাস করে।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\nগণনাটি কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় যেহেতু এটি একটি একক-অঙ্কের সংখ্যা।",
      "bg": "Напишете CPP функция `int addDigits(int num)`, за да решите следния проблем:  \nДадено е неотрицателно цяло число num, тази функция го намалява до едноцифрено число, като многократно събира всичките му цифри.  \nНапример:  \n    >>> addDigits(38)  \n    2  \nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. Връща се 2, тъй като е едноцифрено число.",
      "zh": "编写一个 CPP 函数 `int addDigits(int num)` 来解决以下问题：  \n给定一个非负整数 num，此函数通过重复相加其所有数字将其减少到一位数字。  \n例如：  \n    >>> addDigits(38)  \n    2  \n计算过程是因为 3 + 8 = 11，然后 1 + 1 = 2。返回 2 因为它是一个一位数。  ",
      "fr": "Écrire une fonction CPP `int addDigits(int num)` pour résoudre le problème suivant :\nÉtant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> addDigits(38)\n    2\nLe calcul est parce que 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.",
      "de": "Schreiben Sie eine CPP-Funktion `int addDigits(int num)`, um das folgende Problem zu lösen:\nGegeben ist eine nicht-negative ganze Zahl num, diese Funktion reduziert sie auf eine einzelne Ziffer, indem sie wiederholt alle ihre Ziffern addiert.\nZum Beispiel:\n    >>> addDigits(38)\n    2\nDie Berechnung ist, weil 3 + 8 = 11, und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.",
      "ha": "Rubuta aikin CPP `int addDigits(int num)` don magance matsalar mai zuwa:  \nAn ba da lamba marar kyau num, wannan aikin yana rage ta zuwa lamba guda ta hanyar ci gaba da ƙara duk lambobinta.  \nMisali:  \n    >>> addDigits(38)  \n    2  \nLissafin yana nufin 3 + 8 = 11, kuma gaba 1 + 1 = 2. 2 an dawo da shi saboda lamba guda ce.  ",
      "hi": "एक CPP फ़ंक्शन `int addDigits(int num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num को, यह फ़ंक्शन इसे एकल अंक में घटा देता है, इसके सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2। 2 लौटाया जाता है क्योंकि यह एक एकल-अंक संख्या है।",
      "hu": "Írj egy CPP függvényt `int addDigits(int num)` a következő probléma megoldására:  \nAdott egy nem negatív egész szám, num, ez a függvény egyetlen számjegyre redukálja azáltal, hogy ismételten összeadja az összes számjegyét.  \nPéldául:  \n    >>> addDigits(38)  \n    2  \nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám."
    },
    "instruction_bertscore": {
      "sq": "0.9816401966201832",
      "hy": "0.9483543132574997",
      "bn": "0.9792051867790765",
      "bg": "0.9762767790714791",
      "zh": "0.9673403982287195",
      "fr": "0.9894209459060819",
      "de": "0.998024223599846",
      "ha": "0.9624449538577337",
      "hi": "0.9973190857471721",
      "hu": "0.9906965502130879"
    },
    "level": "easy",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n",
      "sq": "Duke pasur një numër të plotë jo-negativ num, kjo funksion e redukton atë në një shifër të vetme duke shtuar përsëri të gjitha shifrat e tij.\nPër shembull:\n    >>> addDigits(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև մեկանիշ թիվ՝ բազմիցս գումարելով նրա բոլոր թվանշանները:\nՕրինակ:\n    >>> addDigits(38)\n    2\nՀաշվարկը հետևյալն է, քանի որ 3 + 8 = 11, և հետագայում 1 + 1 = 2: Վերադարձվում է 2, քանի որ այն մեկանիշ թիվ է:",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি তার সমস্ত অঙ্ক যোগ করে বারবার একক অঙ্কে কমিয়ে আনে। উদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\nগণনা করা হয় কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় কারণ এটি একটি একক অঙ্কের সংখ্যা।",
      "bg": "Дадено е неотрицателно цяло число num, тази функция го свежда до едноцифрено число чрез многократно събиране на всичките му цифри.\nНапример:\n    >>> addDigits(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. 2 се връща, тъй като е едноцифрено число.",
      "zh": "给定一个非负整数 num，此函数通过反复相加其所有位数将其减少到一位数字。\n例如：\n    >>> addDigits(38)\n    2\n计算过程是因为 3 + 8 = 11，然后 1 + 1 = 2。返回 2 因为它是一位数字。",
      "fr": "Étant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en additionnant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> addDigits(38)\n    2\nLe calcul est le suivant : 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.",
      "de": "Gegeben ist eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einzelne Ziffer, indem sie wiederholt alle ihre Ziffern addiert.  \nZum Beispiel:  \n    >>> addDigits(38)  \n    2  \nDie Berechnung ist, weil 3 + 8 = 11, und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.",
      "ha": "An ba da wani lamba mara kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar ƙara duk lambobinsa akai-akai.\nMisali:\n    >>> addDigits(38)\n    2\nLissafin yana saboda 3 + 8 = 11, sannan kuma 1 + 1 = 2. 2 yana dawowa saboda yana lamba guda.",
      "hi": "एक गैर-ऋणात्मक पूर्णांक num दिया गया है, यह फ़ंक्शन इसे एकल अंक तक घटाता है, इसके सभी अंकों को बार-बार जोड़कर।\n\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\n\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2। 2 वापस किया जाता है क्योंकि यह एक एकल-अंक संख्या है।",
      "hu": "Adott egy nem negatív egész szám, ez a függvény egy számjegyre csökkenti azáltal, hogy ismételten összeadja az összes számjegyét.\nPéldául:\n    >>> addDigits(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2-t ad vissza, mivel ez egy egyjegyű szám."
    },
    "docstring_bertscore": {
      "sq": "0.9970598730999216",
      "hy": "0.9470425582211454",
      "bn": "0.9507942888581323",
      "bg": "0.9745725304021998",
      "zh": "0.95925236774336",
      "fr": "0.9661515953982257",
      "de": "0.9963799613056392",
      "ha": "0.9267842456593971",
      "hi": "0.977511465519992",
      "hu": "0.9747892361479089"
    }
  },
  {
    "task_id": "CPP/49",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\n * your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\n * stone wins the game. Given the number of stones n, determine if you can win the game if both you\n * and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe\n * kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit\n * fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju\n * ashtu edhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë e merrni lëvizjen e parë.\n *\n * Ja disa raste:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերից բաղկացած կույտով, և դուք ու ձեր\n * մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին\n * քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր\n * մրցակիցը խաղում եք օպտիմալ կերպով։\n * Նշում: Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա մի քանի դեպքեր:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * তুমি একটি Nim নামক খেলা খেলছো। এই খেলায়, তুমি n পাথর দিয়ে শুরু করো, এবং তুমি ও\n * তোমার প্রতিপক্ষ পালাক্রমে ১ থেকে ৩ পাথর পাইল থেকে সরিয়ে নাও। যে শেষ পাথরটি সরায়\n * সে খেলাটি জিতে যায়। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করো তুমি খেলাটি জিততে পারবে কিনা যদি\n * তুমি এবং তোমার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলে।\n * নোট: তুমি সবসময় প্রথম পালা নাও।\n *\n * এখানে কিছু উদাহরণ:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият\n * противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне\n * последния камък, печели играта. Като се има предвид броят на камъните n, определете дали\n * можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\n * Забележка: Винаги вие правите първия ход.\n *\n * Ето някои случаи:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式进行游戏，你是否能赢得比赛。\n * 注意：你总是先走。\n *\n * 这里有一些情况：\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et\n * votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière\n * pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et\n * votre adversaire jouez de manière optimale.\n * Remarque : Vous prenez toujours le premier tour.\n *\n * Voici quelques cas :\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und\n * dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten\n * Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du\n * als auch dein Gegner optimal spielen.\n * Hinweis: Du machst immer den ersten Zug.\n *\n * Hier sind einige Fälle:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Kuna wasa da wani wasa mai suna Nim. A cikin wannan wasa, kuna farawa da tarin duwatsu n, ku da\n * abokin hamayyarku kuna juyawa don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na karshe\n * shi ne ya ci wasan. An ba da adadin duwatsu n, tantance idan za ku iya cin wasan idan ku duka\n * ku da abokin hamayyarku kuna wasa da kyau.\n * Lura: Kullum kuna fara juyawa.\n *\n * Ga wasu lokuta:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और\n * आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों अनुकूल रूप से खेलते हैं।\n * ध्यान दें: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te valamint\n * az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó\n * követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha mind te,\n * mind az ellenfeled optimálisan játszik.\n * Megjegyzés: Mindig te kezded az első lépést.\n *\n * Íme néhány eset:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9926345868408453",
      "hy": "0.9785401722633718",
      "bn": "0.9729640215765794",
      "bg": "0.9790063577676607",
      "zh": "0.9722614659188589",
      "fr": "0.9911607494135665",
      "de": "0.9883691980385021",
      "ha": "0.983945103561712",
      "hi": "0.9872812994415741",
      "hu": "0.979799886139895"
    },
    "canonical_solution": "{\n    return n % 4 != 0;\n}",
    "instruction": {
      "en": "Write a CPP function `bool canWinNim(int n)` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Shkruani një funksion CPP `bool canWinNim(int n)` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë e merrni lëvizjen e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Գրեք CPP ֆունկցիա `bool canWinNim(int n)` հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim կոչվող խաղը: Այս խաղում դուք սկսում եք n քարերից բաղկացած կույտով, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից: Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը: Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով:\nՆշում: Դուք միշտ առաջինն եք խաղում:\n\nԱհա որոշ դեպքեր:\n    >>> canWinNim(1)\n    true",
      "bn": "একটি CPP ফাংশন `bool canWinNim(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে 1 থেকে 3 পাথর পাইল থেকে সরিয়ে নেন। যে শেষ পাথরটি সরায় সে গেমটি জিতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nএখানে কিছু উদাহরণ দেওয়া হলো:\n    >>> canWinNim(1)\n    true",
      "bg": "Напишете CPP функция `bool canWinNim(int n)`, за да решите следния проблем:\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Като се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "编写一个 CPP 函数 `bool canWinNim(int n)` 来解决以下问题：  \n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，如果你和你的对手都采取最优策略，确定你是否能赢得游戏。  \n注意：你总是先手。  \n\n以下是一些情况：  \n    >>> canWinNim(1)  \n    true  ",
      "fr": "Écrivez une fonction CPP `bool canWinNim(int n)` pour résoudre le problème suivant :  \nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle de 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :  \n    >>> canWinNim(1)  \n    true  ",
      "de": "Schreiben Sie eine CPP-Funktion `bool canWinNim(int n)`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen.\nHinweis: Sie sind immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Rubuta aikin CPP `bool canWinNim(int n)` don warware matsalar mai zuwa:\nKana wasa da ake kira Nim. A cikin wannan wasan, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. Idan aka ba da adadin duwatsu n, tantance ko zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa cikin hikima.\nLura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:",
      "hi": "एक CPP फ़ंक्शन `bool canWinNim(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहां कुछ उदाहरण हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Írj egy CPP függvényt `bool canWinNim(int n)` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha te és az ellenfeled is optimálisan játszotok.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "instruction_bertscore": {
      "sq": "0.9921531067972167",
      "hy": "0.9818006899680594",
      "bn": "0.9783000281327006",
      "bg": "0.9868635797502576",
      "zh": "0.9808709011544351",
      "fr": "0.992381928996169",
      "de": "0.9865566958115588",
      "ha": "0.9561010967482414",
      "hi": "0.9851889270077525",
      "hu": "0.980494496582374"
    },
    "level": "easy",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտով, և դուք և ձեր հակառակորդը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջին հերթն եք կատարում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true",
      "bn": "তুমি একটি গেম খেলছো যার নাম নিম। এই গেমে, তুমি n সংখ্যক পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিপক্ষ পালাক্রমে পাথরের স্তূপ থেকে ১ থেকে ৩টি পাথর সরিয়ে নাও। যে শেষ পাথরটি সরায় সে গেমটি জেতে। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করো তুমি গেমটি জিততে পারবে কিনা যদি তুমি এবং তোমার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলে।\nনোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ এখানে:\n    >>> canWinNim(1)\n    true",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.  \nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。\n注意：你总是先走。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer am Zug.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna yin juyi don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da adadin duwatsu n, tantance ko zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne koyaushe kake fara juyi.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम रूप से खेलते हैं तो क्या आप खेल जीत सकते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik.\nMegjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9740578790849385",
      "bn": "0.9702268949259185",
      "bg": "0.9781613841267381",
      "zh": "0.9759559910061079",
      "fr": "0.9757365044350643",
      "de": "0.9948342196804256",
      "ha": "0.9846158783584669",
      "hi": "0.9867195727240073",
      "hu": "0.9646823264697106"
    }
  },
  {
    "task_id": "CPP/50",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\n * Examples:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose produktin e a dhe b nëse shuma është tek.\n * Shembuj:\n *    evenSumOrOddProduct(2, 3) kthen 6\n *    evenSumOrOddProduct(5, 5) kthen 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *    evenSumOrOddProduct(2, 3) վերադարձնում է 6\n *    evenSumOrOddProduct(5, 5) վերադարձնում է 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফলটি যদি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণ:\n *    evenSumOrOddProduct(2, 3) 6 ফেরত দেয়\n *    evenSumOrOddProduct(5, 5) 10 ফেরত দেয়\n */\nint evenSumOrOddProduct(int a, int b)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\n * Примери:\n *    evenSumOrOddProduct(2, 3) връща 6\n *    evenSumOrOddProduct(5, 5) връща 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定两个整数 a 和 b，如果它们的和是偶数则返回和，如果和是奇数则返回 a 和 b 的乘积。\n * 例子:\n *    evenSumOrOddProduct(2, 3) 返回 6\n *    evenSumOrOddProduct(5, 5) 返回 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\n * Exemples :\n *    evenSumOrOddProduct(2, 3) retourne 6\n *    evenSumOrOddProduct(5, 5) retourne 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\n * Beispiele:\n *    evenSumOrOddProduct(2, 3) gibt 6 zurück\n *    evenSumOrOddProduct(5, 5) gibt 10 zurück\n */\nint evenSumOrOddProduct(int a, int b)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da lambobi biyu a da b, dawo da jumlar idan jumlar tana da lamba mai lamba, ko samfurin a da b idan jumlar tana da lamba mai lamba.\n * Misalai:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए दो पूर्णांक a और b के लिए, योग को लौटाएं यदि योग सम है, या a और b का गुणनफल यदि योग विषम है।\n * उदाहरण:\n *    evenSumOrOddProduct(2, 3) 6 लौटाता है\n *    evenSumOrOddProduct(5, 5) 10 लौटाता है\n */\nint evenSumOrOddProduct(int a, int b)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Két egész szám, a és b esetén térjen vissza az összeggel, ha az összeg páros, vagy a és b szorzatával, ha az összeg páratlan.\n * Példák:\n *    evenSumOrOddProduct(2, 3) visszatér 6\n *    evenSumOrOddProduct(5, 5) visszatér 10\n */\nint evenSumOrOddProduct(int a, int b)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.9880025263551118",
      "bg": "0.999999801369619",
      "zh": "0.980198735945013",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9632436466198749",
      "hi": "0.983437602938168",
      "hu": "0.9882730609340812"
    },
    "canonical_solution": "{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "en": "Write a CPP function `int evenSumOrOddProduct(int a, int b)` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sq": "Shkruani një funksion CPP `int evenSumOrOddProduct(int a, int b)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose produktin e a dhe b nëse shuma është tek.  \nShembuj:  \nevenSumOrOddProduct(2, 3) kthen 6  \nevenSumOrOddProduct(5, 5) kthen 10",
      "hy": "Գրեք CPP ֆունկցիա `int evenSumOrOddProduct(int a, int b)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\nevenSumOrOddProduct(2, 3) վերադարձնում է 6\nevenSumOrOddProduct(5, 5) վերադարձնում է 10",
      "bn": "একটি CPP ফাংশন `int evenSumOrOddProduct(int a, int b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফল যদি জোড় হয় তবে যোগফল ফেরত দিন, অথবা যদি যোগফল বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণসমূহ:\nevenSumOrOddProduct(2, 3) 6 ফেরত দেয়\nevenSumOrOddProduct(5, 5) 10 ফেরত দেয়",
      "bg": "Напишете CPP функция `int evenSumOrOddProduct(int a, int b)` за решаване на следния проблем:  \nДадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.  \nПримери:  \nevenSumOrOddProduct(2, 3) връща 6  \nevenSumOrOddProduct(5, 5) връща 10",
      "zh": "编写一个 CPP 函数 `int evenSumOrOddProduct(int a, int b)` 来解决以下问题：\n给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n示例：\nevenSumOrOddProduct(2, 3) 返回 6\nevenSumOrOddProduct(5, 5) 返回 10",
      "fr": "Écrire une fonction CPP `int evenSumOrOddProduct(int a, int b)` pour résoudre le problème suivant :  \nÉtant donné deux entiers a et b, retourner la somme si la somme est paire, ou le produit de a et b si la somme est impaire.  \nExemples :  \nevenSumOrOddProduct(2, 3) retourne 6  \nevenSumOrOddProduct(5, 5) retourne 10",
      "de": "Schreiben Sie eine CPP-Funktion `int evenSumOrOddProduct(int a, int b)`, um das folgende Problem zu lösen:  \nGegeben sind zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.  \nBeispiele:  \nevenSumOrOddProduct(2, 3) gibt 6 zurück  \nevenSumOrOddProduct(5, 5) gibt 10 zurück",
      "ha": "Rubuta aikin CPP `int evenSumOrOddProduct(int a, int b)` don warware matsalar mai zuwa:  \nAn ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma samfurin a da b idan jumlar tana da lamba mai waje.  \nMisalai:  \nevenSumOrOddProduct(2, 3) yana dawowa 6  \nevenSumOrOddProduct(5, 5) yana dawowa 10",
      "hi": "एक CPP फ़ंक्शन `int evenSumOrOddProduct(int a, int b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\nउदाहरण:\nevenSumOrOddProduct(2, 3) 6 लौटाता है\nevenSumOrOddProduct(5, 5) 10 लौटाता है",
      "hu": "Írj egy CPP függvényt `int evenSumOrOddProduct(int a, int b)` a következő probléma megoldására:\nAdott két egész szám, a és b, add vissza az összeget, ha az összeg páros, vagy a és b szorzatát, ha az összeg páratlan.\nPéldák:\nevenSumOrOddProduct(2, 3) visszaadja 6\nevenSumOrOddProduct(5, 5) visszaadja 10"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9956170220120841",
      "bg": "1",
      "zh": "0.9644791275899119",
      "fr": "1",
      "de": "0.9976917163419936",
      "ha": "0.9699881412079147",
      "hi": "0.9936883210122354",
      "hu": "0.9946153290005252"
    },
    "level": "easy",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose prodhimin e a dhe b nëse shuma është tek.\nShembuj:\nevenSumOrOddProduct(2, 3) kthen 6\nevenSumOrOddProduct(5, 5) kthen 10",
      "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\nevenSumOrOddProduct(2, 3) վերադարձնում է 6\nevenSumOrOddProduct(5, 5) վերադարձնում է 10",
      "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণ:\nevenSumOrOddProduct(2, 3) 6 ফেরত দেয়\nevenSumOrOddProduct(5, 5) 10 ফেরত দেয়",
      "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\nПримери:\nevenSumOrOddProduct(2, 3) връща 6\nevenSumOrOddProduct(5, 5) връща 10",
      "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n\n示例：\nevenSumOrOddProduct(2, 3) 返回 6\nevenSumOrOddProduct(5, 5) 返回 10",
      "fr": "Étant donnés deux entiers a et b, renvoyez la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\nExemples :\nevenSumOrOddProduct(2, 3) renvoie 6\nevenSumOrOddProduct(5, 5) renvoie 10",
      "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\nBeispiele:\nevenSumOrOddProduct(2, 3) gibt 6 zurück\nevenSumOrOddProduct(5, 5) gibt 10 zurück",
      "ha": "An ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma samfurin a da b idan jumlar tana da lamba mai wauta.\nMisalai:\nevenSumOrOddProduct(2, 3) yana dawowa 6\nevenSumOrOddProduct(5, 5) yana dawowa 10",
      "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n\nउदाहरण:\nevenSumOrOddProduct(2, 3) 6 लौटाता है\nevenSumOrOddProduct(5, 5) 10 लौटाता है",
      "hu": "Két egész szám, a és b megadása esetén térjen vissza az összeggel, ha az összeg páros, vagy a és b szorzatával, ha az összeg páratlan.\nPéldák:\nevenSumOrOddProduct(2, 3) visszatér 6\nevenSumOrOddProduct(5, 5) visszatér 10"
    },
    "docstring_bertscore": {
      "sq": "0.9993671636060228",
      "hy": "0.9915693321073552",
      "bn": "0.9902456592481387",
      "bg": "1",
      "zh": "0.9439685544442494",
      "fr": "1",
      "de": "1",
      "ha": "0.9533327851277582",
      "hi": "0.9321017795900821",
      "hu": "0.9838841240347344"
    }
  }
]