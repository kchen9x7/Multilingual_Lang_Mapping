[
  {
    "task_id": "Python/1",
    "prompt": {
      "en": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "sq": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n    pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "hy": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ստուգել, արդյոք տրված թվերի ցուցակում կան որևէ երկու թվեր, որոնք միմյանցից ավելի մոտ են,\n    քան տրված շեմը:\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "bn": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে\n    কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "bg": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Проверете дали в дадения списък от числа има някакви две числа, които са по-близо едно до друго\n    от дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "zh": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "fr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Vérifie si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que\n    le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "de": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n    der gegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "ha": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Duba idan a cikin jerin lambobin da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n    ƙayyadadden tazara.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "hi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के अधिक निकट हैं\n    दिए गए सीमा से।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "hu": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ellenőrizze, hogy a megadott számok listájában van-e bármelyik két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9855113041161722",
      "hy": "0.972877220100067",
      "bn": "0.978701261502391",
      "bg": "0.972877220100067",
      "zh": "0.9610205753953325",
      "fr": "0.9756588399560796",
      "de": "0.9841683641099953",
      "ha": "0.9636327635363223",
      "hi": "0.9853490230948666",
      "hu": "0.9654116972288708"
    },
    "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False",
    "instruction": {
      "en": "Write a python function 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' to solve the following problem:\n Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "sq": "Shkruani një funksion python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' për të zgjidhur problemin e mëposhtëm:\n Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n    pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "hy": "Պայթոն ֆունկցիա 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n Ստուգեք, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ ավելի մոտ են միմյանց, քան\n    տրված շեմը։\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "bn": "একটি পাইথন ফাংশন 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n প্রদত্ত সংখ্যার তালিকায় পরীক্ষা করুন, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "bg": "Напишете Python функция 'def has_close_elements(numbers: List[float], threshold: float) -> bool:', за да решите следния проблем:\n Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от\n    дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "zh": "编写一个Python函数 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' 来解决以下问题：\n 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "fr": "Écrivez une fonction python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' pour résoudre le problème suivant :\n Vérifiez si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "de": "Schreiben Sie eine Python-Funktion 'def has_close_elements(numbers: List[float], threshold: float) -> bool:', um das folgende Problem zu lösen:\n Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "ha": "Rubuta wani aikin python 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' don warware matsalar mai zuwa:\n Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da suke kusa da juna fiye da\n    iyakar da aka bayar.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "hi": "एक पायथन फ़ंक्शन 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n जांचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएं एक-दूसरे के जितनी करीब हैं उतनी जितनी दी गई सीमा है।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "hu": "Írj egy python függvényt 'def has_close_elements(numbers: List[float], threshold: float) -> bool:' a következő probléma megoldására:\n Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    "
    },
    "instruction_bertscore": {
      "sq": "0.9859727224913162",
      "hy": "0.9804929075393257",
      "bn": "0.9807102091761779",
      "bg": "0.9740407968721694",
      "zh": "0.9648090526528109",
      "fr": "0.978598966856158",
      "de": "0.9831605135566243",
      "ha": "0.9761663405796238",
      "hi": "0.9653886561046707",
      "hu": "0.9719400819623445"
    },
    "level": "easy",
    "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:",
    "docstring": {
      "en": " Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "sq": " Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "hy": " Ստուգեք, արդյոք տրված թվերի ցուցակում կան որևէ երկու թվեր, որոնք միմյանց ավելի մոտ են, քան տրված շեմը։\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "bn": " প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি দেওয়া থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "bg": " Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "zh": " 检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "fr": " Vérifiez si, dans une liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "de": " Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "ha": " Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n    ƙayyadadden ƙima.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "hi": " दिए गए संख्याओं की सूची में जांचें, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    ",
      "hu": " Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám közelebb egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9660411569063704",
      "hy": "0.9605861707520092",
      "bn": "0.9424182443202721",
      "bg": "0.959087504527101",
      "zh": "0.9332353631746482",
      "fr": "0.9641676751524493",
      "de": "0.9534718263944826",
      "ha": "0.9538192309309126",
      "hi": "0.9486451081353349",
      "hu": "0.9576200232720152"
    }
  },
  {
    "task_id": "Python/2",
    "prompt": {
      "en": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "sq": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Hyrja në këtë funksion është një varg që përmban grupe të shumta të kllapave të brendshme. Qëllimi juaj është të\n    ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të brendshme brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "hy": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Այս ֆունկցիայի մուտքը տող է, որը պարունակում է մի քանի խմբեր ներդրված փակագծերով: Ձեր նպատակը\n    այդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցուցակը:\n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ ներդրված չեն:\n    Անտեսեք մուտքագրված տողի ցանկացած բացատ:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "bn": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল \n    সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং সেগুলোর তালিকা ফেরত দেওয়া।\n    আলাদা গ্রুপগুলো সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়।\n    ইনপুট স্ট্রিংয়ের যেকোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "bg": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Входът за тази функция е низ, съдържащ няколко групи вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списък с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали в входния низ.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "zh": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" 此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成独立的字符串，并返回这些字符串的列表。\n    分离的组是平衡的（每个开括号都有正确的闭合）并且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "fr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n    séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n    Les groupes séparés sont équilibrés (chaque parenthèse ouverte est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n    Ignorez tous les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "de": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n    diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt.\n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "ha": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Shigar wannan aikin shine wani igiya wanda ke dauke da kungiyoyi da yawa na kowane nau'in kowane nau'in baka. Manufarka ita ce\n    raba waɗannan kungiyoyin zuwa igiyoyi daban-daban kuma dawo da jerin waɗannan.\n    Kungiyoyi daban-daban suna daidaitawa (kowace buɗaɗɗen baka an rufe ta daidai) kuma ba a haɗa su cikin juna ba\n    Yi watsi da duk wani sarari a cikin igiyar shigar.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "hi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों की नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है \n    उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उनकी सूची लौटाना।\n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n    इनपुट स्ट्रिंग में किसी भी स्पेस को नजरअंदाज करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "hu": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több csoportba rendezett, egymásba ágyazott zárójelet tartalmaz. A cél az,\n    hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját.\n    A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n    Figyelmen kívül hagyja a bemeneti karakterláncban lévő szóközöket.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9469468183774865",
      "hy": "0.9376139712941813",
      "bn": "0.9440724381335307",
      "bg": "0.9382865337643654",
      "zh": "0.9268174169330299",
      "fr": "0.9484252243035292",
      "de": "0.9523169893591458",
      "ha": "0.9232466385731658",
      "hi": "0.944700904659125",
      "hu": "0.928503391607254"
    },
    "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result",
    "instruction": {
      "en": "Write a python function 'def separate_paren_groups(paren_string: str) -> List[str]:' to solve the following problem:\n Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "sq": "Shkruani një funksion python 'def separate_paren_groups(paren_string: str) -> List[str]:' për të zgjidhur problemin e mëposhtëm:\n Hyrja në këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të\n    ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "hy": "Պայթոն ֆունկցիա 'def separate_paren_groups(paren_string: str) -> List[str]:' գրեք հետևյալ խնդիրը լուծելու համար:\n Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խմբեր: Ձեր նպատակն է\n    այդ խմբերը առանձնացնել առանձին տողերի մեջ և վերադարձնել դրանց ցուցակը:\n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և միմյանց մեջ ներդրված չեն:\n    Անտեսեք մուտքագրված տողի ցանկացած բացատ:\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "bn": "একটি পাইথন ফাংশন 'def separate_paren_groups(paren_string: str) -> List[str]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\nএই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল \n    সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং তাদের তালিকা ফেরত দেওয়া।\n    আলাদা গ্রুপগুলো সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়।\n    ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "bg": "Напишете Python функция 'def separate_paren_groups(paren_string: str) -> List[str]:' за решаване на следния проблем:\n Входът за тази функция е низ, съдържащ множество групи от вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списъка с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали във входния низ.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "zh": "编写一个Python函数 'def separate_paren_groups(paren_string: str) -> List[str]:' 来解决以下问题：\n\n    此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串并返回这些字符串的列表。\n    分离的组是平衡的（每个开放括号都正确关闭）并且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "fr": "Écrivez une fonction python 'def separate_paren_groups(paren_string: str) -> List[str]:' pour résoudre le problème suivant :\n L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n    séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n    Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n    Ignorez tous les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "de": "Schreiben Sie eine Python-Funktion 'def separate_paren_groups(paren_string: str) -> List[str]:' um das folgende Problem zu lösen:\n Die Eingabe dieser Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n    diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer ist korrekt geschlossen) und nicht ineinander verschachtelt.\n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "ha": "Rubuta wani aikin python 'def separate_paren_groups(paren_string: str) -> List[str]:' don warware matsalar mai zuwa:\n Shigar da wannan aikin shi ne wani igiyar rubutu mai dauke da rukuni da dama na kowane irin baka. Burinka shi ne\n    raba wadannan rukuni zuwa igiyoyi daban-daban kuma dawo da jerin su.\n    Rukunan da aka raba suna daidaita (kowace buɗewa tana da rufewa daidai) kuma ba a nannade su cikin juna ba\n    Yi watsi da duk wani sarari a cikin igiyar shigarwa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "hi": "एक पायथन फ़ंक्शन 'def separate_paren_groups(paren_string: str) -> List[str]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों की नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n    उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उनकी सूची लौटाएं।\n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n    इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "hu": "Írj egy Python függvényt 'def separate_paren_groups(paren_string: str) -> List[str]:', hogy megoldja a következő problémát:\n Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A célod az,\n    hogy ezeket a csoportokat külön karakterláncokra bontsd, és visszaadd ezek listáját.\n    A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n    Hagyd figyelmen kívül a bemeneti karakterláncban lévő szóközöket.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    "
    },
    "instruction_bertscore": {
      "sq": "0.9480951006102493",
      "hy": "0.9365681823380326",
      "bn": "0.9474527299579824",
      "bg": "0.947336729815458",
      "zh": "0.9362680518322889",
      "fr": "0.9502593772420054",
      "de": "0.9536819773376175",
      "ha": "0.9314963541886878",
      "hi": "0.9496903012003404",
      "hu": "0.9442873562058104"
    },
    "level": "hard",
    "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)",
    "entry_point": "separate_paren_groups",
    "signature": "def separate_paren_groups(paren_string: str) -> List[str]:",
    "docstring": {
      "en": " Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "sq": " Hyrja për këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e veçanta janë të balancuara (çdo kllapë e hapur është mbyllur si duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "hy": " Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խումբ։ Ձեր նպատակն է այդ խմբերը բաժանել առանձին տողերի և վերադարձնել դրանց ցուցակը։  \n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և միմյանց մեջ չեն ներդրված։  \n    Անտեսեք մուտքային տողի ցանկացած բացատ։  \n    >>> separate_paren_groups('( ) (( )) (( )( ))')  \n    ['()', '(())', '(()())']\n    ",
      "bn": " এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গোষ্ঠীর নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল সেই গোষ্ঠীগুলিকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং তাদের তালিকা ফেরত দেওয়া।\n    পৃথক গোষ্ঠীগুলি সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়\n    ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "bg": " Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списък с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали в входния низ.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "zh": " 函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。\n    分离的组是平衡的（每个打开的括号都有正确的闭合）且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "fr": " L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci. Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres. Ignorez tous les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "de": " Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben. \n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird korrekt geschlossen) und nicht ineinander verschachtelt. \n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
      "ha": " Shigar da wannan aikin shine wani kirtani wanda ya ƙunshi rukuni da yawa na zoben baka da aka nannade. Manufarka ita ce\n    raba waɗannan rukunin zuwa kirtani daban-daban kuma dawo da jerin waɗannan.\n    Rukuni daban-daban suna daidaitawa (kowace buɗaɗɗen baka an rufe ta daidai) kuma ba a nannade su cikin juna ba\n    Yi watsi da duk wani sarari a cikin kirtanin shigarwa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "hi": " इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उन स्ट्रिंग्स की सूची लौटाना है। \n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं। \n    इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    ",
      "hu": " A függvény bemenete egy olyan karakterlánc, amely több, egymásba ágyazott zárójelet tartalmaz. A cél az, hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját. A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva. Figyelmen kívül hagyjuk a bemeneti karakterláncban lévő szóközöket. >>> separate_paren_groups('( ) (( )) (( )( ))') ['()', '(())', '(()())']\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9238826530532395",
      "hy": "0.925069866840685",
      "bn": "0.9316419502579864",
      "bg": "0.9249371817461537",
      "zh": "0.9129911533699534",
      "fr": "0.9281246034706205",
      "de": "0.9436747801106988",
      "ha": "0.9049662873457629",
      "hi": "0.928964611352017",
      "hu": "0.9176240083772111"
    }
  },
  {
    "task_id": "Python/3",
    "prompt": {
      "en": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "sq": "def truncate_number(number: float) -> float:\n    \"\"\" Duke dhënë një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n    pjesën e plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetoret\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthen pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "hy": "def truncate_number(number: float) -> float:\n    \"\"\" Տրված դրական տասնորդական թիվը կարելի է բաժանել ամբողջ մասի \n    (ամենամեծ ամբողջ թիվը, որը փոքր է տրված թվից) և տասնորդականների \n    (մնացորդային մասը, որը միշտ փոքր է 1-ից):\n    \n    Վերադարձնել թվի տասնորդական մասը:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "bn": "def truncate_number(number: float) -> float:\n    \"\"\" একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্টাংশ যা সর্বদা 1-এর চেয়ে ছোট) বিভক্ত করা যায়।\n    \n    সংখ্যার দশমিক অংশটি ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "bg": "def truncate_number(number: float) -> float:\n    \"\"\" Дадено е положително число с плаваща запетая, което може да бъде \n    разложено на цяла част (най-голямото цяло число, по-малко от даденото число) и \n    десетична част (остатък, който винаги е по-малък от 1).\n    \n    Връща десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "zh": "def truncate_number(number: float) -> float:\n    \"\"\" 给定一个正浮点数，它可以被分解为整数部分（小于给定数的最大整数）和小数部分（总是小于1的剩余部分）。\n    \n    返回该数的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "fr": "def truncate_number(number: float) -> float:\n    \"\"\" Étant donné un nombre flottant positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retourne la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "de": "def truncate_number(number: float) -> float:\n    \"\"\" Gegeben eine positive Fließkommazahl, kann sie in einen ganzzahligen \n    Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen \n    (Restteil, der immer kleiner als 1 ist) zerlegt werden.\n    \n    Gibt den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "ha": "def truncate_number(number: float) -> float:\n    \"\"\" An ba da lamba mai yawo mai kyau, za a iya raba shi zuwa\n    wani ɓangare na cikakken lamba (mafi girman cikakken lamba ƙasa da lambar da aka bayar) da kuma ragowar\n    (ɓangaren da ya rage koyaushe ƙasa da 1).\n    \n    Mayar da ɓangaren ragowar lambar.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "hi": "def truncate_number(number: float) -> float:\n    \"\"\" दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) \n    और दशमलव में विभाजित किया जा सकता है (हमेशा 1 से छोटा बचा हुआ भाग)।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "hu": "def truncate_number(number: float) -> float:\n    \"\"\" Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n    (a maradék rész mindig kisebb, mint 1).\n    \n    Visszaadja a szám tizedes részét.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9375164437770932",
      "hy": "0.905900843288532",
      "bn": "0.9190672567258107",
      "bg": "0.9108354178445818",
      "zh": "0.9228910901911133",
      "fr": "0.9629584133927088",
      "de": "0.9313088471089909",
      "ha": "0.9120448782347033",
      "hi": "0.9204882584717342",
      "hu": "0.9222745414883811"
    },
    "canonical_solution": "    return number % 1.0",
    "instruction": {
      "en": "Write a python function 'def truncate_number(number: float) -> float:' to solve the following problem:\n Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "sq": "Shkruani një funksion python 'def truncate_number(number: float) -> float:' për të zgjidhur problemin e mëposhtëm:\n Duke pasur një numër pozitiv me pikë lundruese, ai mund të dekompozohet në\n    një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthe pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "hy": "Պայթոն ֆունկցիա 'def truncate_number(number: float) -> float:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Տրված դրական լողացող կետով թիվը կարելի է բաժանել\n    ամբողջ մասի (տրված թվից փոքր ամենամեծ ամբողջ թիվը) և տասնորդական մասի\n    (մնացորդային մասը միշտ փոքր է 1-ից):\n\n    Վերադարձնել թվի տասնորդական մասը:\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "bn": "একটি পাইথন ফাংশন 'def truncate_number(number: float) -> float:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (দেওয়া সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n    \n    সংখ্যার দশমিক অংশটি ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "bg": "Напишете Python функция 'def truncate_number(number: float) -> float:', за да решите следния проблем:\n Дадено е положително число с плаваща запетая, което може да бъде разложено на\n    цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n    (оставаща част, винаги по-малка от 1).\n    \n    Върнете десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "zh": "编写一个Python函数 'def truncate_number(number: float) -> float:' 来解决以下问题：\n\n 给定一个正浮点数，它可以分解为整数部分（小于给定数的最大整数）和小数部分（剩余部分总是小于1）。\n    \n 返回该数的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "fr": "Écrivez une fonction python 'def truncate_number(number: float) -> float:' pour résoudre le problème suivant :\n Étant donné un nombre à virgule flottante positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retournez la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "de": "Schreiben Sie eine Python-Funktion 'def truncate_number(number: float) -> float:', um das folgende Problem zu lösen:\n Gegeben eine positive Gleitkommazahl, kann sie in einen ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen (übrig bleibender Teil, der immer kleiner als 1 ist) zerlegt werden.\n    \n    Geben Sie den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "ha": "Rubuta wani aikin python 'def truncate_number(number: float) -> float:' don warware matsalar mai zuwa:\n An ba da lamba mai kyau mai iyo, za a iya raba ta zuwa\n    kuma ɓangaren cikakken lamba (mafi girman cikakken lamba fiye da lambar da aka bayar) da ƙananan lambobi\n    (ɓangaren da ya rage koyaushe ya fi 1 ƙanƙanta).\n    \n    Mayar da ɓangaren ƙananan lambobi na lambar.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "hi": "एक पायथन फ़ंक्शन 'def truncate_number(number: float) -> float:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n दिए गए धनात्मक फ्लोटिंग पॉइंट संख्या को तोड़ा जा सकता है\n    और पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव\n    (बचा हुआ भाग हमेशा 1 से छोटा होता है) में।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "hu": "Írj egy python függvényt 'def truncate_number(number: float) -> float:' a következő probléma megoldására:\n\n    Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n    (a maradék rész mindig kisebb, mint 1).\n    \n    Add vissza a szám tizedes részét.\n    >>> truncate_number(3.5)\n    0.5\n    "
    },
    "instruction_bertscore": {
      "sq": "0.945337912291104",
      "hy": "0.920646169624657",
      "bn": "0.9315118473584085",
      "bg": "0.9530815176957491",
      "zh": "0.9257265388803864",
      "fr": "0.970189751044665",
      "de": "0.9368446758284331",
      "ha": "0.9085684493058306",
      "hi": "0.9304211679361459",
      "hu": "0.9338560831153823"
    },
    "level": "easy",
    "test": "def check(truncate_number):\n    assert truncate_number(3.5) == 0.5\n    assert abs(truncate_number(1.33) - 0.33) < 1e-6\n    assert abs(truncate_number(123.456) - 0.456) < 1e-6\n \ncheck(truncate_number)",
    "entry_point": "truncate_number",
    "signature": "def truncate_number(number: float) -> float:",
    "docstring": {
      "en": " Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "sq": " Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n    një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthe pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "hy": " Տրված դրական տասնորդական կետով թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի (մնացորդային մաս, որը միշտ փոքր է 1-ից)։\n\n    Վերադարձնել թվի տասնորդական մասը։\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "bn": " প্রদত্ত একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা, এটি ভাঙা যেতে পারে একটি পূর্ণসংখ্যার অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ সবসময় ১ এর চেয়ে ছোট)।\n\n    সংখ্যার দশমিক অংশ ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "bg": " Дадено е положително число с плаваща запетая, то може да бъде разложено на\n    цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n    (оставаща част, винаги по-малка от 1).\n    \n    Върнете десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "zh": " 给定一个正浮点数，可以将其分解为整数部分（小于给定数的最大整数）和小数部分（剩余部分总是小于1）。\n    \n    返回该数的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "fr": " Étant donné un nombre flottant positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retourne la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "de": " Gegeben eine positive Gleitkommazahl, kann sie in einen ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen (Restteil, der immer kleiner als 1 ist) zerlegt werden.\n    \n    Gib den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "ha": " An ba da lamba mai lamba mai kyau, za a iya raba ta zuwa\n    wani ɓangare na integer (babban integer mafi ƙanƙanta fiye da adadin da aka bayar) da decimals\n    (ɓangaren da ya rage koyaushe ƙasa da 1).\n    \n    Mayar da ɓangaren decimal na lambar.\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "hi": " दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को दो भागों में विभाजित किया जा सकता है:\n    एक पूर्णांक भाग (दी गई संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव\n    (बचा हुआ भाग जो हमेशा 1 से छोटा होता है)।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    ",
      "hu": " Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre\n    (a maradék rész mindig kisebb, mint 1).\n    \n    Adja vissza a szám tizedes részét.\n    >>> truncate_number(3.5)\n    0.5\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9177950291352822",
      "hy": "0.869690723456253",
      "bn": "0.9165011508332209",
      "bg": "0.9219652739851096",
      "zh": "0.9064671385048625",
      "fr": "0.9569121045940069",
      "de": "0.9100212319127198",
      "ha": "0.9234538100605851",
      "hi": "0.8920557098392573",
      "hu": "0.9041779233634355"
    }
  },
  {
    "task_id": "Python/4",
    "prompt": {
      "en": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "sq": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ju është dhënë një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me\n    bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n    në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "hy": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ձեզ տրված է բանկային հաշվի վրա կատարվող ավանդների և հանումների գործողությունների ցուցակ, որը սկսվում է\n    զրոյական մնացորդով: Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը իջնում է զրոյից ցածր, և\n    այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False:\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "bn": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" আপনার কাছে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। \n    আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই মুহূর্তে ফাংশনটি True রিটার্ন করা উচিত। \n    অন্যথায় এটি False রিটার্ন করা উচিত।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "bg": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Даден ви е списък с операции за депозити и тегления от банкова сметка, която започва с\n    нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нулата и\n    в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "zh": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 给定一个银行账户的存款和取款操作列表，该账户初始余额为零。\n    你的任务是检测账户余额是否在任何时候低于零，如果是，函数应返回 True。\n    否则应返回 False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "fr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n    un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n    à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "de": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sie erhalten eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit\n    einem Kontostand von null beginnt. Ihre Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und\n    in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "ha": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" An ba ka jerin ayyukan ajiya da cire kudi daga asusun banki wanda ya fara da\n    sifili a matsayin ma'auni. Aikin ka shi ne gano ko a wani lokaci ma'aunin asusun ya fadi kasa da sifili, kuma\n    a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "hi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" आपको एक बैंक खाते पर जमा और निकासी संचालन की एक सूची दी गई है जो शून्य शेष के साथ शुरू होता है।\n    आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते का शेष शून्य से नीचे गिरता है, और उस बिंदु पर\n    फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "hu": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Egy bankszámlán végzett befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármikor az egyenleg nulla alá csökken, és ebben az esetben a függvénynek True-t kell visszaadnia. Ellenkező esetben False-t kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9680234881090986",
      "hy": "0.9733481727335008",
      "bn": "0.9704388335424827",
      "bg": "0.9686761875411791",
      "zh": "0.9471798118144404",
      "fr": "0.9679432414351604",
      "de": "0.9540639435603476",
      "ha": "0.9659505814526185",
      "hi": "0.9737114677004136",
      "hu": "0.9459020225732431"
    },
    "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False",
    "instruction": {
      "en": "Write a python function 'def below_zero(operations: List[int]) -> bool:' to solve the following problem:\n You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ",
      "sq": "Shkruani një funksion python 'def below_zero(operations: List[int]) -> bool:' për të zgjidhur problemin e mëposhtëm:\n Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me\n    bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n    në atë moment funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "hy": "Պայթոն ֆունկցիա 'def below_zero(operations: List[int]) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n Ձեզ տրված է բանկային հաշվի վրա ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է\n    զրոյական հաշվեկշռով։ Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը զրոյից ցածր է ընկնում, և\n    այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "bn": "একটি পাইথন ফাংশন 'def below_zero(operations: List[int]) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন অপারেশনের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই মুহূর্তে ফাংশনটি True রিটার্ন করা উচিত। অন্যথায় এটি False রিটার্ন করা উচিত।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "bg": "Напишете Python функция 'def below_zero(operations: List[int]) -> bool:', за да решите следния проблем:\n Дават ви се списък с операции за депозити и тегления по банкова сметка, която започва с\n    нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и\n    в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "zh": "编写一个 Python 函数 'def below_zero(operations: List[int]) -> bool:' 来解决以下问题：\n 你得到一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并且在这种情况下函数应该返回 True。否则，它应该返回 False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "fr": "Écrivez une fonction python 'def below_zero(operations: List[int]) -> bool:' pour résoudre le problème suivant :\n Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n    un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n    à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "de": "Schreiben Sie eine Python-Funktion 'def below_zero(operations: List[int]) -> bool:', um das folgende Problem zu lösen:\n Sie erhalten eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem\n    Kontostand von null beginnt. Ihre Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und\n    in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "ha": "Rubuta wani aikin python 'def below_zero(operations: List[int]) -> bool:' don warware matsalar mai zuwa:\n An baka jerin ajiya da cire kudi a asusun banki wanda ya fara da\n    sifili. Aikinka shi ne gano ko a kowane lokaci asusun ya fadi kasa da sifili, kuma\n    a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "hi": "एक पायथन फ़ंक्शन 'def below_zero(operations: List[int]) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको एक बैंक खाते पर जमा और निकासी संचालन की एक सूची दी गई है जो शून्य शेष राशि से शुरू होती है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "hu": "Írj egy python függvényt 'def below_zero(operations: List[int]) -> bool:' a következő probléma megoldására:\n Adott egy lista, amely egy bankszámlán végrehajtott befizetési és kifizetési műveleteket tartalmaz, és amely nulla egyenleggel indul. A feladatod az, hogy észleld, ha bármely ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False-t kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True"
    },
    "instruction_bertscore": {
      "sq": "0.9704477719096294",
      "hy": "0.9704727993376397",
      "bn": "0.9735354811828166",
      "bg": "0.9619696313559172",
      "zh": "0.9562166996300038",
      "fr": "0.9697724286141107",
      "de": "0.9560709049303241",
      "ha": "0.9527084898401655",
      "hi": "0.9730448641416605",
      "hu": "0.9527343117897"
    },
    "level": "easy",
    "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)",
    "entry_point": "below_zero",
    "signature": "def below_zero(operations: List[int]) -> bool:",
    "docstring": {
      "en": " You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    ",
      "sq": " Ju jepet një listë operacionesh depozitimi dhe tërheqjeje në një llogari bankare që fillon me një bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "hy": " Ձեզ տրված է բանկային հաշվի ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է զրոյական մնացորդով։ Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "bn": " আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময়ে অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময়ে ফাংশনটি True ফেরত দেওয়া উচিত। অন্যথায় এটি False ফেরত দেওয়া উচিত।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "bg": " Даден ви е списък с операции за депозити и тегления от банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нулата, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "zh": " 你有一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并在此时函数应返回 True。否则应返回 False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "fr": " Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "de": " Du hast eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Deine Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "ha": " An ba ku jerin ajiya da cire kudi a kan asusun banki wanda ya fara da sifili. Aikin ku shi ne gano ko a kowane lokaci asusun ya yi kasa da sifili, kuma a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "hi": " आपको एक बैंक खाते पर जमा और निकासी संचालन की सूची दी गई है, जो शून्य शेष के साथ शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी बिंदु पर खाते का शेष शून्य से नीचे गिरता है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True",
      "hu": " Egy bankszámlán végzett befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármely ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False értéket kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True"
    },
    "docstring_bertscore": {
      "sq": "0.9654830055356624",
      "hy": "0.9541288956949461",
      "bn": "0.9598899712664819",
      "bg": "0.9643055246368875",
      "zh": "0.9519370094402261",
      "fr": "0.9621684603673332",
      "de": "0.9259531761451472",
      "ha": "0.9414572705368254",
      "hi": "0.9590152030684043",
      "hu": "0.9504671446205679"
    }
  },
  {
    "task_id": "Python/5",
    "prompt": {
      "en": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "sq": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Për një listë të dhënë të numrave hyrës, llogaritni Devijimin Absolut Mesatar\n    rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është mesatarja e diferencës absolute midis secilit\n    element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mesatarja |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "hy": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Տրված թվերի ցուցակի համար հաշվարկել միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում՝ միջինի) միջև միջին բացարձակ տարբերությունն է:\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "bn": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "bg": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" За даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в този случай средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "zh": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n    平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "fr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Pour une liste donnée de nombres en entrée, calculer la Déviation Absolue Moyenne\n    autour de la moyenne de cet ensemble de données.\n    La Déviation Absolue Moyenne est la différence absolue moyenne entre chaque\n    élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "de": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Für eine gegebene Liste von Eingabezahlen, berechne die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "ha": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Don jerin lambobi da aka bayar, ƙididdige Matsakaicin Bambanci na Gaskiya\n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Bambanci na Gaskiya shine matsakaicin bambancin kowane\n    abu da wata cibiyar (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "hi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर औसत निरपेक्ष विचलन की गणना करें।\n    औसत निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "hu": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Egy adott számok listájára számítsa ki az átlagos abszolút eltérést\n    az adathalmaz átlagához képest.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (ebben az esetben az átlag) közötti átlagos abszolút különbség:\n    MAD = átlag | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9670384800495465",
      "hy": "0.9316334091516019",
      "bn": "0.9578498386228725",
      "bg": "0.9665772603047835",
      "zh": "0.9333384523424053",
      "fr": "0.9684996051324392",
      "de": "0.9645007783014448",
      "ha": "0.950775617602315",
      "hi": "0.9630072764664435",
      "hu": "0.9409628795184295"
    },
    "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)",
    "instruction": {
      "en": "Write a python function 'def mean_absolute_deviation(numbers: List[float]) -> float:' to solve the following problem:\n For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "sq": "Shkruani një funksion python 'def mean_absolute_deviation(numbers: List[float]) -> float:' për të zgjidhur problemin e mëposhtëm:\n Për një listë të dhënë të numrave hyrës, llogaritni Devijimin Absolut Mesatar\n    rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është mesatarja e diferencës absolute midis secilit\n    element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "hy": "Պայթոն ֆունկցիա 'def mean_absolute_deviation(numbers: List[float]) -> float:' գրեք հետևյալ խնդիրը լուծելու համար:\n Տրված մուտքային թվերի ցուցակի համար հաշվարկել Միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը յուրաքանչյուր\n    տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև միջին բացարձակ տարբերությունն է:\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "bn": "একটি পাইথন ফাংশন 'def mean_absolute_deviation(numbers: List[float]) -> float:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি (Mean Absolute Deviation) গণনা করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "bg": "Напишете функция на Python 'def mean_absolute_deviation(numbers: List[float]) -> float:', за да решите следния проблем:\n За даден списък от входни числа, изчислете Средното Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в този случай средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "zh": "编写一个 Python 函数 'def mean_absolute_deviation(numbers: List[float]) -> float:' 来解决以下问题：\n\n对于给定的输入数字列表，计算该数据集均值周围的平均绝对偏差。\n\n平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：\n\nMAD = average | x - x_mean |\n\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0",
      "fr": "Écrivez une fonction python 'def mean_absolute_deviation(numbers: List[float]) -> float:' pour résoudre le problème suivant :\n Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne\n    autour de la moyenne de cet ensemble de données.\n    La Déviation Absolue Moyenne est la différence absolue moyenne entre chaque\n    élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "de": "Schreiben Sie eine Python-Funktion 'def mean_absolute_deviation(numbers: List[float]) -> float:', um das folgende Problem zu lösen:\n Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "ha": "Rubuta wani aikin python 'def mean_absolute_deviation(numbers: List[float]) -> float:' don warware matsalar mai zuwa:\n Don jerin lambobi da aka bayar, ƙididdige Matsakaicin Bambancin Dangi\n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Bambancin Dangi shine matsakaicin bambancin dangi tsakanin kowane\n    abu da wani tsakiya (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "hi": "एक पायथन फ़ंक्शन 'def mean_absolute_deviation(numbers: List[float]) -> float:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटासेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।\n    माध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "hu": "Írj egy Python függvényt 'def mean_absolute_deviation(numbers: List[float]) -> float:' a következő probléma megoldására:\n Egy adott bemeneti számok listájához számítsd ki az átlagos abszolút eltérést\n    ennek az adathalmaznak az átlaga körül.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (ebben az esetben az átlag) közötti átlagos abszolút különbség:\n    MAD = átlag | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0"
    },
    "instruction_bertscore": {
      "sq": "0.9678447207661671",
      "hy": "0.9455343577379475",
      "bn": "0.9541793478117289",
      "bg": "0.9648080595009058",
      "zh": "0.9516422419547702",
      "fr": "0.9691014551869749",
      "de": "0.9613618223899505",
      "ha": "0.9527029281894965",
      "hi": "0.9643903398095894",
      "hu": "0.9536068950535863"
    },
    "level": "easy",
    "test": "def check(mean_absolute_deviation):\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n    \ncheck(mean_absolute_deviation)",
    "entry_point": "mean_absolute_deviation",
    "signature": "def mean_absolute_deviation(numbers: List[float]) -> float:",
    "docstring": {
      "en": " For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "sq": " Për një listë të dhënë të numrave të hyrjes, llogaritni Devijimin Absolut Mesatar rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "hy": " Տրված թվերի ցուցակի համար հաշվարկել միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև միջին բացարձակ տարբերությունն է.\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "bn": " প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0",
      "bg": " За даден списък от входни числа, изчислете Средното Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в този случай средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "zh": " 对于给定的输入数字列表，计算该数据集平均值周围的平均绝对偏差。  \n平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "fr": " Pour une liste donnée de nombres d'entrée, calculer la déviation absolue moyenne autour de la moyenne de cet ensemble de données.\n    La déviation absolue moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "de": " Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "ha": " Don Allah, a jerin lambobi masu shigarwa da aka bayar, a lissafta Matsakaicin Maimaitawa na Dama \n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Maimaitawa na Dama shine matsakaicin bambancin dama tsakanin kowanne \n    abu da wani tsakiya (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "hi": " दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटासेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।  \nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    ",
      "hu": " Adott bemeneti számok listája esetén számítsa ki az átlagos abszolút eltérést\n    az adathalmaz átlagához képest.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti abszolút különbségek átlaga:\n    MAD = átlag | x - x_átlag |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9757253811337263",
      "hy": "0.9148455666072951",
      "bn": "0.9434833004233812",
      "bg": "0.965566628926078",
      "zh": "0.9373738271635101",
      "fr": "0.954367848043331",
      "de": "0.9441097806451653",
      "ha": "0.9423991758036928",
      "hi": "0.9500974934814619",
      "hu": "0.9281949186255068"
    }
  },
  {
    "task_id": "Python/6",
    "prompt": {
      "en": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    \"\"\"",
      "sq": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.\n    \"\"\"",
      "hy": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Գումարում է երկու ամբողջ թիվ:\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի:\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի:\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը:\n    \"\"\"",
      "bn": "def add(a: int, b: int) -> int:\n    \"\"\"\n    দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\n    প্যারামিটারসমূহ:\n    a (int): যোগ করার জন্য প্রথম সংখ্যা।\n    b (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\n    রিটার্ন:\n    int: দুটি সংখ্যার যোগফল।\n    \"\"\"",
      "bg": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Събира две цели числа.\n\n    Parameters:\n    a (int): Първото число, което ще бъде събрано.\n    b (int): Второто число, което ще бъде събрано.\n\n    Returns:\n    int: Сумата на двете числа.\n    \"\"\"",
      "zh": "def add(a: int, b: int) -> int:\n    \"\"\"\n    将两个整数相加。\n\n    参数:\n    a (int): 要相加的第一个数字。\n    b (int): 要相加的第二个数字。\n\n    返回:\n    int: 两个数字的和。\n    \"\"\"",
      "fr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Additionne deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Retourne:\n    int: La somme des deux nombres.\n    \"\"\"",
      "de": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Addiert zwei ganze Zahlen miteinander.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Rückgabewert:\n    int: Die Summe der beiden Zahlen.\n    \"\"\"",
      "ha": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Ƙara lambobi guda biyu tare.\n\n    Ma'auni:\n    a (int): Lambar farko da za a ƙara.\n    b (int): Lambar biyu da za a ƙara.\n\n    Komawa:\n    int: Jimillar lambobin guda biyu.\n    \"\"\"",
      "hi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    दो पूर्णांक संख्याओं को जोड़ता है।\n\n    पैरामीटर्स:\n    a (int): पहली संख्या जिसे जोड़ा जाना है।\n    b (int): दूसरी संख्या जिसे जोड़ा जाना है।\n\n    रिटर्न:\n    int: दोनों संख्याओं का योग।\n    \"\"\"",
      "hu": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Két egész számot ad össze.\n\n    Paraméterek:\n    a (int): Az első szám, amelyet hozzáadunk.\n    b (int): A második szám, amelyet hozzáadunk.\n\n    Visszatér:\n    int: A két szám összege.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9744187904872789",
      "hy": "0.9827362390627338",
      "bn": "0.9744187904872789",
      "bg": "0.9827362390627338",
      "zh": "0.9476624836403552",
      "fr": "0.9617837133192686",
      "de": "0.9750466611217301",
      "ha": "0.9578377221696295",
      "hi": "0.9839455008224741",
      "hu": "0.9671620281465502"
    },
    "canonical_solution": "    return a + b",
    "instruction": {
      "en": "Write a python function 'def add(a: int, b: int) -> int:' to solve the following problem:\n\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    ",
      "sq": "Shkruani një funksion python 'def add(a: int, b: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.",
      "hy": "Պայթոն ֆունկցիա 'def add(a: int, b: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գումարում է երկու ամբողջ թվեր միասին։\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի։\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի։\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը։",
      "bn": "একটি পাইথন ফাংশন 'def add(a: int, b: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\n    প্যারামিটার:\n    a (int): প্রথম সংখ্যা যা যোগ করা হবে।\n    b (int): দ্বিতীয় সংখ্যা যা যোগ করা হবে।\n\n    রিটার্নস:\n    int: দুটি সংখ্যার যোগফল।",
      "bg": "Напишете Python функция 'def add(a: int, b: int) -> int:' за решаване на следния проблем:\n\n    Събира две цели числа заедно.\n\n    Параметри:\n    a (int): Първото число, което ще бъде добавено.\n    b (int): Второто число, което ще бъде добавено.\n\n    Връща:\n    int: Сумата от двете числа.",
      "zh": "编写一个python函数 'def add(a: int, b: int) -> int:' 来解决以下问题：\n\n    将两个整数相加。\n\n    参数:\n    a (int): 第一个要相加的数字。\n    b (int): 第二个要相加的数字。\n\n    返回:\n    int: 两个数字的和。",
      "fr": "Écrivez une fonction python 'def add(a: int, b: int) -> int:' pour résoudre le problème suivant :\n\n    Ajoute deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Renvoie:\n    int: La somme des deux nombres.",
      "de": "Schreiben Sie eine Python-Funktion 'def add(a: int, b: int) -> int:', um das folgende Problem zu lösen:\n\n    Addiert zwei ganze Zahlen zusammen.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Gibt zurück:\n    int: Die Summe der beiden Zahlen.",
      "ha": "Rubuta wani aikin python 'def add(a: int, b: int) -> int:' don warware matsalar mai zuwa:\n\n    Ƙara lambobi guda biyu na cikakken lamba tare.\n\n    Sigogi:\n    a (int): Lambar farko da za a ƙara.\n    b (int): Lambar ta biyu da za a ƙara.\n\n    Yana dawowa:\n    int: Jimillar lambobin biyu.",
      "hi": "एक पायथन फ़ंक्शन 'def add(a: int, b: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दो पूर्णांक संख्याओं को एक साथ जोड़ता है।\n\n    पैरामीटर्स:\n    a (int): जोड़ने के लिए पहली संख्या।\n    b (int): जोड़ने के लिए दूसरी संख्या।\n\n    लौटाता है:\n    int: दोनों संख्याओं का योग।",
      "hu": "Írj egy python függvényt 'def add(a: int, b: int) -> int:' a következő probléma megoldására:\n\n    Két egész számot összead.\n\n    Paraméterek:\n    a (int): Az első szám, amit hozzá kell adni.\n    b (int): A második szám, amit hozzá kell adni.\n\n    Visszatér:\n    int: A két szám összege."
    },
    "instruction_bertscore": {
      "sq": "0.9952414119615471",
      "hy": "0.9952414119615471",
      "bn": "0.9927023198007782",
      "bg": "0.9928630117790355",
      "zh": "0.9544322042867863",
      "fr": "0.9816668130912419",
      "de": "0.9773255474833433",
      "ha": "0.9667357673488494",
      "hi": "0.9835468496477371",
      "hu": "0.9737507965158585"
    },
    "level": "easy",
    "test": "# Test cases:\n# The following lines are not part of the function's implementation but are provided\n# for testing purposes.\n\n# Test case 1: Positive integers\nassert add(2, 3) == 5\n\n# Test case 2: A positive and a negative integer\nassert add(-1, 1) == 0\n\n# Test case 3: Two negative integers\nassert add(-4, -5) == -9\n\n# Test case 4: Zeroes\nassert add(0, 0) == 0\n\n# Test case 5: Large integers\nassert add(123456, 654321) == 777777\n\nprint(\"All test cases passed.\")",
    "entry_point": "add",
    "signature": "def add(a: int, b: int) -> int:",
    "docstring": {
      "en": "\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    ",
      "sq": "\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.\n    ",
      "hy": "\n    Գումարում է երկու ամբողջ թվեր:\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի:\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի:\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը.\n    ",
      "bn": "\n    দুটি পূর্ণসংখ্যা যোগ করে।\n\n    প্যারামিটারসমূহ:\n    a (int): যোগ করার জন্য প্রথম সংখ্যা।\n    b (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\n    রিটার্নস:\n    int: দুটি সংখ্যার যোগফল।\n    ",
      "bg": "\n    Събира две цели числа.\n\n    Параметри:\n    a (int): Първото число за събиране.\n    b (int): Второто число за събиране.\n\n    Връща:\n    int: Сумата на двете числа.\n    ",
      "zh": "\n    将两个整数相加。\n\n    参数:\n    a (int): 要相加的第一个数字。\n    b (int): 要相加的第二个数字。\n\n    返回:\n    int: 两个数字的和。\n    ",
      "fr": "\n    Ajoute deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Retourne:\n    int: La somme des deux nombres.\n    ",
      "de": "\n    Addiert zwei ganze Zahlen miteinander.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Rückgabewert:\n    int: Die Summe der beiden Zahlen.\n    ",
      "ha": "\n    Ƙara lambobi guda biyu masu cikakken lamba tare.\n\n    Sigogi:\n    a (int): Lamba ta farko da za a ƙara.\n    b (int): Lamba ta biyu da za a ƙara.\n\n    Dawowa:\n    int: Jimillar lambobi biyun.\n    ",
      "hi": "\n    दो पूर्णांक संख्याओं को एक साथ जोड़ता है।\n\n    पैरामीटर:\n    a (int): जोड़ने के लिए पहली संख्या।\n    b (int): जोड़ने के लिए दूसरी संख्या।\n\n    रिटर्न:\n    int: दोनों संख्याओं का योग।",
      "hu": "\n    Két egész számot ad össze.\n\n    Paraméterek:\n    a (int): Az első szám, amelyet hozzá kell adni.\n    b (int): A második szám, amelyet hozzá kell adni.\n\n    Visszatér:\n    int: A két szám összege.\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9933258205668467",
      "hy": "0.9807268941281848",
      "bn": "0.9521849001557576",
      "bg": "0.9240115641705311",
      "zh": "0.9185428725198785",
      "fr": "0.935215310812804",
      "de": "0.9593937925746567",
      "ha": "0.9483243200699635",
      "hi": "0.9672015555923762",
      "hu": "0.9582536541875165"
    }
  },
  {
    "task_id": "Python/7",
    "prompt": {
      "en": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "sq": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Gjen qilimin më të sipërm që mbulon një pikë të dhënë në planin koordinativ.\n\n    Args:\n    n (int): Numri total i qilimave.\n    carpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një qilimi.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\n                              gjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Returns:\n    int: Numri i qilimit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "hy": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Գտնում է տրված կետը ծածկող ամենավերին գորգը կոորդինատային հարթության վրա:\n\n    Պարամետրեր:\n    n (int): Գորգերի ընդհանուր քանակը:\n    carpets (list of tuples): Ցուցակ, որը պարունակում է n տուփեր, յուրաքանչյուրն ներկայացնում է գորգի մասին տեղեկատվությունը:\n                              Յուրաքանչյուր տուփ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարությունները \n                              համապատասխանաբար x և y առանցքների երկայնքով:\n    point (tuple): Տուփ, որը պարունակում է երկու ամբողջ թիվ (x, y), կետը ստուգելու կոորդինատները:\n\n    Վերադարձնում է:\n    int: Ամենավերին գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\n    Օրինակներ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "bn": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    সমন্বয় সমতলে একটি নির্দিষ্ট বিন্দু আচ্ছাদনকারী সর্বোচ্চ কার্পেট খুঁজে বের করে।\n\n    আর্গস:\n    n (int): মোট কার্পেটের সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\n                              কার্পেটের নিচের-বাম কোণের সমন্বয় এবং (g, k) হল x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, চেক করার জন্য বিন্দুর সমন্বয়।\n\n    রিটার্নস:\n    int: সর্বোচ্চ কার্পেটের সংখ্যা যা বিন্দু (x, y) আচ্ছাদন করে, অথবা -1 যদি কোনো কার্পেট এটি আচ্ছাদন না করে।\n\n    উদাহরণ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "bg": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Намира най-горния килим, покриващ дадена точка в координатната равнина.\n\n    Args:\n    n (int): Общият брой килими.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки от които представлява информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима, а (g, k) са дължините на килима\n                              по оста x и y съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Returns:\n    int: Номерът на най-горния килим, покриващ точката (x, y), или -1 ако няма килим, който да я покрива.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "zh": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    找到覆盖坐标平面上给定点的最上层地毯。\n\n    参数:\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 包含 n 个元组的列表，每个元组代表一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 是地毯在 x 和 y 轴上的长度。\n    point (tuple): 包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回:\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "fr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Arguments:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\n                              coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Retourne:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Exemples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "de": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Args:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (list of tuples): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- und y-Achse sind.\n    point (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Returns:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "ha": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Nemo tabarmar da take saman sauran tabarma waɗanda ke rufe wani wuri a kan tsarin daidaitawa.\n\n    Args:\n    n (int): Jimillar adadin tabarmai.\n    carpets (list of tuples): Jerin da ke ɗauke da n tuplai, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tupla yana ƙunshe da lambobi huɗu (a, b, g, k) inda (a, b) \n                              suke matsayin daidaitawar kusurwar ƙasa-hagu na tabarma kuma (g, k) \n                              su ne tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tupla da ke ƙunshe da lambobi biyu (x, y), daidaitawar wurin da za a duba.\n\n    Returns:\n    int: Lambar tabarmar da take saman sauran tabarmai da ke rufe wuri (x, y), ko -1 idan babu tabarma da ta rufe shi.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "hi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    दिए गए बिंदु पर समन्वय तल पर सबसे ऊपर का कालीन खोजें।\n\n    Args:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): एक सूची जिसमें n ट्यूपल होते हैं, प्रत्येक एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b)\n                              कालीन के नीचे-बाएँ कोने के समन्वय होते हैं और (g, k) क्रमशः x और y अक्ष पर कालीन की लंबाई होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के समन्वय।\n\n    Returns:\n    int: बिंदु (x, y) को ढकने वाला सबसे ऊपर का कालीन संख्या, या -1 यदि कोई कालीन इसे नहीं ढकता।\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "hu": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Megtalálja a koordináta síkon egy adott pontot lefedő legfelső szőnyeget.\n\n    Args:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információját képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\n                              koordinátái, és (g, k) a szőnyeg hosszai az x és y tengely mentén.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Returns:\n    int: A pontot (x, y) lefedő legfelső szőnyeg száma, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Példák:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9861937981054081",
      "hy": "0.9862514009159081",
      "bn": "0.9917270446298969",
      "bg": "0.9934475809904211",
      "zh": "0.9828375405570615",
      "fr": "0.9936948758148095",
      "de": "0.9877266287558543",
      "ha": "0.952409352486327",
      "hi": "0.9866063534068175",
      "hu": "0.986210880318177"
    },
    "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point",
    "instruction": {
      "en": "Write a python function 'def find_topmost_carpet(n, carpets, point) -> int:' to solve the following problem:\n\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "sq": "Shkruani një funksion python 'def find_topmost_carpet(n, carpets, point) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Gjen tapetin më të sipërm që mbulon një pikë të dhënë në planin koordinativ.\n\n    Argumentet:\n    n (int): Numri total i tapetëve.\n    carpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një tapeti.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të tapetit dhe (g, k) janë\n                              gjatësitë e tapetit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Kthen:\n    int: Numri i tapetit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë tapet nuk e mbulon atë.\n\n    Shembuj:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "hy": "Պայթոն ֆունկցիա 'def find_topmost_carpet(n, carpets, point) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Տրված կոորդինատային հարթության վրա կետը ծածկող ամենավերին գորգը գտնել:\n\n    Args:\n    n (int): Գորգերի ընդհանուր քանակը:\n    carpets (list of tuples): Ցանկ, որը պարունակում է n տուփեր, որոնցից յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկատվությունը:\n                              Յուրաքանչյուր տուփ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարությունները \n                              համապատասխանաբար x և y առանցքների երկայնքով:\n    point (tuple): Տուփ, որը պարունակում է երկու ամբողջ թիվ (x, y), այն կետի կոորդինատները, որը պետք է ստուգել:\n\n    Returns:\n    int: Կետի (x, y) վրա գտնվող ամենավերին գորգի համարը, կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "bn": "একটি পাইথন ফাংশন 'def find_topmost_carpet(n, carpets, point) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    প্রদত্ত বিন্দুতে স্থানাঙ্ক সমতলে যে কার্পেটটি সবচেয়ে উপরে রয়েছে তা খুঁজে বের করুন।\n\n    আর্গুমেন্টস:\n    n (int): মোট কার্পেটের সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\n                              কার্পেটের নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল\n                              যথাক্রমে x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, যাচাই করার জন্য বিন্দুর স্থানাঙ্ক।\n\n    রিটার্নস:\n    int: বিন্দু (x, y) কে আবৃতকারী সবচেয়ে উপরের কার্পেটের সংখ্যা, অথবা -1 যদি কোনো কার্পেট এটি আবৃত না করে।\n\n    উদাহরণ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "bg": "Напишете Python функция 'def find_topmost_carpet(n, carpets, point) -> int:', за да решите следния проблем:\n\n    Намира най-горния килим, покриващ дадена точка на координатната равнина.\n\n    Аргументи:\n    n (int): Общият брой на килимите.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки от които представлява информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима, а (g, k) са\n                              дължините на килима по x и y осите съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Връща:\n    int: Номерът на най-горния килим, покриващ точката (x, y), или -1, ако няма килим, който да я покрива.\n\n    Примери:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "zh": "编写一个python函数 'def find_topmost_carpet(n, carpets, point) -> int:' 来解决以下问题：\n\n    找到在坐标平面上覆盖给定点的最上层地毯。\n\n    参数：\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 包含n个元组的列表，每个元组代表一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 分别是地毯在x轴和y轴上的长度。\n    point (tuple): 包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回：\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例：\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "fr": "Écrivez une fonction python 'def find_topmost_carpet(n, carpets, point) -> int:' pour résoudre le problème suivant :\n\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Args:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont\n                              les coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Returns:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "de": "Schreiben Sie eine Python-Funktion 'def find_topmost_carpet(n, carpets, point) -> int:', um das folgende Problem zu lösen:\n\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Argumente:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (Liste von Tupeln): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- bzw. y-Achse sind.\n    point (Tupel): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Rückgabewert:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Beispiele:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "ha": "Rubuta aikin python 'def find_topmost_carpet(n, carpets, point) -> int:' don warware matsalar mai zuwa:\n\n    Nemi tabarma mafi sama da ke rufe wani wuri a kan tsararren tsari.\n\n    Args:\n    n (int): Jimillar adadin tabarma.\n    carpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) \n                              suke matsayin ko'odinet na kusurwar kasa-hagu na tabarma kuma (g, k) \n                              sune tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tuple da ke dauke da lambobi biyu (x, y), ko'odinet na wurin da za a duba.\n\n    Returns:\n    int: Lambar tabarma mafi sama da ke rufe wurin (x, y), ko -1 idan babu tabarma da ke rufe shi.\n\n    Misalai:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "hi": "एक पायथन फ़ंक्शन 'def find_topmost_carpet(n, carpets, point) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए बिंदु पर निर्देशांक तल पर सबसे ऊपर का कालीन खोजें।\n\n    तर्क:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): n ट्यूपल्स की एक सूची, जिसमें प्रत्येक ट्यूपल एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b) कालीन के \n                              निचले-बाएँ कोने के निर्देशांक होते हैं और (g, k) क्रमशः x और y अक्ष के \n                              साथ कालीन की लंबाई होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जो जांचने के लिए बिंदु के निर्देशांक होते हैं।\n\n    लौटाता है:\n    int: सबसे ऊपर के कालीन की संख्या जो बिंदु (x, y) को ढकता है, या -1 यदि कोई कालीन इसे नहीं ढकता।\n\n    उदाहरण:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "hu": "Írj egy python függvényt 'def find_topmost_carpet(n, carpets, point) -> int:' a következő probléma megoldására:\n\n    Megkeresi a koordinátasíkon egy adott pontot lefedő legfelső szőnyeget.\n\n    Argumentumok:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információját képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\n                              koordinátái, és (g, k) a szőnyeg hossza az x és y tengely mentén.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Visszatérési érték:\n    int: A pontot (x, y) lefedő legfelső szőnyeg száma, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Példák:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1"
    },
    "instruction_bertscore": {
      "sq": "0.9870566484806236",
      "hy": "0.9876894848746007",
      "bn": "0.9809650519550456",
      "bg": "0.9911502220033716",
      "zh": "0.9836278908431993",
      "fr": "0.9928385802421681",
      "de": "0.9816298678403694",
      "ha": "0.9707395599393696",
      "hi": "0.9703176690100515",
      "hu": "0.9830975477258362"
    },
    "level": "easy",
    "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()",
    "entry_point": "find_topmost_carpet",
    "signature": "def find_topmost_carpet(n, carpets, point) -> int:",
    "docstring": {
      "en": "\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "sq": "\n    Gjen qilimin më sipërfaqësor që mbulon një pikë të dhënë në planin koordinativ.\n\n    Argumentet:\n    n (int): Numri total i qilimave.\n    carpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një qilimi.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\n                              gjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Kthen:\n    int: Numri i qilimit më sipërfaqësor që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\n    Shembuj:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "hy": "\n    Գտնում է տրված կոորդինատային հարթության վրա գտնվող կետի վրա գտնվող ամենավերևի գորգը։\n\n    Պարամետրեր:\n    n (int): Գորգերի ընդհանուր քանակը։\n    carpets (list of tuples): Ցանկ, որը պարունակում է n թյուպլ, յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկություն։\n                              Յուրաքանչյուր թյուպլ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարություններն են \n                              համապատասխանաբար x և y առանցքների երկայնքով։\n    point (tuple): Թյուպլ, որը պարունակում է երկու ամբողջ թիվ (x, y), կոորդինատները այն կետի, որը պետք է ստուգել։\n\n    Վերադարձնում է:\n    int: Ամենավերևի գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն։\n\n    Օրինակներ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "bn": "\n    প্রদত্ত বিন্দুতে স্থানাঙ্ক সমতলে আবৃত শীর্ষস্থানীয় কার্পেট খুঁজে বের করে।\n\n    আর্গুমেন্টসমূহ:\n    n (int): কার্পেটের মোট সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল কার্পেটের\n                              নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, চেক করার জন্য বিন্দুটির স্থানাঙ্ক।\n\n    রিটার্নস:\n    int: শীর্ষস্থানীয় কার্পেটের সংখ্যা যা বিন্দু (x, y) আবৃত করে, অথবা -1 যদি কোনো কার্পেট এটি আবৃত না করে।\n\n    উদাহরণ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "bg": "\n    Намира най-горния килим, покриващ дадена точка в координатната равнина.\n\n    Аргументи:\n    n (int): Общият брой на килимите.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки от които представлява информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима и (g, k) са дължините на килима\n                              по оста x и y съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Връща:\n    int: Номера на най-горния килим, покриващ точката (x, y), или -1, ако няма килим, който да я покрива.\n\n    Примери:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "zh": "\n    找到在坐标平面上覆盖给定点的最上层地毯。\n\n    参数:\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 一个包含 n 个元组的列表，每个元组代表一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 分别是地毯在 x 和 y 轴上的长度。\n    point (tuple): 一个包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回:\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1",
      "fr": "\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Args:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\n                              coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Returns:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "de": "\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Argumente:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (list von Tupeln): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der linken unteren Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- und y-Achse sind.\n    point (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Rückgabewert:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Beispiele:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "ha": "\n    Nemo tabarmar da ke saman wani wuri a kan filin da aka bayar.\n\n    Ma'auni:\n    n (int): Jimillar adadin tabarmai.\n    carpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) \n                              suke matsayin da ke kasa-hagu na tabarma kuma (g, k) suna \n                              tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tuple da ke dauke da lambobi biyu (x, y), wuraren da za a duba.\n\n    Komawa:\n    int: Lambar tabarmar da ke saman wurin (x, y), ko -1 idan babu tabarma da ta rufe shi.\n\n    Misalai:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "hi": "\n    दिए गए बिंदु पर समन्वय तल पर सबसे ऊपर की कालीन को खोजें।\n\n    तर्क:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): एक सूची जिसमें n ट्यूपल होते हैं, प्रत्येक एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b) कालीन के निचले-बाएँ कोने के\n                              समन्वय होते हैं और (g, k) कालीन की लंबाई x और y अक्ष के साथ होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के समन्वय।\n\n    लौटाता है:\n    int: सबसे ऊपर की कालीन की संख्या जो बिंदु (x, y) को कवर करती है, या -1 यदि कोई कालीन इसे कवर नहीं करती है।\n\n    उदाहरण:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    ",
      "hu": "\n    Megkeresi a koordináta síkon adott pontot lefedő legfelső szőnyeget.\n\n    Args:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információit képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\n                              koordinátái, és (g, k) a szőnyeg x és y tengely menti hossza.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Returns:\n    int: A (x, y) pontot lefedő legfelső szőnyeg száma, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9832063971746433",
      "hy": "0.9816268883846538",
      "bn": "0.9881087936089654",
      "bg": "0.9926588197473316",
      "zh": "0.9791360634064764",
      "fr": "0.9920206203330665",
      "de": "0.9754610040965689",
      "ha": "0.9404454473758336",
      "hi": "0.9799931535006419",
      "hu": "0.981655888420285"
    }
  },
  {
    "task_id": "Python/8",
    "prompt": {
      "en": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "sq": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Llogarit shumën maksimale të vlerave të mbledhura në dy shtigje në një rrjetë N x N.\n\n    Kjo funksion përdor programimin dinamik për të gjetur dy shtigje nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetës që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dy shtigjet kalojnë përmes saj.\n\n    Argumentet:\n    - N (int): Madhësia e rrjetës (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjetë në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zero.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy shtigjet.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "hy": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Հաշվարկել արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա N x N ցանցում:\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղիներ ցանցի վերին ձախ անկյունից\n    մինչև ցանցի ներքևի աջ անկյունը, որոնք առավելագույնացնում են հավաքված արժեքների գումարը: Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով:\n\n    Պարամետրեր:\n    - N (int): Ցանցի չափը (N x N):\n    - grid_values (List[Tuple[int, int, int]]): Թվերի ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է\n      x-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում:\n      Ցուցակը ավարտվում է զրոներով տուփով:\n\n    Վերադարձնում է:\n    - int: Երկու ուղիների վրա հավաքված արժեքների առավելագույն գումարը:\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "bn": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\n    নীচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি\n    মান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি উভয় পথ এর মধ্য দিয়ে গেলেও।\n\n    আর্গস:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\n      গ্রিডের নির্দিষ্ট অবস্থানে স্থাপন করার জন্য x-অক্ষাংশ, y-অক্ষাংশ এবং মান থাকে।\n      তালিকাটি সমস্ত শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "bg": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната сума от стойности, събрани по два пътя в мрежа N x N.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл\n    до долния десен ъгъл на мрежата, които максимизират сумата от събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\n    Аргументи:\n    - N (int): Размерът на мрежата (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\n      Списъкът завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "zh": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    计算在 N x N 网格中收集的两条路径上的最大值总和。\n\n    此函数利用动态规划找到从网格的左上角到右下角的两条路径，\n    以最大化收集的值的总和。即使两条路径都经过某个值，该值最多也只能被收集一次。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含\n      x 坐标、y 坐标和要放置在该位置的网格上的值。\n      列表以一个全为零的元组结束。\n\n    返回:\n    - int: 在两条路径上收集的最大值总和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "fr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins allant du coin\n    supérieur gauche au coin inférieur droit de la grille qui maximisent la somme des valeurs\n    collectées. Chaque valeur peut être collectée au maximum une fois, même si les deux chemins\n    passent par elle.\n\n    Arguments:\n    - N (int): La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Retourne:\n    - int: La somme maximale des valeurs collectées sur les deux chemins.\n\n    Exemples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "de": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Berechne die maximale Summe der gesammelten Werte auf zwei Pfaden in einem N x N Gitter.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt\n    zum unteren rechten Eckpunkt des Gitters zu finden, die die Summe der gesammelten Werte maximieren.\n    Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Gitters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position auf das Gitter\n      gesetzt werden soll. Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "ha": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Lissafi mafi girman jimillar ƙimomi da aka tattara akan hanyoyi biyu a cikin grid na N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\n    ƙasan dama na grid wanda ke haɓaka jimillar ƙimomin da aka tattara. Ana iya tattara kowace ƙima sau ɗaya kawai, ko da kuwa duk hanyoyin sun wuce ta cikinsa.\n\n    Args:\n    - N (int): Girman grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi\n      x-ma'auni, y-ma'auni, da ƙima da za a sanya a kan grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple tare da duk sifili.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimomi da aka tattara akan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "hi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    एक N x N ग्रिड में दो पथों पर एकत्रित मानों के अधिकतम योग की गणना करें।\n\n    यह फ़ंक्शन डायनामिक प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथों को खोजा जा सके जो एकत्रित मानों के योग को अधिकतम करते हैं। प्रत्येक\n    मान को अधिकतम एक बार ही एकत्रित किया जा सकता है, भले ही दोनों पथ उसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मान होते हैं।\n      सूची एक ट्यूपल के साथ समाप्त होती है जिसमें सभी शून्य होते हैं।\n\n    वापसी:\n    - int: दो पथों पर एकत्रित मानों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "hu": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Számítsa ki az értékek maximális összegét, amelyet két útvonalon gyűjtenek össze egy N x N-es rácson.\n\n    Ez a függvény dinamikus programozást használ annak érdekében, hogy megtalálja a rács bal felső sarkából\n    a jobb alsó sarkába vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden\n    értéket legfeljebb egyszer lehet összegyűjteni, még akkor is, ha mindkét útvonal áthalad rajta.\n\n    Paraméterek:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy olyan tuple-ök listája, ahol minden tuple tartalmazza\n      az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni.\n      A lista egy minden nullát tartalmazó tuple-lel zárul.\n\n    Visszatér:\n    - int: Az összegyűjtött értékek maximális összege a két útvonalon.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9883608555624986",
      "hy": "0.985368091611446",
      "bn": "0.9855144822022687",
      "bg": "0.9904830225534754",
      "zh": "0.9794270569146925",
      "fr": "0.9905366527563548",
      "de": "0.9818580941481785",
      "ha": "0.9673149735399471",
      "hi": "0.9889627056170344",
      "hu": "0.983449322130649"
    },
    "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]",
    "instruction": {
      "en": "Write a python function 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' to solve the following problem:\n\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ",
      "sq": "Shkruani një funksion python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni shumën maksimale të vlerave të mbledhura në dy rrugë në një rrjet N x N.\n\n    Ky funksion përdor programimin dinamik për të gjetur dy rrugë nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetit që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dyja rrugët kalojnë nëpër të.\n\n    Args:\n    - N (int): Madhësia e rrjetit (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjet në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zerot.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy rrugët.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "hy": "Պայթոն ֆունկցիա 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա N x N ցանցում:\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղի ցանցի վերին ձախ անկյունից\n    ցանցի ներքևի աջ անկյունը, որոնք առավելագույնացնում են հավաքված արժեքների գումարը: Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն էլ անցնում են դրա միջով:\n\n    Արգումենտներ:\n    - N (int): Ցանցի չափը (N x N):\n    - grid_values (List[Tuple[int, int, int]]): Թվերի ցուցակ, որտեղ յուրաքանչյուր տապլի մեջ պարունակվում է\n      x-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում:\n      Ցուցակը ավարտվում է զրոներով տապլով:\n\n    Վերադարձնում է:\n    - int: Արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա:\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "bn": "একটি পাইথন ফাংশন 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\n    নিচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফলকে সর্বাধিক করে। প্রতিটি\n    মান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\n    আর্গুমেন্টস:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\n      x-অক্ষাংশ, y-অক্ষাংশ, এবং মান থাকে যা সেই অবস্থানে গ্রিডে স্থাপন করা হবে।\n      তালিকাটি সমস্ত শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "bg": "Напишете Python функция 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:', за да решите следния проблем:\n\n    Изчислете максималната сума от стойности, събрани по два пътя в решетка N x N.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до\n    долния десен ъгъл на решетката, които максимизират сумата от събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя преминават през нея.\n\n    Аргументи:\n    - N (int): Размерът на решетката (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координатата, y-координатата и стойността, която да бъде поставена на решетката на тази позиция.\n      Списъкът завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "zh": "编写一个python函数'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:'来解决以下问题：\n\n    计算在N x N网格中收集的两个路径上的值的最大和。\n\n    此函数利用动态编程从网格的左上角找到两条路径到右下角，这两条路径最大化收集的值的和。即使两条路径都经过，每个值最多只能收集一次。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含x坐标、y坐标和要放置在该位置的网格上的值。列表以一个全为零的元组结束。\n\n    返回:\n    - int: 在两条路径上收集的值的最大和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "fr": "Écrivez une fonction python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins du coin supérieur gauche\n    au coin inférieur droit de la grille qui maximisent la somme des valeurs collectées. Chaque\n    valeur peut être collectée au maximum une fois, même si les deux chemins passent par elle.\n\n    Args:\n    - N (int): La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Returns:\n    - int: La somme maximale des valeurs collectées sur les deux chemins.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "de": "Schreiben Sie eine Python-Funktion 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die maximale Summe der Werte, die auf zwei Pfaden in einem N x N Gitter gesammelt werden.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt\n    zum unteren rechten Eckpunkt des Gitters zu finden, die die Summe der gesammelten Werte maximieren.\n    Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Gitters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position auf das Gitter gelegt werden soll.\n      Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "ha": "Rubuta wani aikin python 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa jimillar mafi girma na ƙimomin da aka tattara akan hanyoyi biyu a cikin grid N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\n    ƙasan dama na grid wanda ke haɓaka jimillar ƙimomin da aka tattara. Kowace\n    ƙima za a iya tattara ta sau ɗaya kawai, ko da kuwa duk hanyoyin biyu sun wuce ta.\n\n    Args:\n    - N (int): Girman grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi\n      x-coordinate, y-coordinate, da ƙima da za a sanya a grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple tare da duk sifili.\n\n    Returns:\n    - int: Jimillar mafi girma na ƙimomin da aka tattara akan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "hi": "एक पायथन फ़ंक्शन 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों का अधिकतम योग गणना करें।\n\n    यह फ़ंक्शन डायनामिक प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथ खोजे जा सकें जो एकत्रित मूल्यों के योग को अधिकतम करते हैं। प्रत्येक\n    मूल्य को अधिकतम एक बार एकत्र किया जा सकता है, भले ही दोनों पथ इसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): ट्यूपल्स की एक सूची जहां प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मूल्य होते हैं।\n      सूची सभी शून्य वाले एक ट्यूपल के साथ समाप्त होती है।\n\n    लौटाता है:\n    - int: दो पथों पर एकत्रित मूल्यों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "hu": "Írj egy python függvényt 'def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki az értékek maximális összegét, amelyet két útvonalon gyűjtenek össze egy N x N-es rácsban.\n\n    Ez a függvény dinamikus programozást használ, hogy megtalálja a rács bal felső sarkából a jobb alsó sarkába vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden értéket legfeljebb egyszer lehet összegyűjteni, még akkor is, ha mindkét útvonal áthalad rajta.\n\n    Argok:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy listája a tuple-öknek, ahol minden tuple tartalmazza az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni. A lista egy teljesen nullákból álló tuple-lel zárul.\n\n    Visszatér:\n    - int: Az értékek maximális összege, amelyet a két útvonalon gyűjtenek össze.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67"
    },
    "instruction_bertscore": {
      "sq": "0.9925070661362209",
      "hy": "0.9787137752163962",
      "bn": "0.9914499552483532",
      "bg": "0.9848437074055139",
      "zh": "0.9932914575109277",
      "fr": "0.9946832605908391",
      "de": "0.9855697014481964",
      "ha": "0.9649790802589768",
      "hi": "0.9928634090397975",
      "hu": "0.9846156797280858"
    },
    "level": "hard",
    "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()",
    "entry_point": "max_value_on_paths",
    "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ",
      "sq": "\n    Llogarit shumën maksimale të vlerave të mbledhura në dy shtigje në një rrjet N x N.\n\n    Kjo funksion përdor programimin dinamik për të gjetur dy shtigje nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetit që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dy shtigjet kalojnë përmes saj.\n\n    Argumentet:\n    - N (int): Madhësia e rrjetit (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjet në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zerot.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy shtigjet.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "hy": "\n    Հաշվեք արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիներով N x N ցանցում։\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղի ցանցի վերին ձախ անկյունից\n    դեպի ցանցի ներքևի աջ անկյունը, որոնք առավելագույնի են հասցնում հավաքված արժեքների գումարը։ Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով։\n\n    Արգումենտներ:\n    - N (int): Ցանցի չափը (N x N)։\n    - grid_values (List[Tuple[int, int, int]]): Կտորների ցուցակ, որտեղ յուրաքանչյուր կտոր պարունակում է\n      x-համակարգը, y-համակարգը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում։\n      Ցուցակը ավարտվում է բոլոր զրոներով կտորով։\n\n    Վերադարձնում է:\n    - int: Երկու ուղիներով հավաքված արժեքների առավելագույն գումարը։\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "bn": "\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে নিচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি মান সর্বাধিক একবার সংগ্রহ করা যেতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\n    আর্গুমেন্টস:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে গ্রিডের নির্দিষ্ট স্থানে স্থাপন করার জন্য x-সমন্বয়, y-সমন্বয় এবং মান থাকে। তালিকাটি সমস্ত শূন্য সহ একটি টুপল দ্বারা সমাপ্ত হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "bg": "\n    Изчислете максималната сума от стойности, събрани по два пътя в N x N мрежа.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до\n    долния десен ъгъл на мрежата, които максимизират сумата на събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\n    Аргументи:\n    - N (int): Размерът на мрежата (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\n      Списъкът завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "zh": "\n    计算在 N x N 网格中两条路径上收集的最大值和。\n\n    此函数利用动态规划找到从网格左上角到右下角的两条路径，以最大化收集的值的总和。\n    每个值最多只能收集一次，即使两条路径都经过该值。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含\n      x 坐标、y 坐标以及要放置在该位置的值。列表以全为零的元组结束。\n\n    返回:\n    - int: 两条路径上收集的最大值和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "fr": "\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins allant du coin\n    supérieur gauche au coin inférieur droit de la grille qui maximisent la somme des valeurs\n    collectées. Chaque valeur peut être collectée au maximum une fois, même si les deux chemins\n    passent par elle.\n\n    Args:\n    - N (int): La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Returns:\n    - int: La somme maximale des valeurs collectées sur les deux chemins.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    ",
      "de": "\n    Berechne die maximale Summe der auf zwei Pfaden gesammelten Werte in einem N x N Raster.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt\n    zum unteren rechten Eckpunkt des Rasters zu finden, die die Summe der gesammelten Werte maximieren.\n    Jeder Wert kann höchstens einmal gesammelt werden, auch wenn beide Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Rasters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position im Raster platziert wird.\n      Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "ha": "\n    Lissafa mafi girman jimillar ƙimomin da aka tattara a kan hanyoyi biyu a cikin grid ɗin N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\n    ƙasan dama na grid wanda ke ƙara yawan jimillar ƙimomin da aka tattara. Kowace ƙima za a iya tattarawa sau ɗaya kawai, ko da kuwa dukkan hanyoyin sun wuce ta cikinta.\n\n    Args:\n    - N (int): Girman grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi\n      x-coordinate, y-coordinate, da ƙima da za a sanya a kan grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple mai dukkan sifili.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimomin da aka tattara a kan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "hi": "\n    एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों का अधिकतम योग गणना करें।\n\n    यह फ़ंक्शन डायनेमिक प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथ खोजे जा सकें जो एकत्रित मूल्यों के योग को अधिकतम करें। प्रत्येक\n    मूल्य को अधिकतम एक बार एकत्र किया जा सकता है, भले ही दोनों पथ उसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): एक सूची जिसमें प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखा जाने वाला मूल्य होता है।\n      सूची एक ट्यूपल के साथ समाप्त होती है जिसमें सभी शून्य होते हैं।\n\n    लौटाता है:\n    - int: दो पथों पर एकत्रित मूल्यों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67",
      "hu": "\n    Számítsa ki az értékek maximális összegét, amelyet két úton gyűjtenek össze egy N x N-es rácsban.\n\n    Ez a függvény dinamikus programozást alkalmaz annak érdekében, hogy megtalálja a rács bal felső sarkából\n    a jobb alsó sarokba vezető két utat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden\n    értéket legfeljebb egyszer lehet összegyűjteni, még akkor is, ha mindkét út áthalad rajta.\n\n    Paraméterek:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy listája a hármasoknak, ahol minden hármas tartalmazza\n      az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni.\n      A lista egy teljesen nullás hármassal zárul.\n\n    Visszatér:\n    - int: Az értékek maximális összege, amelyet a két úton gyűjtöttek össze.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67"
    },
    "docstring_bertscore": {
      "sq": "0.9877147109329921",
      "hy": "0.97752834910238",
      "bn": "0.9829022940612789",
      "bg": "0.9863175448327928",
      "zh": "0.9837208498615236",
      "fr": "0.9931349367706722",
      "de": "0.9843963917874233",
      "ha": "0.9648189841718626",
      "hi": "0.9768017591685544",
      "hu": "0.970969772550989"
    }
  },
  {
    "task_id": "Python/9",
    "prompt": {
      "en": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "sq": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    të tilla që numri i dytë është dy herë i pari dhe i treti është tre herë i pari.\n\n    Kthen:\n        listë e treshave: Një listë e renditur e treshave, ku secila treshe përmban tre numra të plotë që përfaqësojnë\n                          kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "hy": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Գեներացնել երեք թվերի բոլոր եզակի կոմբինացիաները, որոնք կազմված են 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը լինի առաջինի կրկնակի, իսկ երրորդը՝ առաջինի եռակի։\n\n    Վերադարձնում է:\n        list of tuples: Դասավորված tuple-ների ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թվեր,\n                        որոնք ներկայացնում են վավեր թվային կոմբինացիաները աճման կարգով՝ հիմնված առաջին թվի վրա։\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "bn": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    ১ থেকে ৯ পর্যন্ত অঙ্কগুলি থেকে পুনরাবৃত্তি ছাড়াই গঠিত তিনটি সংখ্যার সমস্ত অনন্য সমন্বয় তৈরি করুন,\n    যাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\n    Returns:\n        list of tuples: একটি সাজানো টুপলের তালিকা, যেখানে প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা\n                        প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যার সমন্বয় উপস্থাপন করে।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "bg": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Генерира всички уникални комбинации от три числа, всяко от които е образувано от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти първото, а третото да е три пъти първото.\n\n    Връща:\n        списък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред на базата на първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "zh": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    生成由数字1到9组成的三个数字的所有唯一组合，且每个数字不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序后的元组列表，其中每个元组包含三个整数，表示根据第一个数字升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "fr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition,\n    de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Retourne:\n        list of tuples: Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                        combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\n    Exemple:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "de": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generiere alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    sodass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        list of tuples: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                        gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "ha": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Ƙirƙiri duk haɗe-haɗe na musamman na lambobi uku, kowanne an ƙirƙira shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu ta ninka ta farko sau biyu kuma ta uku ta ninka ta farko sau uku.\n\n    Abin da ake mayarwa:\n        jerin tuples: Jerin tuples da aka tsara, inda kowane tuple ya ƙunshi lambobi uku masu wakiltar\n                      haɗe-haɗen lambobi masu inganci a cikin tsari mai tashi dangane da lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "hi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1 से 9 तक के अंकों से बिना पुनरावृत्ति के बने तीन संख्याओं के सभी अद्वितीय संयोजनों को उत्पन्न करें,\n    ताकि दूसरी संख्या पहली का दोगुना हो और तीसरी संख्या पहली का तीन गुना हो।\n\n    Returns:\n        list of tuples: एक क्रमबद्ध सूची जिसमें प्रत्येक ट्यूपल तीन पूर्णांकों को दर्शाता है जो पहले नंबर के आधार पर \n                        आरोही क्रम में मान्य संख्या संयोजन हैं।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "hu": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generálja az összes egyedi háromszám-kombinációt, amelyeket az 1-től 9-ig terjedő számjegyekből képeznek ismétlés nélkül,\n    úgy, hogy a második szám kétszerese az elsőnek, a harmadik pedig háromszorosa az elsőnek.\n\n    Visszatér:\n        list of tuples: Egy rendezett lista a tuple-ökről, ahol minden tuple három egész számot tartalmaz,\n                        amelyek a megfelelő számkombinációkat ábrázolják növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9909339135184246",
      "hy": "0.9672756447245022",
      "bn": "0.9652960943471085",
      "bg": "0.9899584397171622",
      "zh": "0.950285993713064",
      "fr": "0.9903070360358784",
      "de": "0.9784291378803732",
      "ha": "0.9871641075167634",
      "hi": "0.9648521554454955",
      "hu": "0.9689864481963557"
    },
    "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])",
    "instruction": {
      "en": "Write a python function 'def find_number_combinations():' to solve the following problem:\n\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    ",
      "sq": "Shkruani një funksion python 'def find_number_combinations():' për të zgjidhur problemin e mëposhtëm:\n\n    Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    në mënyrë që numri i dytë të jetë dy herë më i madh se i pari dhe i treti të jetë tri herë më i madh se i pari.\n\n    Kthen:\n        listë tuplesh: Një listë e renditur tuplesh, ku secili tuple përmban tre numra të plotë që përfaqësojnë\n                        kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "hy": "Պայթոն ֆունկցիա 'def find_number_combinations():' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գեներացնել երեք թվերի բոլոր եզակի կոմբինացիաները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը լինի առաջինի կրկնակի և երրորդը՝ առաջինի եռակի:\n\n    Վերադարձնում է:\n        list of tuples: Դասավորված tuple-ների ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թիվ, \n                        որոնք ներկայացնում են վավեր թվային կոմբինացիաները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "bn": "একটি পাইথন ফাংশন 'def find_number_combinations():' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    তিনটি সংখ্যার সমস্ত অনন্য সমন্বয় তৈরি করুন, প্রতিটি সংখ্যা 1 থেকে 9 পর্যন্ত অঙ্ক থেকে পুনরাবৃত্তি ছাড়াই গঠিত,\n    যাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\n    Returns:\n        list of tuples: একটি সাজানো টিউপলের তালিকা, যেখানে প্রতিটি টিউপল তিনটি পূর্ণসংখ্যা ধারণ করে\n                        যা প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যার সমন্বয় উপস্থাপন করে।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "bg": "Напишете Python функция 'def find_number_combinations():' за решаване на следния проблем:\n\n    Генерирайте всички уникални комбинации от три числа, всяко образувано от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти първото, а третото да е три пъти първото.\n\n    Връща:\n        списък от кортежи: Подреден списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред на базата на първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "zh": "编写一个Python函数 'def find_number_combinations():' 以解决以下问题：\n\n    生成三个数字的所有唯一组合，每个数字由1到9的数字组成且不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序的元组列表，其中每个元组包含三个整数，\n                        表示基于第一个数字按升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "fr": "Écrivez une fonction python 'def find_number_combinations():' pour résoudre le problème suivant :\n\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition,\n    de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Renvoie :\n        liste de tuples : Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                          combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\n    Exemple :\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "de": "Schreiben Sie eine Python-Funktion 'def find_number_combinations():' um das folgende Problem zu lösen:\n\n    Generieren Sie alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    so dass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        Liste von Tupeln: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                          gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "ha": "Rubuta wani aikin python 'def find_number_combinations():' don warware matsalar mai zuwa:\n\n    Samar da dukkan haɗin gwiwar na musamman na lambobi uku, kowanne an kafa shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu tana ninki biyu na na farko kuma ta uku tana ninki uku na na farko.\n\n    Returns:\n        list of tuples: Jerin jerin jeri wanda aka tsara, inda kowanne tuple ya ƙunshi lambobi uku da ke wakiltar\n                        sahihan haɗin lambobi a tsari mai tashi bisa lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "hi": "एक पायथन फ़ंक्शन 'def find_number_combinations():' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    तीन संख्याओं के सभी अद्वितीय संयोजनों को उत्पन्न करें, जिनमें से प्रत्येक को 1 से 9 तक के अंकों से बिना पुनरावृत्ति के बनाया गया है,\n    ताकि दूसरी संख्या पहली का दो गुना हो और तीसरी संख्या पहली का तीन गुना हो।\n\n    लौटाता है:\n        सूची का ट्यूपल: ट्यूपलों की एक क्रमबद्ध सूची, जहाँ प्रत्येक ट्यूपल में तीन पूर्णांक होते हैं जो पहले नंबर के आधार पर \n                        आरोही क्रम में मान्य संख्या संयोजनों का प्रतिनिधित्व करते हैं।\n\n    उदाहरण:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "hu": "Írj egy python függvényt 'def find_number_combinations():' a következő probléma megoldására:\n\n    Generálj minden egyedi kombinációt három számból, amelyek mindegyike az 1-től 9-ig terjedő számjegyekből van kialakítva ismétlés nélkül,\n    úgy, hogy a második szám kétszerese az elsőnek, és a harmadik háromszorosa az elsőnek.\n\n    Visszatérési érték:\n        list of tuples: Egy rendezett lista tuple-ökkel, ahol minden tuple három egész számot tartalmaz, amelyek a\n                        érvényes számkombinációkat képviselik növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]"
    },
    "instruction_bertscore": {
      "sq": "0.9928115665103474",
      "hy": "0.9755370795325052",
      "bn": "0.9723492605472763",
      "bg": "0.9877917795208337",
      "zh": "0.9664787396357902",
      "fr": "0.9916529554977709",
      "de": "0.9890854591925139",
      "ha": "0.9719758354309307",
      "hi": "0.9724738017961851",
      "hu": "0.9906212692986757"
    },
    "level": "middle",
    "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")",
    "entry_point": "find_number_combinations",
    "signature": "def find_number_combinations():",
    "docstring": {
      "en": "\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    ",
      "sq": "\n    Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    në mënyrë që numri i dytë të jetë dy herë i pari dhe i treti të jetë tre herë i pari.\n\n    Kthen:\n        list of tuples: Një listë e renditur tuples, ku secili tuple përmban tre numra të plotë që përfaqësojnë\n                        kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "hy": "\n    Գեներացնել երեք թվերի բոլոր եզակի համակցությունները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը երկու անգամ մեծ լինի առաջինից, իսկ երրորդը՝ երեք անգամ մեծ լինի առաջինից:\n\n    Վերադարձնում է:\n        list of tuples: Կարգավորված tuple-ների ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թիվ, \n                        որոնք ներկայացնում են վավեր թվային համակցությունները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "bn": "\n    ১ থেকে ৯ পর্যন্ত অঙ্কগুলি থেকে পুনরাবৃত্তি ছাড়াই গঠিত তিনটি সংখ্যার সমস্ত অনন্য সংমিশ্রণ তৈরি করুন, \n    যাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\n    Returns:\n        list of tuples: একটি সাজানো টুপলের তালিকা, যেখানে প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা \n                        প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যার সংমিশ্রণ উপস্থাপন করে।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "bg": "\n    Генерирайте всички уникални комбинации от три числа, всяко от които е образувано от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти по-голямо от първото, а третото да е три пъти по-голямо от първото.\n\n    Връща:\n        списък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред въз основа на първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "zh": "\n    生成所有由数字1到9组成的三个数字的唯一组合，每个数字不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序后的元组列表，其中每个元组包含三个整数，表示基于第一个数字按升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "fr": "\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition,\n    de sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Retourne:\n        list of tuples: Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                        combinaisons de nombres valides en ordre croissant basé sur le premier nombre.\n\n    Exemple:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "de": "\n    Erzeuge alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    so dass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        list of tuples: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                        gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "ha": "\n    Samar da duk haɗakarwa na musamman na lambobi uku, kowanne an ƙirƙira shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu sau biyu ce ta farko kuma ta uku sau uku ce ta farko.\n\n    Yana dawowa:\n        jerin tubalan: Jerin tubalan da aka tsara, inda kowane tubali ya ƙunshi lambobi uku da ke wakiltar\n                        haɗakar lambobi masu inganci a cikin tsari mai tashi dangane da lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "hi": "\n    1 से 9 तक के अंकों से बिना पुनरावृत्ति के बने तीन संख्याओं के सभी अद्वितीय संयोजन उत्पन्न करें,\n    ताकि दूसरी संख्या पहली संख्या का दोगुना हो और तीसरी संख्या पहली संख्या का तीन गुना हो।\n\n    Returns:\n        list of tuples: एक क्रमबद्ध सूची जो tuples का समावेश करती है, जहाँ प्रत्येक tuple तीन पूर्णांकों को \n                        दर्शाता है जो पहले संख्या के आधार पर आरोही क्रम में वैध संख्या संयोजन हैं।\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]",
      "hu": "\n    Generálja az összes egyedi kombinációját három számnak, mindegyik az 1-től 9-ig terjedő számjegyekből ismétlés nélkül, úgy, hogy a második szám kétszerese az elsőnek, a harmadik pedig háromszorosa az elsőnek.\n\n    Visszatér:\n        list of tuples: Egy rendezett lista a tuple-ökkel, ahol minden tuple három egész számot tartalmaz, amelyek a megfelelő számkombinációkat képviselik növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]"
    },
    "docstring_bertscore": {
      "sq": "0.9891458428283485",
      "hy": "0.9785101790758355",
      "bn": "0.958204592483401",
      "bg": "0.9951561995280832",
      "zh": "0.9551184722532619",
      "fr": "0.9898960697775173",
      "de": "0.9898960697775173",
      "ha": "0.9743445027247718",
      "hi": "0.962679933598498",
      "hu": "0.9746597291394742"
    }
  },
  {
    "task_id": "Python/10",
    "prompt": {
      "en": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "sq": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\n    Kjo funksion përdor një metodë më efikase për të llogaritur faktoriel duke shumëzuar\n    në mënyrë iterative numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur\n    llogaritjet e panevojshme. Pastaj akumulon faktorielin e çdo numri nga 1 deri te n përfshirë.\n\n    Argumentet:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "hy": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Հաշվարկել ֆակտորիալ արժեքների կուտակային գումարը 1-ից մինչև նշված ամբողջ թիվ n:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալներ հաշվարկելու համար՝\n    հերթական թվի բազմապատկմամբ նախորդ ֆակտորիալ արդյունքի վրա, այդպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\n    Պարամետրեր:\n    n (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկել ֆակտորիալների գումարը:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1! -ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "bn": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    ১ থেকে নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানের সমষ্টি গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য আরও দক্ষ পদ্ধতি ব্যবহার করে, \n    যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে \n    পুনরাবৃত্তি করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। \n    এরপর এটি ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়াল যোগ করে।\n\n    আর্গুমেন্টসমূহ:\n    n (int): সেই পরিসরের উপরের সীমা যার জন্য ফ্যাক্টোরিয়াল সমষ্টি গণনা করা হবে।\n             n এর মান ১ থেকে ৫০ এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    রিটার্নস:\n    int: ১! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের সমষ্টি।\n\n    উদাহরণ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "bg": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Изчислява кумулативната сума на факториелните стойности от 1 до зададено цяло число n.\n\n    Тази функция използва по-ефективен метод за изчисляване на факториелите, като итеративно\n    умножава текущото число с предишния резултат от факториела, като по този начин избягва\n    излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\n    Аргументи:\n    n (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n             Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\n    Връща:\n    int: Сумата на всички факториелни стойности от 1! до n!.\n\n    Примери:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "zh": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    计算从1到指定整数n的阶乘值的累积和。\n\n    此函数采用更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。\n    然后累加从1到n（包括n）的每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围上限。\n             n的值应在1到50之间（包括1和50）。\n\n    返回:\n    int: 从1!到n!的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "fr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    itérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi des calculs\n    redondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "de": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl iterativ mit dem vorherigen Fakultätsergebnis multipliziert, um so\n    redundante Berechnungen zu vermeiden. Anschließend akkumuliert sie die Fakultät jeder Zahl\n    von 1 bis einschließlich n.\n\n    Argumente:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\n    Rückgabewert:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "ha": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka fayyace.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorial ta hanyar\n    ninka adadin yanzu da sakamakon factorial na baya, don haka yana guje wa lissafi\n    mai maimaitawa. Daga nan yana tara factorial na kowane adadi daga 1 zuwa n har da shi.\n\n    Args:\n    n (int): Iyakar kewayon da za a lissafa jimillar factorial.\n             Darajar n ya kamata ta kasance a cikin kewayon 1 zuwa 50, har da shi.\n\n    Returns:\n    int: Jimillar duk darajar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "hi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1 से लेकर एक निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल्स की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, \n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करके अनावश्यक गणनाओं से बचता है। \n    इसके बाद यह 1 से n तक प्रत्येक संख्या के फैक्टोरियल को जोड़ता है।\n\n    Args:\n    n (int): वह सीमा जिसके लिए फैक्टोरियल योग की गणना की जानी है।\n             n का मान 1 से 50 के बीच होना चाहिए, समावेशी।\n\n    Returns:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\"",
      "hu": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Számítsa ki a faktoriális értékek kumulatív összegét 1-től egy megadott n egész számig.\n\n    Ez a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy\n    iteratívan szorozza meg az aktuális számot az előző faktoriális eredménnyel, így elkerülve\n    a felesleges számításokat. Ezután összegzi az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\n    Paraméterek:\n    n (int): Az a felső határ, amelynek tartományához a faktoriális összegét ki kell számítani.\n             Az n értékének 1 és 50 között kell lennie, beleértve.\n\n    Visszatérési érték:\n    int: Az 1! és n! közötti összes faktoriális érték összege.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9612734318703899",
      "hy": "0.9526475103131878",
      "bn": "0.9605345268529402",
      "bg": "0.9735267414460511",
      "zh": "0.962110460296071",
      "fr": "0.9831783902909174",
      "de": "0.974220954627768",
      "ha": "0.9442770274259966",
      "hi": "0.9538996762352318",
      "hu": "0.9508703642940687"
    },
    "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials",
    "instruction": {
      "en": "Write a python function 'def sum_of_factorials_optimized(n: int) -> int:' to solve the following problem:\n\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "sq": "Shkruani një funksion python 'def sum_of_factorials_optimized(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni shumën kumulative të vlerave faktoriale nga 1 deri te një numër i caktuar n.\n\n    Ky funksion përdor një metodë më efikase për të llogaritur faktorialet duke shumëzuar në mënyrë iterative\n    numrin aktual me rezultatin e mëparshëm faktorial, duke shmangur kështu llogaritjet e panevojshme.\n    Më pas akumulon faktorialin e secilit numër nga 1 deri në n përfshirë.\n\n    Args:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma faktoriale.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriale nga 1! deri në n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "hy": "Պայթոն ֆունկցիա 'def sum_of_factorials_optimized(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք ֆակտորիալ արժեքների կումուլյատիվ գումարը 1-ից մինչև նշված ամբողջ թիվ n:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվարկելու համար՝\n    ընթացիկ թիվը բազմապատկելով նախորդ ֆակտորիալ արդյունքի հետ, այդպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\n    Արգումենտներ:\n    n (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկվի ֆակտորիալ գումարը:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1! -ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "bn": "একটি পাইথন ফাংশন 'def sum_of_factorials_optimized(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    1 থেকে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানগুলির সামষ্টিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। এটি তারপর 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে অন্তর্ভুক্ত করে যোগফল করে।\n\n    Args:\n    n (int): ফ্যাক্টোরিয়াল যোগফল গণনা করার জন্য যার পরিসরের উপরের সীমা।\n             n এর মান 1 থেকে 50 এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    Returns:\n    int: 1! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের যোগফল।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "bg": "Напишете Python функция 'def sum_of_factorials_optimized(n: int) -> int:', за да решите следния проблем:\n\n    Изчислете кумулативната сума на факториелните стойности от 1 до дадено цяло число n.\n\n    Тази функция използва по-ефективен метод за изчисляване на факториели, като итеративно\n    умножава текущото число с предишния резултат от факториела, като по този начин избягва\n    излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\n    Аргументи:\n    n (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n             Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\n    Връща:\n    int: Сумата на всички факториелни стойности от 1! до n!.\n\n    Примери:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "zh": "编写一个 python 函数 'def sum_of_factorials_optimized(n: int) -> int:' 来解决以下问题：\n\n    计算从 1 到指定整数 n 的阶乘值的累积和。\n\n    该函数采用一种更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。然后，它累积从 1 到 n（包括 n）的每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围的上限。\n             n 的值应在 1 到 50 之间（包括 1 和 50）。\n\n    返回:\n    int: 从 1! 到 n! 的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "fr": "Écrivez une fonction python 'def sum_of_factorials_optimized(n: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    itérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi les calculs redondants.\n    Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Exemples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "de": "Schreiben Sie eine Python-Funktion 'def sum_of_factorials_optimized(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl iterativ mit dem vorherigen Fakultätsergebnis multipliziert und so\n    redundante Berechnungen vermeidet. Anschließend summiert sie die Fakultät jeder Zahl von 1 bis einschließlich n.\n\n    Argumente:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\n    Rückgabewert:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "ha": "Rubuta wani aikin python 'def sum_of_factorials_optimized(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa jimlar jimlar ƙimar factorial daga 1 har zuwa wani cikakken lamba n.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorials ta hanyar \n    ninka lambar yanzu zuwa sakamakon factorial na baya, ta haka yana guje wa lissafin \n    da ba dole ba. Sannan yana tara factorial na kowace lamba daga 1 zuwa n har da shi.\n\n    Args:\n    n (int): Iyakar kewayon wanda za a lissafa jimlar factorial.\n             Darajar n ya kamata ta kasance a cikin kewayon 1 zuwa 50, har da shi.\n\n    Returns:\n    int: Jimlar duk ƙimar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "hi": "एक पायथन फ़ंक्शन 'def sum_of_factorials_optimized(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    1 से लेकर निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल्स की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, \n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करके पुनरावृत्त रूप से करता है, \n    इस प्रकार अनावश्यक गणनाओं से बचता है। फिर यह 1 से n तक प्रत्येक संख्या का फैक्टोरियल \n    समावेशी रूप से संचित करता है।\n\n    तर्क:\n    n (int): वह सीमा जिसके लिए फैक्टोरियल योग की गणना की जानी है।\n             n का मान 1 से 50 के बीच होना चाहिए, समावेशी।\n\n    लौटाता है:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    उदाहरण:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153",
      "hu": "Írj egy Python függvényt 'def sum_of_factorials_optimized(n: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a faktoriális értékek összegét 1-től egy megadott n egész számig.\n\n    Ez a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy iteratívan\n    szorozza a jelenlegi számot az előző faktoriális eredménnyel, így elkerülve a felesleges\n    számításokat. Ezután összegzi az 1-től n-ig terjedő számok faktoriálisát, beleértve.\n\n    Argumentumok:\n    n (int): Az a tartomány felső határa, amelyre a faktoriális összeg kiszámítandó.\n             Az n értékének 1 és 50 között kell lennie, beleértve.\n\n    Visszatér:\n    int: Az összes faktoriális érték összege 1!-től n!-ig.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153"
    },
    "instruction_bertscore": {
      "sq": "0.9754713328763827",
      "hy": "0.9696214695245242",
      "bn": "0.9588674220649143",
      "bg": "0.9698002368674556",
      "zh": "0.962760180272436",
      "fr": "0.9807195448040865",
      "de": "0.9785250763544131",
      "ha": "0.9567343304029806",
      "hi": "0.9676017958101615",
      "hu": "0.9522778591740819"
    },
    "level": "easy",
    "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()",
    "entry_point": "sum_of_factorials_optimized",
    "signature": "def sum_of_factorials_optimized(n: int) -> int:",
    "docstring": {
      "en": "\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "sq": "\n    Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\n    Kjo funksion përdor një metodë më efikase për të llogaritur faktorielët duke shumëzuar në mënyrë iteruese\n    numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur kështu llogaritjet e panevojshme.\n    Më pas, akumulon faktorielin e secilit numër nga 1 deri te n përfshirë.\n\n    Argumentet:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "hy": "\n    Հաշվել ֆակտորիալ արժեքների կուտակային գումարը 1-ից մինչև նշված n ամբողջ թիվը:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվելու համար՝\n    հերթական թվին բազմապատկելով նախորդ ֆակտորիալի արդյունքը, այդպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\n    Պարամետրեր:\n    n (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկել ֆակտորիալների գումարը:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1!-ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "bn": "\n    ১ থেকে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানগুলির ক্রমবর্ধমান যোগফল গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে, যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। এটি ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে অন্তর্ভুক্ত করে জমা করে।\n\n    আর্গস:\n    n (int): ফ্যাক্টোরিয়াল যোগফল গণনা করার জন্য সীমার উপরের সীমা।\n             n এর মান ১ থেকে ৫০ এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    রিটার্নস:\n    int: ১! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের যোগফল।\n\n    উদাহরণ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "bg": "\n    Изчислете кумулативната сума на факториелните стойности от 1 до дадено цяло число n.\n\nТази функция използва по-ефективен метод за изчисляване на факториели, като итеративно умножава текущото число с предишния резултат на факториела, като по този начин избягва излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\nАргументи:\nn (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n         Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\nВръща:\nint: Сумата на всички факториелни стойности от 1! до n!.\n\nПримери:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n    153\n    ",
      "zh": "\n    计算从 1 到指定整数 n 的阶乘值的累积和。\n\n    该函数采用一种更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。\n    然后累积从 1 到 n（包括 n）每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围上限。\n             n 的值应在 1 到 50 之间（包括 1 和 50）。\n\n    返回:\n    int: 从 1! 到 n! 的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "fr": "\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    de manière itérative le nombre actuel par le résultat factoriel précédent, évitant ainsi les\n    calculs redondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme des factorielles doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "de": "\n    Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl mit dem vorherigen Fakultätsergebnis multipliziert, um so redundante\n    Berechnungen zu vermeiden. Anschließend summiert sie die Fakultät jeder Zahl von 1 bis einschließlich n.\n\n    Argumente:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\n    Rückgabewert:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "ha": "\n    Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka kayyade.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorial ta hanyar\n    ninka adadi na yanzu da sakamakon factorial na baya, don haka yana guje wa lissafi\n    maras amfani. Sannan yana tara factorial na kowanne adadi daga 1 zuwa n ciki har da shi.\n\n    Args:\n    n (int): Iyakacin adadin da za a lissafa jimillar factorial.\n             Darajar n ya kamata ta kasance a tsakanin 1 zuwa 50, ciki har da su.\n\n    Returns:\n    int: Jimillar dukkan darajar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "hi": "\n    1 से लेकर एक निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, \n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करके अनावश्यक गणनाओं से बचता है। \n    फिर यह 1 से n तक प्रत्येक संख्या के फैक्टोरियल को जोड़ता है।\n\n    तर्क:\n    n (int): उस सीमा का ऊपरी सीमा जिसके लिए फैक्टोरियल योग की गणना की जानी है। \n             n का मान 1 से 50 की सीमा में होना चाहिए, समावेशी।\n\n    वापसी:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    उदाहरण:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    ",
      "hu": "\n    Számítsa ki az 1-től egy megadott n egész számig terjedő faktoriális értékek kumulatív összegét.\n\n    Ez a függvény hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy iteratívan\n    megszorozza a jelenlegi számot az előző faktoriális eredménnyel, így elkerülve a felesleges\n    számításokat. Ezután összegzi az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\n    Paraméterek:\n    n (int): Az a tartomány felső határa, amelyre a faktoriális összeget ki kell számítani.\n             Az n értékének 1 és 50 között kell lennie, beleértve mindkettőt.\n\n    Visszatér:\n    int: Az 1! és n! közötti összes faktoriális érték összege.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9663937258327072",
      "hy": "0.9499062124245253",
      "bn": "0.9474400176135962",
      "bg": "0.9608149929509614",
      "zh": "0.9484474709062051",
      "fr": "0.9817426898967972",
      "de": "0.9539719776939285",
      "ha": "0.9286156177725388",
      "hi": "0.9615282746492577",
      "hu": "0.9428778750219868"
    }
  },
  {
    "task_id": "Python/11",
    "prompt": {
      "en": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"",
      "sq": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të cilin do të gjendet fraksioni përkatës.\n\n    Kthen:\n    - str: Një përfaqësim me varg i fraksionit në pozicionin e N-të në tabelën e Cantor-it.\n    \"\"\"",
      "hy": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Որոշում է Cantor աղյուսակի N-րդ անդամի համարիչը և հայտարարիչը։\n\n    Պարամետրեր:\n    - N (int): Դիրքը Cantor աղյուսակում, որի համար պետք է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Տողային ներկայացում Cantor աղյուսակի N-րդ դիրքի կոտորակի։\n    \"\"\"",
      "bn": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    ক্যান্টর টেবিলের N-তম পদের লব ও হর নির্ধারণ করে।\n\n    আর্গুমেন্ট:\n    - N (int): ক্যান্টর টেবিলে যে অবস্থানের জন্য সংশ্লিষ্ট ভগ্নাংশ খুঁজতে হবে।\n\n    রিটার্নস:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে থাকা ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।\n    \"\"\"",
      "bg": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.\n    \"\"\"",
      "zh": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    确定康托表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): 康托表中要查找对应分数的位置。\n\n    返回:\n    - str: 康托表中第 N 个位置的分数的字符串表示。\n    \"\"\"",
      "fr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\n    Arguments:\n    - N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\n    Retourne:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.\n    \"\"\"",
      "de": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\n    Rückgabe:\n    - str: Eine Zeichenfolgenrepräsentation des Bruchs an der N-ten Position in der Cantor-Tabelle.\n    \"\"\"",
      "ha": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Tabbatar da mai ƙididdigewa da kuma mai rarrabawa na juzu'i na N-na a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayi a cikin teburin Cantor don nemo juzu'i daidai da shi.\n\n    Returns:\n    - str: Wakilcin juzu'i a matsayin kirtani a matsayi na N a cikin teburin Cantor.\n    \"\"\"",
      "hi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor तालिका में N-वें पद का अंश और हर का निर्धारण करता है।\n\n    तर्क:\n    - N (int): Cantor तालिका में वह स्थिति जिसके लिए संबंधित भिन्न को खोजा जाना है।\n\n    वापसी:\n    - str: Cantor तालिका में N-वें स्थान पर भिन्न का स्ट्रिंग प्रतिनिधित्व।\n    \"\"\"",
      "hu": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Meghatározza az N-edik elem számlálóját és nevezőjét a Cantor-táblázatban.\n\n    Args:\n    - N (int): A Cantor-táblázatban lévő pozíció, amelyhez a megfelelő törtet meg kell találni.\n\n    Returns:\n    - str: A Cantor-táblázat N-edik pozícióján lévő tört szöveges ábrázolása.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9678467070699774",
      "hy": "0.9625929334916047",
      "bn": "0.9593858473594153",
      "bg": "0.985954647126642",
      "zh": "0.9659795814882495",
      "fr": "0.9529230106516832",
      "de": "0.9754244561064584",
      "ha": "0.9490566702848391",
      "hi": "0.9733698234450335",
      "hu": "0.955791233353827"
    },
    "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"",
    "instruction": {
      "en": "Write a python function 'def cantor_numbering(N: int) -> str:' to solve the following problem:\n\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    ",
      "sq": "Shkruani një funksion python 'def cantor_numbering(N: int) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të gjetur thyesën përkatëse.\n\n    Kthen:\n    - str: Një përfaqësim me varg i thyesës në pozicionin e N-të në tabelën e Cantor-it.",
      "hy": "Պայթոն ֆունկցիա 'def cantor_numbering(N: int) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Սահմանում է Cantor աղյուսակի N-րդ անդամի համարիչը և հայտարարը։\n\n    Արձագանքներ:\n    - N (int): Cantor աղյուսակում դիրքը, որի համար պետք է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Տողային ներկայացում Cantor աղյուսակի N-րդ դիրքի կոտորակի համար։",
      "bn": "একটি পাইথন ফাংশন 'def cantor_numbering(N: int) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ক্যান্টর টেবিলের N-তম পদটির লব এবং হর নির্ধারণ করে।\n\n    আর্গুমেন্ট:\n    - N (int): ক্যান্টর টেবিলে অবস্থান, যার জন্য সংশ্লিষ্ট ভগ্নাংশ খুঁজে বের করতে হবে।\n\n    রিটার্নস:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।",
      "bg": "Напишете функция на Python 'def cantor_numbering(N: int) -> str:' за да решите следния проблем:\n\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стрингова репрезентация на дробта на N-тата позиция в таблицата на Кантор.",
      "zh": "编写一个 python 函数 'def cantor_numbering(N: int) -> str:' 来解决以下问题：\n\n    确定 Cantor 表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): Cantor 表中要查找对应分数的位置。\n\n    返回:\n    - str: Cantor 表中第 N 位置的分数的字符串表示。",
      "fr": "Écrivez une fonction python 'def cantor_numbering(N: int) -> str:' pour résoudre le problème suivant :\n\n    Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\n    Args:\n    - N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\n    Retourne:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.",
      "de": "Schreiben Sie eine Python-Funktion 'def cantor_numbering(N: int) -> str:', um das folgende Problem zu lösen:\n\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, um den entsprechenden Bruch zu finden.\n\n    Rückgaben:\n    - str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.",
      "ha": "Rubuta wani aikin python 'def cantor_numbering(N: int) -> str:' don warware matsalar mai zuwa:\n\n    Yana tantance mai lamba da mai kasa na sharadi na N a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayin a cikin teburin Cantor don nemo rabon da ya dace.\n\n    Returns:\n    - str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.",
      "hi": "एक पायथन फ़ंक्शन 'def cantor_numbering(N: int) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    कैंटर तालिका में N-वें पद के अंश और हर का निर्धारण करता है।\n\n    तर्क:\n    - N (int): कैंटर तालिका में वह स्थिति जिसके लिए संबंधित भिन्न खोजनी है।\n\n    लौटाता है:\n    - str: कैंटर तालिका में N-वें स्थिति पर भिन्न का स्ट्रिंग प्रतिनिधित्व।",
      "hu": "Írj egy Python függvényt 'def cantor_numbering(N: int) -> str:' a következő probléma megoldására:\n\n    Meghatározza az N-edik tétel számlálóját és nevezőjét a Cantor táblázatban.\n\n    Argumentumok:\n    - N (int): A pozíció a Cantor táblázatban, amelyhez meg kell találni a megfelelő törtet.\n\n    Visszatér:\n    - str: A tört szöveges ábrázolása az N-edik pozíción a Cantor táblázatban."
    },
    "instruction_bertscore": {
      "sq": "0.9835543976022164",
      "hy": "0.9675960355291114",
      "bn": "0.9722014795437863",
      "bg": "0.9752294010722822",
      "zh": "0.9685133106287306",
      "fr": "0.954026402418332",
      "de": "0.9926095594128349",
      "ha": "0.9244169687782233",
      "hi": "0.9771960404749086",
      "hu": "0.9515764952986477"
    },
    "level": "easy",
    "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()",
    "entry_point": "cantor_numbering",
    "signature": "def cantor_numbering(N: int) -> str:",
    "docstring": {
      "en": "\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    ",
      "sq": "\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të gjetur fraksionin përkatës.\n\n    Kthen:\n    - str: Një përfaqësim në formë vargu i fraksionit në pozicionin e N-të në tabelën e Cantor-it.",
      "hy": "\n    Որոշում է Կանտորի աղյուսակի N-րդ անդամի համարիչը և հայտարարիչը։\n\n    Արգումենտներ:\n    - N (int): Դիրքը Կանտորի աղյուսակում, որի համար պետք է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Կանտորի աղյուսակի N-րդ դիրքում գտնվող կոտորակի տողային ներկայացումը։",
      "bn": "\n    ক্যান্টর টেবিলের N-তম পদের লব এবং হর নির্ধারণ করে।\n\n    আর্গুমেন্টসমূহ:\n    - N (int): ক্যান্টর টেবিলে যে অবস্থানের জন্য সংশ্লিষ্ট ভগ্নাংশ খুঁজে বের করতে হবে।\n\n    রিটার্ন:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে থাকা ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।",
      "bg": "\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.",
      "zh": "\n    确定康托表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): 康托表中要查找对应分数的位置。\n\n    返回:\n    - str: 康托表中第 N 个位置的分数的字符串表示。",
      "fr": "\n    Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\n    Args:\n    - N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\n    Returns:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.",
      "de": "\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\n    Rückgabe:\n    - str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.",
      "ha": "\n    Yana tantance mai lamba da mai kasa na sharadi na N a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayin a cikin teburin Cantor don nemo rabon da ya dace.\n\n    Returns:\n    - str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.",
      "hi": "\n    कैन्टर तालिका में N-वें पद का अंश और हर का निर्धारण करता है।\n\n    तर्क:\n    - N (int): कैन्टर तालिका में स्थिति जिसके लिए संबंधित भिन्न को खोजना है।\n\n    लौटाता है:\n    - str: कैन्टर तालिका में N-वें स्थान पर भिन्न का स्ट्रिंग प्रतिनिधित्व।",
      "hu": "\n    Meghatározza a Cantor-táblázat N-edik elemének számlálóját és nevezőjét.\n\n    Paraméterek:\n    - N (int): A Cantor-táblázatban lévő pozíció, amelyhez a megfelelő törtet meg kell találni.\n\n    Visszatér:\n    - str: A Cantor-táblázat N-edik pozícióján lévő tört szöveges ábrázolása."
    },
    "docstring_bertscore": {
      "sq": "0.9389199660494857",
      "hy": "0.9045592936950224",
      "bn": "0.9217328764392989",
      "bg": "0.9613342127669866",
      "zh": "0.9485855190210244",
      "fr": "0.9554928905215127",
      "de": "0.9570491595569209",
      "ha": "0.920190710160944",
      "hi": "0.9552217600514",
      "hu": "0.918813208468467"
    }
  },
  {
    "task_id": "Python/12",
    "prompt": {
      "en": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"",
      "sq": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja të shumëzimit në vargun e numrave.)\n    \"\"\"",
      "hy": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Ֆունկցիայի անունը: max_product\n    Արգումենտներ:\n    num_str (str): Տող, որը ներկայացնում է թվային տողը։\n    N (int): Թվային տողի երկարությունը ներկայացնող ամբողջ թիվ։\n    K (int): Ամբողջ թիվ, որը ներկայացնում է տեղադրելու բազմապատկման նշանների քանակը։\n    Վերադարձի տիպը: int (Ֆունկցիան վերադարձնում է առավելագույն արտադրյալը, որը կարելի է ստանալ թվային տողի մեջ K բազմապատկման նշաններ տեղադրելով։)\n    \"\"\"",
      "bn": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): একটি স্ট্রিং যা সংখ্যা স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যা স্ট্রিংয়ের দৈর্ঘ্যকে উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা প্রবেশ করানোর জন্য গুণচিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে Kটি গুণচিহ্ন প্রবেশ করিয়ে প্রাপ্ত সর্বাধিক গুণফল রিটার্ন করে।)\n    \"\"\"",
      "bg": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Име на функция: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния произведение, което може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)\n    \"\"\"",
      "zh": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (该函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)\n    \"\"\"",
      "fr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nom de la fonction : max_product\n    Arguments :\n    num_str (str) : Une chaîne représentant le nombre sous forme de chaîne.\n    N (int) : Un entier représentant la longueur de la chaîne de nombres.\n    K (int) : Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour : int (La fonction renvoie le produit maximum pouvant être obtenu en insérant K signes de multiplication dans la chaîne de nombres.)\n    \"\"\"",
      "de": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Ein Integer, der die Länge der Zahlenfolge darstellt.\n    K (int): Ein Integer, der die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch das Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)\n    \"\"\"",
      "ha": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Sunan aiki: max_product\n    Huɗɗa:\n    num_str (str): Wani kirtani da ke wakiltar lambar kirtani.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon lambar kirtani.\n    K (int): Wani cikakken lamba da ke wakiltar yawan alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka K alamomin ninkawa cikin lambar kirtani.)\n    \"\"\"",
      "hi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): संख्या स्ट्रिंग का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    N (int): संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    K (int): गुणा चिह्नों की संख्या डालने का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    वापसी प्रकार: int (यह फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)\n    \"\"\"",
      "hu": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a számkarakterláncot képviseli.\n    N (int): Egy egész szám, amely a számkarakterlánc hosszát jelenti.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelenti.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet a K szorzásjel beszúrásával lehet elérni a számkarakterláncba.)\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9621585288482813",
      "hy": "0.9763754983708535",
      "bn": "0.9803336059737358",
      "bg": "0.958654887557207",
      "zh": "0.9562609942049746",
      "fr": "0.9781047744681433",
      "de": "0.9638937638570022",
      "ha": "0.9751126064082337",
      "hi": "0.9866103260144382",
      "hu": "0.9850683583664643"
    },
    "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]",
    "instruction": {
      "en": "Write a python function 'def max_product(num_str: str, N: int, K: int) -> int:' to solve the following problem:\n\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    ",
      "sq": "Shkruani një funksion python 'def max_product(num_str: str, N: int, K: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për të futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja shumëzimi në vargun e numrave.)",
      "hy": "Պայթոն ֆունկցիա 'def max_product(num_str: str, N: int, K: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Ֆունկցիայի անունը: max_product\n    Արգումենտներ:\n    num_str (str): Թվային տողը ներկայացնող տող:\n    N (int): Թվային տողի երկարությունը ներկայացնող ամբողջ թիվ:\n    K (int): Մուտքագրելու բազմապատկման նշանների քանակը ներկայացնող ամբողջ թիվ:\n    Վերադարձի տիպը: int (Ֆունկցիան վերադարձնում է առավելագույն արդյունքը, որը կարող է ստացվել թվային տողի մեջ K բազմապատկման նշաններ մուտքագրելով:)",
      "bn": "একটি পাইথন ফাংশন 'def max_product(num_str: str, N: int, K: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টস:\n    num_str (str): একটি স্ট্রিং যা সংখ্যার স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যার স্ট্রিংয়ের দৈর্ঘ্য উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা প্রবেশ করানোর জন্য গুণের চিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে K গুণের চিহ্ন প্রবেশ করিয়ে প্রাপ্ত সর্বাধিক গুণফল রিটার্ন করে।)",
      "bg": "Напишете Python функция 'def max_product(num_str: str, N: int, K: int) -> int:' за да решите следния проблем:\n\n    Име на функцията: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния продукт, който може да бъде получен чрез вмъкване на K знака за умножение в числовия низ.)",
      "zh": "编写一个Python函数 'def max_product(num_str: str, N: int, K: int) -> int:' 来解决以下问题:\n\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)",
      "fr": "Écrivez une fonction python 'def max_product(num_str: str, N: int, K: int) -> int:' pour résoudre le problème suivant :\n\n    Nom de la fonction : max_product\n    Arguments :\n    num_str (str) : Une chaîne représentant la chaîne de chiffres.\n    N (int) : Un entier représentant la longueur de la chaîne de chiffres.\n    K (int) : Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour : int (La fonction retourne le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)",
      "de": "Schreiben Sie eine Python-Funktion 'def max_product(num_str: str, N: int, K: int) -> int:' um das folgende Problem zu lösen:\n\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)",
      "ha": "Rubuta wani aikin python 'def max_product(num_str: str, N: int, K: int) -> int:' don warware matsalar mai zuwa:\n\n    Sunan aiki: max_product\n    Hujojji:\n    num_str (str): Wani zare mai wakiltar zaren lamba.\n    N (int): Wani cikakken lamba mai wakiltar tsawon zaren lamba.\n    K (int): Wani cikakken lamba mai wakiltar adadin alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka alamomin ninkawa K cikin zaren lamba.)",
      "hi": "एक पायथन फ़ंक्शन 'def max_product(num_str: str, N: int, K: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): एक स्ट्रिंग जो संख्या स्ट्रिंग का प्रतिनिधित्व करती है।\n    N (int): एक पूर्णांक जो संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करता है।\n    K (int): एक पूर्णांक जो डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करता है।\n    लौटाने का प्रकार: int (फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)",
      "hu": "Írj egy python függvényt 'def max_product(num_str: str, N: int, K: int) -> int:' a következő probléma megoldására:\n\n    Függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a számkarakterláncot ábrázolja.\n    N (int): Egy egész szám, amely a számkarakterlánc hosszát jelöli.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelöli.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amely elérhető a K szorzásjel beszúrásával a számkarakterláncba.)"
    },
    "instruction_bertscore": {
      "sq": "0.9632337151008232",
      "hy": "0.9647307922826832",
      "bn": "0.9770424991903687",
      "bg": "0.9774115544383315",
      "zh": "0.9639813598550385",
      "fr": "0.9595399845350985",
      "de": "0.9634627359301564",
      "ha": "0.9768504236119079",
      "hi": "0.9806577707555847",
      "hu": "0.9736177141605651"
    },
    "level": "middle",
    "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()",
    "entry_point": "max_product",
    "signature": "def max_product(num_str: str, N: int, K: int) -> int:",
    "docstring": {
      "en": "\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    ",
      "sq": "\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja shumëzimi në vargun e numrave.)",
      "hy": "\n    Գործառույթի անունը: max_product\n    Փոփոխականներ:\n    num_str (str): Թվային տողը ներկայացնող տող։\n    N (int): Թվային տողի երկարությունը ներկայացնող ամբողջ թիվ։\n    K (int): Մուլտիպլիկացիայի նշանների քանակը տեղադրելու համար ներկայացնող ամբողջ թիվ։\n    Վերադարձի տեսակը: int (Գործառույթը վերադարձնում է առավելագույն արդյունքը, որը կարելի է ստանալ թվային տողի մեջ K մուլտիպլիկացիայի նշաններ տեղադրելով։)",
      "bn": "\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): একটি স্ট্রিং যা সংখ্যার স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যার স্ট্রিংয়ের দৈর্ঘ্যকে উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা যোগ করার জন্য গুণ চিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে Kটি গুণ চিহ্ন যোগ করে প্রাপ্ত সর্বাধিক গুণফল প্রদান করে।)",
      "bg": "\n    Име на функция: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния произведение, което може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)",
      "zh": "\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (该函数返回通过在数字字符串中插入 K 个乘号可以获得的最大乘积。)",
      "fr": "\n    Nom de la fonction: max_product\n    Arguments:\n    num_str (str): Une chaîne représentant la chaîne de chiffres.\n    N (int): Un entier représentant la longueur de la chaîne de chiffres.\n    K (int): Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour: int (La fonction renvoie le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)",
      "de": "\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)",
      "ha": "\n    Sunan aiki: max_product\n    Huɗa:\n    num_str (str): Wani kirtani da ke wakiltar lambar kirtani.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon lambar kirtani.\n    K (int): Wani cikakken lamba da ke wakiltar adadin alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka alamomin ninkawa K cikin lambar kirtani.)",
      "hi": "\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): एक स्ट्रिंग जो संख्या स्ट्रिंग का प्रतिनिधित्व करती है।\n    N (int): एक पूर्णांक जो संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करता है।\n    K (int): एक पूर्णांक जो डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करता है।\n    लौटाने का प्रकार: int (यह फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)",
      "hu": "\n    A függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a számot reprezentálja.\n    N (int): Egy egész szám, amely a szám karakterlánc hosszát jelöli.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelöli.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet a szám karakterláncba K szorzásjel beszúrásával lehet elérni.)"
    },
    "docstring_bertscore": {
      "sq": "0.9472719763112406",
      "hy": "0.9476763877670277",
      "bn": "0.9222709661415224",
      "bg": "0.9680969813500815",
      "zh": "0.9461288584683849",
      "fr": "0.9498470205709769",
      "de": "0.9439794791152063",
      "ha": "0.9459858445940398",
      "hi": "0.975792120941754",
      "hu": "0.9654593685203191"
    }
  },
  {
    "task_id": "Python/13",
    "prompt": {
      "en": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"\n\n",
      "sq": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Nëse nota mesatare përfundimtare është më e madhe se 80 dhe një ose më shumë punime janë publikuar, do të shtohet një bursë prej 8000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 pikë dhe vlerësimi i klasës është më i madh se 80 pikë, bursa do të rritet me 4000 pikë\n    Nëse nota mesatare përfundimtare është më e madhe se 90 pikë, bursa do të rritet me 2000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 dhe studenti është nga rajoni perëndimor, bursa do të rritet me 1000\n    Nëse vlerësimi përfundimtar i klasës është më i madh se 80 pikë dhe lideri i klasës është lideri i klasës, bursa do të rritet me 850 pikë\n\n    Parametra:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është lider i klasës.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër i plotë që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti është i kualifikuar.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "hy": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Եթե վերջնական միջին գնահատականը մեծ է 80-ից և մեկ կամ ավելի հոդվածներ են տպագրվել, ապա 8000 դրամի կրթաթոշակ կավելացվի\n    Եթե վերջնական միջին գնահատականը մեծ է 85 միավորից և դասի գնահատականը մեծ է 80 միավորից, ապա կրթաթոշակը կավելանա 4000 միավորով\n    Եթե վերջնական միջին գնահատականը մեծ է 90 միավորից, ապա կրթաթոշակը կավելանա 2000-ով\n    Եթե վերջնական միջին գնահատականը մեծ է 85-ից և ուսանողը արևմտյան տարածաշրջանից է, ապա կրթաթոշակը կավելանա 1000-ով\n    Եթե դասի վերջնական գնահատականը մեծ է 80 միավորից և դասի ղեկավարը դասի ղեկավարն է, ապա կրթաթոշակը կավելանա 850-ով\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարր պարունակող ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [տարեվերջի միջին, դասի գնահատական]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը դասի ղեկավար է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից տպագրված գիտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Կրթաթոշակի ընդհանուր գումարը, որին ուսանողը իրավունք ունի:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "bn": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    যদি চূড়ান্ত গড় স্কোর 80 এর বেশি হয় এবং এক বা একাধিক পেপার প্রকাশিত হয়, তাহলে 8000 টাকার বৃত্তি যোগ করা হবে\n    যদি চূড়ান্ত গড় স্কোর 85 পয়েন্টের বেশি হয় এবং শ্রেণীর মূল্যায়ন 80 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 4000 পয়েন্ট বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর 90 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 2000 বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর 85 এর বেশি হয় এবং ছাত্রটি পশ্চিমাঞ্চল থেকে আসে, তাহলে বৃত্তি 1000 বাড়ানো হবে\n    যদি শ্রেণীর চূড়ান্ত মূল্যায়ন 80 পয়েন্টের বেশি হয় এবং শ্রেণী নেতা শ্রেণী নেতা হয়, তাহলে বৃত্তি 850 বাড়ানো হবে\n\n    Parameters:\n    grades (list of int): একটি দুই-উপাদান তালিকা যা ছাত্রের একাডেমিক গ্রেড [টার্মের শেষ গড়, শ্রেণীর মূল্যায়ন] ধারণ করে।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে ছাত্রটি শ্রেণী নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে ছাত্রটি পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা ছাত্রের দ্বারা প্রকাশিত গবেষণাপত্রের সংখ্যা নির্দেশ করে।\n\n    Returns:\n    int: ছাত্রটি যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "bg": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Ако крайната средна оценка е по-голяма от 80 и е публикувана една или повече статии, ще се добави стипендия от 8000\n    Ако крайната средна оценка е по-голяма от 85 точки и оценката на класа е по-голяма от 80 точки, стипендията ще се увеличи с 4000 точки\n    Ако крайната средна оценка е по-голяма от 90 точки, стипендията ще се увеличи с 2000\n    Ако крайната средна оценка е по-голяма от 85 и студентът е от западния регион, стипендията ще се увеличи с 1000\n    Ако крайната оценка на класа е по-голяма от 80 точки и класният ръководител е класен ръководител, стипендията ще се увеличи с 850 точки\n\n    Параметри:\n    grades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [среден успех в края на срока, оценка на класа].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен ръководител.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на публикуваните научни статии от студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "zh": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    如果期末平均分大于80且发表了一篇或多篇论文，则奖学金增加8000\n    如果期末平均分大于85分且班级评估大于80分，则奖学金增加4000分\n    如果期末平均分大于90分，则奖学金增加2000\n    如果期末平均分大于85且学生来自西部地区，则奖学金增加1000\n    如果班级的最终评估大于80分且班长是班长，则奖学金增加850分\n\n    参数:\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均, 班级评估]。\n    leader (str): 一个字符串 ('Y' 或 'N')，表示学生是否是班长。\n    west (str): 一个字符串 ('Y' 或 'N')，表示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回:\n    int: 学生有资格获得的总奖学金金额。\n\n    示例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "fr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Si la note moyenne finale est supérieure à 80 et qu'un ou plusieurs articles sont publiés, une bourse de 8000 sera ajoutée\n    Si la note moyenne finale est supérieure à 85 points et que l'évaluation de la classe est supérieure à 80 points, la bourse sera augmentée de 4000 points\n    Si la note moyenne finale est supérieure à 90 points, la bourse sera augmentée de 2000\n    Si la note moyenne finale est supérieure à 85 et que l'étudiant est de la région ouest, la bourse sera augmentée de 1000\n    Si l'évaluation finale de la classe est supérieure à 80 points et que le chef de classe est le chef de classe, la bourse sera augmentée de 850 points\n\n    Paramètres:\n    grades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de la classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un chef de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est d'une province de l'ouest.\n    papers (int): Un entier représentant le nombre d'articles de recherche publiés par l'étudiant.\n\n    Retourne:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "de": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Wenn die endgültige Durchschnittsnote größer als 80 ist und ein oder mehrere Arbeiten veröffentlicht werden, wird ein Stipendium von 8000 hinzugefügt.\n    Wenn die endgültige Durchschnittsnote größer als 85 Punkte ist und die Klassenbewertung größer als 80 Punkte ist, wird das Stipendium um 4000 Punkte erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 90 Punkte ist, wird das Stipendium um 2000 erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 85 ist und der Student aus der westlichen Region stammt, wird das Stipendium um 1000 erhöht.\n    Wenn die endgültige Bewertung der Klasse größer als 80 Punkte ist und der Klassensprecher der Klassensprecher ist, wird das Stipendium um 850 erhöht.\n\n    Parameter:\n    grades (list of int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Durchschnitt am Ende des Semesters, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student ein Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\n    papers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabe:\n    int: Der Gesamtbetrag des Stipendiums, für den der Student berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "ha": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Idan matsakaicin maki na ƙarshe ya fi 80 kuma an buga ɗaya ko fiye da haka, za a ƙara tallafin karatu na 8000\n    Idan matsakaicin maki na ƙarshe ya fi maki 85 kuma kimantawa na aji ya fi maki 80, za a ƙara tallafin karatu da maki 4000\n    Idan matsakaicin maki na ƙarshe ya fi maki 90, za a ƙara tallafin karatu da 2000\n    Idan matsakaicin maki na ƙarshe ya fi 85 kuma ɗalibin yana daga yankin yamma, za a ƙara tallafin karatu da 1000\n    Idan kimantawa na ƙarshe na aji ya fi maki 80 kuma shugaban aji shine shugaban aji, za a ƙara tallafin karatu da 850\n\n    Parameters:\n    grades (list of int): Jerin abubuwa guda biyu da ke dauke da maki na ɗalibi [matsakaicin ƙarshen lokaci, kimantawa na aji].\n    leader (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin shine shugaban aji.\n    west (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin yana daga lardin yamma.\n    papers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibin ya buga.\n\n    Returns:\n    int: Jimlar adadin tallafin karatu da ɗalibin ya cancanci samu.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "hi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    यदि अंतिम औसत स्कोर 80 से अधिक है और एक या अधिक पेपर प्रकाशित हैं, तो 8000 की छात्रवृत्ति जोड़ी जाएगी\n    यदि अंतिम औसत स्कोर 85 अंक से अधिक है और कक्षा मूल्यांकन 80 अंक से अधिक है, तो छात्रवृत्ति 4000 अंक से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 90 अंक से अधिक है, तो छात्रवृत्ति 2000 से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 85 से अधिक है और छात्र पश्चिमी क्षेत्र से है, तो छात्रवृत्ति 1000 से बढ़ाई जाएगी\n    यदि कक्षा का अंतिम मूल्यांकन 80 अंक से अधिक है और कक्षा लीडर कक्षा लीडर है, तो छात्रवृत्ति 850 से बढ़ाई जाएगी\n\n    पैरामीटर्स:\n    grades (list of int): दो तत्वों की सूची जिसमें छात्र के शैक्षणिक ग्रेड [अवधि के अंत का औसत, कक्षा मूल्यांकन] शामिल हैं।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा लीडर है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या को दर्शाता है।\n\n    रिटर्न्स:\n    int: कुल छात्रवृत्ति राशि जिसके लिए छात्र पात्र है।\n\n    उदाहरण:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\"",
      "hu": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Ha a végső átlagpontszám nagyobb, mint 80, és egy vagy több publikáció van, akkor 8000 ösztöndíjat adnak hozzá\n    Ha a végső átlagpontszám nagyobb, mint 85 pont, és az osztályértékelés nagyobb, mint 80 pont, akkor az ösztöndíjat 4000 ponttal növelik\n    Ha a végső átlagpontszám nagyobb, mint 90 pont, akkor az ösztöndíjat 2000-rel növelik\n    Ha a végső átlagpontszám nagyobb, mint 85, és a diák nyugati régióból származik, akkor az ösztöndíjat 1000-rel növelik\n    Ha az osztály végső értékelése nagyobb, mint 80 pont, és az osztályvezető az osztályvezető, akkor az ösztöndíjat 850-rel növelik\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely a diák tanulmányi eredményeit tartalmazza [félévi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a diák által publikált kutatási dolgozatok számát jelzi.\n\n    Visszatér:\n    int: Az összes ösztöndíj összege, amelyre a diák jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9621245630531244",
      "hy": "0.9409674480171933",
      "bn": "0.9727985624691773",
      "bg": "0.9657896908439801",
      "zh": "0.9462452558716713",
      "fr": "0.9844508165118269",
      "de": "0.9620711314806261",
      "ha": "0.9466480782844101",
      "hi": "0.9719589518485428",
      "hu": "0.9612686647412451"
    },
    "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship",
    "instruction": {
      "en": "Write a python function 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' to solve the following problem:\n\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ",
      "sq": "Shkruani një funksion python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Nëse nota mesatare përfundimtare është më e madhe se 80 dhe një ose më shumë punime janë publikuar, një bursë prej 8000 do të shtohet\n    Nëse nota mesatare përfundimtare është më e madhe se 85 pikë dhe vlerësimi i klasës është më i madh se 80 pikë, bursa do të rritet me 4000 pikë\n    Nëse nota mesatare përfundimtare është më e madhe se 90 pikë, bursa do të rritet me 2000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 dhe studenti është nga rajoni perëndimor, bursa do të rritet me 1000\n    Nëse vlerësimi përfundimtar i klasës është më i madh se 80 pikë dhe drejtuesi i klasës është drejtuesi i klasës, bursa do të rritet me 850 pikë\n\n    Parametrat:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është drejtues i klasës.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër i plotë që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti është i kualifikuar.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "hy": "Պայթոն ֆունկցիա 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Եթե վերջնական միջին գնահատականը գերազանցում է 80-ը և մեկ կամ ավելի հոդվածներ հրապարակված են, կավելացվի 8000 դրամի կրթաթոշակ\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85 միավորը և դասի գնահատականը գերազանցում է 80 միավորը, կրթաթոշակը կավելանա 4000 միավորով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 90 միավորը, կրթաթոշակը կավելանա 2000-ով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85-ը և ուսանողը արևմտյան տարածաշրջանից է, կրթաթոշակը կավելանա 1000-ով\n    Եթե դասի վերջնական գնահատականը գերազանցում է 80 միավորը և դասի ղեկավարը դասի ղեկավարն է, կրթաթոշակը կավելանա 850 միավորով\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարրից բաղկացած ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [կիսամյակի վերջի միջին, դասի գնահատական]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը դասի ղեկավար է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Թիվ, որը ներկայացնում է ուսանողի կողմից հրապարակված գիտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Կրթաթոշակի ընդհանուր գումարը, որին ուսանողը իրավունք ունի:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "bn": "একটি পাইথন ফাংশন 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    যদি চূড়ান্ত গড় স্কোর 80 এর বেশি হয় এবং একটি বা একাধিক পেপার প্রকাশিত হয়, তাহলে 8000 টাকার বৃত্তি যোগ করা হবে\n    যদি চূড়ান্ত গড় স্কোর 85 পয়েন্টের বেশি হয় এবং শ্রেণীর মূল্যায়ন 80 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 4000 পয়েন্ট দ্বারা বৃদ্ধি পাবে\n    যদি চূড়ান্ত গড় স্কোর 90 পয়েন্টের বেশি হয়, তাহলে বৃত্তি 2000 দ্বারা বৃদ্ধি পাবে\n    যদি চূড়ান্ত গড় স্কোর 85 এর বেশি হয় এবং ছাত্রটি পশ্চিমাঞ্চল থেকে আসে, তাহলে বৃত্তি 1000 দ্বারা বৃদ্ধি পাবে\n    যদি শ্রেণীর চূড়ান্ত মূল্যায়ন 80 পয়েন্টের বেশি হয় এবং শ্রেণীর নেতা শ্রেণীর নেতা হয়, তাহলে বৃত্তি 850 পয়েন্ট দ্বারা বৃদ্ধি পাবে\n\n    Parameters:\n    grades (list of int): একটি দুই-উপাদান তালিকা যা শিক্ষার্থীর একাডেমিক গ্রেড [টার্মের শেষ গড়, শ্রেণীর মূল্যায়ন] ধারণ করে।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে যে শিক্ষার্থী শ্রেণীর নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে যে শিক্ষার্থী পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা শিক্ষার্থীর দ্বারা প্রকাশিত গবেষণা পেপারের সংখ্যা উপস্থাপন করে।\n\n    Returns:\n    int: শিক্ষার্থী যে মোট বৃত্তির জন্য যোগ্য তার পরিমাণ।\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "bg": "Напишете Python функция 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' за решаване на следния проблем:\n\n    Ако крайната средна оценка е по-голяма от 80 и е публикувана една или повече статии, ще бъде добавена стипендия от 8000\n    Ако крайната средна оценка е по-голяма от 85 точки и оценката на класа е по-голяма от 80 точки, стипендията ще бъде увеличена с 4000 точки\n    Ако крайната средна оценка е по-голяма от 90 точки, стипендията ще бъде увеличена с 2000\n    Ако крайната средна оценка е по-голяма от 85 и студентът е от западния регион, стипендията ще бъде увеличена с 1000\n    Ако крайната оценка на класа е по-голяма от 80 точки и класният ръководител е класният ръководител, стипендията ще бъде увеличена с 850 точки\n\n    Параметри:\n    grades (list of int): Списък с два елемента, съдържащ академичните оценки на студента [средна оценка в края на срока, оценка на класа].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен ръководител.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на научните статии, публикувани от студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "zh": "编写一个 Python 函数 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' 来解决以下问题：\n\n    如果期末平均分大于80且发表了一篇或多篇论文，则增加8000的奖学金\n    如果期末平均分大于85分且班级评价大于80分，则奖学金增加4000分\n    如果期末平均分大于90分，则奖学金增加2000\n    如果期末平均分大于85且学生来自西部地区，则奖学金增加1000\n    如果班级的最终评估大于80分且班长是班长，则奖学金增加850分\n\n    参数：\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均分, 班级评价]。\n    leader (str): 一个字符串 ('Y' 或 'N')，指示学生是否是班长。\n    west (str): 一个字符串 ('Y' 或 'N')，指示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回：\n    int: 学生有资格获得的总奖学金金额。\n\n    示例：\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "fr": "Écrivez une fonction python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' pour résoudre le problème suivant :\n\n    Si la note moyenne finale est supérieure à 80 et qu'un ou plusieurs articles sont publiés, une bourse de 8000 sera ajoutée.\n    Si la note moyenne finale est supérieure à 85 points et que l'évaluation de la classe est supérieure à 80 points, la bourse sera augmentée de 4000 points.\n    Si la note moyenne finale est supérieure à 90 points, la bourse sera augmentée de 2000.\n    Si la note moyenne finale est supérieure à 85 et que l'étudiant est de la région ouest, la bourse sera augmentée de 1000.\n    Si l'évaluation finale de la classe est supérieure à 80 points et que le chef de classe est le chef de classe, la bourse sera augmentée de 850 points.\n\n    Paramètres:\n    grades (list of int): Une liste à deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de la classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un chef de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est d'une province de l'ouest.\n    papers (int): Un entier représentant le nombre d'articles de recherche publiés par l'étudiant.\n\n    Renvoie:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "de": "Schreiben Sie eine Python-Funktion 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:', um das folgende Problem zu lösen:\n\n    Wenn die endgültige Durchschnittsnote größer als 80 ist und ein oder mehrere Arbeiten veröffentlicht wurden, wird ein Stipendium von 8000 hinzugefügt.\n    Wenn die endgültige Durchschnittsnote größer als 85 Punkte ist und die Klassenbewertung größer als 80 Punkte ist, wird das Stipendium um 4000 Punkte erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 90 Punkte ist, wird das Stipendium um 2000 erhöht.\n    Wenn die endgültige Durchschnittsnote größer als 85 ist und der Schüler aus der westlichen Region kommt, wird das Stipendium um 1000 erhöht.\n    Wenn die endgültige Bewertung der Klasse größer als 80 Punkte ist und der Klassensprecher der Klassensprecher ist, wird das Stipendium um 850 Punkte erhöht.\n\n    Parameter:\n    grades (list von int): Eine Liste mit zwei Elementen, die die akademischen Noten des Schülers enthält [Durchschnitt am Ende des Semesters, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Schüler Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Schüler aus einer westlichen Provinz stammt.\n    papers (int): Eine Ganzzahl, die die Anzahl der vom Schüler veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabe:\n    int: Der Gesamtbetrag des Stipendiums, für das der Schüler berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "ha": "Rubuta wani aikin python 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' don warware matsalar mai zuwa:\n\n    Idan matsakaicin maki na ƙarshe ya fi 80 kuma an buga takardu ɗaya ko fiye, za a ƙara tallafin karatu na 8000\n    Idan matsakaicin maki na ƙarshe ya fi maki 85 kuma kimantawa na aji ya fi maki 80, za a ƙara tallafin karatu da maki 4000\n    Idan matsakaicin maki na ƙarshe ya fi maki 90, za a ƙara tallafin karatu da 2000\n    Idan matsakaicin maki na ƙarshe ya fi 85 kuma ɗalibin yana daga yankin yamma, za a ƙara tallafin karatu da 1000\n    Idan kimantawa na ƙarshe na aji ya fi maki 80 kuma shugaban aji shine shugaban aji, za a ƙara tallafin karatu da maki 850\n\n    Sigogi:\n    grades (list na int): Jerin abubuwa guda biyu da ke ƙunshe da maki na ɗalibin [matsakaicin ƙarshen lokaci, kimantawa na aji].\n    leader (str): Wata kirtani ('Y' ko 'N') da ke nuna idan ɗalibin shine shugaban aji.\n    west (str): Wata kirtani ('Y' ko 'N') da ke nuna idan ɗalibin yana daga lardin yamma.\n    papers (int): Wani lamba da ke wakiltar yawan takardun bincike da ɗalibin ya wallafa.\n\n    Returns:\n    int: Jimlar adadin tallafin karatu da ɗalibin ya cancanta.\n\n    Misalai:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "hi": "एक पायथन फ़ंक्शन 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    यदि अंतिम औसत स्कोर 80 से अधिक है और एक या अधिक शोध पत्र प्रकाशित होते हैं, तो 8000 की छात्रवृत्ति जोड़ी जाएगी\n    यदि अंतिम औसत स्कोर 85 अंकों से अधिक है और कक्षा मूल्यांकन 80 अंकों से अधिक है, तो छात्रवृत्ति 4000 अंकों से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 90 अंकों से अधिक है, तो छात्रवृत्ति 2000 से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 85 से अधिक है और छात्र पश्चिमी क्षेत्र से है, तो छात्रवृत्ति 1000 से बढ़ाई जाएगी\n    यदि कक्षा का अंतिम मूल्यांकन 80 अंकों से अधिक है और कक्षा नेता कक्षा का नेता है, तो छात्रवृत्ति 850 से बढ़ाई जाएगी\n\n    पैरामीटर:\n    grades (list of int): एक दो-तत्वों वाली सूची जिसमें छात्र के शैक्षणिक ग्रेड [सत्रांत औसत, कक्षा मूल्यांकन] शामिल हैं।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा का नेता है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या का प्रतिनिधित्व करता है।\n\n    लौटाता है:\n    int: कुल छात्रवृत्ति राशि जिसके लिए छात्र पात्र है।\n\n    उदाहरण:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "hu": "Írj egy python függvényt 'def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:' a következő probléma megoldására:\n\n    Ha a végső átlagpontszám nagyobb, mint 80, és egy vagy több dolgozat megjelenik, akkor 8000 ösztöndíjat adnak hozzá\n    Ha a végső átlagpontszám nagyobb, mint 85 pont, és az osztályértékelés nagyobb, mint 80 pont, akkor az ösztöndíj 4000 ponttal növekszik\n    Ha a végső átlagpontszám nagyobb, mint 90 pont, akkor az ösztöndíj 2000-rel növekszik\n    Ha a végső átlagpontszám nagyobb, mint 85, és a diák a nyugati régióból származik, akkor az ösztöndíj 1000-rel növekszik\n    Ha az osztály végső értékelése nagyobb, mint 80 pont, és az osztályvezető az osztályvezető, akkor az ösztöndíj 850 ponttal növekszik\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely tartalmazza a diák tanulmányi eredményeit [félév végi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák egy nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a diák által publikált kutatási dolgozatok számát jelöli.\n\n    Visszatér:\n    int: Az összes ösztöndíj összege, amelyre a diák jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000"
    },
    "instruction_bertscore": {
      "sq": "0.9624632278527889",
      "hy": "0.9294433105703112",
      "bn": "0.9632372904476818",
      "bg": "0.9616412953360666",
      "zh": "0.9437480747213007",
      "fr": "0.9776443492449044",
      "de": "0.9628197693867465",
      "ha": "0.9318938135811385",
      "hi": "0.9568622483683671",
      "hu": "0.9646489565656968"
    },
    "level": "easy",
    "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()",
    "entry_point": "calculate_scholarship",
    "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:",
    "docstring": {
      "en": "\n    If the final average score is greater than 80 and one or more papers are published, a scholarship of 8000 will be added\n    If the final average score is greater than 85 points and the class evaluation is greater than 80 points, the scholarship will be increased by 4000 points\n    If the final average score is greater than 90 points, the scholarship will be increased by 2000\n    If the final average score is greater than 85 and the student is from the western region, the scholarship will be increased by 1000\n    If the final assessment of the class is greater than 80 points and the class leader is the class leader, the scholarship will be increased by 850 points\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ",
      "sq": "\n    Nëse nota mesatare përfundimtare është më e madhe se 80 dhe një ose më shumë punime janë publikuar, një bursë prej 8000 do të shtohet\n    Nëse nota mesatare përfundimtare është më e madhe se 85 pikë dhe vlerësimi i klasës është më i madh se 80 pikë, bursa do të rritet me 4000 pikë\n    Nëse nota mesatare përfundimtare është më e madhe se 90 pikë, bursa do të rritet me 2000\n    Nëse nota mesatare përfundimtare është më e madhe se 85 dhe studenti është nga rajoni perëndimor, bursa do të rritet me 1000\n    Nëse vlerësimi përfundimtar i klasës është më i madh se 80 pikë dhe udhëheqësi i klasës është udhëheqësi i klasës, bursa do të rritet me 850 pikë\n\n    Parametra:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është udhëheqës i klasës.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti është i kualifikuar.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "hy": "\n    Եթե վերջնական միջին գնահատականը գերազանցում է 80-ը և հրապարակված է մեկ կամ ավելի հոդվածներ, ապա 8000 դրամի կրթաթոշակ կավելացվի\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85 միավորը և դասի գնահատականը գերազանցում է 80 միավորը, ապա կրթաթոշակը կավելանա 4000 միավորով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 90 միավորը, ապա կրթաթոշակը կավելանա 2000-ով\n    Եթե վերջնական միջին գնահատականը գերազանցում է 85-ը և ուսանողը արևմտյան տարածաշրջանից է, ապա կրթաթոշակը կավելանա 1000-ով\n    Եթե դասի վերջնական գնահատականը գերազանցում է 80 միավորը և դասի ղեկավարը դասի ղեկավարն է, ապա կրթաթոշակը կավելանա 850-ով\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարրերից բաղկացած ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [կիսամյակի վերջնական միջին, դասի գնահատում]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը դասի ղեկավար է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, թե արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից հրապարակված գիտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Կրթաթոշակի ընդհանուր գումարը, որին ուսանողը իրավասու է:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "bn": "\n    যদি চূড়ান্ত গড় স্কোর ৮০ এর বেশি হয় এবং একটি বা একাধিক পেপার প্রকাশিত হয়, তাহলে ৮০০০ টাকার বৃত্তি যোগ করা হবে\n    যদি চূড়ান্ত গড় স্কোর ৮৫ পয়েন্টের বেশি হয় এবং শ্রেণীর মূল্যায়ন ৮০ পয়েন্টের বেশি হয়, তাহলে বৃত্তি ৪০০০ পয়েন্ট বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর ৯০ পয়েন্টের বেশি হয়, তাহলে বৃত্তি ২০০০ বাড়ানো হবে\n    যদি চূড়ান্ত গড় স্কোর ৮৫ এর বেশি হয় এবং শিক্ষার্থী পশ্চিমাঞ্চল থেকে হয়, তাহলে বৃত্তি ১০০০ বাড়ানো হবে\n    যদি শ্রেণীর চূড়ান্ত মূল্যায়ন ৮০ পয়েন্টের বেশি হয় এবং শ্রেণী নেতা শ্রেণী নেতা হয়, তাহলে বৃত্তি ৮৫০ পয়েন্ট বাড়ানো হবে\n\n    প্যারামিটারসমূহ:\n    grades (list of int): একটি দুই-উপাদান তালিকা যা শিক্ষার্থীর একাডেমিক গ্রেড [টার্মের শেষ গড়, শ্রেণীর মূল্যায়ন] ধারণ করে।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী শ্রেণী নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা শিক্ষার্থীর প্রকাশিত গবেষণাপত্রের সংখ্যা নির্দেশ করে।\n\n    রিটার্নস:\n    int: শিক্ষার্থী যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\n    উদাহরণ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "bg": "\n    Ако крайната средна оценка е по-голяма от 80 и е публикувана една или повече статии, ще бъде добавена стипендия от 8000\n    Ако крайната средна оценка е по-голяма от 85 точки и оценката на класа е по-голяма от 80 точки, стипендията ще бъде увеличена с 4000 точки\n    Ако крайната средна оценка е по-голяма от 90 точки, стипендията ще бъде увеличена с 2000\n    Ако крайната средна оценка е по-голяма от 85 и студентът е от западния регион, стипендията ще бъде увеличена с 1000\n    Ако крайната оценка на класа е по-голяма от 80 точки и класният ръководител е класен ръководител, стипендията ще бъде увеличена с 850 точки\n\n    Параметри:\n    grades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [средна оценка в края на срока, оценка на класа].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен ръководител.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на научните статии, публикувани от студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "zh": "\n    如果期末平均分大于80且发表了一篇或多篇论文，则增加8000奖学金\n    如果期末平均分大于85分且班级评价大于80分，则奖学金增加4000分\n    如果期末平均分大于90分，则奖学金增加2000\n    如果期末平均分大于85且学生来自西部地区，则奖学金增加1000\n    如果班级的最终评估大于80分且班长是班长，则奖学金增加850分\n\n    参数:\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均分, 班级评价]。\n    leader (str): 一个字符串 ('Y' 或 'N')，表示学生是否是班长。\n    west (str): 一个字符串 ('Y' 或 'N')，表示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回:\n    int: 学生有资格获得的总奖学金金额。\n\n    示例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "fr": "\n    Si la moyenne finale est supérieure à 80 et qu'un ou plusieurs articles sont publiés, une bourse de 8000 sera ajoutée.\n    Si la moyenne finale est supérieure à 85 points et que l'évaluation de la classe est supérieure à 80 points, la bourse sera augmentée de 4000 points.\n    Si la moyenne finale est supérieure à 90 points, la bourse sera augmentée de 2000.\n    Si la moyenne finale est supérieure à 85 et que l'étudiant est de la région occidentale, la bourse sera augmentée de 1000.\n    Si l'évaluation finale de la classe est supérieure à 80 points et que le chef de classe est le chef de classe, la bourse sera augmentée de 850 points.\n\n    Paramètres:\n    grades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de la classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un chef de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est d'une province occidentale.\n    papers (int): Un entier représentant le nombre d'articles de recherche publiés par l'étudiant.\n\n    Retourne:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n    ",
      "de": "\n    Wenn die endgültige Durchschnittsnote größer als 80 ist und ein oder mehrere Arbeiten veröffentlicht wurden, wird ein Stipendium von 8000 hinzugefügt\n    Wenn die endgültige Durchschnittsnote größer als 85 Punkte ist und die Klassenbewertung größer als 80 Punkte ist, wird das Stipendium um 4000 Punkte erhöht\n    Wenn die endgültige Durchschnittsnote größer als 90 Punkte ist, wird das Stipendium um 2000 erhöht\n    Wenn die endgültige Durchschnittsnote größer als 85 ist und der Student aus der westlichen Region stammt, wird das Stipendium um 1000 erhöht\n    Wenn die endgültige Bewertung der Klasse größer als 80 Punkte ist und der Klassensprecher der Klassensprecher ist, wird das Stipendium um 850 erhöht\n\n    Parameter:\n    grades (list of int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Ende der Semester-Durchschnitt, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\n    papers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabe:\n    int: Der Gesamtbetrag des Stipendiums, für den der Student berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "ha": "\n    Idan matsakaicin maki na ƙarshe ya fi 80 kuma an buga takardu ɗaya ko fiye, za a ƙara tallafin karatu na 8000\n    Idan matsakaicin maki na ƙarshe ya fi maki 85 kuma kimantawa na aji ya fi maki 80, za a ƙara tallafin karatu da maki 4000\n    Idan matsakaicin maki na ƙarshe ya fi maki 90, za a ƙara tallafin karatu da 2000\n    Idan matsakaicin maki na ƙarshe ya fi 85 kuma ɗalibin daga yankin yamma ne, za a ƙara tallafin karatu da 1000\n    Idan kimantawa na ƙarshe na aji ya fi maki 80 kuma shugaban aji ne, za a ƙara tallafin karatu da 850\n\n    Parameters:\n    grades (list of int): Jerin abubuwa guda biyu da ke ɗauke da maki na ɗalibi [matsakaicin ƙarshen zangon, kimantawa na aji].\n    leader (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin shugaban aji ne.\n    west (str): Wani kirtani ('Y' ko 'N') da ke nuna idan ɗalibin daga lardin yamma ne.\n    papers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibin ya buga.\n\n    Returns:\n    int: Jimillar adadin tallafin karatu da ɗalibin ya cancanci samu.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "hi": "\n    यदि अंतिम औसत स्कोर 80 से अधिक है और एक या अधिक पेपर प्रकाशित होते हैं, तो 8000 की छात्रवृत्ति जोड़ी जाएगी\n    यदि अंतिम औसत स्कोर 85 अंकों से अधिक है और कक्षा का मूल्यांकन 80 अंकों से अधिक है, तो छात्रवृत्ति 4000 अंकों से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 90 अंकों से अधिक है, तो छात्रवृत्ति 2000 से बढ़ाई जाएगी\n    यदि अंतिम औसत स्कोर 85 से अधिक है और छात्र पश्चिमी क्षेत्र से है, तो छात्रवृत्ति 1000 से बढ़ाई जाएगी\n    यदि कक्षा का अंतिम मूल्यांकन 80 अंकों से अधिक है और कक्षा का नेता कक्षा का नेता है, तो छात्रवृत्ति 850 से बढ़ाई जाएगी\n\n    Parameters:\n    grades (list of int): एक दो-तत्वों की सूची जिसमें छात्र के शैक्षणिक ग्रेड [अवधि के अंत का औसत, कक्षा का मूल्यांकन] शामिल हैं।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा का नेता है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या को दर्शाता है।\n\n    Returns:\n    int: कुल छात्रवृत्ति राशि जिसके लिए छात्र पात्र है।\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000",
      "hu": "\n    Ha a végső átlagpontszám nagyobb, mint 80, és egy vagy több dolgozat megjelent, 8000 ösztöndíj kerül hozzáadásra\n    Ha a végső átlagpontszám nagyobb, mint 85 pont, és az osztályértékelés nagyobb, mint 80 pont, az ösztöndíj 4000 ponttal növekszik\n    Ha a végső átlagpontszám nagyobb, mint 90 pont, az ösztöndíj 2000-rel növekszik\n    Ha a végső átlagpontszám nagyobb, mint 85, és a diák a nyugati régióból származik, az ösztöndíj 1000-rel növekszik\n    Ha az osztály végső értékelése nagyobb, mint 80 pont, és az osztályvezető az osztályvezető, az ösztöndíj 850 ponttal növekszik\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely tartalmazza a diák tanulmányi eredményeit [félév végi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a diák nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a diák által publikált kutatási dolgozatok számát jelzi.\n\n    Visszatér:\n    int: Az összes ösztöndíj összege, amelyre a diák jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000"
    },
    "docstring_bertscore": {
      "sq": "0.9540083270536579",
      "hy": "0.9295513654975941",
      "bn": "0.9645128947546879",
      "bg": "0.9616621515260751",
      "zh": "0.9348480432382704",
      "fr": "0.9772347733992104",
      "de": "0.9561469803662604",
      "ha": "0.9345997552619768",
      "hi": "0.9625655224990218",
      "hu": "0.9583376748386943"
    }
  },
  {
    "task_id": "Python/14",
    "prompt": {
      "en": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "sq": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifikoni saktësinë e një numri të dhënë ISBN dhe korrigjojeni atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN sipas llogaritjes standarde të kontrollit të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Argumentet:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "hy": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ստուգել տրված ISBN համարի ճշգրտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\n    Ֆունկցիան ստուգում է տրամադրված ISBN համարը՝ համաձայն ISBN ստանդարտի ստուգման գումարի հաշվարկի։\n    Եթե ստուգման գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\": Եթե ստուգման գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\n    Արգումենտներ:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը։ Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգման գումարի թիվը։\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգման գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ֆորմատով, ինչ մուտքագրվածը, եթե ստուգման գումարը սխալ է։\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "bn": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরকে ISBN মানদণ্ডের চেকসাম গণনার সাথে মিলিয়ে দেখে।\n    যদি চেকসাম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\n    ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    Args:\n    isbn: যাচাই করার জন্য একটি স্ট্রিং যা ISBN নম্বরকে উপস্থাপন করে। ফরম্যাটটি হওয়া উচিত 'x-xxx-xxxxx-x',\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসাম সংখ্যা উপস্থাপন করে।\n\n    Returns:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "bg": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума за ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последният 'x' може също да бъде 'X', представляващ контролния знак.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входа, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "zh": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 表示要验证的ISBN号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n          其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验和数字的 'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确，则为 \"Right\"；如果校验和不正确，则为\n    与输入格式相同的更正后的ISBN号码。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "fr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Vérifie la validité d'un numéro ISBN donné et le corrige si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni en utilisant le calcul de la somme de contrôle standard de l'ISBN.\n    Si la somme de contrôle est correcte, la fonction retourne \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction retourne le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne de caractères représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' peut également être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne de caractères qui est soit \"Right\" si la somme de contrôle de l'ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "de": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung.\n    Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer falsch ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, was die Prüfziffer darstellt.\n\n    Rückgaben:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfziffer falsch ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "ha": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara ta idan ya zama dole.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin duba daidaiton ISBN.\n    Idan lissafin duba ya yi daidai, aikin yana dawo da \"Right\". Idan lissafin duba bai yi daidai ba,\n    aikin yana dawo da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\n          inda 'x' yake nuni da lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar duba.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan lissafin duba ISBN ya yi daidai, ko kuma lambar ISBN da aka gyara\n    a cikin tsarin iri ɗaya da shigarwar idan lissafin duba bai yi daidai ba.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "hi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\n    यह फ़ंक्शन प्रदान किए गए ISBN नंबर को ISBN मानक चेकसम गणना के विरुद्ध जाँचता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    Args:\n    isbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\n    Returns:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या यदि चेकसम गलत है तो इनपुट के समान प्रारूप में सही किया गया ISBN नंबर है।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\"",
      "hu": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ellenőrzi egy adott ISBN szám helyességét, és szükség esetén kijavítja.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabványos ellenőrző összeg számítása alapján.\n    Ha az ellenőrző összeg helyes, a függvény \"Right\" értéket ad vissza. Ha az ellenőrző összeg hibás,\n    a függvény a javított ISBN számot adja vissza.\n\n    Paraméterek:\n    isbn: Egy string, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x' kell lennie,\n          ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet képviseli.\n\n    Visszatérési érték:\n    Egy string, amely \"Right\", ha az ISBN ellenőrző összege helyes, vagy a javított ISBN szám\n    ugyanabban a formátumban, mint a bemenet, ha az ellenőrző összeg hibás.\n\n    Példák:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9621889192965797",
      "hy": "0.9779669249837051",
      "bn": "0.9814417648695294",
      "bg": "0.9872362103450791",
      "zh": "0.979845372497152",
      "fr": "0.9793021184050216",
      "de": "0.966574479479449",
      "ha": "0.9576825918420412",
      "hi": "0.9939719651963532",
      "hu": "0.9697893121964987"
    },
    "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit",
    "instruction": {
      "en": "Write a python function 'def verify_isbn(isbn: str) -> str:' to solve the following problem:\n\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    ",
      "sq": "Shkruani një funksion python 'def verify_isbn(isbn: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Verifikoni saktësinë e një numri të dhënë ISBN dhe korrigjojeni atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes së kontrollit standard të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Args:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "hy": "Պայթոն ֆունկցիա 'def verify_isbn(isbn: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Ստուգել տրված ISBN համարի ճշգրտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\n    Ֆունկցիան ստուգում է տրված ISBN համարը՝ համեմատելով այն ISBN ստանդարտ ստուգիչ գումարի հաշվարկի հետ։\n    Եթե ստուգիչ գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\"։ Եթե ստուգիչ գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\n    Արգումենտներ:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը։ Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգիչ թիվը։\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգիչ գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ֆորմատով, ինչ մուտքագրվածը, եթե ստուգիչ գումարը սխալ է։\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "bn": "একটি পাইথন ফাংশন 'def verify_isbn(isbn: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজনে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN স্ট্যান্ডার্ড চেকসম গণনার সাথে যাচাই করে।\n    যদি চেকসম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসম ভুল হয়,\n    ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    Args:\n    isbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি 'x-xxx-xxxxx-x' হওয়া উচিত,\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসম সংখ্যা উপস্থাপন করে।\n\n    Returns:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের একই ফরম্যাটে যদি চেকসম ভুল হয়।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "bg": "Напишете функция на Python 'def verify_isbn(isbn: str) -> str:', за да решите следния проблем:\n\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума на ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последният 'x' може да бъде и 'X', представляващ контролна цифра.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входа, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "zh": "编写一个Python函数 'def verify_isbn(isbn: str) -> str:' 来解决以下问题：\n\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 一个表示要验证的ISBN号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n          其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验位的 'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确则为 \"Right\"，如果校验和不正确则为\n    与输入格式相同的更正后的ISBN号码。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "fr": "Écrivez une fonction python 'def verify_isbn(isbn: str) -> str:' pour résoudre le problème suivant :\n\n    Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni par rapport au calcul standard de la somme de contrôle ISBN.\n    Si la somme de contrôle est correcte, la fonction renvoie \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction renvoie le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' pourrait aussi être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne qui est soit \"Right\" si la somme de contrôle ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "de": "Schreiben Sie eine Python-Funktion 'def verify_isbn(isbn: str) -> str:', um das folgende Problem zu lösen:\n\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung.\n    Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer nicht korrekt ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, das die Prüfziffer darstellt.\n\n    Rückgabewert:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfziffer nicht korrekt ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "ha": "Rubuta wani aikin python 'def verify_isbn(isbn: str) -> str:' don warware matsalar mai zuwa:\n\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara idan ya cancanta.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin checksum na ma'aunin ISBN.\n    Idan checksum din ya dace, aikin yana dawowa \"Right\". Idan checksum din ba daidai ba ne,\n    aikin yana dawowa da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya zama 'x-xxx-xxxxx-x',\n          inda 'x' ke nuni da lamba, kuma na ƙarshe 'x' na iya zama 'X' wanda ke wakiltar lambar checksum.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan checksum na ISBN ya dace, ko kuma lambar ISBN da aka gyara\n    a cikin irin wannan tsarin kamar yadda aka shigar idan checksum din ba daidai ba ne.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "hi": "एक पायथन फ़ंक्शन 'def verify_isbn(isbn: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए ISBN नंबर की शुद्धता की जांच करें और यदि आवश्यक हो तो उसे सही करें।\n\n    फ़ंक्शन प्रदान किए गए ISBN नंबर की ISBN मानक चेकसम गणना के खिलाफ जांच करता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    तर्क:\n    isbn: एक स्ट्रिंग जो सत्यापित करने के लिए ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\n    लौटाता है:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या सही किया गया ISBN नंबर\n    उसी प्रारूप में जैसा इनपुट है यदि चेकसम गलत है।\n\n    उदाहरण:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "hu": "Írj egy Python függvényt 'def verify_isbn(isbn: str) -> str:' a következő probléma megoldására:\n\n    Ellenőrizze egy adott ISBN szám helyességét, és szükség esetén javítsa ki.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrző összeg számításával.\n    Ha az ellenőrző összeg helyes, a függvény \"Right\"-ot ad vissza. Ha az ellenőrző összeg helytelen,\n    a függvény a javított ISBN számot adja vissza.\n\n    Args:\n    isbn: Egy string, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x'-nek kell lennie,\n          ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet képviseli.\n\n    Returns:\n    Egy string, amely vagy \"Right\", ha az ISBN ellenőrző összege helyes, vagy a javított ISBN szám\n    ugyanabban a formátumban, mint a bemenet, ha az ellenőrző összeg helytelen.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'"
    },
    "instruction_bertscore": {
      "sq": "0.9664958218485592",
      "hy": "0.9834671988649422",
      "bn": "0.9851925023546112",
      "bg": "0.986626613705683",
      "zh": "0.9797832011878881",
      "fr": "0.9883181500305761",
      "de": "0.9625289745089114",
      "ha": "0.9798340505654329",
      "hi": "0.9906302076658222",
      "hu": "0.9769016702502149"
    },
    "level": "middle",
    "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()",
    "entry_point": "verify_isbn",
    "signature": "def verify_isbn(isbn: str) -> str:",
    "docstring": {
      "en": "\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n    ",
      "sq": "\n    Verifikoni saktësinë e një numri ISBN të dhënë dhe korrigjojeni atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes standarde të kontrollit të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Argumentet:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "hy": "\n    Ստուգել տրված ISBN համարի ճշտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\n    Ֆունկցիան ստուգում է տրամադրված ISBN համարը ըստ ISBN ստանդարտի ստուգիչ գումարի հաշվարկի։\n    Եթե ստուգիչ գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\"։ Եթե ստուգիչ գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\n    Պարամետրեր:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը։ Ձևաչափը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգիչ թիվը։\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգիչ գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ձևաչափով, ինչ մուտքագրվածը, եթե ստուգիչ գումարը սխալ է։\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "bn": "\n    প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN মানদণ্ডের চেকসাম গণনার বিরুদ্ধে পরীক্ষা করে।\n    যদি চেকসাম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\n    ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    আর্গুমেন্টসমূহ:\n    isbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি হওয়া উচিত 'x-xxx-xxxxx-x',\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসাম ডিজিট উপস্থাপন করে।\n\n    রিটার্নস:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের মতো একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\n    উদাহরণ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "bg": "\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролната сума на ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последното 'x' може да бъде и 'X', представляващо контролния знак.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входа, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "zh": "\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 一个表示要验证的ISBN号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n          其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验和数字的 'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确，则为 \"Right\"；如果校验和不正确，\n    则为与输入格式相同的更正后的ISBN号码。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "fr": "\n    Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni en utilisant le calcul de somme de contrôle standard de l'ISBN.\n    Si la somme de contrôle est correcte, la fonction renvoie \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction renvoie le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne de caractères représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' peut également être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne de caractères qui est soit \"Right\" si la somme de contrôle de l'ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "de": "\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung.\n    Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer falsch ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, was die Prüfziffer darstellt.\n\n    Rückgabe:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfziffer falsch ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "ha": "\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara ta idan ya cancanta.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin duba daidaiton ISBN.\n    Idan lissafin duba ya yi daidai, aikin yana dawowa da \"Right\". Idan lissafin duba bai yi daidai ba,\n    aikin yana dawowa da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\n          inda 'x' yake wakiltar lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar duba.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan lissafin duba ISBN ya yi daidai, ko kuma lambar ISBN da aka gyara\n    a cikin tsarin daidai da shigarwar idan lissafin duba bai yi daidai ba.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "hi": "\n    दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\n    फ़ंक्शन दिए गए ISBN नंबर को ISBN मानक चेकसम गणना के विरुद्ध जाँचता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    Args:\n    isbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\n    Returns:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या यदि चेकसम गलत है तो इनपुट के समान प्रारूप में सही किया गया ISBN नंबर।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'",
      "hu": "\n    Ellenőrizze egy adott ISBN szám helyességét, és szükség esetén javítsa ki.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrzőösszeg-számítása alapján.\n    Ha az ellenőrzőösszeg helyes, a függvény \"Right\" értéket ad vissza. Ha az ellenőrzőösszeg helytelen,\n    a függvény a javított ISBN számot adja vissza.\n\n    Paraméterek:\n    isbn: Egy karakterlánc, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x'\n          kell lennie, ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet jelöli.\n\n    Visszatér:\n    Egy karakterlánc, amely vagy \"Right\", ha az ISBN ellenőrzőösszeg helyes, vagy a javított ISBN szám\n    azonos formátumban, mint a bemenet, ha az ellenőrzőösszeg helytelen.\n\n    Példák:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'"
    },
    "docstring_bertscore": {
      "sq": "0.9715362663977005",
      "hy": "0.975359305341479",
      "bn": "0.9882994787747589",
      "bg": "0.9797128860330017",
      "zh": "0.9678276385533982",
      "fr": "0.9779798359584723",
      "de": "0.9549760542700598",
      "ha": "0.9707977586410128",
      "hi": "0.9919171339045473",
      "hu": "0.9748049279480107"
    }
  },
  {
    "task_id": "Python/15",
    "prompt": {
      "en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "sq": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\n    Args:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për t'u shtuar.\n    L (int): Numri i korridoreve vertikale për t'u shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secili përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Returns:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksat optimalë të rreshtave dhe kolonave për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në çdo pozicion të mundshëm.\n    Pastaj zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2')\n    \"\"\"",
      "hy": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Օպտիմալացնել միջանցքների տեղադրումը դասարանում՝ նվազագույնի հասցնելու ուսանողների միջև զրույցների քանակը։\n\n    Արգումենտներ:\n    M (int): Դասարանի շարքերի քանակը։\n    N (int): Դասարանի սյուների քանակը։\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը։\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը։\n    D (int): Դասարանում զրուցող զույգերի քանակը։\n    chatting_pairs (ցանկ tuple-ների): Tuple-ների ցանկ, որոնցից յուրաքանչյուրը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi)։\n\n    Վերադարձնում է:\n    (str, str): Երկու բացատով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ շարքի և սյունակի ինդեքսները։\n\n    Ֆունկցիան աշխատում է՝ հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում միջանցք ավելացնելով։\n    Այնուհետև ընտրում է միջանցքների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով բաժանել հնարավորինս շատ զրուցող զույգեր։\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2')\n    \"\"\"",
      "bn": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    শ্রেণীকক্ষে শিক্ষার্থীদের মধ্যে কথোপকথনের পরিমাণ কমানোর জন্য আইলগুলির অবস্থান অপ্টিমাইজ করুন।\n\n    Args:\n    M (int): শ্রেণীকক্ষে সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষে কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক আইলগুলির সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব আইলগুলির সংখ্যা।\n    D (int): শ্রেণীকক্ষে কথোপকথনকারী জোড়াগুলির সংখ্যা।\n    chatting_pairs (list of tuples): একটি টুপলের তালিকা, প্রতিটি টুপলে একটি কথোপকথনকারী জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) রয়েছে।\n\n    Returns:\n    (str, str): আইলগুলির জন্য অপ্টিমাল সারি এবং কলাম সূচকগুলি নির্দেশ করে দুটি স্পেস-বিচ্ছিন্ন স্ট্রিং।\n\n    ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি আইল যোগ করার মাধ্যমে পৃথক করা যেতে পারে এমন কথোপকথনকারী জোড়াগুলির সংখ্যা গণনা করে কাজ করে।\n    তারপর এটি আইলগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব কথোপকথনকারী জোড়াগুলিকে পৃথক করার লক্ষ্য নিয়ে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "bg": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\n    Args:\n    M (int): Броят на редовете в класната стая.\n    N (int): Броят на колоните в класната стая.\n    K (int): Броят на хоризонталните пътеки, които да се добавят.\n    L (int): Броят на вертикалните пътеки, които да се добавят.\n    D (int): Броят на двойките, които разговарят в класната стая.\n    chatting_pairs (list of tuples): Списък от кортежи, всеки от които съдържа позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\n    Returns:\n    (str, str): Два низа, разделени с интервал, представляващи оптималните индекси на редовете и колоните за пътеките.\n\n    Функцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\n    След това избира най-ефективните позиции за пътеки, с цел да раздели възможно най-много двойки, които разговарят.\n\n    Примери:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "zh": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    优化教室中走道的布置，以尽量减少学生之间的聊天。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平走道数量。\n    L (int): 要添加的垂直走道数量。\n    D (int): 教室中聊天对的数量。\n    chatting_pairs (list of tuples): 一个包含元组的列表，每个元组包含一个聊天对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个空格分隔的字符串，分别表示走道的最佳行和列索引。\n\n    该函数通过计算可以通过在每个可能位置添加走道来分隔的聊天对的数量来工作。\n    然后选择最有效的走道位置，旨在分隔尽可能多的聊天对。\n\n    示例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')\n    \"\"\"",
      "fr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les étudiants.\n\n    Args:\n    M (int): Le nombre de rangées dans la salle de classe.\n    N (int): Le nombre de colonnes dans la salle de classe.\n    K (int): Le nombre d'allées horizontales à ajouter.\n    L (int): Le nombre d'allées verticales à ajouter.\n    D (int): Le nombre de paires bavardant dans la salle de classe.\n    chatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardant.\n\n    Returns:\n    (str, str): Deux chaînes séparées par des espaces représentant les indices optimaux des rangées et colonnes pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardant qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer le plus grand nombre possible de paires bavardant.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "de": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimieren Sie die Platzierung der Gänge in einem Klassenzimmer, um die Menge an Gesprächen zwischen den Schülern zu minimieren.\n\n    Args:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (list of tuples): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Returns:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für die Gänge aus, um möglichst viele Gesprächspaare zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Gibt zurück: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Gibt zurück: ('2', '2')\n    \"\"\"",
      "ha": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Inganta wurin sanya hanyoyi a cikin aji don rage yawan hira tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layuka a cikin aji.\n    N (int): Yawan ginshikai a cikin aji.\n    K (int): Yawan hanyoyi a kwance da za a ƙara.\n    L (int): Yawan hanyoyi a tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu hira a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'aurata masu hira.\n\n    Returns:\n    (str, str): Haruffa guda biyu da aka raba da sarari waɗanda ke wakiltar mafi kyawun layi da ginshiƙai don hanyoyin.\n\n    Aiki yana aiki ta hanyar ƙididdige yawan ma'aurata masu hira waɗanda za a iya raba ta hanyar ƙara hanya a kowanne matsayi mai yiwuwa.\n    Sannan yana zaɓar mafi kyawun wurare don hanyoyi, yana nufin raba ma'aurata masu hira da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "hi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    कक्षा में छात्रों के बीच बातचीत की मात्रा को कम करने के लिए गलियारों की व्यवस्था को अनुकूलित करें।\n\n    Args:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): एक सूची जिसमें प्रत्येक जोड़ी के स्थान (Xi, Yi) और (Pi, Qi) होते हैं।\n\n    Returns:\n    (str, str): दो स्पेस से अलग किए गए स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करते हैं।\n\n    यह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जितना संभव हो सके उतने बातचीत करने वाले जोड़ों को अलग करने का लक्ष्य रखते हुए।\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    \"\"\"",
      "hu": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimalizálja a folyosók elhelyezését egy tanteremben, hogy minimalizálja a diákok közötti beszélgetéseket.\n\n    Args:\n    M (int): A tanterem sorainak száma.\n    N (int): A tanterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A tanteremben lévő beszélgető párok száma.\n    chatting_pairs (list of tuples): Egy tuple-ök listája, mindegyik tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\n    Returns:\n    (str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy minél több beszélgető párt elválasszon.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszaadja: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszaadja: ('2', '2')\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9971566060954856",
      "hy": "0.9854779342121582",
      "bn": "0.9703816279927447",
      "bg": "0.9672390967343918",
      "zh": "0.9681394882516229",
      "fr": "0.9865682163736588",
      "de": "0.9935572249607524",
      "ha": "0.979321981443125",
      "hi": "0.9717054994823422",
      "hu": "0.9806643255581589"
    },
    "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)",
    "instruction": {
      "en": "Write a python function 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' to solve the following problem:\n\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    ",
      "sq": "Shkruani një funksion python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' për të zgjidhur problemin e mëposhtëm:\n\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\n    Argumentet:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për të shtuar.\n    L (int): Numri i korridoreve vertikale për të shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secila përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Kthen:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksin optimal të rreshtit dhe kolonës për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\n    Më pas zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2')",
      "hy": "Պայթոն ֆունկցիա 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Օպտիմալացրեք դասարանում միջանցքների տեղադրումը՝ նվազեցնելու ուսանողների միջև զրույցների քանակը:\n\n    Արգումենտներ:\n    M (int): Դասարանի շարքերի քանակը:\n    N (int): Դասարանի սյուների քանակը:\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը:\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը:\n    D (int): Դասարանում զրուցող զույգերի քանակը:\n    chatting_pairs (list of tuples): Կրկնակի ցուցակ, որը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi):\n\n    Վերադարձնում է:\n    (str, str): Երկու տարածքով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ շարքի և սյան ինդեքսները:\n\n    Ֆունկցիան աշխատում է՝ հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում միջանցք ավելացնելով:\n    Այնուհետև ընտրում է միջանցքների համար ամենաարդյունավետ դիրքերը՝ հնարավորինս շատ զրուցող զույգեր բաժանելու նպատակով:\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2')",
      "bn": "একটি পাইথন ফাংশন 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    শ্রেণীকক্ষে পথের অবস্থানকে অপ্টিমাইজ করুন যাতে শিক্ষার্থীদের মধ্যে কথোপকথনের পরিমাণ কমানো যায়।\n\n    আর্গুমেন্টস:\n    M (int): শ্রেণীকক্ষে সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষে কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক পথের সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব পথের সংখ্যা।\n    D (int): শ্রেণীকক্ষে কথোপকথনকারী জোড়ার সংখ্যা।\n    chatting_pairs (list of tuples): একটি তালিকা যা প্রতিটি জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) ধারণ করে।\n\n    রিটার্নস:\n    (str, str): দুটি স্পেস-আলাদা স্ট্রিং যা পথের জন্য সর্বোত্তম সারি এবং কলামের সূচক নির্দেশ করে।\n\n    ফাংশনটি কাজ করে প্রতিটি সম্ভাব্য অবস্থানে একটি পথ যোগ করে কতগুলি কথোপকথনকারী জোড়া আলাদা করা যেতে পারে তা গণনা করে।\n    তারপর এটি পথের জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব কথোপকথনকারী জোড়া আলাদা করার লক্ষ্য নিয়ে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    রিটার্নস: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    রিটার্নস: ('2', '2')",
      "bg": "Напишете Python функция 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):', за да решите следния проблем:\n\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\n    Аргументи:\n    M (int): Броят на редовете в класната стая.\n    N (int): Броят на колоните в класната стая.\n    K (int): Броят на хоризонталните пътеки, които да се добавят.\n    L (int): Броят на вертикалните пътеки, които да се добавят.\n    D (int): Броят на двойките, които си говорят в класната стая.\n    chatting_pairs (списък от кортежи): Списък от кортежи, всеки съдържащ позициите (Xi, Yi) и (Pi, Qi) на двойка, която си говори.\n\n    Връща:\n    (str, str): Два стринга, разделени с интервал, представляващи оптималните индекси на редовете и колоните за пътеките.\n\n    Функцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\n    След това избира най-ефективните позиции за пътеките, с цел да раздели възможно най-много двойки, които си говорят.\n\n    Примери:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Връща: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Връща: ('2', '2')",
      "zh": "编写一个python函数 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' 来解决以下问题：\n\n    优化教室中过道的放置，以最小化学生之间的交谈量。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平过道数量。\n    L (int): 要添加的垂直过道数量。\n    D (int): 教室中交谈的对数。\n    chatting_pairs (list of tuples): 一个元组列表，每个元组包含一个交谈对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个以空格分隔的字符串，表示过道的最佳行和列索引。\n\n    该函数通过计算在每个可能的位置添加过道可以分开的交谈对数来工作。\n    然后选择最有效的过道位置，旨在尽可能多地分开交谈对。\n\n    示例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')",
      "fr": "Écrivez une fonction python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' pour résoudre le problème suivant :\n\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les étudiants.\n\n    Arguments :\n    M (int) : Le nombre de rangées dans la salle de classe.\n    N (int) : Le nombre de colonnes dans la salle de classe.\n    K (int) : Le nombre d'allées horizontales à ajouter.\n    L (int) : Le nombre d'allées verticales à ajouter.\n    D (int) : Le nombre de paires bavardantes dans la salle de classe.\n    chatting_pairs (liste de tuples) : Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardante.\n\n    Renvoie :\n    (str, str) : Deux chaînes séparées par des espaces représentant les indices de rangées et de colonnes optimaux pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardantes qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardantes que possible.\n\n    Exemples :\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Renvoie : ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Renvoie : ('2', '2')",
      "de": "Schreiben Sie eine Python-Funktion 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):', um das folgende Problem zu lösen:\n\n    Optimieren Sie die Platzierung von Gängen in einem Klassenzimmer, um die Menge an Gesprächen zwischen den Schülern zu minimieren.\n\n    Argumente:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (Liste von Tupeln): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Rückgaben:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für die Gänge aus, um so viele Gesprächspaare wie möglich zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Gibt zurück: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Gibt zurück: ('2', '2')",
      "ha": "Rubuta wani aikin python 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' don warware matsalar mai zuwa:\n\n    Inganta wurin da za a sanya hanyoyin shiga a cikin aji don rage yawan magana tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layuka a cikin aji.\n    N (int): Yawan ginshiƙai a cikin aji.\n    K (int): Yawan hanyoyin shiga a kwance da za a ƙara.\n    L (int): Yawan hanyoyin shiga a tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu magana a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'aurata masu magana.\n\n    Returns:\n    (str, str): Haruffa guda biyu da aka raba da sarari suna wakiltar mafi kyawun layi da ginshiƙai don hanyoyin shiga.\n\n    Aikin yana aiki ta hanyar ƙididdige yawan ma'aurata masu magana da za a iya raba ta hanyar ƙara hanya a kowanne matsayi mai yiwuwa.\n    Sannan yana zaɓar wurare mafi inganci don hanyoyin shiga, yana nufin raba ma'aurata masu magana da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')",
      "hi": "एक पायथन फ़ंक्शन 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    कक्षा में गलियारों के स्थान को अनुकूलित करें ताकि छात्रों के बीच बातचीत की मात्रा को कम किया जा सके।\n\n    तर्क:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): ट्यूपल की एक सूची, जिसमें प्रत्येक में बातचीत करने वाले जोड़े की स्थिति (Xi, Yi) और (Pi, Qi) होती है।\n\n    लौटाता है:\n    (str, str): दो स्पेस सेपरेटेड स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करती हैं।\n\n    फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करके काम करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य यथासंभव अधिक से अधिक बातचीत करने वाले जोड़ों को अलग करना होता है।\n\n    उदाहरण:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')",
      "hu": "Írj egy python függvényt 'def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):' a következő probléma megoldására:\n\n    Optimalizáld a folyosók elhelyezését egy osztályteremben, hogy minimalizáld a diákok közötti beszélgetések mennyiségét.\n\n    Argumentumok:\n    M (int): Az osztályterem sorainak száma.\n    N (int): Az osztályterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A beszélgető párok száma az osztályteremben.\n    chatting_pairs (list of tuples): Egy listája a tuple-öknek, amelyek mindegyike tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\n    Visszatérési érték:\n    (str, str): Két szóközzel elválasztott string, amelyek a folyosók optimális sor- és oszlopindexeit jelölik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszatér: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszatér: ('2', '2')"
    },
    "instruction_bertscore": {
      "sq": "0.9961175705722921",
      "hy": "0.9770971225451532",
      "bn": "0.9731314669877917",
      "bg": "0.9711328480938186",
      "zh": "0.981633443187228",
      "fr": "0.9972869076254445",
      "de": "0.987599703942373",
      "ha": "0.9847066524425998",
      "hi": "0.9892809114874522",
      "hu": "0.9871939020739187"
    },
    "level": "hard",
    "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()",
    "entry_point": "optimize_seating",
    "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):",
    "docstring": {
      "en": "\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')\n    ",
      "sq": "\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\n    Argumentet:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për t'u shtuar.\n    L (int): Numri i korridoreve vertikale për t'u shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secila që përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Kthen:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksat optimalë të rreshtave dhe kolonave për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë dhe që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\n    Më pas zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2')",
      "hy": "\n    Դասարանում միջանցքների տեղադրումը օպտիմալացնել՝ նվազեցնելու ուսանողների միջև խոսակցությունների քանակը։\n\n    Պարամետրեր:\n    M (int): Դասարանի տողերի քանակը։\n    N (int): Դասարանի սյուների քանակը։\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը։\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը։\n    D (int): Դասարանում խոսակցող զույգերի քանակը։\n    chatting_pairs (list of tuples): Զույգերի ցուցակ, որոնցից յուրաքանչյուրն ունի զույգի դիրքերը (Xi, Yi) և (Pi, Qi)։\n\n    Վերադարձնում է:\n    (str, str): Երկու բացատով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ տողի և սյունակի ինդեքսները։\n\n    Ֆունկցիան աշխատում է՝ հաշվելով խոսակցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում միջանցք ավելացնելով։\n    Այնուհետև ընտրում է միջանցքների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով հնարավորինս շատ զույգերի բաժանել։\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2')",
      "bn": "\n    শ্রেণীকক্ষে ছাত্রদের মধ্যে কথোপকথন কমানোর জন্য আইলগুলির অবস্থান অপ্টিমাইজ করুন।\n\n    প্যারামিটার:\n    M (int): শ্রেণীকক্ষের সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষের কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক আইলের সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব আইলের সংখ্যা।\n    D (int): শ্রেণীকক্ষে কথোপকথনকারী জোড়ার সংখ্যা।\n    chatting_pairs (list of tuples): একটি টুপলের তালিকা, প্রতিটি টুপলে কথোপকথনকারী জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) অন্তর্ভুক্ত।\n\n    রিটার্নস:\n    (str, str): দুটি স্পেস-বিচ্ছিন্ন স্ট্রিং যা আইলগুলির জন্য সর্বোত্তম সারি এবং কলামের সূচক উপস্থাপন করে।\n\n    এই ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি আইল যোগ করে কতগুলি কথোপকথনকারী জোড়া আলাদা করা যায় তা গণনা করে কাজ করে।\n    তারপর এটি আইলগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব কথোপকথনকারী জোড়া আলাদা করার লক্ষ্য নিয়ে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    রিটার্নস: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    রিটার্নস: ('2', '2')",
      "bg": "\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\nАргументи:\nM (int): Броят на редовете в класната стая.\nN (int): Броят на колоните в класната стая.\nK (int): Броят на хоризонталните пътеки, които да се добавят.\nL (int): Броят на вертикалните пътеки, които да се добавят.\nD (int): Броят на двойките, които разговарят в класната стая.\nchatting_pairs (list of tuples): Списък от кортежи, всеки от които съдържа позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\nВръща:\n(str, str): Два разделени с интервал низа, представляващи оптималните индекси на редовете и колоните за пътеките.\n\nФункцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\nСлед това избира най-ефективните позиции за пътеки, с цел да раздели възможно най-много двойки, които разговарят.\n\nПримери:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nВръща: ('2', '2 4')\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nВръща: ('2', '2')",
      "zh": "\n    优化教室中过道的布局，以最小化学生之间的交谈量。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平过道数。\n    L (int): 要添加的垂直过道数。\n    D (int): 教室中交谈对的数量。\n    chatting_pairs (list of tuples): 一个包含元组的列表，每个元组包含一个交谈对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个用空格分隔的字符串，表示过道的最佳行和列索引。\n\n    该函数通过计算可以通过在每个可能位置添加过道来分隔的交谈对的数量来工作。\n    然后选择最有效的过道位置，旨在尽可能多地分隔交谈对。\n\n    示例:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')",
      "fr": "\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardages entre les élèves.\n\n    Args:\n    M (int): Le nombre de rangées dans la salle de classe.\n    N (int): Le nombre de colonnes dans la salle de classe.\n    K (int): Le nombre d'allées horizontales à ajouter.\n    L (int): Le nombre d'allées verticales à ajouter.\n    D (int): Le nombre de paires bavardant dans la salle de classe.\n    chatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardant.\n\n    Returns:\n    (str, str): Deux chaînes séparées par des espaces représentant les indices optimaux de rangées et de colonnes pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardant qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardant que possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')",
      "de": "\n    Optimieren Sie die Platzierung der Gänge in einem Klassenzimmer, um die Menge an Gesprächen zwischen den Schülern zu minimieren.\n\n    Args:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (list of tuples): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Returns:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für die Gänge aus, um möglichst viele Gesprächspaare zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')",
      "ha": "\n    Inganta wuraren da aka sanya hanyoyin wucewa a cikin aji don rage yawan hira tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layukan kujeru a cikin aji.\n    N (int): Yawan ginshiƙai a cikin aji.\n    K (int): Yawan hanyoyin wucewa na kwance da za a ƙara.\n    L (int): Yawan hanyoyin wucewa na tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu hira a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'aurata masu hira.\n\n    Returns:\n    (str, str): Haruffa guda biyu da aka raba da sarari suna wakiltar wuraren layi da ginshiƙai mafi kyau don hanyoyin wucewa.\n\n    Aiki yana aiki ta hanyar ƙididdige yawan ma'aurata masu hira da za a iya raba ta hanyar ƙara hanya a kowane matsayi mai yiwuwa.\n    Sannan yana zaɓar wuraren da suka fi dacewa don hanyoyin wucewa, yana nufin raba ma'aurata masu hira da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')",
      "hi": "\n    कक्षा में गलियारों की व्यवस्था को इस प्रकार अनुकूलित करें कि छात्रों के बीच बातचीत की मात्रा न्यूनतम हो सके।\n\n    Args:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए ऊर्ध्वाधर गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): एक सूची जिसमें प्रत्येक तत्व एक युग्म के स्थान (Xi, Yi) और (Pi, Qi) को दर्शाता है जो बातचीत कर रहे हैं।\n\n    Returns:\n    (str, str): दो स्पेस सेपरेटेड स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक दर्शाती हैं।\n\n    यह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करके कार्य करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य जितना संभव हो सके उतने बातचीत करने वाले जोड़ों को अलग करना है।\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2')",
      "hu": "\n    Optimalizálja a folyosók elhelyezését egy osztályteremben, hogy minimalizálja a diákok közötti beszélgetés mennyiségét.\n\n    Paraméterek:\n    M (int): Az osztályterem sorainak száma.\n    N (int): Az osztályterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A beszélgető párok száma az osztályteremben.\n    chatting_pairs (list of tuples): Egy listája a pároknak, amelyek mindegyike tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\n    Visszatérési érték:\n    (str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyek elválaszthatók egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszatér: ('2', '2 4')\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszatér: ('2', '2')"
    },
    "docstring_bertscore": {
      "sq": "0.96776467272261",
      "hy": "0.9640699490049801",
      "bn": "0.9476855247645553",
      "bg": "0.9411676674412764",
      "zh": "0.9470642089326782",
      "fr": "0.994881493711112",
      "de": "0.9819321832803045",
      "ha": "0.9290504196766242",
      "hi": "0.9542562177691893",
      "hu": "0.9790899811580763"
    }
  },
  {
    "task_id": "Python/16",
    "prompt": {
      "en": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "sq": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\n    në mënyrë që pas 'm' kalimeve, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Argumentet:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalohet.\n\n    Kthen:\n    Një numër i plotë që përfaqëson numrin e mënyrave të dallueshme të kalimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' kalimeve.\n\n    Rastet:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "hy": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Հաշվում է տարբեր եղանակների քանակը, որով գնդակը կարող է փոխանցվել 'n' ուսանողների միջև, որոնք կանգնած են \n    շրջանաձև, այնպես, որ 'm' փոխանցումից հետո գնդակը վերադառնա մեկնարկային ուսանողին:\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար: \n    Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին:\n\n    Պարամետրեր:\n    n: Ուսանողների քանակը, որոնք կանգնած են շրջանաձև:\n    m: Գնդակի փոխանցման քանակը:\n\n    Վերադարձնում է:\n    Թիվ, որը ներկայացնում է տարբեր փոխանցման եղանակների քանակը, որոնք բերում են գնդակը \n    վերադարձնել մեկնարկային ուսանողին 'm' փոխանցումից հետո:\n\n    Դեպքեր:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "bn": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' জন শিক্ষার্থীকে একটি বৃত্তে সাজিয়ে বল পাস করার বিভিন্ন পদ্ধতির সংখ্যা গণনা করে \n    যাতে 'm' বার পাস করার পর বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    ফাংশনটি বল পাস করার ক্রমের সংখ্যা নির্ধারণ করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে। \n    প্রতিটি শিক্ষার্থী বলটি বাম পাশের প্রতিবেশী বা ডান পাশের প্রতিবেশীর কাছে পাস করতে পারে।\n\n    Args:\n    n: বৃত্তে দাঁড়িয়ে থাকা শিক্ষার্থীর সংখ্যা।\n    m: বলটি পাস করার সংখ্যা।\n\n    Returns:\n    একটি পূর্ণসংখ্যা যা 'm' বার পাস করার পর বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসার \n    বিভিন্ন পাসিং পদ্ধতির সংখ্যা উপস্থাপন করে।\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "bg": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Брои броя на различните начини за подаване на топка между 'n' ученици, подредени в кръг,\n    така че след 'm' подавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на подаване. Всеки ученик\n    може да подаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на подаванията на топката.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на подаване, които водят до\n    връщане на топката при началния ученик след 'm' подавания.\n\n    Примери:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "zh": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    计算在 'n' 个学生围成一圈的情况下，传球 'm' 次后，球返回到起始学生的不同方式的数量。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生人数。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在传球 'm' 次后，球返回到起始学生的不同传球方式的数量。\n\n    示例:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "fr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Compte le nombre de façons différentes de passer un ballon parmi 'n' étudiants disposés en cercle\n    de sorte qu'après 'm' passes, le ballon revienne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit au voisin de gauche, soit au voisin de droite.\n\n    Arguments:\n    n: Le nombre d'étudiants se tenant en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Retourne:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    revienne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "de": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern zu passen, \n    die in einem Kreis angeordnet sind, sodass nach 'm' Pässen der Ball zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Pass-Sequenzen zu bestimmen. Jeder Schüler\n    kann den Ball entweder an den linken Nachbarn oder an den rechten Nachbarn weitergeben.\n\n    Argumente:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Rückgabe:\n    Eine ganze Zahl, die die Anzahl der verschiedenen Passmöglichkeiten darstellt, die dazu führen, \n    dass der Ball nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "ha": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Yana ƙididdige yawan hanyoyin daban-daban na wuce ƙwallo tsakanin 'n' ɗalibai da aka shirya a cikin \n    da'ira ta yadda bayan 'm' wucewa, ƙwallon zai dawo ga ɗalibin da ya fara.\n\n    Aikin yana amfani da shirye-shiryen motsi don tantance yawan jerin wucewa. Kowanne ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Args:\n    n: Yawan ɗalibai da ke tsaye a cikin da'ira.\n    m: Yawan lokutan da ake wuce ƙwallon.\n\n    Returns:\n    Lamba mai nuna yawan hanyoyin wucewa daban-daban da ke haifar da dawowar ƙwallon\n    ga ɗalibin da ya fara bayan 'm' wucewa.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "hi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' छात्रों के बीच गेंद पास करने के विभिन्न तरीकों की संख्या गिनता है, जो एक वृत्त में व्यवस्थित हैं,\n    ताकि 'm' पास के बाद, गेंद शुरुआती छात्र के पास लौट आए।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके पासिंग अनुक्रमों की संख्या निर्धारित करता है। प्रत्येक छात्र\n    गेंद को या तो बाएं पड़ोसी को या दाएं पड़ोसी को पास कर सकता है।\n\n    Args:\n    n: एक वृत्त में खड़े छात्रों की संख्या।\n    m: गेंद पास करने की संख्या।\n\n    Returns:\n    एक पूर्णांक जो विभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है, जिसके परिणामस्वरूप\n    'm' पास के बाद गेंद शुरुआती छात्र के पास लौटती है।\n\n    मामले:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\"",
      "hu": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Megszámolja, hányféleképpen lehet átadni egy labdát 'n' diák között, akik körben állnak úgy,\n    hogy 'm' passz után a labda visszatér a kiinduló diákhoz.\n\n    A függvény dinamikus programozást használ a passzolási sorozatok számának meghatározásához. \n    Minden diák vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja tovább a labdát.\n\n    Paraméterek:\n    n: A körben álló diákok száma.\n    m: A labda átadásának száma.\n\n    Visszatér:\n    Egy egész szám, amely a különböző passzolási módok számát jelenti, amelyek eredményeként\n    a labda 'm' passz után visszatér a kiinduló diákhoz.\n\n    Esetek:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9933979233951624",
      "hy": "0.9483837105538929",
      "bn": "0.9572821529938749",
      "bg": "0.9771575061809878",
      "zh": "0.9206199504143604",
      "fr": "0.9837550142870617",
      "de": "0.9875605737573091",
      "ha": "0.9909146463714642",
      "hi": "0.9672313501495314",
      "hu": "0.9654069300997259"
    },
    "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]",
    "instruction": {
      "en": "Write a python function 'def count_passing_ways(n: int, m: int) -> int:' to solve the following problem:\n\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "sq": "Shkruani një funksion python 'def count_passing_ways(n: int, m: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top ndërmjet 'n' studentëve të rregulluar në një rreth\n    në mënyrë të tillë që pas 'm' pasimeve, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të pasimeve. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Args:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalon.\n\n    Kthen:\n    Një numër i plotë që përfaqëson numrin e mënyrave të veçanta të pasimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' pasimeve.\n\n    Raste:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "hy": "Պայթոն ֆունկցիա 'def count_passing_ways(n: int, m: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է գնդակը 'n' ուսանողների միջև փոխանցելու տարբեր եղանակների քանակը, որոնք դասավորված են շրջանաձև այնպես,\n    որ 'm' փոխանցումներից հետո գնդակը վերադառնա մեկնարկային ուսանողին:\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում փոխանցման հաջորդականությունների քանակը որոշելու համար: Յուրաքանչյուր ուսանող\n    կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին:\n\n    Արգումենտներ:\n    n: Ուսանողների քանակը, ովքեր կանգնած են շրջանաձև:\n    m: Գնդակը փոխանցելու քանակը:\n\n    Վերադարձնում է:\n    Մի ամբողջ թիվ, որը ներկայացնում է տարբեր փոխանցման եղանակների քանակը, որի արդյունքում գնդակը\n    'm' փոխանցումներից հետո վերադառնում է մեկնարկային ուսանողին:\n\n    Դեպքեր:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "bn": "একটি পাইথন ফাংশন 'def count_passing_ways(n: int, m: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    'n' জন শিক্ষার্থীর মধ্যে বলটি কত বিভিন্ন উপায়ে পাস করা যায় তা গণনা করুন, যারা একটি বৃত্তে সাজানো আছে \n    যাতে 'm' পাসের পরে বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    ফাংশনটি পাসিং সিকোয়েন্সের সংখ্যা নির্ধারণ করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে। প্রতিটি শিক্ষার্থী \n    বলটি বাম পাশের প্রতিবেশী বা ডান পাশের প্রতিবেশীর কাছে পাস করতে পারে।\n\n    আর্গস:\n    n: বৃত্তে দাঁড়িয়ে থাকা শিক্ষার্থীর সংখ্যা।\n    m: বল পাস করার সংখ্যা।\n\n    রিটার্নস:\n    একটি পূর্ণসংখ্যা যা বিভিন্ন পাসিং উপায়ের সংখ্যা উপস্থাপন করে যা 'm' পাসের পরে \n    বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    কেস:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "bg": "Напишете Python функция 'def count_passing_ways(n: int, m: int) -> int:' за да решите следния проблем:\n\n    Брои броя на различните начини за предаване на топка между 'n' ученици, подредени в кръг, \n    така че след 'm' предавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на предаване. Всеки ученик\n    може да предаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на предаванията на топката.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на предаване, които водят до това, че топката\n    се връща при началния ученик след 'm' предавания.\n\n    Примери:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "zh": "编写一个Python函数 'def count_passing_ways(n: int, m: int) -> int:' 来解决以下问题：\n\n    计算在'n'个学生围成一圈的情况下传球的不同方式数量，\n    使得经过'm'次传球后，球返回到起始学生。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生\n    可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生人数。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在'm'次传球后球返回到起始学生的不同传球方式的数量。\n\n    示例:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "fr": "Écrire une fonction python 'def count_passing_ways(n: int, m: int) -> int:' pour résoudre le problème suivant :\n\n    Compte le nombre de façons différentes de passer un ballon parmi 'n' étudiants disposés en cercle\n    de sorte qu'après 'm' passes, le ballon retourne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit à son voisin de gauche, soit à son voisin de droite.\n\n    Args:\n    n: Le nombre d'étudiants debout en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Renvoie:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    retourne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "de": "Schreiben Sie eine Python-Funktion 'def count_passing_ways(n: int, m: int) -> int:', um das folgende Problem zu lösen:\n\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball zwischen 'n' Schülern, die im Kreis angeordnet sind, \n    so zu passen, dass nach 'm' Pässen der Ball zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Pass-Sequenzen zu bestimmen. Jeder Schüler\n    kann den Ball entweder an den linken Nachbarn oder an den rechten Nachbarn weitergeben.\n\n    Argumente:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Rückgabewert:\n    Eine ganze Zahl, die die Anzahl der unterschiedlichen Passmöglichkeiten darstellt, die dazu führen, dass der Ball\n    nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "ha": "Rubuta wani aikin python 'def count_passing_ways(n: int, m: int) -> int:' don warware matsalar mai zuwa:\n\n    Yana ƙidaya adadin hanyoyi daban-daban don wuce ƙwallo tsakanin 'n' ɗalibai da aka shirya a cikin da'ira \n    ta yadda bayan 'm' wucewa, ƙwallon zai koma ga ɗalibin da ya fara.\n\n    Aikin yana amfani da shirye-shiryen motsi don tantance adadin jerin wucewa. Kowane ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Args:\n    n: Adadin ɗalibai masu tsayawa a cikin da'ira.\n    m: Adadin lokutan da aka wuce ƙwallon.\n\n    Returns:\n    Wani cikakken lamba da ke wakiltar adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\n    dawowa ga ɗalibin da ya fara bayan 'm' wucewa.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "hi": "एक पायथन फ़ंक्शन 'def count_passing_ways(n: int, m: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    'n' छात्रों के बीच एक गेंद पास करने के विभिन्न तरीकों की संख्या गिनें जो एक वृत्त में व्यवस्थित हैं \n    ताकि 'm' पास के बाद, गेंद प्रारंभिक छात्र के पास वापस आ जाए।\n\n    फ़ंक्शन पासिंग अनुक्रमों की संख्या निर्धारित करने के लिए गतिशील प्रोग्रामिंग का उपयोग करता है। प्रत्येक छात्र\n    गेंद को या तो बाएं पड़ोसी या दाएं पड़ोसी को पास कर सकता है।\n\n    तर्क:\n    n: एक वृत्त में खड़े छात्रों की संख्या।\n    m: गेंद को पास करने की संख्या।\n\n    लौटाता है:\n    एक पूर्णांक जो विभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है जिसके परिणामस्वरूप गेंद\n    'm' पास के बाद प्रारंभिक छात्र के पास वापस आ जाती है।\n\n    मामले:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "hu": "Írj egy python függvényt 'def count_passing_ways(n: int, m: int) -> int:' a következő probléma megoldására:\n\n    Számolja meg a különböző módokat, ahogyan egy labdát 'n' diák között lehet passzolni, akik körben állnak úgy, hogy 'm' passz után a labda visszatér a kiinduló diákhoz.\n\n    A függvény dinamikus programozást használ a passzolási sorozatok számának meghatározására. Minden diák\n    átadhatja a labdát vagy a bal szomszédjának, vagy a jobb szomszédjának.\n\n    Paraméterek:\n    n: A körben álló diákok száma.\n    m: A labda passzolásának száma.\n\n    Visszatérési érték:\n    Egy egész szám, amely a különböző passzolási módokat jelöli, amelyek eredményeként a labda\n    'm' passz után visszatér a kiinduló diákhoz.\n\n    Esetek:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6"
    },
    "instruction_bertscore": {
      "sq": "0.9896793640318082",
      "hy": "0.9877025944797491",
      "bn": "0.9717249652596837",
      "bg": "0.9785711586028132",
      "zh": "0.9516841529651686",
      "fr": "0.9887751985373374",
      "de": "0.9825985882086765",
      "ha": "0.9954406382337252",
      "hi": "0.9747423593779847",
      "hu": "0.9640717366784094"
    },
    "level": "easy",
    "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()",
    "entry_point": "count_passing_ways",
    "signature": "def count_passing_ways(n: int, m: int) -> int:",
    "docstring": {
      "en": "\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6\n    ",
      "sq": "\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\n    në mënyrë të tillë që pas 'm' kalimeve, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Args:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalon.\n\n    Returns:\n    Një numër i plotë që përfaqëson numrin e mënyrave të dallueshme të kalimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' kalimeve.\n\n    Rastet:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "hy": "\n    Հաշվում է գնդակը 'n' ուսանողների միջև փոխանցելու տարբեր եղանակների քանակը, որոնք դասավորված են շրջանաձև այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա մեկնարկային ուսանողին։\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար։ Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին։\n\n    Արգումենտներ:\n    n: Շրջանաձև կանգնած ուսանողների քանակը։\n    m: Գնդակի փոխանցումների քանակը։\n\n    Վերադարձնում է:\n    Թիվ, որը ներկայացնում է տարբեր փոխանցման եղանակների քանակը, որոնք հանգեցնում են գնդակի վերադարձին մեկնարկային ուսանողին 'm' փոխանցումներից հետո։\n\n    Դեպքեր:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "bn": "\n    'n' জন শিক্ষার্থীকে একটি বৃত্তে সাজানো অবস্থায় একটি বল পাস করার বিভিন্ন উপায়ের সংখ্যা গণনা করে \n    যাতে 'm' বার পাস করার পর, বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসে।\n\n    ফাংশনটি বল পাস করার ক্রমের সংখ্যা নির্ধারণ করতে গতিশীল প্রোগ্রামিং ব্যবহার করে। প্রতিটি শিক্ষার্থী \n    বলটি বাম পাশের প্রতিবেশী বা ডান পাশের প্রতিবেশীর কাছে পাস করতে পারে।\n\n    আর্গুমেন্ট:\n    n: বৃত্তে দাঁড়িয়ে থাকা শিক্ষার্থীর সংখ্যা।\n    m: বল পাস করার সংখ্যা।\n\n    রিটার্ন:\n    একটি পূর্ণসংখ্যা যা 'm' বার পাস করার পর বলটি শুরু করা শিক্ষার্থীর কাছে ফিরে আসার ফলাফল হিসেবে \n    ভিন্ন পাসিং উপায়ের সংখ্যা উপস্থাপন করে।\n\n    কেস:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "bg": "\n    Брои броя на различните начини за предаване на топка между 'n' ученици, подредени в кръг,\n    така че след 'm' предавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на предаване. Всеки ученик\n    може да предаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на предаванията на топката.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на предаване, които водят до това,\n    че топката се връща при началния ученик след 'm' предавания.\n\n    Примери:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "zh": "\n    计算在 'n' 个学生围成一圈的情况下，将球传递的不同方式的数量，\n    使得经过 'm' 次传递后，球返回到起始学生。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生数量。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在 'm' 次传递后球返回到起始学生的不同传递方式的数量。\n\n    情况:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "fr": "\n    Compte le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants disposés en cercle \n    de sorte qu'après 'm' passes, le ballon revienne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit à son voisin de gauche, soit à son voisin de droite.\n\n    Args:\n    n: Le nombre d'étudiants se tenant en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Returns:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    revienne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "de": "\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis angeordnet sind, so zu passen, dass der Ball nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Passsequenzen zu bestimmen. Jeder Schüler kann den Ball entweder an den linken oder den rechten Nachbarn weitergeben.\n\n    Args:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Returns:\n    Eine ganze Zahl, die die Anzahl der unterschiedlichen Passmöglichkeiten darstellt, die dazu führen, dass der Ball nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "ha": "\n    Yana ƙididdige adadin hanyoyi daban-daban don wuce ƙwallo tsakanin 'n' ɗalibai da aka shirya a cikin da'ira \n    ta yadda bayan 'm' na wucewa, ƙwallon zai dawo ga ɗalibin da ya fara.\n\n    Aiki yana amfani da shirye-shiryen motsi don tantance adadin jerin wucewa. Kowanne ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Ƙayyadaddun bayanai:\n    n: Adadin ɗalibai da ke tsaye a cikin da'ira.\n    m: Adadin lokutan da aka wuce ƙwallon.\n\n    Yana dawowa:\n    Wani cikakken lamba da ke wakiltar adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\n    dawowa ga ɗalibin da ya fara bayan 'm' na wucewa.\n\n    Misalai:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "hi": "\n    'n' छात्रों के बीच गेंद पास करने के विभिन्न तरीकों की संख्या गिनें, जो एक वृत्त में व्यवस्थित हैं, \n    ताकि 'm' पास के बाद, गेंद प्रारंभिक छात्र के पास लौट आए।\n\n    यह फ़ंक्शन पासिंग अनुक्रमों की संख्या निर्धारित करने के लिए डायनामिक प्रोग्रामिंग का उपयोग करता है। प्रत्येक छात्र \n    गेंद को या तो बाएँ पड़ोसी को या दाएँ पड़ोसी को पास कर सकता है।\n\n    तर्क:\n    n: वृत्त में खड़े छात्रों की संख्या।\n    m: गेंद को पास करने की संख्या।\n\n    वापसी:\n    एक पूर्णांक जो विभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है, जिसके परिणामस्वरूप 'm' पास के बाद गेंद \n    प्रारंभिक छात्र के पास लौटती है।\n\n    मामले:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6",
      "hu": "\n    Számolja meg, hányféleképpen lehet átadni a labdát 'n' diák között, akik körben állnak úgy, hogy 'm' átadás után a labda visszatér a kezdő diákhoz.\n\n    A függvény dinamikus programozást használ az átadási sorozatok számának meghatározásához. Minden diák vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja tovább a labdát.\n\n    Paraméterek:\n    n: A körben álló diákok száma.\n    m: A labda átadásának száma.\n\n    Visszatér:\n    Egy egész szám, amely azokat a különböző átadási módokat jelenti, amelyek eredményeként a labda 'm' átadás után visszatér a kezdő diákhoz.\n\n    Esetek:\n    >>> count_passing_ways(3, 3)\n    2\n    >>> count_passing_ways(5, 4)\n    6"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9513719060061818",
      "bn": "0.9534233605815101",
      "bg": "0.9636784485239603",
      "zh": "0.9462339339399524",
      "fr": "0.9861858528901666",
      "de": "0.9735336935093873",
      "ha": "0.9765125533337676",
      "hi": "0.9558377128629891",
      "hu": "0.9605855748608662"
    }
  },
  {
    "task_id": "Python/17",
    "prompt": {
      "en": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Hiq numrat e përsëritur nga lista e dhënë dhe kthe numrat unik të renditur.\n\n    Funksioni fillimisht konverton listën e numrave në një grup për të hequr çdo përsëritje,\n    pastaj rendit grupin e numrave unik. Kthen një dyshe që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\n    Argumentet:\n    numbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\n    Kthen:\n    Tuple[int, List[int]]: Një dyshe me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Հեռացնել կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձնել դասավորված եզակի թվերը։\n\n    Ֆունկցիան նախ փոխակերպում է թվերի մուտքային ցուցակը հավաքածուի՝ հեռացնելու համար ցանկացած կրկնություն,\n    ապա դասավորում է եզակի թվերի ստացված հավաքածուն։ Այն վերադարձնում է զույգ, որը պարունակում է\n    եզակի թվերի քանակը և այդ եզակի թվերի ցուցակը աճման կարգով։\n\n    Արգումենտներ:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնություններ։\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Զույգ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը։\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով։\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যা সরান এবং সাজানো অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট তালিকাকে একটি সেটে রূপান্তর করে যেকোনো সদৃশ সংখ্যা সরিয়ে দেয়,\n    তারপর অনন্য সংখ্যাগুলির সেটকে সাজায়। এটি একটি টিউপল ফেরত দেয় যা অনন্য সংখ্যাগুলির\n    সংখ্যা এবং এই অনন্য সংখ্যাগুলির একটি ক্রমবর্ধমান তালিকা ধারণ করে।\n\n    আর্গুমেন্টসমূহ:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা থাকতে পারে।\n\n    রিটার্নস:\n    Tuple[int, List[int]]: দুটি উপাদান সহ একটি টিউপল:\n        - অনন্য সংখ্যাগুলির সংখ্যাকে উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n        - ক্রমবর্ধমানভাবে সাজানো অনন্য সংখ্যাগুলির একটি তালিকা।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне дубликатите,\n    след това сортира полученото множество от уникални числа. Връща кортеж, съдържащ броя\n    на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък с уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以去除任何重复项，\n    然后对结果的唯一数字集合进行排序。它返回一个包含两个元素的元组：\n    唯一数字的数量和按升序排列的唯一数字列表。\n\n    参数:\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回:\n    Tuple[int, List[int]]: 一个包含两个元素的元组：\n        - 一个整数，表示唯一数字的数量。\n        - 一个按升序排列的唯一数字列表。\n\n    示例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Supprimez les entiers en double de la liste d'entrée et retournez les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entrée de nombres en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés par ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Entfernen Sie doppelte Ganzzahlen aus der Eingabeliste und geben Sie die sortierten eindeutigen Zahlen zurück.\n\n    Die Funktion konvertiert zuerst die Eingabeliste von Zahlen in eine Menge, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge eindeutiger Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Args:\n    numbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\n    Returns:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine Ganzzahl, die die Anzahl der eindeutigen Zahlen darstellt.\n        - Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Cire lambobin maimaitawa daga jerin shigarwa kuma dawo da lambobin da ba su maimaita ba a jere.\n\n    Aiki na farko yana canza jerin lambobi na shigarwa zuwa saitin don cire duk maimaitawa,\n    sannan ya jera saitin lambobin da ba su maimaita ba. Yana dawowa da tuple wanda ke dauke da adadin\n    lambobin da ba su maimaita ba da kuma jerin wadannan lambobin da ba su maimaita ba a cikin tsari mai hawa.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple tare da abubuwa biyu:\n        - Lamba mai nuna adadin lambobin da ba su maimaita ba.\n        - Jerin lambobin da ba su maimaita ba a cikin tsari mai hawa.\n\n    Misalai:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और क्रमबद्ध अद्वितीय संख्याएं लौटाएं।\n\n    यह फ़ंक्शन सबसे पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि कोई भी डुप्लिकेट हट जाए,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\n    और इन अद्वितीय संख्याओं की आरोही क्रम में सूची होती है।\n\n    तर्क:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    रिटर्न:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - अद्वितीय संख्याओं की गिनती को दर्शाने वाला एक पूर्णांक।\n        - अद्वितीय संख्याओं की आरोही क्रम में सूची।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\n    A függvény először átalakítja a bemeneti számok listáját egy halmazzá, hogy eltávolítsa az esetleges duplikátumokat,\n    majd rendezi az így kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza az egyedi számok\n    számát és egy listát ezekről az egyedi számokról növekvő sorrendben.\n\n    Paraméterek:\n    numbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\n    Visszatér:\n    Tuple[int, List[int]]: Egy tuple két elemmel:\n        - Egy egész szám, amely az egyedi számok számát jelöli.\n        - Egy lista az egyedi számokról növekvő sorrendben.\n\n    Példák:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9702642374375531",
      "hy": "0.9916162088772794",
      "bn": "0.971658424082037",
      "bg": "0.992559305926433",
      "zh": "0.9833031301702073",
      "fr": "0.9955927891055979",
      "de": "0.9922206411267686",
      "ha": "0.938124848634203",
      "hi": "0.9865876821510002",
      "hu": "0.9781520484988295"
    },
    "canonical_solution": "# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers",
    "instruction": {
      "en": "Write a python function 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' to solve the following problem:\n\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    ",
      "sq": "Shkruani një funksion python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' për të zgjidhur problemin e mëposhtëm:\n\n    Hiqni numrat e plotë të dyfishtë nga lista e hyrjes dhe ktheni numrat unik të renditur.\n\n    Funksioni së pari konverton listën e numrave të hyrjes në një set për të hequr çdo dublikatë,\n    pastaj rendit setin e rezultuar të numrave unik. Ai kthen një tuple që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\n    Args:\n    numbers (List[int]): Një listë numrash të plotë, që mund të përmbajë dublikatë.\n\n    Returns:\n    Tuple[int, List[int]]: Një tuple me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "hy": "Պայթոն ֆունկցիա 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հեռացրեք կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձեք դասավորված եզակի թվերը։\n\n    Ֆունկցիան նախ փոխակերպում է մուտքային թվերի ցուցակը հավաքածուի՝ հեռացնելու համար ցանկացած կրկնվողներ,\n    ապա դասավորում է ստացված եզակի թվերի հավաքածուն։ Այն վերադարձնում է զույգ, որը պարունակում է եզակի թվերի քանակը\n    և այս եզակի թվերի ցուցակը աճման կարգով։\n\n    Արձագանքներ:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնվողներ։\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Զույգ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը։\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով։\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "bn": "একটি পাইথন ফাংশন 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যাগুলি সরান এবং সাজানো অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট তালিকাকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা থাকে না,\n    তারপর অনন্য সংখ্যাগুলির সেটটিকে সাজায়। এটি একটি টিউপল ফেরত দেয় যা অনন্য সংখ্যাগুলির সংখ্যা \n    এবং এই অনন্য সংখ্যাগুলির একটি তালিকা ক্রমবর্ধমান ক্রমে ধারণ করে।\n\n    আর্গস:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা থাকতে পারে।\n\n    রিটার্নস:\n    Tuple[int, List[int]]: একটি টিউপল যার দুটি উপাদান রয়েছে:\n        - অনন্য সংখ্যাগুলির সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n        - অনন্য সংখ্যাগুলির একটি তালিকা যা ক্রমবর্ধমান ক্রমে সাজানো।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "bg": "Напишете Python функция 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' за да решите следния проблем:\n\n    Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне всички дубликати,\n    след това сортира полученото множество от уникални числа. Тя връща кортеж, съдържащ броя\n    на уникалните числа и списък от тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък на уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "zh": "编写一个Python函数 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' 来解决以下问题：\n\n    从输入列表中删除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以删除任何重复项，\n    然后对结果的唯一数字集合进行排序。它返回一个包含唯一数字计数的元组\n    和一个按升序排列的唯一数字列表。\n\n    参数：\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回：\n    Tuple[int, List[int]]: 一个包含两个元素的元组：\n        - 一个表示唯一数字计数的整数。\n        - 一个按升序排列的唯一数字列表。\n\n    示例：\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "fr": "Écrivez une fonction python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' pour résoudre le problème suivant :\n\n    Supprimez les entiers en double de la liste d'entrée et renvoyez les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entrée de nombres en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle renvoie un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés dans l'ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "de": "Schreiben Sie eine Python-Funktion 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' um das folgende Problem zu lösen:\n\n    Entfernen Sie doppelte Ganzzahlen aus der Eingabeliste und geben Sie die sortierten eindeutigen Zahlen zurück.\n\n    Die Funktion konvertiert zuerst die Eingabeliste der Zahlen in eine Menge, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge der eindeutigen Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Argumente:\n    numbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\n    Rückgabewerte:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine Ganzzahl, die die Anzahl der eindeutigen Zahlen darstellt.\n        - Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Beispiele:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "ha": "Rubuta wani aikin python 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' don warware matsalar mai zuwa:\n\n    Cire lambobin maimaitawa daga jerin shigarwa sannan a dawo da lambobin musamman da aka tsara.\n\n    Aikin yana fara canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa,\n    sannan yana tsara saitin lambobin musamman da aka samu. Yana dawowa da tuple mai dauke da adadin\n    lambobin musamman da jerin wadannan lambobin musamman a tsari mai hauhawa.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple mai dauke da abubuwa biyu:\n        - Lamba mai wakiltar adadin lambobin musamman.\n        - Jerin lambobin musamman da aka tsara a tsari mai hauhawa.\n\n    Misalai:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "hi": "एक पायथन फ़ंक्शन 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटा दें और क्रमबद्ध अद्वितीय संख्याएँ लौटाएँ।\n\n    फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि किसी भी डुप्लिकेट को हटा सके,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\n    और इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\n    तर्क:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    लौटाता है:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - अद्वितीय संख्याओं की गिनती को दर्शाने वाला एक पूर्णांक।\n        - अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में क्रमबद्ध होती है।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "hu": "Írj egy python függvényt 'def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:' a következő probléma megoldására:\n\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\n    A függvény először átalakítja a bemeneti számok listáját egy halmazzá, hogy eltávolítsa az esetleges duplikátumokat,\n    majd rendezi az eredményül kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza\n    az egyedi számok számát és az ezekből álló listát növekvő sorrendben.\n\n    Args:\n    numbers (List[int]): Egész számok listája, amely tartalmazhat duplikátumokat.\n\n    Returns:\n    Tuple[int, List[int]]: Egy tuple két elemmel:\n        - Egy egész szám, amely az egyedi számok számát jelöli.\n        - Az egyedi számok listája növekvő sorrendben.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])"
    },
    "instruction_bertscore": {
      "sq": "0.997563003855083",
      "hy": "0.9940404926778103",
      "bn": "0.9781514526076864",
      "bg": "0.9892767402494506",
      "zh": "0.9893218293459455",
      "fr": "0.9919085927981628",
      "de": "0.9955560424851064",
      "ha": "0.9884065405501367",
      "hi": "0.992524346979371",
      "hu": "0.9834612399535111"
    },
    "level": "easy",
    "test": "def test_process_random_numbers():\n    # Test case 1: Basic example with duplicates\n    assert process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15]) == (8, [15, 20, 32, 40, 67, 89, 300, 400]), \"Test case 1 failed\"\n\n    # Test case 2: All elements are the same\n    assert process_random_numbers([1, 1, 1, 1]) == (1, [1]), \"Test case 2 failed\"\n\n    # Test case 3: No duplicates\n    assert process_random_numbers([3, 1, 4, 2]) == (4, [1, 2, 3, 4]), \"Test case 3 failed\"\n\n    # Test case 4: Random numbers with single element\n    assert process_random_numbers([42]) == (1, [42]), \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert process_random_numbers([]) == (0, []), \"Test case 5 failed\"\n\n    # Test case 6: Random numbers with negatives and zero\n    assert process_random_numbers([0, -1, -2, -1, 0, 3]) == (4, [-2, -1, 0, 3]), \"Test case 6 failed\"\n\n    # Test case 7: Large range of numbers\n    assert process_random_numbers(list(range(1000, 0, -1))) == (1000, list(range(1, 1001))), \"Test case 7 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_process_random_numbers()",
    "entry_point": "process_random_numbers",
    "signature": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:",
    "docstring": {
      "en": "\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    ",
      "sq": "\n    Hiqni numrat e përsëritur nga lista e hyrjes dhe kthejeni numrat unik të renditur.\n\n    Funksioni së pari konverton listën e numrave të hyrjes në një set për të hequr çdo përsëritje,\n    pastaj rendit setin e rezultuar të numrave unik. Ai kthen një tuple që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\n    Argumentet:\n    numbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\n    Kthen:\n    Tuple[int, List[int]]: Një tuple me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "hy": "\n    Մուտքային ցուցակից հեռացնել կրկնվող ամբողջ թվերը և վերադարձնել դասավորված եզակի թվերը։\n\n    Ֆունկցիան նախ մուտքային թվերի ցուցակը փոխակերպում է բազմության՝ կրկնօրինակները հեռացնելու համար,\n    ապա դասավորում է ստացված եզակի թվերի բազմությունը։ Այն վերադարձնում է տուփ, որը պարունակում է\n    եզակի թվերի քանակը և այդ եզակի թվերի ցուցակը աճման կարգով։\n\n    Պարամետրեր:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնօրինակներ։\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Տուփ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը։\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով։\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "bn": "\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যাগুলি সরান এবং বাছাইকৃত অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট সংখ্যার তালিকাকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা না থাকে,\n    তারপর অনন্য সংখ্যাগুলির সেটকে সাজায়। এটি একটি টুপল ফেরত দেয় যা অনন্য সংখ্যাগুলির সংখ্যা এবং \n    এই অনন্য সংখ্যাগুলির একটি তালিকা ক্রমবর্ধমান ক্রমে অন্তর্ভুক্ত করে।\n\n    প্যারাম:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা থাকতে পারে।\n\n    রিটার্নস:\n    Tuple[int, List[int]]: দুটি উপাদান সহ একটি টুপল:\n        - অনন্য সংখ্যাগুলির গণনা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n        - অনন্য সংখ্যাগুলির একটি তালিকা যা ক্রমবর্ধমান ক্রমে সাজানো।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "bg": "\n    Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне всички дубликати,\n    след това сортира полученото множество от уникални числа. Връща кортеж, съдържащ броя\n    на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък с уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "zh": "\n    从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以去除任何重复项，\n    然后对结果的唯一数字集合进行排序。它返回一个包含唯一数字计数和这些唯一数字按升序排列的列表的元组。\n\n    参数:\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回:\n    Tuple[int, List[int]]: 一个包含两个元素的元组:\n        - 一个整数，表示唯一数字的数量。\n        - 一个按升序排列的唯一数字列表。\n\n    示例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "fr": "\n    Supprimer les entiers dupliqués de la liste d'entrée et retourner les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entiers en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés par ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "de": "\n    Entferne doppelte ganze Zahlen aus der Eingabeliste und gib die sortierten eindeutigen Zahlen zurück.\n\n    Die Funktion wandelt zuerst die Eingabeliste von Zahlen in eine Menge um, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge eindeutiger Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Argumente:\n    numbers (List[int]): Eine Liste von ganzen Zahlen, die Duplikate enthalten kann.\n\n    Rückgabewerte:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine ganze Zahl, die die Anzahl der eindeutigen Zahlen darstellt.\n        - Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Beispiele:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "ha": "\n    Cire lambobin maimaita daga jerin shigarwa kuma mayar da lambobin daban-daban masu tsari.\n\n    Aiki yana fara da canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa,\n    sannan yana tsara saitin lambobin daban-daban da aka samu. Yana mayar da wani tuple wanda ke dauke da adadin\n    lambobin daban-daban da kuma jerin wadannan lambobin daban-daban a tsari mai hawa.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple tare da abubuwa biyu:\n        - Wani lamba wanda ke wakiltar adadin lambobin daban-daban.\n        - Jerin lambobin daban-daban da aka tsara a tsari mai hawa.\n\n    Misalai:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "hi": "\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और अद्वितीय संख्याओं को क्रमबद्ध करके लौटाएं।\n\n    फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में बदलता है ताकि कोई भी डुप्लिकेट हट जाएं,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें\n    अद्वितीय संख्याओं की गिनती और इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\n    तर्क:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    रिटर्न:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - एक पूर्णांक जो अद्वितीय संख्याओं की गिनती का प्रतिनिधित्व करता है।\n        - अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में होती है।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])",
      "hu": "\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\n    A függvény először a bemeneti számok listáját egy halmazzá alakítja, hogy eltávolítsa az esetleges duplikátumokat,\n    majd rendezi az így kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza az egyedi számok számát\n    és ezeknek az egyedi számoknak a listáját növekvő sorrendben.\n\n    Paraméterek:\n    numbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\n    Visszatérési érték:\n    Tuple[int, List[int]]: Egy két elemből álló tuple:\n        - Egy egész szám, amely az egyedi számok számát jelenti.\n        - Egy lista az egyedi számokról növekvő sorrendben.\n\n    Példák:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])"
    },
    "docstring_bertscore": {
      "sq": "0.9893434800574783",
      "hy": "0.985078289885516",
      "bn": "0.9849601048088004",
      "bg": "0.996020440315966",
      "zh": "0.9934392385144176",
      "fr": "0.9838453911104326",
      "de": "0.9954827478745045",
      "ha": "0.9730778367849123",
      "hi": "0.9901693851818213",
      "hu": "0.9751952366467442"
    }
  },
  {
    "task_id": "Python/18",
    "prompt": {
      "en": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit 0-1 të çantës ku secili artikull ka një çmim dhe një \n    vlerë të lidhur rëndësie. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimi total buxhetin.\n    \n    Argumentet:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë tuplesh, ku secili tuple përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Kthen:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Shembuj:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվում է ապրանքների առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում։\n    \n    Այս ֆունկցիան լուծում է 0-1 պայուսակի խնդրի տարբերակ, որտեղ յուրաքանչյուր ապրանք ունի գին և \n    կապված կարևորության արժեք։ Նպատակն է առավելագույնացնել ապրանքների ընտրության կարևորության արժեքների \n    գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն։\n    \n    Պարամետրեր:\n    n (int): Ապրանքներ գնելու համար հասանելի ընդհանուր բյուջեն։\n    m (int): Ընտրելու համար տարբեր ապրանքների քանակը։\n    items (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի պարունակում է երկու ամբողջ թիվ՝\n        - Առաջին թիվը ներկայացնում է ապրանքի գինը։\n        - Երկրորդ թիվը ներկայացնում է ապրանքի կարևորության արժեքը։\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է ստանալ առանց բյուջեն գերազանցելու։\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    প্রদত্ত বাজেটের মধ্যে ক্রয় করা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি ভিন্ন রূপ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল আইটেমগুলির একটি নির্বাচনের গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    আর্গুমেন্টসমূহ:\n    n (int): আইটেম ক্রয়ের জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): একটি টাপলের তালিকা, যেখানে প্রতিটি টাপল দুটি পূর্ণসংখ্যা ধারণ করে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n    \n    রিটার্নস:\n    int: বাজেট অতিক্রম না করে অর্জন করা যেতে পারে এমন সর্বাধিক মোট গুরুত্ব মান।\n    \n    উদাহরণ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на важност на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата 0-1, където всеки предмет има цена и свързана стойност на важност. \n    Целта е да се максимизира сумата от стойностите на важност на избраните предмети, без общата цена да надвишава бюджета.\n    \n    Аргументи:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които може да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n        - Първото число представлява цената на предмета.\n        - Второто число представлява стойността на важност на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важност, която може да бъде постигната, без да се надвишава бюджета.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    此函数解决了0-1背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。\n    目标是在不超过预算的情况下，最大化所选物品的重要性值之和。\n    \n    参数:\n    n (int): 可用于购买物品的总预算。\n    m (int): 可选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个包含元组的列表，其中每个元组包含两个整数:\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回:\n    int: 在不超过预算的情况下可以达到的最大总重要性值。\n    \n    示例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcule la valeur totale maximale d'importance des articles qui peuvent être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Arguments:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le deuxième entier représente la valeur d'importance de l'article.\n    \n    Retourne:\n    int: La valeur totale maximale d'importance qui peut être atteinte sans dépasser le budget.\n    \n    Exemples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen \n    zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer \n    Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Argumente:\n    n (int): Das insgesamt verfügbare Budget zum Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen Gegenstände, aus denen gewählt werden kann.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Rückgabe:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa mafi girman jimlar darajar muhimmanci na kayayyakin da za a iya saya cikin kasafin kudi da aka bayar.\n    \n    Wannan aikin yana warware wani nau'i na matsalar jakar 0-1 inda kowanne kaya yana da farashi da kuma \n    darajar muhimmanci mai alaka. Manufar ita ce a kara jimlar darajar muhimmanci na zaben kayayyaki \n    ba tare da jimlar farashi ya wuce kasafin kudin ba.\n    \n    Args:\n    n (int): Jimlar kasafin kudin da ake da shi don siyan kayayyaki.\n    m (int): Yawan nau'ikan kayayyaki daban-daban da za a zaba daga ciki.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi guda biyu:\n        - Lamba ta farko tana wakiltar farashin kayan.\n        - Lamba ta biyu tana wakiltar darajar muhimmancin kayan.\n    \n    Returns:\n    int: Mafi girman jimlar darajar muhimmanci da za a iya samu ba tare da wuce kasafin kudin ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    दिए गए बजट के भीतर खरीदे जा सकने वाले वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक \n    संबंधित महत्व मान होता है। लक्ष्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को अधिकतम किया जाए \n    बिना कुल कीमत बजट से अधिक हुए।\n    \n    Args:\n    n (int): वस्तुएँ खरीदने के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    Returns:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kiszámítja a tárgyak maximális összesített fontossági értékét, amelyeket egy adott költségvetésen belül lehet megvásárolni.\n    \n    Ez a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy \n    hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek \n    összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n    \n    Paraméterek:\n    n (int): A tárgyak vásárlására rendelkezésre álló teljes költségvetés.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár két egész számot tartalmaz:\n        - Az első egész szám a tárgy árát jelenti.\n        - A második egész szám a tárgy fontossági értékét jelenti.\n    \n    Visszatér:\n    int: A maximális összesített fontossági érték, amely elérhető anélkül, hogy meghaladná a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9882837869746571",
      "hy": "0.9826063347935369",
      "bn": "0.9862301474651374",
      "bg": "0.9895784597982425",
      "zh": "0.9740290776796884",
      "fr": "0.99576400849405",
      "de": "0.9825084100156867",
      "ha": "0.9718677805036477",
      "hi": "0.9883280815496279",
      "hu": "0.9713348551913311"
    },
    "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]",
    "instruction": {
      "en": "Write a python function 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    ",
      "sq": "Shkruani një funksion python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit të çantës 0-1 ku çdo artikull ka një çmim dhe një \n    vlerë të rëndësisë së lidhur. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimin total buxhetin.\n    \n    Args:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë e tufa, ku çdo tufë përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Returns:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "hy": "Պայթոն ֆունկցիա 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է իրերի առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում:\n    \n    Այս ֆունկցիան լուծում է 0-1 ուսապարկի խնդրի մի տարբերակ, որտեղ յուրաքանչյուր իր ունի գին և \n    համապատասխան կարևորության արժեք: Նպատակն է առավելագույնացնել իրերի ընտրության \n    կարևորության արժեքների գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն:\n    \n    Արձ:\n    n (int): Ընդհանուր բյուջեն, որը հասանելի է իրեր գնելու համար:\n    m (int): Ընտրելու համար տարբեր իրերի քանակը:\n    items (List[Tuple[int, int]]): Կրկնորդների ցուցակ, որտեղ յուրաքանչյուր կրկնորդ պարունակում է երկու ամբողջ թիվ:\n        - Առաջին ամբողջ թիվը ներկայացնում է իրի գինը:\n        - Երկրորդ ամբողջ թիվը ներկայացնում է իրի կարևորության արժեքը:\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է հասնել առանց բյուջեն գերազանցելու:\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "bn": "একটি পাইথন ফাংশন 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত বাজেটের মধ্যে কেনা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি প্রকরণ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল আইটেমগুলির একটি নির্বাচনের গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    আর্গুমেন্টস:\n    n (int): আইটেম কেনার জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য নির্দেশ করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান নির্দেশ করে।\n    \n    রিটার্নস:\n    int: সর্বাধিক মোট গুরুত্ব মান যা বাজেট অতিক্রম না করে অর্জন করা যেতে পারে।\n    \n    উদাহরণ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "bg": "Напишете функция на Python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:', за да решите следния проблем:\n\n    Изчислява максималната обща стойност на важност на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата (0-1 knapsack problem), където всеки предмет има цена и \n    свързана стойност на важност. Целта е да се максимизира сумата от стойностите на важност на \n    избрани предмети, без общата цена да надвишава бюджета.\n    \n    Аргументи:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n        - Първото цяло число представлява цената на предмета.\n        - Второто цяло число представлява стойността на важност на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важност, която може да бъде постигната, без да се надвишава бюджетът.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "zh": "编写一个 Python 函数 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' 来解决以下问题：\n\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    此函数解决了 0-1 背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。目标是最大化所选物品的重要性值之和，而总价格不超过预算。\n    \n    参数：\n    n (int): 可用于购买物品的总预算。\n    m (int): 可选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数：\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回：\n    int: 在不超过预算的情况下可以实现的最大总重要性值。\n    \n    示例：\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "fr": "Écrivez une fonction python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calcule la valeur totale maximale d'importance des articles qui peuvent être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Args:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le deuxième entier représente la valeur d'importance de l'article.\n    \n    Returns:\n    int: La valeur totale maximale d'importance qui peut être atteinte sans dépasser le budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "de": "Schreiben Sie eine Python-Funktion 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen \n    zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer \n    Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Argumente:\n    n (int): Das gesamte verfügbare Budget für den Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen Gegenstände, aus denen gewählt werden kann.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Rückgabewert:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "ha": "Rubuta wani aikin python 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi girman jimillar darajar muhimmanci na abubuwan da za a iya saya a cikin kasafin kuɗi da aka bayar.\n    \n    Wannan aikin yana warware wani bambancin matsalar 0-1 knapsack inda kowanne abu yana da farashi da \n    darajar muhimmanci da aka haɗa. Manufar ita ce a ƙara yawan jimlar darajar muhimmanci na \n    zaɓin abubuwa ba tare da jimillar farashi ta wuce kasafin kuɗi ba.\n    \n    Args:\n    n (int): Jimillar kasafin kuɗi da ake da shi don sayen abubuwa.\n    m (int): Yawan abubuwa daban-daban da za a zaɓa daga.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi guda biyu:\n        - Lamba ta farko tana wakiltar farashin abu.\n        - Lamba ta biyu tana wakiltar darajar muhimmancin abu.\n    \n    Returns:\n    int: Mafi girman jimillar darajar muhimmanci da za a iya samu ba tare da wuce kasafin kuɗi ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "hi": "एक पायथन फ़ंक्शन 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    उन वस्तुओं के अधिकतम कुल महत्व मान की गणना करें जिन्हें दिए गए बजट के भीतर खरीदा जा सकता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और \n    एक संबंधित महत्व मान होता है। उद्देश्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को \n    अधिकतम किया जाए बिना कुल कीमत बजट से अधिक हुए।\n    \n    तर्क:\n    n (int): वस्तुएं खरीदने के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    लौटाता है:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    उदाहरण:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "hu": "Írj egy python függvényt 'def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:' a következő probléma megoldására:\n\n    Kiszámítja a tárgyak maximális összfontossági értékét, amelyeket egy adott költségvetésen belül lehet megvásárolni.\n    \n    Ez a függvény megoldja a 0-1 hátizsák probléma egy változatát, ahol minden tárgynak van egy ára és egy \n    hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a tárgyak kiválasztásának fontossági értékeinek \n    összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n    \n    Paraméterek:\n    n (int): Az összes rendelkezésre álló költségvetés a tárgyak megvásárlásához.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy tuple-ök listája, ahol minden tuple két egész számot tartalmaz:\n        - Az első egész szám a tárgy árát jelenti.\n        - A második egész szám a tárgy fontossági értékét jelenti.\n    \n    Visszatér:\n    int: A maximális összfontossági érték, amely elérhető anélkül, hogy meghaladná a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80"
    },
    "instruction_bertscore": {
      "sq": "0.9903525223931354",
      "hy": "0.9874384160729727",
      "bn": "0.9819222517612528",
      "bg": "0.972797569317272",
      "zh": "0.9817615597829955",
      "fr": "0.9960820157340868",
      "de": "0.9861044144339424",
      "ha": "0.9688805782032641",
      "hi": "0.9799349547989987",
      "hu": "0.9826895609231905"
    },
    "level": "easy",
    "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()",
    "entry_point": "max_happiness",
    "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    ",
      "sq": "\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit 0-1 të çantës ku secili artikull ka një çmim dhe një \n    vlerë të lidhur rëndësie. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimi total buxhetin.\n    \n    Argumentet:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë e tufeve, ku secila tufë përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Kthen:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Shembuj:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "hy": "\n    Հաշվարկում է ապրանքների առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է գնել տրված բյուջեի սահմաններում։\n    \n    Այս ֆունկցիան լուծում է 0-1 դարակաշարային խնդրի մի տարբերակ, որտեղ յուրաքանչյուր ապրանք ունի գին և \n    կապված կարևորության արժեք։ Նպատակն է առավելագույնացնել ապրանքների ընտրության կարևորության արժեքների \n    գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն։\n    \n    Արձանագրություններ:\n    n (int): Ապրանքներ գնելու համար հասանելի ընդհանուր բյուջեն։\n    m (int): Ընտրելու համար տարբեր ապրանքների քանակը։\n    items (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի թիվ պարունակում է երկու ամբողջ թիվ՝\n        - Առաջին ամբողջ թիվը ներկայացնում է ապրանքի գինը։\n        - Երկրորդ ամբողջ թիվը ներկայացնում է ապրանքի կարևորության արժեքը։\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է ստանալ առանց բյուջեն գերազանցելու։\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "bn": "\n    প্রদত্ত বাজেটের মধ্যে কেনা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি প্রকরণ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল এমন আইটেমগুলির একটি নির্বাচন থেকে গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    Args:\n    n (int): আইটেম কেনার জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): টুপলের একটি তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n    \n    Returns:\n    int: বাজেট অতিক্রম না করে অর্জন করা যেতে পারে এমন সর্বাধিক মোট গুরুত্ব মান।\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "bg": "\n    Изчислява максималната обща стойност на важността на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата (0-1 knapsack problem), където всеки предмет има цена и свързана с нея стойност на важността. Целта е да се максимизира сумата от стойностите на важността на избраните предмети, без общата цена да надвишава бюджета.\n    \n    Параметри:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които може да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n        - Първото число представлява цената на предмета.\n        - Второто число представлява стойността на важността на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важността, която може да бъде постигната, без да се надвишава бюджета.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "zh": "\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    该函数解决了0-1背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。\n    目标是在不超过预算的情况下，最大化所选物品的重要性值之和。\n    \n    参数:\n    n (int): 可用于购买物品的总预算。\n    m (int): 可供选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数:\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回:\n    int: 在不超过预算的情况下可以达到的最大总重要性值。\n    \n    示例:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "fr": "\n    Calcule la valeur d'importance totale maximale des articles pouvant être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Arguments:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le second entier représente la valeur d'importance de l'article.\n    \n    Retourne:\n    int: La valeur d'importance totale maximale pouvant être atteinte sans dépasser le budget.\n    \n    Exemples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "de": "\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Argumente:\n    n (int): Das gesamte verfügbare Budget für den Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen zur Auswahl stehenden Gegenstände.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Rückgabewert:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "ha": "\n    Lissafa yawan jimillar mahimmancin abubuwan da za a iya saya cikin kasafin kuɗi da aka bayar.\n    \n    Wannan aikin yana warware wani bambancin matsalar jakar 0-1 inda kowanne abu yana da farashi da kuma \n    mahimmancin da aka haɗa. Manufar ita ce a haɓaka jimillar mahimmancin zaɓin abubuwa ba tare da \n    jimillar farashin ta zarce kasafin kuɗi ba.\n    \n    Args:\n    n (int): Jimillar kasafin kuɗi da ake da shi don siyan abubuwa.\n    m (int): Yawan abubuwa daban-daban da za a zaɓa daga.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi biyu:\n        - Lamba ta farko tana wakiltar farashin abu.\n        - Lamba ta biyu tana wakiltar mahimmancin abu.\n    \n    Returns:\n    int: Jimillar mahimmancin da za a iya samu ba tare da zarce kasafin kuɗi ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "hi": "\n    दिए गए बजट के भीतर खरीदे जा सकने वाले वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक \n    संबंधित महत्व मान होता है। लक्ष्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को अधिकतम किया जाए \n    बिना कुल कीमत बजट से अधिक हुए।\n    \n    Args:\n    n (int): वस्तुएं खरीदने के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    Returns:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80",
      "hu": "\n    Kiszámítja a tárgyak maximális összesített fontossági értékét, amelyeket meg lehet vásárolni egy adott költségvetésen belül.\n    \n    Ez a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n    \n    Paraméterek:\n    n (int): A tárgyak vásárlására rendelkezésre álló teljes költségvetés.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy két egész számot tartalmazó tuple:\n        - Az első egész szám a tárgy árát jelöli.\n        - A második egész szám a tárgy fontossági értékét jelöli.\n    \n    Visszatér:\n    int: A maximális összesített fontossági érték, amely elérhető anélkül, hogy meghaladnánk a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80"
    },
    "docstring_bertscore": {
      "sq": "0.9741933450048043",
      "hy": "0.9867698262104092",
      "bn": "0.9816403952505642",
      "bg": "0.9682948172095922",
      "zh": "0.9684463721903218",
      "fr": "0.9941906572458726",
      "de": "0.9624566730502148",
      "ha": "0.9512741798587127",
      "hi": "0.9840213776280294",
      "hu": "0.9643394904320445"
    }
  },
  {
    "task_id": "Python/19",
    "prompt": {
      "en": "def max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "sq": "def max_energy(beads):\n    \"\"\"\n    Llogarit energjinë maksimale që mund të çlirohet duke bashkuar rruazat në një varëse.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një varëse, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së secilës rruazë duhet të përputhet\n    me vlerën e bishtit të rruazës së ardhshme në sekuencë. Varësja është rrethore, dhe bashkimi i dy rruazave\n    ngjitur çliron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës përputhëse,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur çlirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit\n    të rruazave dhe përdor programimin dinamik për të llogaritur energjinë maksimale të mundshme.\n\n    Args:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të varëses.\n\n    Returns:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "hy": "def max_energy(beads):\n    \"\"\"\n    Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտների միաձուլմամբ վզնոցում:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա գտնվող էներգիայի մարգարիտները, որտեղ\n    յուրաքանչյուր մարգարիտ ունի գլխի և պոչի արժեք: Յուրաքանչյուր մարգարիտի գլխի արժեքը պետք է համընկնի հաջորդ մարգարիտի\n    պոչի արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից մարգարիտների միաձուլումը ազատում է էներգիա,\n    որը հավասար է առաջին մարգարիտի գլխի արժեքի, համընկնող արժեքի և երկրորդ մարգարիտի պոչի արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միաձուլման բոլոր հնարավոր կարգերը\n    և օգտագործում է դինամիկ ծրագրավորում՝ առավելագույն հասանելի էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլխի արժեքը և\n               նախորդ մարգարիտի պոչի արժեքը: Վերջին մարգարիտի պոչի արժեքը ենթադրվում է, որ համընկնում է առաջին\n               մարգարիտի գլխի արժեքի հետ՝ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր մարգարիտների օպտիմալ միաձուլմամբ:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "bn": "def max_energy(beads):\n    \"\"\"\n    একটি মালার উপর মুক্তাগুলি একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা গ্রহণ করে যা একটি মালার উপর শক্তি মুক্তাগুলিকে উপস্থাপন করে, যেখানে\n    প্রতিটি মুক্তার একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি মুক্তার মাথার মান অবশ্যই পরবর্তী মুক্তার\n    লেজের মানের সাথে মেলাতে হবে। মালাটি বৃত্তাকার, এবং দুটি সংলগ্ন মুক্তা একত্রিত করলে প্রথম মুক্তার\n    মাথার মান, মেলানো মান, এবং দ্বিতীয় মুক্তার লেজের মানের গুণফল সমান শক্তি মুক্তি পায়।\n\n    সর্বাধিক শক্তি মুক্তির জন্য, ফাংশনটি মুক্তাগুলি একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং গতিশীল প্রোগ্রামিং ব্যবহার করে সর্বাধিক প্রাপ্তযোগ্য শক্তি গণনা করে।\n\n    আর্গস:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি মুক্তার মাথার মান এবং\n               পূর্ববর্তী মুক্তার লেজের মান উপস্থাপন করে। মালার বৃত্তাকার প্রকৃতির কারণে শেষ মুক্তার\n               লেজের মান প্রথম মুক্তার মাথার মানের সাথে মেলে বলে ধরা হয়।\n\n    রিটার্নস:\n        একটি পূর্ণসংখ্যা যা সমস্ত মুক্তা সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "bg": "def max_energy(beads):\n    \"\"\"\n    Изчислява максималната енергия, която може да бъде освободена чрез обединяване на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада\n    със стойността на опашката на следващото мънисто в последователността. Огърлицата е кръгова и обединяването\n    на две съседни мъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто,\n    съвпадащата стойност и стойността на опашката на второто мънисто.\n\n    За да намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на обединяване на мъниста\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко число представлява стойността на главата на мънисто и\n               стойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се предполага,\n               че съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално обединяване на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "zh": "def max_energy(beads):\n    \"\"\"\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子都有一个头部和尾部值。\n    每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻珠子\n    释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n    为了找到最大能量释放，函数考虑所有可能的合并珠子的顺序，并使用动态规划来计算可获得的最大能量。\n\n    参数:\n        beads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。\n               由于项链的环形特性，假设最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n    返回:\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "fr": "def max_energy(beads):\n    \"\"\"\n    Calculer l'énergie maximale qui peut être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et une valeur de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la deuxième perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Arguments:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Retourne:\n        Un entier représentant l'énergie maximale qui peut être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Exemples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "de": "def max_energy(beads):\n    \"\"\"\n    Berechne die maximale Energie, die durch das Verschmelzen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten\n    Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Verschmelzen von zwei benachbarten\n    Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden Wert und dem\n    Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des\n    Verschmelzens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede Zahl den Kopfwert einer Perle und den Schwanzwert der\n               vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird aufgrund der kreisförmigen\n               Natur der Halskette als übereinstimmend mit dem Kopfwert der ersten Perle angenommen.\n\n    Rückgabe:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Verschmelzen aller Perlen\n        erreicht werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "ha": "def max_energy(beads):\n    \"\"\"\n    Lissafa mafi yawan kuzari da za a iya saki ta hanyar haɗa beads akan abin wuya.\n\n    Aikin yana ɗaukar jerin lambobi waɗanda ke wakiltar kuzarin beads akan abin wuya, inda\n    kowanne bead yana da ƙimar kai da ƙimar wutsiya. Dole ne ƙimar kai na kowanne bead ya dace da ƙimar wutsiya\n    na bead na gaba a jere. Abin wuya yana zagaye, kuma haɗa beads biyu masu makwabtaka\n    yana sakin kuzari daidai da samfurin ƙimar kai na bead na farko, ƙimar da ta dace,\n    da ƙimar wutsiya na bead na biyu.\n\n    Don nemo mafi yawan sakin kuzari, aikin yana la'akari da dukkan yiwuwar oda na haɗa beads\n    kuma yana amfani da shirye-shiryen motsi don lissafa mafi yawan kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowanne lamba yana wakiltar ƙimar kai na bead da\n               ƙimar wutsiya na bead na baya. Ana ɗauka cewa ƙimar wutsiya na bead na ƙarshe\n               ya dace da ƙimar kai na bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar mafi yawan kuzari da za a iya samu ta hanyar haɗa duk beads da kyau.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "hi": "def max_energy(beads):\n    \"\"\"\n    एक माला पर मोतियों को मिलाकर जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\n    यह फ़ंक्शन एक सूची लेता है जिसमें माला पर ऊर्जा मोतियों का प्रतिनिधित्व करने वाले पूर्णांक होते हैं,\n    जहां प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में अगले मोती के\n    पूंछ मान से मेल खाना चाहिए। माला गोलाकार है, और दो सटे हुए मोतियों को मिलाने पर उतनी ऊर्जा जारी होती है\n    जितनी पहले मोती के सिर मान, मेल खाने वाले मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है\n    और गतिशील प्रोग्रामिंग का उपयोग करके प्राप्त की जा सकने वाली अधिकतम ऊर्जा की गणना करता है।\n\n    तर्क:\n        beads: पूर्णांकों की एक सूची जहां प्रत्येक पूर्णांक एक मोती के सिर मान और\n               पिछले मोती के पूंछ मान का प्रतिनिधित्व करता है। माला की गोलाकार प्रकृति के कारण\n               अंतिम मोती का पूंछ मान पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\n    वापसी:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\"",
      "hu": "def max_energy(beads):\n    \"\"\"\n    Számítsa ki a maximális energiát, amely a gyöngyök összeolvasztásával szabadulhat fel egy nyakláncon.\n\n    A függvény egy egész számok listáját veszi át, amelyek a nyaklánc gyöngyeinek energiáját képviselik, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő\n    gyöngy farokértékével a sorozatban. A nyaklánc kör alakú, és két szomszédos gyöngy összeolvasztása\n    energiát szabadít fel, amely egyenlő az első gyöngy fejértékének, az egyező értéknek és a második gyöngy\n    farokértékének szorzatával.\n\n    A maximális energiafelszabadulás megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Args:\n        beads: Egy egész számok listája, ahol minden egész szám egy gyöngy fejértékét és az előző gyöngy\n               farokértékét képviseli. Az utolsó gyöngy farokértéke feltételezhetően megegyezik az első\n               gyöngy fejértékével a nyaklánc körkörös jellege miatt.\n\n    Returns:\n        Egy egész szám, amely a maximális energiát képviseli, amely az összes gyöngy optimális összeolvasztásával\n        nyerhető.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9781123224226226",
      "hy": "0.9713509442521949",
      "bn": "0.9514765842169872",
      "bg": "0.9748512088267918",
      "zh": "0.9713888826549726",
      "fr": "0.983671589527027",
      "de": "0.9860120513067611",
      "ha": "0.9606586708410869",
      "hi": "0.9728448433479584",
      "hu": "0.9845892618874083"
    },
    "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))",
    "instruction": {
      "en": "Write a python function 'def max_energy(beads):' to solve the following problem:\n\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    ",
      "sq": "Shkruani një funksion python 'def max_energy(beads):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni energjinë maksimale që mund të lirohet duke bashkuar rruazat në një varëse.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një varëse, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së çdo rruaze duhet të përputhet me vlerën e bishtit\n    të rruazës tjetër në sekuencë. Varësja është rrethore, dhe bashkimi i dy rruazave ngjitur\n    liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës që përputhet,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit të rruazave\n    dhe përdor programimin dinamik për të llogaritur energjinë maksimale të arritshme.\n\n    Args:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të varëses.\n\n    Returns:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar optimalisht të gjitha rruazat.\n\n    Shembuj:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "hy": "Պայթոն ֆունկցիա 'def max_energy(beads):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել վզնոցի վրա գնդիկները միացնելիս:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա գտնվող էներգիայի գնդիկները, որտեղ\n    յուրաքանչյուր գնդիկ ունի գլուխ և պոչ արժեք: Յուրաքանչյուր գնդիկի գլուխ արժեքը պետք է համընկնի հաջորդ գնդիկի\n    պոչ արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից գնդիկների միացումը ազատում է էներգիա,\n    որը հավասար է առաջին գնդիկի գլուխ արժեքի, համընկնող արժեքի և երկրորդ գնդիկի պոչ արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում գնդիկների միացման բոլոր հնարավոր\n    կարգերը և օգտագործում է դինամիկ ծրագրավորում՝ առավելագույն էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է գնդիկի գլուխ արժեքը և\n               նախորդ գնդիկի պոչ արժեքը: Վերջին գնդիկի պոչ արժեքը համարվում է, որ համընկնում է առաջին գնդիկի\n               գլուխ արժեքի հետ՝ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր գնդիկները օպտիմալ\n        միացնելիս:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "bn": "একটি পাইথন ফাংশন 'def max_energy(beads):' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    নেকলেসে থাকা পুঁতিগুলিকে একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা গ্রহণ করে যা নেকলেসে থাকা শক্তি পুঁতিগুলিকে উপস্থাপন করে, যেখানে\n    প্রতিটি পুঁতির একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি পুঁতির মাথার মান অবশ্যই ক্রমানুসারে পরবর্তী পুঁতির\n    লেজের মানের সাথে মেলাতে হবে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন পুঁতিকে একত্রিত করলে প্রথম পুঁতির মাথার মান,\n    মিলিত মান এবং দ্বিতীয় পুঁতির লেজের মানের গুণফলের সমান শক্তি মুক্তি পায়।\n\n    সর্বাধিক শক্তি মুক্তি খুঁজে পেতে, ফাংশনটি পুঁতিগুলিকে একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং সর্বাধিক প্রাপ্তিযোগ্য শক্তি গণনা করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে।\n\n    আর্গস:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি পুঁতির মাথার মান এবং\n               পূর্ববর্তী পুঁতির লেজের মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে\n               শেষ পুঁতির লেজের মান প্রথম পুঁতির মাথার মানের সাথে মেলানোর অনুমান করা হয়।\n\n    রিটার্নস:\n        একটি পূর্ণসংখ্যা যা সমস্ত পুঁতিকে সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "bg": "Напишете Python функция 'def max_energy(beads):', за да решите следния проблем:\n\n    Изчислете максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийни мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада със стойността на опашката\n    на следващото мънисто в последователността. Огърлицата е кръгова, и сливането на две съседни\n    мъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто, съвпадащата\n    стойност и стойността на опашката на второто мънисто.\n\n    За да намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко число представлява стойността на главата на мънисто и\n               стойността на опашката на предходното мънисто. Стойността на опашката на последното мънисто се предполага\n               да съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "zh": "编写一个Python函数'def max_energy(beads):'来解决以下问题：\n\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子都有一个头部和尾部值。每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻的珠子释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n    为了找到最大能量释放，函数考虑所有可能的珠子合并顺序，并使用动态编程来计算可获得的最大能量。\n\n    参数：\n        beads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。由于项链的环形特性，假设最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n    返回：\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例：\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "fr": "Écrivez une fonction python 'def max_energy(beads):' pour résoudre le problème suivant :\n\n    Calculer l'énergie maximale qui peut être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la deuxième perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Args:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Returns:\n        Un entier représentant l'énergie maximale qui peut être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Exemples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "de": "Schreiben Sie eine Python-Funktion 'def max_energy(beads):', um das folgende Problem zu lösen:\n\n    Berechnen Sie die maximale Energie, die durch das Zusammenführen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten\n    Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Zusammenführen von zwei benachbarten\n    Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden Wert und dem\n    Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des\n    Zusammenführens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede ganze Zahl den Kopfwert einer Perle und den\n               Schwanzwert der vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird\n               aufgrund der kreisförmigen Natur der Halskette als mit dem Kopfwert der ersten Perle übereinstimmend angenommen.\n\n    Rückgabe:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Zusammenführen aller Perlen erzielt werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "ha": "Rubuta aikin python 'def max_energy(beads):' don warware matsalar mai zuwa:\n\n    Lissafi iyakar kuzari da za a iya saki ta hanyar haɗa beads a kan abin wuya.\n\n    Aikin yana ɗaukar jerin lambobi masu wakiltar beads na kuzari a kan abin wuya, inda\n    kowanne bead yana da ƙima a kai da kuma ƙima a ƙasa. Dole ne ƙimar kai na kowanne bead yayi daidai da ƙimar ƙasa\n    na bead na gaba a jerin. Abin wuya yana da zagaye, kuma haɗa beads biyu masu makwabtaka\n    yana sakin kuzari daidai da samfurin ƙimar kai na bead na farko, ƙimar da ta dace,\n    da kuma ƙimar ƙasa na bead na biyu.\n\n    Don samun iyakar sakin kuzari, aikin yana la'akari da dukkan yiwuwar jerin haɗa beads\n    kuma yana amfani da shirye-shiryen motsi don ƙididdige iyakar kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowanne lamba yana wakiltar ƙimar kai na bead da\n               ƙimar ƙasa na bead na baya. Ana ɗauka ƙimar ƙasa na bead na ƙarshe\n               yayi daidai da ƙimar kai na bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar iyakar kuzari da za a iya samu ta hanyar haɗa duk beads da kyau.\n\n    Misalai:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "hi": "एक पायथन फ़ंक्शन 'def max_energy(beads):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    हार के मोतियों को मिलाकर जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\n    फ़ंक्शन एक पूर्णांकों की सूची लेता है जो हार पर ऊर्जा मोतियों का प्रतिनिधित्व करती है, जहां\n    प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। अनुक्रम में अगले मोती के पूंछ मान से\n    प्रत्येक मोती का सिर मान मेल खाना चाहिए। हार वृत्ताकार है, और दो आसन्न\n    मोतियों को मिलाने पर ऊर्जा जारी होती है जो पहले मोती के सिर मान, मिलान\n    मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है\n    और प्राप्त की जा सकने वाली अधिकतम ऊर्जा की गणना करने के लिए गतिशील प्रोग्रामिंग का उपयोग करता है।\n\n    तर्क:\n        beads: पूर्णांकों की एक सूची जहां प्रत्येक पूर्णांक एक मोती के सिर मान का प्रतिनिधित्व करता है और\n               पिछले मोती का पूंछ मान। हार की वृत्ताकार प्रकृति के कारण अंतिम मोती का पूंछ मान\n               पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\n    लौटाता है:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "hu": "Írj egy python függvényt 'def max_energy(beads):' a következő probléma megoldására:\n\n    Számítsd ki a maximális energiát, amely felszabadítható a gyöngyök összefűzésével egy nyakláncon.\n\n    A függvény egy egész számokból álló listát vesz át, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő\n    gyöngy farokértékével a sorozatban. A nyaklánc körkörös, és két szomszédos gyöngy összefűzése olyan energiát\n    szabadít fel, amely egyenlő az első gyöngy fejértékének, az egyező értéknek és a második gyöngy farokértékének\n    szorzatával.\n\n    A maximális energia felszabadításának megtalálásához a függvény figyelembe veszi a gyöngyök összefűzésének\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Paraméterek:\n        beads: Egy egész számokból álló lista, ahol minden egész szám egy gyöngy fejértékét és az előző\n               gyöngy farokértékét képviseli. Az utolsó gyöngy farokértéke a nyaklánc körkörös jellege miatt\n               feltételezhetően megegyezik az első gyöngy fejértékével.\n\n    Visszatér:\n        Egy egész szám, amely a gyöngyök optimális összefűzésével elérhető maximális energiát képviseli.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48"
    },
    "instruction_bertscore": {
      "sq": "0.9826935335308112",
      "hy": "0.96606797200781",
      "bn": "0.9617197543365753",
      "bg": "0.9801024002102111",
      "zh": "0.9684604749473753",
      "fr": "0.9913351468881151",
      "de": "0.9898128436478637",
      "ha": "0.9667304043285614",
      "hi": "0.9648694362886455",
      "hu": "0.9522226399281543"
    },
    "level": "middle",
    "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()",
    "entry_point": "max_energy",
    "signature": "def max_energy(beads):",
    "docstring": {
      "en": "\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48\n    ",
      "sq": "\n    Llogarit energjinë maksimale që mund të lirohet duke bashkuar rruazat në një gjerdan.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një gjerdan, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së secilës rruazë duhet të përputhet\n    me vlerën e bishtit të rruazës së ardhshme në sekuencë. Gjerdani është rrethor, dhe bashkimi i dy rruazave\n    ngjitur liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës që përputhet,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit\n    të rruazave dhe përdor programimin dinamik për të llogaritur energjinë maksimale të mundshme.\n\n    Argumentet:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të gjerdanit.\n\n    Kthen:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\n    Shembuj:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "hy": "\n    Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտների միաձուլմամբ վզնոցի վրա:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա մարգարիտների էներգիան, որտեղ\n    յուրաքանչյուր մարգարիտ ունի գլխի և պոչի արժեք: Յուրաքանչյուր մարգարիտի գլխի արժեքը պետք է համընկնի հաջորդ մարգարիտի\n    պոչի արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից մարգարիտների միաձուլումը ազատում է էներգիա,\n    որը հավասար է առաջին մարգարիտի գլխի արժեքի, համընկնող արժեքի և երկրորդ մարգարիտի պոչի արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միաձուլման բոլոր հնարավոր\n    հերթականությունները և օգտագործում է դինամիկ ծրագրավորում առավելագույն էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլխի արժեքը և\n               նախորդ մարգարիտի պոչի արժեքը: Վերջին մարգարիտի պոչի արժեքը համարվում է, որ համընկնում է առաջին\n               մարգարիտի գլխի արժեքի հետ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարելի է ստանալ բոլոր մարգարիտները օպտիմալ\n        միաձուլմամբ:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "bn": "\n    নেকলেসের পুঁতি একত্রিত করে সর্বাধিক শক্তি কতটা মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা নেয় যা নেকলেসের পুঁতির শক্তিকে উপস্থাপন করে, যেখানে\n    প্রতিটি পুঁতির একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি পুঁতির মাথার মান অবশ্যই পরবর্তী পুঁতির লেজের\n    মানের সাথে মিলে যেতে হবে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন পুঁতি একত্রিত করলে প্রথম পুঁতির মাথার মান,\n    মিলিত মান এবং দ্বিতীয় পুঁতির লেজের মানের গুণফলের সমান শক্তি মুক্ত হয়।\n\n    সর্বাধিক শক্তি মুক্তি পেতে, ফাংশনটি পুঁতি একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং সর্বাধিক শক্তি প্রাপ্তির জন্য ডাইনামিক প্রোগ্রামিং ব্যবহার করে।\n\n    আর্গুমেন্টসমূহ:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি পুঁতির মাথার মান এবং\n               পূর্ববর্তী পুঁতির লেজের মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে\n               শেষ পুঁতির লেজের মান প্রথম পুঁতির মাথার মানের সাথে মিলে যায় বলে ধরা হয়।\n\n    রিটার্নস:\n        একটি পূর্ণসংখ্যা যা সমস্ত পুঁতি সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তিকে উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "bg": "\n    Изчислете максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада със стойността на опашката\n    на следващото мънисто в последователността. Огърлицата е кръгова и сливането на две съседни\n    мъниста освобождава енергия, равна на произведението на стойността на главата на първото мънисто, съвпадащата\n    стойност и стойността на опашката на второто мънисто.\n\n    За да се намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко число представлява стойността на главата на мънисто и\n               стойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се предполага,\n               че съвпада със стойността на главата на първото мънисто поради кръговия характер на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "zh": "\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子有一个头值和一个尾值。\n    每个珠子的头值必须与序列中下一个珠子的尾值匹配。项链是圆形的，合并两个相邻的珠子\n    释放的能量等于第一个珠子的头值、匹配值和第二个珠子的尾值的乘积。\n\n    为了找到最大能量释放，函数考虑合并珠子的所有可能顺序，并使用动态规划计算可获得的最大能量。\n\n    参数:\n        beads: 一个整数列表，其中每个整数表示一个珠子的头值和前一个珠子的尾值。\n               由于项链的圆形特性，最后一个珠子的尾值假定与第一个珠子的头值匹配。\n\n    返回:\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "fr": "\n    Calculer l'énergie maximale pouvant être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et une valeur de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la deuxième perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Args:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Returns:\n        Un entier représentant l'énergie maximale pouvant être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "de": "\n    Berechne die maximale Energie, die durch das Verschmelzen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten\n    Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Verschmelzen von zwei benachbarten\n    Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden Wert und dem\n    Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des\n    Verschmelzens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede Zahl den Kopfwert einer Perle und den Schwanzwert der\n               vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird aufgrund der kreisförmigen\n               Natur der Halskette als mit dem Kopfwert der ersten Perle übereinstimmend angenommen.\n\n    Rückgabe:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Verschmelzen aller Perlen\n        gewonnen werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "ha": "\n    Lissafi mafi ƙarancin kuzari da za a iya sakin ta hanyar haɗa beads akan abin wuya.\n\n    Aikin yana ɗaukar jerin lambobi waɗanda ke wakiltar beads na kuzari akan abin wuya, inda\n    kowanne bead yana da ƙima ta gaba da ƙima ta baya. Dole ne ƙimar gaba ta kowanne bead ta dace da ƙimar baya\n    ta bead na gaba a jerin. Abin wuya yana zagaye, kuma haɗa beads biyu masu makwabtaka yana sakin kuzari\n    daidai da samfurin ƙimar gaba ta bead na farko, ƙimar da ta dace, da ƙimar baya ta bead na biyu.\n\n    Don nemo mafi ƙarancin sakin kuzari, aikin yana la'akari da dukkan yiwuwar oda na haɗa beads\n    kuma yana amfani da shirye-shiryen motsi don lissafin mafi ƙarancin kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowanne lamba ke wakiltar ƙimar gaba ta bead da\n               ƙimar baya ta bead na baya. Ana ɗauka cewa ƙimar baya ta bead na ƙarshe ta dace\n               da ƙimar gaba ta bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar mafi ƙarancin kuzari da za a iya samu ta hanyar haɗa duk beads cikin hikima.\n\n    Misalai:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "hi": "\n    हार के मोतियों को मिलाकर अधिकतम ऊर्जा की गणना करें।\n\n    यह फ़ंक्शन हार पर ऊर्जा मोतियों का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची लेता है, \n    जहाँ प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में \n    अगले मोती के पूंछ मान से मेल खाना चाहिए। हार गोलाकार है, और दो आसन्न मोतियों को मिलाने से \n    ऊर्जा निकलती है जो पहले मोती के सिर मान, मिलान मान, और दूसरे मोती के पूंछ मान के गुणनफल के \n    बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार \n    करता है और अधिकतम ऊर्जा प्राप्त करने के लिए डायनामिक प्रोग्रामिंग का उपयोग करता है।\n\n    तर्क:\n        beads: पूर्णांकों की एक सूची जहाँ प्रत्येक पूर्णांक एक मोती के सिर मान और पिछले मोती के \n               पूंछ मान का प्रतिनिधित्व करता है। हार की गोलाकार प्रकृति के कारण अंतिम मोती का \n               पूंछ मान पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\n    वापसी:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा \n        का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48",
      "hu": "\n    Számítsa ki a maximális energiát, amely a gyöngyök egy nyakláncon történő összeolvasztásával szabadulhat fel.\n\n    A függvény egy egész számokból álló listát vesz át, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő\n    gyöngy farokértékével a sorozatban. A nyaklánc körkörös, és két szomszédos gyöngy összeolvasztása olyan energiát\n    szabadít fel, amely egyenlő az első gyöngy fejértékének, az egyező értéknek és a második gyöngy farokértékének\n    szorzatával.\n\n    A maximális energiafelszabadulás megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Paraméterek:\n        beads: Egy egész számokból álló lista, ahol minden egész szám egy gyöngy fejértékét és az előző\n               gyöngy farokértékét képviseli. Az utolsó gyöngy farokértékét feltételezzük, hogy megegyezik\n               az első gyöngy fejértékével a nyaklánc körkörös jellege miatt.\n\n    Visszatér:\n        Egy egész szám, amely a gyöngyök optimális összeolvasztásával elérhető maximális energiát képviseli.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        >>> max_energy([1, 2, 3, 4])\n        48"
    },
    "docstring_bertscore": {
      "sq": "0.9730971039318727",
      "hy": "0.9257748060629778",
      "bn": "0.9442299520256914",
      "bg": "0.9612027194547414",
      "zh": "0.9741603723615524",
      "fr": "0.9868756962035008",
      "de": "0.9857393317936002",
      "ha": "0.9263480533426445",
      "hi": "0.9550155817158857",
      "hu": "0.9592764020194652"
    }
  },
  {
    "task_id": "Python/20",
    "prompt": {
      "en": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "sq": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\n    përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të lënë jashtë.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablën `x`.\n    - Pjesa e variablës formatohet bazuar në shkallën e saj; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat janë të bashkuar pa hapësira shtesë, duke filluar me termi me shkallën më të lartë.\n\n    Args:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Returns:\n        str: Përfaqësimi si varg i polinomit.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "hy": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Վերածում է բազմապատկիչ գործակիցների ցուցակը ձևաչափված տողային ներկայացման:\n\n    Ֆունկցիան ընդունում է բազմապատկիչի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ: Այն վերադարձնում է տող,\n    որը ներկայացնում է բազմապատկիչը հետևյալ կանոններով:\n    - Գործակիցը զրո ունեցող անդամները բաց են թողնվում:\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առաջին անդամի համար\n      առանց առաջատար '+' նշանի:\n    - Գործակցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`:\n    - Փոփոխականի մասը ձևաչափվում է ըստ նրա աստիճանի; `x^աստիճան` աստիճան > 1-ի համար, `x` 1-ի համար,\n      և ոչինչ 0-ի համար (հաստատուն անդամ):\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից:\n\n    Արգումենտներ:\n        n (int): Բազմապատկիչի ամենաբարձր աստիճանը:\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից:\n\n    Վերադարձնում է:\n        str: Բազմապատկիչի տողային ներկայացումը:\n\n    Օրինակներ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "bn": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    একটি তালিকার পলিনোমিয়াল সহগগুলিকে একটি বিন্যাসিত স্ট্রিং উপস্থাপনায় রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং সহগগুলির একটি তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি পদ থেকে ধ্রুবক পদ পর্যন্ত ক্রমানুসারে সাজানো থাকে। এটি একটি স্ট্রিং ফেরত দেয় যা\n    নিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n    - সহগ শূন্য হলে সেই পদ বাদ দেওয়া হয়।\n    - প্রতিটি পদের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম পদের জন্য কোন নেতৃস্থানীয় '+' নেই।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং পদটিতে চলক `x` অন্তর্ভুক্ত থাকে।\n    - চলক অংশটি তার ডিগ্রির উপর ভিত্তি করে বিন্যাসিত হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক পদ) এর জন্য কিছুই নয়।\n    - পদগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি পদ দিয়ে শুরু হয়।\n\n    Args:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগগুলির একটি তালিকা, সর্বোচ্চ ডিগ্রি পদের সহগ দিয়ে শুরু।\n\n    Returns:\n        str: পলিনোমিয়ালের স্ট্রিং উপস্থাপনা।\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "bg": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`,\n    които са подредени от термина с най-висока степен до константния термин. Връща низ, който\n    представя полинома със следните правила:\n    - Термини с коефициент нула се пропускат.\n    - Знакът на всеки термин се определя (+ за положителен, - за отрицателен), без водещ '+' за първия термин.\n    - Абсолютната стойност на коефициента се показва, освен ако не е 1 и терминът включва променливата `x`.\n    - Променливата част се форматира въз основа на нейната степен; `x^степен` за степен > 1, `x` за степен 1, и\n      нищо за степен 0 (константен термин).\n    - Термините се съединяват без допълнителни интервали, започвайки с термина с най-висока степен.\n\n    Аргументи:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък от коефициенти, започващ с коефициента на термина с най-висока степен.\n\n    Връща:\n        str: Текстовото представяне на полинома.\n\n    Примери:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "zh": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    将多项式系数列表转换为格式化的字符串表示。\n\n    该函数接收多项式的最高次 `n` 和一个系数列表 `coeffs`，\n    系数按从最高次项到常数项的顺序排列。它返回一个表示多项式的字符串，规则如下：\n    - 系数为零的项被省略。\n    - 每项的符号由其正负决定（正数为 +，负数为 -），首项不带前导 '+'。\n    - 系数的绝对值被显示，除非系数为 1 且该项包含变量 `x`。\n    - 变量部分根据其次数进行格式化；次数大于 1 时为 `x^degree`，次数为 1 时为 `x`，\n      常数项（次数为 0）则不显示变量。\n    - 项之间没有额外空格，按从最高次项开始连接。\n\n    参数:\n        n (int): 多项式的最高次。\n        coeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n    返回:\n        str: 多项式的字符串表示。\n\n    示例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "fr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour un degré > 1, `x` pour un degré 1, et\n      rien pour un degré 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "de": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Wandelt eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation um.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die von dem Term mit dem höchsten Grad bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück,\n    die das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von Null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der Absolutwert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem Term höchsten Grades.\n\n    Args:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des Terms höchsten Grades.\n\n    Returns:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "ha": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Canza jerin lambobin polynomial zuwa tsari na rubutu da aka tsara.\n\n    Aikin yana karɓar mafi girman digiri `n` na polynomial da jerin lambobi `coeffs`,\n    waɗanda aka tsara daga mafi girman digiri zuwa kalmar akai-akai. Yana dawo da rubutu wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idodin:\n    - Ana cire kalmomin da ke da lamba na sifili.\n    - Ana ƙayyade alamar kowace kalma (+ don tabbatacce, - don korau), ba tare da jagorar '+' don kalma ta farko ba.\n    - Ana nuna ƙimar lamba sai dai idan yana da 1 kuma kalmar tana haɗa da canji `x`.\n    - Ana tsara sashin canji bisa ga digirinsa; `x^degree` don digiri > 1, `x` don digiri 1, da\n      babu komai don digiri 0 (kalmar akai-akai).\n    - Ana haɗa kalmomin ba tare da ƙarin sarari ba, farawa da kalmar mafi girman digiri.\n\n    Args:\n        n (int): Mafi girman digiri na polynomial.\n        coeffs (List[int]): Jerin lambobi, farawa da lambar mafi girman digiri.\n\n    Returns:\n        str: Wakilcin rubutu na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "hi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    बहुपद गुणांक की एक सूची को स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांकों की एक सूची `coeffs` लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - जिन पदों का गुणांक शून्य होता है, उन्हें छोड़ दिया जाता है।\n    - प्रत्येक पद का चिह्न निर्धारित होता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं होता।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 नहीं होता और पद में चर `x` शामिल होता है।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; `x^degree` डिग्री > 1 के लिए, `x` डिग्री 1 के लिए, और\n      कुछ नहीं डिग्री 0 (स्थिरांक पद) के लिए।\n    - पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होता है।\n\n    Args:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    Returns:\n        str: बहुपद का स्ट्रिंग प्रतिनिधित्व।\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "hu": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Egy polinomiális együtthatók listáját formázott karakterlánc-reprezentációvá alakítja.\n\n    A függvény megkapja a polinom legmagasabb fokszámát `n` és egy együtthatók listáját `coeffs`,\n    amelyek a legmagasabb fokszámú tagtól a konstans tagig vannak rendezve. Visszaad egy karakterláncot,\n    amely a következő szabályok szerint ábrázolja a polinomot:\n    - Azok a tagok, amelyek együtthatója nulla, kihagyásra kerülnek.\n    - Minden tag előjele meghatározásra kerül (+ a pozitív, - a negatív esetén), az első tag előtt nincs '+' jel.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1, és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján formázódik; `x^fokszám` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül csatlakoznak, a legmagasabb fokszámú taggal kezdve.\n\n    Args:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Egy lista az együtthatókról, a legmagasabb fokszámú tag együtthatójával kezdve.\n\n    Returns:\n        str: A polinom karakterlánc-reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9928848611209493",
      "hy": "0.9801776811246233",
      "bn": "0.9894737815874372",
      "bg": "0.9844601521397355",
      "zh": "0.9450220899852585",
      "fr": "0.9875188613772917",
      "de": "0.9770760677247635",
      "ha": "0.9699688740609542",
      "hi": "0.9869855388042131",
      "hu": "0.9678802756043724"
    },
    "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)",
    "instruction": {
      "en": "Write a python function 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' to solve the following problem:\n\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    ",
      "sq": "Shkruani një funksion python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\n    përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të injoruar.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablin `x`.\n    - Pjesa e variablit formatohet bazuar në shkallën e tij; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat bashkohen pa hapësira shtesë, duke filluar me termin me shkallën më të lartë.\n\n    Args:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Returns:\n        str: Përfaqësimi si varg i polinomit.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "hy": "Պայթոն ֆունկցիա 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Փոխակերպում է բազմանդամի գործակիցների ցուցակը ձևավորված տողային ներկայացման։\n\n    Ֆունկցիան ընդունում է բազմանդամի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ։ Այն վերադարձնում է\n    բազմանդամը ներկայացնող տող հետևյալ կանոններով.\n    - Զրոյական գործակից ունեցող անդամները բաց են թողնվում։\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առաջին անդամի համար առանց առաջատար '+'։\n    - Գործակցի բացարձակ արժեքը ցույց է տրվում, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`։\n    - Փոփոխականի մասը ձևավորվում է ըստ նրա աստիճանի; `x^degree` աստիճանի > 1 համար, `x` աստիճանի 1 համար, և\n      ոչինչ աստիճանի 0 (հաստատուն անդամ) համար։\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից։\n\n    Արգումենտներ:\n        n (int): Բազմանդամի ամենաբարձր աստիճանը։\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից։\n\n    Վերադարձնում է:\n        str: Բազմանդամի տողային ներկայացումը։\n\n    Օրինակներ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "bn": "একটি পাইথন ফাংশন 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি পলিনোমিয়াল সহগের তালিকাকে একটি ফরম্যাট করা স্ট্রিং প্রতিনিধিত্বে রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং একটি সহগের তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত সাজানো থাকে। এটি একটি স্ট্রিং ফেরত দেয় যা\n    নিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n    - শূন্য সহগের টার্মগুলি বাদ দেওয়া হয়।\n    - প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম টার্মের জন্য কোন নেতৃস্থানীয় '+' ছাড়া।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মটিতে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n    - ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে ফরম্যাট করা হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n    - টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\n    Args:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু।\n\n    Returns:\n        str: পলিনোমিয়ালের স্ট্রিং প্রতিনিধিত্ব।\n\n    উদাহরণ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "bg": "Напишете Python функция 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' за решаване на следния проблем:\n\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`,\n    които са подредени от терма с най-висока степен до константния терм. Тя връща низ, който\n    представя полинома със следните правила:\n    - Терми с коефициент нула се пропускат.\n    - Знакът на всеки терм се определя (+ за положителен, - за отрицателен), без водещ '+' за първия терм.\n    - Абсолютната стойност на коефициента се показва, освен ако не е 1 и термът включва променливата `x`.\n    - Променливата част се форматира въз основа на степента; `x^degree` за степен > 1, `x` за степен 1 и\n      нищо за степен 0 (константен терм).\n    - Терми се съединяват без допълнителни интервали, започвайки с терма с най-висока степен.\n\n    Args:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък с коефициенти, започвайки с коефициента на терма с най-висока степен.\n\n    Returns:\n        str: Текстовото представяне на полинома.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "zh": "编写一个 Python 函数 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' 来解决以下问题：\n\n    将多项式系数列表转换为格式化的字符串表示。\n\n    该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，\n    这些系数按从最高次项到常数项的顺序排列。它返回一个字符串，\n    该字符串表示多项式，遵循以下规则：\n    - 系数为零的项被省略。\n    - 每项的符号由其决定（正数为 +，负数为 -），第一项不带前导 '+'。\n    - 除非系数为 1 且该项包含变量 `x`，否则显示系数的绝对值。\n    - 变量部分根据其次数进行格式化；当次数大于 1 时为 `x^degree`，次数为 1 时为 `x`，\n      常数项（次数为 0）则不显示变量。\n    - 各项之间不加额外空格，从最高次项开始连接。\n\n    参数：\n        n (int): 多项式的最高次数。\n        coeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n    返回：\n        str: 多项式的字符串表示。\n\n    示例：\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "fr": "Écrivez une fonction python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' pour résoudre le problème suivant :\n\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour degré > 1, `x` pour degré 1, et\n      rien pour degré 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Exemples :\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "de": "Schreiben Sie eine Python-Funktion 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:', um das folgende Problem zu lösen:\n\n    Wandelt eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation um.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die vom höchsten Grad-Term bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück, die\n    das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der absolute Wert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem höchsten Grad-Term.\n\n    Args:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des höchsten Grad-Terms.\n\n    Returns:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Beispiele:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "ha": "Rubuta wani aikin python 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' don warware matsalar mai zuwa:\n\n    Yana canza jerin maki na polynomial zuwa wakilcin rubutu mai tsari.\n\n    Aikin yana karɓar mafi girman digiri `n` na polynomial da jerin maki `coeffs`,\n    waɗanda aka tsara daga mafi girman digiri zuwa kalmar akai-akai. Yana dawo da rubutu wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idodin:\n    - Ana cire kalmomi tare da maki na sifili.\n    - Ana tantance alamar kowace kalma (+ don tabbatacce, - don korau), ba tare da jagorar '+' don kalma ta farko ba.\n    - Ana nuna ƙimar coefficient sai dai idan yana da 1 kuma kalmar tana haɗa da canji `x`.\n    - Ana tsara ɓangaren canji bisa ga digirinsa; `x^degree` don digiri > 1, `x` don digiri 1, kuma\n      babu komai don digiri 0 (kalmar akai-akai).\n    - Ana haɗa kalmomi ba tare da ƙarin sarari ba, farawa da mafi girman digiri.\n\n    Args:\n        n (int): Mafi girman digiri na polynomial.\n        coeffs (List[int]): Jerin maki, farawa da maki na mafi girman digiri.\n\n    Returns:\n        str: Wakilcin rubutu na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "hi": "एक पायथन फ़ंक्शन 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    बहुपद गुणांक की सूची को स्वरूपित स्ट्रिंग अभ्यRepresentation में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - शून्य गुणांक वाले पदों को छोड़ दिया जाता है।\n    - प्रत्येक पद का चिह्न निर्धारित किया जाता है (धनात्मक के लिए +, ऋणात्मक के लिए -), पहले पद के लिए कोई अग्रणी '+' नहीं।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; डिग्री > 1 के लिए `x^degree`, डिग्री 1 के लिए `x`, और\n      डिग्री 0 (स्थिरांक पद) के लिए कुछ नहीं।\n    - पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होता है।\n\n    तर्क:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    लौटाता है:\n        str: बहुपद का स्ट्रिंग अभ्यRepresentation।\n\n    उदाहरण:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "hu": "Írj egy python függvényt 'def polynomial_to_string(n: int, coeffs: List[int]) -> str:' a következő probléma megoldására:\n\n    Egy polinomiális együtthatók listáját alakítja át formázott sztring reprezentációvá.\n\n    A függvény a polinom legmagasabb fokszámát `n` és az együtthatók `coeffs` listáját veszi át,\n    amelyek a legmagasabb fokú tagtól a konstans tagig vannak rendezve. Egy olyan sztringet ad vissza,\n    amely a következő szabályok szerint ábrázolja a polinomot:\n    - A nulla együtthatójú tagok elhagyásra kerülnek.\n    - Minden tag előjele meghatározásra kerül (+ a pozitív, - a negatív esetén), az első tagnál nincs vezető '+' jel.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1, és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján van formázva; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül vannak összekapcsolva, a legmagasabb fokú taggal kezdve.\n\n    Argumentumok:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Az együtthatók listája, a legmagasabb fokú tag együtthatójával kezdve.\n\n    Visszatér:\n        str: A polinom sztring reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'"
    },
    "instruction_bertscore": {
      "sq": "0.9912578796698925",
      "hy": "0.9794018308563011",
      "bn": "0.9815551828171003",
      "bg": "0.9761784570328669",
      "zh": "0.9324670608608052",
      "fr": "0.99006550149254",
      "de": "0.9860354896917232",
      "ha": "0.9707771010813852",
      "hi": "0.9765061971615745",
      "hu": "0.9641513874612044"
    },
    "level": "hard",
    "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()",
    "entry_point": "polynomial_to_string",
    "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:",
    "docstring": {
      "en": "\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    ",
      "sq": "\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatizuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg\n    që përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të lënë jashtë.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç kur është 1 dhe termi përfshin variablën `x`.\n    - Pjesa e variablës është e formatuar bazuar në shkallën e saj; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat janë të bashkuar pa hapësira shtesë, duke filluar me termi me shkallën më të lartë.\n\n    Argumentet:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Kthen:\n        str: Përfaqësimi si varg i polinomit.\n\n    Shembuj:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "hy": "\n    Պոլինոմի գործակիցների ցուցակը վերածում է ձևաչափված տողային ներկայացման։\n\n    Ֆունկցիան ընդունում է պոլինոմի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ։ Այն վերադարձնում է տող,\n    որը ներկայացնում է պոլինոմը հետևյալ կանոններով.\n    - Զրոյական գործակից ունեցող անդամները բաց են թողնվում։\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), \n      առանց առաջին անդամի համար առաջատար '+' նշանի։\n    - Գործակիցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`։\n    - Փոփոխականի մասը ձևաչափվում է ըստ իր աստիճանի՝ `x^աստիճան` աստիճանի համար > 1, `x` 1 աստիճանի համար,\n      և ոչինչ 0 աստիճանի համար (հաստատուն անդամ)։\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից։\n\n    Պարամետրեր:\n        n (int): Պոլինոմի ամենաբարձր աստիճանը։\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից։\n\n    Վերադարձնում է:\n        str: Պոլինոմի տողային ներկայացումը։\n\n    Օրինակներ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "bn": "\n    পলিনোমিয়াল সহগের একটি তালিকাকে একটি ফরম্যাটেড স্ট্রিং উপস্থাপনায় রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং সহগের একটি তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত সাজানো থাকে। এটি একটি স্ট্রিং রিটার্ন করে যা\n    নিম্নলিখিত নিয়ম অনুযায়ী পলিনোমিয়াল উপস্থাপন করে:\n    - সহগ শূন্য হলে টার্মগুলি বাদ দেওয়া হয়।\n    - প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম টার্মের জন্য কোনো নেতৃস্থানীয় '+' নেই।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n    - ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে ফরম্যাট করা হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n    - টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\n    প্যারামিটার:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু।\n\n    রিটার্নস:\n        str: পলিনোমিয়ালের স্ট্রিং উপস্থাপনা।\n\n    উদাহরণ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "bg": "\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`,\n    които са подредени от най-високата степен към константния член. Тя връща низ, който\n    представлява полинома със следните правила:\n    - Членове с коефициент нула се пропускат.\n    - Знакът на всеки член се определя (+ за положителен, - за отрицателен), без водещ '+' за първия член.\n    - Абсолютната стойност на коефициента се показва, освен ако не е 1 и членът включва променливата `x`.\n    - Променливата част се форматира според степента си; `x^степен` за степен > 1, `x` за степен 1 и\n      нищо за степен 0 (константен член).\n    - Членовете се съединяват без допълнителни интервали, започвайки с члена с най-висока степен.\n\n    Аргументи:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък от коефициенти, започвайки с коефициента на члена с най-висока степен.\n\n    Връща:\n        str: Текстовото представяне на полинома.\n\n    Примери:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "zh": "\n    将多项式系数列表转换为格式化的字符串表示形式。\n\n    该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，系数按从最高次项到常数项的顺序排列。\n    它返回一个表示多项式的字符串，遵循以下规则：\n    - 系数为零的项被省略。\n    - 每项的符号由其正负决定（正数为 +，负数为 -），首项不带前导 '+'。\n    - 系数的绝对值会显示，除非系数为 1 且该项包含变量 `x`。\n    - 变量部分根据其次数进行格式化；对于次数大于 1 的项为 `x^degree`，次数为 1 的项为 `x`，常数项则无变量。\n    - 项之间不加额外空格，从最高次项开始连接。\n\n    参数:\n        n (int): 多项式的最高次数。\n        coeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n    返回:\n        str: 多项式的字符串表示形式。\n\n    示例:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "fr": "\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour un degré > 1, `x` pour un degré 1, et\n      rien pour un degré 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "de": "\n    Wandelt eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation um.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die von dem Term mit dem höchsten Grad bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück,\n    die das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der absolute Wert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem Term höchsten Grades.\n\n    Argumente:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des Terms höchsten Grades.\n\n    Rückgabe:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Beispiele:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "ha": "\n    Canza jerin abubuwan haɗin polynomial zuwa wakilcin kirtani mai tsari.\n\n    Aikin yana ɗaukar mafi girman daraja `n` na polynomial da jerin abubuwan haɗin `coeffs`,\n    waɗanda aka tsara daga mafi girman daraja zuwa abin da ba shi da canji. Yana dawowa da kirtani wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idojin:\n    - Ana cire sharuɗɗan da ke da haɗin zero.\n    - Ana tantance alamar kowanne sharadi (+ don tabbatacce, - don korau), ba tare da '+' na farko ba don sharadi na farko.\n    - Ana nuna ƙimar haɗin ba tare da la'akari da ko yana da 1 ba kuma sharadi ya haɗa da canji `x`.\n    - Ana tsara ɓangaren canji bisa ga darajarsa; `x^degree` don daraja > 1, `x` don daraja 1, da\n      babu komai don daraja 0 (abin da ba shi da canji).\n    - Ana haɗa sharuɗɗan ba tare da ƙarin sarari ba, farawa da sharadi mafi girman daraja.\n\n    Args:\n        n (int): Mafi girman daraja na polynomial.\n        coeffs (List[int]): Jerin abubuwan haɗin, farawa da haɗin sharadi mafi girman daraja.\n\n    Returns:\n        str: Wakilcin kirtani na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "hi": "\n    बहुपद गुणांक की सूची को एक स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - जिन पदों का गुणांक शून्य होता है, उन्हें छोड़ दिया जाता है।\n    - प्रत्येक पद का चिह्न निर्धारित किया जाता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; डिग्री > 1 के लिए `x^degree`, डिग्री 1 के लिए `x`, और\n      डिग्री 0 (स्थिरांक पद) के लिए कुछ नहीं।\n    - पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होते हुए।\n\n    तर्क:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    लौटाता है:\n        str: बहुपद का स्ट्रिंग प्रतिनिधित्व।\n\n    उदाहरण:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'",
      "hu": "\n    Egy polinomiális együtthatók listáját formázott karakterlánc-reprezentációvá alakítja.\n\n    A függvény a polinom legmagasabb fokszámát `n` és egy együtthatók listáját `coeffs` veszi be,\n    amelyek a legmagasabb fokszámú tagtól a konstans tagig vannak rendezve. Egy olyan karakterláncot ad vissza,\n    amely a polinomot a következő szabályok szerint ábrázolja:\n    - Azok a tagok, amelyek együtthatója nulla, kimaradnak.\n    - Minden tag előjele meghatározott (+ a pozitív, - a negatív esetén), az első tag előtt nincs '+' jel.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1 és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján van formázva; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül vannak összekapcsolva, a legmagasabb fokszámú taggal kezdve.\n\n    Paraméterek:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Egy együtthatók listája, a legmagasabb fokszámú tag együtthatójával kezdve.\n\n    Visszatér:\n        str: A polinom karakterlánc-reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'"
    },
    "docstring_bertscore": {
      "sq": "0.9829916777327445",
      "hy": "0.9676441040813218",
      "bn": "0.9718894312151806",
      "bg": "0.9816421829239935",
      "zh": "0.9121942482812415",
      "fr": "0.975945662226294",
      "de": "0.9713980196525003",
      "ha": "0.9541300874772323",
      "hi": "0.9743794616718339",
      "hu": "0.954612759303147"
    }
  },
  {
    "task_id": "Python/21",
    "prompt": {
      "en": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\n    ata pastaj renditen sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutëve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistë.\n    \n    Argumentet:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve që do të rekrutohen.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Kthen:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Shembuj:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Ընտրում է և որոշում հարցազրույցի գնահատականների շեմը և դիմորդների ցանկը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n    \n    Ֆունկցիան դասավորում է դիմորդներին ըստ նրանց թեստային գնահատականների նվազման կարգով։ Եթե մի քանի դիմորդներ ունեն նույն գնահատականը,\n    ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի գնահատականների շեմը հաշվարկվում է ըստ նախատեսված\n    հավաքագրման 150%-ի, կլորացված ներքև։ Բոլոր դիմորդները, որոնց գնահատականները հավասար են կամ բարձր են շեմից, համարվում են\n    որակավորված հարցազրույցի համար։\n    \n    Պարամետրեր:\n    - n (int): Դիմորդների ընդհանուր քանակը։\n    - m (int): Նախատեսված հավաքագրվող կամավորների քանակը։\n    - applicants (List[Tuple[int, int]]): Ցանկ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային գնահատականը։\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի գնահատականների շեմը և տուփերի ցանկ, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային գնահատականը։\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    সাক্ষাৎকারের জন্য যোগ্য আবেদনকারীদের তালিকা এবং সাক্ষাৎকারের স্কোরের কাটঅফ নির্ধারণ করে নির্বাচন করে।\n\n    ফাংশনটি আবেদনকারীদের তাদের টেস্ট স্কোর অনুযায়ী অবতরণ ক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে,\n    তাহলে তাদের রেজিস্ট্রেশন নম্বর অনুযায়ী আরোহী ক্রমে সাজানো হয়। পরিকল্পিত নিয়োগের 150% ভিত্তিতে সাক্ষাৎকারের স্কোরের কাটঅফ\n    গণনা করা হয়, যা নিচের দিকে পূর্ণসংখ্যায় পরিণত হয়। সকল আবেদনকারী যাদের স্কোর কাটঅফের সমান বা তার বেশি, তারা সাক্ষাৎকারের জন্য\n    যোগ্য বলে বিবেচিত হয়।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): মোট আবেদনকারীর সংখ্যা।\n    - m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যারা নিয়োগ করা হবে।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে আবেদনকারীর রেজিস্ট্রেশন নম্বর এবং টেস্ট স্কোর থাকে।\n\n    রিটার্নস:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টুপল যা সাক্ষাৎকারের স্কোরের কাটঅফ এবং যোগ্য আবেদনকারীদের তালিকা সহ প্রতিটি টুপল\n      অন্তর্ভুক্ত করে, যেখানে প্রতিটি টুপলে আবেদনকারীর রেজিস্ট্রেশন নম্বর এবং টেস্ট স্কোর থাকে।\n\n    উদাহরণ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Избира и определя прага за оценка на интервюто и списъка на кандидатите, които се квалифицират за процеса на интервю.\n    \n    Функцията сортира кандидатите по техните тестови оценки в низходящ ред. Ако няколко кандидати имат една и съща оценка,\n    те се сортират по регистрационния си номер във възходящ ред. Прагът за оценка на интервюто се изчислява на базата на 150%\n    от планирания брой на наетите, закръглен надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\n    квалифицирани за интервюто.\n    \n    Аргументи:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой на доброволците, които ще бъдат наети.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Връща:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага за оценка на интервюто и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на квалифицираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    选择并确定面试分数线以及符合面试流程的申请人名单。\n    \n    该函数根据申请人的测试成绩按降序排序。如果多个申请人的成绩相同，则按注册号升序排序。\n    面试分数线是基于计划招募人数的150%计算的，向下取整。所有成绩等于或高于分数线的申请人被视为符合面试资格。\n    \n    参数:\n    - n (int): 申请人的总数。\n    - m (int): 计划招募的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试成绩。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和符合资格的申请人名单的元组，每个元组包括申请人的注册号和测试成绩。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'entier inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int): Le nombre total de candidats.\n    - m (int): Le nombre prévu de volontaires à recruter.\n    - applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Wählt aus und bestimmt die Interview-Punktzahlgrenze sowie die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie anschließend nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahlgrenze wird basierend auf 150%\n    der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, gelten als\n    qualifiziert für das Interview.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabe:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahlgrenze und eine Liste von Tupeln enthält, von denen jedes die\n      Registrierungsnummer und die Testergebnisse qualifizierter Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zaɓi kuma ƙayyade ƙimar ƙimar hira da jerin masu nema waɗanda suka cancanci tsarin hira.\n    \n    Aikin yana tsara masu nema bisa ga maki gwajinsu a cikin tsari mai saukowa. Idan masu nema da yawa suna da maki iri ɗaya,\n    to ana tsara su ta hanyar lambar rajistarsu a cikin tsari mai hawa. Ana ƙididdige ƙimar ƙimar hira bisa ga 150%\n    na adadin masu son da aka shirya, an zagaye ƙasa. Duk masu nema da maki daidai ko mafi girma fiye da ƙimar sun cancanci\n    a ɗauke su a matsayin waɗanda suka cancanci hirar.\n    \n    Args:\n    - n (int): Jimillar adadin masu nema.\n    - m (int): Adadin masu son da aka shirya za a ɗauka.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne ya ƙunshi lambar rajista da maki gwajin mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple mai ɗauke da ƙimar ƙimar hira da jerin tuples, kowanne yana ɗauke da\n      lambar rajista da maki gwajin masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन और निर्धारण करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n    \n    यह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के समान स्कोर हैं,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ की गणना नियोजित\n    भर्ती संख्या के 150% के आधार पर की जाती है, जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के\n    बराबर या उससे अधिक हैं, साक्षात्कार के लिए योग्य माने जाते हैं।\n    \n    तर्क:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): नियोजित स्वयंसेवकों की संख्या जिन्हें भर्ती किया जाना है।\n    - applicants (List[Tuple[int, int]]): एक सूची जिसमें प्रत्येक टपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n    \n    लौटाता है:\n    - Tuple[int, List[Tuple[int, int]]]: एक टपल जिसमें साक्षात्कार स्कोर कटऑफ और टपल की एक सूची शामिल होती है, जिनमें से प्रत्येक में\n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n    \n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Kiválasztja és meghatározza az interjú pontszám küszöböt és az interjú folyamatra kvalifikált jelentkezők listáját.\n    \n    A függvény csökkenő sorrendbe rendezi a jelentkezőket a tesztpontszámaik alapján. Ha több jelentkezőnek azonos a pontszáma,\n    akkor a regisztrációs számuk alapján növekvő sorrendbe kerülnek. Az interjú pontszám küszöböt a tervezett toborzási létszám\n    150%-a alapján számítják ki, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöböt,\n    kvalifikáltnak tekintendő az interjúra.\n    \n    Paraméterek:\n    - n (int): A jelentkezők teljes száma.\n    - m (int): A tervezett önkéntesek száma, akiket toborozni kívánnak.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy tuple, amely tartalmazza a jelentkező\n      regisztrációs számát és tesztpontszámát.\n    \n    Visszatérési érték:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöböt és egy listát,\n      amelyben minden elem egy tuple, amely tartalmazza a kvalifikált jelentkezők regisztrációs számát és tesztpontszámát.\n    \n    Példák:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9866879904934228",
      "hy": "0.9622669810363265",
      "bn": "0.9477049905418967",
      "bg": "0.9821500808082998",
      "zh": "0.9541525327102892",
      "fr": "0.9683138857261715",
      "de": "0.9805157500331447",
      "ha": "0.9638174897906848",
      "hi": "0.9717488009054078",
      "hu": "0.9481940185400046"
    },
    "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants",
    "instruction": {
      "en": "Write a python function 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' to solve the following problem:\n\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ",
      "sq": "Shkruani një funksion python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' për të zgjidhur problemin e mëposhtëm:\n\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\n    ata renditen më pas sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutëve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistë.\n    \n    Argumentet:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve që do të rekrutohen.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Kthen:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secili prej të cilëve përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Shembuj:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "hy": "Պայթոն ֆունկցիա 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Ընտրում է և որոշում հարցազրույցի միավորների շեմը և դիմորդների ցուցակը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար:\n    \n    Ֆունկցիան դասավորում է դիմորդներին ըստ նրանց թեստային միավորների նվազման կարգով: Եթե մի քանի դիմորդներ ունեն նույն միավորը,\n    ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով: Հարցազրույցի միավորների շեմն հաշվարկվում է ըստ նախատեսված\n    հավաքագրման 150%-ի, կլորացված ներքև: Բոլոր դիմորդները, որոնց միավորները հավասար են կամ բարձր են շեմից, համարվում են\n    որակավորված հարցազրույցի համար:\n    \n    Արգումենտներ:\n    - n (int): Դիմորդների ընդհանուր քանակը:\n    - m (int): Նախատեսված հավաքագրվող կամավորների քանակը:\n    - applicants (List[Tuple[int, int]]): Ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը:\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցուցակը, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային միավորը:\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "bn": "একটি পাইথন ফাংশন 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    সাক্ষাৎকার স্কোরের কাটঅফ এবং সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য আবেদনকারীদের তালিকা নির্বাচন এবং নির্ধারণ করে।\n    \n    ফাংশনটি আবেদনকারীদের তাদের পরীক্ষার স্কোরের উপর ভিত্তি করে অবতরণ ক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে,\n    তবে তাদের নিবন্ধন নম্বরের উপর ভিত্তি করে আরোহী ক্রমে সাজানো হয়। পরিকল্পিত নিয়োগের 150% এর উপর ভিত্তি করে সাক্ষাৎকার স্কোরের কাটঅফ গণনা করা হয়,\n    নিচের দিকে পূর্ণসংখ্যায় পরিণত করে। সমস্ত আবেদনকারী যারা কাটঅফের সমান বা তার চেয়ে বেশি স্কোর পায় তাদের সাক্ষাৎকারের জন্য যোগ্য বলে বিবেচনা করা হয়।\n    \n    আর্গুমেন্টস:\n    - n (int): মোট আবেদনকারীর সংখ্যা।\n    - m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যারা নিয়োগ করা হবে।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টিউপলে একটি আবেদনকারীর নিবন্ধন নম্বর এবং পরীক্ষার স্কোর থাকে।\n    \n    রিটার্নস:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টিউপল যা সাক্ষাৎকার স্কোরের কাটঅফ এবং টিউপলের একটি তালিকা ধারণ করে, যার প্রতিটিতে\n      যোগ্য আবেদনকারীদের নিবন্ধন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n    \n    উদাহরণ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "bg": "Напишете Python функция 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' за решаване на следния проблем:\n\n    Избира и определя прага за оценка на интервюто и списъка на кандидатите, които се класират за интервю процеса.\n    \n    Функцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат една и съща оценка,\n    те се сортират по регистрационен номер във възходящ ред. Прагът за оценка на интервюто се изчислява въз основа на 150%\n    от планирания брой на наетите, закръглено надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат\n    за квалифицирани за интервюто.\n    \n    Аргументи:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой доброволци за наемане.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Връща:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага за оценка на интервюто и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на квалифицираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "zh": "编写一个Python函数 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' 来解决以下问题：\n\n    选择并确定面试分数的截止线以及符合面试流程的申请者名单。\n    \n    函数根据申请者的测试分数按降序排序。如果多个申请者有相同的分数，\n    则按其注册号按升序排序。面试分数的截止线是基于计划招聘人数的150%计算的，并向下取整。\n    所有分数等于或高于截止线的申请者被认为符合面试资格。\n    \n    参数:\n    - n (int): 申请者的总人数。\n    - m (int): 计划招聘的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请者的注册号和测试分数。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数截止线和符合资格的申请者名单的元组，\n      每个元组包含申请者的注册号和测试分数。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "fr": "Écrire une fonction python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' pour résoudre le problème suivant :\n\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'entier inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int) : Le nombre total de candidats.\n    - m (int) : Le nombre prévu de volontaires à recruter.\n    - applicants (List[Tuple[int, int]]) : Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]] : Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "de": "Schreiben Sie eine Python-Funktion 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' um das folgende Problem zu lösen:\n\n    Wählt aus und bestimmt die Interview-Punktzahl-Grenze und die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie dann nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahl-Grenze wird basierend auf 150%\n    der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, gelten als\n    für das Interview qualifiziert.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabewerte:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahl-Grenze und eine Liste von Tupeln enthält, von denen jedes die\n      Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "ha": "Rubuta wani aikin python 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' don warware matsalar mai zuwa:\n\n    Zabi da tantance iyakar maki na hira da jerin masu nema da suka cancanci shiga tsarin hirar.\n    \n    Aikin yana tsara masu nema bisa ga maki na gwaji daga mafi girma zuwa mafi ƙanƙanta. Idan masu nema da yawa suna da maki ɗaya,\n    to ana tsara su bisa ga lambar rajista daga mafi ƙanƙanta zuwa mafi girma. Ana lissafin iyakar maki na hira bisa ga 150%\n    na adadin masu daukar aiki da aka tsara, an zagaye ƙasa. Duk masu nema da suka samu maki daidai ko sama da iyakar ana ɗauka\n    sun cancanci shiga hirar.\n    \n    Args:\n    - n (int): Jimillar adadin masu nema.\n    - m (int): Adadin masu sa kai da aka shirya dauka.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi lambar rajista da maki na gwajin mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple wanda ya ƙunshi iyakar maki na hira da jerin tuples, kowanne ya haɗa da\n      lambar rajista da maki na gwajin masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "hi": "एक पायथन फ़ंक्शन 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    साक्षात्कार प्रक्रिया के लिए अर्हता प्राप्त करने वाले आवेदकों की सूची और साक्षात्कार स्कोर कटऑफ का चयन और निर्धारण करता है।\n    \n    फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के समान स्कोर हैं,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के 150% के आधार पर गणना की जाती है,\n    जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं, उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n    \n    तर्क:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): नियोजित स्वयंसेवकों की संख्या जिन्हें भर्ती किया जाना है।\n    - applicants (List[Tuple[int, int]]): एक सूची जिसमें प्रत्येक टपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर होता है।\n    \n    लौटाता है:\n    - Tuple[int, List[Tuple[int, int]]]: एक टपल जिसमें साक्षात्कार स्कोर कटऑफ और टपल की एक सूची होती है, जिसमें प्रत्येक में\n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n    \n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "hu": "Írj egy python függvényt 'def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:' a következő probléma megoldására:\n\n    Kiválasztja és meghatározza az interjú pontszám küszöbértékét és azon jelentkezők listáját, akik megfelelnek az interjú folyamatra.\n    \n    A függvény a jelentkezőket a tesztpontszámuk alapján csökkenő sorrendbe rendezi. Ha több jelentkezőnek azonos a pontszáma,\n    akkor a regisztrációs számuk alapján növekvő sorrendbe rendeződnek. Az interjú pontszám küszöbértéke a tervezett toborzási létszám 150%-a\n    alapján kerül kiszámításra, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöbértéket,\n    alkalmasnak minősül az interjúra.\n    \n    Paraméterek:\n    - n (int): A jelentkezők összesített száma.\n    - m (int): A tervezett önkéntesek száma, akiket toborozni kívánnak.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden tuple egy jelentkező regisztrációs számát és tesztpontszámát tartalmazza.\n    \n    Visszatérési érték:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöbértékét és egy listát a tuple-ökről, amelyek\n      mindegyike tartalmazza a megfelelő jelentkezők regisztrációs számát és tesztpontszámát.\n    \n    Példák:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])"
    },
    "instruction_bertscore": {
      "sq": "0.9865620588318467",
      "hy": "0.9644940248684896",
      "bn": "0.962224672765166",
      "bg": "0.9662620338900811",
      "zh": "0.9627234336519446",
      "fr": "0.9699359014177025",
      "de": "0.976361594244181",
      "ha": "0.9539801215395509",
      "hi": "0.9670736376269897",
      "hu": "0.9605422734378005"
    },
    "level": "middle",
    "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()",
    "entry_point": "select_volunteers",
    "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:",
    "docstring": {
      "en": "\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ",
      "sq": "\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\n    ata renditen më pas sipas numrit të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutimeve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistën.\n    \n    Args:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve për t'u rekrutuar.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "hy": "\n    Ընտրում է և որոշում հարցազրույցի միավորների շեմը և դիմորդների ցանկը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n    \n    Ֆունկցիան դասավորում է դիմորդներին իրենց թեստային միավորների հիման վրա նվազման կարգով։ Եթե մի քանի դիմորդ ունեն նույն միավորը,\n    ապա նրանք դասավորվում են իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի միավորների շեմը հաշվարկվում է ըստ նախատեսված\n    հավաքագրվելիք կամավորների 150%-ի, կլորացված դեպի ներքև։ Բոլոր դիմորդները, որոնց միավորները հավասար են կամ բարձր են շեմից,\n    համարվում են որակավորված հարցազրույցի համար։\n    \n    Արգումենտներ:\n    - n (int): Դիմորդների ընդհանուր քանակը։\n    - m (int): Նախատեսված հավաքագրվելիք կամավորների քանակը։\n    - applicants (List[Tuple[int, int]]): Ցանկ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը։\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցանկ, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային միավորը։\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "bn": "\n    সাক্ষাৎকারের স্কোর কাটঅফ এবং সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য আবেদনকারীদের তালিকা নির্বাচন এবং নির্ধারণ করে।\n    \n    ফাংশনটি আবেদনকারীদের তাদের পরীক্ষার স্কোরের উপর ভিত্তি করে অবতরণক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে,\n    তবে তাদের রেজিস্ট্রেশন নম্বর অনুযায়ী আরোহীক্রমে সাজানো হয়। সাক্ষাৎকারের স্কোর কাটঅফ পরিকল্পিত নিয়োগের 150% এর ভিত্তিতে গণনা করা হয়,\n    যা নিচের দিকে পূর্ণসংখ্যায় পরিণত হয়। সমস্ত আবেদনকারী যাদের স্কোর কাটঅফের সমান বা তার চেয়ে বেশি, তাদের সাক্ষাৎকারের জন্য যোগ্য বলে বিবেচনা করা হয়।\n    \n    আর্গুমেন্টসমূহ:\n    - n (int): মোট আবেদনকারীর সংখ্যা।\n    - m (int): পরিকল্পিত নিয়োগের স্বেচ্ছাসেবকের সংখ্যা।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে একটি আবেদনকারীর রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর থাকে।\n    \n    রিটার্নস:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টিউপল যা সাক্ষাৎকারের স্কোর কাটঅফ এবং একটি তালিকা ধারণ করে, যেখানে প্রতিটি টুপলে\n      যোগ্য আবেদনকারীদের রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n    \n    উদাহরণ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "bg": "\n    Избира и определя прага на оценките за интервю и списъка с кандидати, които се квалифицират за процеса на интервюиране.\n    \n    Функцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат еднаква оценка,\n    те се сортират по регистрационния си номер във възходящ ред. Прагът на оценките за интервю се изчислява въз основа на 150%\n    от планирания брой наемания, закръглен надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\n    квалифицирани за интервюто.\n    \n    Аргументи:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой доброволци, които ще бъдат наети.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Връща:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага на оценките за интервю и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на квалифицираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "zh": "\n    选择并确定面试分数线以及符合面试流程的申请人名单。\n    \n    该函数根据申请人的测试分数按降序排序。如果多个申请人的分数相同，则按注册号升序排序。\n    面试分数线是基于计划招聘人数的150%计算的，并向下取整。所有分数等于或高于分数线的申请人被认为符合面试资格。\n    \n    参数:\n    - n (int): 申请人的总数。\n    - m (int): 计划招募的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试分数。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和元组列表的元组，每个元组包括符合资格的申请人的注册号和测试分数。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    ",
      "fr": "\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'entier inférieur. Tous les candidats ayant des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int): Le nombre total de candidats.\n    - m (int): Le nombre prévu de bénévoles à recruter.\n    - applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "de": "\n    Wählt aus und bestimmt die Punkteschwelle für das Vorstellungsgespräch sowie die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie anschließend nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Punkteschwelle für das Vorstellungsgespräch wird basierend auf 150%\n    der geplanten Anzahl der Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Schwelle sind, gelten als\n    qualifiziert für das Vorstellungsgespräch.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabewerte:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Punkteschwelle für das Vorstellungsgespräch und eine Liste von Tupeln enthält, von denen jedes\n      die Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "ha": "\n    Zaɓi kuma kayyade iyakar maki na hira da jerin masu nema waɗanda suka cancanci shiga tsarin hira.\n    \n    Aikin yana tsara masu nema bisa ga maki na gwaji a cikin tsari mai saukarwa. Idan masu nema da yawa suna da maki iri ɗaya,\n    to za a tsara su bisa ga lambar rajista a cikin tsari mai hawa. Ana lissafin iyakar maki na hira bisa ga kashi 150%\n    na adadin masu daukar aiki da aka shirya, an zagaye ƙasa. Duk masu nema da suka samu maki daidai ko sama da iyakar ana ɗaukar su\n    sun cancanci shiga hirar.\n    \n    Args:\n    - n (int): Jimlar adadin masu nema.\n    - m (int): Adadin masu sa kai da aka shirya dauka.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple yana dauke da lambar rajista da maki na gwajin mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple wanda ke dauke da iyakar maki na hira da jerin tuples, kowanne yana dauke da\n      lambar rajista da maki na gwajin masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "hi": "\n    साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन और निर्धारण करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n    \n    यह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के स्कोर समान हैं,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के 150%\n    के आधार पर गणना की जाती है, जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं, \n    उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n    \n    आर्ग्स:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): भर्ती किए जाने वाले स्वयंसेवकों की नियोजित संख्या।\n    - applicants (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर शामिल है।\n    \n    रिटर्न:\n    - Tuple[int, List[Tuple[int, int]]]: एक ट्यूपल जिसमें साक्षात्कार स्कोर कटऑफ और ट्यूपल की एक सूची शामिल है, जिसमें प्रत्येक में \n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल है।\n    \n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])",
      "hu": "\n    Kiválasztja és meghatározza az interjú pontszám küszöböt és az interjú folyamatra jogosult jelentkezők listáját.\n    \n    A függvény a jelentkezőket a tesztpontszámaik alapján csökkenő sorrendbe rendezi. Ha több jelentkezőnek azonos a pontszáma,\n    akkor őket a regisztrációs számuk alapján növekvő sorrendbe rendezi. Az interjú pontszám küszöb a tervezett toborzási létszám\n    150%-a alapján kerül kiszámításra, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöböt,\n    interjúra jogosultnak tekintendő.\n    \n    Paraméterek:\n    - n (int): A jelentkezők teljes száma.\n    - m (int): A tervezett toborzandó önkéntesek száma.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy tuple, amely tartalmazza a jelentkező regisztrációs számát és tesztpontszámát.\n    \n    Visszatérési érték:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöböt és egy listát, amelyben minden elem egy tuple,\n      amely tartalmazza a jogosult jelentkezők regisztrációs számát és tesztpontszámát.\n    \n    Példák:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])"
    },
    "docstring_bertscore": {
      "sq": "0.982037457382253",
      "hy": "0.9604493144194761",
      "bn": "0.9451267681960639",
      "bg": "0.9583917023023357",
      "zh": "0.9657440058563421",
      "fr": "0.9591689429833253",
      "de": "0.9600699303916995",
      "ha": "0.9591609977680838",
      "hi": "0.9695328803745826",
      "hu": "0.9346414676419942"
    }
  },
  {
    "task_id": "Python/22",
    "prompt": {
      "en": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "sq": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekodon një mesazh të koduar duke përdorur një shifër të nxjerrë nga një çift i njohur i koduar-origjinal.\n    \n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Dështoi\".\n    \n    Argumentet:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n    \n    Kthen:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Dështoi\" nëse dekodimi nuk është i mundur.\n    \n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "hy": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան ստեղծում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում\n    համապատասխանության կառուցման ընթացքում, կամ եթե բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ապա\n    ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Փաստարկներ:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է կոդավորված տողին համապատասխանող բնօրինակ տեղեկատվությունը:\n    message (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջողված է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "bn": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n    \n    ফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তা ডিকোড করে। ম্যাপিং নির্মাণের সময় যদি কোনো বিরোধ পাওয়া যায়, অথবা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" ফেরত দেয়।\n    \n    আর্গস:\n    encoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n    \n    রিটার্নস:\n    str: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোড করা সম্ভব না হলে \"Failed\"।\n    \n    উদাহরণ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "bg": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Декодира криптирано съобщение, използвайки шифър, получен от известна кодирана-оригинална двойка.\n    \n    Функцията създава съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие, за да декодира дадено криптирано съобщение. Ако се открие противоречие по време на\n    създаването на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n    \n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n    \n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n    \n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "zh": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    使用已知的编码-原始对派生的密码解码加密消息。\n    \n    该函数构建从编码字母到原始字母的映射，并使用此映射解码给定的加密消息。\n    如果在映射构建过程中发现矛盾，或者映射中没有表示所有字母，函数返回 \"Failed\"。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果解码成功则返回解码后的消息，如果解码不可能则返回 \"Failed\"。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "fr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Décode un message chiffré en utilisant un chiffrement dérivé d'une paire encodée-originale connue.\n    \n    La fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction\n    de la correspondance, ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction\n    retourne \"Failed\".\n    \n    Arguments:\n    encoded (str): Une chaîne représentant l'information encodée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Retourne:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Exemples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "de": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Entschlüsselt eine verschlüsselte Nachricht mithilfe eines aus einem bekannten Paar von kodierten und originalen Zeichenfolgen abgeleiteten Chiffre.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese\n    Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Konstruktion der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Eine Zeichenfolge, die die kodierten Informationen darstellt.\n    original (str): Eine Zeichenfolge, die die ursprünglichen Informationen darstellt, die der kodierten Zeichenfolge entsprechen.\n    message (str): Eine Zeichenfolge, die die zu entschlüsselnde verschlüsselte Nachricht darstellt.\n    \n    Rückgabe:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "ha": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Fassar da saƙon da aka ɓoye ta amfani da wata hanyar ɓoye da aka samo daga sanannen encoded-original ɗin ma'aurata.\n    \n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa haruffan asali kuma yana amfani da wannan\n    taswira don fassar da wani saƙon da aka ɓoye. Idan an sami sabani yayin gina taswira,\n    ko kuma ba duk haruffa ne aka wakilta a cikin taswira ba, aikin yana dawowa da \"Failed\".\n    \n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanan da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar saƙon da aka ɓoye da za a fassara.\n    \n    Returns:\n    str: Saƙon da aka fassara idan ya yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "hi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    ज्ञात एन्कोडेड-ओरिजिनल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n    \n    यह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग \n    एक दिए गए एन्क्रिप्टेड संदेश को डिकोड करने के लिए करता है। यदि मैपिंग निर्माण के दौरान कोई विरोधाभास \n    पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं, तो फ़ंक्शन \"Failed\" लौटाता है।\n    \n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    \n    लौटाता है:\n    str: यदि सफल होता है तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n    \n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "hu": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel használatával.\n    \n    A függvény létrehoz egy leképezést a kódolt betűkből az eredeti betűkre, és ezt a leképezést használja\n    egy adott titkosított üzenet dekódolására. Ha ellentmondás található a leképezés létrehozása során, vagy\n    nem minden betű van képviselve a leképezésben, a függvény \"Failed\" értéket ad vissza.\n    \n    Paraméterek:\n    encoded (str): Egy string, amely a kódolt információt képviseli.\n    original (str): Egy string, amely az eredeti információt képviseli, amely megfelel a kódolt stringnek.\n    message (str): Egy string, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Visszatér:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9896986311787687",
      "hy": "0.9788921452985655",
      "bn": "0.972563781358794",
      "bg": "0.9907031050156621",
      "zh": "0.9767930194317889",
      "fr": "0.9868915866339836",
      "de": "0.9795754338093255",
      "ha": "0.9587563876819158",
      "hi": "0.9907237625752897",
      "hu": "0.9850953720982851"
    },
    "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message",
    "instruction": {
      "en": "Write a python function 'def decode(encoded: str, original: str, message: str) -> str:' to solve the following problem:\n\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    ",
      "sq": "Shkruani një funksion python 'def decode(encoded: str, original: str, message: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Dekodon një mesazh të koduar duke përdorur një shifër të nxjerrë nga një çift i njohur i koduar-original.\n\n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Failed\".\n\n    Args:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n\n    Returns:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Failed\" nëse dekodimi nuk është i mundur.\n\n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "hy": "Պայթոն ֆունկցիա 'def decode(encoded: str, original: str, message: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան կառուցում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում\n    համապատասխանության կառուցման ընթացքում, կամ բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Արգումենտներ:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է կոդավորված տողին համապատասխանող բնօրինակ տեղեկատվությունը:\n    message (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n",
      "bn": "একটি পাইথন ফাংশন 'def decode(encoded: str, original: str, message: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n    \n    ফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং \n    ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তা ডিকোড করে। যদি ম্যাপিং নির্মাণের সময় \n    কোনও বিরোধ পাওয়া যায়, বা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" ফেরত দেয়।\n    \n    Args:\n    encoded (str): এনকোড করা তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোড করা স্ট্রিংয়ের সাথে সংশ্লিষ্ট মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n    \n    Returns:\n    str: ডিকোড করা বার্তা যদি সফল হয়, অথবা \"Failed\" যদি ডিকোড করা সম্ভব না হয়।\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "bg": "Напишете Python функция 'def decode(encoded: str, original: str, message: str) -> str:' за решаване на следния проблем:\n\n    Декодира криптирано съобщение, използвайки шифър, извлечен от известна двойка кодирано-оригинално.\n    \n    Функцията създава съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие за декодиране на дадено криптирано съобщение. Ако се намери противоречие по време на\n    създаването на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n    \n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n    \n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n    \n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "zh": "编写一个Python函数 'def decode(encoded: str, original: str, message: str) -> str:' 来解决以下问题：\n\n    使用从已知的编码-原始对派生的密码解码加密消息。\n    \n    该函数从编码字母到其原始字母构建一个映射，并使用此映射解码给定的加密消息。\n    如果在构建映射过程中发现矛盾，或者映射中并未代表所有字母，函数返回 \"Failed\"。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果解码成功则返回解码后的消息，如果解码不可能则返回 \"Failed\"。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "fr": "Écrivez une fonction python 'def decode(encoded: str, original: str, message: str) -> str:' pour résoudre le problème suivant :\n\n    Décode un message chiffré en utilisant un chiffrement dérivé d'une paire encodée-originale connue.\n    \n    La fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction\n    de la correspondance, ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction retourne \"Failed\".\n    \n    Args:\n    encoded (str): Une chaîne représentant l'information encodée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Returns:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "de": "Schreiben Sie eine Python-Funktion 'def decode(encoded: str, original: str, message: str) -> str:' um das folgende Problem zu lösen:\n\n    Entschlüsselt eine verschlüsselte Nachricht mit Hilfe eines Chiffre, der aus einem bekannten kodierten-originalen Paar abgeleitet ist.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese\n    Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird\n    oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Ein String, der die kodierten Informationen darstellt.\n    original (str): Ein String, der die ursprünglichen Informationen darstellt, die dem kodierten String entsprechen.\n    message (str): Ein String, der die zu entschlüsselnde verschlüsselte Nachricht darstellt.\n    \n    Rückgabewert:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "ha": "Rubuta wani aikin python 'def decode(encoded: str, original: str, message: str) -> str:' don warware matsalar mai zuwa:\n\n    Fassarawa sakon da aka ɓoye ta amfani da wani cipher da aka samo daga sanannen encoded-original nau'i biyu.\n    \n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa haruffan asali kuma yana amfani da wannan\n    taswira don fassara wani sakon da aka ɓoye. Idan aka sami sabani yayin gina taswira,\n    ko kuma ba duk haruffa suna cikin taswira ba, aikin yana dawowa da \"Failed\".\n    \n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanan da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar sakon da aka ɓoye da za a fassara.\n    \n    Returns:\n    str: Sakon da aka fassara idan an yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n    \n    Misalai:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "hi": "एक पायथन फ़ंक्शन 'def decode(encoded: str, original: str, message: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    ज्ञात एन्कोडेड-मूल जोड़ी से व्युत्पन्न एक सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n    \n    फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग \n    दिए गए एन्क्रिप्टेड संदेश को डिकोड करने के लिए करता है। यदि मैपिंग निर्माण के दौरान कोई \n    विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं, तो फ़ंक्शन \"Failed\" लौटाता है।\n    \n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    \n    लौटाता है:\n    str: यदि सफल होता है तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n    \n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "hu": "Írj egy python függvényt 'def decode(encoded: str, original: str, message: str) -> str:' a következő probléma megoldására:\n\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel segítségével.\n    \n    A függvény létrehoz egy leképezést a kódolt betűk és az eredeti betűk között, és ezt a\n    leképezést használja a megadott titkosított üzenet dekódolására. Ha ellentmondás található a\n    leképezés létrehozása során, vagy nem minden betű van képviselve a leképezésben, a függvény \"Failed\"-et ad vissza.\n    \n    Paraméterek:\n    encoded (str): Egy karakterlánc, amely a kódolt információt képviseli.\n    original (str): Egy karakterlánc, amely az eredeti információt képviseli, amely megfelel a kódolt karakterláncnak.\n    message (str): Egy karakterlánc, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Visszatér:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'"
    },
    "instruction_bertscore": {
      "sq": "0.9876066560057092",
      "hy": "0.9793462143496113",
      "bn": "0.9786335285424581",
      "bg": "0.992313600145093",
      "zh": "0.9848742964841932",
      "fr": "0.9864097093295929",
      "de": "0.992313600145093",
      "ha": "0.9723977263602488",
      "hi": "0.9909863519390179",
      "hu": "0.9693151814769684"
    },
    "level": "hard",
    "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()",
    "entry_point": "decode",
    "signature": "def decode(encoded: str, original: str, message: str) -> str:",
    "docstring": {
      "en": "\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    ",
      "sq": "\n    Dekodon një mesazh të koduar duke përdorur një çelës të nxjerrë nga një çift i njohur i koduar-origjinal.\n    \n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Dështoi\".\n    \n    Argumentet:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n    \n    Kthen:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Dështoi\" nëse dekodimi nuk është i mundur.\n    \n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "hy": "\n    Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան կառուցում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում համապատասխանության\n    կառուցման ընթացքում, կամ բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Պարամետրեր:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է կոդավորված տողի համապատասխան բնօրինակ տեղեկատվությունը:\n    message (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "bn": "\n    একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n    \n    ফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তা ডিকোড করে। ম্যাপিং নির্মাণের সময় যদি কোনো বিরোধ পাওয়া যায়, বা ম্যাপিংয়ে সব অক্ষর প্রতিনিধিত্ব না করে, তাহলে ফাংশন \"Failed\" ফেরত দেয়।\n    \n    আর্গস:\n    encoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n    \n    রিটার্নস:\n    str: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোডিং সম্ভব না হলে \"Failed\"।\n    \n    উদাহরণ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "bg": "\n    Декодира криптирано съобщение, използвайки шифър, извлечен от известна двойка кодирано-оригинално.\n    \n    Функцията създава съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие, за да декодира дадено криптирано съобщение. Ако бъде намерено противоречие по време на създаването на съответствието,\n    или не всички букви са представени в съответствието, функцията връща \"Failed\".\n    \n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n    \n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n    \n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "zh": "\n    使用从已知编码-原始对派生的密码解码加密消息。\n    \n    该函数从编码字母到其原始字母构建一个映射，并使用此映射解码给定的加密消息。\n    如果在映射构建过程中发现矛盾，或者映射中没有表示所有字母，函数返回 \"Failed\"。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果成功则返回解码后的消息，如果解码不可能则返回 \"Failed\"。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "fr": "\n    Décode un message chiffré en utilisant un chiffre dérivé d'une paire connue encodée-originale.\n    \n    La fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction de la correspondance,\n    ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction retourne \"Failed\".\n    \n    Args:\n    encoded (str): Une chaîne représentant l'information encodée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Returns:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "de": "\n    Entschlüsselt eine verschlüsselte Nachricht mithilfe eines Chiffres, der aus einem bekannten Paar von kodierten und originalen Zeichenfolgen abgeleitet wurde.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Eine Zeichenfolge, die die kodierte Information darstellt.\n    original (str): Eine Zeichenfolge, die die ursprüngliche Information darstellt, die der kodierten Zeichenfolge entspricht.\n    message (str): Eine Zeichenfolge, die die zu entschlüsselnde verschlüsselte Nachricht darstellt.\n    \n    Rückgabe:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "ha": "\n    Fassar da saƙon da aka ɓoye ta amfani da wata hanya da aka samo daga sanannen encoded-original ma'aurata.\n    \n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa haruffan asali kuma yana amfani da wannan\n    taswira don fassara wani saƙon da aka ɓoye. Idan an sami sabani yayin gina taswira,\n    ko kuma ba duk haruffa suna cikin taswirar ba, aikin yana dawowa da \"Failed\".\n    \n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanan da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar saƙon da aka ɓoye da za a fassara.\n    \n    Returns:\n    str: Saƙon da aka fassara idan an yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n    \n    Misalai:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "hi": "\n    ज्ञात एन्कोडेड-मूल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n    \n    यह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग करके दिए गए एन्क्रिप्टेड संदेश को डिकोड करता है। यदि मैपिंग निर्माण के दौरान कोई विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षरों का प्रतिनिधित्व नहीं होता है, तो फ़ंक्शन \"Failed\" लौटाता है।\n    \n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    \n    लौटाता है:\n    str: यदि सफल हो तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n    \n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'",
      "hu": "\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel segítségével.\n    \n    A függvény egy leképezést épít a kódolt betűk és az eredeti betűk között, és ezt a leképezést használja\n    egy adott titkosított üzenet dekódolására. Ha ellentmondást talál a leképezés építése során, vagy nem minden betű szerepel a leképezésben, a függvény \"Failed\" értéket ad vissza.\n    \n    Paraméterek:\n    encoded (str): Egy karakterlánc, amely a kódolt információt képviseli.\n    original (str): Egy karakterlánc, amely az eredeti információt képviseli, amely megfelel a kódolt karakterláncnak.\n    message (str): Egy karakterlánc, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Visszatér:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'"
    },
    "docstring_bertscore": {
      "sq": "0.9695304968100102",
      "hy": "0.9694139007763427",
      "bn": "0.9742330710810112",
      "bg": "0.9864311614107447",
      "zh": "0.9769284853516547",
      "fr": "0.9844355219724872",
      "de": "0.9720552875833447",
      "ha": "0.9273854998227897",
      "hi": "0.9879441290230875",
      "hu": "0.975700353705716"
    }
  },
  {
    "task_id": "Python/23",
    "prompt": {
      "en": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "sq": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Gjeni faktorin më të madh prim të një numri të dhënë të plotë pozitiv.\n    \n    Supozohet se numri është produkt i saktësisht dy numrave të ndryshëm prim.\n    Funksioni iteron nëpër faktorët potencialë duke filluar nga primi më i vogël (2)\n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden faktorë\n    deri në rrënjën katrore të 'n', atëherë vetë 'n' është një numër prim dhe kthehet si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri i plotë pozitiv për të faktoruar, i cili është produkt i dy numrave të ndryshëm prim.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "hy": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ գործակիցը։\n    \n    Ենթադրվում է, որ ամբողջ թիվը երկու տարբեր պարզ թվերի արտադրյալն է։\n    Ֆունկցիան սկսում է ամենափոքր պարզ թվից (2) և ստուգում է՝ արդյոք դրանք 'n'-ի գործակից են։\n    Եթե գործակից է գտնվում, ֆունկցիան վերադարձնում է 'n'-ը այդ գործակցով բաժանելու արդյունքը, որը ամենամեծ պարզ գործակիցն է։\n    Եթե 'n'-ի քառակուսի արմատի սահմաններում գործակիցներ չեն գտնվել, ապա 'n'-ը ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ գործակից։\n    \n    Արգումենտներ:\n    n (int): Դրական ամբողջ թիվը, որը պետք է գործակիցների բաժանել, որը երկու տարբեր պարզ թվերի արտադրյալն է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ գործակիցներից ամենամեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n",
      "bn": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যার সর্বাধিক মৌলিক গুণনীয়ক খুঁজে বের করুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি ভিন্ন মৌলিক সংখ্যার গুণফল বলে অনুমান করা হয়।\n    ফাংশনটি সম্ভাব্য গুণনীয়কগুলির মধ্যে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে এবং পরীক্ষা করে যে তারা 'n'-এর গুণনীয়ক কিনা।\n    যদি একটি গুণনীয়ক পাওয়া যায়, ফাংশনটি 'n' কে এই গুণনীয়ক দ্বারা ভাগ করার ফলাফল ফেরত দেয়, যা বৃহত্তম মৌলিক গুণনীয়ক।\n    যদি 'n'-এর বর্গমূল পর্যন্ত কোনো গুণনীয়ক পাওয়া না যায়, তবে 'n' নিজেই একটি মৌলিক সংখ্যা এবং সর্বাধিক মৌলিক গুণনীয়ক হিসেবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): ধনাত্মক পূর্ণসংখ্যা যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n'-এর দুটি মৌলিক গুণনীয়কের মধ্যে বৃহত্তম।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n",
      "bg": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че цялото число е произведение на точно две различни прости числа.\n    Функцията преминава през потенциални делители, започвайки от най-малкото просто число (2),\n    и проверява дали те са делители на 'n'. Ако се намери делител, функцията връща\n    делението на 'n' с този делител, което е по-големият прост делител. Ако не се намерят\n    делители до квадратния корен на 'n', тогава 'n' сам по себе си е просто число и се\n    връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизация, което е произведение на две различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "zh": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    找到给定正整数的最大素因数。\n    \n    假设该整数是两个不同素数的乘积。\n    该函数从最小的素数(2)开始迭代潜在因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的素因数。\n    如果在 'n' 的平方根范围内没有找到因数，则 'n' 本身是一个素数，并作为最大的素因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，它是两个不同素数的乘积。\n    \n    返回:\n    int: 'n' 的两个素因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "fr": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Trouver le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de deux nombres premiers distincts exactement.\n    La fonction itère à travers les facteurs potentiels en commençant par le plus petit nombre premier (2)\n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "de": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Die Zahl wird angenommen als das Produkt von genau zwei verschiedenen Primzahlen.\n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit der kleinsten Primzahl (2),\n    und prüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis\n    zur Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl\n    und wird als der größte Primfaktor zurückgegeben.\n    \n    Argumente:\n    n (int): Die zu faktorisierende positive ganze Zahl, die das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Rückgabewert:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Beispiele:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"",
      "ha": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Nemo mafi girman lambar farko daga wani adadi mai kyau da aka bayar.\n    \n    Ana tsammanin adadin shine samfurin lambobi biyu na farko daban-daban.\n    Aikin yana zagayawa ta hanyar abubuwan da ake iya samu daga mafi ƙarancin lamba ta farko (2)\n    kuma yana duba ko suna da alaƙa da 'n'. Idan an sami wani abu, aikin yana dawo da\n    rabon 'n' da wannan abin, wanda shine mafi girman lambar farko. Idan ba a sami\n    abubuwa ba har zuwa tushen murabba'in 'n', to 'n' kanta lamba ce ta farko kuma\n    ana dawo da ita a matsayin mafi girman lambar farko.\n    \n    Args:\n    n (int): Adadi mai kyau don yin factorize, wanda shine samfurin lambobi biyu na farko daban-daban.\n    \n    Returns:\n    int: Daya daga cikin lambobin farko biyu na 'n' wanda yafi girma.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "hi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    पूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं का गुणनफल माना जाता है।\n    फ़ंक्शन संभावित गुणनखण्डों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू होता है \n    और जांचता है कि क्या वे 'n' के गुणनखण्ड हैं। यदि कोई गुणनखण्ड मिलता है, तो फ़ंक्शन \n    'n' को इस गुणनखण्ड से विभाजित करके लौटाता है, जो कि बड़ा अभाज्य गुणनखण्ड होता है। \n    यदि 'n' के वर्गमूल तक कोई गुणनखण्ड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है \n    और इसे सबसे बड़े अभाज्य गुणनखण्ड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखण्डों में से बड़ा।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n   ",
      "hu": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Feltételezzük, hogy az egész szám pontosan két különböző prímszám szorzata.\n    A függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön, \n    és ellenőrzi, hogy ezek tényezői-e 'n'-nek. Ha talál tényezőt, a függvény \n    visszaadja 'n' osztását ezzel a tényezővel, ami a nagyobb prímtényező. Ha \n    'n' négyzetgyökéig nem található tényező, akkor maga 'n' prímszám, és \n    visszatér a legnagyobb prímtényezőként.\n    \n    Args:\n    n (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prímszám szorzata.\n    \n    Returns:\n    int: 'n' két prímtényezője közül a nagyobb.\n    \n    Példák:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    \"\"\"\n"
    },
    "prompt_bertscore": {
      "sq": "0.9965054957064532",
      "hy": "0.9575876465199066",
      "bn": "0.9841705490441867",
      "bg": "0.9925352716503278",
      "zh": "1",
      "fr": "0.9883755542106952",
      "de": "0.9963124269760874",
      "ha": "1",
      "hi": "1",
      "hu": "0.9867114288783849"
    },
    "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor",
    "instruction": {
      "en": "Write a python function 'def largest_prime_factor(n: int) -> int:' to solve the following problem:\n\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
      "sq": "Shkruani një funksion python 'def largest_prime_factor(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Gjeni faktorin më të madh prim të një numri të plotë pozitiv të dhënë.\n    \n    Numri i plotë supozohet të jetë prodhimi i saktësisht dy numrave të ndryshëm prim.\n    Funksioni iteron nëpër faktorët e mundshëm duke filluar nga primi më i vogël (2)\n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden\n    faktorë deri në rrënjën katrore të 'n', atëherë 'n' vetë është një numër prim dhe\n    kthehet si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri i plotë pozitiv për të faktorizuar, i cili është prodhimi i dy primeve të ndryshëm.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Shembuj:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "hy": "Պայթոն ֆունկցիա 'def largest_prime_factor(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ գործակիցը։\n    \n    Ամբողջ թիվը համարվում է ճիշտ երկու տարբեր պարզ թվերի արտադրյալ։ \n    Ֆունկցիան անցնում է հնարավոր գործակիցներով՝ սկսելով ամենափոքր պարզ թվից (2) \n    և ստուգում է՝ արդյոք դրանք 'n'-ի գործակից են։ Եթե գործակից է գտնվում, ֆունկցիան վերադարձնում է \n    'n'-ի բաժանումը այդ գործակցով, որը ամենամեծ պարզ գործակիցն է։ Եթե 'n'-ի \n    քառակուսի արմատի չափով գործակիցներ չեն գտնվում, ապա 'n'-ն ինքնին պարզ թիվ է և \n    վերադարձվում է որպես ամենամեծ պարզ գործակից։\n    \n    Արգումենտներ:\n    n (int): Դրական ամբողջ թիվը, որը պետք է գործակիցել, որը երկու տարբեր պարզ թվերի արտադրյալ է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ գործակիցներից մեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "bn": "একটি পাইথন ফাংশন 'def largest_prime_factor(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত ধনাত্মক পূর্ণসংখ্যার সবচেয়ে বড় মৌলিক গুণনীয়ক খুঁজুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি পৃথক মৌলিক সংখ্যার গুণফল হিসাবে ধরা হয়।\n    ফাংশন সম্ভাব্য গুণনীয়কগুলির মধ্য দিয়ে সবচেয়ে ছোট মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে \n    এবং পরীক্ষা করে যে তারা 'n' এর গুণনীয়ক কিনা। যদি একটি গুণনীয়ক পাওয়া যায়, তাহলে ফাংশন \n    'n' কে এই গুণনীয়ক দ্বারা ভাগ করে, যা বড় মৌলিক গুণনীয়ক হয়, তা ফেরত দেয়। যদি 'n' এর \n    বর্গমূল পর্যন্ত কোনো গুণনীয়ক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা এবং \n    সবচেয়ে বড় মৌলিক গুণনীয়ক হিসাবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): ধনাত্মক পূর্ণসংখ্যা যা গুণনীয়ক করতে হবে, যা দুটি পৃথক মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n' এর দুটি মৌলিক গুণনীয়কের মধ্যে বড়টি।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "bg": "Напишете Python функция 'def largest_prime_factor(n: int) -> int:', за да решите следния проблем:\n\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че числото е произведение на точно две различни прости числа.\n    Функцията преминава през потенциални делители, започвайки от най-малкото просто число (2),\n    и проверява дали те са делител на 'n'. Ако се намери делител, функцията връща\n    делението на 'n' с този делител, което е по-големият прост делител. Ако не се намерят делители\n    до квадратния корен на 'n', тогава 'n' самото е просто число и се връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизиране, което е произведение на две различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "zh": "编写一个 Python 函数 'def largest_prime_factor(n: int) -> int:' 来解决以下问题：\n\n    找到给定正整数的最大素因数。\n    \n    假设该整数是恰好两个不同素数的乘积。\n    函数从最小的素数（2）开始迭代潜在因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的素因数。\n    如果在 'n' 的平方根之前没有找到因数，那么 'n' 本身就是一个素数，并作为最大的素因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，是两个不同素数的乘积。\n    \n    返回:\n    int: 'n' 的两个素因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "fr": "Écrivez une fonction python 'def largest_prime_factor(n: int) -> int:' pour résoudre le problème suivant :\n\n    Trouvez le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de exactement deux nombres premiers distincts.\n    La fonction parcourt les facteurs potentiels en commençant par le plus petit nombre premier (2)\n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "de": "Schreiben Sie eine Python-Funktion 'def largest_prime_factor(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Finden Sie den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Es wird angenommen, dass die ganze Zahl das Produkt von genau zwei verschiedenen Primzahlen ist.\n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit dem kleinsten Prim (2),\n    und überprüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur\n    Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird\n    als der größte Primfaktor zurückgegeben.\n    \n    Argumente:\n    n (int): Die positive ganze Zahl, die faktorisiert werden soll, welche das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Rückgabewert:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Beispiele:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "ha": "Rubuta wani aikin python 'def largest_prime_factor(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Nemo mafi girman abin da ba a iya raba shi ba na wani adadi mai kyau da aka bayar.\n    \n    Ana ɗaukar cewa adadin yana daidai da samfurin lambobi biyu masu rarrabe waɗanda ba a iya raba su ba.\n    Aikin yana juyawa ta hanyar abubuwan da za a iya samu farawa daga mafi ƙarancin abin da ba a iya raba shi ba (2)\n    kuma yana duba idan suna cikin abubuwan da suka hada da 'n'. Idan an sami wani abu, aikin yana mayar da\n    rabon 'n' da wannan abu, wanda shine mafi girman abin da ba a iya raba shi ba. Idan ba a sami wani abu ba har zuwa\n    tushen murabba'in 'n', to 'n' kanta lamba ce da ba a iya raba ta ba kuma ana mayar da ita a matsayin\n    mafi girman abin da ba a iya raba shi ba.\n    \n    Args:\n    n (int): Adadi mai kyau da za a raba, wanda shine samfurin lambobi biyu masu rarrabe waɗanda ba a iya raba su ba.\n    \n    Returns:\n    int: Mafi girman daga cikin abubuwan da ba a iya raba su ba guda biyu na 'n'.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "hi": "एक पायथन फ़ंक्शन 'def largest_prime_factor(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    यह पूर्णांक ठीक दो भिन्न अभाज्य संख्याओं का गुणनफल माना जाता है।\n    फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू करते हुए पुनरावृत्ति करता है \n    और जांचता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड मिलता है, तो फ़ंक्शन \n    'n' को इस गुणनखंड से विभाजित करके लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। यदि 'n' \n    के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे \n    सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा एक।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "hu": "Írjon egy python függvényt 'def largest_prime_factor(n: int) -> int:' a következő probléma megoldására:\n\n    Keresse meg a megadott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Az egész számot pontosan két különböző prímszám szorzataként feltételezzük. \n    A függvény a lehetséges tényezőkön iterál a legkisebb prímtől (2) kezdve, \n    és ellenőrzi, hogy ezek a tényezők-e 'n'-nek. Ha talál tényezőt, a függvény \n    visszaadja 'n' osztását ezzel a tényezővel, amely a nagyobb prímtényező. \n    Ha nem található tényező 'n' négyzetgyökéig, akkor 'n' maga is prímszám, és \n    visszatér a legnagyobb prímtényezőként.\n    \n    Args:\n    n (int): A pozitív egész szám, amelyet tényezőkre kell bontani, és amely két különböző prímszám szorzata.\n    \n    Returns:\n    int: 'n' két prímtényezője közül a nagyobb.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5"
    },
    "instruction_bertscore": {
      "sq": "0.9977044286863798",
      "hy": "0.9999996027392379",
      "bn": "0.9930507174891134",
      "bg": "0.9909865505693989",
      "zh": "0.9887283217674132",
      "fr": "0.9896199735478788",
      "de": "0.9985416557424418",
      "ha": "0.9977044286863798",
      "hi": "0.9999996027392379",
      "hu": "0.986927935993713"
    },
    "level": "easy",
    "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()",
    "entry_point": "largest_prime_factor",
    "signature": "def largest_prime_factor(n: int) -> int:",
    "docstring": {
      "en": "\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    ",
      "sq": "\n    Gjeni faktorin më të madh prim të një numri të dhënë të plotë pozitiv.\n    \n    Supozohet që numri i plotë është produkt i saktësisht dy numrave të ndryshëm prim.\n    Funksioni iteron nëpër faktorët e mundshëm duke filluar nga primi më i vogël (2)\n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden faktorë\n    deri në rrënjën katrore të 'n', atëherë 'n' vetë është një numër prim dhe kthehet si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri i plotë pozitiv për të faktorizuar, i cili është produkt i dy primeve të ndryshëm.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "hy": "\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ գործոնը։\n    \n    Ենթադրվում է, որ ամբողջ թիվը հենց երկու տարբեր պարզ թվերի արտադրյալն է։\n    Ֆունկցիան սկսում է ամենափոքր պարզ թվից (2) և ստուգում է, արդյոք դրանք 'n'-ի գործոն են։\n    Եթե գործոն է գտնվել, ֆունկցիան վերադարձնում է 'n'-ի բաժանումը այդ գործոնով, որը ամենամեծ պարզ գործոնն է։\n    Եթե 'n'-ի քառակուսի արմատի սահմաններում գործոններ չեն գտնվել, ապա 'n'-ն ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ գործոն։\n    \n    Պարամետրեր:\n    n (int): Դրական ամբողջ թիվը, որը պետք է բաժանել, որը երկու տարբեր պարզ թվերի արտադրյալն է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ գործոններից ամենամեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "bn": "\n    প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যার বৃহত্তম মৌলিক গুণনীয়ক খুঁজুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি ভিন্ন মৌলিক সংখ্যার গুণফল বলে ধরা হয়।\n    ফাংশনটি সম্ভাব্য গুণনীয়কগুলির মধ্য দিয়ে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে এবং তারা 'n' এর গুণনীয়ক কিনা তা পরীক্ষা করে।\n    যদি একটি গুণনীয়ক পাওয়া যায়, ফাংশনটি এই গুণনীয়ক দ্বারা 'n' এর ভাগফল প্রদান করে, যা বৃহত্তম মৌলিক গুণনীয়ক।\n    যদি 'n' এর বর্গমূল পর্যন্ত কোনো গুণনীয়ক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা এবং বৃহত্তম মৌলিক গুণনীয়ক হিসাবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): গুণনীয়ক করতে হবে এমন ধনাত্মক পূর্ণসংখ্যা, যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n' এর দুটি মৌলিক গুণনীয়কের মধ্যে বৃহত্তম।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "bg": "\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че цялото число е произведение на точно два различни прости числа.\n    Функцията обхожда потенциалните делители, започвайки от най-малкото просто число (2),\n    и проверява дали те са делители на 'n'. Ако се намери делител, функцията връща\n    резултата от делението на 'n' с този делител, което е по-големият прост делител.\n    Ако не се намерят делители до квадратния корен на 'n', тогава самото 'n' е просто число\n    и се връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизация, което е произведение на два различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "zh": "\n    找出给定正整数的最大质因数。\n    \n    假设该整数是两个不同质数的乘积。\n    该函数从最小的质数(2)开始迭代可能的因数，并检查它们是否是 'n' 的因数。\n    如果找到一个因数，函数返回 'n' 除以该因数的结果，即较大的质因数。\n    如果在 'n' 的平方根范围内没有找到因数，那么 'n' 本身就是一个质数，并作为最大质因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，它是两个不同质数的乘积。\n    \n    返回:\n    int: 'n' 的两个质因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "fr": "\n    Trouver le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de exactement deux nombres premiers distincts.\n    La fonction itère à travers les facteurs potentiels en commençant par le plus petit nombre premier (2)\n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "de": "\n    Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Es wird angenommen, dass die ganze Zahl das Produkt von genau zwei verschiedenen Primzahlen ist.\n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit der kleinsten Primzahl (2),\n    und überprüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur\n    Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird\n    als größter Primfaktor zurückgegeben.\n    \n    Args:\n    n (int): Die positive ganze Zahl, die faktorisiert werden soll, welche das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Returns:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "ha": "\n    Nemo mafi girman lambar farko ta wani adadi mai kyau da aka bayar.\n    \n    Ana ɗaukar adadin a matsayin samfurin lambobi biyu na farko daban-daban.\n    Aiki yana zagayawa ta hanyar yiwuwar abubuwan da aka fara daga mafi ƙarancin lamba ta farko (2)\n    kuma yana duba ko su abubuwan 'n' ne. Idan an sami abu, aikin yana dawowa\n    rabon 'n' da wannan abu, wanda shine mafi girman lambar farko. Idan babu abubuwan da aka samu har zuwa tushen murabba'in 'n', to 'n' kanta lamba ta farko ce kuma ana\n    dawowa da ita a matsayin mafi girman lambar farko.\n    \n    Args:\n    n (int): Adadi mai kyau don rarrabawa, wanda shine samfurin lambobi biyu na farko daban-daban.\n    \n    Returns:\n    int: Mafi girman lambobi biyu na farko na 'n'.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "hi": "\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    पूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में माना जाता है।\n    यह फ़ंक्शन सबसे छोटे अभाज्य (2) से संभावित गुणनखंडों के माध्यम से पुनरावृत्ति करता है\n    और जांचता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड पाया जाता है, तो फ़ंक्शन\n    'n' को इस गुणनखंड से विभाजित कर लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। यदि 'n'\n    के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे\n    सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "hu": "\n    Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Az egész szám feltételezhetően pontosan két különböző prímszám szorzata.\n    A függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön,\n    és ellenőrzi, hogy ezek a tényezők-e 'n'-nek. Ha talál tényezőt, a függvény\n    visszaadja 'n' osztását ezzel a tényezővel, ami a nagyobb prímtényező.\n    Ha 'n' négyzetgyökéig nem talál tényezőket, akkor 'n' maga is prímszám,\n    és mint a legnagyobb prímtényező kerül visszaadásra.\n    \n    Paraméterek:\n    n (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prímszám szorzata.\n    \n    Visszatér:\n    int: 'n' két prímtényezője közül a nagyobbik.\n    \n    Példák:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9515435226553959",
      "bn": "1",
      "bg": "0.9984254569695364",
      "zh": "1",
      "fr": "0.9886711162176751",
      "de": "0.9984254569695364",
      "ha": "0.9972620788278151",
      "hi": "1",
      "hu": "0.9882615403719812"
    }
  },
  {
    "task_id": "Python/24",
    "prompt": {
      "en": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "sq": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve në të cilat do të ndahet n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të ndarjes së dallueshme.\n\n    Shembuj:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "hy": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Հաշվել, թե քանի եղանակով կարելի է n ամբողջ թիվը բաժանել k մասերի,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի հերթականությունը նշանակություն չունի։\n\n    Պարամետրեր:\n    n (int): Ամբողջ թիվը, որը պետք է բաժանել։\n    k (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "bn": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ কমপক্ষে x এবং অংশগুলির ক্রম গুরুত্বপূর্ণ নয়।\n\n    প্যারামিটার:\n    n (int): যে পূর্ণসংখ্যাটি ভাগ করা হবে।\n    k (int): n কে ভাগ করার জন্য অংশের সংখ্যা।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    রিটার্নস:\n    int: স্বতন্ত্র ভাগ করার উপায়গুলির সংখ্যা।\n\n    উদাহরণ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "bg": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Пребройте броя на начините за разделяне на цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "zh": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    计算将整数 n 分成 k 部分的方法数，\n    其中每部分至少为 x，并且部分的顺序不重要。\n\n    参数:\n    n (int): 要分割的整数。\n    k (int): 将 n 分成的部分数。\n    x (int): 每部分的最小值。\n\n    返回:\n    int: 不同分割方法的数量。\n\n    示例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "fr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Retourne:\n    int: Le nombre de façons de partition distinctes.\n\n    Exemples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "de": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Zähle die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu zerlegen,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu zerlegende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabe:\n    int: Die Anzahl der unterschiedlichen Zerlegungsmöglichkeiten.\n\n    Beispiele:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "ha": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Ƙirga yawan hanyoyin raba lamba n zuwa k sassa,\n    inda kowanne sashi ya kasance aƙalla x kuma tsari na sassa ba shi da mahimmanci.\n\n    Ma'auni:\n    n (int): Lambar da za a raba.\n    k (int): Yawan sassan da za a raba n zuwa.\n    x (int): Ƙimar mafi ƙaranci ga kowane sashi.\n\n    Komawa:\n    int: Yawan hanyoyin rarrabuwa daban-daban.\n\n    Misalai:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "hi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    एक पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों का क्रम मायने नहीं रखता।\n\n    पैरामीटर्स:\n    n (int): विभाजित किया जाने वाला पूर्णांक।\n    k (int): n को विभाजित करने के लिए भागों की संख्या।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    रिटर्न्स:\n    int: विभाजन के विभिन्न तरीकों की संख्या।\n\n    उदाहरण:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\"",
      "hu": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Számolja meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amire n-t fel kell osztani.\n    x (int): Minden rész minimum értéke.\n\n    Visszatér:\n    int: Az eltérő felosztási módok száma.\n\n    Példák:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9778888632439583",
      "hy": "0.9746350989722258",
      "bn": "0.9842496039358385",
      "bg": "0.9711870741878412",
      "zh": "0.9620135286701259",
      "fr": "0.9869219770822819",
      "de": "0.9733461864296904",
      "ha": "0.9760555048270063",
      "hi": "0.9866015862776727",
      "hu": "0.9870963745568305"
    },
    "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count",
    "instruction": {
      "en": "Write a python function 'def count_partitions(n: int, k: int, x: int) -> int:' to solve the following problem:\n\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "sq": "Shkruani një funksion python 'def count_partitions(n: int, k: int, x: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve për të ndarë n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të dallueshme të ndarjes.\n\n    Shembuj:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "hy": "Պայթոն ֆունկցիա 'def count_partitions(n: int, k: int, x: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվել եղանակների քանակը, որոնցով կարելի է բաժանել n ամբողջ թիվը k մասերի,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի հերթականությունը կարևոր չէ։\n\n    Պարամետրեր:\n    n (int): Բաժանվող ամբողջ թիվը։\n    k (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "bn": "একটি পাইথন ফাংশন 'def count_partitions(n: int, k: int, x: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ অন্তত x এবং অংশগুলির ক্রম বিবেচ্য নয়।\n\n    Parameters:\n    n (int): বিভাজন করার জন্য পূর্ণসংখ্যা।\n    k (int): n কে ভাগ করার জন্য অংশের সংখ্যা।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    Returns:\n    int: পৃথক বিভাজন পদ্ধতির সংখ্যা।\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "bg": "Напишете Python функция 'def count_partitions(n: int, k: int, x: int) -> int:' за да решите следния проблем:\n\n    Пребройте броя на начините да разделите цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "zh": "编写一个Python函数 'def count_partitions(n: int, k: int, x: int) -> int:' 来解决以下问题：\n\n    计算将整数n划分为k部分的方法数，\n    其中每部分至少为x，并且部分的顺序无关紧要。\n\n    参数：\n    n (int): 要划分的整数。\n    k (int): 将n划分为的部分数。\n    x (int): 每部分的最小值。\n\n    返回：\n    int: 不同划分方法的数量。\n\n    示例：\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "fr": "Écrire une fonction python 'def count_partitions(n: int, k: int, x: int) -> int:' pour résoudre le problème suivant :\n\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Renvoie:\n    int: Le nombre de façons distinctes de partitionner.\n\n    Exemples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "de": "Schreiben Sie eine Python-Funktion 'def count_partitions(n: int, k: int, x: int) -> int:', um das folgende Problem zu lösen:\n\n    Zählen Sie die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu partitionierende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabewert:\n    int: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\n    Beispiele:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "ha": "Rubuta wani aikin python 'def count_partitions(n: int, k: int, x: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa yawan hanyoyin da za a raba adadi n zuwa k sassa,\n    inda kowanne sashi ya kasance a kalla x kuma tsarin sassa ba shi da mahimmanci.\n\n    Sigogi:\n    n (int): Adadin da za a raba.\n    k (int): Yawan sassan da za a raba n zuwa.\n    x (int): Mafi karancin darajar kowane sashi.\n\n    Mayar da:\n    int: Yawan hanyoyin rarrabawa daban-daban.\n\n    Misalai:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "hi": "एक पायथन फ़ंक्शन 'def count_partitions(n: int, k: int, x: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\n    पैरामीटर्स:\n    n (int): वह पूर्णांक जिसे विभाजित करना है।\n    k (int): भागों की संख्या जिसमें n को विभाजित करना है।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    लौटाता है:\n    int: भिन्न विभाजन तरीकों की संख्या।\n\n    उदाहरण:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "hu": "Írj egy python függvényt 'def count_partitions(n: int, k: int, x: int) -> int:' a következő probléma megoldására:\n\n    Számold meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amire n-t fel kell osztani.\n    x (int): Az egyes részek minimális értéke.\n\n    Visszatér:\n    int: Az eltérő felosztási módok száma.\n\n    Példák:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9893540074676731",
      "hy": "0.9781129183137657",
      "bn": "0.9888286301098358",
      "bg": "0.9820712245470289",
      "zh": "0.957493694349677",
      "fr": "0.9819039777661975",
      "de": "0.9665558082236317",
      "ha": "0.9709671903560355",
      "hi": "0.986079982897075",
      "hu": "0.9850427350473109"
    },
    "level": "easy",
    "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()",
    "entry_point": "count_partitions",
    "signature": "def count_partitions(n: int, k: int, x: int) -> int:",
    "docstring": {
      "en": "\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3\n    ",
      "sq": "\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve për të ndarë n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të ndarjes të dallueshme.\n\n    Shembuj:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "hy": "\n    Հաշվեք n ամբողջ թիվը k մասերի բաժանելու եղանակների քանակը,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի կարգը կարևոր չէ։\n\n    Պարամետրեր:\n    n (int): Բաժանվող ամբողջ թիվը։\n    k (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "bn": "\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ কমপক্ষে x এবং অংশগুলির ক্রম গুরুত্বপূর্ণ নয়।\n\n    প্যারামিটারসমূহ:\n    n (int): বিভক্ত করার জন্য পূর্ণসংখ্যা।\n    k (int): n কে ভাগ করার জন্য অংশের সংখ্যা।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    রিটার্নস:\n    int: স্বতন্ত্র বিভাজনের উপায়গুলির সংখ্যা।\n\n    উদাহরণ:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "bg": "\n    Пребройте броя на начините за разделяне на цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "zh": "\n    计算将整数 n 分成 k 部分的方法数，其中每部分至少为 x，并且部分的顺序不重要。\n\n    参数:\n    n (int): 要分割的整数。\n    k (int): 将 n 分成的部分数量。\n    x (int): 每部分的最小值。\n\n    返回:\n    int: 不同分割方法的数量。\n\n    示例:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "fr": "\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Retourne:\n    int: Le nombre de façons distinctes de partitionner.\n\n    Exemples:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "de": "\n    Zähle die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu partitionierende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabe:\n    int: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\n    Beispiele:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "ha": "\n    Ƙididdige yawan hanyoyin da za a iya raba lamba n zuwa k sassa,\n    inda kowane sashi ya kasance aƙalla x kuma tsari na sassa bai da mahimmanci.\n\n    Sigogi:\n    n (int): Lambar da za a raba.\n    k (int): Yawan sassa da za a raba n.\n    x (int): Ƙimar mafi ƙaranci ga kowane sashi.\n\n    Komawa:\n    int: Yawan hanyoyin rarraba daban-daban.\n\n    Misalai:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "hi": "\n    एक पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\n    पैरामीटर्स:\n    n (int): विभाजित करने के लिए पूर्णांक।\n    k (int): n को विभाजित करने के लिए भागों की संख्या।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    रिटर्न्स:\n    int: विभाजन के भिन्न तरीकों की संख्या।\n\n    उदाहरण:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3",
      "hu": "\n    Számolja meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amelyekre n-t fel kell osztani.\n    x (int): Az egyes részek minimális értéke.\n\n    Visszatér:\n    int: A különböző felosztási módok száma.\n\n    Példák:\n    >>> count_partitions(7, 3, 1)\n    4\n    >>> count_partitions(6, 2, 1)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9920454491306958",
      "hy": "0.9656875948281283",
      "bn": "0.9847461798884257",
      "bg": "0.9824651085926212",
      "zh": "0.9551869997347189",
      "fr": "0.9834020480999627",
      "de": "0.9642536821074373",
      "ha": "0.9564548574568645",
      "hi": "0.9801711263220492",
      "hu": "0.9730943231065382"
    }
  },
  {
    "task_id": "Python/25",
    "prompt": {
      "en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "sq": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. \n    Kjo funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Args:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\n                     për secilin vlerë 'last' të hasur.\n    \n    Returns:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "hy": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Հաշվել վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել ըստ որոշակի կանոնների։\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված թվով 'n', և նոր թիվը կարող է կցվել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը։ Այս\n    ֆունկցիան օգտագործում է հիշողության օպտիմալացում՝ պահելու համար նախապես հաշվարկված արդյունքները՝\n    կատարողականությունը օպտիմալացնելու համար։\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը։\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը։\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության օպտիմալացման համար, պահելով վավեր հաջորդականությունների քանակը\n                     յուրաքանչյուր հանդիպած 'last' արժեքի համար։\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ձևավորվել 'n'-ով սկսած։\n    \n    Օրինակներ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "bn": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের সংখ্যা গণনা করুন।\n    \n    প্রতিটি সিকোয়েন্স একটি নির্দিষ্ট সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা সিকোয়েন্সে যোগ করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং সিকোয়েন্সের শেষ সংখ্যার অর্ধেকের চেয়ে বড় না হয়। এই\n    ফাংশনটি মেমোইজেশন ব্যবহার করে পূর্বে গণনা করা ফলাফলগুলি সংরক্ষণ করে কর্মক্ষমতা উন্নত করতে।\n    \n    Args:\n        n (int): সিকোয়েন্সের শুরুর সংখ্যা।\n        last (int): বর্তমান সিকোয়েন্সের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি ডিকশনারি, প্রতিটি 'last' মানের জন্য বৈধ সিকোয়েন্সের সংখ্যা\n                     সংরক্ষণ করে।\n    \n    Returns:\n        int: 'n' দিয়ে শুরু করে গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের মোট সংখ্যা।\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "bg": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Изчисляване на броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация за съхранение на предварително изчислени резултати за оптимизиране на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "zh": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    根据特定规则计算可以形成的有效序列的数量。\n    \n    每个序列以给定数字 'n' 开始，可以将一个新数字附加到序列中，\n    如果它是一个正整数且不大于序列中最后一个数字的一半。\n    此函数使用记忆化技术存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列中的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的 'last' 值的有效序列数量。\n    \n    返回:\n        int: 可以从 'n' 开始形成的有效序列的总数。\n    \n    示例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "fr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il est un entier positif et n'est pas supérieur à la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "de": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz.\n    Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Argumente:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden 'last'-Wert speichert, der aufgetreten ist.\n    \n    Rückgabewert:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' gebildet werden können.\n    \n    Beispiele:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "ha": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Lissafa adadin jerin da za a iya samarwa bisa ga wasu ƙa'idoji na musamman.\n    \n    Kowace jeri tana farawa da wani lamba 'n', kuma za a iya ƙara sabon lamba ga jerin\n    idan yana da lamba mai kyau kuma ba ya fi rabin lamba na ƙarshe a cikin jerin ba. Wannan\n    aiki yana amfani da memoization don adana sakamakon da aka ƙididdige a baya don inganta aiki.\n    \n    Args:\n        n (int): Lambar da ke farawa da jeri.\n        last (int): Lambar ƙarshe a cikin jerin yanzu.\n        memo (dict): Kamus da ake amfani da shi don memoization, yana adana adadin jerin masu inganci\n                     don kowane ƙimar 'last' da aka haɗu da shi.\n    \n    Returns:\n        int: Jimlar adadin jerin masu inganci da za a iya samarwa farawa da 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "hi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    विशिष्ट नियमों के अनुसार बनाई जा सकने वाली मान्य अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और अनुक्रम में एक नई संख्या जोड़ी जा सकती है\n    यदि यह एक धनात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\n    फ़ंक्शन प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मरणीयता का उपयोग करता है।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): स्मरणीयता के लिए उपयोग की जाने वाली एक डिक्शनरी, प्रत्येक 'last' मान के लिए मान्य अनुक्रमों की संख्या\n                     संग्रहीत करती है।\n    \n    वापसी:\n        int: 'n' से शुरू होने वाले बनाए जा सकने वाले कुल मान्य अनुक्रमों की संख्या।\n    \n    उदाहरण:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\"",
      "hu": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Számítsa ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám hozzáadható a sorozathoz,\n    ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ, hogy tárolja a korábban kiszámított eredményeket a teljesítmény optimalizálása érdekében.\n    \n    Paraméterek:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár, amelyet memoizációra használnak, és amely tárolja az érvényes sorozatok számát\n                     az egyes 'last' értékekhez, amelyekkel találkoztak.\n    \n    Visszatér:\n        int: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n    \n    Példák:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9921864767012306",
      "hy": "0.9829249379247169",
      "bn": "0.9797432764813",
      "bg": "0.9824663003749073",
      "zh": "0.9900811932926418",
      "fr": "0.992678484155054",
      "de": "0.9771654513962292",
      "ha": "0.9555173220583799",
      "hi": "0.983569294880794",
      "hu": "0.9743097424080907"
    },
    "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count",
    "instruction": {
      "en": "Write a python function 'def count_sequences(n: int, last: int, memo: dict) -> int:' to solve the following problem:\n\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    ",
      "sq": "Shkruani një funksion python 'def count_sequences(n: int, last: int, memo: dict) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Ky\n    funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Args:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, duke ruajtur numrin e sekuencave të vlefshme\n                     për çdo vlerë 'last' të hasur.\n    \n    Kthen:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Shembuj:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "hy": "Պայթոն ֆունկցիա 'def count_sequences(n: int, last: int, memo: dict) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել հատուկ կանոնների համաձայն:\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվ կարող է ավելացվել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը: Այս \n    ֆունկցիան օգտագործում է հիշողություն՝ պահպանելու համար նախապես հաշվարկված արդյունքները՝ \n    օպտիմալացնելու կատարողականությունը:\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը:\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը:\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության համար, պահպանում է վավեր հաջորդականությունների \n                     քանակը յուրաքանչյուր հանդիպած 'last' արժեքի համար:\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են կազմվել 'n'-ով սկսած:\n    \n    Օրինակներ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "bn": "একটি পাইথন ফাংশন 'def count_sequences(n: int, last: int, memo: dict) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠিত বৈধ ক্রমগুলির সংখ্যা গণনা করুন।\n    \n    প্রতিটি ক্রম একটি প্রদত্ত সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা ক্রমে যোগ করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং ক্রমের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই\n    ফাংশনটি মেমোইজেশন ব্যবহার করে পূর্বে গণনা করা ফলাফল সংরক্ষণ করতে, যা কর্মক্ষমতা উন্নত করে।\n    \n    আর্গুমেন্টস:\n        n (int): ক্রমের শুরু সংখ্যা।\n        last (int): বর্তমান ক্রমের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি ডিকশনারি, প্রতিটি 'last' মানের জন্য বৈধ ক্রমের সংখ্যা\n                     সংরক্ষণ করে।\n    \n    রিটার্নস:\n        int: 'n' দিয়ে শুরু করে গঠিত হতে পারে এমন বৈধ ক্রমগুলির মোট সংখ্যা।\n    \n    উদাহরণ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "bg": "Напишете функция на Python 'def count_sequences(n: int, last: int, memo: dict) -> int:' за решаване на следния проблем:\n\n    Изчислете броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация за съхранение на предварително изчислени резултати с цел оптимизация на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "zh": "编写一个 python 函数 'def count_sequences(n: int, last: int, memo: dict) -> int:' 来解决以下问题：\n\n    计算可以根据特定规则形成的有效序列的数量。\n    \n    每个序列以给定数字 'n' 开始，如果新数字是正整数且不大于序列中最后一个数字的一半，则可以将其附加到序列中。此函数使用记忆化技术存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列中的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的 'last' 值的有效序列数量。\n    \n    返回:\n        int: 可以以 'n' 开始形成的有效序列的总数。\n    \n    示例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "fr": "Écrivez une fonction python 'def count_sequences(n: int, last: int, memo: dict) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il est un entier positif et n'est pas supérieur à la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "de": "Schreiben Sie eine Python-Funktion 'def count_sequences(n: int, last: int, memo: dict) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der gültigen Sequenzen, die gemäß spezifischen Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz ist. Diese\n    Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Argumente:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden aufgetretenen 'last'-Wert speichert.\n    \n    Rückgabewert:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' gebildet werden können.\n    \n    Beispiele:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "ha": "Rubuta aikin python 'def count_sequences(n: int, last: int, memo: dict) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa adadin jerin sahihai da za a iya samarwa bisa ga wasu ka'idoji.\n\n    Kowace jeri tana farawa da wata lamba 'n', kuma za a iya kara wata sabuwar lamba zuwa jerin\n    idan lamba ce mai kyau kuma ba ta fi rabin lambar karshe a jerin ba. Wannan\n    aikin yana amfani da memoization don adana sakamakon da aka lissafa a baya don inganta aiki.\n\n    Args:\n        n (int): Lambar farawa na jerin.\n        last (int): Lambar karshe a cikin jerin yanzu.\n        memo (dict): Kamus da ake amfani da shi don memoization, yana adana adadin jerin sahihai\n                     don kowane darajar 'last' da aka samu.\n\n    Returns:\n        int: Jimlar adadin jerin sahihai da za a iya samarwa farawa da 'n'.\n\n    Misalai:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "hi": "एक पायथन फ़ंक्शन 'def count_sequences(n: int, last: int, memo: dict) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    विशिष्ट नियमों के अनुसार बनाए जा सकने वाले वैध अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और अनुक्रम में एक नई संख्या जोड़ी जा सकती है\n    यदि यह एक धनात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\n    फ़ंक्शन पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मरणशक्ति का उपयोग करता है ताकि प्रदर्शन को अनुकूलित किया जा सके।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): स्मरणशक्ति के लिए उपयोग किया जाने वाला शब्दकोश, प्रत्येक 'last' मान के लिए वैध अनुक्रमों की संख्या संग्रहीत करता है।\n    \n    लौटाता है:\n        int: 'n' से शुरू होकर बनाए जा सकने वाले कुल वैध अनुक्रमों की संख्या।\n    \n    उदाहरण:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "hu": "Írjon egy Python függvényt 'def count_sequences(n: int, last: int, memo: dict) -> int:' a következő probléma megoldására:\n\n    Számítsa ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint alakíthatók ki.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám hozzáadható a sorozathoz,\n    ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ a korábban kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n    \n    Paraméterek:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár, amelyet memoizációra használnak, tárolva az érvényes sorozatok számát\n                     minden egyes 'last' értékhez, amellyel találkoztak.\n    \n    Visszatér:\n        int: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n    \n    Példák:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6"
    },
    "instruction_bertscore": {
      "sq": "0.9932034642521292",
      "hy": "0.9806702844695898",
      "bn": "0.9692679074462821",
      "bg": "0.9703997033574189",
      "zh": "0.9919707641074267",
      "fr": "0.993128183337717",
      "de": "0.9892830964216437",
      "ha": "0.9621047000150209",
      "hi": "0.9856334618005086",
      "hu": "0.9760259089002321"
    },
    "level": "easy",
    "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()",
    "entry_point": "count_sequences",
    "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:",
    "docstring": {
      "en": "\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6\n    ",
      "sq": "\n    Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund t'i shtohet sekuencës\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Kjo\n    funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Args:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\n                     për çdo vlerë 'last' të hasur.\n    \n    Returns:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "hy": "\n    Հաշվարկել վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել հատուկ կանոնների համաձայն։\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվը կարող է ավելացվել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը։ Այս\n    ֆունկցիան օգտագործում է հիշողություն, որպեսզի պահպանի նախապես հաշվարկված արդյունքները՝ օպտիմալացնելու համար կատարողականությունը։\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը։\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը։\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության համար, պահելով վավեր հաջորդականությունների քանակը\n                     յուրաքանչյուր 'last' արժեքի համար, որը հանդիպել է։\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ձևավորվել 'n'-ից սկսած։\n    \n    Օրինակներ:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "bn": "\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠিত হতে পারে এমন বৈধ ক্রমের সংখ্যা গণনা করুন।\n    \n    প্রতিটি ক্রম একটি প্রদত্ত সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা ক্রমের সাথে যুক্ত করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং ক্রমের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই\n    ফাংশনটি কর্মক্ষমতা উন্নত করার জন্য পূর্বে গণনা করা ফলাফল সংরক্ষণ করতে মেমোইজেশন ব্যবহার করে।\n    \n    Args:\n        n (int): ক্রমের শুরু সংখ্যা।\n        last (int): বর্তমান ক্রমের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি অভিধান, প্রতিটি 'last' মানের জন্য\n                     বৈধ ক্রমের সংখ্যা সংরক্ষণ করে।\n    \n    Returns:\n        int: 'n' দিয়ে শুরু করে গঠিত হতে পারে এমন বৈধ ক্রমের মোট সংখ্যা।\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "bg": "\n    Изчислете броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация, за да съхранява предварително изчислени резултати за оптимизиране на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "zh": "\n    计算可以根据特定规则形成的有效序列的数量。\n    \n    每个序列以给定数字 'n' 开始，如果一个新数字是正整数且不大于序列中最后一个数字的一半，则可以将其附加到序列中。\n    该函数使用记忆化技术存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列中的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的 'last' 值的有效序列数量。\n    \n    返回:\n        int: 可以从 'n' 开始形成的有效序列的总数。\n    \n    示例:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "fr": "\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il s'agit d'un entier positif et qu'il n'est pas supérieur à la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "de": "\n    Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz ist.\n    Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Args:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden 'last'-Wert speichert, der aufgetreten ist.\n    \n    Returns:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' gebildet werden können.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "ha": "\n    Lissafa adadin jerin abubuwan da za a iya samarwa bisa ga wasu ka'idoji.\n    \n    Kowace jeri tana farawa da wani adadi 'n', kuma za a iya kara sabon adadi zuwa jerin idan\n    yana da adadi mai kyau kuma ba ya fi rabin adadin ƙarshe a cikin jerin ba. Wannan aiki yana\n    amfani da memoization don adana sakamakon da aka lissafa a baya don inganta aiki.\n    \n    Args:\n        n (int): Adadin farawa na jerin.\n        last (int): Adadin ƙarshe a cikin jerin yanzu.\n        memo (dict): Kamus da ake amfani da shi don memoization, yana adana adadin jerin abubuwan\n                     da suka dace don kowane ƙimar 'last' da aka samu.\n    \n    Returns:\n        int: Jimlar adadin jerin abubuwan da za a iya samarwa farawa da 'n'.\n    \n    Examples:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "hi": "\n    विशिष्ट नियमों के अनुसार बनाई जा सकने वाली वैध अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और अनुक्रम में एक नई संख्या जोड़ी जा सकती है \n    यदि यह एक धनात्मक पूर्णांक है और अनुक्रम की अंतिम संख्या के आधे से अधिक नहीं है। यह \n    फ़ंक्शन प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए मेमोइज़ेशन का उपयोग करता है।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): मेमोइज़ेशन के लिए उपयोग किया जाने वाला एक शब्दकोश, प्रत्येक 'last' मान के लिए \n                     वैध अनुक्रमों की संख्या संग्रहीत करता है।\n    \n    वापसी:\n        int: 'n' से शुरू होने वाले वैध अनुक्रमों की कुल संख्या।\n    \n    उदाहरण:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6",
      "hu": "\n    Számítsa ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám hozzáadható a sorozathoz,\n    ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ az előzőleg kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n    \n    Paraméterek:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár, amelyet memoizációra használnak, és az érvényes sorozatok számát tárolja\n                     minden találkozott 'last' értékre.\n    \n    Visszatér:\n        int: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n    \n    Példák:\n        >>> count_sequences(1, 1, {})\n        1\n        >>> count_sequences(6, 6, {})\n        6"
    },
    "docstring_bertscore": {
      "sq": "0.9935991359711507",
      "hy": "0.9777855754458201",
      "bn": "0.9776280615536596",
      "bg": "0.9789054535340949",
      "zh": "0.9889915070222844",
      "fr": "0.9812757098709842",
      "de": "0.9824283619721297",
      "ha": "0.9450471174132689",
      "hi": "0.9703617649546412",
      "hu": "0.971379944287826"
    }
  },
  {
    "task_id": "Python/26",
    "prompt": {
      "en": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "sq": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si maksimumin e tyre të përbashkët \n    dhe y0 si minimumin e tyre të përbashkët.\n\n    Argumentet:\n    x0 (int): MCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): MCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkëkryesorë (MCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfish të 'x0' nga faktorë bashkëkryesorë për të ruajtur\n    MCD si 'x0'. Nëse 'a' dhe 'b' janë bashkëkryesorë, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të llogaritur të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj të rasteve:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "hy": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես որ P-ն և Q-ն ունեն x0 որպես իրենց ամենամեծ ընդհանուր բաժանարար (GCD)\n    և y0 որպես նրանց ամենափոքր ընդհանուր բազմապատիկ (LCM)։\n\n    Արգումենտներ:\n    x0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\n    y0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին։\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանման բոլոր հնարավոր գործոնների 'a'-ով։ Յուրաքանչյուր գործոնի 'a' համար,\n    այն հաշվարկում է համապատասխան գործոն 'b', այնպես որ 'a * b = y0 / x0'։ Այնուհետև ստուգում է, արդյոք 'a' և 'b'\n    համատեղելի են (նրանց GCD-ն 1 է), քանի որ P-ն և Q-ն կարող են լինել միայն 'x0'-ի բազմապատիկներ համատեղելի գործոններով,\n    որպեսզի պահպանեն GCD-ն որպես 'x0'։ Եթե 'a' և 'b' համատեղելի են, քանակը ավելացվում է 1-ով, եթե 'a'-ն նույնն է ինչ 'b',\n    այլապես 2-ով՝ հաշվի առնելով և՛ (P, Q), և՛ (Q, P) զույգերը։\n\n    Օրինակային դեպքեր:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "bn": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    কতগুলি ধনাত্মক পূর্ণসংখ্যার জোড়া (P, Q) রয়েছে তা গণনা করে যেখানে P এবং Q এর x0 তাদের গরিষ্ঠ সাধারণ বিভাজক (GCD) \n    এবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\n    আর্গুমেন্টস:\n    x0 (int): GCD যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n\n    রিটার্নস:\n    int: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি y0 / x0 এর ভাগফলের সমস্ত সম্ভাব্য গুণিতক 'a' এর মাধ্যমে পুনরাবৃত্তি করে। প্রতিটি গুণিতক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণিতক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে যে 'a' এবং 'b'\n    সহমিলিত (তাদের GCD হল 1) কিনা কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমিলিত গুণিতক দ্বারা \n    GCD কে 'x0' হিসাবে বজায় রাখতে। যদি 'a' এবং 'b' সহমিলিত হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' \n    একই হয়, অন্যথায় 2 দ্বারা বৃদ্ধি পায় উভয় (P, Q) এবং (Q, P) জোড়া গণনা করার জন্য।\n\n    উদাহরণ কেস:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "bg": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като тяхно най-малко общо кратно (НОК).\n\n    Аргументи:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Връща:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни фактори 'a' на частното 'y0 / x0'. За всеки фактор 'a',\n    тя изчислява съответния фактор 'b', така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости фактори, за да се запази\n    НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "zh": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的最大公约数。\n    y0 (int): 每对 (P, Q) 必须具有的最小公倍数。\n\n    返回:\n    int: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n    该函数遍历商 'y0 / x0' 的所有可能因数 'a'。对于每个因数 'a'，计算对应的因数 'b'，使得 'a * b = y0 / x0'。\n    然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因数来保持\n    GCD 为 'x0'。如果 'a' 和 'b' 互质，计数增加 1，如果 'a' 与 'b' 相同，否则增加 2，以考虑 (P, Q) 和 (Q, P) 两种对。\n\n    示例案例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "fr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q aient x0 comme leur plus grand commun diviseur (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction itère à travers tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\n    le PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compteur est incrémenté de 1 si 'a' est le même que 'b',\n    sinon de 2 pour tenir compte des paires (P, Q) et (Q, P).\n\n    Cas d'exemple:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "de": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der Paare positiver ganzer Zahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD)\n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Argumente:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Das LCM, das jedes Paar (P, Q) haben muss.\n\n    Rückgabewert:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Sie überprüft dann, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können,\n    um den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a'\n    gleich 'b' ist, andernfalls um 2, um sowohl (P, Q) als auch (Q, P) Paare zu berücksichtigen.\n\n    Beispiel Fälle:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "ha": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Yana ƙidaya adadin ma'aurata na lambobin kirki (P, Q) ta yadda P da Q suna da x0 a matsayin babbar mai raba su (GCD)\n    kuma y0 a matsayin ƙaramin mai haɗa su (LCM).\n\n    Args:\n    x0 (int): GCD da kowace ma'aurata (P, Q) dole ne su samu.\n    y0 (int): LCM da kowace ma'aurata (P, Q) dole ne su samu.\n\n    Returns:\n    int: Adadin dukkan ma'aurata masu yiwuwa (P, Q) da suka cika ka'idodin da aka bayyana.\n\n    Aikin yana zagayawa ta dukkan masu yiwuwa 'a' na rabo 'y0 / x0'. Ga kowane mai 'a',\n    yana ƙididdige mai daidai 'b' ta yadda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b'\n    suna da juna (GCD nasu shine 1) domin P da Q za su iya zama sau biyu na 'x0' ta hanyar masu da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\n    Misalan Hali:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "hi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    उन युग्मों (P, Q) की संख्या गिनता है जिनके लिए P और Q का x0 उनका महत्तम समापवर्तक (GCD) है\n    और y0 उनका लघुत्तम समापवर्त्य (LCM) है।\n\n    Args:\n    x0 (int): वह GCD जो प्रत्येक युग्म (P, Q) के पास होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक युग्म (P, Q) के पास होना चाहिए।\n\n    Returns:\n    int: सभी संभावित युग्मों (P, Q) की संख्या जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    यह फ़ंक्शन 'y0 / x0' के भागफल के सभी संभावित गुणकों 'a' के माध्यम से पुनरावृत्ति करता है। प्रत्येक गुणक 'a' के लिए,\n    यह संबंधित गुणक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं या नहीं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणकों के सह-प्राइम गुणकों द्वारा ही हो सकते हैं\n    ताकि GCD 'x0' बना रहे। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती को 1 से बढ़ाया जाता है यदि 'a' और 'b' समान हैं,\n    अन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों युग्मों के लिए खाता हो।\n\n    उदाहरण मामले:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\"",
      "hu": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Megszámolja azon pozitív egész szám párok (P, Q) számát, amelyekre P és Q legnagyobb közös osztója (GCD) x0,\n    és legkisebb közös többszöröse (LCM) y0.\n\n    Paraméterek:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\n    Visszatér:\n    int: Az összes lehetséges (P, Q) pár száma, amelyek megfelelnek a megadott kritériumoknak.\n\n    A függvény végigmegy az összes lehetséges 'a' tényezőn, amely a 'y0 / x0' hányados tényezője. Minden 'a' tényezőhöz\n    kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e\n    (azaz a GCD-jük 1), mert P és Q csak akkor lehetnek 'x0' többszörösei, ha relatív prím tényezőkkel rendelkeznek, hogy\n    a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, akkor a számlálót 1-gyel növeli, ha 'a' megegyezik 'b'-vel,\n    ellenkező esetben 2-vel, hogy mind a (P, Q), mind a (Q, P) párokat figyelembe vegye.\n\n    Példa esetek:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9627740843991085",
      "hy": "0.970855758712275",
      "bn": "0.9511726797340038",
      "bg": "0.9772488761562639",
      "zh": "0.9435782457455159",
      "fr": "0.9796395914223999",
      "de": "0.973685447120498",
      "ha": "0.9604471294852848",
      "hi": "0.9523084482527613",
      "hu": "0.9307274559837017"
    },
    "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count",
    "instruction": {
      "en": "Write a python function 'def count_coprime_pairs(x0: int, y0: int) -> int:' to solve the following problem:\n\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ",
      "sq": "Shkruani një funksion python 'def count_coprime_pairs(x0: int, y0: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si pjesëtuesin më të madh të përbashkët (GCD)\n    dhe y0 si shumëfishin më të vogël të përbashkët (LCM).\n\n    Args:\n    x0 (int): GCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkë-prime (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorët bashkë-prime për të ruajtur\n    GCD si 'x0'. Nëse 'a' dhe 'b' janë bashkë-prime, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të llogaritur të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj Rastesh:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "hy": "Պայթոն ֆունկցիա 'def count_coprime_pairs(x0: int, y0: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես որ P և Q ունեն x0 որպես իրենց ամենամեծ ընդհանուր բաժանարար (GCD)\n    և y0 որպես իրենց ամենափոքր ընդհանուր բազմապատիկ (LCM):\n\n    Արգումենտներ:\n    x0 (int): GCD, որը յուրաքանչյուր զույգ (P, Q) պետք է ունենա:\n    y0 (int): LCM, որը յուրաքանչյուր զույգ (P, Q) պետք է ունենա:\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին:\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանման բոլոր հնարավոր գործոններով 'a':ի։ Յուրաքանչյուր գործոնի 'a' համար,\n    այն հաշվարկում է համապատասխան գործոնը 'b', այնպես որ 'a * b = y0 / x0':ի։ Այնուհետև ստուգում է, արդյոք 'a' և 'b'\n    համապրիմ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են լինել միայն 'x0'-ի բազմապատիկներ համապրիմ գործոններով՝ պահպանելու համար\n    GCD-ն որպես 'x0':ի։ Եթե 'a' և 'b' համապրիմ են, հաշվարկը ավելացվում է 1-ով, եթե 'a' նույնն է 'b'-ի հետ,\n    այլապես 2-ով՝ հաշվի առնելով թե (P, Q), թե (Q, P) զույգերը:\n\n    Օրինակ դեպքեր:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "bn": "একটি পাইথন ফাংশন 'def count_coprime_pairs(x0: int, y0: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ধনাত্মক পূর্ণসংখ্যার (P, Q) জোড়ার সংখ্যা গণনা করে যেখানে P এবং Q এর x0 তাদের সর্বাধিক সাধারণ বিভাজক (GCD) \n    এবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\n    Args:\n    x0 (int): GCD যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n\n    Returns:\n    int: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি 'y0 / x0' এর সমস্ত সম্ভাব্য গুণক 'a' এর মাধ্যমে পুনরাবৃত্তি করে। প্রতিটি গুণক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে যে 'a' এবং 'b'\n    সহমিলিত (তাদের GCD 1) কিনা কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমিলিত গুণকের মাধ্যমে GCD \n    'x0' বজায় রাখতে। যদি 'a' এবং 'b' সহমিলিত হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' একই হয়,\n    অন্যথায় 2 দ্বারা বৃদ্ধি পায় যাতে উভয় (P, Q) এবং (Q, P) জোড়া গণনা করা হয়।\n\n    উদাহরণ কেস:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "bg": "Напишете Python функция 'def count_coprime_pairs(x0: int, y0: int) -> int:', за да решите следния проблем:\n\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като техен най-малък общ кратен (НОК).\n\n    Аргументи:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Връща:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни фактори 'a' на частното 'y0 / x0'. За всеки фактор 'a',\n    изчислява съответния фактор 'b', така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости фактори, за да се запази\n    НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "zh": "编写一个 Python 函数 'def count_coprime_pairs(x0: int, y0: int) -> int:' 来解决以下问题：\n\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的 GCD。\n    y0 (int): 每对 (P, Q) 必须具有的 LCM。\n\n    返回:\n    int: 满足指定条件的所有可能的 (P, Q) 对的数量。\n\n    函数遍历商 'y0 / x0' 的所有可能因子 'a'。对于每个因子 'a'，\n    它计算相应的因子 'b'，使得 'a * b = y0 / x0'。然后检查 'a' 和 'b'\n    是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的互质因子的倍数，以保持\n    GCD 为 'x0'。如果 'a' 和 'b' 是互质的，计数增加 1 如果 'a' 等于 'b'，\n    否则增加 2 以考虑 (P, Q) 和 (Q, P) 对。\n\n    示例案例：\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "fr": "Écrivez une fonction python 'def count_coprime_pairs(x0: int, y0: int) -> int:' pour résoudre le problème suivant :\n\n    Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q ont x0 comme leur plus grand diviseur commun (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction itère à travers tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\n    le PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compte est incrémenté de 1 si 'a' est le même que 'b',\n    sinon de 2 pour tenir compte des deux paires (P, Q) et (Q, P).\n\n    Cas d'exemple :\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "de": "Schreiben Sie eine Python-Funktion 'def count_coprime_pairs(x0: int, y0: int) -> int:', um das folgende Problem zu lösen:\n\n    Zählt die Anzahl der Paare positiver Ganzzahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD)\n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Argumente:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Das LCM, das jedes Paar (P, Q) haben muss.\n\n    Rückgabe:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Dann wird überprüft, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um\n    den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist,\n    andernfalls um 2, um sowohl die Paare (P, Q) als auch (Q, P) zu berücksichtigen.\n\n    Beispiel-Fälle:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "ha": "Rubuta wani aikin python 'def count_coprime_pairs(x0: int, y0: int) -> int:' don warware matsalar mai zuwa:\n\n    Yana ƙidaya adadin ma'aurata na lambobin integers masu kyau (P, Q) ta yadda P da Q suna da x0 a matsayin babbar mai raba su (GCD)\n    kuma y0 a matsayin ƙaramin ƙa'idar su (LCM).\n\n    Args:\n    x0 (int): GCD wanda kowace ma'aurata (P, Q) dole ne su kasance da shi.\n    y0 (int): LCM wanda kowace ma'aurata (P, Q) dole ne su kasance da shi.\n\n    Returns:\n    int: Adadin dukkan ma'aurata masu yiwuwa (P, Q) waɗanda suka cika ƙa'idodin da aka fayyace.\n\n    Aikin yana zagayawa ta dukkan yiwuwar abubuwan 'a' na rabo 'y0 / x0'. Ga kowane abu 'a',\n    yana ƙididdige abu mai dacewa 'b' ta yadda 'a * b = y0 / x0'. Sannan yana duba ko 'a' da 'b'\n    suna da juna (GCD ɗinsu shine 1) saboda P da Q na iya zama sau biyu na 'x0' kawai ta abubuwan da ba su da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\n    Misalan Hali:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "hi": "एक पायथन फ़ंक्शन 'def count_coprime_pairs(x0: int, y0: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    धनात्मक पूर्णांकों के जोड़ों (P, Q) की संख्या गिनें ताकि P और Q का x0 उनके महत्तम समापवर्तक (GCD) के रूप में हो\n    और y0 उनका लघुत्तम समापवर्त्य (LCM) हो।\n\n    तर्क:\n    x0 (int): वह GCD जो प्रत्येक जोड़े (P, Q) के पास होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक जोड़े (P, Q) के पास होना चाहिए।\n\n    लौटाता है:\n    int: सभी संभावित जोड़ों (P, Q) की गिनती जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    फ़ंक्शन सभी संभावित गुणनखंडों 'a' के माध्यम से y0 / x0 के भागफल की पुनरावृत्ति करता है। प्रत्येक गुणनखंड 'a' के लिए,\n    यह संबंधित गुणनखंड 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं (उनका GCD 1 है) क्योंकि P और Q केवल सह-प्राइम गुणनखंडों द्वारा 'x0' के गुणज हो सकते हैं ताकि\n    GCD को 'x0' बनाए रखा जा सके। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती को 1 से बढ़ाया जाता है यदि 'a' 'b' के समान है,\n    अन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों जोड़ों को शामिल किया जा सके।\n\n    उदाहरण मामले:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "hu": "Írj egy python függvényt 'def count_coprime_pairs(x0: int, y0: int) -> int:' a következő probléma megoldására:\n\n    Számolja meg a pozitív egész számok (P, Q) párosainak számát úgy, hogy P és Q legnagyobb közös osztója (GCD) x0,\n    és legkisebb közös többszöröse (LCM) y0.\n\n    Argumentumok:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\n    Visszatérési érték:\n    int: Az összes lehetséges (P, Q) pár száma, amely megfelel a megadott kritériumoknak.\n\n    A függvény végigmegy az összes lehetséges 'a' tényezőn a 'y0 / x0' hányados esetén. Minden 'a' tényezőhöz\n    kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b'\n    relatív prímek-e (GCD-jük 1), mert P és Q csak akkor lehetnek az 'x0' többszörösei, ha relatív prím tényezők,\n    hogy a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, a számlálót 1-gyel növeli, ha 'a' megegyezik 'b'-vel,\n    különben 2-vel, hogy mindkét (P, Q) és (Q, P) párt figyelembe vegye.\n\n    Példa esetek:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0"
    },
    "instruction_bertscore": {
      "sq": "0.9738721596786708",
      "hy": "0.9721742671815846",
      "bn": "0.9523271195085785",
      "bg": "0.9684618653600425",
      "zh": "0.9579745785021625",
      "fr": "0.979606420148767",
      "de": "0.9689989619103608",
      "ha": "0.9626302760032392",
      "hi": "0.9674542134370525",
      "hu": "0.9334653771558866"
    },
    "level": "easy",
    "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()",
    "entry_point": "count_coprime_pairs",
    "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:",
    "docstring": {
      "en": "\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0\n    ",
      "sq": "\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si maksimumin e tyre të përbashkët të plotë (GCD)\n    dhe y0 si minimumin e tyre të përbashkët të shumëfishtë (LCM).\n\n    Argumentet:\n    x0 (int): GCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkëkryesorë (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorë bashkëkryesorë për të ruajtur\n    GCD si 'x0'. Nëse 'a' dhe 'b' janë bashkëkryesorë, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të marrë parasysh të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj Rastesh:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "hy": "\n    Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես, որ P և Q ունենան x0 որպես իրենց ամենամեծ ընդհանուր բաժանարարը (GCD)\n    և y0 որպես իրենց ամենափոքր ընդհանուր բազմապատիկը (LCM):\n\n    Պարամետրեր:\n    x0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n    y0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին:\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանարարի բոլոր հնարավոր գործոններով 'a':ի միջոցով: Յուրաքանչյուր գործոնի համար 'a',\n    հաշվարկվում է համապատասխան գործոնը 'b', այնպես, որ 'a * b = y0 / x0':ին: Այնուհետև ստուգվում է, արդյոք 'a' և 'b'\n    համապրիմ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են միայն 'x0'-ի բազմապատիկներ լինել համապրիմ գործոններով՝ GCD-ն 'x0' պահելու համար:\n    Եթե 'a' և 'b' համապրիմ են, ապա քանակը ավելացվում է 1-ով, եթե 'a'-ն նույնն է 'b'-ի հետ,\n    այլապես 2-ով՝ հաշվի առնելով ինչպես (P, Q), այնպես էլ (Q, P) զույգերը:\n\n    Օրինակային դեպքեր:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "bn": "\n    (P, Q) জোড়ার সংখ্যা গণনা করে যেখানে P এবং Q এর সর্বাধিক সাধারণ গুণনীয়ক (GCD) x0 এবং সর্বনিম্ন সাধারণ গুণিতক (LCM) y0।\n\n    আর্গুমেন্ট:\n    x0 (int): GCD যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি জোড়া (P, Q) এর থাকতে হবে।\n\n    রিটার্নস:\n    int: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি 'y0 / x0' এর ভাগফলের সমস্ত সম্ভাব্য গুণনীয়ক 'a' এর মাধ্যমে পুনরাবৃত্তি করে। প্রতিটি গুণনীয়ক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণনীয়ক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে 'a' এবং 'b'\n    সহমৌলিক কিনা (তাদের GCD 1) কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমৌলিক গুণনীয়ক দ্বারা GCD\n    'x0' বজায় রাখতে। যদি 'a' এবং 'b' সহমৌলিক হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি করা হয় যদি 'a' এবং 'b' একই হয়,\n    অন্যথায় 2 দ্বারা বৃদ্ধি করা হয় (P, Q) এবং (Q, P) উভয় জোড়ার জন্য।\n\n    উদাহরণ কেস:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "bg": "\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като техен най-малък общ кратен (НОК).\n\n    Аргументи:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Връща:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни делители 'a' на частното 'y0 / x0'. За всеки делител 'a',\n    тя изчислява съответния делител 'b' така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости делители, за да се запази\n    НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "zh": "\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的 GCD。\n    y0 (int): 每对 (P, Q) 必须具有的 LCM。\n\n    返回:\n    int: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n    该函数遍历商 'y0 / x0' 的所有可能因数 'a'。对于每个因数 'a'，计算相应的因数 'b'，使得 'a * b = y0 / x0'。\n    然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因数来保持\n    GCD 为 'x0'。如果 'a' 和 'b' 互质，计数增加 1（如果 'a' 和 'b' 相同），否则增加 2，以考虑 (P, Q) 和 (Q, P) 两种情况。\n\n    示例案例:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "fr": "\n    Compte le nombre de paires d'entiers positifs (P, Q) telles que P et Q aient x0 comme leur plus grand commun diviseur (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction itère à travers tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont premiers entre eux (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs\n    premiers entre eux pour maintenir le PGCD comme 'x0'. Si 'a' et 'b' sont premiers entre eux, le compte est\n    incrémenté de 1 si 'a' est le même que 'b', sinon de 2 pour tenir compte des paires (P, Q) et (Q, P).\n\n    Cas d'exemple:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "de": "\n    Zählt die Anzahl der Paare positiver Ganzzahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD) \n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Args:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Der LCM, den jedes Paar (P, Q) haben muss.\n\n    Returns:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Sie prüft dann, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um \n    den GCD als 'x0' zu erhalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist,\n    andernfalls um 2, um sowohl für (P, Q) als auch (Q, P) Paare zu berücksichtigen.\n\n    Beispiel Fälle:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "ha": "\n    Yana kirga adadin ma'aurata na lambobin kirki (P, Q) inda P da Q suna da x0 a matsayin mafi girman abin da za a iya rabawa (GCD)\n    da y0 a matsayin mafi ƙarancin abin da za a iya ninkawa (LCM).\n\n    Args:\n    x0 (int): GCD wanda kowace ma'aurata (P, Q) dole ne su samu.\n    y0 (int): LCM wanda kowace ma'aurata (P, Q) dole ne su samu.\n\n    Returns:\n    int: Adadin dukkan ma'aurata masu yiwuwa (P, Q) da suka cika ka'idodin da aka fayyace.\n\n    Aikin yana zagayawa ta dukkan abubuwan da za a iya samu 'a' na rabon 'y0 / x0'. Ga kowane abu 'a',\n    yana lissafa abin da ya dace 'b' wanda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b'\n    suna da juna (GCD dinsu 1 ne) saboda P da Q za su iya kasancewa masu yawa na 'x0' ta hanyar abubuwan da ba su da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin ma'aurata biyu (P, Q) da (Q, P).\n\n    Misalan Lokuta:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "hi": "\n    गिनती करता है कि कितने जोड़े सकारात्मक पूर्णांक (P, Q) हैं जिनके लिए P और Q का x0 सबसे बड़ा सामान्य भाजक (GCD) है\n    और y0 उनका सबसे छोटा सामान्य गुणज (LCM) है।\n\n    तर्क:\n    x0 (int): वह GCD जो प्रत्येक जोड़े (P, Q) का होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक जोड़े (P, Q) का होना चाहिए।\n\n    वापसी:\n    int: सभी संभावित जोड़ों (P, Q) की गिनती जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    यह फ़ंक्शन सभी संभावित गुणकों 'a' के माध्यम से 'y0 / x0' के भागफल की पुनरावृत्ति करता है। प्रत्येक गुणक 'a' के लिए,\n    यह संबंधित गुणक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणकों के सह-प्राइम गुणकों से ही हो सकते हैं\n    ताकि GCD 'x0' बना रहे। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती में 1 की वृद्धि की जाती है यदि 'a' 'b' के समान है,\n    अन्यथा 2 की वृद्धि की जाती है ताकि दोनों (P, Q) और (Q, P) जोड़े शामिल हों।\n\n    उदाहरण मामले:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0",
      "hu": "\n    Megszámolja azon pozitív egész szám párok (P, Q) számát, amelyekre P és Q legnagyobb közös osztója (GCD) x0, \n    és legkisebb közös többszöröse (LCM) y0.\n\n    Paraméterek:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak meg kell felelnie.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak meg kell felelnie.\n\n    Visszatér:\n    int: Az összes lehetséges (P, Q) pár száma, amely megfelel a megadott feltételeknek.\n\n    A függvény végigmegy a 'y0 / x0' hányados összes lehetséges 'a' osztóján. Minden 'a' osztóhoz kiszámítja a megfelelő 'b' osztót úgy, \n    hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e (GCD-jük 1), mert P és Q csak akkor lehet 'x0' többszöröse, \n    ha relatív prím tényezők, hogy a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, a számláló 1-gyel nő, ha 'a' megegyezik 'b'-vel, \n    különben 2-vel, hogy mind a (P, Q), mind a (Q, P) párokat figyelembe vegye.\n\n    Példa esetek:\n\n    >>> count_coprime_pairs(3, 60)\n    4\n    >>> count_coprime_pairs(2, 50)\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9734242481694372",
      "hy": "0.9667526509312373",
      "bn": "0.9283802407710124",
      "bg": "0.9563732203702592",
      "zh": "0.9395214188432593",
      "fr": "0.973838789774657",
      "de": "0.970240997682972",
      "ha": "0.9454459672183869",
      "hi": "0.9524878114868358",
      "hu": "0.920133901871968"
    }
  },
  {
    "task_id": "Python/27",
    "prompt": {
      "en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "sq": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rikonstrukton pemën binare nga renditjet e saj inorder dhe postorder dhe\n    kthen renditjen preorder si një varg.\n\n    Args:\n    inorder (str): Renditja inorder e pemës binare.\n    postorder (str): Renditja postorder e pemës binare.\n\n    Returns:\n    str: Renditja preorder e pemës binare.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "hy": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Վերականգնում է բինար ծառը իր inorder և postorder շրջանցումներից և\n    վերադարձնում է preorder շրջանցումը որպես տող։\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder շրջանցումը։\n    postorder (str): Բինար ծառի postorder շրջանցումը։\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder շրջանցումը։\n\n    Օրինակ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "bn": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং\n    প্রিঅর্ডার ট্রাভার্সাল একটি স্ট্রিং হিসেবে প্রদান করে।\n\n    প্যারামিটার:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    রিটার্নস:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    উদাহরণ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "bg": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Възстановява двоичното дърво от неговите обходи по ред на възход и низход\n    и връща обхода по предред като низ.\n\n    Аргументи:\n    inorder (str): Обходът по възход на двоичното дърво.\n    postorder (str): Обходът по низход на двоичното дърво.\n\n    Връща:\n    str: Обходът по предред на двоичното дърво.\n\n    Пример:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "zh": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    从中序遍历和后序遍历重建二叉树，并返回前序遍历作为字符串。\n\n    参数:\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回:\n    str: 二叉树的前序遍历。\n\n    示例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "fr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruit l'arbre binaire à partir de ses parcours inorder et postorder et\n    renvoie le parcours preorder sous forme de chaîne.\n\n    Args:\n    inorder (str): Le parcours inorder de l'arbre binaire.\n    postorder (str): Le parcours postorder de l'arbre binaire.\n\n    Returns:\n    str: Le parcours preorder de l'arbre binaire.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "de": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des Binärbaums.\n    postorder (str): Die Postorder-Traversierung des Binärbaums.\n\n    Rückgabewert:\n    str: Die Preorder-Traversierung des Binärbaums.\n\n    Beispiel:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "ha": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Sake gina itacen binary daga hanyoyin inorder da postorder kuma\n    ya dawo da hanyar preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Hanyar inorder na itacen binary.\n    postorder (str): Hanyar postorder na itacen binary.\n\n    Returns:\n    str: Hanyar preorder na itacen binary.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "hi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से बाइनरी ट्री को पुनर्निर्मित करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    Args:\n    inorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\n    Returns:\n    str: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\"",
      "hu": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Újjáépíti a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást sztringként.\n\n    Paraméterek:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Visszatér:\n    str: A bináris fa preorder bejárása.\n\n    Példa:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9857822359559038",
      "bn": "0.9617988092282272",
      "bg": "1",
      "zh": "0.9867424152178264",
      "fr": "1",
      "de": "1",
      "ha": "0.9895047679268786",
      "hi": "0.9936253551814473",
      "hu": "0.994790520996598"
    },
    "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder",
    "instruction": {
      "en": "Write a python function 'def preorder_traversal(inorder: str, postorder: str) -> str:' to solve the following problem:\n\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    ",
      "sq": "Shkruani një funksion python 'def preorder_traversal(inorder: str, postorder: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Rikonstrukton pemën binare nga renditjet e saj inorder dhe postorder dhe\n    kthen renditjen preorder si një varg.\n\n    Argumentet:\n    inorder (str): Renditja inorder e pemës binare.\n    postorder (str): Renditja postorder e pemës binare.\n\n    Kthen:\n    str: Renditja preorder e pemës binare.\n\n    Shembull:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "hy": "Պայթոն ֆունկցիա 'def preorder_traversal(inorder: str, postorder: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Վերականգնում է բինար ծառը իր inorder և postorder անցումներից և\n    վերադարձնում է preorder անցումը որպես տող:\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder անցումը:\n    postorder (str): Բինար ծառի postorder անցումը:\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder անցումը:\n\n    Օրինակ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "bn": "একটি পাইথন ফাংশন 'def preorder_traversal(inorder: str, postorder: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং\n    প্রিঅর্ডার ট্রাভার্সালকে একটি স্ট্রিং হিসাবে ফেরত দেয়।\n\n    আর্গুমেন্টসমূহ:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    ফেরত দেয়:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    উদাহরণ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "bg": "Напишете Python функция 'def preorder_traversal(inorder: str, postorder: str) -> str:' за да решите следния проблем:\n\n    Възстановява двоичното дърво от неговите inorder и postorder обхождания и\n    връща preorder обхождането като низ.\n\n    Аргументи:\n    inorder (str): Inorder обхождането на двоичното дърво.\n    postorder (str): Postorder обхождането на двоичното дърво.\n\n    Връща:\n    str: Preorder обхождането на двоичното дърво.\n\n    Пример:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "zh": "编写一个python函数 'def preorder_traversal(inorder: str, postorder: str) -> str:' 来解决以下问题：\n\n    从中序和后序遍历重建二叉树，并返回前序遍历作为字符串。\n\n    参数：\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回：\n    str: 二叉树的前序遍历。\n\n    示例：\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "fr": "Écrivez une fonction python 'def preorder_traversal(inorder: str, postorder: str) -> str:' pour résoudre le problème suivant :\n\n    Reconstruit l'arbre binaire à partir de ses parcours inorder et postorder et\n    renvoie le parcours preorder sous forme de chaîne.\n\n    Arguments :\n    inorder (str): Le parcours inorder de l'arbre binaire.\n    postorder (str): Le parcours postorder de l'arbre binaire.\n\n    Renvoie :\n    str: Le parcours preorder de l'arbre binaire.\n\n    Exemple :\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "de": "Schreiben Sie eine Python-Funktion 'def preorder_traversal(inorder: str, postorder: str) -> str:', um das folgende Problem zu lösen:\n\n    Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des Binärbaums.\n    postorder (str): Die Postorder-Traversierung des Binärbaums.\n\n    Rückgabe:\n    str: Die Preorder-Traversierung des Binärbaums.\n\n    Beispiel:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "ha": "Rubuta wani aikin python 'def preorder_traversal(inorder: str, postorder: str) -> str:' don warware matsalar mai zuwa:\n\n    Sake gina itacen binary daga hanyoyin inorder da postorder kuma\n    ya mayar da hanyoyin preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Hanyar inorder na itacen binary.\n    postorder (str): Hanyar postorder na itacen binary.\n\n    Returns:\n    str: Hanyar preorder na itacen binary.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "hi": "एक पायथन फ़ंक्शन 'def preorder_traversal(inorder: str, postorder: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    इसकी इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल्स से बाइनरी ट्री का पुनर्निर्माण करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    तर्क:\n    inorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\n    लौटाता है:\n    str: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\n    उदाहरण:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "hu": "Írj egy Python függvényt 'def preorder_traversal(inorder: str, postorder: str) -> str:' a következő probléma megoldására:\n\n    Rekonstruálja a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást egy karakterláncként.\n\n    Argumentumok:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Visszatér:\n    str: A bináris fa preorder bejárása.\n\n    Példa:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9969357291117747",
      "bn": "0.9800936604734456",
      "bg": "0.9861280514492855",
      "zh": "0.9889764111133258",
      "fr": "0.9952038708195315",
      "de": "1",
      "ha": "0.9925571209922417",
      "hi": "0.9846915565336412",
      "hu": "0.9856779550058604"
    },
    "level": "hard",
    "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()",
    "entry_point": "preorder_traversal",
    "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:",
    "docstring": {
      "en": "\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'\n    ",
      "sq": "\n    Rikonstrukton pemën binare nga renditja e saj në rendin e mesëm dhe pas renditjes së saj dhe\n    kthen renditjen para renditjes si një varg.\n\n    Args:\n    inorder (str): Renditja në rendin e mesëm e pemës binare.\n    postorder (str): Renditja pas renditjes e pemës binare.\n\n    Returns:\n    str: Renditja para renditjes e pemës binare.\n\n    Example:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "hy": "\n    Վերակառուցում է բինար ծառը իր inorder և postorder շրջագայություններից և\n    վերադարձնում է preorder շրջագայությունը որպես տող:\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder շրջագայությունը:\n    postorder (str): Բինար ծառի postorder շրջագայությունը:\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder շրջագայությունը:\n\n    Օրինակ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "bn": "\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং \n    প্রিঅর্ডার ট্রাভার্সালকে একটি স্ট্রিং হিসেবে ফেরত দেয়।\n\n    আর্গুমেন্টসমূহ:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    রিটার্নস:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    উদাহরণ:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "bg": "\n    Възстановява бинарното дърво от неговите обходи по ред на възлите и след реда на възлите и\n    връща обхода по предред като низ.\n\n    Аргументи:\n    inorder (str): Обходът по ред на възлите на бинарното дърво.\n    postorder (str): Обходът след реда на възлите на бинарното дърво.\n\n    Връща:\n    str: Обходът по предред на бинарното дърво.\n\n    Пример:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "zh": "\n    从中序和后序遍历重建二叉树，并以字符串形式返回前序遍历。\n\n    参数:\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回:\n    str: 二叉树的前序遍历。\n\n    示例:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "fr": "\n    Reconstruit l'arbre binaire à partir de ses parcours en ordre et en post-ordre et\nretourne le parcours en pré-ordre sous forme de chaîne.\n\nParamètres:\ninorder (str): Le parcours en ordre de l'arbre binaire.\npostorder (str): Le parcours en post-ordre de l'arbre binaire.\n\nRetourne:\nstr: Le parcours en pré-ordre de l'arbre binaire.\n\nExemple:\n>>> preorder_traversal('BADC', 'BDCA')\n'ABCD'\n>>> preorder_traversal('A', 'A')\n'A'",
      "de": "\n    Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des Binärbaums.\n    postorder (str): Die Postorder-Traversierung des Binärbaums.\n\n    Rückgabe:\n    str: Die Preorder-Traversierung des Binärbaums.\n\n    Beispiel:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "ha": "\n    Sake gina itacen binary daga hanyoyin inorder da postorder sannan\n    ya dawo da hanyar preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Hanyar inorder na itacen binary.\n    postorder (str): Hanyar postorder na itacen binary.\n\n    Returns:\n    str: Hanyar preorder na itacen binary.\n\n    Misali:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "hi": "\n    इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से बाइनरी ट्री को पुनर्निर्मित करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    तर्क:\n    inorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\n    रिटर्न्स:\n    str: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\n    उदाहरण:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'",
      "hu": "\n    Újjáépíti a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást egy karakterláncként.\n\n    Paraméterek:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Visszatér:\n    str: A bináris fa preorder bejárása.\n\n    Példa:\n    >>> preorder_traversal('BADC', 'BDCA')\n    'ABCD'\n    >>> preorder_traversal('A', 'A')\n    'A'"
    },
    "docstring_bertscore": {
      "sq": "0.9981980251832515",
      "hy": "0.99660083828935",
      "bn": "0.9731815218438125",
      "bg": "1",
      "zh": "0.9836455689471114",
      "fr": "0.9803262566496375",
      "de": "1",
      "ha": "0.9853273723833339",
      "hi": "0.9711622453902118",
      "hu": "0.9852371941903441"
    }
  },
  {
    "task_id": "Python/28",
    "prompt": {
      "en": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "sq": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Kryej transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg të synuar B, së bashku me një listë\n    rregullash transformimi, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm Kërkimi në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të kërkuar. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu i synuar që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\n                            që përmban nënvargun burim (që do të zëvendësohet) dhe\n                            nënvargun synim (me të cilin do të zëvendësohet).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "hy": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Կատարել տողերի փոխակերպում A-ից դեպի B օգտագործելով փոխակերպման կանոնների հավաքածու։\n\n    Այս ֆունկցիան վերցնում է սկզբնական A տողը և նպատակային B տողը, ինչպես նաև փոխակերպման\n    կանոնների ցուցակը, և փորձում է փոխակերպել A-ն դեպի B օգտագործելով այդ կանոնները։\n    Լայնության առաջին որոնման (BFS) ալգորիթմը օգտագործվում է հնարավոր փոխակերպումները\n    ուսումնասիրելու համար մինչև առավելագույնը 10 քայլ։ Եթե A-ն հնարավոր է փոխակերպել B-ի\n    10 քայլից պակասում, ֆունկցիան վերադարձնում է անհրաժեշտ նվազագույն քայլերի քանակը։\n    Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\"։\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի։\n    B (str): Նպատակային տողը, որը պետք է ստացվի։\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որը պետք է փոխարինի)։\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\"։\n\n    Օրինակներ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "bn": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    একটি সেট রূপান্তর নিয়ম ব্যবহার করে A থেকে B এ স্ট্রিং রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, \n    সাথে একটি রূপান্তর নিয়মের তালিকা, এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে।\n    একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি \n    সর্বাধিক 10 ধাপ পর্যন্ত অনুসন্ধান করতে। যদি A কে 10 ধাপের মধ্যে B তে রূপান্তর করা যায়, \n    তাহলে ফাংশনটি প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা প্রদান করে। যদি এটি সম্ভব না হয়, \n    তাহলে ফাংশনটি \"NO ANSWER!\" প্রদান করে।\n\n    Parameters:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টিউপল \n                            হিসেবে থাকে যা উৎস সাবস্ট্রিং (যা প্রতিস্থাপিত হবে) এবং \n                            লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে) ধারণ করে।\n\n    Returns:\n    Union[int, str]: যদি সম্ভব হয় তাহলে রূপান্তরের সর্বনিম্ন ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "bg": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Извършва трансформация на низ от A към B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация,\n    и се опитва да трансформира A в B, използвайки правилата.\n    Използва се алгоритъм за обхождане в ширина (BFS), за да се изследват възможните трансформации\n    до максимум 10 стъпки. Ако A може да бъде трансформирано в B в рамките на 10 стъпки, функцията\n    връща минималния брой необходими стъпки. Ако това не е възможно, функцията връща\n    \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който трябва да бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж,\n                            съдържащ изходния подниз (който да бъде заменен) и\n                            целевия подниз (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "zh": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    使用一组转换规则从 A 转换为 B 的字符串转换。\n\n    该函数接受一个初始字符串 A 和一个目标字符串 B，以及一个转换规则列表，\n    并尝试使用这些规则将 A 转换为 B。\n    使用广度优先搜索 (BFS) 算法来探索可能的转换，最多进行 10 步。\n    如果 A 能在 10 步内转换为 B，函数返回所需的最小步骤数。\n    如果不可能，函数返回 \"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要达到的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换）和\n                            目标子字符串（用于替换）的元组。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小的转换步骤数，否则返回 \"NO ANSWER!\"。\n\n    示例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "fr": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    retourne le nombre minimum d'étapes requises. Si ce n'est pas possible, la fonction retourne\n    \"NO ANSWER!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (pour remplacer).\n\n    Retourne:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"NO ANSWER!\".\n\n    Exemples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "de": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Führe eine Zeichenkettenumwandlung von A nach B unter Verwendung eines Satzes von Umwandlungsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B sowie eine Liste\n    von Umwandlungsregeln und versucht, A unter Verwendung der Regeln in B umzuwandeln.\n    Ein Breadth-First Search (BFS)-Algorithmus wird verwendet, um die möglichen Umwandlungen\n    bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B\n    umgewandelt werden kann, gibt die Funktion die minimale Anzahl der erforderlichen Schritte zurück.\n    Wenn es nicht möglich ist, gibt die Funktion \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die umgewandelt werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Umwandlungsregeln, wobei jede Regel ein Tupel ist,\n                            das das Quell-Substring (das ersetzt werden soll) und das\n                            Ziel-Substring (mit dem ersetzt wird) enthält.\n\n    Rückgabe:\n    Union[int, str]: Die minimale Anzahl der Umwandlungsschritte, falls möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "ha": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Yi canjin kirtani daga A zuwa B ta amfani da saitin dokokin canji.\n\n    Wannan aikin yana ɗaukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin canji, kuma yana ƙoƙarin canza A zuwa B ta amfani da dokokin.\n    Ana amfani da algorithm na Breadth-First Search (BFS) don bincika yiwuwar canje-canje\n    har zuwa matakai 10 na iyaka. Idan za a iya canza A zuwa B cikin matakai 10, aikin\n    zai dawo da mafi ƙarancin adadin matakan da ake buƙata. Idan ba zai yiwu ba, aikin zai dawo\n    da \"NO ANSWER!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a canza.\n    B (str): Kirtani na manufa da za a cimma.\n    rules (list of tuples): Jerin dokokin canji, inda kowanne doka yake da\n                            kirtani na asali (da za a maye gurbin) da\n                            kirtani na manufa (da za a maye gurbin da shi).\n\n    Komawa:\n    Union[int, str]: Mafi ƙarancin adadin matakan canji idan zai yiwu, in ba haka ba \"NO ANSWER!\".\n\n    Misalai:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "hi": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    एक सेट के परिवर्तन नियमों का उपयोग करके A से B तक स्ट्रिंग परिवर्तन करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही परिवर्तन नियमों की एक सूची,\n    और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिथ्म का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): प्रारंभिक स्ट्रिंग जिसे परिवर्तित करना है।\n    B (str): लक्ष्य स्ट्रिंग जिसे प्राप्त करना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहां प्रत्येक नियम एक ट्यूपल होता है\n                            जिसमें स्रोत सबस्ट्रिंग (जिसे बदला जाना है) और\n                            लक्ष्य सबस्ट्रिंग (जिससे बदलना है) शामिल होता है।\n\n    रिटर्न्स:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\"",
      "hu": "from collections import deque\nfrom typing import Union\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Sztring transzformáció végrehajtása A-ból B-be egy halmaz transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A sztringet és egy cél B sztringet vesz át, valamint egy listát\n    a transzformációs szabályokkal, és megpróbálja A-t B-vé alakítani a szabályok segítségével.\n    Egy Szélességi Első Keresés (BFS) algoritmust használunk a lehetséges transzformációk\n    felfedezésére legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\n    visszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény visszaadja\n    a \"NO ANSWER!\" szöveget.\n\n    Paraméterek:\n    A (str): A kezdeti sztring, amelyet át kell alakítani.\n    B (str): A cél sztring, amelyet el kell érni.\n    rules (list of tuples): Egy lista a transzformációs szabályokról, ahol minden szabály egy\n                            forrás részsztringet tartalmaz (amit le kell cserélni) és a\n                            cél részsztringet (amire le kell cserélni).\n\n    Visszatérési érték:\n    Union[int, str]: A minimális transzformációs lépések száma, ha lehetséges, különben \"NO ANSWER!\".\n\n    Példák:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9869477990318165",
      "hy": "0.9857365509682657",
      "bn": "0.9882551841997881",
      "bg": "0.9825088072764487",
      "zh": "0.9763981422342914",
      "fr": "0.9814886416394536",
      "de": "0.9893182539990868",
      "ha": "0.9701337372772132",
      "hi": "0.9786815970946685",
      "hu": "0.9838302952014739"
    },
    "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"",
    "instruction": {
      "en": "Write a python function 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' to solve the following problem:\n\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    ",
      "sq": "Shkruani një funksion python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' për të zgjidhur problemin e mëposhtëm:\n\n    Kryeni transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg objektiv B, së bashku me një listë\n    të rregullave të transformimit, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm i Kërkimit në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të nevojshëm. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu objektiv që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\n                            që përmban nënvargun burim (që do të zëvendësohet) dhe\n                            nënvargun objektiv (për të zëvendësuar me).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "hy": "Պայթոն ֆունկցիա 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Կատարել տողի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու:\n\n    Այս ֆունկցիան ընդունում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման\n    կանոնների ցուցակ և փորձում է փոխակերպել A-ն B-ի՝ օգտագործելով այդ կանոնները:\n    Լայնության-առաջին որոնման (BFS) ալգորիթմը օգտագործվում է հնարավոր փոխակերպումները\n    ուսումնասիրելու համար առավելագույնը 10 քայլով: Եթե A-ն կարող է փոխակերպվել B-ի 10 քայլի\n    ընթացքում, ֆունկցիան վերադարձնում է անհրաժեշտ նվազագույն քայլերի քանակը: Եթե դա հնարավոր չէ,\n    ֆունկցիան վերադարձնում է \"NO ANSWER!\":\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի:\n    B (str): Նպատակային տողը, որը պետք է ստացվի:\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուրի ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որով պետք է փոխարինել):\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\":\n\n    Օրինակներ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "bn": "একটি পাইথন ফাংশন 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    একটি সেট ট্রান্সফরমেশন নিয়ম ব্যবহার করে A থেকে B তে স্ট্রিং রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, \n    সাথে একটি ট্রান্সফরমেশন নিয়মের তালিকা, এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে।\n    একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে \n    সর্বাধিক 10 ধাপ পর্যন্ত। যদি A কে 10 ধাপের মধ্যে B তে রূপান্তর করা যায়, তাহলে ফাংশনটি \n    প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দেয়। যদি এটি সম্ভব না হয়, তাহলে ফাংশনটি \n    \"NO ANSWER!\" ফেরত দেয়।\n\n    Parameters:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): একটি ট্রান্সফরমেশন নিয়মের তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল\n                            ধারণ করে উৎস সাবস্ট্রিং (যা প্রতিস্থাপিত হবে) এবং\n                            লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে)।\n\n    Returns:\n    Union[int, str]: যদি সম্ভব হয় তাহলে রূপান্তরের সর্বনিম্ন ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "bg": "Напишете Python функция 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' за решаване на следния проблем:\n\n    Извършете трансформация на низ от A към B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък\n    от правила за трансформация, и се опитва да трансформира A в B, използвайки правилата.\n    Алгоритъм за обхождане в ширина (BFS) се използва за изследване на възможните трансформации\n    до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките на 10 стъпки, функцията\n    връща минималния брой необходими стъпки. Ако не е възможно, функцията връща\n    \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който ще бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък с правила за трансформация, където всяко правило е кортеж,\n                            съдържащ изходния подниз (който ще бъде заменен) и\n                            целевия подниз (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "zh": "编写一个Python函数 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' 来解决以下问题：\n\n    使用一组转换规则从A到B执行字符串转换。\n\n    此函数接受初始字符串A和目标字符串B，以及转换规则列表，并尝试使用这些规则将A转换为B。\n    使用广度优先搜索（BFS）算法来探索可能的转换，最多10步。\n    如果A可以在10步内转换为B，函数返回所需的最小步骤数。如果不可能，函数返回\"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要达到的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个元组，包含源子字符串（要替换的）和目标子字符串（用于替换的）。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小的转换步骤数，否则返回\"NO ANSWER!\"。\n\n    示例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "fr": "Écrivez une fonction python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' pour résoudre le problème suivant :\n\n    Effectuer la transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    renvoie le nombre minimum d'étapes nécessaires. Si ce n'est pas possible, la fonction renvoie\n    \"NO ANSWER!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (par laquelle remplacer).\n\n    Renvoie:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"NO ANSWER!\".\n\n    Exemples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "de": "Schreiben Sie eine Python-Funktion 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' um das folgende Problem zu lösen:\n\n    Führen Sie eine Zeichenkettenumwandlung von A zu B unter Verwendung eines Satzes von Umwandlungsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B, zusammen mit einer Liste\n    von Umwandlungsregeln, und versucht, A mithilfe der Regeln in B umzuwandeln.\n    Ein Breadth-First Search (BFS)-Algorithmus wird verwendet, um die möglichen Umwandlungen\n    bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B umgewandelt werden kann, gibt die Funktion\n    die minimale Anzahl der erforderlichen Schritte zurück. Wenn es nicht möglich ist, gibt die Funktion\n    \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die umgewandelt werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Umwandlungsregeln, wobei jede Regel ein Tupel ist,\n                            das das Quell-Substring (das ersetzt werden soll) und das\n                            Ziel-Substring (mit dem ersetzt werden soll) enthält.\n\n    Rückgabe:\n    Union[int, str]: Die minimale Anzahl der Umwandlungsschritte, wenn möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "ha": "Rubuta wani aikin python 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' don warware matsalar mai zuwa:\n\n    Yi sauyin kirtani daga A zuwa B ta amfani da saitin dokokin sauyi.\n\n    Wannan aikin yana ɗaukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin sauyi, kuma yana ƙoƙarin sauya A zuwa B ta amfani da dokokin.\n    Ana amfani da wani algorithm na Bincike na Farko (BFS) don bincika yiwuwar sauye-sauye\n    har zuwa matakai 10 mafi girma. Idan za a iya sauya A zuwa B cikin matakai 10, aikin\n    yana dawowa da adadin matakan da ake bukata. Idan ba zai yiwu ba, aikin yana dawowa\n    \"BA AMSA!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a sauya.\n    B (str): Kirtani na manufa da za a cimma.\n    rules (list of tuples): Jerin dokokin sauyi, inda kowanne doka yake da tuple\n                            dauke da kirtani na asali (da za a maye gurbinsa) da\n                            kirtani na manufa (da za a maye gurbinsa da shi).\n\n    Returns:\n    Union[int, str]: Mafi ƙarancin adadin matakan sauyi idan zai yiwu, in ba haka ba \"BA AMSA!\".\n\n    Misalai:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'BA AMSA!'",
      "hi": "एक पायथन फ़ंक्शन 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    परिवर्तन नियमों के सेट का उपयोग करके A से B तक स्ट्रिंग परिवर्तन करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही \n    परिवर्तन नियमों की एक सूची, और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन \n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन \n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): प्रारंभिक स्ट्रिंग जिसे परिवर्तित किया जाना है।\n    B (str): लक्ष्य स्ट्रिंग जिसे प्राप्त किया जाना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहां प्रत्येक नियम एक टपल होता है\n                            जिसमें स्रोत उपस्ट्रिंग (जिसे बदला जाना है) और \n                            लक्ष्य उपस्ट्रिंग (जिससे बदलना है) होती है।\n\n    लौटाता है:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "hu": "Írj egy python függvényt 'def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:' a következő probléma megoldására:\n\n    Végezze el az A-ból B-be történő sztring transzformációt egy sor transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A sztringet és egy cél B sztringet vesz át, valamint egy listát\n    a transzformációs szabályokkal, és megpróbálja A-t B-vé alakítani a szabályok használatával.\n    Egy Szélességi Első Keresés (BFS) algoritmust használunk a lehetséges transzformációk\n    felfedezésére, legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\n    visszaadja a szükséges minimális lépésszámot. Ha nem lehetséges, a függvény\n    \"NO ANSWER!\"-t ad vissza.\n\n    Paraméterek:\n    A (str): Az átalakítandó kezdeti sztring.\n    B (str): Az elérendő cél sztring.\n    rules (list of tuples): Egy lista a transzformációs szabályokról, ahol minden szabály egy\n                            forrás részsztringet (amit ki kell cserélni) és egy\n                            cél részsztringet (amire ki kell cserélni) tartalmazó tuple.\n\n    Visszatérési érték:\n    Union[int, str]: A transzformációs lépések minimális száma, ha lehetséges, különben \"NO ANSWER!\".\n\n    Példák:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'"
    },
    "instruction_bertscore": {
      "sq": "0.9972823391266806",
      "hy": "0.9869019154137973",
      "bn": "0.9868254427170989",
      "bg": "0.9847785566405345",
      "zh": "0.9788760562377017",
      "fr": "0.9782990349807954",
      "de": "0.9953055695746215",
      "ha": "0.9707910052080576",
      "hi": "0.9832667808104779",
      "hu": "0.9894412062049475"
    },
    "level": "hard",
    "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()",
    "entry_point": "string_transformation",
    "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:",
    "docstring": {
      "en": "\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'\n    ",
      "sq": "\n    Kryeni transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg të synuar B, së bashku me një listë\n    rregullash transformimi, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm Kërkimi në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të nevojshëm. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu i synuar që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\n                            që përmban nënvargun burimor (që do të zëvendësohet) dhe\n                            nënvargun e synuar (me të cilin do të zëvendësohet).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "hy": "\n    Կատարել տողի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու։\n\n    Այս ֆունկցիան վերցնում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման կանոնների ցուցակ,\n    և փորձում է փոխակերպել A-ն B-ի՝ օգտագործելով այդ կանոնները։ Լայնության Առաջին Որոնման (BFS) ալգորիթմը\n    օգտագործվում է հնարավոր փոխակերպումները ուսումնասիրելու համար՝ առավելագույնը 10 քայլով։ Եթե A-ն հնարավոր է\n    փոխակերպել B-ի 10 քայլի ընթացքում, ֆունկցիան վերադարձնում է պահանջվող նվազագույն քայլերի քանակը։\n    Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\"։\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի։\n    B (str): Նպատակային տողը, որը պետք է ստացվի։\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որով պետք է փոխարինել)։\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\"։\n\n    Օրինակներ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "bn": "\n    একটি সেট রূপান্তর নিয়ম ব্যবহার করে স্ট্রিং A থেকে B এ রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, সাথে একটি রূপান্তর নিয়মের তালিকা,\n    এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে। একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম\n    ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে সর্বাধিক 10 ধাপ পর্যন্ত। যদি A কে 10 ধাপের মধ্যে B তে\n    রূপান্তর করা যায়, ফাংশনটি প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দেয়। যদি এটি সম্ভব না হয়, ফাংশনটি\n    \"NO ANSWER!\" ফেরত দেয়।\n\n    প্যারামিটারসমূহ:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টাপল\n                            যা উৎস সাবস্ট্রিং (প্রতিস্থাপন করতে হবে) এবং লক্ষ্য সাবস্ট্রিং\n                            (যা দিয়ে প্রতিস্থাপন করতে হবে) ধারণ করে।\n\n    রিটার্নস:\n    Union[int, str]: যদি সম্ভব হয় তবে রূপান্তরের সর্বনিম্ন ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    উদাহরণ:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "bg": "\n    Извършете трансформация на низ от A към B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация, и се опитва да трансформира A в B, използвайки правилата. Използва се алгоритъм за търсене в широчина (BFS), за да се изследват възможните трансформации до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките на 10 стъпки, функцията връща минималния брой необходими стъпки. Ако не е възможно, функцията връща \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който трябва да бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж, съдържащ изходния подниз (който да бъде заменен) и целевия подниз (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "zh": "\n    使用一组转换规则将字符串从A转换为B。\n\n    该函数接收一个初始字符串A和一个目标字符串B，以及一个转换规则列表，并尝试使用这些规则将A转换为B。\n    使用广度优先搜索(BFS)算法来探索可能的转换，最多进行10步。\n    如果A可以在10步内转换为B，函数返回所需的最小步骤数。\n    如果不可能转换，函数返回\"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要达到的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换的）和目标子字符串（用于替换）的元组。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小转换步骤数，否则返回\"NO ANSWER!\"。\n\n    示例:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "fr": "\n    Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    retourne le nombre minimum d'étapes requises. Si ce n'est pas possible, la fonction retourne\n    \"PAS DE RÉPONSE!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (pour remplacer).\n\n    Renvoie:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"PAS DE RÉPONSE!\".\n\n    Exemples:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "de": "\n    Führe eine Zeichenkettenumwandlung von A nach B unter Verwendung eines Satzes von Umwandlungsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B sowie eine Liste\n    von Umwandlungsregeln und versucht, A mithilfe der Regeln in B umzuwandeln.\n    Ein Breadth-First Search (BFS) Algorithmus wird verwendet, um die möglichen Umwandlungen\n    bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B\n    umgewandelt werden kann, gibt die Funktion die minimale Anzahl der erforderlichen Schritte zurück.\n    Wenn es nicht möglich ist, gibt die Funktion \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die umgewandelt werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Umwandlungsregeln, wobei jede Regel ein Tupel ist,\n                            das das Quell-Teilzeichenkette (die ersetzt werden soll) und die\n                            Ziel-Teilzeichenkette (die ersetzt werden soll) enthält.\n\n    Rückgabe:\n    Union[int, str]: Die minimale Anzahl der Umwandlungsschritte, wenn möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "ha": "\n    Yi canjin kirtani daga A zuwa B ta amfani da saitin dokokin canji.\n\n    Wannan aikin yana daukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin canji, kuma yana ƙoƙarin canza A zuwa B ta amfani da dokokin.\n    Ana amfani da dabarar Binciken Farko (BFS) don bincika yiwuwar canje-canje\n    har zuwa matakai 10 na sama. Idan za a iya canza A zuwa B cikin matakai 10, aikin\n    yana mayar da adadin matakan da ake bukata. Idan ba zai yiwu ba, aikin yana mayar da\n    \"BA AMSA!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a canza.\n    B (str): Kirtani na manufa da za a cimma.\n    dokoki (jerin tuples): Jerin dokokin canji, inda kowace doka take da tuple\n                           wanda ke dauke da kirtani na asali (da za a maye gurbin) da\n                           kirtani na manufa (da za a maye gurbinsa da shi).\n\n    Komawa:\n    Union[int, str]: Mafi karancin adadin matakan canji idan zai yiwu, in ba haka ba \"BA AMSA!\".\n\n    Misalai:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "hi": "\n    A से B में स्ट्रिंग परिवर्तन एक सेट के परिवर्तन नियमों का उपयोग करके करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही परिवर्तन नियमों की एक सूची,\n    और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): प्रारंभिक स्ट्रिंग जिसे परिवर्तित किया जाना है।\n    B (str): लक्ष्य स्ट्रिंग जिसे प्राप्त किया जाना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम एक युग्म है\n                            जिसमें स्रोत उपस्ट्रिंग (जिसे बदला जाना है) और\n                            लक्ष्य उपस्ट्रिंग (जिससे बदला जाएगा) शामिल है।\n\n    रिटर्न्स:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'",
      "hu": "\n    Végezze el az A sztring átalakítását B sztringgé egy halmaz transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A sztringet és egy cél B sztringet vesz át, valamint egy\n    transzformációs szabályok listáját, és megpróbálja A-t B-vé alakítani a szabályok\n    segítségével. Egy Szélességi Első Keresés (BFS) algoritmus kerül alkalmazásra a lehetséges\n    átalakítások felfedezésére legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé,\n    a függvény visszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény\n    \"NO ANSWER!\"-t ad vissza.\n\n    Paraméterek:\n    A (str): Az átalakítandó kezdeti sztring.\n    B (str): Az elérendő cél sztring.\n    rules (list of tuples): Egy lista transzformációs szabályokkal, ahol minden szabály egy\n                            olyan tuple, amely tartalmazza a forrás részsztringet (amit\n                            cserélni kell) és a cél részsztringet (amire cserélni kell).\n\n    Visszatér:\n    Union[int, str]: A minimális átalakítási lépések száma, ha lehetséges, ellenkező esetben \"NO ANSWER!\".\n\n    Példák:\n    >>> string_transformation(\"abcd\", \"xyz\", [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")])\n    3\n    >>> string_transformation(\"aaa\", \"bbbb\", [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")])\n    'NO ANSWER!'"
    },
    "docstring_bertscore": {
      "sq": "0.9915496676996327",
      "hy": "0.9837013840841823",
      "bn": "0.9890898290608967",
      "bg": "0.9868959565023664",
      "zh": "0.9612499934854278",
      "fr": "0.9801651674106181",
      "de": "0.988801020486872",
      "ha": "0.958404216016341",
      "hi": "0.9707866353396749",
      "hu": "0.9738048239795"
    }
  },
  {
    "task_id": "Python/29",
    "prompt": {
      "en": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "sq": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Llogarit numrin më të vogël të plotë pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n të jetë më e madhe se një numër i plotë pozitiv i dhënë k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentet:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën e pragut që shuma e serisë harmonike duhet të tejkalojë.\n\n    Kthen:\n    - int: Numri më i vogël i plotë n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "hy": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Հաշվել ամենափոքր դրական ամբողջ թիվը n, այնպես որ հարմոնիկ շարքի գումարը\n    մինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\n    Պարամետրեր:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմային արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\n    Վերադարձնում է:\n    - int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "bn": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n নির্ণয় করুন যাতে হারমোনিক সিরিজের \n    যোগফল 1/n পর্যন্ত প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বেশি হয়।\n\n    হারমোনিক সিরিজকে সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\n    আর্গুমেন্ট:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন থ্রেশহোল্ড মানকে উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: এমন ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n থ্রেশহোল্ড k কে অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "bg": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Изчислява най-малкото положително цяло число n, такова че сумата на хармоничната редица\n    до 1/n е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "zh": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    计算最小的正整数 n，使得调和级数的和\n    达到 1/n 时大于给定的正整数 k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "fr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "de": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Berechne die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabewerte:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "ha": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Lissafi mafi ƙarancin lamba mai kyau n ta yadda jumlar jerin harmonic\n    har zuwa 1/n ya fi wani lamba mai kyau k.\n\n    An ayyana jerin harmonic a matsayin S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Lamba mai kyau da ke wakiltar ƙimar ƙofa da jumlar jerin harmonic dole ta wuce.\n\n    Returns:\n    - int: Mafi ƙarancin lamba n wanda jumlar jerin harmonic S_n ta wuce ƙimar ƙofa k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "hi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    उस सबसे छोटे धनात्मक पूर्णांक n की गणना करें ताकि हार्मोनिक श्रेणी का योग\n    1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\n    हार्मोनिक श्रेणी को इस प्रकार परिभाषित किया गया है: S_n = 1 + 1/2 + 1/3 + ... + 1/n।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    वापसी:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k से अधिक होता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\"",
      "hu": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Számítsd ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat\n    1/n-ig terjedő összege nagyobb, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat definíciója: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Paraméterek:\n    - k (int): Egy pozitív egész szám, amely az a küszöbérték, amit a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatér:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9778258974131703",
      "hy": "0.975461798618093",
      "bn": "0.9789217412253397",
      "bg": "0.9767727591329233",
      "zh": "0.9720078149222774",
      "fr": "0.9831539587540501",
      "de": "0.9773217735061037",
      "ha": "0.9731682136082832",
      "hi": "0.9759830047379285",
      "hu": "0.9610831439653585"
    },
    "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1",
    "instruction": {
      "en": "Write a python function 'def find_min_n_greater_than_k(k: int) -> int:' to solve the following problem:\n\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ",
      "sq": "Shkruani një funksion python 'def find_min_n_greater_than_k(k: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin më të vogël të plotë pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n është më e madhe se një numër i plotë pozitiv i dhënë k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\n    Kthen:\n    - int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "hy": "Պայթոն ֆունկցիա 'def find_min_n_greater_than_k(k: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք ամենափոքր դրական ամբողջ թիվը n, այնպես որ հարմոնիկ շարքի գումարը\n    մինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից:\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n:\n\n    Արգումենտներ:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմային արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի:\n\n    Վերադարձնում է:\n    - int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k:\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "bn": "একটি পাইথন ফাংশন 'def find_min_n_greater_than_k(k: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n গণনা করুন যাতে 1/n পর্যন্ত হারমোনিক সিরিজের যোগফল\n    প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বেশি হয়।\n\n    হারমোনিক সিরিজটি S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে সংজ্ঞায়িত।\n\n    আর্গুমেন্টসমূহ:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন সীমা মান প্রতিনিধিত্ব করে।\n\n    রিটার্নস:\n    - int: ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n সীমা k অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "bg": "Напишете Python функция 'def find_min_n_greater_than_k(k: int) -> int:' за да решите следния проблем:\n\n    Изчислете най-малкото положително цяло число n, така че сумата на хармоничната редица\n    до 1/n да е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "zh": "编写一个python函数 'def find_min_n_greater_than_k(k: int) -> int:' 来解决以下问题：\n\n    计算最小的正整数n，使得调和级数的和\n    达到1/n时大于给定的正整数k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "fr": "Écrivez une fonction python 'def find_min_n_greater_than_k(k: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Exemples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "de": "Schreiben Sie eine Python-Funktion 'def find_min_n_greater_than_k(k: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabewert:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "ha": "Rubuta wani aikin python 'def find_min_n_greater_than_k(k: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa ƙaramin lamba mai kyau n wanda adadin jerin harmonic\n    har zuwa 1/n ya fi wani lamba mai kyau k.\n\n    Jerin harmonic an bayyana shi kamar haka S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Lamba mai kyau wanda ke wakiltar ƙimar iyaka da adadin jerin harmonic dole ne ya wuce.\n\n    Returns:\n    - int: Mafi ƙarancin lamba n wanda adadin jerin harmonic S_n ya wuce iyaka k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "hi": "एक पायथन फ़ंक्शन 'def find_min_n_greater_than_k(k: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    सबसे छोटा धनात्मक पूर्णांक n गणना करें ताकि हार्मोनिक श्रेणी का योग\n    1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\n    हार्मोनिक श्रेणी को इस प्रकार परिभाषित किया गया है: S_n = 1 + 1/2 + 1/3 + ... + 1/n।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    लौटाता है:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k को पार करता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "hu": "Írj egy python függvényt 'def find_min_n_greater_than_k(k: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a legkisebb pozitív egész számot n, hogy a harmonikus sorozat\n    1/n-ig terjedő összege nagyobb legyen, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat így van definiálva: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Paraméterek:\n    - k (int): Egy pozitív egész szám, amely a küszöbértéket jelöli, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatérési érték:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11"
    },
    "instruction_bertscore": {
      "sq": "0.9833317329450764",
      "hy": "0.9768857798197321",
      "bn": "0.9806625378847295",
      "bg": "0.979805447790564",
      "zh": "0.975928381383144",
      "fr": "0.9852671873778803",
      "de": "0.9779438838595049",
      "ha": "0.9721091164166051",
      "hi": "0.979344823936944",
      "hu": "0.974094824335811"
    },
    "level": "easy",
    "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()",
    "entry_point": "find_min_n_greater_than_k",
    "signature": "def find_min_n_greater_than_k(k: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11\n    ",
      "sq": "\n    Llogarit numrin më të vogël pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n është më e madhe se një numër i dhënë pozitiv k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\n    Returns:\n    - int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "hy": "\n    Հաշվեք ամենափոքր դրական ամբողջ թիվը n, որպեսզի հարմոնիկ շարքի գումարը մինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\n    Պարամետրեր:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմի արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\n    Վերադարձնում է:\n    - int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "bn": "\n    প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বড় হওয়ার জন্য হারমোনিক সিরিজের \n    1/n পর্যন্ত যোগফল সহ সবচেয়ে ছোট ধনাত্মক পূর্ণসংখ্যা n গণনা করুন।\n\n    হারমোনিক সিরিজকে সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\n    আর্গস:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন থ্রেশহোল্ড মান উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: সবচেয়ে ছোট পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n থ্রেশহোল্ড k অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "bg": "\n    Изчислете най-малкото положително цяло число n, така че сумата на хармоничната редица\n    до 1/n да е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "zh": "\n    计算最小的正整数 n，使得调和级数的和达到 1/n 时大于给定的正整数 k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "fr": "\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "de": "\n    Berechne die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabe:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "ha": "\n    Lissafa ƙaramin cikakken lamba n wanda ya fi haka, jumillar jerin lissafi\n    har zuwa 1/n ya fi wata cikakkiyar lamba k.\n\n    Jerin lissafi an bayyana shi kamar S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Ƙa'idodi:\n    - k (int): Cikakkiyar lamba mai kyau wanda ke wakiltar ƙimar ƙofa da jumillar jerin lissafi dole ta wuce.\n\n    Komawa:\n    - int: Ƙaramin lamba n wanda don shi jumillar jerin lissafi S_n ya wuce ƙimar ƙofa k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "hi": "\n    दिए गए धनात्मक पूर्णांक k से अधिक होने के लिए हार्मोनिक श्रेणी के योग के लिए सबसे छोटा धनात्मक पूर्णांक n की गणना करें।\n\n    हार्मोनिक श्रेणी को S_n = 1 + 1/2 + 1/3 + ... + 1/n के रूप में परिभाषित किया गया है।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मूल्य का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    वापसी:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k से अधिक होता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11",
      "hu": "\n    Számítsd ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat összege\n    1/n-ig nagyobb, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat definíciója: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Paraméterek:\n    - k (int): Egy pozitív egész szám, amely a küszöbértéket jelenti, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatér:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    >>> find_min_n_greater_than_k(3)\n    11"
    },
    "docstring_bertscore": {
      "sq": "0.9749757500757007",
      "hy": "0.9766825809399334",
      "bn": "0.983483486556187",
      "bg": "0.9771336705352637",
      "zh": "0.9745602153185756",
      "fr": "0.983483486556187",
      "de": "0.9748150580974434",
      "ha": "0.9554678630935022",
      "hi": "0.9609593972379737",
      "hu": "0.9608004929331458"
    }
  },
  {
    "task_id": "Python/30",
    "prompt": {
      "en": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "sq": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Përcaktoni nëse një numër i dhënë është një numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka pjesëtues pozitivë përveç 1 dhe vetvetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon për pjesëtueshmëri me 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri në rrënjën katrore të numrit.\n\n    Args:\n    num (int): Numri për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është një numër i thjeshtë, False përndryshe.\n\n    Raste:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "hy": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Սահմանել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ՝ բացի 1-ից և ինքն իրենից: Ֆունկցիան ստուգում է պարզությունը՝ բացառելով ոչ պարզ թվերը մի քանի թեստերի միջոցով: Նախ, այն մշակում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոններ ստուգելու համար:\n\n    Արգումենտներ:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "bn": "def is_prime(num: int) -> bool:\n    \"\"\"\n    প্রদত্ত পূর্ণসংখ্যাটি একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\n    একটি মৌলিক সংখ্যা হল 1 এর চেয়ে বড় একটি প্রাকৃতিক সংখ্যা যার 1 এবং নিজে ছাড়া অন্য কোনো ধনাত্মক বিভাজক নেই। \n    এই ফাংশনটি বিভিন্ন পরীক্ষা ব্যবহার করে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা যাচাই করে। প্রথমে, এটি 1 বা তার চেয়ে কম সংখ্যার জন্য প্রান্তিক \n    ক্ষেত্রগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (2 এবং 3) যা মৌলিক। তারপর এটি 2 এবং 3 দ্বারা বিভাজ্যতা পরীক্ষা করে। \n    বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত ফ্যাক্টর পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    Args:\n    num (int): মৌলিকতা যাচাই করার জন্য পূর্ণসংখ্যা।\n\n    Returns:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    উদাহরণ:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "bg": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Определя дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото себе си. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва граничните случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за делители до квадратния корен на числото.\n\n    Аргументи:\n    num (int): Цялото число, което да се провери за простота.\n\n    Връща:\n    bool: True ако `num` е просто число, False в противен случай.\n\n    Примери:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "zh": "def is_prime(num: int) -> bool:\n    \"\"\"\n    确定给定整数是否为素数。\n\n    素数是大于1的自然数，除了1和它本身没有其他正因数。\n    该函数通过使用几个测试来消除非素数，从而检查素性。\n    首先，它处理小于或等于1的数字的边界情况，这些数字不是素数，而小数字(2和3)是素数。\n    然后检查是否能被2和3整除。\n    对于较大的数字，它使用6k +/- 1优化来测试因数，直到数字的平方根。\n\n    参数:\n    num (int): 要检查素性的整数。\n\n    返回:\n    bool: 如果 `num` 是素数则返回 True，否则返回 False。\n\n    示例:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "fr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "de": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Bestimmen, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primalität, indem sie Nicht-Primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Sonderfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann wird die Teilbarkeit durch 2 und 3 überprüft. Für größere Zahlen wird eine 6k +/- 1 Optimierung verwendet, um nach Teilern bis zur Quadratwurzel der Zahl zu testen.\n\n    Argumente:\n    num (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\n    Rückgabewert:\n    bool: True, wenn `num` eine Primzahl ist, andernfalls False.\n\n    Fälle:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "ha": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Tabbatar ko wani lamba cikakken lamba ne.\n\n    Cikakken lamba shi ne lamba na halitta wanda ya fi 1 girma kuma ba shi da masu raba lamba masu kyau sai dai 1 da kansa. Aikin yana duba cikakken lamba ta hanyar kawar da lambobi marasa cikakken lamba ta amfani da gwaje-gwaje da dama. Da farko, yana kula da yanayi na musamman ga lambobi da suka yi ƙasa ko daidai da 1, waɗanda ba su cikakke ba, da ƙananan lambobi (2 da 3) waɗanda su ne cikakke. Sannan yana duba rarrabewa da 2 da 3. Don manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada masu raba har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba don cikakken lamba.\n\n    Returns:\n    bool: Gaskiya idan `num` cikakken lamba ne, Karya in ba haka ba.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "hi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या एक प्राकृतिक संख्या है जो 1 से बड़ी होती है और जिसका कोई धनात्मक भाजक नहीं होता है सिवाय 1 और स्वयं के। यह फ़ंक्शन कई परीक्षणों का उपयोग करके अभाज्यता की जाँच करता है, गैर-अभाज्य संख्याओं को समाप्त करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएँ (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जाँच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक कारकों के लिए परीक्षण करने के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    Args:\n    num (int): अभाज्यता की जाँच करने के लिए पूर्णांक।\n\n    Returns:\n    bool: True यदि `num` एक अभाज्य संख्या है, अन्यथा False।\n\n    उदाहरण:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\"",
      "hu": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Határozza meg, hogy egy adott egész szám prímszám-e.\n\n    A prímszám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény több teszt segítségével szűri ki a nem prímszámokat. Először kezeli az 1-nél kisebb vagy egyenlő számok speciális eseteit, amelyek nem prímek, valamint a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén 6k +/- 1 optimalizálást használ a szám négyzetgyökéig terjedő osztók tesztelésére.\n\n    Paraméterek:\n    num (int): Az egész szám, amelyet a prímtesztre ellenőrzünk.\n\n    Visszatérési érték:\n    bool: Igaz, ha `num` prímszám, hamis egyébként.\n\n    Esetek:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.98514622147583",
      "hy": "0.9775527806392473",
      "bn": "0.9763737106974242",
      "bg": "0.9783749117863507",
      "zh": "0.977619719077656",
      "fr": "0.9890405687264",
      "de": "0.9712861907479776",
      "ha": "0.9716854378138577",
      "hi": "0.98763366973753",
      "hu": "0.9511275906375088"
    },
    "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "instruction": {
      "en": "Write a python function 'def is_prime(num: int) -> bool:' to solve the following problem:\n\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "sq": "Shkruani një funksion python 'def is_prime(num: int) -> bool:' për të zgjidhur problemin e mëposhtëm:\n\n    Përcaktoni nëse një numër i dhënë është numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka pjesëtuese pozitive përveç 1 dhe vetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon pjesëtueshmërinë me 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar faktorët deri në rrënjën katrore të numrit.\n\n    Args:\n    num (int): Numri për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është numër i thjeshtë, False përndryshe.\n\n    Rastet:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "hy": "Պայթոն ֆունկցիա 'def is_prime(num: int) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Սահմանել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ, բացի 1-ից և ինքն իրենից: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելու մի քանի թեստերի միջոցով: Նախ, այն կարգավորում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև այն ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոնները ստուգելու համար:\n\n    Արձ:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "bn": "একটি পাইথন ফাংশন 'def is_prime(num: int) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    নির্ধারণ করুন একটি প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা।\n\n    একটি মৌলিক সংখ্যা হল 1 এর চেয়ে বড় একটি স্বাভাবিক সংখ্যা যার কোনো ধনাত্মক গুণনীয়ক নেই 1 এবং তার নিজস্ব ছাড়া। ফাংশনটি বিভিন্ন পরীক্ষার মাধ্যমে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা পরীক্ষা করে। প্রথমে, এটি 1 বা তার চেয়ে ছোট সংখ্যার জন্য প্রান্তিক কেসগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (2 এবং 3) যা মৌলিক। তারপর এটি 2 এবং 3 দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    আর্গস:\n    num (int): মৌলিকতা পরীক্ষা করার জন্য পূর্ণসংখ্যা।\n\n    রিটার্নস:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    কেস:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "bg": "Напишете Python функция 'def is_prime(num: int) -> bool:' за да решите следния проблем:\n\n    Определете дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва гранични случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за фактори до квадратния корен на числото.\n\n    Аргументи:\n    num (int): Цялото число, което да се провери за простота.\n\n    Връща:\n    bool: True, ако `num` е просто число, False в противен случай.\n\n    Примери:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "zh": "编写一个python函数 'def is_prime(num: int) -> bool:' 来解决以下问题：\n\n    确定给定的整数是否是一个素数。\n\n    素数是大于1的自然数，除了1和它本身没有其他正除数。该函数通过使用多种测试消除非素数来检查素数性。首先，它处理小于或等于1的数字的边界情况，这些数字不是素数，以及小数字（2和3），它们是素数。然后，它检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试直到数字平方根的因子。\n\n    参数：\n    num (int): 要检查是否为素数的整数。\n\n    返回：\n    bool: 如果 `num` 是素数则返回True，否则返回False。\n\n    示例：\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "fr": "Écrire une fonction python 'def is_prime(num: int) -> bool:' pour résoudre le problème suivant :\n\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle traite les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "de": "Schreiben Sie eine Python-Funktion 'def is_prime(num: int) -> bool:', um das folgende Problem zu lösen:\n\n    Bestimmen Sie, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primalität, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Randfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann überprüft sie die Teilbarkeit durch 2 und 3. Für größere Zahlen verwendet sie eine 6k +/- 1 Optimierung, um Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\n    Argumente:\n    num (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\n    Rückgabewert:\n    bool: True, wenn `num` eine Primzahl ist, andernfalls False.\n\n    Fälle:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "ha": "Rubuta wani aikin python 'def is_prime(num: int) -> bool:' don warware matsalar mai zuwa:\n\n    Tantance ko wani lamba mai cikakken lamba shine lamba mai lamba.\n\n    Lamba mai lamba shine lamba mai halitta da ya fi 1 girma wanda ba shi da masu raba lamba masu kyau banda 1 da kansa. Aikin yana duba ko lamba mai lamba ne ta hanyar kawar da lambobi marasa lamba mai lamba ta amfani da gwaje-gwaje da yawa. Da farko, yana kula da yanayin gefen lambobi da suka yi ƙasa ko daidai da 1, waɗanda ba su da lamba mai lamba, da ƙananan lambobi (2 da 3) waɗanda suke lamba mai lamba. Sannan yana duba ko za a iya raba shi da 2 da 3. Don lambobi masu girma, yana amfani da ingantaccen 6k +/- 1 don gwada masu raba har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba ko lamba mai lamba ce.\n\n    Returns:\n    bool: Gaskiya idan `num` lamba mai lamba ce, Karya in ba haka ba.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "hi": "एक पायथन फ़ंक्शन 'def is_prime(num: int) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या 1 से बड़ी प्राकृतिक संख्या होती है जिसका कोई धनात्मक भाजक नहीं होता सिवाय 1 और स्वयं के। फ़ंक्शन कई परीक्षणों का उपयोग करके अभाज्यता की जांच करता है, गैर-अभाज्य संख्याओं को समाप्त करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएं (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जांच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक गुणनखंडों का परीक्षण करने के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    तर्क:\n    num (int): अभाज्यता की जांच के लिए पूर्णांक।\n\n    लौटाता है:\n    bool: True यदि `num` एक अभाज्य संख्या है, अन्यथा False।\n\n    मामले:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "hu": "Írj egy Python függvényt 'def is_prime(num: int) -> bool:' a következő probléma megoldására:\n\n    Határozd meg, hogy a megadott egész szám prím-e.\n\n    A prímszám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény több teszt segítségével ellenőrzi a prím tulajdonságot, kizárva a nem prím számokat. Először kezeli azokat a szélsőséges eseteket, amikor a szám kisebb vagy egyenlő 1-gyel, amelyek nem prímek, és a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén egy 6k +/- 1 optimalizálást használ, hogy tesztelje a szám négyzetgyökéig terjedő osztókat.\n\n    Args:\n    num (int): Az egész szám, amelyet a prím tulajdonság ellenőrzésére vizsgálunk.\n\n    Returns:\n    bool: Igaz, ha `num` prímszám, egyébként Hamis.\n\n    Esetek:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False"
    },
    "instruction_bertscore": {
      "sq": "0.979094351026459",
      "hy": "0.9802096606159699",
      "bn": "0.9849577212442279",
      "bg": "0.9894263089263698",
      "zh": "0.9802821607050477",
      "fr": "0.9896191790263547",
      "de": "0.9810933671811942",
      "ha": "0.9737698650324378",
      "hi": "0.981319607185193",
      "hu": "0.9450723434716602"
    },
    "level": "easy",
    "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()",
    "entry_point": "is_prime",
    "signature": "def is_prime(num: int) -> bool:",
    "docstring": {
      "en": "\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False\n    ",
      "sq": "\n    Përcaktoni nëse një numër i dhënë është numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka ndarës pozitivë përveç 1 dhe vetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) që janë të thjeshtë. Pastaj kontrollon për pjesëtueshmëri me 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri në rrënjën katrore të numrit.\n\n    Args:\n    num (int): Numri për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është numër i thjeshtë, False përndryshe.\n\n    Rastet:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "hy": "\n    Որոշել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ, բացի 1-ից և իրենից: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելով մի քանի փորձարկումներով: Նախ, այն մշակում է 1-ից փոքր կամ հավասար թվերի եզակի դեպքերը, որոնք պարզ չեն, և փոքր թվերը (2 և 3), որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոններ ստուգելու համար:\n\n    Պարամետրեր:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "bn": "\n    একটি প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\n    একটি মৌলিক সংখ্যা হল ১ এর চেয়ে বড় একটি স্বাভাবিক সংখ্যা যার কোনো ধনাত্মক গুণনীয়ক নেই ১ এবং তার নিজের বাইরে। ফাংশনটি মৌলিকতা পরীক্ষা করে অমৌলিক সংখ্যা বাদ দিয়ে বিভিন্ন পরীক্ষার মাধ্যমে। প্রথমে, এটি ১ বা তার চেয়ে ছোট সংখ্যাগুলির জন্য প্রান্তিক ক্ষেত্রগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (2 এবং 3) যা মৌলিক। তারপর এটি 2 এবং 3 দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    Args:\n    num (int): মৌলিকতা পরীক্ষা করার জন্য পূর্ণসংখ্যা।\n\n    Returns:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    উদাহরণ:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "bg": "\n    Определете дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него. Функцията проверява за простота, като елиминира не-простите числа чрез няколко теста. Първо, тя обработва граничните случаи за числа, по-малки или равни на 1, които не са прости, и малките числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за делители до квадратния корен на числото.\n\n    Аргументи:\n    num (int): Цялото число, което да се провери за простота.\n\n    Връща:\n    bool: True ако `num` е просто число, False в противен случай.\n\n    Примери:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "zh": "\n    判断给定整数是否为质数。\n\n    质数是大于1的自然数，除了1和它本身外没有其他正因数。该函数通过使用几个测试来排除非质数以检查质数性。首先，它处理小于或等于1的数字的边界情况，这些数字不是质数，而小数字（2和3）是质数。然后检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试因数，直到数字的平方根。\n\n    参数:\n    num (int): 要检查是否为质数的整数。\n\n    返回:\n    bool: 如果 `num` 是质数则返回 True，否则返回 False。\n\n    示例:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "fr": "\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "de": "\n    Bestimmen Sie, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primzahl-Eigenschaft, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Sonderfälle für Zahlen kleiner oder gleich 1, die keine Primzahlen sind, und kleine Zahlen (2 und 3), die Primzahlen sind. Dann wird die Teilbarkeit durch 2 und 3 überprüft. Für größere Zahlen wird eine 6k +/- 1 Optimierung verwendet, um Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\n    Args:\n    num (int): Die ganze Zahl, die auf Primzahl-Eigenschaft überprüft werden soll.\n\n    Returns:\n    bool: True, wenn `num` eine Primzahl ist, andernfalls False.\n\n    Fälle:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "ha": "\n    Tantance ko wani lamba cikakke shine lamba mai lamba.\n\n    Lamba mai lamba shine lamba na halitta wanda ya fi 1 wanda ba shi da masu raba lamba masu kyau sai dai 1 da kansa. Aikin yana duba cikakken lamba ta hanyar kawar da lambobin da ba su da cikakken lamba ta amfani da gwaje-gwaje da dama. Da farko, yana magance lokuta na musamman ga lambobi da suka yi ƙasa ko daidai da 1, waɗanda ba su da cikakken lamba, da ƙananan lambobi (2 da 3) waɗanda suke cikakke. Sannan yana duba rarrabuwar 2 da 3. Ga manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada masu raba har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba don cikakken lamba.\n\n    Returns:\n    bool: Gaskiya idan `num` cikakke ne, Karya in ba haka ba.\n\n    Cases:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "hi": "\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या एक प्राकृतिक संख्या है जो 1 से बड़ी होती है और जिसका कोई अन्य धनात्मक भाजक नहीं होता सिवाय 1 और स्वयं के। यह फ़ंक्शन कई परीक्षणों का उपयोग करके अभाज्यता की जांच करता है, गैर-अभाज्य संख्याओं को समाप्त करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं होते, और छोटी संख्याएं (2 और 3) जो अभाज्य होती हैं। फिर यह 2 और 3 से विभाज्यता की जांच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक कारकों का परीक्षण करने के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    तर्क:\n    num (int): अभाज्यता की जांच के लिए पूर्णांक।\n\n    लौटाता है:\n    bool: True अगर `num` एक अभाज्य संख्या है, अन्यथा False।\n\n    मामले:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False",
      "hu": "\n    Határozza meg, hogy egy adott egész szám prímszám-e.\n\n    A prímszám olyan természetes szám, amely nagyobb, mint 1, és nincs más pozitív osztója, csak 1 és önmaga. A függvény több teszt segítségével szűri ki a nem prím számokat, hogy ellenőrizze a prím tulajdonságot. Először kezeli az 1-nél kisebb vagy egyenlő számok speciális eseteit, amelyek nem prímek, valamint a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén 6k +/- 1 optimalizálást használ, hogy tesztelje az osztókat a szám négyzetgyökéig.\n\n    Paraméterek:\n    num (int): Az egész szám, amelyet a prím tulajdonságra ellenőrzünk.\n\n    Visszatér:\n    bool: Igaz, ha `num` prímszám, egyébként Hamis.\n\n    Esetek:\n    >>> is_prime(2)\n    True\n    >>> is_prime(15)\n    False"
    },
    "docstring_bertscore": {
      "sq": "0.9833297466412659",
      "hy": "0.9674927477309733",
      "bn": "0.9755039082588725",
      "bg": "0.9820583135722617",
      "zh": "0.9711930330992722",
      "fr": "0.9874008749309571",
      "de": "0.9603049101324638",
      "ha": "0.9627873926346379",
      "hi": "0.9791988306068834",
      "hu": "0.9330768561305823"
    }
  },
  {
    "task_id": "Python/31",
    "prompt": {
      "en": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "sq": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Gjeneroni të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\n    Argumentet:\n    - n (int): Numri origjinal i plotë për të transformuar.\n    - rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull paraqitet\n                              si një tuple (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Raste:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "hy": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Գեներացնել բոլոր եզակի թվերը տրված թվից՝ կիրառելով փոխակերպման կանոններ։\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի։ \n    Լայնության առաջին որոնում (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար։ \n    Ֆունկցիան վերադարձնում է եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ թիվը։\n\n    Պարամետրեր:\n    - n (int): Սկզբնական ամբողջ թիվը փոխակերպելու համար։\n    - rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն ներկայացված է որպես\n                              զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի։\n\n    Վերադարձնում է:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են գեներացվել։\n\n    Օրինակներ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "bn": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    প্রদত্ত সংখ্যাটি থেকে রূপান্তর নিয়ম প্রয়োগ করে সব অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। \n    সমস্ত সম্ভাব্য রূপান্তর অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। \n    ফাংশনটি মূল সংখ্যা সহ মূল সংখ্যাটি থেকে তৈরি করা যেতে পারে এমন অনন্য সংখ্যার সংখ্যা প্রদান করে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): রূপান্তর করার মূল পূর্ণসংখ্যা সংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) \n                              হিসাবে উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\n    রিটার্নস:\n    - int: অনন্য সংখ্যার মোট সংখ্যা যা তৈরি করা যেতে পারে।\n\n    কেসসমূহ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "bg": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Генерира всички уникални числа от даденото число чрез прилагане на правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа,\n    които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформиране.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "zh": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    通过应用转换规则从给定数字生成所有唯一数字。\n\n    每个规则允许将一个数字转换为另一个。使用广度优先搜索 (BFS) 来探索所有可能的转换。\n    该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数:\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则列表，其中每个规则表示为一个元组 (x, y)，\n                              表示数字 x 可以转换为 y。\n\n    返回:\n    - int: 可以生成的唯一数字的总数。\n\n    示例:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "fr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un seul chiffre en un autre. Une recherche en largeur\n    (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre\n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (list of tuples): Une liste de règles de transformation, où chaque règle est représentée\n                              comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Returns:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "de": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Erzeuge alle eindeutigen Zahlen aus der gegebenen Zahl durch Anwendung von Transformationsregeln.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der eindeutigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich\n    der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel als Tupel (x, y)\n                              dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgaben:\n    - int: Die Gesamtanzahl der eindeutigen Zahlen, die generiert werden können.\n\n    Fälle:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "ha": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\n    Kowace doka tana ba da damar sauya lamba guda ɗaya zuwa wata. Ana amfani da binciken faɗin-farko\n    (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana dawo da adadin lambobin musamman\n    da za a iya samarwa daga lambar asali, gami da lambar kanta.\n\n    Args:\n    - n (int): Lambar asali ta integer don sauyawa.\n    - rules (list of tuples): Jerin dokokin sauyi, inda kowace doka ke wakiltar\n                              ta matsayin tuple (x, y) wanda ke nuna cewa ana iya sauya lamba x zuwa y.\n\n    Returns:\n    - int: Jimlar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "hi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    दिए गए संख्या से परिवर्तन नियम लागू करके सभी अद्वितीय संख्याएँ उत्पन्न करें।\n\n    प्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए\n    ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। यह फ़ंक्शन उन अद्वितीय संख्याओं की गिनती लौटाता है\n    जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें स्वयं संख्या भी शामिल है।\n\n    तर्क:\n    - n (int): मूल पूर्णांक संख्या जिसे परिवर्तित करना है।\n    - rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम को एक ट्यूपल (x, y) के रूप में\n                              दर्शाया गया है, यह दर्शाता है कि अंक x को y में बदला जा सकता है।\n\n    लौटाता है:\n    - int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\n    उदाहरण:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\"",
      "hu": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generáljon minden egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi egyetlen számjegy átalakítását egy másikra. Egy szélességi \n    keresést (BFS) használnak az összes lehetséges átalakítás felfedezésére. A függvény visszaadja \n    az eredeti számból generálható egyedi számok számát, beleértve magát a számot is.\n\n    Paraméterek:\n    - n (int): Az eredeti egész szám, amit át kell alakítani.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy \n                              (x, y) párként van megadva, jelezve, hogy az x számjegy \n                              átalakítható y-ra.\n\n    Visszatérési érték:\n    - int: Az összes generálható egyedi szám teljes száma.\n\n    Esetek:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9857961400825762",
      "hy": "0.9623637140318905",
      "bn": "0.9844947138260356",
      "bg": "0.9743852219528839",
      "zh": "0.9691948114660612",
      "fr": "0.9854425780043341",
      "de": "0.9915484759173465",
      "ha": "0.9766019370052332",
      "hi": "0.9731807273222883",
      "hu": "0.9621700494103814"
    },
    "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)",
    "instruction": {
      "en": "Write a python function 'def generate_numbers(n, rules) -> int:' to solve the following problem:\n\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ",
      "sq": "Shkruani një funksion python 'def generate_numbers(n, rules) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Gjeneroni të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim i parë në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, përfshirë vetë numrin.\n\n    Args:\n    - n (int): Numri origjinal i plotë për t'u transformuar.\n    - rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\n                              si një tuple (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Rastet:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "hy": "Պայթոն ֆունկցիա 'def generate_numbers(n, rules) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Տրված թվից ստեղծել բոլոր եզակի թվերը՝ կիրառելով փոխակերպման կանոններ:\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի: Լայնությամբ առաջին որոնում \n    (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար: Ֆունկցիան վերադարձնում է \n    եզակի թվերի քանակը, որոնք կարող են ստեղծվել սկզբնական թվից, ներառյալ ինքը՝ թիվը:\n\n    Args:\n    - n (int): Փոխակերպման ենթակա սկզբնական ամբողջ թիվը:\n    - rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն ներկայացված է\n                              որպես կույտ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի:\n\n    Returns:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են ստեղծվել:\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "bn": "একটি পাইথন ফাংশন 'def generate_numbers(n, rules) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    রূপান্তর নিয়ম প্রয়োগ করে প্রদত্ত সংখ্যাটি থেকে সমস্ত অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তর অন্বেষণ করতে \n    একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ মূল সংখ্যা থেকে \n    তৈরি করা যেতে পারে এমন অনন্য সংখ্যার গণনা প্রদান করে।\n\n    আর্গুমেন্ট:\n    - n (int): রূপান্তর করার জন্য মূল পূর্ণসংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) \n                              হিসাবে উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\n    রিটার্নস:\n    - int: অনন্য সংখ্যার মোট গণনা যা তৈরি করা যেতে পারে।\n\n    উদাহরণ:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "bg": "Напишете Python функция 'def generate_numbers(n, rules) -> int:', за да решите следния проблем:\n\n    Генерирайте всички уникални числа от даденото число, като приложите правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя\n    на уникалните числа, които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформиране.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "zh": "编写一个 Python 函数 'def generate_numbers(n, rules) -> int:' 以解决以下问题：\n\n    通过应用转换规则，从给定数字生成所有唯一的数字。\n\n    每个规则允许将一个数字转换为另一个数字。使用广度优先搜索 (BFS) 来探索所有可能的转换。\n    函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数：\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则的列表，其中每个规则表示为一个元组 (x, y)，\n                              表示数字 x 可以转换为 y。\n\n    返回：\n    - int: 可以生成的唯一数字的总数。\n\n    示例：\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "fr": "Écrire une fonction python 'def generate_numbers(n, rules) -> int:' pour résoudre le problème suivant :\n\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un chiffre unique en un autre. Une recherche en largeur\n    (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre\n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (liste de tuples): Une liste de règles de transformation, où chaque règle est représentée\n                               comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Retourne:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "de": "Schreiben Sie eine Python-Funktion 'def generate_numbers(n, rules) -> int:', um das folgende Problem zu lösen:\n\n    Erzeugen Sie alle eindeutigen Zahlen aus der gegebenen Zahl, indem Sie Transformationsregeln anwenden.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der eindeutigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (Liste von Tupeln): Eine Liste von Transformationsregeln, wobei jede Regel als\n                                Tupel (x, y) dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgabewert:\n    - int: Die Gesamtanzahl der eindeutigen Zahlen, die generiert werden können.\n\n    Fälle:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "ha": "Rubuta aikin python 'def generate_numbers(n, rules) -> int:' don warware matsalar mai zuwa:\n\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\n    Kowace doka tana ba da damar canza lamba ɗaya zuwa wata. Ana amfani da binciken farko na faɗi\n    (BFS) don bincika dukkan sauye-sauye masu yiwuwa. Aikin yana mayar da yawan\n    lambobin musamman da za a iya samarwa daga lambar asali, ciki har da lambar kanta.\n\n    Args:\n    - n (int): Lambar cikakken lamba ta asali don canzawa.\n    - rules (jerin tuples): Jerin dokokin sauyi, inda kowace doka take wakilta\n                              a matsayin tuple (x, y) wanda ke nuna cewa za a iya canza lamba x zuwa y.\n\n    Returns:\n    - int: Jimlar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "hi": "एक पायथन फ़ंक्शन 'def generate_numbers(n, rules) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    परिवर्तन नियमों को लागू करके दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें।\n\n    प्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए \n    एक ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। फ़ंक्शन उस अद्वितीय संख्याओं की गिनती लौटाता है \n    जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें संख्या स्वयं भी शामिल है।\n\n    तर्क:\n    - n (int): वह मूल पूर्णांक संख्या जिसे बदलना है।\n    - rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम को एक युग्म (x, y) के रूप में \n                              दर्शाया गया है, जो इंगित करता है कि अंक x को y में बदला जा सकता है।\n\n    लौटाता है:\n    - int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\n    मामले:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "hu": "Írj egy python függvényt 'def generate_numbers(n, rules) -> int:' a következő probléma megoldására:\n\n    Generálj minden egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi, hogy egyetlen számjegy átalakuljon egy másikba. Egy szélességi keresést\n    (BFS) használnak az összes lehetséges átalakítás felfedezésére. A függvény visszaadja az eredeti számból\n    generálható egyedi számok számát, beleértve magát a számot is.\n\n    Argumentumok:\n    - n (int): Az eredeti egész szám, amit átalakítunk.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy (x, y) \n                              tuple-ként van megadva, jelezve, hogy az x számjegy átalakulhat y-ra.\n\n    Visszatér:\n    - int: Az összes generálható egyedi szám száma.\n\n    Esetek:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9878527590478114",
      "hy": "0.9714742937188177",
      "bn": "0.9791209674975178",
      "bg": "0.9705558268369123",
      "zh": "0.9675841177062493",
      "fr": "0.9814820868368794",
      "de": "0.9751106201044233",
      "ha": "0.9656109235010488",
      "hi": "0.9790295975222417",
      "hu": "0.9621879261446745"
    },
    "level": "hard",
    "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()",
    "entry_point": "generate_numbers",
    "signature": "def generate_numbers(n, rules) -> int:",
    "docstring": {
      "en": "\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2\n    ",
      "sq": "\n    Gjeneroni të gjitha numrat unikë nga numri i dhënë duke zbatuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\n    Argumentet:\n    - n (int): Numri origjinal i plotë për të transformuar.\n    - rules (listë e treshave): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\n                                si një treshe (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Rastet:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "hy": "\n    Գեներացրեք բոլոր եզակի թվերը տրված թվից՝ կիրառելով փոխակերպման կանոնները։\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի։ Լայնության առաջին որոնումը (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար։ Ֆունկցիան վերադարձնում է եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ ինքը՝ թիվը։\n\n    Արգումենտներ:\n    - n (int): Սկզբնական ամբողջ թիվը՝ փոխակերպելու համար։\n    - rules (ցանկ՝ զույգերի): Փոխակերպման կանոնների ցանկ, որտեղ յուրաքանչյուր կանոն ներկայացված է որպես զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի։\n\n    Վերադարձնում է:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են գեներացվել։\n\n    Դեպքեր:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "bn": "\n    প্রদত্ত সংখ্যাটি থেকে রূপান্তর নিয়ম প্রয়োগ করে সমস্ত অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ মূল সংখ্যাটি থেকে তৈরি করা যেতে পারে এমন অনন্য সংখ্যার সংখ্যা প্রদান করে।\n\n    আর্গস:\n    - n (int): রূপান্তর করার মূল পূর্ণসংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) হিসাবে উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\n    রিটার্নস:\n    - int: মোট অনন্য সংখ্যার সংখ্যা যা তৈরি করা যেতে পারে।\n\n    কেস:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "bg": "\n    Генерирайте всички уникални числа от даденото число, като приложите правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа,\n    които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформация.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "zh": "\n    通过应用转换规则生成给定数字的所有唯一数字。\n\n    每个规则允许将一个数字转换为另一个数字。使用广度优先搜索 (BFS) 来探索所有可能的转换。\n    该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数:\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则列表，其中每个规则表示为一个元组 (x, y)，表示数字 x 可以转换为 y。\n\n    返回:\n    - int: 可以生成的唯一数字的总数。\n\n    示例:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "fr": "\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un seul chiffre en un autre. Une recherche en largeur (BFS) \n    est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre \n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (list of tuples): Une liste de règles de transformation, où chaque règle est représentée \n                              comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Returns:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "de": "\n    Erzeuge alle eindeutigen Zahlen aus der gegebenen Zahl durch Anwendung von Transformationsregeln.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der eindeutigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel als Tupel (x, y) dargestellt wird,\n                              das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgabewert:\n    - int: Die Gesamtanzahl der eindeutigen Zahlen, die generiert werden können.\n\n    Fälle:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "ha": "\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyawa.\n\n    Kowace doka tana ba da damar canza lamba guda ɗaya zuwa wani. Ana amfani da bincike na farko\n    (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana dawo da adadin lambobin musamman\n    da za a iya samarwa daga lambar asali, gami da lambar kanta.\n\n    Args:\n    - n (int): Lambar asali ta integer don sauyawa.\n    - rules (list of tuples): Jerin dokokin sauyawa, inda kowace doka ke wakiltar\n                              a matsayin tuple (x, y) yana nuna cewa ana iya sauya lamba x zuwa y.\n\n    Returns:\n    - int: Jimillar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "hi": "\n    दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें, परिवर्तन नियम लागू करके।\n\n    प्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए \n    ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। फ़ंक्शन उस मूल संख्या सहित उत्पन्न की जा सकने वाली \n    अद्वितीय संख्याओं की गिनती लौटाता है।\n\n    तर्क:\n    - n (int): परिवर्तित करने के लिए मूल पूर्णांक संख्या।\n    - rules (list of tuples): परिवर्तन नियमों की सूची, जहाँ प्रत्येक नियम को एक टपल (x, y) के रूप में \n                              दर्शाया गया है, जो इंगित करता है कि अंक x को y में बदला जा सकता है।\n\n    रिटर्न:\n    - int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\n    उदाहरण:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2",
      "hu": "\n    Generálja az összes egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi, hogy egyetlen számjegy átalakuljon egy másikra. Szélességi keresést\n    (BFS) használunk az összes lehetséges átalakítás felfedezésére. A függvény visszaadja az eredeti számból\n    generálható egyedi számok számát, beleértve magát a számot is.\n\n    Paraméterek:\n    - n (int): Az eredeti egész szám, amelyet át kell alakítani.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy\n                              (x, y) alakú tuple, amely jelzi, hogy az x számjegy átalakulhat y-ra.\n\n    Visszatér:\n    - int: Az összes generálható egyedi szám száma.\n\n    Esetek:\n    >>> generate_numbers(234, [(2, 5), (3, 6)])\n    4\n    >>> generate_numbers(100, [(1, 9)])\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9841050010184451",
      "hy": "0.9533967441104514",
      "bn": "0.9813045112762343",
      "bg": "0.9644491344023757",
      "zh": "0.9640051955007627",
      "fr": "0.9844734603752648",
      "de": "0.9745719345110567",
      "ha": "0.9573701462526734",
      "hi": "0.9597431834148972",
      "hu": "0.9528060173572537"
    }
  },
  {
    "task_id": "Python/32",
    "prompt": {
      "en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "sq": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Kjo funksion merr emrin e një krimineli të mundshëm (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon\n    nëse deklaratat e bëra nga të gjithë pjesëmarrësit janë konsistente me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që testohet si krimineli i mundshëm.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është konsistent me deklaratat, False përndryshe.\n\n    Raste Testimi:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "hy": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Գնահատում է սցենարի համահունչությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնված տրված հայտարարությունների վրա։\n\n    Այս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (սցենար) և ստախոսների հավաքածու (liar_count) և ստուգում է, \n    արդյոք բոլոր մասնակիցների կողմից արված հայտարարությունները համահունչ են այս սցենարին՝ անտեսելով շաբաթվա օրվա վերաբերյալ \n    ցանկացած հայտարարություն։\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք ենթադրվում են ստախոսներ։\n    - statements (dict): Բառարան, որը քարտեզում է մասնակիցների անունները նրանց համապատասխան հայտարարությունների ցուցակներին։\n    - days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը։\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը համահունչ է հայտարարություններին, False՝ հակառակ դեպքում։\n\n    Թեստային դեպքեր:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "bn": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    প্রদত্ত বিবৃতির ভিত্তিতে একজন অংশগ্রহণকারী অপরাধী কিনা তা যাচাই করে একটি দৃশ্যের সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি একটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং \n    সমস্ত অংশগ্রহণকারীর বিবৃতিগুলি এই দৃশ্যের সাথে সামঞ্জস্যপূর্ণ কিনা তা পরীক্ষা করে, সপ্তাহের দিনের \n    বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষাধীন অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে ধরা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামের সাথে তাদের সংশ্লিষ্ট বিবৃতির তালিকা ম্যাপ করা একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনগুলি উপস্থাপনকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্নস:\n    - bool: যদি দৃশ্যটি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    টেস্ট কেস:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "bg": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Оценява последователността на сценарий, в който един участник е престъпник въз основа на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и множество от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват всички изявления\n    относно деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Множество от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Множество от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "zh": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    评估一个参与者是罪犯的场景在给定陈述下的一致性。\n\n    此函数接受一个潜在罪犯的名字（scenario）和一组撒谎者（liar_count），并检查所有参与者的陈述是否与此场景一致，\n    忽略关于星期几的任何陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 假定为撒谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者名字映射到他们各自陈述的列表。\n    - days_of_week (set): 表示星期几的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致则为 True，否则为 False。\n\n    测试用例:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "fr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Évalue la cohérence d'un scénario où un participant est le criminel en fonction des déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé en tant que criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "de": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer der Täter ist, basierend auf den gegebenen Aussagen.\n\n    Diese Funktion nimmt den Namen eines potenziellen Täters (Szenario) und eine Menge von Lügnern (liar_count) und überprüft,\n    ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario konsistent sind, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n    - liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage repräsentieren.\n\n    Rückgabe:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "ha": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Kimanta daidaiton wani yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin maƙaryata (liar_count) sannan yana duba idan\n    bayanan da duk mahalarta suka bayar suna daidai da wannan yanayin, ba tare da la'akari da duk wani bayani\n    game da ranar mako ba.\n\n    Sigogi:\n    - scenario (str): Sunan mahalartin da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saitin sunayen mahalarta da ake ɗauka a matsayin maƙaryata.\n    - statements (dict): Kamus mai alaƙa da sunayen mahalarta zuwa jerin bayanan su na musamman.\n    - days_of_week (set): Saitin kirtani da ke wakiltar ranakun mako.\n\n    Komawa:\n    - bool: Gaskiya idan yanayin yana daidai da bayanan, Karya idan ba haka ba.\n\n    Gwaje-gwaje:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "hi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    दिए गए बयानों के आधार पर किसी परिदृश्य की संगति का मूल्यांकन करता है जहाँ एक प्रतिभागी अपराधी है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठ बोलने वालों का एक सेट (liar_count) लेता है और\n    यह जांचता है कि क्या सभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं, सप्ताह के दिन के \n    बारे में किसी भी बयान को नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसकी संभावित अपराधी के रूप में जांच की जा रही है।\n    - liar_count (set): उन प्रतिभागियों के नामों का सेट जिन्हें झूठा माना जा रहा है।\n    - statements (dict): प्रतिभागियों के नामों को उनके संबंधित बयानों की सूचियों से जोड़ने वाला एक शब्दकोश।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    रिटर्न्स:\n    - bool: यदि परिदृश्य बयानों के साथ संगत है तो True, अन्यथा False।\n\n    परीक्षण मामले:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\"",
      "hu": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Kiértékeli egy olyan forgatókönyv következetességét, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnös nevét (forgatókönyv) és egy hazugok halmazát (liar_count) veszi figyelembe, és ellenőrzi, hogy\n    az összes résztvevő által tett állítások következetesek-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjairól szóló állításokat.\n\n    Paraméterek:\n    - scenario (str): A vizsgált potenciális bűnös résztvevő neve.\n    - liar_count (set): A hazugnak feltételezett résztvevők neveinek halmaza.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a megfelelő állításaik listájához rendeli.\n    - days_of_week (set): A hét napjait reprezentáló karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: True, ha a forgatókönyv következetes az állításokkal, ellenkező esetben False.\n\n    Tesztesetek:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9820384505341582",
      "hy": "0.9800400302705662",
      "bn": "0.9614142608105437",
      "bg": "0.9819814436148011",
      "zh": "0.9559451718991291",
      "fr": "0.9840678571371916",
      "de": "0.9800320850553248",
      "ha": "0.9650815735355908",
      "hi": "0.9694760720856067",
      "hu": "0.968601303887529"
    },
    "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True",
    "instruction": {
      "en": "Write a python function 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' to solve the following problem:\n\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ",
      "sq": "Shkruani një funksion python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' për të zgjidhur problemin e mëposhtëm:\n\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Ky funksion merr emrin e një krimineli të mundshëm (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\n    deklaratat e bëra nga të gjithë pjesëmarrësit janë në përputhje me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që po testohet si kriminel i mundshëm.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është në përputhje me deklaratat, False përndryshe.\n\n    Rastet e Testit:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "hy": "Պայթոն ֆունկցիա 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Գնահատում է սցենարի համահունչությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնվելով տրված հայտարարությունների վրա։\n\n    Այս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (scenario) և ստախոսների հավաքածու (liar_count) և ստուգում է՝\n    արդյոք բոլոր մասնակիցների հայտարարությունները համահունչ են այս սցենարին՝ անտեսելով շաբաթվա օրվա վերաբերյալ ցանկացած հայտարարություն։\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ։\n    - statements (dict): Բառարան, որը մասնակիցների անունները կապում է նրանց համապատասխան հայտարարությունների ցուցակների հետ։\n    - days_of_week (set): Շաբաթվա օրերը ներկայացնող տողերի հավաքածու։\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը համահունչ է հայտարարություններին, հակառակ դեպքում՝ False։\n\n    Թեստային դեպքեր:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "bn": "একটি পাইথন ফাংশন 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত বিবৃতির ভিত্তিতে যেখানে একজন অংশগ্রহণকারী অপরাধী, সেই পরিস্থিতির সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং পরীক্ষা করে \n    যে সমস্ত অংশগ্রহণকারীর দ্বারা প্রদত্ত বিবৃতিগুলি এই পরিস্থিতির সাথে সামঞ্জস্যপূর্ণ কিনা, সপ্তাহের দিনের \n    বিষয়ে কোনো বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষা করা অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে মনে করা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকায় ম্যাপ করা একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনগুলিকে উপস্থাপনকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্ন করে:\n    - bool: যদি পরিস্থিতি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    টেস্ট কেস:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "bg": "Напишете Python функция 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' за решаване на следния проблем:\n\n    Оценява последователността на сценарий, в който един участник е престъпникът, базирано на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и множество от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват всички изявления\n    относно деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Множество от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Множество от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "zh": "编写一个python函数 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' 来解决以下问题:\n\n    评估一个场景的连贯性，其中一个参与者是基于给定陈述的罪犯。\n\n    此函数接受一个潜在罪犯的名字（scenario）和一组撒谎者（liar_count），并检查所有参与者所做的陈述是否与此场景一致，忽略任何关于星期几的陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 假定为撒谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者名字映射到各自陈述的列表。\n    - days_of_week (set): 表示星期几的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致则为True，否则为False。\n\n    测试用例:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "fr": "Écrivez une fonction python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' pour résoudre le problème suivant :\n\n    Évalue la cohérence d'un scénario où un participant est le criminel basé sur les déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé en tant que criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "de": "Schreiben Sie eine Python-Funktion 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:', um das folgende Problem zu lösen:\n\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer basierend auf den gegebenen Aussagen der Täter ist.\n\n    Diese Funktion nimmt den Namen eines potenziellen Täters (Szenario) und eine Menge von Lügnern (liar_count) und überprüft,\n    ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario konsistent sind, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n    - liar_count (set): Eine Menge von Namen von Teilnehmern, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage darstellen.\n\n    Rückgabewerte:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "ha": "Rubuta wani aikin python 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' don warware matsalar mai zuwa:\n\n    Kimanta daidaiton wani yanayi inda wani mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana daukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin makaryata (liar_count) kuma yana duba idan\n    bayanan da duk mahalarta suka yi suna daidai da wannan yanayin, tare da watsi da duk wani bayani\n    game da ranar mako.\n\n    Sigogi:\n    - scenario (str): Sunan mahalarta da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saitin sunayen mahalarta da ake tsammanin makaryata ne.\n    - statements (dict): Kamus mai danganta sunayen mahalarta zuwa jerin bayanan su na musamman.\n    - days_of_week (set): Saitin kirtani da ke wakiltar ranakun mako.\n\n    Komawa:\n    - bool: Gaskiya idan yanayin yana daidai da bayanan, Karya idan ba haka ba.\n\n    Gwajin Lokuta:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "hi": "एक पायथन फ़ंक्शन 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए बयानों के आधार पर एक परिदृश्य की संगति का मूल्यांकन करता है जहां एक प्रतिभागी अपराधी है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे लोगों का एक सेट (liar_count) लेता है और जांचता है कि\n    सभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं या नहीं, सप्ताह के दिन के बारे में किसी भी बयान को नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसे संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n    - liar_count (set): उन प्रतिभागियों के नामों का सेट जिन्हें झूठा माना जाता है।\n    - statements (dict): प्रतिभागियों के नामों को उनके संबंधित बयानों की सूची से मैप करने वाली एक डिक्शनरी।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    लौटाता है:\n    - bool: True यदि परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\n    परीक्षण मामले:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "hu": "Írj egy Python függvényt 'def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:' a következő probléma megoldására:\n\n    Értékeli egy olyan forgatókönyv konzisztenciáját, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnös nevét (scenario) és egy hazugok halmazát (liar_count) veszi, és ellenőrzi, hogy\n    az összes résztvevő által tett állítások konzisztens-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjával\n    kapcsolatos bármely állítást.\n\n    Paraméterek:\n    - scenario (str): A résztvevő neve, akit potenciális bűnösként tesztelnek.\n    - liar_count (set): A hazugnak feltételezett résztvevők neveinek halmaza.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a megfelelő állításaik listájához rendeli.\n    - days_of_week (set): A hét napjait képviselő karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: Igaz, ha a forgatókönyv konzisztens az állításokkal, hamis egyébként.\n\n    Tesztesetek:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True"
    },
    "instruction_bertscore": {
      "sq": "0.989695254462291",
      "hy": "0.9670313293558293",
      "bn": "0.9730005695666897",
      "bg": "0.9812425385973513",
      "zh": "0.979480885747953",
      "fr": "0.9846152824673238",
      "de": "0.9816537034860936",
      "ha": "0.977659047893101",
      "hi": "0.9747091881043518",
      "hu": "0.9697859354800211"
    },
    "level": "hard",
    "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()",
    "entry_point": "check_scenario",
    "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:",
    "docstring": {
      "en": "\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True\n    ",
      "sq": "\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Kjo funksion merr emrin e një të dyshuari potencial (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\n    deklaratat e bëra nga të gjithë pjesëmarrësit janë në përputhje me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që po testohet si kriminel potencial.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohen të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është në përputhje me deklaratat, False përndryshe.\n\n    Rastet e Testimit:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "hy": "\n    Գնահատում է սցենարի հետևողականությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնվելով տրված հայտարարությունների վրա։\n\n    Այս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (սցենար) և ստախոսների հավաքածու (liar_count) և ստուգում է՝ արդյոք\n    բոլոր մասնակիցների հայտարարությունները համահունչ են այս սցենարի հետ՝ անտեսելով շաբաթվա օրվա մասին հայտարարությունները։\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ։\n    - statements (dict): Բառարան, որը մասնակիցների անունները կապում է նրանց համապատասխան հայտարարությունների ցուցակների հետ։\n    - days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը։\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը համահունչ է հայտարարություններին, հակառակ դեպքում՝ False։\n\n    Թեստային դեպքեր:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "bn": "\n    প্রদত্ত বিবৃতির ভিত্তিতে একজন অংশগ্রহণকারী অপরাধী এমন একটি পরিস্থিতির সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি একটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং\n    সমস্ত অংশগ্রহণকারীদের দ্বারা প্রদত্ত বিবৃতিগুলি এই পরিস্থিতির সাথে সামঞ্জস্যপূর্ণ কিনা তা পরীক্ষা করে, সপ্তাহের দিনের \n    সম্পর্কে কোনও বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষিত অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে ধারণা করা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকার সাথে মানচিত্র করে এমন একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনগুলিকে উপস্থাপনকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্ন:\n    - bool: যদি পরিস্থিতি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    টেস্ট কেস:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "bg": "\n    Оценява последователността на сценарий, при който един участник е престъпникът въз основа на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и набор от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, пренебрегвайки всякакви изявления\n    за деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Набор от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Набор от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "zh": "\n    评估一个场景的连贯性，其中一个参与者是基于给定陈述的罪犯。\n\n    该函数接受一个潜在罪犯的名字（scenario）和一组说谎者（liar_count），并检查所有参与者的陈述是否与该场景一致，忽略任何关于星期几的陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 被假定为说谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者的名字映射到他们各自陈述的列表。\n    - days_of_week (set): 表示星期几的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致则为 True，否则为 False。\n\n    测试用例:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "fr": "\n    Évalue la cohérence d'un scénario où un participant est le criminel basé sur les déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé comme criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "de": "\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer basierend auf den gegebenen Aussagen der Täter ist.\n\n    Diese Funktion nimmt den Namen eines potenziellen Täters (scenario) und eine Menge von Lügnern (liar_count) und überprüft, ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario übereinstimmen, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n    - liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage darstellen.\n\n    Rückgabewert:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "ha": "\n    Kimanta daidaiton yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin makaryata (liar_count) kuma yana duba idan\n    bayanan da duk mahalarta suka bayar suna daidaita da wannan yanayi, ba tare da la'akari da duk wani bayani\n    game da ranar mako ba.\n\n    Sigogi:\n    - scenario (str): Sunan mahalartin da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saiti na sunayen mahalarta da ake ɗauka a matsayin makaryata.\n    - statements (dict): Kamus mai haɗa sunayen mahalarta da jerin bayanan su na musamman.\n    - days_of_week (set): Saiti na kirtani da ke wakiltar ranakun mako.\n\n    Abin da ake dawowa da shi:\n    - bool: Gaskiya idan yanayin yana daidaita da bayanan, Karya idan ba haka ba.\n\n    Gwaje-gwajen:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "hi": "\n    दिए गए बयानों के आधार पर एक परिदृश्य की संगति का मूल्यांकन करता है जहां एक प्रतिभागी अपराधी है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे व्यक्तियों का एक सेट (liar_count) लेता है और जांचता है कि\n    क्या सभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं, सप्ताह के दिन के बारे में किसी भी बयान को नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसका संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n    - liar_count (set): प्रतिभागियों के नामों का एक सेट जिन्हें झूठा माना जा रहा है।\n    - statements (dict): प्रतिभागियों के नामों को उनके संबंधित बयानों की सूचियों के साथ मैप करने वाली एक डिक्शनरी।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    रिटर्न्स:\n    - bool: True यदि परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\n    परीक्षण मामले:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True",
      "hu": "\n    Értékeli annak a forgatókönyvnek a következetességét, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnös nevét (forgatókönyv) és egy hazugok halmazát (hazugok_száma) veszi, és ellenőrzi, hogy az összes résztvevő által tett állítások következetesek-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjaira vonatkozó állításokat.\n\n    Paraméterek:\n    - scenario (str): A résztvevő neve, akit potenciális bűnösként vizsgálnak.\n    - liar_count (set): A résztvevők neveinek halmaza, akiket hazugnak feltételezünk.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a saját állításaik listájához rendeli.\n    - days_of_week (set): A hét napjait képviselő karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: Igaz, ha a forgatókönyv következetes az állításokkal, hamis egyébként.\n\n    Tesztesetek:\n    >>> check_scenario(\"ALICE\", {\"BOB\", \"CHARLIE\"}, {\"ALICE\": [\"I am guilty.\"], \"BOB\": [\"ALICE is not guilty.\"], \"CHARLIE\": []}, {\"MONDAY\", \"TUESDAY\"})\n    True"
    },
    "docstring_bertscore": {
      "sq": "0.9846635496499152",
      "hy": "0.9613312333112711",
      "bn": "0.9640484969238283",
      "bg": "0.9842345080268798",
      "zh": "0.9563311107294798",
      "fr": "0.9816904501065851",
      "de": "0.9769189510933649",
      "ha": "0.9547537868736817",
      "hi": "0.9720054313577049",
      "hu": "0.9658649717583924"
    }
  },
  {
    "task_id": "Python/33",
    "prompt": {
      "en": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "sq": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Llogarit rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_i_lojtari:rezultati_i_kundërshtarit\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje gjithashtu përfshihet në rezultat.\n\n    Argumentet:\n    - system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Kthen:\n    - list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\n    Rastet:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "hy": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Հաշվարկել սեղանի թենիսի խաղերի մի շարքերի միավորները՝ հիմնված տրամադրված միավորների համակարգի վրա։\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և տող, \n    որը ներկայացնում է խաղացողի ('W') և հակառակորդի ('L') շահած միավորների հաջորդականությունը։ \n    Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի միավորների ցուցակ՝ ձևաչափված որպես \"խաղացողի_միավոր:հակառակորդի_միավոր\"։\n\n    Խաղը համարվում է ավարտված, երբ մի խաղացող հասնում է համակարգի պահանջվող միավորների քանակին \n    (11 կամ 21) առնվազն 2 միավորի առավելությամբ։ Եթե միավորների հաջորդականությունը ավարտվում է խաղի կեսին, \n    այդ խաղի ընթացիկ միավորն էլ ներառվում է արդյունքի մեջ։\n\n    Պարամետրեր:\n    - system (int): Խաղը շահելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21)։\n    - points (str): 'W' և 'L' տառերի տող, որը նշում է խաղացողի և հակառակորդի շահած միավորները։\n\n    Վերադարձնում է:\n    - list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի միավորը։\n\n    Օրինակներ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "bn": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে পিং-পং গেমগুলোর একটি সিরিজের স্কোর গণনা করুন।\n\n    এই ফাংশনটি পছন্দের স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং নেয় \n    যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জেতা পয়েন্টগুলির ক্রম উপস্থাপন করে। \n    ফাংশনটি স্ট্রিং প্রক্রিয়া করে এবং গেম স্কোরের একটি তালিকা ফেরত দেয় যা \"player_score:opponent_score\" \n    হিসাবে ফরম্যাট করা হয়।\n\n    যখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২ পয়েন্টের \n    ব্যবধানে পৌঁছে যায়, তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। যদি পয়েন্টের ক্রম একটি গেমের \n    মাঝখানে শেষ হয়, সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্টস:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর মধ্যে একটি)।\n    - points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জেতা পয়েন্টগুলি নির্দেশ করে।\n\n    রিটার্নস:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    উদাহরণ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "bg": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Изчисляване на резултата от серия пинг-понг игри въз основа на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11, или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и опонента ('L'). \n    Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"player_score:opponent_score\".\n\n    Играта се счита за завършена, когато един играч достигне необходимия брой точки според системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки завърши в средата на игра, \n    текущият резултат от тази игра също се включва в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точки, спечелени от играча и опонента.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "zh": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    该函数接受所需的计分系统（11分或21分）和一个字符串，\n    该字符串表示玩家（'W'）和对手（'L'）赢得的分数序列。\n    该函数处理字符串并返回格式为 \"player_score:opponent_score\" 的比赛得分列表。\n\n    当一名玩家以至少2分的领先优势达到系统要求的分数（11或21分）时，比赛被视为结束。\n    如果分数序列在比赛中途结束，则该场比赛的当前得分也会包含在输出中。\n\n    参数:\n    - system (int): 赢得比赛所需的分数（11或21分）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回:\n    - list: 表示每场比赛得分的字符串列表。\n\n    示例:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "fr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculer le score d'une série de matchs de ping-pong en fonction du système de score fourni.\n\n    Cette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \n    représentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L').\n    La fonction traite la chaîne et renvoie une liste de scores de match formatés comme \"player_score:opponent_score\".\n\n    Le match est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n    (11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un match, \n    le score actuel de ce match est également inclus dans le résultat.\n\n    Arguments:\n    - system (int): Le nombre de points requis pour gagner un match (soit 11 ou 21).\n    - points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\n    Renvoie:\n    - list: Une liste de chaînes représentant le score de chaque match.\n\n    Cas:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "de": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Berechne die Punktzahl einer Reihe von Tischtennisspielen basierend auf dem bereitgestellten Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String, \n    der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt, entgegen. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielergebnissen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht \n    (11 oder 21) und mindestens einen Vorsprung von 2 Punkten hat. Wenn die Punktfolge mitten in einem Spiel endet, \n    wird der aktuelle Spielstand dieses Spiels ebenfalls in der Ausgabe enthalten.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\n    Rückgabe:\n    - list: Eine Liste von Strings, die die Punktzahl jedes Spiels darstellen.\n\n    Fälle:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "ha": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma igiyar \n    haruffa da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana aiwatar da igiyar kuma yana dawo da jerin maki na wasanni da aka tsara a matsayin \"maki_dan_wasa:maki_abokin_hamayya\".\n\n    Ana ɗaukar wasan ya ƙare idan ɗan wasa ɗaya ya kai adadin maki da tsarin ya tanada \n    (11 ko 21) tare da tazarar maki 2 aƙalla. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na wannan wasan a cikin sakamakon.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n    - points (str): Igiyar haruffa 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin igiyoyi da ke wakiltar maki na kowane wasa.\n\n    Misalai:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "hi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    प्रदान की गई स्कोरिंग प्रणाली के आधार पर पिंग-पोंग खेलों की एक श्रृंखला का स्कोर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग प्रणाली (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के क्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची लौटाता है जो \"player_score:opponent_score\" के रूप में स्वरूपित होती है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी प्रणाली द्वारा आवश्यक अंकों की संख्या (11 या 21) \n    कम से कम 2 अंकों की बढ़त के साथ प्राप्त कर लेता है। यदि अंकों का क्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल किया जाता है।\n\n    तर्क:\n    - system (int): एक खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    लौटाता है:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    उदाहरण:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\"",
      "hu": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Számítsa ki egy sor pingpong játék pontszámát a megadott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz fel, \n    amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát ábrázolja. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék pontszámokkal, \n    amelyek \"játékos_pontszám:ellenfél_pontszám\" formátumban vannak.\n\n    A játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által \n    megkövetelt pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata \n    egy játék közepén ér véget, akkor annak a játéknak az aktuális pontszáma is szerepel a kimenetben.\n\n    Paraméterek:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): Egy 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Visszatér:\n    - list: Egy karakterláncokból álló lista, amely az egyes játékok pontszámát ábrázolja.\n\n    Esetek:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9705286144747105",
      "hy": "0.9621215835974088",
      "bn": "0.9694367432701617",
      "bg": "0.9795388858192151",
      "zh": "0.9427608817275573",
      "fr": "0.9628886941289656",
      "de": "0.9663178490271519",
      "ha": "0.964456483726474",
      "hi": "0.9808391202934695",
      "hu": "0.9595459434465295"
    },
    "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores",
    "instruction": {
      "en": "Write a python function 'def calculate_score(system: int, points: str) -> list:' to solve the following problem:\n\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    ",
      "sq": "Shkruani një funksion python 'def calculate_score(system: int, points: str) -> list:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"player_score:opponent_score\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një epërsi prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje përfshihet gjithashtu në rezultat.\n\n    Args:\n    - system (int): Numri i pikëve të nevojshme për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Returns:\n    - list: Një listë e vargjeve që përfaqësojnë rezultatin e secilës lojë.\n\n    Rastet:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "hy": "Պայթոն ֆունկցիա 'def calculate_score(system: int, points: str) -> list:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել սերիական պինգ-պոնգ խաղերի հաշիվը՝ հիմնվելով տրամադրված միավորների համակարգի վրա։\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և տող, \n    որը ներկայացնում է խաղացողի ('W') և մրցակցի ('L') կողմից շահած միավորների հաջորդականությունը։ \n    Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի հաշիվների ցանկը, ձևաչափված որպես \"player_score:opponent_score\"։\n\n    Խաղը համարվում է ավարտված, երբ մեկ խաղացող հասնում է համակարգի պահանջվող միավորների քանակին \n    (11 կամ 21) առնվազն 2 միավորի առավելությամբ։ Եթե միավորների հաջորդականությունը ավարտվում է խաղի կեսին, \n    այդ խաղի ընթացիկ հաշիվը նույնպես ներառվում է արդյունքի մեջ։\n\n    Արգումենտներ:\n    - system (int): Խաղը հաղթելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21)։\n    - points (str): 'W' և 'L' նիշերի տող, որը նշում է խաղացողի և մրցակցի կողմից շահած միավորները։\n\n    Վերադարձնում է:\n    - list: Տողերի ցանկ, որը ներկայացնում է յուրաքանչյուր խաղի հաշիվը։\n\n    Դեպքեր:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "bn": "একটি পাইথন ফাংশন 'def calculate_score(system: int, points: str) -> list:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত স্কোরিং সিস্টেমের উপর ভিত্তি করে একটি সিরিজ পিং-পং গেমের স্কোর গণনা করুন।\n\n    এই ফাংশনটি কাঙ্ক্ষিত স্কোরিং সিস্টেম (১১ অথবা ২১ পয়েন্ট) এবং একটি স্ট্রিং গ্রহণ করে \n    যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জয়ী পয়েন্টগুলির ক্রমকে উপস্থাপন করে। \n    ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং \"player_score:opponent_score\" ফরম্যাটে গেমের স্কোরের একটি তালিকা প্রদান করে।\n\n    গেমটি শেষ হয়েছে বলে বিবেচিত হয় যখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা \n    (১১ অথবা ২১) কমপক্ষে ২ পয়েন্টের লিড সহ পৌঁছে যায়। যদি পয়েন্টের ক্রমটি একটি গেমের মাঝখানে শেষ হয়, \n    তবে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্ট:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ অথবা ২১)।\n    - points (str): খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জয়ী পয়েন্টগুলি নির্দেশ করে 'W' এবং 'L' অক্ষরের একটি স্ট্রিং।\n\n    রিটার্ন:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    কেস:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "bg": "Напишете Python функция 'def calculate_score(system: int, points: str) -> list:' за решаване на следния проблем:\n\n    Изчислете резултата от серия пинг-понг игри на базата на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11, или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). \n    Функцията обработва низа и връща списък от резултати на игрите, форматирани като \"player_score:opponent_score\".\n\n    Играта се счита за завършена, когато един играч достигне изисквания брой точки на системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки свършва в средата на игра, \n    текущият резултат на тази игра също е включен в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точките, спечелени от играча и противника.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "zh": "编写一个 Python 函数 'def calculate_score(system: int, points: str) -> list:' 来解决以下问题：\n\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    此函数接受所需的计分系统（11或21分）和一个字符串，表示玩家（'W'）和对手（'L'）赢得的分数序列。\n    函数处理该字符串并返回一个游戏得分列表，格式为 \"player_score:opponent_score\"。\n\n    当一名玩家达到系统要求的分数（11或21分）并至少领先2分时，比赛被认为结束。\n    如果分数序列在比赛中途结束，该场比赛的当前得分也会包含在输出中。\n\n    参数：\n    - system (int): 赢得比赛所需的分数（11或21）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回：\n    - list: 一个字符串列表，表示每场比赛的得分。\n\n    示例：\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "fr": "Écrivez une fonction python 'def calculate_score(system: int, points: str) -> list:' pour résoudre le problème suivant :\n\n    Calculer le score d'une série de parties de ping-pong en fonction du système de score fourni.\n\n    Cette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \n    représentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L'). \n    La fonction traite la chaîne et renvoie une liste de scores de jeu formatés comme \"player_score:opponent_score\".\n\n    Le jeu est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n    (11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un jeu, \n    le score actuel de ce jeu est également inclus dans la sortie.\n\n    Args:\n    - system (int): Le nombre de points requis pour gagner un jeu (soit 11 ou 21).\n    - points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\n    Returns:\n    - list: Une liste de chaînes représentant le score de chaque jeu.\n\n    Cas:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "de": "Schreiben Sie eine Python-Funktion 'def calculate_score(system: int, points: str) -> list:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Punktzahl einer Reihe von Tischtennisspielen basierend auf dem bereitgestellten Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String \n    entgegen, der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht \n    (11 oder 21) und dabei mindestens 2 Punkte Vorsprung hat. Wenn die Punktesequenz mitten in einem Spiel endet, \n    wird der aktuelle Spielstand ebenfalls in die Ausgabe aufgenommen.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\n    Rückgabe:\n    - list: Eine Liste von Strings, die die Punktzahl jedes Spiels darstellen.\n\n    Fälle:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "ha": "Rubuta wani aikin python 'def calculate_score(system: int, points: str) -> list:' don warware matsalar mai zuwa:\n\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani igiyar \n    da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana sarrafa igiyar kuma yana mayar da jerin maki na wasanni da aka tsara a matsayin \"player_score:opponent_score\".\n\n    Ana ɗaukar wasan ya ƙare lokacin da ɗan wasa ɗaya ya kai adadin maki da tsarin ya buƙata \n    (11 ko 21) tare da akalla tazarar maki 2. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na yanzu na wannan wasan a cikin fitarwa.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n    - points (str): Igiyar haruffa 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin igiyoyi da ke wakiltar maki na kowanne wasa.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "hi": "एक पायथन फ़ंक्शन 'def calculate_score(system: int, points: str) -> list:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए स्कोरिंग सिस्टम के आधार पर पिंग-पोंग खेलों की एक श्रृंखला का स्कोर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग सिस्टम (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के अनुक्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और खेल स्कोर की एक सूची को \"player_score:opponent_score\" के रूप में स्वरूपित करके लौटाता है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी सिस्टम द्वारा आवश्यक अंकों की संख्या (11 या 21) \n    कम से कम 2 अंकों की बढ़त के साथ प्राप्त कर लेता है। यदि अंकों का अनुक्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल किया जाता है।\n\n    तर्क:\n    - system (int): खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    लौटाता है:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    मामले:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "hu": "Írj egy python függvényt 'def calculate_score(system: int, points: str) -> list:' a következő probléma megoldására:\n\n    Számítsd ki egy sorozat ping-pong játék eredményét a megadott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot \n    vesz át, amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorrendjét ábrázolja. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék eredményeivel, \n    \"player_score:opponent_score\" formátumban.\n\n    A játék befejezettnek tekinthető, amikor az egyik játékos eléri a rendszer által megkövetelt \n    pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorrendje egy játék közepén ér véget, \n    akkor annak a játéknak az aktuális eredménye is szerepel a kimenetben.\n\n    Argok:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): Egy 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Visszatér:\n    - list: Egy karakterláncokból álló lista, amely az egyes játékok eredményét ábrázolja.\n\n    Esetek:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]"
    },
    "instruction_bertscore": {
      "sq": "0.9778143768510702",
      "hy": "0.9629506668078485",
      "bn": "0.9728148501604221",
      "bg": "0.9809582985220905",
      "zh": "0.9440629038752409",
      "fr": "0.9841123503425434",
      "de": "0.9606479448005111",
      "ha": "0.9770993074793446",
      "hi": "0.9809964355552492",
      "hu": "0.9657898894743612"
    },
    "level": "middle",
    "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()",
    "entry_point": "calculate_score",
    "signature": "def calculate_score(system: int, points: str) -> list:",
    "docstring": {
      "en": "\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]\n    ",
      "sq": "\n    Llogaritni rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_i_lojtari:rezultati_i_kundërshtari\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje përfshihet gjithashtu në dalje.\n\n    Args:\n    - system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Returns:\n    - list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\n    Raste:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "hy": "\n    Հաշվեք սերիայի պինգ-պոնգ խաղերի միավորները ըստ տրված միավորների համակարգի:\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և տող, \n    որը ներկայացնում է խաղացողի ('W') և հակառակորդի ('L') շահած միավորների հաջորդականությունը: \n    Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի միավորների ցուցակը, ձևաչափված որպես \"խաղացողի_միավոր:հակառակորդի_միավոր\":\n\n    Խաղը համարվում է ավարտված, երբ խաղացողներից մեկը հասնում է համակարգի պահանջվող միավորների քանակին \n    (11 կամ 21) առնվազն 2 միավորի առավելությամբ: Եթե միավորների հաջորդականությունը ավարտվում է խաղի \n    ընթացքում, այդ խաղի ընթացիկ միավորն էլ ներառվում է արդյունքի մեջ:\n\n    Արգումենտներ:\n    - system (int): Խաղը հաղթելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21):\n    - points (str): 'W' և 'L' տառերի տող, որը նշում է խաղացողի և հակառակորդի շահած միավորները:\n\n    Վերադարձնում է:\n    - list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի միավորը:\n\n    Օրինակներ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "bn": "\n    প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে একাধিক পিং-পং গেমের স্কোর গণনা করুন।\n\n    এই ফাংশনটি কাঙ্ক্ষিত স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং গ্রহণ করে \n    যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জিতেছে এমন পয়েন্টগুলির ক্রম উপস্থাপন করে। \n    ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং \"player_score:opponent_score\" হিসাবে ফরম্যাট করা গেম স্কোরের একটি তালিকা প্রদান করে।\n\n    যখন কোনো খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২-পয়েন্ট লিড সহ পৌঁছে যায়, \n    তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। যদি পয়েন্টের ক্রম গেমের মাঝখানে শেষ হয়, \n    তাহলে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্ট:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর মধ্যে একটি)।\n    - points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জিতেছে এমন পয়েন্টগুলি নির্দেশ করে।\n\n    রিটার্ন:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    উদাহরণ:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "bg": "\n    Изчислете резултата от серия пинг-понг игри въз основа на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11, или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). \n    Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"резултат_на_играча:резултат_на_противника\".\n\n    Играта се счита за завършена, когато един играч достигне изисквания брой точки на системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки завърши в средата на игра, \n    текущият резултат на тази игра също се включва в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точки, спечелени от играча и противника.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "zh": "\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    该函数接收所需的计分系统（11分或21分）和一个表示玩家（'W'）和对手（'L'）赢得的分数序列的字符串。\n    函数处理该字符串并返回格式为 \"player_score:opponent_score\" 的比赛得分列表。\n\n    当一名玩家达到系统要求的分数（11分或21分）并至少领先2分时，比赛被视为结束。\n    如果分数序列在比赛中途结束，该比赛的当前得分也将包含在输出中。\n\n    参数:\n    - system (int): 赢得比赛所需的分数（11分或21分）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回:\n    - list: 表示每场比赛得分的字符串列表。\n\n    示例:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "fr": "\n    Calculer le score d'une série de matchs de ping-pong en fonction du système de score fourni.\n\nCette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \nreprésentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L'). \nLa fonction traite la chaîne et renvoie une liste de scores de matchs formatés comme \"score_joueur:score_adversaire\".\n\nLe match est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n(11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un match, \nle score actuel de ce match est également inclus dans le résultat.\n\nArguments:\n- system (int): Le nombre de points requis pour gagner un match (soit 11 ou 21).\n- points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\nRenvoie:\n- list: Une liste de chaînes représentant le score de chaque match.\n\nCas:\n>>> calculate_score(11, \"WWWWWWWWWWL\")\n[\"10:1\"]",
      "de": "\n    Berechne die Punktzahl einer Serie von Tischtennisspielen basierend auf dem bereitgestellten Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String \n    entgegen, der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht \n    (11 oder 21) und dabei mindestens einen Vorsprung von 2 Punkten hat. Wenn die Punktesequenz mitten in einem Spiel endet, \n    wird der aktuelle Spielstand ebenfalls in die Ausgabe aufgenommen.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte kennzeichnen.\n\n    Rückgabe:\n    - list: Eine Liste von Strings, die den Spielstand jedes Spiels darstellen.\n\n    Fälle:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "ha": "\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani zare \n    da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana sarrafa zaren kuma yana dawo da jerin maki na wasanni da aka tsara kamar \"maki_ɗan_wasa:maki_abokin_hamayya\".\n\n    Ana ɗaukar wasan ya ƙare lokacin da ɗan wasa ɗaya ya kai adadin maki da tsarin ke buƙata \n    (11 ko 21) tare da tazarar maki 2 aƙalla. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na wannan wasan a cikin sakamakon da aka bayar.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n    - points (str): Zaren haruffa 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin zaren da ke wakiltar maki na kowane wasa.\n\n    Cases:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "hi": "\n    एक श्रृंखला के पिंग-पोंग खेलों का स्कोर दिए गए स्कोरिंग सिस्टम के आधार पर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग सिस्टम (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के क्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची लौटाता है जो \"player_score:opponent_score\" के रूप में स्वरूपित होती है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी सिस्टम द्वारा आवश्यक अंकों की संख्या तक पहुँच जाता है \n    (11 या 21) कम से कम 2 अंकों की बढ़त के साथ। यदि अंकों का क्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल किया जाता है।\n\n    आर्ग्स:\n    - system (int): एक खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    रिटर्न्स:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    मामले:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]",
      "hu": "\n    Számítsa ki egy sor pingpong játék pontszámát a megadott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz be, \n    amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát jelöli. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék pontszámairól, \n    \"játékos_pontszám:ellenfél_pontszám\" formátumban.\n\n    A játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által megkövetelt \n    pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata egy játék közepén ér véget, \n    akkor annak a játéknak az aktuális pontszáma is szerepel a kimenetben.\n\n    Paraméterek:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): Egy 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Visszatér:\n    - list: Egy karakterláncokból álló lista, amely az egyes játékok pontszámát jelöli.\n\n    Esetek:\n    >>> calculate_score(11, \"WWWWWWWWWWL\")\n    [\"10:1\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9795913242398083",
      "hy": "0.9590938606992941",
      "bn": "0.9613211031618383",
      "bg": "0.979276296455487",
      "zh": "0.949916143943577",
      "fr": "0.9614839800742869",
      "de": "0.9606543009727042",
      "ha": "0.9620190903207949",
      "hi": "0.9788172616449153",
      "hu": "0.9618969326364585"
    }
  },
  {
    "task_id": "Python/34",
    "prompt": {
      "en": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"",
      "sq": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Llogarit numrin e n-të të Catalan-it.\n\n    Funksioni llogarit numrin e n-të të Catalan-it duke përdorur programimin dinamik. Numrat e Catalan-it janë një sekuencë \n    e numrave natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e disa llojeve të shtigjeve \n    në rrjetë, numrin e shprehjeve që përmbajnë n çifte kllapash që janë të përputhura saktë, numrin e mënyrave të ndryshme si \n    faktorët n+1 mund të vendosen plotësisht në kllapa, dhe më shumë.\n\n    Args:\n    - n (int): Pozicioni në sekuencën e numrave të Catalan-it për të llogaritur (duhet të jetë jo-negativ).\n\n    Returns:\n    - int: Numri i n-të i Catalan-it.\n\n    Raste:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.\n    \"\"\"",
      "hy": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Հաշվել n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, \n    որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորիկ մաթեմատիկայում, ներառյալ որոշ տեսակների ցանցային ուղիների հաշվարկը, \n    n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ համընկնում են, n+1 գործոնների ամբողջական փակագծման տարբեր եղանակների քանակը և ավելին։\n\n    Արգումենտներ:\n    - n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվել (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0) հավասար է 1:\n    \"\"\"",
      "bn": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth ক্যাটালান সংখ্যা গণনা করুন।\n\n    ফাংশনটি ডাইনামিক প্রোগ্রামিং ব্যবহার করে nth ক্যাটালান সংখ্যা গণনা করে। ক্যাটালান সংখ্যা একটি প্রাকৃতিক সংখ্যা \n    ক্রম যা সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, যার মধ্যে নির্দিষ্ট ধরনের ল্যাটিস পথের গণনা, n জোড়া বন্ধনী \n    ধারণকারী প্রকাশের সংখ্যা যা সঠিকভাবে মেলানো হয়েছে, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন \n    উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\n    আর্গুমেন্ট:\n    - n (int): ক্যাটালান সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-নেতিবাচক হতে হবে)।\n\n    রিটার্নস:\n    - int: nth ক্যাটালান সংখ্যা।\n\n    কেস:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    নোট:\n    গণনা পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।\n    \"\"\"",
      "bg": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Изчисляване на n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са редица от естествени \n    числа, които имат много приложения в комбинаторната математика, включително броене на определени видове решетъчни пътища, \n    броят на изразите, съдържащи n двойки скоби, които са правилно съчетани, броят на различните начини, по които n+1 \n    фактора могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в редицата на числата на Каталан, която да се изчисли (трябва да е неотрицателно).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Забележка:\n    Изчислението се базира на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.\n    \"\"\"",
      "zh": "def catalan_number(n: int) -> int:\n    \"\"\"\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，\n    包括计数某些类型的格路径、包含 n 对括号的表达式的正确匹配数、n+1 个因子完全括号化的不同方式数等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负数）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    示例:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    计算基于递归公式:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 为 1。\n    \"\"\"",
      "fr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une séquence de nombres naturels \n    qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de certains types de chemins de grille, \n    le nombre d'expressions contenant n paires de parenthèses correctement appariées, le nombre de façons différentes dont n+1 \n    facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Args:\n    - n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\n    Returns:\n    - int: Le nième nombre de Catalan.\n\n    Cas:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Remarque:\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.\n    \"\"\"",
      "de": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Berechne die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine \n    Folge natürlicher Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung \n    bestimmter Arten von Gitterpfaden, der Anzahl der Ausdrücke, die n korrekt gepaarte Klammern enthalten, der Anzahl der \n    verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht-negativ sein).\n\n    Rückgabewert:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.\n    \"\"\"",
      "ha": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Lissafi na Catalan na n.\n\n    Aikin yana lissafin lambar Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan suna da jerin lambobin halitta \n    waɗanda suke da aikace-aikace da yawa a cikin lissafin haɗuwa, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin jimlolin da ke ɗauke da nau'i-nau'i na ma'aurata waɗanda aka daidaita daidai, adadin hanyoyin daban-daban na n+1 \n    abubuwa za a iya sanya su cikin ma'aurata gaba ɗaya, da sauransu.\n\n    Args:\n    - n (int): Matsayi a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lambar Catalan ta n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.\n    \"\"\"",
      "hi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth कैटलन संख्या की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक संख्याओं का एक अनुक्रम हैं \n    जिनके संयोज्य गणित में कई अनुप्रयोग हैं, जिनमें कुछ प्रकार के जाली पथों की गिनती, n जोड़े कोष्ठकों वाली अभिव्यक्तियों की संख्या \n    जो सही ढंग से मेल खाते हैं, n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और भी बहुत कुछ शामिल हैं।\n\n    तर्क:\n    - n (int): कैटलन संख्या अनुक्रम में गणना करने के लिए स्थिति (गैर-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth कैटलन संख्या।\n\n    मामले:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।\n    \"\"\"",
      "hu": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Számítsa ki az n-edik Catalan számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok egy olyan természetes \n    számok sorozata, amely számos alkalmazással bír a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak számolását, \n    az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző módon történő teljes \n    zárójelezésének számát, és még sok más.\n\n    Paraméterek:\n    - n (int): A Catalan szám sorozatban lévő pozíció, amelyet ki kell számítani (nem lehet negatív).\n\n    Visszatér:\n    - int: Az n-edik Catalan szám.\n\n    Esetek:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Megjegyzés:\n    A számítás az alábbi rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9809666409980939",
      "hy": "0.9726883226077029",
      "bn": "0.9617868914053651",
      "bg": "0.9773930818128952",
      "zh": "0.9707717380610973",
      "fr": "0.9744678521913944",
      "de": "0.9614166443751161",
      "ha": "0.940458954241744",
      "hi": "0.9710124780829115",
      "hu": "0.9584240790544445"
    },
    "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]",
    "instruction": {
      "en": "Write a python function 'def catalan_number(n: int) -> int:' to solve the following problem:\n\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    ",
      "sq": "Shkruani një funksion python 'def catalan_number(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit numrin e n-të të Katalanit.\n\n    Funksioni llogarit numrin e n-të të Katalanit duke përdorur programimin dinamik. Numrat e Katalanit janë një sekuencë \n    numrash natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e llojeve të caktuara të shtigjeve të rrjetit, \n    numrin e shprehjeve që përmbajnë n çifte kllapash që janë të lidhura saktë, numrin e mënyrave të ndryshme që n+1 \n    faktorë mund të parentezohen plotësisht, dhe më shumë.\n\n    Args:\n    - n (int): Pozicioni në sekuencën e numrave të Katalanit për të llogaritur (duhet të jetë jo-negativ).\n\n    Returns:\n    - int: Numri i n-të i Katalanit.\n\n    Rastet:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.",
      "hy": "Պայթոն ֆունկցիա 'def catalan_number(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվարկում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական \n    թվերի հաջորդականություն են, որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորիկ մաթեմատիկայում, ներառյալ որոշակի \n    տեսակների ցանցային ուղիների հաշվարկը, n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են համընկնում, \n    n+1 գործոնների ամբողջական փակագծման տարբեր եղանակների քանակը և ավելին։\n\n    Արգումենտներ:\n    - n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվարկվի (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0) հավասար է 1։",
      "bn": "একটি পাইথন ফাংশন 'def catalan_number(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    nth ক্যাটালান সংখ্যা গণনা করুন।\n\n    ফাংশনটি ডাইনামিক প্রোগ্রামিং ব্যবহার করে nth ক্যাটালান সংখ্যা গণনা করে। ক্যাটালান সংখ্যা একটি প্রাকৃতিক সংখ্যার ক্রম যা সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, \n    যার মধ্যে কিছু প্রকারের ল্যাটিস পথের গণনা, n জোড়া বন্ধনী ধারণকারী সঠিকভাবে মিলিত প্রকাশের সংখ্যা, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু অন্তর্ভুক্ত।\n\n    Args:\n    - n (int): ক্যাটালান সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\n    Returns:\n    - int: nth ক্যাটালান সংখ্যা।\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    গণনা পুনরাবৃত্তিমূলক সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।",
      "bg": "Напишете Python функция 'def catalan_number(n: int) -> int:' за да решите следния проблем:\n\n    Изчислете n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са последователност \n    от естествени числа, които имат много приложения в комбинаторната математика, включително броене на определени видове \n    решетъчни пътеки, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини, \n    по които n+1 фактори могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в последователността на числата на Каталан, която да се изчисли (трябва да бъде неотрицателна).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Забележка:\n    Изчислението се основава на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.",
      "zh": "编写一个 Python 函数 'def catalan_number(n: int) -> int:' 来解决以下问题：\n\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一个自然数序列，\n    在组合数学中有许多应用，包括计数某些类型的格路径、包含 n 对正确匹配的括号的表达式数量、\n    n+1 个因子可以完全括号化的不同方式数量等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负数）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    示例:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    计算基于递归公式：\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 为 1。",
      "fr": "Écrire une fonction python 'def catalan_number(n: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une séquence de nombres naturels \n    qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de certains types de chemins de réseau, \n    le nombre d'expressions contenant n paires de parenthèses correctement appariées, le nombre de façons différentes dont n+1 \n    facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Arguments :\n    - n (int) : La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\n    Renvoie :\n    - int : Le nième nombre de Catalan.\n\n    Cas :\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Remarque :\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.",
      "de": "Schreiben Sie eine Python-Funktion 'def catalan_number(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine Sequenz von natürlichen \n    Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung bestimmter Arten von Gitterpfaden, \n    der Anzahl der Ausdrücke, die n korrekt gepaarte Klammerpaare enthalten, der Anzahl der verschiedenen Möglichkeiten, n+1 \n    Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlen-Sequenz, die berechnet werden soll (muss nicht-negativ sein).\n\n    Rückgabewert:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.",
      "ha": "Rubuta wani aikin python 'def catalan_number(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa lambar Catalan ta n.\n\n    Aikin yana lissafin lambar Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan suna jerin lambobin halitta \n    waɗanda ke da aikace-aikace da yawa a cikin lissafin haɗin gwiwa, gami da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin maganganun da ke ɗauke da nau'i-nau'i na n waɗanda aka haɗa su daidai, adadin hanyoyin daban-daban na n+1 \n    abubuwan da za a iya rufe su gaba ɗaya, da ƙari.\n\n    Args:\n    - n (int): Matsayin a cikin jerin lambobin Catalan don lissafawa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lambar Catalan ta n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.",
      "hi": "एक पायथन फ़ंक्शन 'def catalan_number(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    nth कैटलन संख्या की गणना करें।\n\n    फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक \n    संख्याओं का एक अनुक्रम हैं जिनका संयोजकीय गणित में कई अनुप्रयोग होते हैं, जिनमें कुछ प्रकार के लैटिस पथों की गिनती, \n    n जोड़े कोष्ठकों वाले अभिव्यक्तियों की संख्या जो सही ढंग से मेल खाते हैं, n+1 \n    कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\n    तर्क:\n    - n (int): कैटलन संख्या अनुक्रम में गणना करने की स्थिति (अ-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth कैटलन संख्या।\n\n    मामले:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।",
      "hu": "Írj egy python függvényt 'def catalan_number(n: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki az n-edik Catalan számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok egy természetes számokból álló sorozat, amelynek számos alkalmazása van a kombinatorikus matematikában, beleértve bizonyos típusú rácsútvonalak számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző módon történő teljes zárójelezésének számát, és még sok mást.\n\n    Argumentumok:\n    - n (int): A Catalan szám sorozatban kiszámítandó pozíció (nem lehet negatív).\n\n    Visszatér:\n    - int: Az n-edik Catalan szám.\n\n    Esetek:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Megjegyzés:\n    A számítás a rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1."
    },
    "instruction_bertscore": {
      "sq": "0.9809624697600922",
      "hy": "0.9607625545303682",
      "bn": "0.9734103440427647",
      "bg": "0.9750937365220353",
      "zh": "0.9722588837239055",
      "fr": "0.9764571354574588",
      "de": "0.9675692204276717",
      "ha": "0.9688712425753554",
      "hi": "0.9739619406108986",
      "hu": "0.9652672929418584"
    },
    "level": "easy",
    "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()",
    "entry_point": "catalan_number",
    "signature": "def catalan_number(n: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    ",
      "sq": "\n    Llogarit numrin e n-të të Catalan.\n\n    Funksioni llogarit numrin e n-të të Catalan duke përdorur programimin dinamik. Numrat Catalan janë një sekuencë \n    numrash natyralë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e disa llojeve të \n    shtigjeve të rrjetit, numrin e shprehjeve që përmbajnë n çifte kllapash që janë të përputhura saktësisht, numrin e \n    mënyrave të ndryshme që n+1 faktorë mund të parantezohen plotësisht, dhe më shumë.\n\n    Argumentet:\n    - n (int): Pozicioni në sekuencën e numrave të Catalan për të llogaritur (duhet të jetë jo-negativ).\n\n    Kthen:\n    - int: Numri i n-të i Catalan.\n\n    Raste:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.\n    ",
      "hy": "\n    Հաշվեք n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվարկում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, \n    որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորական մաթեմատիկայում, ներառյալ որոշ տեսակների ցանցային ուղիների հաշվարկը, \n    n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են համընկնում, n+1 գործոնների ամբողջական փակագծման \n    տարբեր եղանակների քանակը և այլն։\n\n    Արգումենտներ:\n    - n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվարկել (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0)-ը 1 է։\n    ",
      "bn": "\n    nth Catalan সংখ্যা গণনা করুন।\n\n    ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে nth Catalan সংখ্যা গণনা করে। Catalan সংখ্যা হল প্রাকৃতিক সংখ্যার একটি ক্রম, \n    যার অনেক প্রয়োগ রয়েছে সমাবেশিক গণিতে, যার মধ্যে রয়েছে নির্দিষ্ট ধরনের ল্যাটিস পথের গণনা, \n    n জোড়া বন্ধনী ধারণকারী অভিব্যক্তির সংখ্যা যা সঠিকভাবে মেলানো হয়েছে, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত \n    করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\n    আর্গুমেন্ট:\n    - n (int): Catalan সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\n    রিটার্ন:\n    - int: nth Catalan সংখ্যা।\n\n    কেস:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    নোট:\n    গণনাটি পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।\n    ",
      "bg": "\n    Изчислете n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са последователност от \n    естествени числа, които имат много приложения в комбинаторната математика, включително преброяване на определени видове \n    решетъчни пътища, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини, по които \n    n+1 фактора могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в последователността на числата на Каталан, която трябва да се изчисли (трябва да е неотрицателна).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Забележка:\n    Изчислението се основава на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.\n    ",
      "zh": "\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，包括计数某些类型的格路径、包含 n 对括号的正确匹配表达式的数量、n+1 个因子可以完全括起来的不同方式的数量等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负的）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    情况:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    注意:\n    计算基于递归公式:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 是 1。\n    ",
      "fr": "\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une \n    séquence de nombres naturels qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de \n    certains types de chemins de grille, le nombre d'expressions contenant n paires de parenthèses correctement appariées, \n    le nombre de façons différentes dont n+1 facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Args:\n    - n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non-négative).\n\n    Returns:\n    - int: Le nième nombre de Catalan.\n\n    Cas:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Note:\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.\n    ",
      "de": "\n    Berechne die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine \n    Folge von natürlichen Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung \n    bestimmter Arten von Gitterpfaden, der Anzahl der Ausdrücke, die n korrekt gepaarte Klammern enthalten, der Anzahl der \n    verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht negativ sein).\n\n    Rückgabe:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.\n    ",
      "ha": "\n    Lissafi lamba ta Catalan ta n.\n\n    Aikin yana lissafin lamba ta Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan jerin lambobi ne na halitta \n    waɗanda suke da aikace-aikace da yawa a cikin lissafin haɗin gwiwa, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin jimlolin da ke ɗauke da nau'i-nau'i na ma'aurata waɗanda aka haɗa daidai, adadin hanyoyin daban-daban na n+1 \n    abubuwa za a iya raba su gaba ɗaya, da ƙari.\n\n    Args:\n    - n (int): Matsayi a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lamba ta Catalan ta n.\n\n    Cases:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Lura:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.\n    ",
      "hi": "\n    nth Catalan संख्या की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth Catalan संख्या की गणना करता है। Catalan संख्याएँ प्राकृतिक संख्याओं की एक श्रृंखला हैं जिनका संयोजक गणित में कई अनुप्रयोग हैं, जिसमें कुछ प्रकार के जाली पथों की गिनती, n जोड़े कोष्ठकों वाले अभिव्यक्तियों की संख्या जो सही ढंग से मेल खाते हैं, n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\n    तर्क:\n    - n (int): Catalan संख्या अनुक्रम में गणना करने के लिए स्थिति (गैर-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth Catalan संख्या।\n\n    मामले:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।",
      "hu": "\n    Számítsa ki az n-edik Catalan számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok olyan természetes számok sorozata, amelyeknek számos alkalmazása van a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen párosítottak, az n+1 tényező teljes zárójelezésének különböző módjait, és még sok mást.\n\n    Paraméterek:\n    - n (int): A Catalan szám sorozatban a kiszámítandó pozíció (nem lehet negatív).\n\n    Visszatér:\n    - int: Az n-edik Catalan szám.\n\n    Esetek:\n      catalan_number(0) -> 1\n      catalan_number(3) -> 5\n      catalan_number(5) -> 42\n    Megjegyzés:\n    A számítás az alábbi rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.\n    "
    },
    "docstring_bertscore": {
      "sq": "0.9774645887500678",
      "hy": "0.9726841513697011",
      "bn": "0.9670845622979466",
      "bg": "0.9719597463700669",
      "zh": "0.9599626699859407",
      "fr": "0.9686680436955567",
      "de": "0.9598186629596904",
      "ha": "0.9334081716061485",
      "hi": "0.9655251151764417",
      "hu": "0.9471253870900369"
    }
  },
  {
    "task_id": "Python/35",
    "prompt": {
      "en": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "sq": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion kalon nëpër listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke marrë parasysh një shtesë prej 30cm që ofron stoli.\n\n    Shembuj rastesh:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "hy": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Հաշվել այն խնձորների քանակը, որոնք Թաո Թաոն կարող է հասնել։\n\n    Պարամետրեր:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Թաո Թաոն կարող է հասնել իր ձեռքը վեր բարձրացնելիս (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել՝ կանգնած կամ առանց 30 սմ բարձրության նստարանի։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցանկով և հաշվում, թե դրանցից քանիսն են Թաո Թաոյի հասանելիության սահմաններում՝\n    հաշվի առնելով 30 սմ հավելյալ բարձրությունը, որը տրամադրում է նստարանը։\n\n    Օրինակներ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0\n    \"\"\"",
      "bn": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    কতগুলি আপেল তাও তাও পৌঁছাতে পারে তা গণনা করুন।\n\n    Args:\n    apple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে পৌঁছাতে পারে এমন সর্বাধিক উচ্চতা (সেন্টিমিটারে)।\n\n    Returns:\n    int: তাও তাও একটি 30cm স্টুলে দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং তাদের মধ্যে কতগুলি তাও তাও এর নাগালের মধ্যে আছে তা গণনা করে,\n    স্টুলটি যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "bg": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Изчислете броя на ябълките, до които Тао Тао може да достигне.\n\n    Аргументи:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, до която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Връща:\n    int: Броят на ябълките, до които Тао Тао може да достигне със или без да стои на столче от 30 см.\n\n    Тази функция преминава през списъка с височини на ябълките и брои колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30 см, които столчето предоставя.\n\n    Примерни случаи:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "zh": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    计算陶陶可以够到的苹果数量。\n\n    参数:\n    apple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\n    tao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n    返回:\n    int: 陶陶站在30厘米高的凳子上或不站凳子上可以够到的苹果数量。\n\n    该函数遍历苹果高度列表，并计算其中有多少在陶陶的可达范围内，\n    考虑到凳子提供的额外30厘米。\n\n    示例案例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "fr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes à partir du sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en considérant un supplément de 30 cm que le tabouret fournit.\n\n    Exemples de cas :\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "de": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Args:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Returns:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon in Reichweite von Tao Tao sind,\n    wobei zusätzliche 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispielhafte Fälle:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "ha": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Lissafa yawan tuffaɗan da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffaɗan daga ƙasa (a santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a santimita).\n\n    Returns:\n    int: Yawan tuffaɗan da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujerar 30cm ba.\n\n    Wannan aikin yana zagayawa cikin jerin tsayin tuffaɗan kuma yana ƙirga nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lokuta:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "hi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    गणना करें कि ताओ ताओ कितने सेब तक पहुँच सकती है।\n\n    Args:\n    apple_heights (List[int]): जमीन से सेबों की ऊँचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊँचाई तक ताओ ताओ अपने हाथ को ऊपर की ओर खींचकर पहुँच सकती है (सेंटीमीटर में)।\n\n    Returns:\n    int: सेबों की संख्या जिन तक ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े होकर पहुँच सकती है।\n\n    यह फ़ंक्शन सेबों की ऊँचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुँच के भीतर हैं,\n    30 सेमी की अतिरिक्त ऊँचाई को ध्यान में रखते हुए जो स्टूल प्रदान करता है।\n\n    उदाहरण मामले:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    \"\"\"",
      "hu": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Számítsd ki, hogy hány almát ér el Tao Tao.\n\n    Paraméterek:\n    apple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet kinyújtott kézzel (centiméterben).\n\n    Visszatér:\n    int: Az almák száma, amelyeket Tao Tao elérhet akár egy 30 cm-es zsámolyon állva is.\n\n    Ez a függvény végigmegy az almák magasságának listáján, és megszámolja, hány közülük van Tao Tao elérhetőségi tartományában,\n    figyelembe véve a zsámoly által biztosított további 30 cm-t.\n\n    Példa esetek:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.986626415075302",
      "hy": "0.9535580319798518",
      "bn": "0.9670358978545931",
      "bg": "0.9781999184206589",
      "zh": "0.9631711465307973",
      "fr": "0.9901836865692558",
      "de": "0.9790870017023607",
      "ha": "0.983455082411699",
      "hi": "0.9739488310057502",
      "hu": "0.966688096057401"
    },
    "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples",
    "instruction": {
      "en": "Write a python function 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' to solve the following problem:\n\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    ",
      "sq": "Shkruani një funksion python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion kalon nëpër listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke marrë parasysh një shtesë prej 30cm që stoli ofron.\n\n    Raste shembuj:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "hy": "Պայթոն ֆունկցիա 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք այն խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել։\n\n    Արգումենտներ:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Թաո Թաոն կարող է հասնել՝ ձեռքը վեր պարզելով (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել՝ կանգնելով կամ չկանգնելով 30 սմ բարձրության նստարանի վրա։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցուցակի միջով և հաշվում, թե դրանցից քանիսն են Թաո Թաոի հասանելիության սահմաններում՝ հաշվի առնելով 30 սմ լրացուցիչ բարձրությունը, որը տրամադրում է նստարանը։\n\n    Օրինակներ:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0",
      "bn": "একটি পাইথন ফাংশন 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    তাও তাও কতগুলি আপেল পৌঁছাতে পারে তা গণনা করুন।\n\n    আর্গুমেন্টস:\n    apple_heights (List[int]): মাটি থেকে আপেলগুলির উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে সর্বাধিক যে উচ্চতায় পৌঁছাতে পারে (সেন্টিমিটারে)।\n\n    রিটার্নস:\n    int: তাও তাও একটি 30cm স্টুলের উপর দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলগুলির উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং তাদের মধ্যে কতগুলি তাও তাও এর নাগালের মধ্যে রয়েছে তা গণনা করে,\n    স্টুলটি যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "bg": "Напишете Python функция 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:', за да решите следния проблем:\n\n    Изчислете броя на ябълките, които Тао Тао може да достигне.\n\n    Аргументи:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Връща:\n    int: Броят на ябълките, които Тао Тао може да достигне със или без да стои на 30см столче.\n\n    Тази функция преминава през списъка с височини на ябълките и преброява колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30см, които предоставя столчето.\n\n    Примерни случаи:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0",
      "zh": "编写一个Python函数 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' 来解决以下问题：\n\n    计算陶陶可以够到的苹果数量。\n\n    参数：\n    apple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\n    tao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n    返回：\n    int: 陶陶在站上30厘米高的凳子上或不站凳子时可以够到的苹果数量。\n\n    此函数遍历苹果高度列表，并计算有多少苹果在陶陶的可及范围内，\n    考虑到凳子提供的额外30厘米。\n\n    示例案例：\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 返回 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 返回 0",
      "fr": "Écrivez une fonction python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes à partir du sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en tenant compte d'un supplément de 30 cm que le tabouret fournit.\n\n    Cas d'exemple :\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "de": "Schreiben Sie eine Python-Funktion 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Argumente:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Rückgabewert:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne Stehen auf einem 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion durchläuft die Liste der Apfelhöhen und zählt, wie viele davon innerhalb der Reichweite von Tao Tao liegen,\n    wobei zusätzlich 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispiel-Fälle:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> gibt 10 zurück\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> gibt 0 zurück",
      "ha": "Rubuta wani aikin python 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffa daga ƙasa (a cikin santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa tare da hannunta a miƙe sama (a cikin santimita).\n\n    Returns:\n    int: Yawan tuffa da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujerar 30cm ba.\n\n    Wannan aikin yana juyawa ta jerin tsayin tuffa kuma yana ƙidaya nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lokuta:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "hi": "एक पायथन फ़ंक्शन 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    उन सेबों की संख्या की गणना करें जिन्हें ताओ ताओ पहुंच सकती है।\n\n    तर्क:\n    apple_heights (List[int]): जमीन से सेबों की ऊंचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊंचाई जिसे ताओ ताओ अपने हाथ को ऊपर की ओर खींचकर पहुंच सकती है (सेंटीमीटर में)।\n\n    लौटाता है:\n    int: उन सेबों की संख्या जिन्हें ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े हुए पहुंच सकती है।\n\n    यह फ़ंक्शन सेब की ऊंचाइयों की सूची पर पुनरावृत्ति करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुंच के भीतर हैं,\n    स्टूल द्वारा प्रदान किए गए अतिरिक्त 30 सेमी को ध्यान में रखते हुए।\n\n    उदाहरण मामले:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "hu": "Írj egy python függvényt 'def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki, hány almát ér el Tao Tao.\n\n    Args:\n    apple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet kinyújtott kézzel (centiméterben).\n\n    Visszatér:\n    int: Az almák száma, amelyeket Tao Tao elérhet akár 30 cm-es sámlin állva, akár anélkül.\n\n    Ez a függvény végigmegy az alma magasságok listáján, és megszámolja, hány van közülük Tao Tao elérhetőségi tartományában,\n    figyelembe véve a sámi által biztosított további 30 cm-t.\n\n    Példa esetek:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszatér 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszatér 0"
    },
    "instruction_bertscore": {
      "sq": "0.9874827106479435",
      "hy": "0.9592323060748754",
      "bn": "0.9729425694954276",
      "bg": "0.9699875453167714",
      "zh": "0.9727785008006927",
      "fr": "0.9786319394994099",
      "de": "0.9725075689609611",
      "ha": "0.9743242424259062",
      "hi": "0.9755265521223104",
      "hu": "0.9744398453076685"
    },
    "level": "easy",
    "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()",
    "entry_point": "count_apples_reachable",
    "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n    ",
      "sq": "\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion iteron mbi listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke marrë parasysh një shtesë prej 30cm që ofron stoli.\n\n    Shembuj të rasteve:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "hy": "\n    Հաշվեք այն խնձորների քանակը, որոնք Թաո Թաոն կարող է հասնել։\n\n    Փաստարկներ:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Թաո Թաոն կարող է հասնել ձեռքը վեր պարզած (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնց Թաո Թաոն կարող է հասնել՝ կանգնած կամ չկանգնած 30սմ բարձակի վրա։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցուցակի վրայով և հաշվում, թե դրանցից քանիսն են Թաո Թաոյի հասանելիության սահմաններում՝ հաշվի առնելով լրացուցիչ 30սմ, որ տալիս է բարձակը։\n\n    Օրինակ դեպքեր:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0",
      "bn": "\n    তাও তাও কতগুলি আপেল পৌঁছাতে পারে তা গণনা করুন।\n\n    Args:\n    apple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে পৌঁছাতে পারে এমন সর্বাধিক উচ্চতা (সেন্টিমিটারে)।\n\n    Returns:\n    int: তাও তাও একটি 30 সেমি স্টুলে দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং তাদের মধ্যে কতগুলি তাও তাও এর নাগালের মধ্যে আছে তা গণনা করে,\n    স্টুল যে অতিরিক্ত 30 সেমি প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "bg": "\n    Изчислете броя на ябълките, които Тао Тао може да достигне.\n\n    Аргументи:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Връща:\n    int: Броят на ябълките, които Тао Тао може да достигне със или без да стои на 30см столче.\n\n    Тази функция обхожда списъка с височини на ябълките и брои колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30см, които столчето предоставя.\n\n    Примерни случаи:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0",
      "zh": "\n    计算涛涛可以够到的苹果数量。\n\n    参数:\n    apple_heights (List[int]): 苹果距离地面的高度（厘米）。\n    tao_reach (int): 涛涛伸手向上时能达到的最大高度（厘米）。\n\n    返回:\n    int: 涛涛在有无站在30厘米高的凳子上时可以够到的苹果数量。\n\n    这个函数遍历苹果高度列表，并计算其中有多少在涛涛的够到范围内，考虑到凳子提供的额外30厘米。\n\n    示例案例:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "fr": "\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes à partir du sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en considérant un ajout de 30 cm que le tabouret fournit.\n\n    Exemples de cas :\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "de": "\n    Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Args:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Returns:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon in Tao Taos Reichweite liegen,\n    wobei zusätzliche 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispielhafte Fälle:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "ha": "\n    Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffa daga ƙasa (a cikin santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a cikin santimita).\n\n    Returns:\n    int: Yawan tuffa da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujera mai tsayin 30cm ba.\n\n    Wannan aikin yana zagayawa ta cikin jerin tsayin tuffa kuma yana ƙidaya nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lamura:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "hi": "\n    ताओ ताओ कितने सेब तक पहुँच सकती है, यह गणना करें।\n\n    तर्क:\n    apple_heights (List[int]): जमीन से सेब की ऊँचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊँचाई तक ताओ ताओ अपने हाथ को ऊपर की ओर खींच सकती है (सेंटीमीटर में)।\n\n    रिटर्न:\n    int: सेबों की संख्या जिन तक ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े पहुँच सकती है।\n\n    यह फ़ंक्शन सेब की ऊँचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुँच के भीतर हैं,\n    30 सेमी की अतिरिक्त ऊँचाई को ध्यान में रखते हुए जो स्टूल प्रदान करता है।\n\n    उदाहरण मामले:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0",
      "hu": "\n    Számítsd ki, hogy Tao Tao hány almát ér el.\n\n    Args:\n    apple_heights (List[int]): Az almák magassága a földtől (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet, ha a kezét felfelé nyújtja (centiméterben).\n\n    Returns:\n    int: Az almák száma, amelyeket Tao Tao elérhet akár egy 30 cm-es zsámolyon állva, akár anélkül.\n\n    Ez a függvény végigmegy az almák magasságának listáján, és megszámolja, hány van közülük Tao Tao elérhető magasságában,\n    figyelembe véve a zsámoly által biztosított további 30 cm-t.\n\n    Példa esetek:\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.991346071559072",
      "hy": "0.9633560714155407",
      "bn": "0.9622695632312799",
      "bg": "0.9692057361370182",
      "zh": "0.9726706445037908",
      "fr": "0.9851039132046696",
      "de": "0.9636403114908016",
      "ha": "0.9648100458047161",
      "hi": "0.973822502083412",
      "hu": "0.9650354912871907"
    }
  },
  {
    "task_id": "Python/36",
    "prompt": {
      "en": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zona specifike janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), \n    që përfaqëson intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Argumentet:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e tufeve ku çdo tufë përfaqëson një zonë të pastruar në rrugë.\n    \n    Kthen:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Shembuj:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20.\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են։\n\n    Ճանապարհը ներկայացված է որպես ուղիղ գիծ, որի երկարությունը 'l' է և սկզբում լցված է ծառերով։\n    Յուրաքանչյուր մաքրման ենթակա տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), որը ներկայացնում է\n    ճանապարհի երկայնքով ընդգրկուն միջակայքը, որտեղ ծառերը կհեռացվեն։\n\n    Արգումենտներ:\n    - l (int): Ճանապարհի երկարությունը։\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք։\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են։\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20.\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা একটি সরল রেখা হিসাবে 'l' দৈর্ঘ্যের প্রতিনিধিত্ব করে এবং প্রাথমিকভাবে গাছ দিয়ে পূর্ণ থাকে।\n    প্রতিটি নির্ধারিত পরিষ্কার এলাকা দুটি পূর্ণসংখ্যার জোড়া (শুরু, শেষ) হিসাবে নির্দিষ্ট করা হয়,\n    যা রাস্তার বরাবর অন্তর্ভুক্ত পরিসরকে উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গস:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার উপর একটি পরিষ্কার এলাকা উপস্থাপন করে।\n    \n    রিটার্নস:\n    - int: নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 ফেরত দেবে    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 ফেরত দেবে।\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислете броя на останалите дървета по пътя след изчистването на специфични зони.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, предвидена за изчистване, е посочена като двойка цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n    \n    Връща:\n    - int: Общият брой на дърветата, останали по пътя след изчистването на посочените зони.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20.\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初布满了树木。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示将要移除树木的道路上的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，每个元组表示道路上的一个清除区域。\n    \n    返回:\n    - int: 在指定区域被清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20.\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\n    La route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\n    Chaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant\n    la plage inclusive le long de la route où les arbres seront enlevés.\n\n    Arguments:\n    - l (int): La longueur de la route.\n    - areas (List[Tuple[int, int]]): Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n    \n    Retourne:\n    - int: Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n    \n    Exemples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) renverra 20.\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\n    Die Straße wird als gerade Linie der Länge 'l' dargestellt und ist anfangs mit Bäumen gefüllt.\n    Jeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, \n    das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\n    Argumente:\n    - l (int): Die Länge der Straße.\n    - areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n    \n    Rückgabewert:\n    - int: Die Gesamtanzahl der verbleibenden Bäume entlang der Straße, nachdem die angegebenen Bereiche gerodet wurden.\n    \n    Beispiele:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) gibt 5 zurück    \n    - remaining_trees_after_clearing(100, [(10, 90)]) gibt 20 zurück.\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\n    Ana wakilta hanyar a matsayin layi madaidaici mai tsawon 'l' kuma a farko cike take da bishiyoyi.\n    Kowanne yanki da aka shirya sharewa an bayyana shi a matsayin ma'aurata na lambobi (farko, ƙarshe), \n    wanda ke wakiltar kewayon da aka haɗa a gefen hanya inda za a cire bishiyoyin.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar yanki da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin bishiyoyin da suka rage a gefen hanya bayan an share wuraren da aka bayyana.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20.\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    विशेष क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की संख्या की गणना करें।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, दो पूर्णांकों (start, end) के जोड़े के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहां पेड़ों को हटाया जाएगा।\n\n    आर्ग्स:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल सड़क पर एक साफ़ क्षेत्र का प्रतिनिधित्व करता है।\n    \n    रिटर्न:\n    - int: निर्दिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की कुल संख्या।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा।\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a megmaradt fák számát egy út mentén, miután meghatározott területeket megtisztítottak.\n\n    Az utat egy 'l' hosszúságú egyenes vonal képviseli, amely kezdetben fákkal van tele.\n    Minden tisztításra ütemezett területet egy egész számokból álló pár (kezdő, vég) jelöl,\n    amely az út mentén azt a tartományt jelöli, ahol a fákat eltávolítják.\n\n    Paraméterek:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy tisztított területet jelöl az úton.\n    \n    Visszatérési érték:\n    - int: A megmaradt fák teljes száma az út mentén a meghatározott területek megtisztítása után.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9870413539412839",
      "hy": "0.963277612415032",
      "bn": "0.9691749484279578",
      "bg": "0.9631256601735403",
      "zh": "0.9686666532828895",
      "fr": "0.9975622093335588",
      "de": "0.978860563067981",
      "ha": "0.9619108367631308",
      "hi": "0.9774492942107281",
      "hu": "0.9526604212879551"
    },
    "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees",
    "instruction": {
      "en": "Write a python function 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    ",
      "sq": "Shkruani një funksion python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin e pemëve të mbetura përgjatë një rruge pasi zonat specifike janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqësojnë\n    intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Args:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e tufeve ku çdo tufë përfaqëson një zonë të pastruar në rrugë.\n    \n    Returns:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20.",
      "hy": "Պայթոն ֆունկցիա 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են:\n\n    Ճանապարհը ներկայացված է որպես երկարությամբ 'l' ուղիղ գիծ և սկզբում լցված է ծառերով:\n    Յուրաքանչյուր մաքրման համար նախատեսված տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), \n    որը ներկայացնում է ճանապարհի երկայնքով ներառական տիրույթը, որտեղ ծառերը կհանվեն:\n\n    Արգումենտներ:\n    - l (int): Ճանապարհի երկարությունը:\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք:\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են:\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20.",
      "bn": "একটি পাইথন ফাংশন 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    নির্দিষ্ট এলাকাগুলি পরিষ্কার করার পরে একটি রাস্তার পাশে অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা 'l' দৈর্ঘ্যের একটি সরল রেখা হিসাবে উপস্থাপিত হয় এবং প্রাথমিকভাবে গাছ দিয়ে পূর্ণ থাকে।\n    পরিষ্কারের জন্য নির্ধারিত প্রতিটি এলাকা দুটি পূর্ণসংখ্যার (start, end) জোড়া হিসাবে নির্দিষ্ট করা হয়,\n    যা রাস্তার বরাবর অন্তর্ভুক্ত পরিসীমা উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গুমেন্টস:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার একটি পরিষ্কার করা এলাকা উপস্থাপন করে।\n    \n    রিটার্নস:\n    - int: নির্দিষ্ট এলাকাগুলি পরিষ্কার করার পরে রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 ফেরত দেবে    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 ফেরত দেবে।",
      "bg": "Напишете Python функция 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:', за да решите следния проблем:\n\n    Изчислете броя на останалите дървета по пътя, след като определени зони са били изчистени.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, планирана за изчистване, е посочена като двойка от цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона по пътя.\n    \n    Връща:\n    - int: Общият брой на дърветата, останали по пътя след изчистването на определените зони.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20.",
      "zh": "编写一个 python 函数 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' 来解决以下问题：\n\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初布满了树木。\n    每个计划清除的区域都指定为一对整数 (start, end)，表示沿道路将要移除树木的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组表示道路上的一个清除区域。\n    \n    返回:\n    - int: 在指定区域被清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20。",
      "fr": "Écrivez une fonction python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été dégagées.\n\n    La route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\n    Chaque zone prévue pour être dégagée est spécifiée comme une paire d'entiers (début, fin), représentant\n    la plage inclusive le long de la route où les arbres seront enlevés.\n\n    Args:\n    - l (int): La longueur de la route.\n    - areas (List[Tuple[int, int]]): Une liste de tuples où chaque tuple représente une zone dégagée sur la route.\n    \n    Returns:\n    - int: Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été dégagées.\n    \n    Exemples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) renverra 20.",
      "de": "Schreiben Sie eine Python-Funktion 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\n    Die Straße wird als gerade Linie der Länge 'l' dargestellt und ist zunächst mit Bäumen gefüllt.\n    Jeder für die Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, \n    das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\n    Argumente:\n    - l (int): Die Länge der Straße.\n    - areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n    \n    Rückgabewert:\n    - int: Die Gesamtanzahl der Bäume, die entlang der Straße verbleiben, nachdem die angegebenen Bereiche gerodet wurden.\n    \n    Beispiele:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) wird 5 zurückgeben    \n    - remaining_trees_after_clearing(100, [(10, 90)]) wird 20 zurückgeben.",
      "ha": "Rubuta wani aikin python 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa adadin itatuwan da suka rage a gefen hanya bayan an share wurare na musamman.\n\n    Ana wakiltar hanyar a matsayin layi madaidaici mai tsawon 'l' kuma a farko an cika ta da itatuwa.\n    Kowanne wuri da aka shirya don sharewa an bayyana shi a matsayin ma'aurata na lambobi (farko, ƙarshe), \n    wanda ke wakiltar kewayon da aka haɗa a gefen hanya inda za a cire itatuwan.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar wuri da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin itatuwan da suka rage a gefen hanya bayan an share wuraren da aka bayyana.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20.",
      "hi": "एक पायथन फ़ंक्शन 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    विशिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की संख्या की गणना करें।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, को पूर्णांकों की एक जोड़ी (प्रारंभ, अंत) के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहां पेड़ों को हटाया जाएगा।\n\n    तर्क:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n    \n    लौटाता है:\n    - int: निर्दिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के किनारे बचे हुए पेड़ों की कुल संख्या।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा।",
      "hu": "Írj egy python függvényt 'def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki az út mentén megmaradt fák számát, miután bizonyos területeket megtisztítottak.\n\n    Az utat egy 'l' hosszúságú egyenes vonalként ábrázoljuk, amely kezdetben fákkal van tele.\n    Minden tisztításra ütemezett területet egy egész szám pár (kezdő, vég) jelöl, amely az út mentén\n    azt a tartományt képviseli, ahol a fákat eltávolítják.\n\n    Argumentumok:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy tisztított területet képvisel az úton.\n    \n    Visszatér:\n    - int: Az út mentén megmaradt fák teljes száma, miután a megadott területeket megtisztították.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja 20."
    },
    "instruction_bertscore": {
      "sq": "0.9955697479813979",
      "hy": "0.9707389640482265",
      "bn": "0.9702441757690686",
      "bg": "0.9681615362239178",
      "zh": "0.9736552553025807",
      "fr": "0.9949200280050328",
      "de": "0.9853186326465683",
      "ha": "0.9607124996743474",
      "hi": "0.9751286954690975",
      "hu": "0.9589333673514179"
    },
    "level": "easy",
    "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()",
    "entry_point": "remaining_trees_after_clearing",
    "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20.\n    ",
      "sq": "\n    Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zona të caktuara janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqëson\n    intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Argumentet:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e tufeve ku çdo tufë përfaqëson një zonë të pastruar në rrugë.\n    \n    Kthen:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Shembuj:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20.",
      "hy": "\n    Հաշվեք ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են։\n\n    Ճանապարհը ներկայացված է որպես ուղիղ գիծ՝ 'l' երկարությամբ, և սկզբում լցված է ծառերով։\n    Յուրաքանչյուր մաքրման ենթակա տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), որը ներկայացնում է\n    ճանապարհի այն ընդգրկուն հատվածը, որտեղից ծառերը կհեռացվեն։\n\n    Պարամետրեր:\n    - l (int): Ճանապարհի երկարությունը։\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի վրա մաքրված տարածք։\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են։\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20.",
      "bn": "\n    রাস্তার পাশে নির্দিষ্ট এলাকা পরিষ্কার করার পর অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা একটি সরল রেখা হিসাবে প্রতিনিধিত্ব করা হয় যার দৈর্ঘ্য 'l' এবং প্রাথমিকভাবে গাছ দ্বারা পূর্ণ।\n    প্রতিটি এলাকা পরিষ্কার করার জন্য নির্ধারিত হয় একটি পূর্ণসংখ্যার জোড়া (start, end) হিসাবে, যা রাস্তার বরাবর অন্তর্ভুক্তিকৃত পরিসীমা প্রতিনিধিত্ব করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গুমেন্ট:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার উপর একটি পরিষ্কার এলাকা প্রতিনিধিত্ব করে।\n    \n    রিটার্নস:\n    - int: নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 রিটার্ন করবে    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 রিটার্ন করবে।",
      "bg": "\n    Изчислете броя на останалите дървета по пътя след като определени зони са били изчистени.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, предвидена за изчистване, е посочена като двойка цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n    \n    Връща:\n    - int: Общият брой на останалите дървета по пътя след като определените зони са били изчистени.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20.",
      "zh": "\n    计算在特定区域被清除后沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初布满了树木。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示沿道路将要移除树木的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组代表道路上的一个清除区域。\n    \n    返回:\n    - int: 在指定区域被清除后沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20.",
      "fr": "\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\nLa route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres. Chaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant la plage inclusive le long de la route où les arbres seront enlevés.\n\nArgs:\n- l (int): La longueur de la route.\n- areas (List[Tuple[int, int]]): Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n\nReturns:\n- int: Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5    \n- remaining_trees_after_clearing(100, [(10, 90)]) renverra 20.",
      "de": "\n    Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\nDie Straße wird als gerade Linie der Länge 'l' dargestellt und ist anfänglich mit Bäumen gefüllt.\nJeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (start, end) angegeben, das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\nArgumente:\n- l (int): Die Länge der Straße.\n- areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verbleibenden Bäume entlang der Straße, nachdem die angegebenen Bereiche gerodet wurden.\n\nBeispiele:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) wird 5 zurückgeben\n- remaining_trees_after_clearing(100, [(10, 90)]) wird 20 zurückgeben.",
      "ha": "\n    Lissafa adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\n    Ana wakilta hanyar a matsayin layi madaidaici mai tsawon 'l' kuma a farko tana cike da bishiyoyi.\n    Kowanne wuri da aka tsara don sharewa ana bayyana shi a matsayin ma'aurata na lambobi (farawa, ƙarewa), \n    wanda ke wakiltar kewayon da aka haɗa a gefen hanya inda za a cire bishiyoyin.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar wuri da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin bishiyoyin da suka rage a gefen hanya bayan an share wuraren da aka ambata.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20.",
      "hi": "\n    सड़क के किनारे कुछ विशेष क्षेत्रों को साफ़ करने के बाद बचे हुए पेड़ों की संख्या की गणना करें।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और शुरुआत में यह पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जो साफ़ करने के लिए निर्धारित है, उसे दो पूर्णांकों (start, end) के जोड़े के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ वह समावेशी सीमा दर्शाता है जहां पेड़ों को हटाया जाएगा।\n\n    तर्क:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n    \n    लौटाता है:\n    - int: सड़क के साथ कुल बचे हुए पेड़ों की संख्या, निर्दिष्ट क्षेत्रों को साफ़ करने के बाद।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा   \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा।",
      "hu": "\n    Számítsd ki az út mentén megmaradó fák számát, miután bizonyos területeket megtisztítottak.\n\n    Az út egy 'l' hosszúságú egyenes vonalként van ábrázolva, és kezdetben fákkal van tele.\n    Minden megtisztításra tervezett területet egy egész szám pár (kezdő, vég) jelöl, amely az út mentén\n    azt a tartományt jelenti, ahol a fákat eltávolítják.\n\n    Paraméterek:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy pár, amely az út egy megtisztított területét jelöli.\n    \n    Visszatérési érték:\n    - int: Az út mentén megmaradó fák teljes száma a megadott területek megtisztítása után.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at."
    },
    "docstring_bertscore": {
      "sq": "0.9802162154185441",
      "hy": "0.9561867064424675",
      "bn": "0.9596663134574367",
      "bg": "0.9681716663733505",
      "zh": "0.972353431785278",
      "fr": "0.9947251716012375",
      "de": "0.9801850304487216",
      "ha": "0.9500712742711653",
      "hi": "0.9738258787998897",
      "hu": "0.9401067825761691"
    }
  },
  {
    "task_id": "Python/37",
    "prompt": {
      "en": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "sq": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohe.\n\n    Kjo funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin e kohës. Çdo bimë mund të mblidhet\n    maksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Argumentet:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuplesh, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e kërkuar për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit të kohës.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "hy": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման մեջ:\n\n    Այս ֆունկցիան լուծում է 0/1 դանակապանակի խնդրի տարբերակը, որտեղ նպատակն է առավելագույնացնել\n    հավաքված խոտաբույսերի ընդհանուր արժեքը՝ առանց ժամանակային սահմանափակումը գերազանցելու: Յուրաքանչյուր խոտաբույս\n    կարելի է հավաքել առավելագույնը մեկ անգամ և ունի համապատասխան ժամանակային արժեք և արժեք:\n\n    Արգումենտներ:\n    - T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n    - M (int): Տարբեր խոտաբույսերի քանակը քարանձավում:\n    - herbs (List[Tuple[int, int]]): Կրկնորդների ցուցակ, որտեղ յուրաքանչյուր կրկնորդ պարունակում է երկու ամբողջ թիվ,\n      որոնք ներկայացնում են խոտաբույսը հավաքելու համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել ժամանակային սահմանափակման մեջ:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "bn": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    একটি নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব বেশি মূল্যবান ভেষজ সংগ্রহের সর্বাধিক মোট মূল্য হিসাব করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি বৈকল্পিক সমাধান করে যেখানে লক্ষ্য হল সময়সীমা অতিক্রম না করে\n    সংগ্রহ করা ভেষজের মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ সর্বাধিক একবারই সংগ্রহ করা যেতে পারে এবং এর সাথে\n    একটি নির্দিষ্ট সময় খরচ এবং মূল্য যুক্ত থাকে।\n\n    আর্গুমেন্ট:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টাপল তালিকা, যেখানে প্রতিটি টাপল দুটি পূর্ণসংখ্যা ধারণ করে\n      যা যথাক্রমে ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "bg": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "zh": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定时间限制内可以采摘的草药的最大总价值。\n\n    此函数解决了0/1背包问题的变体，其目标是在不超过时间限制的情况下最大化采摘草药的总价值。\n    每种草药最多可以采摘一次，并且具有相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘草药的总时间。\n    - M (int): 洞穴中不同草药的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，每个元组包含两个整数，分别表示采摘草药所需的时间和草药的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的草药的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "fr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer la valeur totale maximale des herbes pouvant être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Arguments:\n    - T (int): Le temps total disponible pour cueillir des herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Renvoie:\n    - int: La valeur totale maximale des herbes pouvant être cueillies dans le délai imparti.\n\n    Exemples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "de": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gepflückt werden können.\n\n    Diese Funktion löst eine Variante des 0/1-Rucksackproblems, bei dem das Ziel darin besteht,\n    den Gesamtwert der gepflückten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten.\n    Jedes Kraut kann höchstens einmal gepflückt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Argumente:\n    - T (int): Die insgesamt verfügbare Zeit zum Pflücken der Kräuter.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält,\n      die die zum Pflücken des Krauts erforderliche Zeit und den Wert des Krauts darstellen.\n\n    Rückgabewert:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gepflückt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "ha": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware wani bambancin matsalar jakar 0/1 inda burin shine a ƙara\n    jimillar ƙimar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Ana iya ɗaukar kowanne ganye\n    sau ɗaya kawai kuma yana da alaƙa da farashin lokaci da ƙima.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi biyu\n      suna wakiltar lokacin da ake buƙata don ɗaukar ganyen da kuma ƙimar ganyen, bi da bi.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokaci.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "hi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करें।\n\n    यह फ़ंक्शन 0/1 नॉapsack समस्या के एक प्रकार को हल करता है जहाँ लक्ष्य है\n    चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना बिना समय सीमा को पार किए। प्रत्येक जड़ी-बूटी को\n    अधिकतम एक बार चुना जा सकता है और इसके साथ एक संबंधित समय लागत और मूल्य होता है।\n\n    तर्क:\n    - T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं\n      जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी का मूल्य दर्शाते हैं।\n\n    वापसी:\n    - int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\"",
      "hu": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a gyógynövények maximális összértékét, amelyet adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény egy 0/1 hátizsák probléma variációját oldja meg, ahol a cél a gyógynövények összértékének\n    maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt legfeljebb egyszer lehet\n    összegyűjteni, és mindegyikhez társul egy időráfordítás és egy érték.\n\n    Paraméterek:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A barlangban található különböző gyógynövények száma.\n    - herbs (List[Tuple[int, int]]): Egy listája a tuple-öknek, ahol minden tuple két egész számot tartalmaz,\n      amelyek a gyógynövény összegyűjtéséhez szükséges időt és a gyógynövény értékét képviselik.\n\n    Visszatér:\n    - int: A gyógynövények maximális összértéke, amelyet az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9809884903400078",
      "hy": "0.9771761774368052",
      "bn": "0.9780674319565087",
      "bg": "0.9821878205806964",
      "zh": "0.9800829344328696",
      "fr": "0.9874483475920244",
      "de": "0.978940412481157",
      "ha": "0.9657352661195766",
      "hi": "0.9780020825611482",
      "hu": "0.9729934188729724"
    },
    "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]",
    "instruction": {
      "en": "Write a python function 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' to solve the following problem:\n\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    ",
      "sq": "Shkruani një funksion python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor.\n\n    Ky funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin kohor. Çdo bimë mund të mblidhet\n    maksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Args:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuples, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e nevojshme për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit kohor.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "hy": "Պայթոն ֆունկցիա 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակի սահմաններում:\n\n    Այս ֆունկցիան լուծում է 0/1 պայուսակի խնդրի տարբերակը, որտեղ նպատակը \n    խոտաբույսերի ընդհանուր արժեքի առավելագույնացումն է՝ առանց ժամանակի սահմանը գերազանցելու: Յուրաքանչյուր խոտաբույս կարելի է հավաքել \n    առավելագույնը մեկ անգամ և ունի կապված ժամանակի արժեք և արժեք:\n\n    Արձ:\n    - T (int): Խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n    - M (int): Քարանձավում տարբեր խոտաբույսերի քանակը:\n    - herbs (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի թիվ պարունակում է երկու ամբողջ թիվ,\n      որոնք համապատասխանաբար ներկայացնում են խոտաբույսը հավաքելու համար պահանջվող ժամանակը և խոտաբույսի արժեքը:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել ժամանակի սահմաններում:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "bn": "একটি পাইথন ফাংশন 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মোট মূল্যবান ভেষজ সংগ্রহ করা যায় তা গণনা করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি রূপ সমাধান করে যেখানে লক্ষ্য হল সময়সীমা অতিক্রম না করে\n    সংগ্রহ করা ভেষজগুলির মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে\n    একটি নির্দিষ্ট সময় খরচ এবং মূল্য যুক্ত থাকে।\n\n    আর্গস:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে\n      যা ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য প্রতিনিধিত্ব করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজগুলির সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "bg": "Напишете функция на Python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' за решаване на следния проблем:\n\n    Изчислете максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариант на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се надвишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "zh": "编写一个python函数'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:'来解决以下问题：\n\n    计算在给定时间限制内可以采摘的草药的最大总价值。\n\n    此函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化\n    采摘的草药的总价值。每种草药最多只能采摘一次，并且具有相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘草药的总时间。\n    - M (int): 洞穴中不同草药的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，\n      分别表示采摘草药所需的时间和草药的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的草药的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "fr": "Écrivez une fonction python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' pour résoudre le problème suivant :\n\n    Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Arguments:\n    - T (int): Le temps total disponible pour cueillir les herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Renvoie:\n    - int: La valeur totale maximale des herbes qui peuvent être cueillies dans la limite de temps.\n\n    Exemples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "de": "Schreiben Sie eine Python-Funktion 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n\n    Diese Funktion löst eine Variante des 0/1-Rucksackproblems, bei dem das Ziel darin besteht,\n    den Gesamtwert der gesammelten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten. Jedes Kraut kann\n    höchstens einmal gesammelt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Argumente:\n    - T (int): Die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält,\n      die jeweils die Zeit repräsentieren, die benötigt wird, um das Kraut zu sammeln, und den Wert des Krauts.\n\n    Rückgabe:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gesammelt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "ha": "Rubuta wani aikin python 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka a cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware bambancin matsalar 0/1 knapsack inda burin shine a ƙara\n    jimillar ƙimar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Kowace ganye za a iya ɗauka\n    sau ɗaya kawai kuma tana da alaƙa da farashin lokaci da ƙima.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi biyu\n      suna wakiltar lokacin da ake buƙata don ɗaukar ganyen da ƙimar ganyen, bi da bi.\n\n    Returns:\n    - int: Mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka a cikin iyakar lokaci.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "hi": "एक पायथन फ़ंक्शन 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करें।\n\n    यह फ़ंक्शन 0/1 नॅपसैक समस्या के एक भिन्न रूप को हल करता है जहां लक्ष्य \n    समय सीमा को पार किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना है। प्रत्येक जड़ी-बूटी को \n    अधिकतम एक बार चुना जा सकता है और इसके साथ एक संबंधित समय लागत और मूल्य होता है।\n\n    तर्क:\n    - T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहां प्रत्येक ट्यूपल में दो पूर्णांक होते हैं\n      जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी का मूल्य दर्शाते हैं।\n\n    लौटाता है:\n    - int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "hu": "Írj egy python függvényt 'def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a gyógynövények maximális összértékét, amelyet egy adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény a 0/1 hátizsák probléma egy változatát oldja meg, ahol a cél a gyógynövények\n    összértékének maximalizálása az időkorlát túllépése nélkül. Minden gyógynövényt legfeljebb egyszer lehet\n    összegyűjteni, és van hozzá rendelve egy időráfordítás és egy érték.\n\n    Paraméterek:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A barlangban található különböző gyógynövények száma.\n    - herbs (List[Tuple[int, int]]): Egy tuple-ök listája, ahol minden tuple két egész számot tartalmaz,\n      amelyek a gyógynövény összegyűjtéséhez szükséges időt és a gyógynövény értékét képviselik.\n\n    Visszatér:\n    - int: A gyógynövények maximális összértéke, amelyet az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10"
    },
    "instruction_bertscore": {
      "sq": "0.984838344385226",
      "hy": "0.9816580733544763",
      "bn": "0.9769052455970736",
      "bg": "0.9758515114256835",
      "zh": "0.9790427071273899",
      "fr": "0.9847288990452757",
      "de": "0.9703399156127274",
      "ha": "0.9644801207418171",
      "hi": "0.9795994680854307",
      "hu": "0.9744684480825375"
    },
    "level": "easy",
    "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()",
    "entry_point": "max_herb_value",
    "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n    ",
      "sq": "\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të caktuar.\n\n    Kjo funksion zgjidh një variant të problemit 0/1 të çantës së shpinës ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin kohor. Çdo bimë mund të mblidhet\n    më së shumti një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Argumentet:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuplesh, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e nevojshme për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit kohor.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "hy": "\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակի սահմանափակման մեջ:\n\n    Այս ֆունկցիան լուծում է 0/1 տոպրակի խնդրի մի տարբերակ, որտեղ նպատակը խոտաբույսերի ընդհանուր արժեքի առավելագույնացումն է՝ առանց ժամանակի սահմանափակման գերազանցման: Յուրաքանչյուր խոտաբույս կարելի է հավաքել առավելագույնը մեկ անգամ և ունի կապված ժամանակի արժեք և արժեք:\n\n    Պարամետրեր:\n    - T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n    - M (int): Քարանձավում տարբեր խոտաբույսերի քանակը:\n    - herbs (List[Tuple[int, int]]): Թվային զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ, որոնք ներկայացնում են խոտաբույսի հավաքման համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել ժամանակի սահմանափակման մեջ:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "bn": "\n    প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মূল্যবান ভেষজ সংগ্রহের হিসাব করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি ভিন্নতা সমাধান করে যেখানে লক্ষ্য হল \n    সময়সীমা অতিক্রম না করে ভেষজ সংগ্রহের মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ \n    সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে একটি সময় খরচ এবং মূল্য \n    যুক্ত থাকে।\n\n    আর্গুমেন্টসমূহ:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে \n      দুটি পূর্ণসংখ্যা থাকে যা যথাক্রমে ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং \n      ভেষজের মূল্য উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "bg": "\n    Изчислете максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "zh": "\n    计算在给定时间限制内可以采摘的药草的最大总价值。\n\n    该函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化采摘药草的总价值。每种药草最多只能采摘一次，并且有一个相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘药草的总时间。\n    - M (int): 洞穴中不同药草的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，分别表示采摘药草所需的时间和药草的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的药草的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "fr": "\n    Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Args:\n    - T (int): Le temps total disponible pour cueillir des herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Returns:\n    - int: La valeur totale maximale des herbes qui peuvent être cueillies dans le délai imparti.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "de": "\n    Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines vorgegebenen Zeitlimits gesammelt werden können.\n\n    Diese Funktion löst eine Variation des 0/1-Rucksackproblems, bei dem das Ziel darin besteht, den Gesamtwert der gesammelten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten. Jedes Kraut kann höchstens einmal gesammelt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Args:\n    - T (int): Die insgesamt verfügbare Zeit zum Sammeln der Kräuter.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält, die die zum Sammeln des Krauts benötigte Zeit und den Wert des Krauts darstellen.\n\n    Returns:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gesammelt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "ha": "\n    Lissafa jimillar ƙimar ganyayyaki mafi girma da za a iya tattara cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware wani bambanci na matsalar jakar 0/1 inda burin shine a haɓaka\n    jimillar ƙimar ganyayyaki da aka tattara ba tare da wuce iyakar lokaci ba. Kowace ganye za a iya tattara\n    sau ɗaya kawai kuma tana da alaƙa da farashin lokaci da ƙima.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don tattara ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowane tuple ya ƙunshi lambobi biyu\n      suna wakiltar lokacin da ake buƙata don tattara ganyen da ƙimar ganyen, bi da bi.\n\n    Returns:\n    - int: Jimillar ƙimar ganyayyaki mafi girma da za a iya tattara cikin iyakar lokaci.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "hi": "\n    दिए गए समय सीमा के भीतर जितनी अधिकतम कुल मूल्य की जड़ी-बूटियाँ चुनी जा सकती हैं, उसकी गणना करें।\n\n    यह फ़ंक्शन 0/1 नॅपसैक समस्या के एक भिन्न रूप को हल करता है, जहाँ लक्ष्य है कि समय सीमा को पार किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना। प्रत्येक जड़ी-बूटी को अधिकतम एक बार चुना जा सकता है और इसके साथ जुड़ी समय लागत और मूल्य होता है।\n\n    Args:\n    - T (int): जड़ी-बूटियाँ चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): एक सूची जिसमें प्रत्येक ट्यूपल में दो पूर्णांक होते हैं जो क्रमशः जड़ी-बूटी चुनने के लिए आवश्यक समय और जड़ी-बूटी का मूल्य दर्शाते हैं।\n\n    Returns:\n    - int: दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10",
      "hu": "\n    Számítsa ki a maximális összértéket a gyógynövényeknek, amelyeket egy adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény a 0/1 hátizsák probléma egy változatát oldja meg, ahol a cél az összegyűjtött gyógynövények összértékének maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt legfeljebb egyszer lehet összegyűjteni, és mindegyikhez egy időráfordítás és egy érték társul.\n\n    Paraméterek:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A barlangban található különböző gyógynövények száma.\n    - herbs (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy-egy tuple, amely két egész számot tartalmaz, amelyek a gyógynövény összegyűjtéséhez szükséges időt és a gyógynövény értékét képviselik.\n\n    Visszatérési érték:\n    - int: A maximális összérték a gyógynövényeknek, amelyeket az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10"
    },
    "docstring_bertscore": {
      "sq": "0.9774341983017695",
      "hy": "0.9671205143969139",
      "bn": "0.9698814766932988",
      "bg": "0.9793321115925578",
      "zh": "0.9782843363325988",
      "fr": "0.9899812822109813",
      "de": "0.9793418444812285",
      "ha": "0.9651731421412478",
      "hi": "0.9671771240555088",
      "hu": "0.9580885923408765"
    }
  },
  {
    "task_id": "Python/38",
    "prompt": {
      "en": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "sq": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Llogarit hapësirën minimale të mbetur në një kuti pasi të përpiqesh të vendosësh një numër artikujsh me vëllime të dhëna.\n    \n    Kjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nënbashkësi e artikujve të dhënë. Më pas kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\n    Argumentet:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve që do të konsiderohen për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Kthen:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Shembuj:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "hy": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Հաշվարկել արկղում մնացած նվազագույն տարածքը այն բանից հետո, երբ փորձել ենք տեղավորել որոշակի ծավալներով իրեր։\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը, որը կարող է զբաղեցվել\n    արկղում տրված իրերի ցանկացած ենթաբազմությամբ։ Այնուհետև վերադարձնում է արկղի ընդհանուր տարողության և այս առավելագույն զբաղեցված ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է։\n\n    Պարամետրեր:\n    - V (int): Արկղի ընդհանուր տարողությունը։\n    - n (int): Իրերի քանակը, որոնք պետք է հաշվի առնել արկղում տեղավորելու համար։\n    - volumes (List[int]): n իրերի ծավալների ցանկը։\n\n    Վերադարձնում է:\n    - int: Արկղում մնացած նվազագույն տարածքը իրերը տեղավորելուց հետո։\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "bn": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    প্রদত্ত ভলিউম সহ কিছু আইটেম ফিট করার চেষ্টা করার পরে একটি বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যেকোনো উপসেট দ্বারা বাক্সে সর্বাধিক কতটুকু ভলিউম দখল করা যেতে পারে।\n    এরপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্য প্রদান করে, যা ন্যূনতম অবশিষ্ট স্থান।\n\n    আর্গুমেন্টসমূহ:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচনা করা আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\n    রিটার্নস:\n    - int: আইটেমগুলি ফিট করার পরে বাক্সে ন্যূনতম অবশিষ্ট স্থান।\n\n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "bg": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Изчисляване на минималното оставащо пространство в кутия след опит за поставяне на брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимално зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n-те предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след поставяне на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "zh": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    计算在尝试将给定体积的若干物品放入箱子后，箱子中剩余的最小空间。\n    \n    该函数使用动态规划方法来确定给定物品的任意子集可以占据的最大体积。\n    然后返回箱子总容量与该最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 要考虑放入箱子的物品数量。\n    - volumes (List[int]): n 个物品的体积列表。\n\n    返回:\n    - int: 将物品放入后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "fr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculer l'espace restant minimum dans une boîte après avoir essayé de placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\n    et ce volume occupé maximum, qui est l'espace restant minimum.\n\n    Arguments:\n    - V (int): La capacité totale de la boîte.\n    - n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]): Une liste des volumes des n articles.\n\n    Retourne:\n    - int: L'espace restant minimum dans la boîte après avoir placé les articles.\n\n    Exemples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "de": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Berechne den minimal verbleibenden Platz in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumina unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmieransatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Anschließend gibt sie die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was dem minimal verbleibenden Platz entspricht.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die für das Verpacken in die Box in Betracht gezogen werden.\n    - volumes (List[int]): Eine Liste der Volumina der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimal verbleibende Platz in der Box nach dem Unterbringen der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "ha": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Lissafa ƙaramin sarari da ya rage a cikin akwatin bayan ƙoƙarin sanya adadin abubuwa tare da ƙayyadaddun girma.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman girman da za a iya mamaye\n    a cikin akwatin ta kowanne rukuni na abubuwan da aka bayar. Sannan yana mayar da bambanci tsakanin jimlar ƙarfin akwatin\n    da wannan mafi girman girman da aka mamaye, wanda shine ƙaramin sarari da ya rage.\n\n    Args:\n    - V (int): Jimlar ƙarfin akwatin.\n    - n (int): Adadin abubuwan da za a yi la'akari da su don shiryawa cikin akwatin.\n    - volumes (List[int]): Jerin girman abubuwan n.\n\n    Returns:\n    - int: Ƙaramin sarari da ya rage a cikin akwatin bayan shiryawa abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "hi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    दिए गए वॉल्यूम के साथ वस्तुओं की संख्या को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करें।\n    \n    यह फ़ंक्शन एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है ताकि यह निर्धारित किया जा सके कि दिए गए वस्तुओं के किसी भी उपसमूह द्वारा बॉक्स में अधिकतम वॉल्यूम कितना भरा जा सकता है।\n    फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच का अंतर लौटाता है, जो कि बची हुई न्यूनतम जगह है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैक करने के लिए विचार की जाने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    रिटर्न:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\"",
      "hu": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Számítsa ki a minimális fennmaradó helyet egy dobozban, miután megpróbált beilleszteni egy adott térfogatú tárgyakat.\n\n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmazával\n    mekkora maximális térfogat foglalható el a dobozban. Ezután visszaadja a doboz teljes kapacitása és a maximálisan elfoglalt térfogat\n    közötti különbséget, ami a minimális fennmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A figyelembe veendő tárgyak száma a dobozba való csomagoláshoz.\n    - volumes (List[int]): Az n tárgy térfogatainak listája.\n\n    Visszatér:\n    - int: A minimális fennmaradó hely a dobozban a tárgyak beillesztése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9808693121113868",
      "hy": "0.9735193921219528",
      "bn": "0.9817977105123439",
      "bg": "0.9879437317623254",
      "zh": "0.9664409998633936",
      "fr": "0.9800324823160869",
      "de": "0.9782056787017089",
      "ha": "0.9885255201483766",
      "hi": "0.9680759265296918",
      "hu": "0.969033920857423"
    },
    "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]",
    "instruction": {
      "en": "Write a python function 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' to solve the following problem:\n\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    ",
      "sq": "Shkruani një funksion python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni hapësirën minimale të mbetur në një kuti pasi të përpiqeni të vendosni një numër artikujsh me vëllime të dhëna.\n    \n    Ky funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nëngrup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, i cili është hapësira minimale e mbetur.\n\n    Argumentet:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve që do të konsiderohen për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Kthen:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Shembuj:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "hy": "Պայթոն ֆունկցիա 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել տուփի մեջ մնացած նվազագույն տարածքը, երբ փորձվում է տեղավորել որոշակի ծավալներով տրված իրեր:\n    \n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը,\n    որը կարող է զբաղեցվել տուփի մեջ տրված իրերի ցանկացած ենթաբազմությամբ: Այնուհետև վերադարձնում է\n    տուփի ընդհանուր տարողության և այս առավելագույն զբաղեցրած ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է:\n\n    Արգումենտներ:\n    - V (int): Տուփի ընդհանուր տարողությունը:\n    - n (int): Տուփի մեջ փաթեթավորելու համար նախատեսված իրերի քանակը:\n    - volumes (List[int]): n իրերի ծավալների ցուցակը:\n\n    Վերադարձնում է:\n    - int: Տուփի մեջ մնացած նվազագույն տարածքը իրերը տեղավորելուց հետո:\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "bn": "একটি পাইথন ফাংশন 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    প্রদত্ত ভলিউম সহ কিছু আইটেম ফিট করার চেষ্টা করার পর একটি বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যে কোনও উপসেট দ্বারা বাক্সে সর্বাধিক কত ভলিউম দখল করা যেতে পারে। এটি তারপর বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্যটি ফেরত দেয়, যা ন্যূনতম অবশিষ্ট স্থান।\n\n    আর্গস:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচনা করা আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\n    রিটার্নস:\n    - int: আইটেম ফিট করার পর বাক্সে ন্যূনতম অবশিষ্ট স্থান।\n\n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "bg": "Напишете Python функция 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:', за да решите следния проблем:\n\n    Изчислете минималното оставащо пространство в кутия, след като се опитате да поставите определен брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от която и да е подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимален зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n-те предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след поставянето на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "zh": "编写一个 Python 函数 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' 来解决以下问题：\n\n    计算在尝试将给定体积的若干物品放入箱子后，箱子中剩余的最小空间。\n    \n    此函数使用动态规划方法来确定给定物品的任意子集在箱子中可以占据的最大体积。\n    然后返回箱子的总容量与此最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 考虑放入箱子的物品数量。\n    - volumes (List[int]): n 个物品的体积列表。\n\n    返回:\n    - int: 在放入物品后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "fr": "Écrivez une fonction python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' pour résoudre le problème suivant :\n\n    Calculer l'espace restant minimum dans une boîte après avoir essayé d'y placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\n    et ce volume maximum occupé, qui est l'espace restant minimum.\n\n    Args:\n    - V (int): La capacité totale de la boîte.\n    - n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]): Une liste des volumes des n articles.\n\n    Returns:\n    - int: L'espace restant minimum dans la boîte après avoir placé les articles.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "de": "Schreiben Sie eine Python-Funktion 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie den minimal verbleibenden Raum in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumen unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmierungsansatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Anschließend gibt sie die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimal verbleibenden Raum darstellt.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die für das Packen in die Box in Betracht gezogen werden.\n    - volumes (List[int]): Eine Liste der Volumen der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimal verbleibende Raum in der Box nach dem Einpacken der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "ha": "Rubuta wani aikin python 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi ƙarancin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da ƙayyadadden girma.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don tantance mafi girman girma da za a iya mamaye\n    a cikin akwatin ta kowanne rukuni na abubuwan da aka bayar. Sannan yana mayar da bambanci tsakanin jimlar ƙarfin akwatin\n    da wannan mafi girman girman da aka mamaye, wanda shine mafi ƙarancin sarari da ya rage.\n\n    Args:\n    - V (int): Jimlar ƙarfin akwatin.\n    - n (int): Yawan abubuwan da za a yi la'akari da su don shiryawa cikin akwatin.\n    - volumes (List[int]): Jerin girman abubuwan n.\n\n    Returns:\n    - int: Mafi ƙarancin sarari da ya rage a cikin akwatin bayan sanya abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "hi": "एक पायथन फ़ंक्शन 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए वॉल्यूम के साथ कई वस्तुओं को फिट करने की कोशिश के बाद बॉक्स में न्यूनतम शेष स्थान की गणना करें।\n    \n    यह फ़ंक्शन दिए गए वस्तुओं के किसी भी उपसमुच्चय द्वारा बॉक्स में कब्जा किए जा सकने वाले अधिकतम वॉल्यूम को निर्धारित करने के लिए एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है। फिर यह बॉक्स की कुल क्षमता और इस अधिकतम कब्जा किए गए वॉल्यूम के बीच का अंतर लौटाता है, जो न्यूनतम शेष स्थान है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैकिंग के लिए विचार करने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    लौटाता है:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में न्यूनतम शेष स्थान।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "hu": "Írj egy python függvényt 'def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a minimális fennmaradó helyet egy dobozban, miután megpróbáltad elhelyezni a megadott térfogatú tárgyakat.\n    \n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmaza\n    által a dobozban elfoglalt maximális térfogat mekkora lehet. Ezután visszaadja a doboz teljes kapacitása és \n    az elfoglalt maximális térfogat közötti különbséget, ami a minimális fennmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A tárgyak száma, amelyeket figyelembe kell venni a dobozba csomagoláskor.\n    - volumes (List[int]): Az n tárgy térfogatainak listája.\n\n    Visszatérési érték:\n    - int: A minimális fennmaradó hely a dobozban a tárgyak elhelyezése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5"
    },
    "instruction_bertscore": {
      "sq": "0.9856531262082311",
      "hy": "0.9709298478444011",
      "bn": "0.9838028842088911",
      "bg": "0.9728670899506343",
      "zh": "0.9579336606436694",
      "fr": "0.9781709183850279",
      "de": "0.978507994141644",
      "ha": "0.9663420819336382",
      "hi": "0.9894229322098922",
      "hu": "0.9664995958257989"
    },
    "level": "easy",
    "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()",
    "entry_point": "min_remaining_space",
    "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:",
    "docstring": {
      "en": "\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n\n    ",
      "sq": "\n    Llogarit hapësirën minimale të mbetur në një kuti pasi të përpiqesh të vendosësh një numër artikujsh me vëllime të dhëna.\n    \n    Kjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nëngrup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\n    Args:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve për t'u konsideruar për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Returns:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "hy": "\n    Հաշվեք տուփում մնացած նվազագույն տարածքը այն բանից հետո, երբ փորձեք տեղավորել որոշակի ծավալներով իրեր։\n    \n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար տուփում ցանկացած ենթաբազմության միջոցով զբաղեցված առավելագույն ծավալը։\n    Այնուհետև վերադարձնում է տուփի ընդհանուր տարողության և այս առավելագույն զբաղեցված ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է։\n\n    Պարամետրեր:\n    - V (int): Տուփի ընդհանուր տարողությունը։\n    - n (int): Տուփի մեջ տեղավորելու համար հաշվի առնվող իրերի քանակը։\n    - volumes (List[int]): n իրերի ծավալների ցուցակ։\n\n    Վերադարձնում է:\n    - int: Տուփում մնացած նվազագույն տարածքը իրերի տեղավորումից հետո։\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "bn": "\n    একটি বাক্সে নির্দিষ্ট আয়তনের কিছু আইটেম ফিট করার পর বাক্সে অবশিষ্ট সর্বনিম্ন স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে যে কোনও প্রদত্ত আইটেমের উপসেট দ্বারা বাক্সে দখল করা সর্বাধিক আয়তন নির্ধারণ করতে। তারপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত আয়তনের মধ্যে পার্থক্য প্রদান করে, যা অবশিষ্ট সর্বনিম্ন স্থান।\n    \n    আর্গুমেন্টসমূহ:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচিত আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের আয়তনের একটি তালিকা।\n    \n    রিটার্নস:\n    - int: আইটেম ফিট করার পর বাক্সে অবশিষ্ট সর্বনিম্ন স্থান।\n    \n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "bg": "\n    Изчислете минималното оставащо пространство в кутия след опит за поставяне на определен брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимален зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разглеждат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след поставяне на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "zh": "\n    计算在尝试将若干具有给定体积的物品放入箱子后，箱子中剩余的最小空间。\n    \n    该函数使用动态规划方法来确定给定物品的任意子集在箱子中可以占据的最大体积。\n    然后返回箱子总容量与该最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 考虑放入箱子的物品数量。\n    - volumes (List[int]): n 个物品的体积列表。\n\n    返回:\n    - int: 将物品放入后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "fr": "\n    Calculer l'espace restant minimum dans une boîte après avoir essayé d'y placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\n    et ce volume maximum occupé, qui est l'espace restant minimum.\n\n    Args:\n    - V (int): La capacité totale de la boîte.\n    - n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]): Une liste des volumes des n articles.\n\n    Returns:\n    - int: L'espace restant minimum dans la boîte après avoir placé les articles.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "de": "\n    Berechne den minimalen verbleibenden Raum in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumina unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmieransatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Sie gibt dann die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimalen verbleibenden Raum darstellt.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die in die Box gepackt werden sollen.\n    - volumes (List[int]): Eine Liste der Volumina der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimale verbleibende Raum in der Box nach dem Unterbringen der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "ha": "\n    Lissafa ƙaramin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da ƙayyadaddun ƙarar.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman ƙarar da za a iya cika\n    a cikin akwatin ta kowace ƙungiya daga cikin abubuwan da aka bayar. Sannan yana mayar da bambanci tsakanin jimillar ƙarfin akwatin\n    da wannan mafi girman ƙarar da aka cika, wanda shine ƙaramin sarari da ya rage.\n\n    Args:\n    - V (int): Jimillar ƙarfin akwatin.\n    - n (int): Adadin abubuwan da za a yi la'akari da su don cika cikin akwatin.\n    - volumes (List[int]): Jerin ƙarar abubuwan n.\n\n    Returns:\n    - int: Ƙaramin sarari da ya rage a cikin akwatin bayan sanya abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "hi": "\n    एक बॉक्स में दिए गए वॉल्यूम वाले वस्तुओं की संख्या को फिट करने के बाद बची हुई न्यूनतम जगह की गणना करें।\n    \n    यह फ़ंक्शन एक डायनेमिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है यह निर्धारित करने के लिए कि दिए गए वस्तुओं के किसी भी उपसमूह द्वारा बॉक्स में अधिकतम वॉल्यूम कितना भरा जा सकता है। फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच का अंतर लौटाता है, जो कि बची हुई न्यूनतम जगह है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैक करने के लिए विचार करने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    रिटर्न:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5",
      "hu": "\n    Számítsa ki a minimális fennmaradó helyet egy dobozban, miután megpróbált egy adott térfogatú tárgyakat elhelyezni benne.\n    \n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a dobozban a megadott tárgyak bármely részhalmaza által elfoglalt maximális térfogat mekkora lehet.\n    Ezután visszaadja a doboz teljes kapacitása és a maximálisan elfoglalt térfogat közötti különbséget, ami a minimális fennmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A figyelembe veendő tárgyak száma a dobozba való csomagoláshoz.\n    - volumes (List[int]): Az n tárgy térfogatának listája.\n\n    Visszatér:\n    - int: A minimális fennmaradó hely a dobozban a tárgyak elhelyezése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5"
    },
    "docstring_bertscore": {
      "sq": "0.9827048554625302",
      "hy": "0.9612877332578245",
      "bn": "0.9607027667856767",
      "bg": "0.975552572702226",
      "zh": "0.9593489021085428",
      "fr": "0.9755956754949106",
      "de": "0.9698342026626126",
      "ha": "0.9622834673579523",
      "hi": "0.9538172446271023",
      "hu": "0.9643178397205117"
    }
  },
  {
    "task_id": "Python/39",
    "prompt": {
      "en": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"",
      "sq": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Llogarit numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë maksimumi a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Args:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove me lule për t'u rregulluar.\n    - a (list of int): Një listë ku a[i] është numri maksimal i vazove për llojin e i-të të luleve.\n\n    Returns:\n    - int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"",
      "hy": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Հաշվել ծաղիկների m կաթսաների դասավորությունների քանակը մինչև n տեսակներ օգտագործելով,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] կաթսաներ, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Արձանագրություններ:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Դասավորելու ընդհանուր ծաղիկների կաթսաների քանակը:\n    - a (list of int): Ցանկ, որտեղ a[i]-ն i-րդ տեսակի ծաղիկների առավելագույն կաթսաների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:\n    \"\"\"",
      "bn": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    n প্রকারের ফুল ব্যবহার করে m টি ফুলের পাত্র সাজানোর উপায়ের সংখ্যা গণনা করুন,\n    যেখানে i তম প্রকারের সর্বাধিক a[i] টি পাত্র থাকতে পারে, এবং সাজানোটি ফুলের প্রকারের \n    ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    Args:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের পাত্রের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল i তম প্রকারের ফুলের জন্য সর্বাধিক পাত্রের সংখ্যা।\n\n    Returns:\n    - int: ভিন্ন ভিন্ন সাজানোর সংখ্যা মডুলো (10^6 + 7)।\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"",
      "bg": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Изчислява броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    където i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (list of int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.\n    \"\"\"",
      "zh": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    计算使用最多 n 种类型的 m 个花盆的排列方式，\n    其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的种类数。\n    - m (int): 要排列的花盆总数。\n    - a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数。\n\n    返回:\n    - int: 不同排列的数量，结果对 (10^6 + 7) 取模。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。\n    \"\"\"",
      "fr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calculer le nombre de façons d'organiser m pots de fleurs en utilisant jusqu'à n types,\n    où le ième type peut avoir au plus a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à organiser.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\n    Returns:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"",
      "de": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Berechne die Anzahl der Möglichkeiten, m Blumentöpfe unter Verwendung von bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in aufsteigender Reihenfolge\n    der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n    - a (list of int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabewert:\n    - int: Die Anzahl der verschiedenen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.\n    \"\"\"",
      "ha": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Lissafa yawan hanyoyin shirya tukwane m na furanni ta amfani da nau'ikan n,\n    inda nau'in na i zai iya samun mafi yawan tukwane a[i], kuma shiryawa dole ne ya kasance a\n    cikin tsari mai ƙaruwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Yawan nau'ikan furanni da ake da su.\n    - m (int): Jimlar yawan tukwane furanni da za a shirya.\n    - a (list of int): Jerin inda a[i] shine mafi yawan tukwane don nau'in furanni na i.\n\n    Returns:\n    - int: Yawan shirye-shiryen daban-daban modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    \"\"\"",
      "hi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    अधिकतम n प्रकारों का उपयोग करके m फूलों के गमलों को सजाने के तरीकों की संख्या की गणना करें,\n    जहाँ iवें प्रकार के पास अधिकतम a[i] गमले हो सकते हैं, और सजावट फूलों के प्रकारों के \n    बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): सजाने के लिए कुल फूलों के गमलों की संख्या।\n    - a (list of int): एक सूची जहाँ a[i] iवें प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\n    वापसी:\n    - int: विशिष्ट सजावटों की संख्या (10^6 + 7) के मापांक के साथ।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।\n    \"\"\"",
      "hu": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Számítsa ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus használatával,\n    ahol az i-edik típusnak legfeljebb a[i] cserép lehet, és az elrendezésnek növekvő sorrendben kell lennie\n    a virágtípusok szerint.\n\n    Paraméterek:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\n    Visszatér:\n    - int: A különböző elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9701059290238683",
      "hy": "0.967138192500826",
      "bn": "0.9562476859694452",
      "bg": "0.969626038023288",
      "zh": "0.9588205452949901",
      "fr": "0.9922701000916463",
      "de": "0.9631999479360474",
      "ha": "0.9551047667569704",
      "hi": "0.9545142386341537",
      "hu": "0.9581644691464318"
    },
    "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]",
    "instruction": {
      "en": "Write a python function 'def calculate_arrangements(n, m, a) -> int:' to solve the following problem:\n\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    ",
      "sq": "Shkruani një funksion python 'def calculate_arrangements(n, m, a) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë maksimumi a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Args:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove me lule për t'u rregulluar.\n    - a (list of int): Një listë ku a[i] është numri maksimal i vazove për llojin i-të të luleve.\n\n    Kthen:\n    - int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\n    Shembuj:\n    - calculate_arrangements(2, 4, [3, 2]) kthen 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.",
      "hy": "Պայթոն ֆունկցիա 'def calculate_arrangements(n, m, a) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք, թե քանի եղանակով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկամաններ, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Արգումենտներ:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Ընդհանուր դասավորելի ծաղկամանների քանակը:\n    - a (list of int): Ցանկ, որտեղ a[i]-ը i-րդ տեսակի ծաղիկների առավելագույն ծաղկամանների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:",
      "bn": "একটি পাইথন ফাংশন 'def calculate_arrangements(n, m, a) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    n প্রকারের মধ্যে m টি ফুলের পাত্র সাজানোর উপায়ের সংখ্যা গণনা করুন,\n    যেখানে i তম প্রকারের সর্বাধিক a[i] পাত্র থাকতে পারে, এবং বিন্যাসটি\n    ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    আর্গুমেন্টস:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের পাত্রের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল i তম প্রকারের ফুলের জন্য সর্বাধিক পাত্রের সংখ্যা।\n\n    রিটার্নস:\n    - int: পৃথক বিন্যাসের সংখ্যা মডুলো (10^6 + 7)।\n\n    উদাহরণ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 ফেরত দেয়।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 ফেরত দেয়।",
      "bg": "Напишете функция на Python 'def calculate_arrangements(n, m, a) -> int:', за да решите следния проблем:\n\n    Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    където i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (списък от int): Списък, където a[i] е максималният брой саксии за i-тия тип цвете.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.",
      "zh": "编写一个Python函数 'def calculate_arrangements(n, m, a) -> int:' 来解决以下问题：\n\n    计算使用最多n种类型的花盆来排列m个花盆的方法数，\n    其中第i种类型最多可以有a[i]个花盆，并且排列必须按照花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的类型数量。\n    - m (int): 要排列的花盆总数。\n    - a (list of int): 一个列表，其中a[i]是第i种花的最大花盆数量。\n\n    返回:\n    - int: 不同排列的数量，结果取模(10^6 + 7)。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。",
      "fr": "Écrire une fonction python 'def calculate_arrangements(n, m, a) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\n    où le ième type peut avoir au maximum a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à arranger.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\n    Retourne:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Exemples:\n    - calculate_arrangements(2, 4, [3, 2]) retourne 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) retourne 6.",
      "de": "Schreiben Sie eine Python-Funktion 'def calculate_arrangements(n, m, a) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die Anzahl der Möglichkeiten, m Blumentöpfe mit bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in\n    aufsteigender Reihenfolge der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n    - a (Liste von int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabewert:\n    - int: Die Anzahl der verschiedenen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.",
      "ha": "Rubuta wani aikin python 'def calculate_arrangements(n, m, a) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa yawan hanyoyin shirya tukwane m na furanni ta amfani da nau'ikan n,\n    inda nau'in na i zai iya samun mafi yawan tukwane a[i], kuma shirin dole ne ya kasance a cikin\n    tsari mai ƙaruwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Yawan nau'ikan furanni da ake da su.\n    - m (int): Jimlar yawan tukwane furanni da za a shirya.\n    - a (jerin int): Jerin inda a[i] shine mafi yawan tukwane don nau'in na i na fure.\n\n    Returns:\n    - int: Yawan shirye-shirye masu bambanta modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.",
      "hi": "एक पायथन फ़ंक्शन 'def calculate_arrangements(n, m, a) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    m फूलों के गमलों को n प्रकारों का उपयोग करके व्यवस्थित करने के तरीकों की संख्या की गणना करें,\n    जहाँ ith प्रकार के पास अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के \n    बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): कुल फूलों के गमलों की संख्या जिन्हें व्यवस्थित करना है।\n    - a (list of int): एक सूची जहाँ a[i] ith प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\n    लौटाता है:\n    - int: भिन्न व्यवस्थाओं की संख्या (10^6 + 7) के मापांक के साथ।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।",
      "hu": "Írj egy python függvényt 'def calculate_arrangements(n, m, a) -> int:' a következő probléma megoldására:\n\n    Számítsd ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus használatával,\n    ahol az i-edik típusnak legfeljebb a[i] cserepe lehet, és az elrendezésnek növekvő\n    sorrendben kell lennie a virágtípusok szerint.\n\n    Argumentumok:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\n    Visszatér:\n    - int: Az eltérő elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszatér 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszatér 6."
    },
    "instruction_bertscore": {
      "sq": "0.9702858881490859",
      "hy": "0.9519777286683382",
      "bn": "0.9526868391286327",
      "bg": "0.9633550782636355",
      "zh": "0.9536130525953984",
      "fr": "0.9914356538609187",
      "de": "0.9597783409923403",
      "ha": "0.9619662546394396",
      "hi": "0.9747224963398812",
      "hu": "0.9603152389122777"
    },
    "level": "easy",
    "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()",
    "entry_point": "calculate_arrangements",
    "signature": "def calculate_arrangements(n, m, a) -> int:",
    "docstring": {
      "en": "\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n    ",
      "sq": "\n    Llogarit numrin e mënyrave për të rregulluar m vazo lulesh duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë më së shumti a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Args:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove të luleve për t'u rregulluar.\n    - a (listë e int): Një listë ku a[i] është numri maksimal i vazove për llojin i-të të luleve.\n\n    Returns:\n    - int: Numri i rregullimeve të veçanta modulo (10^6 + 7).\n\n    Shembuj:\n    - calculate_arrangements(2, 4, [3, 2]) kthen 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.",
      "hy": "\n    Հաշվել, թե քանի եղանակով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկաման, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Պարամետրեր:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Դասավորելու ընդհանուր ծաղկամանների քանակը:\n    - a (list of int): Ցուցակ, որտեղ a[i]-ը ծաղիկների i-րդ տեսակի համար առավելագույն ծաղկամանների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:",
      "bn": "\n    m টি ফুলের টব সাজানোর উপায়ের সংখ্যা গণনা করুন n প্রকারের ফুল ব্যবহার করে,\n    যেখানে iতম প্রকারের ফুলের সর্বাধিক a[i] টি টব থাকতে পারে, এবং সাজানো\n    অবশ্যই ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের টবের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল iতম প্রকারের ফুলের জন্য সর্বাধিক টবের সংখ্যা।\n\n    রিটার্ন:\n    - int: পৃথক সাজানোর সংখ্যা মডুলো (10^6 + 7)।\n\n    উদাহরণ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 রিটার্ন করে।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 রিটার্ন করে।",
      "bg": "\n    Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    като i-тият тип може да има най-много a[i] саксии, а подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (list of int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.",
      "zh": "\n    计算使用最多 n 种类型的 m 个花盆的排列方式，其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按照花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的种类数。\n    - m (int): 要排列的花盆总数。\n    - a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数。\n\n    返回:\n    - int: 不同排列的数量，结果取模 (10^6 + 7)。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。",
      "fr": "\n    Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\n    où le ième type peut avoir au plus a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à arranger.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\n    Returns:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.",
      "de": "\n    Berechne die Anzahl der Möglichkeiten, m Blumentöpfe mit bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in\n    aufsteigender Reihenfolge der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtzahl der anzuordnenden Blumentöpfe.\n    - a (Liste von int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabe:\n    - int: Die Anzahl der unterschiedlichen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.",
      "ha": "\n    Lissafa adadin hanyoyin da za a tsara tukwane m na furanni ta amfani da har zuwa nau'ikan n,\n    inda nau'in na i na iya samun a kalla tukwane a[i], kuma tsarawa dole ne ya kasance a cikin\n    tsari mai karuwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Adadin nau'ikan furanni da ake da su.\n    - m (int): Jimillar adadin tukwane na furanni da za a tsara.\n    - a (list of int): Jerin inda a[i] shine mafi yawan tukwane don nau'in furanni na i.\n\n    Returns:\n    - int: Adadin tsaruka masu bambanci modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.",
      "hi": "\n    m गमलों को n प्रकारों तक का उपयोग करके फूलों की व्यवस्था करने के तरीकों की संख्या की गणना करें,\n    जहाँ ith प्रकार में अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): कुल गमलों की संख्या जिन्हें व्यवस्थित करना है।\n    - a (list of int): एक सूची जहाँ a[i] ith प्रकार के फूल के लिए गमलों की अधिकतम संख्या है।\n\n    लौटाता है:\n    - int: विशिष्ट व्यवस्थाओं की संख्या, (10^6 + 7) के मापांक के साथ।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।",
      "hu": "\n    Számítsuk ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus felhasználásával, ahol az i-edik típusnak legfeljebb a[i] cserép lehet, és az elrendezésnek növekvő sorrendben kell lennie a virágtípusok szerint.\n\n    Paraméterek:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\n    Visszatér:\n    - int: A különböző elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6."
    },
    "docstring_bertscore": {
      "sq": "0.9738111801516931",
      "hy": "0.9390437127768704",
      "bn": "0.9386867739821507",
      "bg": "0.9704110252891379",
      "zh": "0.9571341733600038",
      "fr": "0.9900456384544366",
      "de": "0.9622908166820506",
      "ha": "0.9594301419343861",
      "hi": "0.9628434064020897",
      "hu": "0.9386893561771041"
    }
  },
  {
    "task_id": "Python/40",
    "prompt": {
      "en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "sq": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë për të koduar tekstin alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Args:\n        key (str): Çelësi i enkriptimit i përdorur për të koduar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Returns:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "hy": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Վերջնական տեքստի ապակոդավորումը, որը կոդավորված է Վիժեների շիֆրով օգտագործելով տրամադրված բանալին։\n    \n    Վիժեների շիֆրը այբբենական տեքստի կոդավորման մեթոդ է, որը օգտագործում է Կեսարի շիֆրերի շարք՝ հիմնված բանալի բառի տառերի վրա։ Այս ֆունկցիան հակադարձում է գործընթացը՝ վերականգնելու սկզբնական տեքստը կոդավորված տեքստից։\n\n    Արգումենտներ:\n        key (str): Կոդավորման բանալին, որը օգտագործվել է սկզբնական տեքստը կոդավորելու համար։\n                   Այս բանալին պետք է պարունակի միայն այբբենական նիշեր։\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է ապակոդավորվի։\n                          Կոդավորված տեքստը պետք է պարունակի միայն այբբենական նիշեր։\n\n    Վերադարձնում է:\n        str: Ապակոդավորված տեքստը, որը համապատասխանում է մուտքային կոդավորված տեքստին։\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "bn": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    প্রদত্ত কী ব্যবহার করে ভিজেনার সাইফার দিয়ে এনক্রিপ্ট করা সাইফারটেক্সট ডিক্রিপ্ট করে।\n\n    ভিজেনার সাইফার হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে\n    সিজার সাইফারের একটি সিরিজ ব্যবহার করে বর্ণমালার পাঠ্য এনক্রিপ্ট করে। \n    এই ফাংশনটি প্রক্রিয়াটি উল্টে দেয় যাতে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করা যায়।\n\n    আর্গুমেন্টস:\n        key (str): মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত এনক্রিপশন কী।\n                   এই কী শুধুমাত্র বর্ণমালার অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা পাঠ্য যা ডিক্রিপ্ট করা প্রয়োজন।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণমালার অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    রিটার্নস:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    উদাহরণ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "bg": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Дешифрира шифротекст, криптиран с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за криптиране на азбучен текст чрез използване на серия от\n    шифри на Цезар, базирани на буквите от ключова дума. Тази функция обръща процеса,\n    за да възстанови оригиналния обикновен текст от шифротекста.\n\n    Аргументи:\n        key (str): Ключът за криптиране, използван за криптиране на оригиналния обикновен текст.\n                   Този ключ трябва да се състои само от азбучни символи.\n        ciphertext (str): Криптираният текст, който трябва да бъде дешифриран.\n                          Шифротекстът трябва да се състои само от азбучни символи.\n\n    Връща:\n        str: Дешифрираният обикновен текст, съответстващ на входния шифротекст.\n\n    Примери:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "zh": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键词字母的凯撒密码系列来加密字母文本的方法。\n    此函数反转该过程以从密文中恢复原始明文。\n\n    参数:\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回:\n        str: 与输入密文对应的解密明文。\n\n    示例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "fr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Déchiffre un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte en clair original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte en clair original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte en clair déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "de": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Entschlüsselt einen mit der Vigenère-Verschlüsselung verschlüsselten Geheimtext unter Verwendung des bereitgestellten Schlüssels.\n    \n    Die Vigenère-Verschlüsselung ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von\n    Caesar-Verschlüsselungen, die auf den Buchstaben eines Schlüsselworts basieren. Diese Funktion kehrt den Prozess um,\n    um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Argumente:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Rückgabe:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "ha": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Sakewa rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta amfani da jerin\n    Caesar ciphers bisa ga haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a sakewa.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka sakewa wanda ya dace da rubutun da aka bayar.\n\n    Misalai:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "hi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    दिए गए कुंजी का उपयोग करके Vigenère सिफर से एन्क्रिप्ट किए गए सिफरटेक्स्ट को डिक्रिप्ट करता है।\n    \n    Vigenère सिफर एक कीवर्ड के अक्षरों के आधार पर सीज़र सिफर की एक श्रृंखला का उपयोग करके वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है। \n    यह फ़ंक्शन प्रक्रिया को उलट देता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट को पुनः प्राप्त किया जा सके।\n\n    Args:\n        key (str): एन्क्रिप्शन कुंजी जिसका उपयोग मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए किया गया था।\n                   इस कुंजी में केवल वर्णमाला के अक्षर होने चाहिए।\n        ciphertext (str): एन्क्रिप्ट किया गया पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट में केवल वर्णमाला के अक्षर होने चाहिए।\n\n    Returns:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्ट किया गया प्लेनटेक्स्ट।\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\"",
      "hu": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Egy Vigenère-rejtjel segítségével titkosított szöveg visszafejtése a megadott kulcs használatával.\n    \n    A Vigenère-rejtjel egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-rejtvények sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje\n    az eredeti szöveget a titkosított szövegből.\n\n    Paraméterek:\n        key (str): Az eredeti szöveg titkosításához használt kulcs.\n                   Ez a kulcs csak alfabetikus karaktereket tartalmazhat.\n        ciphertext (str): A visszafejtendő titkosított szöveg.\n                          A titkosított szöveg csak alfabetikus karaktereket tartalmazhat.\n\n    Visszatér:\n        str: A visszafejtett szöveg, amely megfelel a bemeneti titkosított szövegnek.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9565488096270941",
      "hy": "0.9494048693427933",
      "bn": "0.9894412062049475",
      "bg": "0.9927045047349696",
      "zh": "0.9954467957755373",
      "fr": "0.9834866646422835",
      "de": "0.9926882170437248",
      "ha": "0.956349583354916",
      "hi": "0.9890274591212518",
      "hu": "0.947097777467073"
    },
    "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)",
    "instruction": {
      "en": "Write a python function 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' to solve the following problem:\n\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    ",
      "sq": "Shkruani një funksion python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' për të zgjidhur problemin e mëposhtëm:\n\n    Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë e enkriptimit të tekstit alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjalë kyçe. Ky funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Args:\n        key (str): Çelësi i enkriptimit i përdorur për të enkriptuar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Returns:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Shembuj:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "hy": "Պայթոն ֆունկցիա 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Վիջենեռի ծածկագրով կոդավորված ծածկագիրը ապակոդավորում է օգտագործելով տրամադրված բանալին:\n    \n    Վիջենեռի ծածկագիրը այբբենական տեքստը կոդավորելու մեթոդ է՝ օգտագործելով Կեսարի \n    ծածկագրերի շարք, հիմնված բանալի բառի տառերի վրա: Այս ֆունկցիան հակադարձում է \n    գործընթացը՝ վերականգնելու սկզբնական պարզ տեքստը ծածկագրից:\n\n    Արձանագրեր:\n        key (str): Կոդավորման բանալին, որն օգտագործվել է սկզբնական պարզ տեքստը կոդավորելու համար:\n                   Այս բանալին պետք է բաղկացած լինի միայն այբբենական նիշերից:\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է ապակոդավորվի:\n                          Ծածկագիրը պետք է բաղկացած լինի միայն այբբենական նիշերից:\n\n    Վերադարձնում է:\n        str: Ապակոդավորված պարզ տեքստը, որը համապատասխանում է մուտքային ծածկագրին:\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "bn": "একটি পাইথন ফাংশন 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    প্রদত্ত কী ব্যবহার করে Vigenère cipher দিয়ে এনক্রিপ্ট করা একটি সাইফারটেক্সট ডিক্রিপ্ট করে।\n    \n    Vigenère cipher হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে একটি সিরিজ\n    সিজার সাইফার ব্যবহার করে বর্ণানুক্রমিক পাঠ্য এনক্রিপ্ট করে। এই ফাংশনটি প্রক্রিয়াটি বিপরীত\n    করে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করে।\n\n    Args:\n        key (str): মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত এনক্রিপশন কী।\n                   এই কী শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা পাঠ্য যা ডিক্রিপ্ট করতে হবে।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    Returns:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "bg": "Напишете функция на Python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' за решаване на следния проблем:\n\n    Декриптира шифротекст, криптиран с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за криптиране на азбучен текст чрез използване на серия от\n    Цезарови шифри, базирани на буквите на ключова дума. Тази функция обръща процеса\n    за възстановяване на оригиналния открит текст от шифротекста.\n\n    Аргументи:\n        key (str): Ключът за криптиране, използван за криптиране на оригиналния открит текст.\n                   Този ключ трябва да съдържа само азбучни символи.\n        ciphertext (str): Криптираният текст, който трябва да бъде декриптиран.\n                          Шифротекстът трябва да съдържа само азбучни символи.\n\n    Връща:\n        str: Декриптираният открит текст, съответстващ на входния шифротекст.\n\n    Примери:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "zh": "编写一个Python函数 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' 来解决以下问题：\n\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键字字母的一系列凯撒密码来加密字母文本的方法。此函数反转该过程以从密文中恢复原始明文。\n\n    参数：\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回：\n        str: 与输入密文相对应的解密明文。\n\n    示例：\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "fr": "Écrivez une fonction python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' pour résoudre le problème suivant :\n\n    Décrypte un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "de": "Schreiben Sie eine Python-Funktion 'def vigenere_decrypt(key: str, ciphertext: str) -> str:', um das folgende Problem zu lösen:\n\n    Entschlüsselt einen mit dem Vigenère-Chiffre verschlüsselten Geheimtext unter Verwendung des angegebenen Schlüssels.\n    \n    Das Vigenère-Chiffre ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von\n    Caesar-Chiffren basierend auf den Buchstaben eines Schlüsselworts. Diese Funktion kehrt den Prozess um,\n    um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Argumente:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Rückgabe:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "ha": "Rubuta wani aikin python 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' don warware matsalar mai zuwa:\n\n    Yana fassara rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta amfani da jerin\n    Caesar ciphers bisa haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a fassara.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka fassara wanda ya dace da rubutun da aka shigar.\n\n    Misalai:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "hi": "एक पायथन फ़ंक्शन 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    दिए गए कुंजी का उपयोग करके Vigenère सिफर के साथ एन्क्रिप्ट किए गए सिफरटेक्स्ट को डिक्रिप्ट करता है।\n    \n    Vigenère सिफर एक कीवर्ड के अक्षरों के आधार पर सीज़र सिफर की एक श्रृंखला का उपयोग करके वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है। \n    यह फ़ंक्शन प्रक्रिया को उलट देता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट को पुनः प्राप्त किया जा सके।\n\n    तर्क:\n        key (str): एन्क्रिप्शन कुंजी जो मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए उपयोग की गई थी।\n                   इस कुंजी में केवल वर्णमाला के अक्षर होने चाहिए।\n        ciphertext (str): एन्क्रिप्टेड पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट में केवल वर्णमाला के अक्षर होने चाहिए।\n\n    लौटाता है:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्ट किया गया प्लेनटेक्स्ट।\n\n    उदाहरण:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "hu": "Írj egy python függvényt 'def vigenere_decrypt(key: str, ciphertext: str) -> str:' a következő probléma megoldására:\n\n    Visszafejt egy Vigenère titkosítással kódolt szöveget a megadott kulcs használatával.\n    \n    A Vigenère titkosítás egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-titkosítások sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje az\n    eredeti nyílt szöveget a titkosított szövegből.\n\n    Paraméterek:\n        key (str): Az eredeti nyílt szöveg titkosításához használt kulcs.\n                   Ennek a kulcsnak csak alfabetikus karakterekből kell állnia.\n        ciphertext (str): A titkosított szöveg, amelyet vissza kell fejteni.\n                          A titkosított szövegnek csak alfabetikus karakterekből kell állnia.\n\n    Visszatér:\n        str: A visszafejtett nyílt szöveg, amely megfelel a bemeneti titkosított szövegnek.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'"
    },
    "instruction_bertscore": {
      "sq": "0.9566223028680769",
      "hy": "0.985788989388859",
      "bn": "0.9815059224826036",
      "bg": "0.9736804813609722",
      "zh": "0.9841663778061849",
      "fr": "0.9702161688853427",
      "de": "0.9863366133493721",
      "ha": "0.9623436523634059",
      "hi": "0.986842723560249",
      "hu": "0.9693249143656392"
    },
    "level": "hard",
    "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()",
    "entry_point": "vigenere_decrypt",
    "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:",
    "docstring": {
      "en": "\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n    ",
      "sq": "\n    Dekriptimi i një teksti të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë e kodimit të tekstit alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Argumentet:\n        key (str): Çelësi i kodimit i përdorur për të koduar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Kthen:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Shembuj:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "hy": "\n    Վերծանում է Վիժեների ծածկագրով կոդավորված գաղտնագիրը՝ օգտագործելով տրամադրված բանալին։\n    \n    Վիժեների ծածկագիրը այբբենական տեքստի կոդավորման մեթոդ է, որը հիմնված է բանալի բառի տառերի վրա\n    Կեսարի մի շարք ծածկագրերի օգտագործմամբ։ Այս ֆունկցիան հակադարձում է գործընթացը՝\n    վերականգնելու սկզբնական պարզ տեքստը գաղտնագրից։\n\n    Արգումենտներ:\n        key (str): Կոդավորման բանալին, որը օգտագործվել է սկզբնական պարզ տեքստը կոդավորելու համար։\n                   Այս բանալին պետք է բաղկացած լինի միայն այբբենական նիշերից։\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է վերծանել։\n                          Գաղտնագիրը պետք է բաղկացած լինի միայն այբբենական նիշերից։\n\n    Վերադարձնում է:\n        str: Վերծանված պարզ տեքստը, որը համապատասխանում է մուտքային գաղտնագրին։\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "bn": "\n    প্রদত্ত কী ব্যবহার করে Vigenère সাইফার দিয়ে এনক্রিপ্ট করা সাইফারটেক্সট ডিক্রিপ্ট করে।\n    \n    Vigenère সাইফার হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে একাধিক Caesar সাইফার ব্যবহার করে বর্ণানুক্রমিক পাঠ্য এনক্রিপ্ট করে। \n    এই ফাংশন প্রক্রিয়াটি বিপরীত করে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করে।\n\n    আর্গুমেন্টস:\n        key (str): মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত এনক্রিপশন কী।\n                   এই কী শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা পাঠ্য যা ডিক্রিপ্ট করা প্রয়োজন।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    রিটার্নস:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    উদাহরণ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "bg": "\n    Декриптира шифротекст, шифрован с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за шифроване на азбучен текст чрез използване на серия от\n    шифри на Цезар, базирани на буквите от ключова дума. Тази функция обръща процеса,\n    за да възстанови оригиналния обикновен текст от шифротекста.\n\n    Аргументи:\n        key (str): Ключът за шифроване, използван за шифроване на оригиналния обикновен текст.\n                   Този ключ трябва да съдържа само азбучни символи.\n        ciphertext (str): Шифрован текст, който трябва да бъде декриптиран.\n                          Шифротекстът трябва да съдържа само азбучни символи.\n\n    Връща:\n        str: Декриптираният обикновен текст, съответстващ на входния шифротекст.\n\n    Примери:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "zh": "\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键字字母的凯撒密码系列来加密字母文本的方法。\n    此函数反转该过程以从密文中恢复原始明文。\n\n    参数:\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回:\n        str: 与输入密文对应的解密明文。\n\n    示例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "fr": "\n    Déchiffre un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "de": "\n    Entschlüsselt einen mit der Vigenère-Verschlüsselung verschlüsselten Geheimtext unter Verwendung des bereitgestellten Schlüssels.\n    \n    Die Vigenère-Verschlüsselung ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von Caesar-Verschlüsselungen basierend auf den Buchstaben eines Schlüsselworts. Diese Funktion kehrt den Prozess um, um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Argumente:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Rückgabewert:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "ha": "\n    Fassar da rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta hanyar amfani da jerin\n    Caesar ciphers bisa kan haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a fassara.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka fassara wanda ya dace da rubutun da aka bayar.\n\n    Misalai:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "hi": "\n    दिए गए कुंजी का उपयोग करके Vigenère सिफर के साथ एन्क्रिप्ट किए गए सिफरटेक्स्ट को डिक्रिप्ट करता है।\n    \n    Vigenère सिफर वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है जो एक कुंजी शब्द के अक्षरों पर आधारित\n    कई Caesar सिफर का उपयोग करती है। यह फ़ंक्शन प्रक्रिया को उलटता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट\n    को पुनः प्राप्त किया जा सके।\n\n    तर्क:\n        key (str): एन्क्रिप्शन कुंजी जिसका उपयोग मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए किया गया था।\n                   इस कुंजी में केवल वर्णमाला के अक्षर होने चाहिए।\n        ciphertext (str): एन्क्रिप्ट किया गया पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट में केवल वर्णमाला के अक्षर होने चाहिए।\n\n    वापसी:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्ट किया गया प्लेनटेक्स्ट।\n\n    उदाहरण:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'",
      "hu": "\n    Dekódolja a Vigenère-rejtjel segítségével titkosított rejtjelezett szöveget a megadott kulcs használatával.\n    \n    A Vigenère-rejtjel egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-rejtjelek sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje az\n    eredeti nyílt szöveget a rejtjelezett szövegből.\n\n    Paraméterek:\n        key (str): Az eredeti nyílt szöveg titkosítására használt kulcs.\n                   Ennek a kulcsnak csak alfabetikus karaktereket kell tartalmaznia.\n        ciphertext (str): A dekódolni kívánt titkosított szöveg.\n                          A rejtjelezett szövegnek csak alfabetikus karaktereket kell tartalmaznia.\n\n    Visszatér:\n        str: A bemeneti rejtjelezett szövegnek megfelelő dekódolt nyílt szöveg.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'"
    },
    "docstring_bertscore": {
      "sq": "0.9437292048351024",
      "hy": "0.9629069681240209",
      "bn": "0.9777629315823821",
      "bg": "0.9822539644975811",
      "zh": "0.9891506099574934",
      "fr": "0.9641948875146511",
      "de": "0.991983476451813",
      "ha": "0.9381782802067014",
      "hi": "0.9835736647491768",
      "hu": "0.9565911178982545"
    }
  },
  {
    "task_id": "Python/41",
    "prompt": {
      "en": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "sq": "def mod_inverse(a, b):\n    \"\"\"\n    Llogarit inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` të jenë bashkëkryesorë (d.m.th., gcd(a, b) == 1). Përdor Algoritmin e Zgjeruar të Euklidit\n    për të llogaritur inversin. Nëse `a` dhe `b` nuk janë bashkëkryesorë, inversi modular nuk ekziston, dhe funksioni kthen `None`.\n    \n    Argumentet:\n      a (int): Numri i plotë për të cilin do të gjendet inversi modular.\n      b (int): Moduli me të cilin kërkohet inversi.\n    \n    Kthen:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Shembuj:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "hy": "def mod_inverse(a, b):\n    \"\"\"\n    Հաշվել `a`-ի մոդուլային բազմապատկիչ հակադարձը `b`-ի մոդուլով:\n    \n    Այս ֆունկցիան գտնում է այնպիսի ամբողջ թիվ `x`, որ (a * x) % b == 1, ենթադրելով, որ\n    `a` և `b` փոխադարձաբար պարզ են (այսինքն՝ gcd(a, b) == 1): Այն օգտագործում է ընդլայնված\n    Եվկլիդյան ալգորիթմը հակադարձը հաշվարկելու համար: Եթե `a` և `b` փոխադարձաբար պարզ չեն,\n    ապա մոդուլային հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`:\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվ, որի մոդուլային հակադարձը պետք է գտնվի:\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է:\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլային հակադարձը `b`-ի մոդուլով, եթե այն գոյություն ունի, հակառակ դեպքում `None`:\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "bn": "def mod_inverse(a, b):\n    \"\"\"\n    `a` এর মডুলার গুণনীয় বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশন একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1 হয়, যদি\n    `a` এবং `b` পরস্পর সহমৌলিক হয় (অর্থাৎ, gcd(a, b) == 1)। এটি Extended Euclidean\n    Algorithm ব্যবহার করে বিপরীত হিসাব করে। যদি `a` এবং `b` পরস্পর সহমৌলিক না হয়, \n    তাহলে মডুলার বিপরীত থাকে না, এবং ফাংশন `None` প্রদান করে।\n    \n    Args:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    Returns:\n      int: যদি থাকে তবে `a` এর মডুলার বিপরীত `b` মডুলোর, অন্যথায় `None`।\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "bg": "def mod_inverse(a, b):\n    \"\"\"\n    Изчисляване на модулната мултипликативна обратна стойност на `a` модул `b`.\n    \n    Тази функция намира цяло число `x` такова, че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цялото число, чиято модулна обратна стойност трябва да бъде намерена.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "zh": "def mod_inverse(a, b):\n    \"\"\"\n    计算 `a` 模 `b` 的模逆。\n    \n    此函数找到一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。\n    它使用扩展欧几里得算法来计算逆元。如果 `a` 和 `b` 不是互质的，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 寻找逆元的模数。\n    \n    返回:\n      int: 如果存在，则为 `a` 模 `b` 的模逆，否则为 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "fr": "def mod_inverse(a, b):\n    \"\"\"\n    Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient premiers entre eux (c'est-à-dire, gcd(a, b) == 1). Elle utilise\n    l'algorithme d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas\n    premiers entre eux, l'inverse modulaire n'existe pas, et la fonction retourne `None`.\n    \n    Arguments:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Retourne:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Exemples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "de": "def mod_inverse(a, b):\n    \"\"\"\n    Berechne das modulare multiplikative Inverse von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, sodass (a * x) % b == 1, vorausgesetzt,\n    `a` und `b` sind teilerfremd (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht\n    teilerfremd sind, existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Argumente:\n      a (int): Die ganze Zahl, deren modulares Inverse gefunden werden soll.\n      b (int): Der Modulus, bezüglich dessen das Inverse gesucht wird.\n    \n    Rückgabewert:\n      int: Das modulare Inverse von `a` modulo `b`, falls es existiert, ansonsten `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "ha": "def mod_inverse(a, b):\n    \"\"\"\n    Lissafi modular multiplicative inverse na `a` modulo `b`.\n    \n    Wannan aikin yana nemo wani cikakken lamba `x` wanda (a * x) % b == 1, idan aka ba da cewa\n    `a` da `b` ba su da rabo (watau, gcd(a, b) == 1). Yana amfani da Tsarin Euclidean\n    Algorithm don lissafa inverse. Idan `a` da `b` ba su da rabo, to modular\n    inverse ba ya wanzu, kuma aikin yana dawowa da `None`.\n    \n    Args:\n      a (int): Cikakken lambar da za a nemo modular inverse ɗinta.\n      b (int): Modulus wanda za a nema inverse dangane da shi.\n    \n    Returns:\n      int: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "hi": "def mod_inverse(a, b):\n    \"\"\"\n    `a` का `b` के मापांक के साथ गुणात्मक प्रतिलोम गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` ढूंढता है ताकि (a * x) % b == 1 हो, बशर्ते कि\n    `a` और `b` सहप्राइम हों (अर्थात, gcd(a, b) == 1)। यह प्रतिलोम की गणना के लिए\n    विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` सहप्राइम नहीं हैं,\n    तो गुणात्मक प्रतिलोम मौजूद नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n    \n    तर्क:\n      a (int): वह पूर्णांक जिसका गुणात्मक प्रतिलोम ढूंढना है।\n      b (int): वह मापांक जिसके संदर्भ में प्रतिलोम खोजा जा रहा है।\n    \n    लौटाता है:\n      int: यदि `a` का `b` के मापांक के साथ गुणात्मक प्रतिलोम मौजूद है तो उसे लौटाता है, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\"",
      "hu": "def mod_inverse(a, b):\n    \"\"\"\n    Számítsa ki `a` moduláris multiplikatív inverzét `b` modulo szerint.\n    \n    Ez a függvény olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek,\n    a moduláris inverz nem létezik, és a függvény `None`-t ad vissza.\n    \n    Paraméterek:\n      a (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\n      b (int): A modulus, amelyhez képest az inverz keresendő.\n    \n    Visszatér:\n      int: `a` moduláris inverze `b` modulo szerint, ha létezik, különben `None`.\n    \n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.985151783126499",
      "hy": "0.9877834370448302",
      "bn": "0.9917000308980761",
      "bg": "0.9868063742005196",
      "zh": "0.9594615255345896",
      "fr": "0.9917598186427676",
      "de": "0.9820612930279772",
      "ha": "0.9898301244910137",
      "hi": "0.9691977909217768",
      "hu": "0.9834356166343575"
    },
    "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b",
    "instruction": {
      "en": "Write a python function 'def mod_inverse(a, b):' to solve the following problem:\n\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    ",
      "sq": "Shkruani një funksion python 'def mod_inverse(a, b):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` të jenë bashkëkryesorë (d.m.th., gcd(a, b) == 1). Ai përdor Algoritmin\n    Euklidian të Zgjeruar për të llogaritur inversin. Nëse `a` dhe `b` nuk janë bashkëkryesorë,\n    inversi modular nuk ekziston, dhe funksioni kthen `None`.\n    \n    Args:\n      a (int): Numri i plotë për të cilin duhet gjetur inversi modular.\n      b (int): Moduli në lidhje me të cilin kërkohet inversi.\n    \n    Returns:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "hy": "Պայթոն ֆունկցիա 'def mod_inverse(a, b):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվեք `a`-ի մոդուլյար բազմապատկիչ հակադարձը `b` մոդուլով:\n    \n    Այս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես որ (a * x) % b == 1, եթե\n    `a` և `b` փոխադարձաբար պարզ են (այսինքն՝ gcd(a, b) == 1): Այն օգտագործում է ընդլայնված Էվկլիդեսյան\n    ալգորիթմը հակադարձը հաշվարկելու համար: Եթե `a` և `b` փոխադարձաբար պարզ չեն, ապա մոդուլյար\n    հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`:\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվը, որի մոդուլյար հակադարձը պետք է գտնվի:\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը որոնվում է:\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլյար հակադարձը `b` մոդուլով, եթե այն գոյություն ունի, այլապես `None`:\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "bn": "একটি পাইথন ফাংশন 'def mod_inverse(a, b):' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    `a` এর মডুলার গুণনীয় বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশন একটি পূর্ণসংখ্যা `x` খুঁজে পায় যাতে (a * x) % b == 1 হয়, যদি \n    `a` এবং `b` পরস্পর সহমিত হয় (অর্থাৎ, gcd(a, b) == 1)। এটি ইনভার্স গণনা করতে \n    Extended Euclidean Algorithm ব্যবহার করে। যদি `a` এবং `b` পরস্পর সহমিত না হয়, \n    তাহলে মডুলার বিপরীত বিদ্যমান নেই এবং ফাংশন `None` ফেরত দেয়।\n    \n    আর্গুমেন্টস:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    রিটার্নস:\n      int: `a` এর মডুলার বিপরীত `b` মডুলোর যদি বিদ্যমান থাকে, অন্যথায় `None`।\n    \n    উদাহরণ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "bg": "Напишете Python функция 'def mod_inverse(a, b):', за да решите следния проблем:\n\n    Изчислете модулната мултипликативна обратна стойност на `a` модул `b`.\n    \n    Тази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е. gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цялото число, чиято модулна обратна стойност трябва да се намери.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "zh": "编写一个 Python 函数 'def mod_inverse(a, b):' 来解决以下问题：\n\n    计算 `a` 模 `b` 的模乘逆。\n    \n    此函数找到一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不是互质的，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 寻找逆的模数。\n    \n    返回:\n      int: 如果存在，返回 `a` 模 `b` 的模逆，否则返回 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "fr": "Écrivez une fonction python 'def mod_inverse(a, b):' pour résoudre le problème suivant :\n\n    Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient premiers entre eux (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\n    d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas premiers entre eux, l'inverse\n    modulaire n'existe pas, et la fonction retourne `None`.\n    \n    Args:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Returns:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Exemples :\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "de": "Schreiben Sie eine Python-Funktion 'def mod_inverse(a, b):', um das folgende Problem zu lösen:\n\n    Berechnen Sie das modulare multiplikative Inverse von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt,\n    `a` und `b` sind teilerfremd (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht teilerfremd sind, \n    existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Argumente:\n      a (int): Die ganze Zahl, deren modulares Inverses gefunden werden soll.\n      b (int): Der Modulus, in Bezug auf den das Inverse gesucht wird.\n    \n    Rückgabewert:\n      int: Das modulare Inverse von `a` modulo `b`, falls es existiert, andernfalls `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "ha": "Rubuta wani aikin python 'def mod_inverse(a, b):' don warware matsalar mai zuwa:\n\n    Lissafa modular multiplicative inverse na `a` modulo `b`.\n    \n    Wannan aikin yana samun wani cikakken lamba `x` wanda (a * x) % b == 1, idan aka\n    ba da cewa `a` da `b` suna da juna (watau, gcd(a, b) == 1). Yana amfani da Tsarin\n    Euclidean na ci gaba don lissafin inverse. Idan `a` da `b` ba su da juna, to modular\n    inverse ba ya wanzu, kuma aikin yana mayar da `None`.\n    \n    Args:\n      a (int): Cikakken lambar da za a nemo modular inverse ɗinta.\n      b (int): Modulus wanda ake nema inverse ɗinsa.\n    \n    Returns:\n      int: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "hi": "एक पायथन फ़ंक्शन 'def mod_inverse(a, b):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    `a` का `b` के मापांक के अनुसार मापांक गुणात्मक प्रतिलोम गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` खोजता है ताकि (a * x) % b == 1 हो, बशर्ते कि\n    `a` और `b` सह-प्राइम हों (अर्थात, gcd(a, b) == 1)। यह प्रतिलोम की गणना के लिए\n    विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` सह-प्राइम नहीं हैं, \n    तो मापांक प्रतिलोम अस्तित्व में नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n    \n    तर्क:\n      a (int): वह पूर्णांक जिसका मापांक प्रतिलोम खोजा जाना है।\n      b (int): वह मापांक जिसके अनुसार प्रतिलोम खोजा जा रहा है।\n    \n    लौटाता है:\n      int: यदि यह अस्तित्व में है तो `a` का `b` के मापांक के अनुसार मापांक प्रतिलोम, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "hu": "Írj egy python függvényt 'def mod_inverse(a, b):' a következő probléma megoldására:\n\n    Számítsd ki `a` moduláris multiplikatív inverzét `b` modulo szerint.\n    \n    Ez a függvény egy olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek, a moduláris\n    inverz nem létezik, és a függvény `None`-t ad vissza.\n    \n    Paraméterek:\n      a (int): Az egész szám, amelynek a moduláris inverzét meg kell találni.\n      b (int): Az a modulus, amelyhez képest az inverz keresendő.\n    \n    Visszatér:\n      int: `a` moduláris inverze `b` modulo szerint, ha létezik, különben `None`.\n    \n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None"
    },
    "instruction_bertscore": {
      "sq": "0.989558398129758",
      "hy": "0.9736415498062893",
      "bn": "0.9824339236227986",
      "bg": "0.9865793396749968",
      "zh": "0.9633695782814511",
      "fr": "0.9959966046702419",
      "de": "0.98158775819959",
      "ha": "0.9907189954461448",
      "hi": "0.9683484474124716",
      "hu": "0.9544026083600121"
    },
    "level": "easy",
    "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()",
    "entry_point": "mod_inverse",
    "signature": "def mod_inverse(a, b):",
    "docstring": {
      "en": "\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None\n    ",
      "sq": "\n    Llogaritni inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` të jenë të bashkëkryqëzuar (d.m.th., gcd(a, b) == 1). Përdor Algoritmin\n    e Zgjeruar të Euklidit për të llogaritur inversin. Nëse `a` dhe `b` nuk janë të\n    bashkëkryqëzuar, inversi modular nuk ekziston, dhe funksioni kthen `None`.\n    \n    Argumentet:\n      a (int): Numri i plotë për të cilin duhet gjetur inversi modular.\n      b (int): Moduli me të cilin kërkohet inversi.\n    \n    Kthen:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Shembuj:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "hy": "\n    Հաշվեք `a`-ի մոդուլային բազմապատիկ հակադարձը `b` մոդուլով:\n    \n    Այս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես, որ (a * x) % b == 1, պայմանով, որ\n    `a` և `b` փոխադարձաբար պարզ են (այսինքն, gcd(a, b) == 1): Այն օգտագործում է ընդլայնված\n    Եվկլիդյան ալգորիթմը հակադարձը հաշվարկելու համար: Եթե `a` և `b` փոխադարձաբար պարզ չեն, \n    մոդուլային հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`:\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվ, որի մոդուլային հակադարձը պետք է գտնվի:\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է:\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլային հակադարձը `b` մոդուլով, եթե այն գոյություն ունի, հակառակ դեպքում `None`:\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "bn": "\n    `a` এর মডুলার গুণাত্মক বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশনটি একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1 হয়, যদি\n    `a` এবং `b` পরস্পর সহমরী (অর্থাৎ, gcd(a, b) == 1) হয়। এটি Extended Euclidean\n    Algorithm ব্যবহার করে বিপরীত হিসাব করে। যদি `a` এবং `b` পরস্পর সহমরী না হয়, তাহলে মডুলার\n    বিপরীত বিদ্যমান নেই, এবং ফাংশনটি `None` ফেরত দেয়।\n    \n    আর্গস:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    রিটার্নস:\n      int: `a` এর মডুলার বিপরীত `b` মডুলোর যদি এটি বিদ্যমান থাকে, অন্যথায় `None`।\n    \n    উদাহরণ:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "bg": "\n    Изчислете модулната мултипликативна обратна стойност на `a` по модул `b`.\n    \n    Тази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цяло число, чиято модулна обратна стойност трябва да бъде намерена.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` по модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "zh": "\n    计算 `a` 模 `b` 的模逆。\n    \n    该函数找到一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。\n    它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不是互质的，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 寻找逆的模数。\n    \n    返回:\n      int: 如果存在，返回 `a` 模 `b` 的模逆，否则返回 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "fr": "\n    Calculer l'inverse modulaire multiplicatif de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient copremiers (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\n    d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas copremiers, l'inverse\n    modulaire n'existe pas, et la fonction retourne `None`.\n    \n    Args:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Returns:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "de": "\n    Berechne das modulare multiplikative Inverse von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt,\n    dass `a` und `b` teilerfremd sind (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht teilerfremd sind,\n    existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Argumente:\n      a (int): Die ganze Zahl, deren modulares Inverse gefunden werden soll.\n      b (int): Der Modulus, in Bezug auf den das Inverse gesucht wird.\n    \n    Rückgabewert:\n      int: Das modulare Inverse von `a` modulo `b`, falls es existiert, andernfalls `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "ha": "\n    Lissafi maimaitawar haɗin kai na `a` modulo `b`.\n    \n    Wannan aikin yana nemo wani cikakken lamba `x` wanda (a * x) % b == 1, idan aka tanadi cewa\n    `a` da `b` ba su da rabo (wato, gcd(a, b) == 1). Yana amfani da Tsarin Euclidean\n    da aka faɗaɗa don lissafin maimaitawar. Idan `a` da `b` ba su da rabo, maimaitawar\n    haɗin kai ba ya wanzu, kuma aikin yana mayar da `None`.\n    \n    Args:\n      a (int): Cikakken lambar da za a nemo maimaitawar haɗin kai.\n      b (int): Modulus da za a nema maimaitawar a kansa.\n    \n    Returns:\n      int: Maimaitawar haɗin kai na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "hi": "\n    `a` का `b` के मापांक के अनुसार गुणात्मक व्युत्क्रम (modular multiplicative inverse) गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` खोजता है ताकि (a * x) % b == 1 हो, बशर्ते कि `a` और `b` सह-प्राइम हों (अर्थात, gcd(a, b) == 1)। यह व्युत्क्रम की गणना के लिए विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` सह-प्राइम नहीं हैं, तो मापांक व्युत्क्रम मौजूद नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n    \n    तर्क:\n      a (int): वह पूर्णांक जिसका मापांक व्युत्क्रम खोजा जाना है।\n      b (int): वह मापांक जिसके संदर्भ में व्युत्क्रम खोजा जा रहा है।\n    \n    वापसी:\n      int: यदि मौजूद है तो `a` का `b` के मापांक के अनुसार व्युत्क्रम, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None",
      "hu": "\n    Számítsa ki `a` moduláris multiplikatív inverzét `b` modulo szerint.\n    \n    Ez a függvény olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek,\n    a moduláris inverz nem létezik, és a függvény `None`-t ad vissza.\n    \n    Paraméterek:\n      a (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\n      b (int): A modulus, amelyhez képest az inverz keresendő.\n    \n    Visszatér:\n      int: `a` moduláris inverze `b` modulo szerint, ha létezik, különben `None`.\n    \n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n\n      >>> mod_inverse(42, 2017)\n      None"
    },
    "docstring_bertscore": {
      "sq": "0.9816590665063816",
      "hy": "0.9901946112402128",
      "bn": "0.9880942935911499",
      "bg": "0.9836688087016925",
      "zh": "0.9531973192078924",
      "fr": "0.9936660744095595",
      "de": "0.9849742075658539",
      "ha": "0.9701303605607355",
      "hi": "0.9595330324717622",
      "hu": "0.9571615843525867"
    }
  },
  {
    "task_id": "Python/42",
    "prompt": {
      "en": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "sq": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më shumë mbi pragun.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e pakënaqur në asnjë ditë,\n    funksioni kthen 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Një listë prej 7 treshesh, ku çdo treshe përfaqëson\n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për çdo ditë të javës, përkatësisht.\n                                           \n    Returns:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0\n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "hy": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Հաշվարկել այն շաբաթվա օրը, երբ Ջինջինը ամենից դժգոհ է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերում անցկացրած ժամերի ընդհանուր քանակը գերազանցում է 8 ժամը մեկ օրվա ընթացքում։ \n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը առավելագույնն է, այսինքն՝ այն օրը, երբ ընդհանուր ժամերը առավելագույնս \n    գերազանցում են շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը \n    ոչ մի օր դժգոհ չէ, ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): Ցուցակ 7 տուփերով, որտեղ յուրաքանչյուր տուփ ներկայացնում է \n                                           դպրոցում և լրացուցիչ դասերում անցկացրած ժամերի քանակը \n                                           շաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենից դժգոհ է (1-7՝ երկուշաբթիից կիրակի) կամ 0, \n             եթե նա երբեք դժգոհ չէ։\n    \n    Օրինակներ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "bn": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    জিনজিনের সময়সূচির উপর ভিত্তি করে সপ্তাহের যে দিনটি সে সবচেয়ে অসুখী তা গণনা করুন।\n    \n    যদি জিনজিন স্কুল এবং অতিরিক্ত ক্লাসে মোট সময় ৮ ঘণ্টার বেশি ব্যয় করে তবে সে অসুখী হয়।\n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অসুখীতা সবচেয়ে বেশি, অর্থাৎ সেই দিনটি যখন মোট\n    সময়সীমা সবচেয়ে বেশি অতিক্রম করে। যদি একাধিক দিনের সর্বাধিক অসুখীতা একই হয়, তবে প্রথম\n    দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনো দিনই অসুখী না হয়, তাহলে ফাংশনটি 0 ফেরত দেয়।\n    \n    আর্গুমেন্টসমূহ:\n        schedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল\n                                           সপ্তাহের প্রতিদিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে\n                                           ব্যয়িত সময়ের সংখ্যা উপস্থাপন করে।\n                                           \n    রিটার্নস:\n        int: সপ্তাহের যে দিনটি জিনজিন সবচেয়ে অসুখী (সোমবার থেকে রবিবারের জন্য ১-৭) অথবা 0\n             যদি সে কখনোই অসুখী না হয়।\n    \n    উদাহরণসমূহ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "bg": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни класове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нейното нещастие е най-голямо, което е денят, когато общият брой часове е най-много над прага.\n    Ако има няколко дни със същото ниво на максимално нещастие, се връща най-ранният ден. \n    Ако Джинджин не е нещастна в нито един ден, функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя на часовете, прекарани в училище и в допълнителни класове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако тя никога не е нещастна.\n    \n    Примери:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "zh": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    根据日程计算金金最不开心的一天。\n    \n    如果金金在学校和额外课程中度过的总时间超过一天8小时，她就会不开心。\n    该函数找到她不开心程度最大的那一天，即总时间超过阈值最多的一天。\n    如果有多天达到相同的不开心程度，则返回最早的一天。\n    如果金金在任何一天都不感到不开心，函数返回0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别代表\n                                           一周中每天在学校和额外课程中度过的小时数。\n                                           \n    返回:\n        int: 金金最不开心的一天（1-7表示周一到周日），如果她从不不开心，则返回0。\n    \n    示例:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "fr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculer le jour de la semaine où Jinjin est la plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le total des heures passées à l'école et en cours supplémentaires dépasse 8 heures par jour.\n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total\n    des heures dépasse le plus le seuil. S'il y a plusieurs jours avec le même niveau de\n    malheur maximal, le premier jour est retourné. Si Jinjin n'est pas malheureuse un seul jour, la\n    fonction retourne 0.\n    \n    Arguments:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\n                                           nombre d'heures passées à l'école et en cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Retourne:\n        int: Le jour de la semaine où Jinjin est la plus malheureuse (1-7 pour lundi à dimanche) ou 0\n             si elle n'est jamais malheureuse.\n    \n    Cas:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "de": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, \n    an einem Tag 8 Stunden überschreiten. Die Funktion findet den Tag, an dem ihr Unglück am größten ist, \n    was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. Wenn es mehrere Tage \n    mit demselben Grad an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. Wenn Jinjin an keinem \n    Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Argumente:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden \n                                           darstellt, die an jedem Wochentag in der Schule und in zusätzlichen \n                                           Kursen verbracht werden.\n                                           \n    Rückgabewert:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, \n             wenn sie nie unglücklich ist.\n    \n    Fälle:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "ha": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Lissafa ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa bisa ga jadawalinta.\n    \n    Jinjin tana cikin rashin jin daɗi idan jimillar awanni da aka kwashe a makaranta da ƙarin aji sun wuce awanni 8 a rana.\n    Aikin yana gano ranar da rashin jin daɗinta ya fi girma, wato ranar da jimillar awanni suka fi nisa sama da ƙayyadadden matakin.\n    Idan akwai ranaku da yawa da suke da irin wannan matakin rashin jin daɗi mafi girma, za a dawo da ranar farko.\n    Idan Jinjin ba ta cikin rashin jin daɗi a kowace rana, aikin zai dawo da 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar \n                                           adadin awanni da aka kwashe a makaranta da kuma a ƙarin aji\n                                           don kowace rana ta mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa (1-7 don Litinin zuwa Lahadi) ko 0 \n             idan ba ta taɓa rashin jin daɗi ba.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "hi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    उसके कार्यक्रम के आधार पर जिनजिन किस दिन सबसे ज्यादा दुखी है, यह गणना करें।\n    \n    अगर जिनजिन स्कूल और अतिरिक्त कक्षाओं में कुल 8 घंटे से अधिक समय बिताती है तो वह दुखी होती है।\n    यह फ़ंक्शन उस दिन को ढूंढता है जब उसकी दुख की मात्रा सबसे अधिक होती है, जो वह दिन होता है जब कुल\n    घंटे सीमा से सबसे अधिक ऊपर होते हैं। यदि कई दिनों में अधिकतम दुख का समान स्तर होता है, तो सबसे पहले\n    वाला दिन लौटाया जाता है। यदि जिनजिन किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    तर्क:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहां प्रत्येक ट्यूपल सप्ताह के प्रत्येक दिन के लिए\n                                           स्कूल और अतिरिक्त कक्षाओं में बिताए गए घंटों की संख्या का प्रतिनिधित्व करता है।\n                                           \n    लौटाता है:\n        int: वह दिन जब जिनजिन सबसे ज्यादा दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             अगर वह कभी दुखी नहीं होती है।\n    \n    मामले:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\"",
      "hu": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Számítsa ki a hét azon napját, amikor Jinjin a legboldogtalanabb a menetrendje alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és az extra órákon eltöltött összes idő meghaladja a napi 8 órát.\n    A függvény megtalálja azt a napot, amikor a boldogtalansága a legnagyobb, ami az a nap, amikor az összes\n    óra a legtávolabb van a küszöbtől. Ha több nap is azonos szintű maximális boldogtalansággal bír, akkor\n    a legkorábbi nap kerül visszaadásra. Ha Jinjin egy napon sem boldogtalan, a függvény 0-t ad vissza.\n    \n    Paraméterek:\n        schedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden elem egy-egy tuple,\n                                          amely az iskolában és az extra órákon eltöltött órák számát\n                                          jelenti a hét minden napjára vonatkozóan.\n                                           \n    Visszatérési érték:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig), vagy 0,\n             ha soha nem boldogtalan.\n    \n    Esetek:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9875534230635918",
      "hy": "0.9827761637693218",
      "bn": "0.9557090003760785",
      "bg": "0.9809130107952145",
      "zh": "0.9495599996703815",
      "fr": "0.9811908946982822",
      "de": "0.9681935157152644",
      "ha": "0.9612517811588571",
      "hi": "0.9592591211763151",
      "hu": "0.9590728058789044"
    },
    "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day",
    "instruction": {
      "en": "Write a python function 'def find_most_unhappy_day(schedule) -> int:' to solve the following problem:\n\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    ",
      "sq": "Shkruani një funksion python 'def find_most_unhappy_day(schedule) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe në klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më larg pragut.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e\n    pakënaqur në asnjë ditë, funksioni kthen 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Një listë prej 7 treshesh, ku secili treshe përfaqëson\n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për secilën ditë të javës, përkatësisht.\n                                           \n    Returns:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0 \n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Rastet:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "hy": "Պայթոն ֆունկցիա 'def find_most_unhappy_day(schedule) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել շաբաթվա այն օրը, երբ Ջինջինը ամենից դժգոհ է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերում անցկացրած ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրում։ \n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը ամենամեծն է, այսինքն այն օրը, երբ ընդհանուր \n    ժամերը ամենից շատ են գերազանցում շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի \n    առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը ոչ մի օր դժգոհ չէ, \n    ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է \n                                           դպրոցում և լրացուցիչ դասերում անցկացրած ժամերի \n                                           քանակը շաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենից դժգոհ է (1-7 երկուշաբթիից կիրակի) կամ 0 \n             եթե նա երբեք դժգոհ չէ։\n    \n    Օրինակներ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "bn": "একটি পাইথন ফাংশন 'def find_most_unhappy_day(schedule) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    তার সময়সূচির উপর ভিত্তি করে সপ্তাহের কোন দিনে জিনজিন সবচেয়ে অসুখী তা গণনা করুন।\n    \n    জিনজিন অসুখী হয় যদি স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় এক দিনে ৮ ঘণ্টার বেশি হয়।\n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অসুখীতা সর্বাধিক হয়, যা সেই দিন যখন মোট\n    সময় সীমার উপরে সবচেয়ে বেশি থাকে। যদি একই স্তরের সর্বাধিক অসুখীতা সহ একাধিক দিন থাকে,\n    তাহলে প্রথম দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনো দিনেই অসুখী না হয়, তাহলে\n    ফাংশনটি 0 ফেরত দেয়।\n    \n    আর্গুমেন্টস:\n        schedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল\n                                           সপ্তাহের প্রতিটি দিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে\n                                           ব্যয় করা ঘন্টার সংখ্যা প্রতিনিধিত্ব করে।\n                                           \n    রিটার্নস:\n        int: সপ্তাহের দিন যখন জিনজিন সবচেয়ে অসুখী (সোমবার থেকে রবিবারের জন্য ১-৭) অথবা ০\n             যদি সে কখনও অসুখী না হয়।\n    \n    কেস:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "bg": "Напишете Python функция 'def find_most_unhappy_day(schedule) -> int:', за да решите следния проблем:\n\n    Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни класове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нейното нещастие е най-голямо, което е денят, когато общият\n    брой часове е най-далеч над прага. Ако има няколко дни с едно и също ниво на\n    максимално нещастие, връща се най-ранният ден. Ако Джинджин не е нещастна в нито един ден,\n    функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя на часовете, прекарани в училище и в допълнителни класове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако никога не е нещастна.\n    \n    Примери:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "zh": "编写一个 Python 函数 'def find_most_unhappy_day(schedule) -> int:' 来解决以下问题：\n\n    根据她的日程安排计算 Jinjin 最不开心的一天。\n    \n    如果在学校和额外课程上花费的总时间超过一天 8 小时，Jinjin 就会不开心。\n    该函数找到她最不开心的一天，即总时间超过阈值最多的一天。\n    如果有多天达到相同的最大不开心程度，则返回最早的一天。\n    如果 Jinjin 在任何一天都不不开心，函数返回 0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含 7 个元组的列表，其中每个元组分别表示\n                                           每周每天在学校和额外课程上花费的小时数。\n                                           \n    返回:\n        int: Jinjin 最不开心的星期几（1-7 表示周一到周日）或如果她从不不开心则返回 0。\n    \n    示例:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "fr": "Écrivez une fonction python 'def find_most_unhappy_day(schedule) -> int:' pour résoudre le problème suivant :\n\n    Calculez le jour de la semaine où Jinjin est le plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le nombre total d'heures passées à l'école et en cours supplémentaires dépasse 8 heures par jour. \n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total\n    d'heures dépasse le plus le seuil. S'il y a plusieurs jours avec le même niveau de \n    malheur maximal, le premier jour est retourné. Si Jinjin n'est pas malheureuse un jour quelconque, la \n    fonction retourne 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le \n                                           nombre d'heures passées à l'école et en cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Returns:\n        int: Le jour de la semaine où Jinjin est le plus malheureuse (1-7 pour lundi à dimanche) ou 0 \n             si elle n'est jamais malheureuse.\n    \n    Cas :\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "de": "Schreiben Sie eine Python-Funktion 'def find_most_unhappy_day(schedule) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie den Wochentag, an dem Jinjin basierend auf ihrem Stundenplan am unglücklichsten ist.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die in der Schule und in zusätzlichen Klassen verbracht werden, 8 Stunden an einem Tag überschreiten. \n    Die Funktion findet den Tag, an dem ihr Unglück am größten ist, was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Argumente:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die \n                                           Anzahl der Stunden darstellt, die in der Schule und in zusätzlichen Klassen\n                                           für jeden Tag der Woche verbracht werden.\n                                           \n    Rückgabe:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, \n             wenn sie niemals unglücklich ist.\n    \n    Fälle:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "ha": "Rubuta wani aikin python 'def find_most_unhappy_day(schedule) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa bisa jadawalin ta.\n    \n    Jinjin ba ta farin ciki ba idan jimlar awanni da aka kwashe a makaranta da karin aji sun wuce awanni 8 a rana.\n    Aikin yana gano ranar da rashin jin daɗin ta ya fi yawa, wato ranar da jimlar\n    awanni suka fi nesa da iyaka. Idan akwai ranaku da yawa tare da irin wannan matakin\n    na rashin jin daɗi mafi girma, ranar farko ce ake dawowa. Idan Jinjin ba ta cikin rashin jin daɗi a kowace rana, \n    aikin yana dawowa 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowane tuple ke wakiltar \n                                           adadin awanni da aka kwashe a makaranta da karin aji\n                                           a kowane rana na mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako inda Jinjin take cikin rashin jin daɗi mafi yawa (1-7 don Litinin zuwa Lahadi) ko 0 \n             idan ba ta taɓa kasancewa cikin rashin jin daɗi ba.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "hi": "एक पायथन फ़ंक्शन 'def find_most_unhappy_day(schedule) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    उसके कार्यक्रम के आधार पर उस सप्ताह के दिन की गणना करें जब जिनजिन सबसे अधिक दुखी होती है।\n    \n    जिनजिन दुखी होती है यदि स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे एक दिन में 8 घंटे से अधिक होते हैं।\n    फ़ंक्शन उस दिन को खोजता है जब उसकी दुख की स्थिति सबसे अधिक होती है, जो वह दिन होता है जब कुल घंटे\n    सीमा से सबसे अधिक ऊपर होते हैं। यदि अधिकतम दुख के समान स्तर वाले कई दिन हैं, तो सबसे पहला दिन लौटाया जाता है।\n    यदि जिनजिन किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    तर्क:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल क्रमशः \n                                           सप्ताह के प्रत्येक दिन के लिए स्कूल और अतिरिक्त कक्षाओं में \n                                           बिताए गए घंटों की संख्या को दर्शाता है।\n                                           \n    लौटाता है:\n        int: वह सप्ताह का दिन जब जिनजिन सबसे अधिक दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             यदि वह कभी दुखी नहीं होती है।\n    \n    मामले:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "hu": "Írj egy python függvényt 'def find_most_unhappy_day(schedule) -> int:' a következő probléma megoldására:\n\n    Számítsd ki, hogy a hét melyik napján a legboldogtalanabb Jinjin a beosztása alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és a különórákon eltöltött összes óra meghaladja a napi 8 órát.\n    A függvény megkeresi azt a napot, amikor a boldogtalansága a legnagyobb, ami az a nap, amikor az összes\n    óra a legnagyobb mértékben haladja meg a küszöböt. Ha több nap is van azonos szintű maximális\n    boldogtalansággal, akkor a legkorábbi napot adja vissza. Ha Jinjin egyetlen napon sem boldogtalan,\n    a függvény 0-t ad vissza.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden elem egy tuple, amely\n                                           az iskolában és a különórákon eltöltött órák számát jelenti\n                                           a hét minden napjára vonatkozóan.\n                                           \n    Returns:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0,\n             ha soha nem boldogtalan.\n    \n    Esetek:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0"
    },
    "instruction_bertscore": {
      "sq": "0.9902516181595697",
      "hy": "0.9697996409763125",
      "bn": "0.965327477947312",
      "bg": "0.9869940799105976",
      "zh": "0.9366251892573896",
      "fr": "0.9824968894535867",
      "de": "0.9798231258944761",
      "ha": "0.9822495946291983",
      "hi": "0.9870810800174908",
      "hu": "0.9542895876732033"
    },
    "level": "easy",
    "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()",
    "entry_point": "find_most_unhappy_day",
    "signature": "def find_most_unhappy_day(schedule) -> int:",
    "docstring": {
      "en": "\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0\n    ",
      "sq": "\n    Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më larg mbi pragun.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme.\n    Nëse Jinjin nuk është e pakënaqur në asnjë ditë, funksioni kthen 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Një listë prej 7 treshesh, ku çdo treshe përfaqëson\n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për çdo ditë të javës, respektivisht.\n                                           \n    Returns:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0\n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "hy": "\n    Հաշվեք շաբաթվա այն օրը, երբ Ջինջինը ամենաանհաջողն է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերին անցկացրած ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրվա ընթացքում։\n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը ամենամեծն է, այսինքն՝ այն օրը, երբ ընդհանուր ժամերը առավելագույնս գերազանցում են շեմը։\n    Եթե կան մի քանի օրեր նույն մակարդակի առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։\n    Եթե Ջինջինը ոչ մի օր դժգոհ չէ, ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է\n                                           դպրոցում և լրացուցիչ դասերին անցկացրած ժամերի քանակը\n                                           շաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենաանհաջողն է (1-7 երկուշաբթիից կիրակի) կամ 0,\n             եթե նա երբեք դժգոհ չէ։\n    \n    Օրինակներ:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "bn": "\n    জিনজিনের সময়সূচির উপর ভিত্তি করে সপ্তাহের কোন দিনটি তার সবচেয়ে অখুশি দিন তা হিসাব করুন।\n    \n    যদি জিনজিনের স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় এক দিনে 8 ঘন্টা অতিক্রম করে, তবে সে অখুশি হয়। \n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অখুশি হওয়ার মাত্রা সবচেয়ে বেশি, অর্থাৎ যেদিন মোট সময় \n    থ্রেশহোল্ডের উপরে সবচেয়ে বেশি। যদি একই স্তরের সর্বাধিক অখুশি হওয়ার একাধিক দিন থাকে, তবে সবচেয়ে \n    প্রথম দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনও দিনই অখুশি না হয়, তবে ফাংশনটি 0 ফেরত দেয়।\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল \n                                           সপ্তাহের প্রতিদিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে \n                                           ব্যয় করা ঘন্টার সংখ্যা উপস্থাপন করে।\n                                           \n    Returns:\n        int: সপ্তাহের দিনটি যখন জিনজিন সবচেয়ে অখুশি (সোমবার থেকে রবিবারের জন্য 1-7) বা \n             0 যদি সে কখনও অখুশি না হয়।\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "bg": "\n    Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни часове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нещастието й е най-голямо, което е денят, когато общият брой часове е най-далеч\n    над прага. Ако има няколко дни със същото ниво на максимално нещастие, се връща най-ранният ден. Ако Джинджин\n    не е нещастна в нито един ден, функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя часове, прекарани в училище и в допълнителни часове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако никога не е нещастна.\n    \n    Примери:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "zh": "\n    计算根据金金的日程安排她最不开心的那一天。\n    \n    如果金金在学校和额外课程中度过的总时间超过8小时，她就会不开心。\n    该函数找到她不开心程度最大的那一天，即总小时数最远超过阈值的那一天。\n    如果有多天具有相同程度的最大不开心，返回最早的一天。\n    如果金金在任何一天都不不开心，函数返回0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别表示\n                                           每周每天在学校和额外课程中度过的小时数。\n                                           \n    返回:\n        int: 金金最不开心的那一天（1-7表示周一到周日），如果她从未不开心则返回0。\n    \n    示例:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "fr": "\n    Calculer le jour de la semaine où Jinjin est le plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le total des heures passées à l'école et aux cours supplémentaires dépasse 8 heures par jour.\n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total des heures dépasse le plus le seuil.\n    S'il y a plusieurs jours avec le même niveau de malheur maximal, le premier jour est retourné. Si Jinjin n'est malheureuse aucun jour,\n    la fonction retourne 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\n                                           nombre d'heures passées à l'école et aux cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Returns:\n        int: Le jour de la semaine où Jinjin est le plus malheureuse (1-7 pour lundi à dimanche) ou 0\n             si elle n'est jamais malheureuse.\n    \n    Cas:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "de": "\n    Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, an einem Tag 8 Stunden überschreiten.\n    Die Funktion findet den Tag, an dem ihr Unglück am größten ist, also den Tag, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen.\n    Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben.\n    Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden darstellt,\n                                           die an jedem Wochentag in der Schule und in zusätzlichen Kursen verbracht werden.\n                                           \n    Returns:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, wenn sie nie unglücklich ist.\n    \n    Fälle:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "ha": "\n    Lissafa ranar mako lokacin da Jinjin take cikin rashin farin ciki mafi yawa bisa ga jadawalin ta.\n    \n    Jinjin tana cikin rashin farin ciki idan adadin awanni da aka kwashe a makaranta da kuma karin azuzuwan sun wuce awanni 8 a rana.\n    Aikin yana gano ranar da rashin farin cikinta ya fi yawa, wato ranar da adadin awanni ya fi nesa da iyaka.\n    Idan akwai ranaku da dama da ke da irin wannan matakin rashin farin ciki mafi girma, ranar da ta zo da wuri za a mayar.\n    Idan Jinjin ba ta cikin rashin farin ciki a kowace rana, aikin yana mayar da 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar \n                                           adadin awanni da aka kwashe a makaranta da kuma karin azuzuwan\n                                           don kowace rana ta mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako lokacin da Jinjin take cikin rashin farin ciki mafi yawa (1-7 don Litinin zuwa Lahadi) ko 0 \n             idan ba ta taɓa kasancewa cikin rashin farin ciki ba.\n    \n    Cases:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "hi": "\n    जिनजिन के शेड्यूल के आधार पर वह किस दिन सबसे ज्यादा दुखी होती है, यह गणना करें।\n    \n    जिनजिन दुखी होती है यदि स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे किसी दिन में 8 घंटे से अधिक हो जाते हैं। \n    यह फ़ंक्शन उस दिन को ढूंढता है जब उसकी दुख की मात्रा सबसे अधिक होती है, अर्थात वह दिन जब कुल घंटे सीमा से सबसे अधिक ऊपर होते हैं। \n    यदि कई दिनों में समान स्तर की अधिकतम दुख होती है, तो सबसे पहले आने वाला दिन लौटाया जाता है। \n    यदि जिनजिन किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    तर्क:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहां प्रत्येक ट्यूपल सप्ताह के प्रत्येक दिन के लिए \n                                           स्कूल और अतिरिक्त कक्षाओं में बिताए गए घंटों की संख्या का प्रतिनिधित्व करता है।\n                                           \n    लौटाता है:\n        int: वह सप्ताह का दिन जब जिनजिन सबसे ज्यादा दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             यदि वह कभी दुखी नहीं होती है।\n    \n    उदाहरण:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0",
      "hu": "\n    Számítsd ki, hogy a hét melyik napján a legboldogtalanabb Jinjin a napirendje alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és a különórákon töltött összes idő meghaladja a napi 8 órát. \n    A függvény megtalálja azt a napot, amikor a boldogtalansága a legnagyobb, ami az a nap, amikor az \n    összóraszám a legjobban meghaladja a küszöböt. Ha több nap is azonos szintű maximális boldogtalanságot \n    mutat, akkor a legkorábbi napot adja vissza. Ha Jinjin egy napon sem boldogtalan, a függvény 0-t ad vissza.\n    \n    Paraméterek:\n        schedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden elem egy tuple, amely az \n                                           iskolában és a különórákon töltött órák számát jelenti a hét \n                                           minden napjára vonatkozóan.\n                                           \n    Visszatérési érték:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0, \n             ha soha nem boldogtalan.\n    \n    Esetek:\n    >>> find_most_unhappy_day([(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)])\n    3\n    >>> find_most_unhappy_day([(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)])\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9887034929697839",
      "hy": "0.973907118625733",
      "bn": "0.9751676270237803",
      "bg": "0.989080096172226",
      "zh": "0.938039437570358",
      "fr": "0.982435909926609",
      "de": "0.9505503707502215",
      "ha": "0.9732913644445248",
      "hi": "0.9580313867911385",
      "hu": "0.9495860202502971"
    }
  },
  {
    "task_id": "Python/43",
    "prompt": {
      "en": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "sq": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformon permutimin hyrës në permutimin e ardhshëm në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek\n    dhe e ndërron atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj e kthen\n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit\n    (në rend zbritës), funksioni kthen False, duke treguar se nuk është i mundur asnjë permutim tjetër.\n    \n    Argumentet:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n    \n    Kthen:\n    bool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n    \n    Shembuj:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "hy": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Փոխակերպում է մուտքային փոխատեղումը հաջորդ փոխատեղման՝ բառարանային կարգով։\n    \n    Ֆունկցիան գտնում է վերջից առաջին թիվը, որը փոքր է իրեն հաջորդող թվից և փոխանակում է այն \n    ամենափոքր թվի հետ, որը մեծ է և գտնվում է դրանից հետո։ Այնուհետև այն շրջում է թվերի \n    կարգը սկզբնական առաջին փոքր թվից հետո։ Եթե մուտքը վերջին փոխատեղումն է (նվազող կարգով), \n    ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխատեղումը հնարավոր չէ։\n    \n    Պարամետրեր:\n    perm (list): Թվերի ցուցակ, որը ներկայացնում է ընթացիկ փոխատեղումը։\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխատեղումը հաջողությամբ փոխակերպվեց, False, եթե դա վերջին փոխատեղումն էր։\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "bn": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ইনপুট ক্রমবিন্যাসকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী ক্রমবিন্যাসে রূপান্তর করে।\n\n    ফাংশনটি শেষ থেকে প্রথম যে সংখ্যাটি তার পরবর্তী সংখ্যার চেয়ে ছোট তা খুঁজে বের করে এবং \n    এটি তার পরবর্তী এবং বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার পরের \n    সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ ক্রমবিন্যাস হয় (অধোগামী ক্রমে), ফাংশনটি \n    False ফেরত দেয়, যা নির্দেশ করে যে পরবর্তী কোনো ক্রমবিন্যাস সম্ভব নয়।\n\n    আর্গুমেন্টসমূহ:\n    perm (list): বর্তমান ক্রমবিন্যাসের প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    bool: যদি ক্রমবিন্যাসটি সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ ক্রমবিন্যাস হয় তবে False।\n\n    উদাহরণ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "bg": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число, \n    и го разменя с най-малкото число, което е по-голямо и идва след него. След това \n    обръща реда на числата след първоначалното по-малко число. Ако входът е последната \n    пермутация (в низходящ ред), функцията връща False, което показва, че няма възможна \n    следваща пермутация.\n    \n    Аргументи:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Връща:\n    bool: True, ако пермутацията е успешно преобразувана, False, ако е последната пермутация.\n    \n    Примери:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "zh": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    将输入排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个小于其后面的数字的数字，并将其与后面较大且最小的数字交换。\n    然后反转原始第一个较小数字之后的数字顺序。\n    如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列可能。\n    \n    参数:\n    perm (list): 表示当前排列的整数列表。\n    \n    返回:\n    bool: 如果排列成功转换则为 True，如果是最后一个排列则为 False。\n    \n    示例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "fr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et qui vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation \n    (en ordre décroissant), la fonction renvoie False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Returns:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "de": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikografischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl vom Ende her, die kleiner ist als die folgende Zahl,\n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die\n    Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die\n    letzte Permutation ist (in absteigender Reihenfolge), gibt die Funktion False zurück, was anzeigt,\n    dass keine nächste Permutation möglich ist.\n    \n    Argumente:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Rückgabe:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Beispiele:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "ha": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Canza shigarwar da aka bayar zuwa juyin halitta na gaba a cikin tsarin haruffa.\n    \n    Aikin yana samun lamba ta farko daga ƙarshen da ta fi ƙarami fiye da lambar da ke biyo baya \n    kuma yana musanya ta da mafi ƙarancin lamba wadda ta fi girma kuma tana zuwa bayan ta. Sannan yana juyar da \n    tsarin lambobi bayan asalin lambar farko mafi ƙaranci. Idan shigarwar ita ce juyin halitta na ƙarshe \n    (a cikin tsarin saukowa), aikin yana dawowa da False, yana nuna babu wani juyin halitta na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobi da ke wakiltar juyin halitta na yanzu.\n    \n    Returns:\n    bool: True idan an yi nasarar canza juyin halitta, False idan ita ce juyin halitta na ƙarshe.\n    \n    Misalai:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "hi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    इनपुट क्रमचय को शब्दकोशीय क्रम में अगले क्रमचय में बदलता है।\n    \n    यह फ़ंक्शन अंत से पहला ऐसा संख्या ढूंढता है जो उसके बाद आने वाली संख्या से छोटी होती है \n    और इसे उसके बाद आने वाली सबसे छोटी और बड़ी संख्या के साथ बदल देता है। फिर यह मूल \n    पहली छोटी संख्या के बाद की संख्याओं के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, यह दर्शाता है कि कोई अगला क्रमचय \n    संभव नहीं है।\n    \n    Args:\n    perm (list): वर्तमान क्रमचय का प्रतिनिधित्व करने वाली पूर्णांकों की सूची।\n    \n    Returns:\n    bool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\"",
      "hu": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Az input permutációt a lexikografikus sorrendben következő permutációvá alakítja.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám,\n    és kicseréli a legkisebb számmal, amely nagyobb és utána következik. Ezután megfordítja\n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input az utolsó permutáció\n    (csökkenő sorrendben), a függvény False-t ad vissza, jelezve, hogy nincs következő permutáció.\n    \n    Paraméterek:\n    perm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n    \n    Visszatérési érték:\n    bool: True, ha a permutációt sikeresen átalakították, False, ha az utolsó permutáció volt.\n    \n    Példák:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9906182898429602",
      "hy": "0.9794544679072753",
      "bn": "0.9629101462101174",
      "bg": "0.9816507240303781",
      "zh": "0.9735271387068132",
      "fr": "0.9908814750978314",
      "de": "0.9889124521306325",
      "ha": "0.9693187568238271",
      "hi": "0.9908371805228606",
      "hu": "0.9800398316401852"
    },
    "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True",
    "instruction": {
      "en": "Write a python function 'def next_permutation(perm: list) -> bool:' to solve the following problem:\n\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    ",
      "sq": "Shkruani një funksion python 'def next_permutation(perm: list) -> bool:' për të zgjidhur problemin e mëposhtëm:\n\n    Transformon permutimin hyrës në permutimin e ardhshëm në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek \n    dhe e shkëmben atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj e kthen \n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit \n    (në rend zbritës), funksioni kthen False, duke treguar se nuk është e mundur një permutim tjetër.\n    \n    Args:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n    \n    Returns:\n    bool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "hy": "Պայթոն ֆունկցիա 'def next_permutation(perm: list) -> bool:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Մուտքագրված փոխատեղումը փոխակերպում է հաջորդ փոխատեղման՝ բառարանային կարգով:\n    \n    Ֆունկցիան գտնում է վերջից առաջին թիվը, որը փոքր է հաջորդ թվից \n    և այն փոխանակում է ամենափոքր թվի հետ, որը մեծ է և գալիս է դրանից հետո: Այնուհետև այն շրջում է \n    թվերի կարգը սկզբնական առաջին փոքր թվից հետո: Եթե մուտքագրվածը վերջին փոխատեղումն է \n    (նվազման կարգով), ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխատեղումը հնարավոր չէ:\n    \n    Արգումենտներ:\n    perm (list): Թվերի ցուցակ, որը ներկայացնում է ընթացիկ փոխատեղումը:\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխատեղումը հաջողությամբ փոխակերպվել է, False, եթե այն վերջին փոխատեղումն էր:\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "bn": "একটি পাইথন ফাংশন 'def next_permutation(perm: list) -> bool:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n\n    ফাংশনটি শেষ থেকে প্রথম সংখ্যাটি খুঁজে বের করে যা তার পরবর্তী সংখ্যার চেয়ে ছোট \n    এবং এটি তার পরবর্তী এবং বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার \n    পরের সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় (অবতরণ ক্রমে), \n    ফাংশনটি False ফেরত দেয়, যা নির্দেশ করে যে পরবর্তী কোনো পারমুটেশন সম্ভব নয়।\n\n    Args:\n    perm (list): বর্তমান পারমুটেশন প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    Returns:\n    bool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ পারমুটেশন হয় তবে False।\n\n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "bg": "Напишете Python функция 'def next_permutation(perm: list) -> bool:' за решаване на следния проблем:\n\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число \n    и го разменя с най-малкото число, което е по-голямо и се намира след него. След това \n    обръща реда на числата след първоначалното първо по-малко число. Ако входът е последната \n    пермутация (в низходящ ред), функцията връща False, което означава, че не е възможна следваща пермутация.\n    \n    Args:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Returns:\n    bool: True, ако пермутацията е успешно преобразувана, False, ако е последната пермутация.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "zh": "编写一个 Python 函数 'def next_permutation(perm: list) -> bool:' 来解决以下问题：\n\n    将输入的排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个比其后面的数字小的数字，并将其与后面比它大的最小数字交换。然后，它反转原始第一个较小数字之后的数字顺序。如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列可能。\n    \n    参数：\n    perm (list): 表示当前排列的整数列表。\n    \n    返回：\n    bool: 如果排列成功转换，返回 True；如果是最后一个排列，返回 False。\n    \n    示例：\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "fr": "Écrire une fonction python 'def next_permutation(perm: list) -> bool:' pour résoudre le problème suivant :\n\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier plus petit nombre original. Si l'entrée est la dernière permutation \n    (en ordre décroissant), la fonction retourne False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Renvoie:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Exemples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "de": "Schreiben Sie eine Python-Funktion 'def next_permutation(perm: list) -> bool:', um das folgende Problem zu lösen:\n\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl vom Ende, die kleiner ist als die folgende Zahl, \n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die \n    Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die \n    letzte Permutation (in absteigender Reihenfolge) ist, gibt die Funktion False zurück, was anzeigt, \n    dass keine nächste Permutation möglich ist.\n    \n    Args:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Returns:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Beispiele:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "ha": "Rubuta wani aikin python 'def next_permutation(perm: list) -> bool:' don warware matsalar mai zuwa:\n\n    Canza permutation ɗin shigarwa zuwa permutation na gaba a cikin tsarin lexicographic.\n    \n    Aikin yana nemo lambar farko daga ƙarshen da ta fi ƙarama fiye da lambar da ke biyo baya \n    kuma yana musanya ta da mafi ƙarancin lamba da ta fi girma kuma ta biyo baya. Sannan yana juyar da \n    tsarin lambobin bayan lambar farko da ta fi ƙarama ta asali. Idan shigarwar ita ce permutation na ƙarshe \n    (a cikin tsarin saukowa), aikin yana dawowa da False, yana nuna babu wani permutation na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobin da ke wakiltar permutation na yanzu.\n    \n    Returns:\n    bool: True idan permutation ɗin an canza shi cikin nasara, False idan ita ce permutation na ƙarshe.\n    \n    Misalai:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "hi": "एक पायथन फ़ंक्शन 'def next_permutation(perm: list) -> bool:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    इनपुट क्रमचय को शब्दकोशीय क्रम में अगले क्रमचय में परिवर्तित करता है।\n    \n    फ़ंक्शन अंत से पहला ऐसा संख्या खोजता है जो इसके बाद आने वाली संख्या से छोटी हो \n    और इसे सबसे छोटी संख्या के साथ बदल देता है जो बड़ी हो और इसके बाद आती हो। फिर यह \n    मूल पहले छोटे संख्या के बाद की संख्याओं के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, यह दर्शाता है कि कोई अगला क्रमचय संभव नहीं है।\n    \n    तर्क:\n    perm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n    \n    लौटाता है:\n    bool: True यदि क्रमचय को सफलतापूर्वक परिवर्तित किया गया, False यदि यह अंतिम क्रमचय था।\n    \n    उदाहरण:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "hu": "Írj egy python függvényt 'def next_permutation(perm: list) -> bool:' a következő probléma megoldására:\n\n    Az input permutációt átalakítja a következő permutációvá lexikografikus sorrendben.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám, \n    és kicseréli a legkisebb, nála nagyobb számmal, amely utána következik. Ezután megfordítja \n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input az utolsó permutáció \n    (csökkenő sorrendben), a függvény False-t ad vissza, jelezve, hogy nincs következő permutáció.\n    \n    Args:\n    perm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n    \n    Returns:\n    bool: True, ha a permutáció sikeresen átalakult, False, ha az utolsó permutáció volt.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]"
    },
    "instruction_bertscore": {
      "sq": "0.9914449894888273",
      "hy": "0.986233325551234",
      "bn": "0.9651542722550496",
      "bg": "0.9820742040027445",
      "zh": "0.9793229745950303",
      "fr": "0.9876926629606972",
      "de": "0.9881729512220396",
      "ha": "0.9829451982235824",
      "hi": "0.9897578230323171",
      "hu": "0.9827678212933183"
    },
    "level": "middle",
    "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()",
    "entry_point": "next_permutation",
    "signature": "def next_permutation(perm: list) -> bool:",
    "docstring": {
      "en": "\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    ",
      "sq": "\n    Transformon permutimin e dhënë në permutimin e radhës në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek \n    dhe e ndërron atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj kthen \n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit \n    (në rend zbritës), funksioni kthen False, duke treguar se nuk është e mundur një permutim tjetër.\n    \n    Argumentet:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n    \n    Kthen:\n    bool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n    \n    Shembuj:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "hy": "\n    Մուտքային փոխատեղումը փոխակերպում է հաջորդ փոխատեղման դեպի բառարանային կարգով հաջորդը։\n    \n    Ֆունկցիան գտնում է առաջին թիվը վերջից, որը փոքր է իրեն հաջորդող թվից և փոխանակում է այն ամենափոքր թվի հետ, որը մեծ է և գալիս է դրանից հետո։ Այնուհետև այն շրջում է թվերի կարգը սկզբնական առաջին փոքր թվից հետո։ Եթե մուտքը վերջին փոխատեղումն է (նվազող կարգով), ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխատեղումը հնարավոր չէ։\n    \n    Պարամետրեր:\n    perm (list): Ցուցակ ամբողջ թվերի, որոնք ներկայացնում են ընթացիկ փոխատեղումը։\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխատեղումը հաջողությամբ փոխակերպվել է, False, եթե դա վերջին փոխատեղումն էր։\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "bn": "\n    ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n    \n    ফাংশনটি শেষ থেকে প্রথম সংখ্যা খুঁজে বের করে যা তার পরবর্তী সংখ্যার চেয়ে ছোট এবং \n    এটি তার পরবর্তী এবং বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার \n    পরবর্তী সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় (অবতরণ ক্রমে), \n    ফাংশনটি False ফেরত দেয়, যা নির্দেশ করে যে কোনো পরবর্তী পারমুটেশন সম্ভব নয়।\n    \n    Args:\n    perm (list): বর্তমান পারমুটেশন প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n    \n    Returns:\n    bool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ পারমুটেশন হয় তবে False।\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "bg": "\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число, и го разменя с най-малкото число, което е по-голямо и идва след него. След това обръща реда на числата след първоначалното по-малко число. Ако входът е последната пермутация (в низходящ ред), функцията връща False, което показва, че няма възможна следваща пермутация.\n    \n    Аргументи:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Връща:\n    bool: True, ако пермутацията е успешно преобразувана, False, ако е последната пермутация.\n    \n    Примери:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "zh": "\n    将输入排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个比后面的数字小的数字，并将其与后面比它大的最小数字交换。\n    然后反转原始第一个较小数字之后的数字顺序。\n    如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列。\n    \n    参数:\n    perm (list): 表示当前排列的整数列表。\n    \n    返回:\n    bool: 如果排列成功转换则为 True，如果是最后一个排列则为 False。\n    \n    示例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "fr": "\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation \n    (en ordre décroissant), la fonction retourne False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Returns:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "de": "\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl von hinten, die kleiner ist als die folgende Zahl, \n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die \n    Reihenfolge der Zahlen nach der ursprünglich kleineren Zahl um. Wenn die Eingabe die letzte \n    Permutation (in absteigender Reihenfolge) ist, gibt die Funktion False zurück, was anzeigt, \n    dass keine nächste Permutation möglich ist.\n    \n    Args:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Returns:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "ha": "\n    Canza shigarwar permutation zuwa permutation na gaba a cikin tsarin lexicographic.\n    \n    Aikin yana nemo lambar farko daga ƙarshe wadda ta fi ƙarama fiye da lambar da ke biye da ita \n    kuma yana musanya ta da ƙaramin lamba wadda ta fi girma kuma tana zuwa bayan ta. Sannan yana juyawa \n    tsarin lambobi bayan lambar farko mafi ƙarama ta asali. Idan shigarwar ita ce permutation na ƙarshe \n    (a cikin tsarin saukowa), aikin yana dawo da Karya, yana nuna babu wani permutation na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobi masu wakiltar permutation na yanzu.\n    \n    Returns:\n    bool: Gaskiya idan an sami nasarar canza permutation, Karya idan permutation na ƙarshe ne.\n    \n    Misalai:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "hi": "\n    इनपुट क्रमचय को शब्दकोश क्रम में अगले क्रमचय में बदलता है।\n    \n    फ़ंक्शन अंत से पहला ऐसा नंबर ढूंढता है जो उसके बाद आने वाले नंबर से छोटा हो \n    और उसे उसके बाद आने वाले सबसे छोटे बड़े नंबर के साथ बदल देता है। फिर यह \n    मूल पहले छोटे नंबर के बाद के नंबरों के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, यह दर्शाता है कि कोई अगला क्रमचय संभव नहीं है।\n    \n    तर्क:\n    perm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n    \n    लौटाता है:\n    bool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n    \n    उदाहरण:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]",
      "hu": "\n    Az input permutációt átalakítja a következő lekszikografikus sorrendű permutációvá.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám, \n    és kicseréli a legkisebb, de nála nagyobb számmal, amely utána következik. Ezután megfordítja \n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input az utolsó permutáció \n    (csökkenő sorrendben), a függvény False-t ad vissza, jelezve, hogy nincs lehetséges következő permutáció.\n    \n    Paraméterek:\n    perm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n    \n    Visszatérési érték:\n    bool: True, ha a permutáció sikeresen átalakult, False, ha az utolsó permutáció volt.\n    \n    Példák:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]"
    },
    "docstring_bertscore": {
      "sq": "0.9846246180952324",
      "hy": "0.9689022289147968",
      "bn": "0.96270913226451",
      "bg": "0.9835551921237405",
      "zh": "0.9669083771499687",
      "fr": "0.9857427085100778",
      "de": "0.9859848389445593",
      "ha": "0.9722092261286467",
      "hi": "0.9755192027982121",
      "hu": "0.9731076313420676"
    }
  },
  {
    "task_id": "Python/44",
    "prompt": {
      "en": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "sq": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pas ndjekjes së planit të saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "hy": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Հաշվարկում է գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում՝\n    իր մայրիկի հետ խնայողությունների պլանին հետևելուց հետո։ Ամեն ամիս նա կարող է\n    իր գրպանի գումարից (300 ամսական) խնայել 100-ի բազմապատիկներ, եթե կանխատեսում է,\n    որ ծախսերից հետո առնվազն 100 միավոր կմնա։ Խնայված գումարը կստանա 20% տոկոսադրույք\n    տարվա վերջում։\n\n    Պարամետրեր:\n    budgets (List[int]): 12 ամբողջ թվերի ցուցակ, որը ներկայացնում է Ջինջինի ամսական բյուջեն։\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում՝ տոկոսադրույքից հետո։\n         Եթե Ջինջինը որևէ ամսում գումարից դուրս է գալիս, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարանիշն է)։\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "bn": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    বছরের শেষে জিনজিনের কত টাকা থাকবে তা গণনা করে\n    তার মায়ের সাথে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পরে। প্রতি মাসে, সে তার পকেটের টাকা থেকে\n    (প্রতি মাসে 300) 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে পূর্বাভাস দেয় যে খরচের পরে অন্তত 100 ইউনিট অবশিষ্ট থাকবে। \n    সঞ্চিত অর্থ বছরের শেষে 20% সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): জিনজিনের মাসিক বাজেটের প্রতিনিধিত্বকারী 12টি পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: বছরের শেষে সুদের পরে জিনজিনের মোট অর্থের পরিমাণ।\n         যদি জিনজিন কোনো মাসে অর্থের বাইরে চলে যায়, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) ফেরত দেয়।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "bg": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    след като следва плана си за спестявания с майка си. Всеки месец тя може да спести\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици, останали след разходите. Спестените пари ще получат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "zh": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    计算金金在年底按照她和妈妈的储蓄计划后将拥有的总金额。\n    每个月，如果她预测在支出后至少剩余100单位，她可以从她的零花钱中（每月300）储蓄100的倍数。\n    储蓄的钱将在年底获得20%的利息。\n\n    参数:\n    budgets (List[int]): 一个包含12个整数的列表，表示金金每月的预算。\n\n    返回:\n    int: 年底金金在利息后的总金额。\n         如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n    示例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "fr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut\n    économiser des multiples de 100 de son argent de poche (300 par mois) si elle prévoit\n    d'avoir au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Retourne:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après les intérêts.\n         Si Jinjin manque d'argent à un moment donné du mois, retourne la valeur négative\n         de ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "de": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie \n    voraussagt, dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben. \n    Das gesparte Geld wird am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabewert:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem bestimmten Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "ha": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyarta tare da mahaifiyarta. Kowanne wata, za ta iya ajiye\n    ninki na 100 daga kuɗin aljihunta (300 a kowane wata) idan ta yi hasashen samun\n    a kalla raka'a 100 da suka rage bayan kashe-kashe. Kuɗin da aka ajiye zai samu\n    riba ta kashi 20% a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Komawa:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowanne wata, za a mayar da ƙimar watan nan a matsayin\n         ƙima mara kyau (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "hi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    वर्ष के अंत तक जिनजिन के पास कुल कितनी राशि होगी की गणना करता है\n    अपनी माँ के साथ उसकी बचत योजना का पालन करने के बाद। प्रत्येक महीने, वह\n    अपने पॉकेट मनी (प्रति माह 300) से 100 के गुणक बचा सकती है यदि वह अनुमान लगाती है कि\n    खर्चों के बाद कम से कम 100 यूनिट शेष रहेंगे। बचाई गई राशि को वर्ष के अंत में 20%\n    ब्याज मिलेगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): जिनजिन के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: वर्ष के अंत में ब्याज के बाद जिनजिन के पास कुल राशि होगी।\n         यदि जिनजिन किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का नकारात्मक मान लौटाता है (-X, जहाँ X महीने का नंबर है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\"",
      "hu": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére, miután követi\n    a megtakarítási tervét az anyukájával. Minden hónapban 100 többszöröseit\n    tudja megtakarítani a zsebpénzéből (300 havonta), ha előre látja, hogy\n    legalább 100 egység marad a kiadások után. A megtakarított pénz az év\n    végén 20% kamatot kap.\n\n    Paraméterek:\n    budgets (List[int]): Egy lista, amely 12 egész számot tartalmaz, Jinjin havi költségvetését.\n\n    Visszatér:\n    int: Az összeg, amivel Jinjin az év végén rendelkezni fog a kamatok után.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap\n         negatív értékével tér vissza (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9847980224178758",
      "hy": "0.9715436157217988",
      "bn": "0.9809934560995336",
      "bg": "0.9849267349047864",
      "zh": "0.9643031410723151",
      "fr": "0.9807304694750434",
      "de": "0.9734353714707751",
      "ha": "0.9714609854832883",
      "hi": "0.9791845292194489",
      "hu": "0.9615620418140336"
    },
    "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money",
    "instruction": {
      "en": "Write a python function 'def jinjin_savings_plan(budgets: List[int]) -> int:' to solve the following problem:\n\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    ",
      "sq": "Shkruani një funksion python 'def jinjin_savings_plan(budgets: List[int]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pasi të ndjekë planin e saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon se do të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "hy": "Պայթոն ֆունկցիա 'def jinjin_savings_plan(budgets: List[int]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկում է գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում\n    իր մայրիկի հետ խնայողությունների պլանին հետևելուց հետո: Ամեն ամիս, նա կարող է խնայել\n    100-ի բազմապատիկներ իր գրպանի գումարից (300 ամսական), եթե կանխատեսում է, որ\n    ծախսերից հետո առնվազն 100 միավոր կմնա: Խնայված գումարը կստանա 20%\n    տոկոսադրույք տարվա վերջում:\n\n    Պարամետրեր:\n    budgets (List[int]): 12 ամբողջ թվերի ցուցակ, որը ներկայացնում է Ջինջինի ամսական բյուջեն:\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում տոկոսադրույքից հետո:\n         Եթե Ջինջինը որևէ ամսում գումարից դուրս է գալիս, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարանիշն է):\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "bn": "একটি পাইথন ফাংশন 'def jinjin_savings_plan(budgets: List[int]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    জিনজিন তার মায়ের সাথে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পরে বছরের শেষে তার কাছে মোট কত টাকা থাকবে তা গণনা করে। \n    প্রতিটি মাসে, সে তার পকেট মানি (প্রতি মাসে 300) থেকে 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে পূর্বাভাস দেয় যে \n    খরচের পরে অন্তত 100 ইউনিট অবশিষ্ট থাকবে। সঞ্চিত অর্থ বছরের শেষে 20% সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): জিনজিনের মাসিক বাজেটের প্রতিনিধিত্বকারী 12টি পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্ন:\n    int: বছরের শেষে সুদের পরে জিনজিনের কাছে মোট কত টাকা থাকবে।\n         যদি জিনজিন কোনো নির্দিষ্ট মাসে টাকা শেষ হয়ে যায়, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) ফেরত দেয়।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "bg": "Напишете Python функция 'def jinjin_savings_plan(budgets: List[int]) -> int:' за решаване на следния проблем:\n\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    след като следва своя план за спестявания с майка си. Всеки месец тя може да спестява\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици, оставащи след разходите. Спестените пари ще натрупат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "zh": "编写一个Python函数 'def jinjin_savings_plan(budgets: List[int]) -> int:' 来解决以下问题：\n\n    计算Jinjin在年底时根据她和她母亲的储蓄计划将拥有的总金额。每个月，如果她预计在支出后至少剩余100单位，她可以从她的零用钱（每月300）中储蓄100的倍数。储蓄的钱将在年底获得20%的利息。\n\n    参数:\n    budgets (List[int]): 一个包含12个整数的列表，表示Jinjin的每月预算。\n\n    返回:\n    int: Jinjin在年底获得利息后的总金额。\n         如果Jinjin在任何一个月用完了钱，返回该月的负值 (-X，其中X是月份编号)。\n\n    示例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "fr": "Écrivez une fonction python 'def jinjin_savings_plan(budgets: List[int]) -> int:' pour résoudre le problème suivant :\n\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser\n    des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir\n    au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Renvoie:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après intérêts.\n         Si Jinjin manque d'argent à un mois donné, renvoie la valeur négative de\n         ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "de": "Schreiben Sie eine Python-Funktion 'def jinjin_savings_plan(budgets: List[int]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie vorhersieht,\n    dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben. Das gesparte Geld wird\n    am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabewert:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem bestimmten Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "ha": "Rubuta wani aikin python 'def jinjin_savings_plan(budgets: List[int]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyar kuɗinta tare da mahaifiyarta. Kowanne wata, za ta iya ajiye\n    sau na 100 daga aljihun kuɗinta (300 a kowane wata) idan ta hango cewa za ta rage\n    aƙalla raka'a 100 bayan kashe-kashe. Kuɗin da aka ajiye zai samu riba ta 20%\n    a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Mayarwa:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowanne wata, za ta mayar da ƙimar\n         wannan watan a matsayin mummunan adadi (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "hi": "एक पायथन फ़ंक्शन 'def jinjin_savings_plan(budgets: List[int]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    वर्ष के अंत तक जिंजिन के पास कुल कितनी राशि होगी, यह उसकी बचत योजना का पालन करने के बाद \n    उसकी माँ के साथ गणना करता है। प्रत्येक महीने, वह अपनी पॉकेट मनी (प्रति माह 300) से \n    100 के गुणांक बचा सकती है यदि वह अनुमान लगाती है कि खर्चों के बाद कम से कम 100 इकाइयाँ \n    शेष रहेंगी। बचाई गई राशि को वर्ष के अंत में 20% ब्याज मिलेगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): जिंजिन के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की एक सूची।\n\n    लौटाता है:\n    int: वर्ष के अंत में ब्याज के बाद जिंजिन के पास कुल कितनी राशि होगी।\n         यदि जिंजिन किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का नकारात्मक \n         मान लौटाता है (-X, जहाँ X महीने का नंबर है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "hu": "Írj egy python függvényt 'def jinjin_savings_plan(budgets: List[int]) -> int:' a következő probléma megoldására:\n\n    Kiszámítja a teljes pénzösszeget, amivel Jinjin az év végére rendelkezni fog,\n    miután követte a megtakarítási tervét az anyjával. Minden hónapban megtakaríthat\n    100-as többszöröseit a zsebpénzéből (300 havonta), ha előre látja, hogy a kiadások után\n    legalább 100 egység marad. A megtakarított pénz az év végén 20%-os\n    kamatot fog kapni.\n\n    Paraméterek:\n    budgets (List[int]): Egy lista, amely 12 egész számot tartalmaz Jinjin havi költségvetéséről.\n\n    Visszatérési érték:\n    int: A teljes pénzösszeg, amivel Jinjin az év végén rendelkezni fog a kamatok után.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap negatív értékét adja vissza\n         (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580"
    },
    "instruction_bertscore": {
      "sq": "0.9891384935042502",
      "hy": "0.9828129103898132",
      "bn": "0.9822813754901638",
      "bg": "0.9885763695259215",
      "zh": "0.9551508490053705",
      "fr": "0.988744212197896",
      "de": "0.981712696709261",
      "ha": "0.9514873102575631",
      "hi": "0.9796540914402153",
      "hu": "0.9681955020190748"
    },
    "level": "middle",
    "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()",
    "entry_point": "jinjin_savings_plan",
    "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:",
    "docstring": {
      "en": "\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580\n    ",
      "sq": "\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pasi të ndjekë planin e saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "hy": "\n    Հաշվում է գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում\n    իր խնայողությունների պլանը մոր հետ հետևելուց հետո: Ամեն ամիս նա կարող է խնայել\n    100-ի բազմապատիկներ իր գրպանի գումարից (300 ամսական), եթե կանխատեսում է, որ կունենա\n    առնվազն 100 միավոր մնացորդ ծախսերից հետո: Խնայված գումարը կստանա 20%\n    տոկոսադրույք տարվա վերջում:\n\n    Պարամետրեր:\n    budgets (List[int]): 12 ամբողջ թվերի ցուցակ, որը ներկայացնում է Ջինջինի ամսական բյուջեն:\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում տոկոսադրույքից հետո:\n         Եթե Ջինջինը որևէ ամսում գումարը սպառի, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարանիշն է):\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "bn": "\n    বছরের শেষে জিনজিন তার সঞ্চয় পরিকল্পনা অনুসরণ করে তার মায়ের সাথে কত টাকা থাকবে তা গণনা করে।\n    প্রতি মাসে, সে তার পকেট মানি (প্রতি মাসে 300) থেকে 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে পূর্বাভাস দেয় যে খরচের পরে কমপক্ষে 100 ইউনিট অবশিষ্ট থাকবে। সঞ্চিত অর্থ বছরের শেষে 20% সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): জিনজিনের মাসিক বাজেট উপস্থাপনকারী 12টি পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: বছরের শেষে সুদের পরে জিনজিনের মোট অর্থের পরিমাণ।\n         যদি জিনজিন কোনো মাসে অর্থ শেষ করে ফেলে, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) রিটার্ন করে।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "bg": "\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    следвайки нейния план за спестявания с майка си. Всеки месец тя може да спести\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици оставащи след разходите. Спестените пари ще натрупат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "zh": "\n    计算金金在年末根据她和母亲的储蓄计划将拥有的总金额。每个月，如果她预测在支出后至少剩余100单位，她可以从她的零用钱（每月300）中储蓄100的倍数。储蓄的钱将在年末获得20%的利息。\n\n    参数:\n    budgets (List[int]): 一个包含12个整数的列表，表示金金每月的预算。\n\n    返回:\n    int: 金金在年末加上利息后的总金额。\n         如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n    示例:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "fr": "\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser\n    des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir\n    au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Retourne:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après les intérêts.\n         Si Jinjin manque d'argent à un moment donné du mois, retourne la valeur négative\n         de ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "de": "\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie vorhersagt,\n    dass sie nach den Ausgaben mindestens 100 Einheiten übrig hat. Das gesparte Geld\n    wird am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabe:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem beliebigen Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "ha": "\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyar kuɗi tare da mahaifiyarta. Kowanne wata, za ta iya ajiye\n    sau na 100 daga aljihun kuɗinta (300 a kowane wata) idan ta hango samun\n    aƙalla raka'a 100 da suka rage bayan kashe kuɗi. Kuɗin da aka ajiye zai samu riba\n    na 20% a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Returns:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowane wata, za a dawo da ƙimar da ta zama\n         mara kyau na wannan watan (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "hi": "\n    वर्ष के अंत तक Jinjin के पास कुल कितनी धनराशि होगी, यह उसकी बचत योजना का पालन करने के बाद पता चलता है।\n    प्रत्येक माह, वह अपनी पॉकेट मनी (प्रति माह 300) से 100 के गुणक बचा सकती है यदि वह खर्चों के बाद कम से कम 100 इकाइयाँ बचने की भविष्यवाणी करती है। \n    बचाई गई धनराशि पर वर्ष के अंत में 20% ब्याज मिलेगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): Jinjin के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: वर्ष के अंत में ब्याज के बाद Jinjin के पास कुल धनराशि।\n         यदि किसी भी माह में Jinjin के पास धन समाप्त हो जाता है, तो उस माह का ऋणात्मक मान लौटाता है (-X, जहाँ X माह संख्या है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580",
      "hu": "\n    Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére, miután követi az anyjával\n    közösen kidolgozott megtakarítási tervét. Minden hónapban 100 többszöröseit tudja\n    megtakarítani a zsebpénzéből (havonta 300), ha előre látja, hogy legalább 100 egység\n    marad a kiadások után. A megtakarított pénz az év végén 20% kamatot kap.\n\n    Paraméterek:\n    budgets (List[int]): Egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelöli.\n\n    Visszatér:\n    int: Az év végén Jinjin összes pénze a kamat után.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor visszatér a hónap negatív értékével\n         (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580"
    },
    "docstring_bertscore": {
      "sq": "0.9910582561369524",
      "hy": "0.9753334833919445",
      "bn": "0.9700934153098631",
      "bg": "0.9829777736060722",
      "zh": "0.952807805030683",
      "fr": "0.9752176818798012",
      "de": "0.9734480838151613",
      "ha": "0.9402412553441297",
      "hi": "0.9701438674266459",
      "hu": "0.9554855411974144"
    }
  },
  {
    "task_id": "Python/45",
    "prompt": {
      "en": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "sq": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë prioriteti) për të siguruar që grumbujt më të vegjël të bashkohen së pari,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrin e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "hy": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Հաշվում է մրգերի մի քանի կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միացման արժեքը հավասար է դրանց քաշերի գումարին: Ֆունկցիան օգտագործում է\n    ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը\n    առաջինն են միացվում՝ նվազագույնի հասցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգի քանակը:\n\n    Վերադարձնում է:\n    int: Մրգերի բոլոր կույտերը միացնելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "bn": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    একক হিপে একাধিক ফলের হিপ একত্রিত করার জন্য ন্যূনতম মোট খরচ গণনা করে।\n    দুটি হিপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হিপ (অগ্রাধিকার কিউ) সহ নিশ্চিত করে যে ছোট হিপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমিয়ে দেয়।\n\n    প্যারামিটার:\n    fruit_counts (List[int]): প্রতিটি ধরণের ফলের গণনা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের হিপ একত্রিত করার জন্য প্রয়োজনীয় ন্যূনতম মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "bg": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Изчислява минималната обща цена за сливане на множество купчини плодове в една купчина.\n    Цената за сливане на две купчини е равна на сумата от техните тегла. Функцията използва\n    жаден алгоритъм с минимална купчина (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плод.\n\n    Връща:\n    int: Минималната обща цена, необходима за сливане на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "zh": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用带有最小堆（优先队列）的贪心算法，\n    以确保首先合并最小的堆，从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "fr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas min (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant le nombre de chaque type de fruit.\n\n    Retourne:\n    int: Le coût total minimum requis pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "de": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten\n    Haufen zuerst verschmolzen werden, wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl der Früchte jeder Art darstellen.\n\n    Rückgabe:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Haufen von Früchten zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "ha": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin jimillar kuɗi don haɗa ɗimbin 'ya'yan itatuwa zuwa taru guda.\n    Farashin haɗa taru biyu yana daidai da jimillar nauyinsu. Aikin yana amfani da\n    dabarar kwaikwayo tare da ƙaramin taru (layin fifiko) don tabbatar da cewa an haɗa ƙananan taru da farko,\n    yana rage jimillar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowane nau'in 'ya'yan itace.\n\n    Returns:\n    int: Mafi ƙarancin jimillar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "hi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    कई ढेरों फलों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। यह फ़ंक्शन सुनिश्चित करने के लिए\n    एक लालची एल्गोरिदम के साथ एक मिन-हीप (प्राथमिकता कतार) का उपयोग करता है कि सबसे छोटे ढेर पहले मिलाए जाएं,\n    जिससे कुल लागत न्यूनतम हो।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती का प्रतिनिधित्व करने वाली पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\"",
      "hu": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Kiszámítja a minimális összköltséget több gyümölcshalom egyetlen halommá történő egyesítéséhez.\n    Két halom egyesítésének költsége egyenlő a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-halommal (prioritási sor), hogy biztosítsa a legkisebb halmok elsőként történő\n    egyesítését, minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számokat tartalmazó lista, amely az egyes gyümölcstípusok számát jelöli.\n\n    Visszatér:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalom egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9678675632599861",
      "hy": "0.9574923039370098",
      "bn": "0.9809207573800749",
      "bg": "0.9682497281130973",
      "zh": "0.9618746860337826",
      "fr": "0.9639807639638954",
      "de": "0.9647719087715574",
      "ha": "0.9431619164668668",
      "hi": "0.965783533302168",
      "hu": "0.9714294032527038"
    },
    "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost",
    "instruction": {
      "en": "Write a python function 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' to solve the following problem:\n\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    ",
      "sq": "Shkruani një funksion python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë me përparësi) për të siguruar që grumbujt më të vegjël të bashkohen të parët,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrin e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "hy": "Պայթոն ֆունկցիա 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է մրգերի բազմաթիվ կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միացման արժեքը հավասար է նրանց քաշերի գումարին: Ֆունկցիան օգտագործում է\n    ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը\n    առաջինը միացվեն՝ նվազեցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Թվերի ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգերի քանակները:\n\n    Վերադարձնում է:\n    int: Մրգերի բոլոր կույտերը միացնելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "bn": "একটি পাইথন ফাংশন 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    একাধিক ফলের স্তূপকে একক স্তূপে একত্রিত করার জন্য সর্বনিম্ন মোট খরচ গণনা করে।\n    দুটি স্তূপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হীপ (প্রায়োরিটি কিউ) সহ নিশ্চিত করে যে ছোট স্তূপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমায়।\n\n    প্যারামিটার:\n    fruit_counts (List[int]): প্রতিটি ধরণের ফলের গণনা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের স্তূপ একত্রিত করার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "bg": "Напишете Python функция 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:', за да решите следния проблем:\n\n    Изчислява минималната обща цена за обединяване на множество купчини плодове в една единствена купчина.\n    Цената за обединяване на две купчини е равна на сумата от техните тегла. Функцията използва\n    алчен алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се обединяват първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плодове.\n\n    Връща:\n    int: Минималната обща цена, необходима за обединяване на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "zh": "编写一个 Python 函数 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' 来解决以下问题：\n\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用\n    带有最小堆（优先队列）的贪心算法来确保首先合并最小的堆，\n    从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300",
      "fr": "Écrivez une fonction python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' pour résoudre le problème suivant :\n\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas minimum (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant le nombre de chaque type de fruit.\n\n    Renvoie:\n    int: Le coût total minimum nécessaire pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "de": "Schreiben Sie eine Python-Funktion 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:', um das folgende Problem zu lösen:\n\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst verschmolzen werden,\n    wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl jeder Fruchtart darstellen.\n\n    Rückgabewert:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Fruchthaufen zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "ha": "Rubuta wani aikin python 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' don warware matsalar mai zuwa:\n\n    Lissafi mafi ƙarancin jimlar kuɗi don haɗa tarin 'ya'yan itatuwa masu yawa zuwa tarin guda.\n    Farashin haɗa tarin biyu yayi daidai da jimlar nauyinsu. Aikin yana amfani\n    da dabarar kwaikwayo tare da ƙaramin tarin (priority queue) don tabbatar da cewa an haɗa ƙananan tarin farko,\n    rage jimlar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowane nau'in 'ya'yan itace.\n\n    Yana dawowa:\n    int: Mafi ƙarancin jimlar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "hi": "एक पायथन फ़ंक्शन 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    फलों के कई ढेरों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करें।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। फ़ंक्शन एक लालची एल्गोरिदम का उपयोग करता है\n    जिसमें एक मिन-हीप (प्राथमिकता कतार) होती है ताकि यह सुनिश्चित किया जा सके कि सबसे छोटे ढेर पहले मिलाए जाएं,\n    जिससे कुल लागत कम से कम हो।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची।\n\n    लौटाता है:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "hu": "Írj egy python függvényt 'def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:' a következő probléma megoldására:\n\n    Kiszámítja a minimális összköltséget, hogy több gyümölcs halmot egyetlen halommá egyesítsen.\n    Két halom egyesítésének költsége egyenlő a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-halommal (prioritási sor), hogy biztosítsa, hogy a legkisebb halmok kerüljenek először egyesítésre,\n    minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számok listája, amely az egyes gyümölcsfajták számát képviseli.\n\n    Visszatér:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalom egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 ."
    },
    "instruction_bertscore": {
      "sq": "0.9688636946208761",
      "hy": "0.9681253854945694",
      "bn": "0.9600909852120892",
      "bg": "0.9661233898841188",
      "zh": "0.9599267178869734",
      "fr": "0.9710462452476875",
      "de": "0.9616107062573872",
      "ha": "0.9566173371085511",
      "hi": "0.9722290891667502",
      "hu": "0.9677460014667928"
    },
    "level": "middle",
    "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()",
    "entry_point": "minimum_cost_to_merge_fruits",
    "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:",
    "docstring": {
      "en": "\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .\n    ",
      "sq": "\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë përparësie) për të siguruar që grumbujt më të vegjël të bashkohen të parët,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrat e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e nevojshme për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "hy": "\n    Հաշվում է մի քանի պտուղների կույտերը մեկ կույտի մեջ միավորելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միավորման արժեքը հավասար է նրանց քաշերի գումարին: Ֆունկցիան օգտագործում է ագահ ալգորիթմ \n    մին-կույտով (նախապատվության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը առաջինը միավորվեն՝ \n    նվազագույնի հասցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի պտղի քանակները:\n\n    Վերադարձնում է:\n    int: Նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր պտուղների կույտերը միավորելու համար:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "bn": "\n    একক হীপে একাধিক ফলের হীপ একত্রিত করার জন্য ন্যূনতম মোট খরচ গণনা করে।\n    দুটি হীপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হীপ (অগ্রাধিকার সারি) সহ, যাতে ছোট হীপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমানো যায়।\n\n    প্যারামিটারসমূহ:\n    fruit_counts (List[int]): প্রতিটি প্রকারের ফলের সংখ্যা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের হীপ একত্রিত করার জন্য প্রয়োজনীয় ন্যূনতম মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "bg": "\n    Изчислява минималната обща цена за сливане на множество купчини плодове в една купчина.\n    Цената за сливане на две купчини е равна на сумата от техните тегла. Функцията използва\n    жаден алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плодове.\n\n    Връща:\n    int: Минималната обща цена, необходима за сливане на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "zh": "\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用贪心算法和最小堆（优先队列）来确保首先合并最小的堆，从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "fr": "\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas min (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant le nombre de chaque type de fruit.\n\n    Retourne:\n    int: Le coût total minimum nécessaire pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "de": "\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst verschmolzen werden,\n    wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl jeder Fruchtart darstellen.\n\n    Rückgabe:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Haufen von Früchten zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "ha": "\n    Lissafa mafi ƙarancin jimillar kuɗi don haɗa tarin 'ya'yan itatuwa masu yawa zuwa tarin guda.\n    Farashin haɗa tarin biyu yana daidai da jimillar nauyinsu. Aikin yana amfani da\n    dabarar kwaikwayo tare da ƙaramin tarin (min-heap) don tabbatar da cewa an fara haɗa ƙananan tarin,\n    yana rage jimillar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowane nau'in 'ya'yan itace.\n\n    Returns:\n    int: Mafi ƙarancin jimillar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "hi": "\n    कई ढेरों फलों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। यह फ़ंक्शन\n    एक लालची एल्गोरिदम का उपयोग करता है जिसमें सबसे छोटे ढेर पहले मिलाए जाते हैं,\n    जिससे कुल लागत न्यूनतम हो जाती है।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती को दर्शाने वाली पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 .",
      "hu": "\n    Kiszámítja a minimális összköltséget több gyümölcshalom egyetlen halommá való egyesítéséhez.\n    Két halom egyesítésének költsége megegyezik a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-halommal (prioritási sor) annak biztosítására, hogy a legkisebb halmokat egyesítik először,\n    minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számokat tartalmazó lista, amely a gyümölcsök típusonkénti mennyiségét jelöli.\n\n    Visszatér:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalom egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 ."
    },
    "docstring_bertscore": {
      "sq": "0.9673831037606421",
      "hy": "0.9574795915926235",
      "bn": "0.9688476055600123",
      "bg": "0.9643009561381237",
      "zh": "0.9514428170522112",
      "fr": "0.9666430069609061",
      "de": "0.9606455612359386",
      "ha": "0.9321283960611407",
      "hi": "0.9184693792788956",
      "hu": "0.9589488605211386"
    }
  },
  {
    "task_id": "Python/46",
    "prompt": {
      "en": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"",
      "sq": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Llogarit numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e studentëve\n    rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Args:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Returns:\n    int: Numri minimal i studentëve që duhet të largohen.\n    \"\"\"",
      "hy": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Հաշվել նվազագույն թվով ուսանողներին, որոնք պետք է հեռանան երգչախմբի կազմ ձևավորելու համար։\n    Երգչախմբի կազմը սահմանված է այնպես, որ որոշ դիրքում 'i', ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմի վերջը։\n\n    Արգումենտներ:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ։\n\n    Վերադարձնում է:\n    int: Նվազագույն թվով ուսանողներին, որոնք պետք է հեռանան։\n    \"\"\"",
      "bn": "def minimum_students_to_leave(heights):\n    \"\"\"\n    একটি গায়কদলের গঠন তৈরি করতে ন্যূনতম কতজন ছাত্রকে চলে যেতে হবে তা হিসাব করুন।\n    একটি গায়কদলের গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কিছু অবস্থান 'i' এর জন্য,\n    ছাত্রদের উচ্চতা শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\n    আর্গুমেন্টসমূহ:\n    heights (List[int]): ছাত্রদের উচ্চতার একটি তালিকা।\n\n    রিটার্নস:\n    int: ন্যূনতম কতজন ছাত্রকে চলে যেতে হবে।\n    \"\"\"",
      "bg": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е определена така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Аргументи:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.\n    \"\"\"",
      "zh": "def minimum_students_to_leave(heights):\n    \"\"\"\n    计算需要离开的最少学生人数以形成合唱队形。\n    合唱队形定义为，对于某个位置 'i'，学生的身高从开始到 'i' 增加，并从 'i' 到队形结束减少。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最少学生人数。\n    \"\"\"",
      "fr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculer le nombre minimum d'élèves qui doivent partir pour former une chorale.\n    Une formation de chorale est définie de telle sorte que pour une position 'i', les hauteurs des élèves\n    augmentent du début à 'i' et diminuent de 'i' à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des élèves.\n\n    Returns:\n    int: Le nombre minimum d'élèves qui doivent partir.\n    \"\"\"",
      "de": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Argumente:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.\n    \"\"\"",
      "ha": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Lissafa mafi ƙarancin yawan ɗaliban da ake buƙata su bar don samar da tsarin ƙungiya.\n    Ana ayyana tsarin ƙungiya ta yadda don wasu matsayi 'i', tsayin ɗalibai\n    yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin ɗalibai.\n\n    Returns:\n    int: Mafi ƙarancin yawan ɗaliban da ake buƙata su bar.\n    \"\"\"",
      "hi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    गायक मण्डली गठन बनाने के लिए न्यूनतम कितने छात्रों को छोड़ना होगा, इसकी गणना करें।\n    गायक मण्डली गठन इस प्रकार परिभाषित है कि किसी स्थिति 'i' के लिए, छात्रों की ऊँचाई\n    शुरुआत से 'i' तक बढ़ती है और 'i' से गठन के अंत तक घटती है।\n\n    तर्क:\n    heights (List[int]): छात्रों की ऊँचाई की सूची।\n\n    लौटाता है:\n    int: न्यूनतम कितने छात्रों को छोड़ना होगा।\n    \"\"\"",
      "hu": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Számítsa ki a minimális számú diákot, akinek távoznia kell, hogy kórusformációt alkossanak.\n    Egy kórusformáció úgy van meghatározva, hogy egy 'i' pozícióra a diákok magassága\n    növekszik a kezdettől 'i'-ig, majd csökken 'i'-től a formáció végéig.\n\n    Paraméterek:\n    heights (List[int]): A diákok magasságának listája.\n\n    Visszatér:\n    int: A minimális számú diák, akinek távoznia kell.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9942699107679055",
      "hy": "0.975421873911505",
      "bn": "0.9872119774385929",
      "bg": "0.9901932208275455",
      "zh": "0.9817250117928851",
      "fr": "0.9760298815078527",
      "de": "0.987833690531232",
      "ha": "0.9554066849361434",
      "hi": "0.9731026655825417",
      "hu": "0.9678961660348552"
    },
    "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length",
    "instruction": {
      "en": "Write a python function 'def minimum_students_to_leave(heights):' to solve the following problem:\n\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    ",
      "sq": "Shkruani një funksion Python 'def minimum_students_to_leave(heights):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e studentëve\n    rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Args:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Kthen:\n    int: Numri minimal i studentëve që duhet të largohen.",
      "hy": "Պայթոն ֆունկցիա 'def minimum_students_to_leave(heights):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել նվազագույն ուսանողների քանակը, որոնք պետք է հեռանան, որպեսզի կազմվի երգչախմբի կազմավորում:\n    Երգչախմբի կազմավորումը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմավորման վերջը:\n\n    Արձ:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ:\n\n    Վերադարձնում է:\n    int: Նվազագույն ուսանողների քանակը, որոնք պետք է հեռանան.",
      "bn": "একটি পাইথন ফাংশন 'def minimum_students_to_leave(heights):' লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n    একটি গায়কদলের গঠন তৈরি করতে যে ন্যূনতম সংখ্যক ছাত্রদের চলে যেতে হবে তা গণনা করুন।\n    একটি গায়কদলের গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কিছু অবস্থান 'i' এর জন্য, ছাত্রদের উচ্চতা\n    শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\n    আর্গুমেন্টস:\n    heights (List[int]): ছাত্রদের উচ্চতার একটি তালিকা।\n\n    রিটার্নস:\n    int: যে ন্যূনতম সংখ্যক ছাত্রদের চলে যেতে হবে।",
      "bg": "Напишете функция на Python 'def minimum_students_to_leave(heights):', за да решите следния проблем:\n\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е дефинирана така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Аргументи:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.",
      "zh": "编写一个Python函数 'def minimum_students_to_leave(heights):' 来解决以下问题：\n\n    计算需要离开的最少学生人数以形成合唱队形。\n    合唱队形的定义是，对于某个位置 'i'，学生的身高从开始到 'i' 增加，并从 'i' 到队形的结尾减少。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最少学生人数。",
      "fr": "Écrivez une fonction python 'def minimum_students_to_leave(heights):' pour résoudre le problème suivant :\n\n    Calculer le nombre minimum d'étudiants qui doivent partir pour former une formation de chorale.\n    Une formation de chorale est définie de telle sorte que pour une certaine position 'i', les hauteurs des étudiants\n    augmentent du début à 'i' et diminuent de 'i' à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des étudiants.\n\n    Returns:\n    int: Le nombre minimum d'étudiants qui doivent partir.",
      "de": "Schreiben Sie eine Python-Funktion 'def minimum_students_to_leave(heights):', um das folgende Problem zu lösen:\n\n    Berechnen Sie die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Argumente:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Rückgabe:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.",
      "ha": "Rubuta wani aikin python 'def minimum_students_to_leave(heights):' don warware matsalar mai zuwa:\n\n    Lissafa mafi karancin adadin daliban da ya kamata su bar don kafa tsarin rera waka.\n    An ayyana tsarin rera waka ta yadda a wani matsayi 'i', tsayin dalibai\n    yana karuwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin dalibai.\n\n    Returns:\n    int: Mafi karancin adadin daliban da ya kamata su bar.",
      "hi": "एक पायथन फ़ंक्शन 'def minimum_students_to_leave(heights):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    गायक मंडली की संरचना बनाने के लिए कितने न्यूनतम छात्रों को छोड़ना होगा, इसकी गणना करें।\n    एक गायक मंडली की संरचना इस प्रकार परिभाषित की जाती है कि किसी स्थिति 'i' के लिए, छात्रों की ऊंचाई\n    शुरुआत से 'i' तक बढ़ती है और 'i' से संरचना के अंत तक घटती है।\n\n    तर्क:\n    heights (List[int]): छात्रों की ऊंचाई की एक सूची।\n\n    लौटाता है:\n    int: न्यूनतम छात्रों की संख्या जिन्हें छोड़ना आवश्यक है।",
      "hu": "Írj egy python függvényt 'def minimum_students_to_leave(heights):' a következő probléma megoldására:\n\n    Számítsd ki a minimális számú diákot, akinek távoznia kell, hogy egy kórusformációt alkossanak.\n    Egy kórusformáció úgy van definiálva, hogy egy bizonyos 'i' pozíciónál a diákok magassága\n    növekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a formáció végéig.\n\n    Paraméterek:\n    heights (List[int]): A diákok magasságainak listája.\n\n    Visszatérési érték:\n    int: A minimális számú diák, akinek távoznia kell."
    },
    "instruction_bertscore": {
      "sq": "0.9932316697662362",
      "hy": "0.9921308601945409",
      "bn": "0.9865962232573847",
      "bg": "0.9899163300763829",
      "zh": "0.9694726953691291",
      "fr": "0.9788158712322481",
      "de": "0.9891879524691279",
      "ha": "0.9801909893601527",
      "hi": "0.957965640135016",
      "hu": "0.959025333217837"
    },
    "level": "middle",
    "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()",
    "entry_point": "minimum_students_to_leave",
    "signature": "def minimum_students_to_leave(heights):",
    "docstring": {
      "en": "\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    ",
      "sq": "\n    Llogarit numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e studentëve\n    rriten nga fillimi deri në 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Args:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Returns:\n    int: Numri minimal i studentëve që duhet të largohen.",
      "hy": "\n    Հաշվեք նվազագույն թվով ուսանողներին, ովքեր պետք է հեռանան երգչախմբի կազմավորման համար:\n    Երգչախմբի կազմավորումը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմավորման վերջը:\n\n    Պարամետրեր:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ:\n\n    Վերադարձնում է:\n    int: Նվազագույն թվով ուսանողներ, ովքեր պետք է հեռանան։",
      "bn": "\n    কতজন শিক্ষার্থীকে ছেড়ে দিতে হবে তা গণনা করুন যাতে একটি গায়কদল গঠন করা যায়।\n    একটি গায়কদল গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কোনো অবস্থান 'i' এর জন্য, শিক্ষার্থীদের উচ্চতা শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠন শেষ পর্যন্ত হ্রাস পায়।\n\n    Args:\n    heights (List[int]): শিক্ষার্থীদের উচ্চতার একটি তালিকা।\n\n    Returns:\n    int: ন্যূনতম কতজন শিক্ষার্থীকে ছেড়ে দিতে হবে।",
      "bg": "\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е определена така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Параметри:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.",
      "zh": "\n    计算需要离开的最少学生人数以形成合唱队形。\n    合唱队形被定义为，对于某个位置 'i'，学生的身高从开始到 'i' 增加，并从 'i' 到队形的末尾减少。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最少学生人数。",
      "fr": "\n    Calculer le nombre minimum d'élèves qui doivent partir pour former une chorale.\n    Une formation de chorale est définie de telle sorte que pour une position 'i', les hauteurs des élèves\n    augmentent du début jusqu'à 'i' et diminuent de 'i' jusqu'à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des élèves.\n\n    Returns:\n    int: Le nombre minimum d'élèves qui doivent partir.",
      "de": "\n    Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Args:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Returns:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.",
      "ha": "\n    Lissafa mafi ƙarancin adadin ɗalibai da ya kamata su bar wurin don samar da tsarin rera waka.\n    An ayyana tsarin rera waka ta yadda don wani matsayi 'i', tsayin ɗalibai yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin ɗalibai.\n\n    Returns:\n    int: Mafi ƙarancin adadin ɗalibai da ya kamata su bar wurin.",
      "hi": "\n    न्यूनतम संख्या में छात्रों की गणना करें जिन्हें एक गाना मंडली का गठन करने के लिए छोड़ना होगा। \n    एक गाना मंडली का गठन इस प्रकार परिभाषित किया जाता है कि किसी स्थिति 'i' के लिए, छात्रों की ऊँचाई \n    शुरुआत से 'i' तक बढ़ती है और 'i' से गठन के अंत तक घटती है।\n\n    Args:\n    heights (List[int]): छात्रों की ऊँचाइयों की सूची।\n\n    Returns:\n    int: न्यूनतम संख्या में छात्रों की संख्या जिन्हें छोड़ना होगा।",
      "hu": "\n    Számítsa ki a minimális számú diákot, akinek távoznia kell, hogy kórusformációt alkossanak.\n    Egy kórusformáció úgy van meghatározva, hogy egy 'i' pozíció esetén a diákok magassága\n    növekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a formáció végéig.\n\n    Paraméterek:\n    heights (List[int]): A diákok magasságának listája.\n\n    Visszatér:\n    int: A minimális számú diák, akinek távoznia kell."
    },
    "docstring_bertscore": {
      "sq": "0.9647218539155367",
      "hy": "0.9514517554193578",
      "bn": "0.9442861644235242",
      "bg": "0.9861552638114872",
      "zh": "0.981889676378763",
      "fr": "0.967809960449486",
      "de": "0.9927533678087042",
      "ha": "0.9334192949074865",
      "hi": "0.9519209203793622",
      "hu": "0.977346205042971"
    }
  },
  {
    "task_id": "Python/47",
    "prompt": {
      "en": "def sort_students(student_scores):\n    \"\"\"\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "sq": "def sort_students(student_scores):\n    \"\"\"\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve totale (në zbritje),\n    pastaj sipas pikëve në gjuhën kineze (në zbritje), dhe më në fund sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Args:\n    student_scores (list): Një listë me tufa, ku secila tufë përbëhet nga (numri_i_studentit, pikët_totale, pikët_kineze).\n    \n    Returns:\n    list: Një listë me tufa të renditura sipas rregullave të mësipërme.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "hy": "def sort_students(student_scores):\n    \"\"\"\n    Դասավորում է ուսանողների ցուցակը՝ հիմնված նրանց գնահատականների վրա։ Ուսանողները հիմնականում դասավորվում են ըստ իրենց ընդհանուր գնահատականի (նվազման կարգով),\n    ապա՝ ըստ իրենց չինարեն գնահատականի (նվազման կարգով), և վերջապես՝ ըստ ուսանողի համարի (աճման կարգով)՝ հավասարության դեպքում։\n    \n    Արգումենտներ:\n    student_scores (list): Թվերի ցուցակ, որտեղ յուրաքանչյուր թվային տուփ բաղկացած է (ուսանողի համար, ընդհանուր գնահատական, չինարեն գնահատական)։\n    \n    Վերադարձնում է:\n    list: Թվերի ցուցակ, որը դասավորված է ըստ վերոնշյալ կանոնների։\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "bn": "def sort_students(student_scores):\n    \"\"\"\n    ছাত্রদের স্কোরের ভিত্তিতে একটি তালিকা সাজায়। ছাত্রদের প্রথমে তাদের মোট স্কোর (অবতরণক্রমে) দ্বারা সাজানো হয়,\n    তারপর তাদের চীনা স্কোর (অবতরণক্রমে) দ্বারা, এবং অবশেষে টাই হলে তাদের ছাত্র নম্বর (আরোহণক্রমে) দ্বারা সাজানো হয়।\n    \n    Args:\n    student_scores (list): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n    \n    Returns:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টুপলের একটি তালিকা।\n    \n    উদাহরণ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "bg": "def sort_students(student_scores):\n    \"\"\"\n    Сортира списък от студенти въз основа на техните оценки. Студентите се сортират основно по общия им резултат (в низходящ ред),\n    след това по оценката им по китайски (в низходящ ред), и накрая по номера на студента (във възходящ ред) в случай на равенство.\n    \n    Args:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (номер на студент, общ резултат, оценка по китайски).\n    \n    Returns:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "zh": "def sort_students(student_scores):\n    \"\"\"\n    根据学生的成绩对学生列表进行排序。学生首先根据总成绩（降序）排序，\n    然后根据语文成绩（降序）排序，最后在成绩相同的情况下根据学号（升序）排序。\n    \n    参数:\n    student_scores (list): 一个包含元组的列表，每个元组由 (学号, 总成绩, 语文成绩) 组成。\n    \n    返回:\n    list: 根据上述规则排序的元组列表。\n    \n    示例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "fr": "def sort_students(student_scores):\n    \"\"\"\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "de": "def sort_students(student_scores):\n    \"\"\"\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert,\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n    \n    Args:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (Studentennummer, Gesamtpunktzahl, Chinesisch-Punktzahl) besteht.\n    \n    Returns:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "ha": "def sort_students(student_scores):\n    \"\"\"\n    Tana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimlar maki nasu (daga mafi girma zuwa ƙanana),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙanana), kuma a ƙarshe bisa ga lambar ɗalibi (daga ƙanana zuwa mafi girma) idan aka yi daidai.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimlar_maki, maki_na_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga ƙa'idodin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "hi": "def sort_students(student_scores):\n    \"\"\"\n    छात्रों की सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंकों (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है,\n    फिर उनके चीनी अंकों (अवरोही क्रम में) के आधार पर, और अंत में टाई की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n    \n    Args:\n    student_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    Returns:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\"",
      "hu": "def sort_students(student_scores):\n    \"\"\"\n    Rendez egy listát a diákokról a pontszámaik alapján. A diákokat elsősorban az összpontszámuk szerint (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák számuk szerint (növekvő sorrendben) rendezi döntetlen esetén.\n    \n    Args:\n    student_scores (list): Egy lista, amelyben minden elem egy tuple, amely a következőket tartalmazza: (diák_szám, összpontszám, kínai_pontszám).\n    \n    Returns:\n    list: Egy lista, amely a fenti szabályok szerint rendezett tuple-öket tartalmazza.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9759730732188768",
      "hy": "0.9675799464682476",
      "bn": "0.9712399098691965",
      "bg": "0.9719311435951978",
      "zh": "0.9715368622888436",
      "fr": "0.9974481954948448",
      "de": "0.982367183814771",
      "ha": "0.9590064633316387",
      "hi": "0.9786376997804599",
      "hu": "0.9598482588864646"
    },
    "canonical_solution": "    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students",
    "instruction": {
      "en": "Write a python function 'def sort_students(student_scores):' to solve the following problem:\n\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    ",
      "sq": "Shkruani një funksion python 'def sort_students(student_scores):' për të zgjidhur problemin e mëposhtëm:\n\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve totale (në zbritje),\n    pastaj sipas pikëve në gjuhën kineze (në zbritje), dhe përfundimisht sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Argumentet:\n    student_scores (list): Një listë tuples, ku çdo tuple përbëhet nga (numri_i_studentit, pikët_totale, pikët_kineze).\n    \n    Kthen:\n    list: Një listë tuples e renditur sipas rregullave të mësipërme.\n    \n    Shembuj:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "hy": "Պայթոն ֆունկցիա 'def sort_students(student_scores):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Դասավորում է ուսանողների ցուցակը ըստ նրանց գնահատականների: Ուսանողները դասավորվում են նախ և առաջ ըստ ընդհանուր գնահատականի (նվազման կարգով),\n    ապա ըստ չինարենի գնահատականի (նվազման կարգով), և վերջապես ըստ ուսանողի համարի (աճման կարգով)՝ եթե գնահատականները հավասար են:\n    \n    Արձանագրություններ:\n    student_scores (list): Թվակազմերի ցուցակ, որտեղ յուրաքանչյուր թվակազմ բաղկացած է (ուսանողի համար, ընդհանուր գնահատական, չինարենի գնահատական)։\n    \n    Վերադարձնում է:\n    list: Թվակազմերի ցուցակ, դասավորված ըստ վերը նշված կանոնների:\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "bn": "একটি পাইথন ফাংশন 'def sort_students(student_scores):' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    শিক্ষার্থীদের একটি তালিকা তাদের স্কোরের ভিত্তিতে সাজানো হয়। শিক্ষার্থীদের প্রথমে তাদের মোট স্কোর (অবতরণক্রমে) \n    দ্বারা সাজানো হয়, তারপর তাদের চীনা স্কোর (অবতরণক্রমে), এবং অবশেষে টাই হলে তাদের ছাত্র নম্বর (আরোহণক্রমে) দ্বারা সাজানো হয়।\n    \n    Args:\n    student_scores (list): একটি টাপলগুলির তালিকা, যেখানে প্রতিটি টাপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n    \n    Returns:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টাপলগুলির একটি তালিকা।\n    \n    উদাহরণ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "bg": "Напишете Python функция 'def sort_students(student_scores):' за решаване на следния проблем:\n\n    Сортира списък от ученици въз основа на техните оценки. Учениците се сортират основно по общия им резултат (в низходящ ред),\n    след това по оценката им по китайски (в низходящ ред) и накрая по номера на ученика (във възходящ ред) в случай на равенство.\n    \n    Args:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (номер на ученик, общ резултат, оценка по китайски).\n    \n    Returns:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "zh": "编写一个 Python 函数 'def sort_students(student_scores):' 来解决以下问题：\n\n    根据学生的分数对学生列表进行排序。学生主要根据他们的总分（降序）排序，\n    然后根据他们的语文分数（降序）排序，最后在平分的情况下根据学号（升序）排序。\n    \n    参数：\n    student_scores (list): 一个元组列表，其中每个元组由 (student_number, total_score, Chinese_score) 组成。\n    \n    返回：\n    list: 一个根据上述规则排序的元组列表。\n    \n    示例：\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "fr": "Écrivez une fonction python 'def sort_students(student_scores):' pour résoudre le problème suivant :\n\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Exemples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "de": "Schreiben Sie eine Python-Funktion 'def sort_students(student_scores):', um das folgende Problem zu lösen:\n\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert,\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n    \n    Argumente:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (student_number, total_score, Chinese_score) besteht.\n    \n    Rückgabe:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Beispiele:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\nSchreiben Sie eine Python-Funktion 'def largest_prime_factor(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Finden Sie den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Die Zahl wird als das Produkt von genau zwei verschiedenen Primzahlen angenommen. \n    Die Funktion iteriert durch mögliche Faktoren, beginnend mit dem kleinsten Prim (2), \n    und prüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion \n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird \n    als größter Primfaktor zurückgegeben.\n    \n    Argumente:\n    n (int): Die positive ganze Zahl, die faktorisiert werden soll, die das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Rückgabe:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Beispiele:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5",
      "ha": "Rubuta wani aikin python 'def sort_students(student_scores):' don warware matsalar mai zuwa:\n\n    Yana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki nasu (daga mafi girma zuwa ƙasa),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga ƙasa zuwa mafi girma) idan akwai daidaituwa.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimillar_maki, maki_na_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga dokokin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "hi": "एक पायथन फ़ंक्शन 'def sort_students(student_scores):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    छात्रों की सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंक (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है,\n    फिर उनके चीनी अंक (अवरोही क्रम में), और अंत में टाई की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n    \n    तर्क:\n    student_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    लौटाता है:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n    \n    उदाहरण:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "hu": "Írj egy python függvényt 'def sort_students(student_scores):' a következő probléma megoldására:\n\n    Rendez egy listát a diákokról a pontszámaik alapján. A diákok elsősorban az összpontszámuk szerint (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), végül pedig a diák számuk szerint (növekvő sorrendben) kerülnek rendezésre, ha azonos pontszámuk van.\n    \n    Args:\n    student_scores (list): Egy listája a tuple-öknek, ahol minden tuple (student_number, total_score, Chinese_score) elemekből áll.\n    \n    Returns:\n    list: Egy listája a tuple-öknek, a fenti szabályok szerint rendezve.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]"
    },
    "instruction_bertscore": {
      "sq": "0.9766978754792731",
      "hy": "0.955842479992134",
      "bn": "0.977682089017301",
      "bg": "0.9791434127305747",
      "zh": "0.9860247636511473",
      "fr": "0.9941684106431967",
      "de": "0.8574564823971711",
      "ha": "0.9610742055982119",
      "hi": "0.9800422152047575",
      "hu": "0.9684277009345045"
    },
    "level": "easy",
    "test": "def test_sort_students():\n    # Test case 1\n    input_scores = [(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)]\n    expected_output = [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 1 failed\"\n\n    # Test case 2\n    input_scores = [(1, 258, 80), (2, 264, 88), (3, 258, 90), (4, 244, 87), (5, 258, 78), (6, 264, 88), (7, 220, 67), (8, 265, 78)]\n    expected_output = [(8, 265, 78), (2, 264, 88), (6, 264, 88), (3, 258, 90), (1, 258, 80), (5, 258, 78), (4, 244, 87), (7, 220, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 2 failed\"\n\n    # Test case 3\n    input_scores = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    expected_output = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    assert sort_students(input_scores) == expected_output, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_sort_students()",
    "entry_point": "sort_students",
    "signature": "def sort_students(student_scores):",
    "docstring": {
      "en": "\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    ",
      "sq": "\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve totale (në zbritje),\n    pastaj sipas pikëve në gjuhën kineze (në zbritje), dhe së fundi sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Args:\n    student_scores (list): Një listë tuples, ku secili tuple përbëhet nga (numri_studentit, pikët_totale, pikët_kineze).\n    \n    Returns:\n    list: Një listë tuples e renditur sipas rregullave të mësipërme.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "hy": "\n    Ուսանողների ցուցակը դասավորում է ըստ նրանց գնահատականների։ Ուսանողները հիմնականում դասավորվում են ըստ իրենց ընդհանուր գնահատականի (նվազման կարգով),\n    ապա՝ ըստ իրենց չինարենի գնահատականի (նվազման կարգով), և վերջապես՝ ըստ իրենց ուսանողական համարի (աճման կարգով)՝ եթե գնահատականները հավասար են։\n    \n    Պարամետրեր:\n    student_scores (list): Ցուցակ, որը բաղկացած է տուփերից, որտեղ յուրաքանչյուր տուփ բաղկացած է (ուսանողական համար, ընդհանուր գնահատական, չինարենի գնահատական)։\n    \n    Վերադարձնում է:\n    list: Տուփերի ցուցակ, դասավորված ըստ վերը նշված կանոնների։\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "bn": "\n    শিক্ষার্থীদের একটি তালিকা তাদের স্কোরের ভিত্তিতে সাজানো হয়। শিক্ষার্থীদের প্রথমে তাদের মোট স্কোর (অবতরণী ক্রমে) দ্বারা সাজানো হয়,\n    তারপর তাদের চীনা স্কোর (অবতরণী ক্রমে) দ্বারা, এবং শেষে সমতার ক্ষেত্রে তাদের ছাত্র নম্বর (আরোহী ক্রমে) দ্বারা সাজানো হয়।\n    \n    আর্গুমেন্টসমূহ:\n    student_scores (list): একটি টাপল-এর তালিকা, যেখানে প্রতিটি টাপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n    \n    রিটার্নস:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টাপল-এর একটি তালিকা।\n    \n    উদাহরণ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "bg": "\n    Сортира списък от студенти въз основа на техните оценки. Студентите се сортират основно по техния общ резултат (в низходящ ред),\n    след това по оценката им по китайски език (в низходящ ред) и накрая по техния студентски номер (във възходящ ред) в случай на равенство.\n    \n    Аргументи:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (студентски номер, общ резултат, оценка по китайски език).\n    \n    Връща:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Примери:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "zh": "\n    根据学生的成绩对学生列表进行排序。学生首先根据总成绩（降序）排序，\n    然后根据语文成绩（降序）排序，最后在成绩相同的情况下根据学号（升序）排序。\n    \n    参数:\n    student_scores (list): 一个包含元组的列表，每个元组由 (student_number, total_score, Chinese_score) 组成。\n    \n    返回:\n    list: 一个根据上述规则排序的元组列表。\n    \n    示例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "fr": "\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "de": "\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert,\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n    \n    Args:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (student_number, total_score, Chinese_score) besteht.\n    \n    Returns:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "ha": "\n    Tana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki (daga mafi girma zuwa ƙasa),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga ƙasa zuwa mafi girma) idan akwai daidaito.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimillar_maki, maki_na_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga ƙa'idodin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "hi": "\n    छात्रों की सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंकों (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी अंकों (अवरोही क्रम में) के आधार पर, और अंत में टाई होने की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n    \n    तर्क:\n    student_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    लौटाता है:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n    \n    उदाहरण:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]",
      "hu": "\n    Rendez egy listát a diákokról a pontszámaik alapján. A diákokat elsősorban az összpontszámuk szerint (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák számuk szerint (növekvő sorrendben) rendezi döntetlen esetén.\n    \n    Argok:\n    student_scores (list): Egy lista, amelyben minden elem egy tuple, amely (diák_szám, összpontszám, kínai_pontszám) elemekből áll.\n    \n    Visszatér:\n    list: Egy lista, amely a fenti szabályok szerint rendezett tuple-öket tartalmazza.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]"
    },
    "docstring_bertscore": {
      "sq": "0.9741693107286991",
      "hy": "0.9568074263832015",
      "bn": "0.9680050154836622",
      "bg": "0.9766418617118213",
      "zh": "0.9723176783166918",
      "fr": "0.9927215869477386",
      "de": "0.9997954107075341",
      "ha": "0.9514326869027785",
      "hi": "0.9808369353592781",
      "hu": "0.9720968013329809"
    }
  },
  {
    "task_id": "Python/48",
    "prompt": {
      "en": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "sq": "def min_groups(w, n, prices):\n    \"\"\"\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte në mënyrë që çmimi total i secilit grup të mos tejkalojë kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Args:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Returns:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "hy": "def min_groups(w, n, prices):\n    \"\"\"\n    Որոշում է անհրաժեշտ խմբերի նվազագույն քանակը, որպեսզի բաշխի հուշանվերները՝ հաշվի առնելով խմբի ընդհանուր գնի սահմանափակումը։\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի `w` սահմանը։ \n    Ֆունկցիան նպատակ ունի նվազագույնացնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո։\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի համար թույլատրելի գների գումարի առավելագույն սահմանը։\n    n (int): Հուշանվերների ընդհանուր քանակը։\n    prices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը։\n    \n    Վերադարձնում է:\n    int: Նվազագույն խմբերի քանակը, որը անհրաժեշտ է բոլոր հուշանվերները բաշխելու համար։\n\n    Օրինակներ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "bn": "def min_groups(w, n, prices):\n    \"\"\"\n    একটি দলের মোট মূল্যের সীমাবদ্ধতার সাথে স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন দলের সংখ্যা নির্ধারণ করে।\n    \n    স্মারকগুলি জোড়ায় জোড়ায় গোষ্ঠীবদ্ধ করা হয় যাতে প্রতিটি দলের মোট মূল্য সীমা `w` অতিক্রম না করে।\n    এই সীমাবদ্ধতার অধীনে তৈরি দলের সংখ্যা সর্বনিম্ন করার লক্ষ্য রাখে ফাংশনটি।\n    \n    আর্গস:\n    w (int): যে কোনো স্মারকের দলের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মারকের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মারকের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n    \n    রিটার্নস:\n    int: সমস্ত স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন দলের সংখ্যা।\n\n    উদাহরণ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "bg": "def min_groups(w, n, prices):\n    \"\"\"\n    Определя минималния брой групи, необходими за разпределяне на сувенири с ограничение върху общата цена на групата.\n    \n    Сувенирите се групират по двойки така, че общата цена на всяка група да не надвишава лимита `w`.\n    Функцията цели да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максимално допустимата сума на цените за която и да е група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределяне на всички сувенири.\n\n    Примери:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "zh": "def min_groups(w, n, prices):\n    \"\"\"\n    确定在对组的总价格有限制的情况下分配纪念品所需的最小组数。\n    \n    纪念品成对分组，使得每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "fr": "def min_groups(w, n, prices):\n    \"\"\"\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont regroupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`.\n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes nécessaires pour distribuer tous les souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "de": "def min_groups(w, n, prices):\n    \"\"\"\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet.\n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Args:\n    w (int): Die maximal erlaubte Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Returns:\n    int: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "ha": "def min_groups(w, n, prices):\n    \"\"\"\n    Tabbatar da mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta tare da ƙuntatawa akan jimillar farashin ƙungiyar.\n\n    Ana haɗa kayan kyauta a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`. \n    Aikin wannan aikin shi ne rage yawan ƙungiyoyin da aka ƙirƙira a ƙarƙashin wannan ƙuntatawa.\n\n    Args:\n    w (int): Mafi girman adadin farashin da aka yarda don kowace ƙungiyar kayan kyauta.\n    n (int): Jimillar adadin kayan kyauta.\n    prices (list): Jerin lambobi masu wakiltar farashin kowane kayan kyauta.\n\n    Returns:\n    int: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kayan kyauta.\n\n    Misalai:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "hi": "def min_groups(w, n, prices):\n    \"\"\"\n    स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है जिसमें समूह की कुल कीमत पर एक बाधा होती है।\n    \n    स्मृति चिह्नों को जोड़ों में समूहित किया जाता है ताकि प्रत्येक समूह की कुल कीमत `w` की सीमा से अधिक न हो। \n    यह फ़ंक्शन इस बाधा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n    \n    Args:\n    w (int): किसी भी स्मृति चिह्न समूह के लिए अनुमत अधिकतम कीमत का योग।\n    n (int): स्मृति चिह्नों की कुल संख्या।\n    prices (list): प्रत्येक स्मृति चिह्न की कीमत को दर्शाने वाली पूर्णांकों की सूची।\n    \n    Returns:\n    int: सभी स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "hu": "def min_groups(w, n, prices):\n    \"\"\"\n    Meghatározza a szükséges csoportok minimális számát az ajándéktárgyak elosztásához, figyelembe véve a csoportok összárára vonatkozó korlátozást.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` határt.\n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás mellett.\n    \n    Args:\n    w (int): Az ajándéktárgyak bármely csoportjára megengedett maximális árösszeg.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát reprezentálja.\n    \n    Returns:\n    int: A szükséges csoportok minimális száma az összes ajándéktárgy elosztásához.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9791781730472557",
      "hy": "0.9716703419048991",
      "bn": "0.9698556547437643",
      "bg": "0.9851547625822146",
      "zh": "0.9631773040726094",
      "fr": "0.9841123503425434",
      "de": "0.9895425076992752",
      "ha": "0.9231802960259001",
      "hi": "0.9770583896208515",
      "hu": "0.9492672184887361"
    },
    "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups",
    "instruction": {
      "en": "Write a python function 'def min_groups(w, n, prices):' to solve the following problem:\n\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "sq": "Shkruani një funksion python 'def min_groups(w, n, prices):' për të zgjidhur problemin e mëposhtëm:\n\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suvenire me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte në mënyrë të tillë që çmimi total i çdo grupi të mos tejkalojë kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Args:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Kthen:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Shembuj:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "hy": "Պայթոն ֆունկցիա 'def min_groups(w, n, prices):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Որոշում է նվազագույն խմբերի քանակը, որոնք անհրաժեշտ են հուշանվերները բաշխելու համար՝ խմբի ընդհանուր գնի սահմանափակմամբ:\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի սահմանը `w`:\n    Ֆունկցիան նպատակ ունի նվազագույնի հասցնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո:\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի համար թույլատրված գների առավելագույն գումարը:\n    n (int): Հուշանվերների ընդհանուր քանակը:\n    prices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը ամբողջ թվերով:\n    \n    Վերադարձնում է:\n    int: Նվազագույն խմբերի քանակը, որոնք անհրաժեշտ են բոլոր հուշանվերները բաշխելու համար:\n\n    Օրինակներ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "bn": "একটি পাইথন ফাংশন 'def min_groups(w, n, prices):' লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\n\n    স্মারক বিতরণ করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করে যেখানে গ্রুপের মোট মূল্যের উপর একটি সীমাবদ্ধতা রয়েছে।\n    \n    স্মারকগুলি জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে। \n    এই সীমাবদ্ধতার অধীনে তৈরি গ্রুপের সংখ্যা কমানোর লক্ষ্য ফাংশনের।\n    \n    আর্গস:\n    w (int): যে কোনো স্মারক গ্রুপের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মারকের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মারকের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n    \n    রিটার্নস:\n    int: সমস্ত স্মারক বিতরণ করতে প্রয়োজনীয় সর্বনিম্ন গ্রুপ সংখ্যা।\n\n    উদাহরণ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "bg": "Напишете Python функция 'def min_groups(w, n, prices):', за да решите следния проблем:\n\n    Определя минималния брой групи, необходими за разпределяне на сувенири с ограничение върху общата цена на групата.\n    \n    Сувенирите са групирани по двойки така, че общата цена на всяка група да не надвишава лимита `w`. \n    Функцията цели да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максималната допустима сума на цените за всяка група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределяне на всички сувенири.\n\n    Примери:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "zh": "编写一个 Python 函数 'def min_groups(w, n, prices):' 来解决以下问题：\n\n    确定在对组的总价格有限制的情况下分配纪念品所需的最小组数。\n    \n    纪念品成对分组，使得每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "fr": "Écrire une fonction python 'def min_groups(w, n, prices):' pour résoudre le problème suivant :\n\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont groupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. \n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes nécessaires pour distribuer tous les souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "de": "Schreiben Sie eine Python-Funktion 'def min_groups(w, n, prices):', um das folgende Problem zu lösen:\n\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet. \n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Argumente:\n    w (int): Die maximal zulässige Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Rückgabewert:\n    int: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\n    Beispiele:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "ha": "Rubuta wani aikin python 'def min_groups(w, n, prices):' don warware matsalar mai zuwa:\n\n    Tabbatar da mafi ƙarancin adadin rukuni da ake buƙata don rarraba abubuwan tunawa tare da iyaka akan jimillar farashin rukunin.\n    \n    Ana haɗa abubuwan tunawa a cikin ma'aurata ta yadda jimillar farashin kowanne rukuni ba zai wuce iyakar `w` ba. \n    Aikin yana nufin rage adadin rukunin da aka ƙirƙira a ƙarƙashin wannan iyaka.\n    \n    Args:\n    w (int): Mafi girman adadin farashin da aka yarda don kowanne rukuni na abubuwan tunawa.\n    n (int): Jimillar adadin abubuwan tunawa.\n    prices (list): Jerin lambobi masu wakiltar farashin kowanne abu na tunawa.\n    \n    Returns:\n    int: Mafi ƙarancin adadin rukunin da ake buƙata don rarraba duk abubuwan tunawa.\n\n    Misalai:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "hi": "एक पायथन फ़ंक्शन 'def min_groups(w, n, prices):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    समूह के कुल मूल्य पर प्रतिबंध के साथ उपहारों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करें।\n    \n    उपहारों को जोड़ों में इस प्रकार समूहित किया जाता है कि प्रत्येक समूह का कुल मूल्य सीमा `w` से अधिक नहीं होता है।\n    फ़ंक्शन इस प्रतिबंध के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का लक्ष्य रखता है।\n    \n    तर्क:\n    w (int): किसी भी उपहार समूह के लिए अनुमत मूल्य का अधिकतम योग।\n    n (int): उपहारों की कुल संख्या।\n    prices (list): प्रत्येक उपहार के मूल्य का प्रतिनिधित्व करने वाली पूर्णांकों की सूची।\n    \n    लौटाता है:\n    int: सभी उपहारों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    उदाहरण:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "hu": "Írj egy Python függvényt 'def min_groups(w, n, prices):' a következő probléma megoldására:\n\n    Meghatározza a szükséges minimális csoportszámot az ajándéktárgyak elosztásához, a csoportok összárának korlátozásával.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` korlátot. \n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás mellett.\n    \n    Argumentumok:\n    w (int): Az ajándéktárgyak bármely csoportjának megengedett maximális ártartománya.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számok listája, amelyek az egyes ajándéktárgyak árát képviselik.\n    \n    Visszatér:\n    int: Az összes ajándéktárgy elosztásához szükséges minimális csoportszám.\n\n    Példák:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9823014371586484",
      "hy": "0.9687274341794861",
      "bn": "0.964729401870016",
      "bg": "0.9786003572688253",
      "zh": "0.9723971304691057",
      "fr": "0.989348048556242",
      "de": "0.9884762598138799",
      "ha": "0.95830231863087",
      "hi": "0.9344603167344904",
      "hu": "0.9470205102488505"
    },
    "level": "easy",
    "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()",
    "entry_point": "min_groups",
    "signature": "def min_groups(w, n, prices):",
    "docstring": {
      "en": "\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "sq": "\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte të tilla që çmimi total i secilit grup të mos e kalojë kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Argumentet:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Kthen:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Shembuj:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "hy": "\n    Որոշում է անհրաժեշտ խմբերի նվազագույն քանակը՝ հուշանվերները բաշխելու համար՝ խմբի ընդհանուր գնի սահմանափակմամբ:\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի `w` սահմանը:\n    Ֆունկցիան նպատակ ունի նվազագույնի հասցնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո:\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի համար թույլատրված գների գումարի առավելագույն չափը:\n    n (int): Հուշանվերների ընդհանուր քանակը:\n    prices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը որպես ամբողջ թիվ:\n    \n    Վերադարձնում է:\n    int: Հուշանվերները բաշխելու համար անհրաժեշտ խմբերի նվազագույն քանակը:\n\n    Օրինակներ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "bn": "\n    স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করে একটি সীমাবদ্ধতার সাথে যা গ্রুপের মোট মূল্যকে সীমাবদ্ধ করে।\n    \n    স্মারকগুলো জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে।\n    এই সীমাবদ্ধতার অধীনে তৈরি গ্রুপের সংখ্যা সর্বনিম্ন করার লক্ষ্য রাখে ফাংশনটি।\n    \n    আর্গুমেন্ট:\n    w (int): স্মারকের যেকোনো গ্রুপের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মারকের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মারকের মূল্যকে উপস্থাপনকারী পূর্ণসংখ্যার তালিকা।\n    \n    রিটার্ন:\n    int: সমস্ত স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ।\n\n    উদাহরণ:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "bg": "\n    Определя минималния брой групи, необходими за разпределяне на сувенири с ограничение върху общата цена на групата.\n    \n    Сувенирите се групират по двойки така, че общата цена на всяка група да не надвишава лимита `w`. \n    Функцията има за цел да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максимално допустимата сума на цените за която и да е група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределяне на всички сувенири.\n\n    Примери:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "zh": "\n    确定分配纪念品所需的最小组数，并对组的总价格施加限制。\n    \n    纪念品以对的形式分组，使得每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "fr": "\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont regroupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. \n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes requis pour distribuer tous les souvenirs.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "de": "\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet.\n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Args:\n    w (int): Die maximal erlaubte Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Returns:\n    int: Die minimale Anzahl von Gruppen, die benötigt werden, um alle Souvenirs zu verteilen.\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    ",
      "ha": "\n    Yana tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kyaututtuka tare da ƙuntatawa kan jimillar farashin ƙungiyar.\n    \n    Ana haɗa kyaututtukan a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`. \n    Aikin wannan aikin shi ne rage yawan ƙungiyoyin da aka ƙirƙira ƙarƙashin wannan ƙuntatawa.\n    \n    Args:\n    w (int): Mafi girman adadin da aka yarda na jimillar farashin kowace ƙungiyar kyaututtuka.\n    n (int): Jimillar adadin kyaututtuka.\n    prices (list): Jerin lambobi da ke wakiltar farashin kowanne kyaututtuka.\n    \n    Returns:\n    int: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kyaututtukan.\n\n    Misalai:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "hi": "\n    स्मृति चिन्ह वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है जिसमें समूह की कुल कीमत पर एक बाधा होती है।\n    \n    स्मृति चिन्हों को जोड़ों में इस प्रकार समूहित किया जाता है कि प्रत्येक समूह की कुल कीमत सीमा `w` से अधिक न हो। \n    यह फ़ंक्शन इस बाधा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n    \n    Args:\n    w (int): किसी भी स्मृति चिन्ह समूह के लिए अनुमत कीमतों का अधिकतम योग।\n    n (int): स्मृति चिन्हों की कुल संख्या।\n    prices (list): प्रत्येक स्मृति चिन्ह की कीमत का प्रतिनिधित्व करने वाले पूर्णांकों की सूची।\n    \n    Returns:\n    int: सभी स्मृति चिन्ह वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    Examples:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2",
      "hu": "\n    Meghatározza a minimális csoportok számát, amelyek szükségesek az ajándéktárgyak elosztásához, figyelembe véve a csoportok összárára vonatkozó korlátozást.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` határt. \n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás alatt.\n    \n    Paraméterek:\n    w (int): Az ajándéktárgyak bármely csoportjának megengedett maximális árösszege.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát jelöli.\n    \n    Visszatérési érték:\n    int: Az összes ajándéktárgy elosztásához szükséges minimális csoportok száma.\n\n    Példák:\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9805447500687758",
      "hy": "0.9559930418209585",
      "bn": "0.9183436462477006",
      "bg": "0.9757474291060212",
      "zh": "0.9697543532494366",
      "fr": "0.9870924019492099",
      "de": "0.9853786190216408",
      "ha": "0.9260137584113628",
      "hi": "0.97480671562144",
      "hu": "0.9282479529372432"
    }
  },
  {
    "task_id": "Python/49",
    "prompt": {
      "en": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    \"\"\"",
      "sq": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi me dy disqe për n çifte disqesh.\n    \n    Kjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një lidhje të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte disqesh.\n    \n    Args:\n    n (int): Numri i çifteve të disqeve (secili prej dy disqeve identikë) në shtyllën A.\n\n    Returns:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjithë disqet nga shtylla A në shtyllën C.\n\n    Raste:\n    - Për n=1, funksioni duhet të kthejë 2.\n    - Për n=2, funksioni duhet të kthejë 6.\n    - Për n=3, funksioni duhet të kthejë 14.\n    \"\"\"",
      "hy": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Հաշվել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակների Հանոյի աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար։\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A ձողից C ձող տեղափոխելու համար կրկնակի սկավառակների Հանոյի աշտարակների պայմաններում՝ հետևելով այն կանոններին, որ միայն մեկ սկավառակ կարող է տեղափոխվել միաժամանակ և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա։ Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար։\n    \n    Արգումենտներ:\n    n (int): Սկավառակների զույգերի քանակը (յուրաքանչյուրը երկու նույնական սկավառակ) A ձողի վրա։\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A ձողից C ձող տեղափոխելու համար։\n\n    Դեպքեր:\n    - n=1-ի համար ֆունկցիան պետք է վերադարձնի 2։\n    - n=2-ի համար ֆունկցիան պետք է վերադարձնի 6։\n    - n=3-ի համար ֆունկցիան պետք է վերադարձնի 14։\n    \"\"\"",
      "bn": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম প্রয়োগ করে যা 2n ডিস্ককে ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করার জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা নির্ধারণ করে, \n    নিয়ম অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনো ডিস্ককে ছোট ডিস্কের উপরে রাখা যাবে না। \n    ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর থাকা ডিস্কের জোড়ার সংখ্যা (প্রতিটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: A পোল থেকে C পোল পর্যন্ত সমস্ত ডিস্ক স্থানান্তর করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা।\n\n    কেসসমূহ:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে।\n    \"\"\"",
      "bg": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Изчислява минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване\n    на 2n диска от кола A към кола C в конфигурация на Ханойски кули с двойни дискове, следвайки правилата, че само един диск \n    може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Аргументи:\n    n (int): Броят на двойките дискове (всяка от два идентични диска) на кола A.\n\n    Връща:\n    int: Минималният брой ходове, необходими за преместване на всички дискове от кола A към кола C.\n\n    Случаи:\n    - За n=1, функцията трябва да върне 2.\n    - За n=2, функцията трябва да върне 6.\n    - За n=3, функцията трябва да върне 14.\n    \"\"\"",
      "zh": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    计算解决双盘汉诺塔问题所需的最小移动次数，对于 n 对圆盘。\n    \n    此函数实现了一个迭代算法，以确定在双盘汉诺塔设置中，将 2n 个圆盘从 A 柱移动到 C 柱所需的最小移动次数，\n    遵循的规则是每次只能移动一个圆盘，且不能将圆盘放在比它小的圆盘上。该函数使用已知的递归关系，并迭代计算\n    n 对圆盘的总移动次数。\n    \n    参数:\n    n (int): A 柱上的圆盘对数（每对有两个相同的圆盘）。\n\n    返回:\n    int: 将所有圆盘从 A 柱移动到 C 柱所需的最小移动次数。\n\n    情况:\n    - 对于 n=1，函数应返回 2。\n    - 对于 n=2，函数应返回 6。\n    - 对于 n=3，函数应返回 14。\n    \"\"\"",
      "fr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2.\n    - Pour n=2, la fonction doit retourner 6.\n    - Pour n=3, la fonction doit retourner 14.\n    \"\"\"",
      "de": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Turm-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um\n    2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Turm-Setup zu übertragen, wobei die Regeln befolgt werden, dass \n    nur eine Scheibe gleichzeitig bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet \n    eine bekannte rekursive Beziehung und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Argumente:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Rückgabe:\n    int: Die minimale Anzahl von Zügen, die erforderlich sind, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben.\n    - Für n=2 sollte die Funktion 6 zurückgeben.\n    - Für n=3 sollte die Funktion 14 zurückgeben.\n    \"\"\"",
      "ha": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin adadin motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i-nau'i na faifai.\n    \n    Wannan aikin yana aiwatar da wani tsari na maimaitawa don tantance mafi ƙarancin adadin motsi da ake buƙata don canja wurin\n    faifai 2n daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin cewa ana iya motsa faifan guda ɗaya kawai a lokaci guda kuma babu faifan da za a iya sanya a saman ƙaramin faifan. Aikin yana amfani da sanannen dangantakar maimaitawa \n    kuma yana maimaita lissafin jimillar adadin motsi don nau'i-nau'i na faifai n.\n    \n    Args:\n    n (int): Adadin nau'i-nau'i na faifai (kowanne na faifai iri biyu) a kan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin adadin motsi da ake buƙata don canja duk faifan daga sandar A zuwa sandar C.\n\n    Cases:\n    - Don n=1, aikin ya kamata ya dawo da 2.\n    - Don n=2, aikin ya kamata ya dawo da 6.\n    - Don n=3, aikin ya kamata ya dawo da 14.\n    \"\"\"",
      "hi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    डबल-डिस्क हनोई टावर्स समस्या को हल करने के लिए आवश्यक न्यूनतम चालों की संख्या की गणना करें, जब n जोड़े डिस्क होते हैं।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि न्यूनतम चालों की संख्या निर्धारित की जा सके, \n    जो 2n डिस्क को A पोल से C पोल तक डबल-डिस्क हनोई टावर्स सेटअप में स्थानांतरित करने के लिए आवश्यक है, \n    इन नियमों का पालन करते हुए कि एक समय में केवल एक डिस्क को स्थानांतरित किया जा सकता है और कोई भी डिस्क \n    एक छोटी डिस्क के ऊपर नहीं रखी जा सकती। यह फ़ंक्शन एक ज्ञात पुनरावृत्त संबंध का उपयोग करता है और n जोड़े डिस्क के लिए \n    कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n    \n    Args:\n    n (int): A पोल पर डिस्क के जोड़े (प्रत्येक दो समान डिस्क) की संख्या।\n\n    Returns:\n    int: सभी डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    Cases:\n    - जब n=1 हो, तो फ़ंक्शन को 2 लौटाना चाहिए।\n    - जब n=2 हो, तो फ़ंक्शन को 6 लौटाना चाहिए।\n    - जब n=3 हो, तो फ़ंक्शन को 14 लौटाना चाहिए।\n    \"\"\"",
      "hu": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Számítsa ki a minimális lépésszámot a dupla korongos Hanoi tornyok problémájának megoldásához n korongpár esetén.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány minimális lépés szükséges\n    2n korong áthelyezéséhez az A oszlopról a C oszlopra egy dupla korongos Hanoi tornyok felállásban, azzal a szabállyal,\n    hogy egyszerre csak egy korong mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert\n    rekurzív összefüggést használ, és iteratívan számítja ki az összes lépést n korongpár esetén.\n    \n    Paraméterek:\n    n (int): Az A oszlopon lévő korongpárok száma (mindegyik két azonos korongból áll).\n\n    Visszatérési érték:\n    int: A minimális lépésszám, amely szükséges az összes korong áthelyezéséhez az A oszlopról a C oszlopra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9390190826096221",
      "hy": "0.9299875578143467",
      "bn": "0.9298493110691465",
      "bg": "0.9451688778368432",
      "zh": "0.9506703435003665",
      "fr": "0.9409795644704364",
      "de": "0.9393009391203105",
      "ha": "0.9424623402648619",
      "hi": "0.9528912297907176",
      "hu": "0.918693235718322"
    },
    "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
    "instruction": {
      "en": "Write a python function 'def hanoi_double_iterative(n: int) -> int:' to solve the following problem:\n\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    ",
      "sq": "Shkruani një funksion python 'def hanoi_double_iterative(n: int) -> int:' për të zgjidhur problemin e mëposhtëm:\n\n    Llogaritni numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoit me dy disqe për n çifte diskesh.\n    \n    Ky funksion zbaton një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga poli A në polin C në një konfigurim të Kullave të Hanoit me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një marrëdhënie të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte diskesh.\n    \n    Args:\n    n (int): Numri i çifteve të disqeve (secili prej dy disqeve identike) në polin A.\n\n    Kthen:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjitha disqet nga poli A në polin C.\n\n    Raste:\n    - Për n=1, funksioni duhet të kthejë 2.\n    - Për n=2, funksioni duhet të kthejë 6.\n    - Për n=3, funksioni duhet të kthejë 14.",
      "hy": "Պայթոն ֆունկցիա 'def hanoi_double_iterative(n: int) -> int:' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվարկել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակներով Հանոյի աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար:\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու համար նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A սյունից տեղափոխելու համար C սյունին կրկնակի սկավառակներով Հանոյի աշտարակների կառուցվածքում՝ հետևելով այն կանոններին, որ մեկ անգամում միայն մեկ սկավառակ կարող է տեղափոխվել և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա: Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվարկում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար:\n    \n    Արգումենտներ:\n    n (int): A սյունում գտնվող սկավառակների զույգերի քանակը (յուրաքանչյուր զույգ բաղկացած է երկու նույնական սկավառակներից):\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A սյունից C սյուն տեղափոխելու համար:\n\n    Դեպքեր:\n    - Եթե n=1, ֆունկցիան պետք է վերադարձնի 2:\n    - Եթե n=2, ֆունկցիան պետք է վերադարձնի 6:\n    - Եթե n=3, ֆունկցիան պետք է վերադարձնի 14:",
      "bn": "একটি পাইথন ফাংশন 'def hanoi_double_iterative(n: int) -> int:' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম বাস্তবায়ন করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে A পোল থেকে C পোল পর্যন্ত \n    2n ডিস্ক স্থানান্তরের জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা নির্ধারণ করে, নিম্নলিখিত নিয়মগুলি অনুসরণ করে যে একবারে \n    শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনো ডিস্ক একটি ছোট ডিস্কের উপরে রাখা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে \n    এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর ডিস্ক জোড়ার সংখ্যা (প্রত্যেকটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: A পোল থেকে C পোল পর্যন্ত সমস্ত ডিস্ক স্থানান্তরের জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা।\n\n    কেস:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে।",
      "bg": "Напишете Python функция 'def hanoi_double_iterative(n: int) -> int:', за да решите следния проблем:\n\n    Изчислете минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за прехвърляне\n    на 2n диска от полюс A към полюс C в настройка на Ханойските кули с двойни дискове, следвайки правилата, че само един диск \n    може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Аргументи:\n    n (int): Броят на двойките дискове (всяка от две идентични диска) на полюс A.\n\n    Връща:\n    int: Минималният брой ходове, необходими за прехвърляне на всички дискове от полюс A към полюс C.\n\n    Случаи:\n    - За n=1, функцията трябва да върне 2.\n    - За n=2, функцията трябва да върне 6.\n    - За n=3, функцията трябва да върне 14.",
      "zh": "编写一个 Python 函数 'def hanoi_double_iterative(n: int) -> int:' 来解决以下问题：\n\n    计算解决 n 对圆盘的双圆盘汉诺塔问题所需的最小移动次数。\n    \n    此函数实现了一种迭代算法，以确定在双圆盘汉诺塔设置中，将 2n 个圆盘从 A 杆转移到 C 杆所需的最小移动次数，遵循一次只能移动一个圆盘且不能将圆盘放在比它小的圆盘上的规则。该函数使用已知的递归关系，并迭代计算 n 对圆盘的总移动次数。\n    \n    参数：\n    n (int): A 杆上的圆盘对数（每对由两个相同的圆盘组成）。\n\n    返回：\n    int: 将所有圆盘从 A 杆转移到 C 杆所需的最小移动次数。\n\n    情况：\n    - 对于 n=1，函数应返回 2。\n    - 对于 n=2，函数应返回 6。\n    - 对于 n=3，函数应返回 14。",
      "fr": "Écrire une fonction python 'def hanoi_double_iterative(n: int) -> int:' pour résoudre le problème suivant :\n\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2.\n    - Pour n=2, la fonction doit retourner 6.\n    - Pour n=3, la fonction doit retourner 14.",
      "de": "Schreiben Sie eine Python-Funktion 'def hanoi_double_iterative(n: int) -> int:', um das folgende Problem zu lösen:\n\n    Berechnen Sie die minimale Anzahl von Zügen, die erforderlich sind, um das Doppel-Scheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um\n    2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppel-Scheiben-Hanoi-Türme-Setup zu übertragen, wobei die Regeln befolgt werden, dass jeweils nur eine Scheibe \n    bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet eine bekannte rekursive Relation \n    und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Argumente:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Zügen, die erforderlich sind, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben.\n    - Für n=2 sollte die Funktion 6 zurückgeben.\n    - Für n=3 sollte die Funktion 14 zurückgeben.",
      "ha": "Rubuta wani aikin python 'def hanoi_double_iterative(n: int) -> int:' don warware matsalar mai zuwa:\n\n    Lissafa mafi ƙarancin adadin motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i biyu na diski.\n\n    Wannan aikin yana aiwatar da wani algorithm mai maimaitawa don tantance mafi ƙarancin adadin motsi da ake buƙata don canja wurin\n    2n diski daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin cewa ana iya motsa faifan diski ɗaya kawai a lokaci guda kuma babu faifan diski da za a iya sanya shi a saman wani ƙarami. Aikin yana amfani da sanannen dangantakar maimaitawa \n    kuma yana lissafin jimillar adadin motsi don n nau'i biyu na diski.\n\n    Args:\n    n (int): Adadin nau'i biyu na diski (kowanne daga cikin diski biyu masu kama) akan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin adadin motsi da ake buƙata don canja dukkan diski daga sandar A zuwa sandar C.\n\n    Cases:\n    - Don n=1, aikin ya kamata ya dawo da 2.\n    - Don n=2, aikin ya kamata ya dawo da 6.\n    - Don n=3, aikin ya kamata ya dawo da 14.",
      "hi": "एक पायथन फ़ंक्शन 'def hanoi_double_iterative(n: int) -> int:' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    n जोड़े डिस्क के लिए डबल-डिस्क हनोई टावर्स समस्या को हल करने के लिए आवश्यक न्यूनतम चालों की संख्या की गणना करें।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि डबल-डिस्क हनोई टावर्स सेटअप में A पोल से C पोल तक \n    2n डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या निर्धारित की जा सके, इस नियम का पालन करते हुए \n    कि एक समय में केवल एक डिस्क को स्थानांतरित किया जा सकता है और कोई भी डिस्क एक छोटी डिस्क के ऊपर नहीं रखी जा सकती। \n    फ़ंक्शन एक ज्ञात पुनरावृत्त संबंध का उपयोग करता है और n जोड़े डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से \n    गणना करता है।\n    \n    तर्क:\n    n (int): A पोल पर डिस्क जोड़ों की संख्या (प्रत्येक दो समान डिस्क का)।\n\n    लौटाता है:\n    int: सभी डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    मामले:\n    - n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    - n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\n    - n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए।",
      "hu": "Írj egy python függvényt 'def hanoi_double_iterative(n: int) -> int:' a következő probléma megoldására:\n\n    Számítsd ki a minimális lépések számát, amely szükséges az n pár korongból álló dupla korongos Hanoi tornyok problémájának megoldásához.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány minimális lépés szükséges ahhoz, hogy 2n korongot áthelyezzünk az A pólusról a C pólusra egy dupla korongos Hanoi tornyok elrendezésben, azokat a szabályokat követve, hogy egyszerre csak egy korong mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan kiszámítja az összes lépés számát n korongpár esetén.\n    \n    Args:\n    n (int): A korongpárok száma (mindegyik két azonos korongból áll) az A póluson.\n\n    Returns:\n    int: A minimális lépések száma, amely szükséges az összes korong áthelyezéséhez az A pólusról a C pólusra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia."
    },
    "instruction_bertscore": {
      "sq": "0.9431754233327772",
      "hy": "0.9121503509670328",
      "bn": "0.9352548382586299",
      "bg": "0.9481312513395975",
      "zh": "0.9322412181175685",
      "fr": "0.9442653082335155",
      "de": "0.9628360570779914",
      "ha": "0.9492946294813189",
      "hi": "0.96465531273789",
      "hu": "0.9525559417075308"
    },
    "level": "easy",
    "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()",
    "entry_point": "hanoi_double_iterative",
    "signature": "def hanoi_double_iterative(n: int) -> int:",
    "docstring": {
      "en": "\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2.\n    - For n=2, the function should return 6.\n    - For n=3, the function should return 14.\n    ",
      "sq": "\n    Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi-t me dy disqe për n çifte diskesh.\n    \n    Kjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi-t me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një marrëdhënie të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte diskesh.\n    \n    Args:\n    n (int): Numri i çifteve të disqeve (secili prej dy disqeve identikë) në shtyllën A.\n\n    Returns:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjitha disqet nga shtylla A në shtyllën C.\n\n    Raste:\n    - Për n=1, funksioni duhet të kthejë 2.\n    - Për n=2, funksioni duhet të kthejë 6.\n    - Për n=3, funksioni duhet të kthejë 14.",
      "hy": "\n    Հաշվեք նվազագույն քայլերի քանակը, որը պահանջվում է լուծելու համար կրկնակի սկավառակների Հանոյյան աշտարակների խնդիրը n զույգ սկավառակների համար։\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու համար նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A սյունակից C սյունակ տեղափոխելու համար կրկնակի սկավառակների Հանոյյան աշտարակների կարգավորումով՝ հետևելով այն կանոններին, որ մեկ անգամում միայն մեկ սկավառակ կարող է տեղափոխվել, և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա։ Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար։\n    \n    Արգումենտներ:\n    n (int): A սյունակում գտնվող սկավառակների զույգերի քանակը (յուրաքանչյուր զույգը բաղկացած է երկու նույնական սկավառակներից)։\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A սյունակից C սյունակ տեղափոխելու համար։\n\n    Դեպքեր:\n    - Երբ n=1, ֆունկցիան պետք է վերադարձնի 2։\n    - Երբ n=2, ֆունկցիան պետք է վերադարձնի 6։\n    - Երբ n=3, ֆունկցիան պետք է վերադարձնի 14։",
      "bn": "\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম প্রয়োগ করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে 2n ডিস্ককে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা নির্ধারণ করে, এই নিয়মগুলি অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনও ডিস্ক ছোট ডিস্কের উপরে রাখা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর ডিস্কের জোড়ার সংখ্যা (প্রতিটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: সমস্ত ডিস্ককে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা।\n\n    উদাহরণসমূহ:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেওয়া উচিত।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেওয়া উচিত।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেওয়া উচিত।",
      "bg": "\n    Изчислете минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване\n    на 2n диска от стълб A към стълб C в настройка на Ханойските кули с двойни дискове, следвайки правилата, че само един диск \n    може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Аргументи:\n    n (int): Броят на двойките дискове (всяка от два идентични диска) на стълб A.\n\n    Връща:\n    int: Минималният брой ходове, необходими за преместване на всички дискове от стълб A към стълб C.\n\n    Случаи:\n    - За n=1, функцията трябва да върне 2.\n    - За n=2, функцията трябва да върне 6.\n    - За n=3, функцията трябва да върне 14.",
      "zh": "\n    计算解决双盘汉诺塔问题所需的最小移动次数，对于 n 对圆盘。\n    \n    此函数实现了一个迭代算法，以确定在双盘汉诺塔设置中，将 2n 个圆盘从 A 柱移动到 C 柱所需的最小移动次数，\n    遵循的规则是一次只能移动一个圆盘，并且不能将圆盘放在比它小的圆盘上。\n    该函数使用已知的递归关系，并迭代计算 n 对圆盘的总移动次数。\n    \n    参数:\n    n (int): A 柱上的圆盘对数（每对由两个相同的圆盘组成）。\n\n    返回:\n    int: 将所有圆盘从 A 柱移动到 C 柱所需的最小移动次数。\n\n    情况:\n    - 对于 n=1，函数应返回 2。\n    - 对于 n=2，函数应返回 6。\n    - 对于 n=3，函数应返回 14。",
      "fr": "\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule itérativement le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2.\n    - Pour n=2, la fonction doit retourner 6.\n    - Pour n=3, la fonction doit retourner 14.",
      "de": "\n    Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um\n    2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Türme-Aufbau zu übertragen, wobei die Regeln befolgt werden, dass nur eine Scheibe \n    gleichzeitig bewegt werden darf und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet eine bekannte rekursive Beziehung \n    und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Args:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Returns:\n    int: Die minimale Anzahl von Zügen, die erforderlich ist, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben.\n    - Für n=2 sollte die Funktion 6 zurückgeben.\n    - Für n=3 sollte die Funktion 14 zurückgeben.",
      "ha": "\n    Lissafa mafi ƙarancin yawan motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don nau'i-nau'i na diski n.\n    \n    Wannan aikin yana aiwatar da wani tsari mai maimaitawa don ƙayyade mafi ƙarancin yawan motsi da ake buƙata don canja wurin\n    diski 2n daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin da ke cewa ana iya motsa faifan diski ɗaya kawai a lokaci guda kuma ba za a iya sanya faifan diski a kan wani ƙaramin faifan diski ba. Aikin yana amfani da wata sananniyar dangantaka mai maimaitawa \n    kuma yana lissafin jimillar yawan motsi don nau'i-nau'i na diski n.\n    \n    Args:\n    n (int): Yawan nau'i-nau'i na diski (kowanne na diski guda biyu iri ɗaya) akan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin yawan motsi da ake buƙata don canja wurin dukkan diski daga sandar A zuwa sandar C.\n\n    Cases:\n    - Don n=1, aikin ya kamata ya dawo da 2.\n    - Don n=2, aikin ya kamata ya dawo da 6.\n    - Don n=3, aikin ya kamata ya dawo da 14.",
      "hi": "\n    दोहरे-डिस्क हनोई टावर्स समस्या को हल करने के लिए आवश्यक न्यूनतम चालों की गणना करें, जिसमें n जोड़े डिस्क होते हैं।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि दोहरे-डिस्क हनोई टावर्स सेटअप में A पोल से C पोल तक 2n डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या निर्धारित की जा सके, इस नियम का पालन करते हुए कि एक समय में केवल एक डिस्क को ही स्थानांतरित किया जा सकता है और कोई भी डिस्क छोटी डिस्क के ऊपर नहीं रखी जा सकती। यह फ़ंक्शन एक ज्ञात पुनरावर्ती संबंध का उपयोग करता है और n जोड़े डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n    \n    Args:\n    n (int): A पोल पर डिस्क के जोड़ों की संख्या (प्रत्येक दो समान डिस्क का एक जोड़ा)।\n\n    Returns:\n    int: सभी डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    Cases:\n    - n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    - n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\n    - n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए।",
      "hu": "\n    Számítsa ki a minimális lépésszámot, amely szükséges a dupla korongos Hanoi tornyok problémájának megoldásához n korongpár esetén.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány minimális lépés szükséges 2n korong áthelyezéséhez az A rúdról a C rúdra egy dupla korongos Hanoi tornyok elrendezésben, azzal a szabállyal, hogy egyszerre csak egy korong mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan számítja ki a teljes lépésszámot n korongpár esetén.\n    \n    Args:\n    n (int): A korongpárok száma (mindegyik két azonos korong) az A rúdon.\n\n    Returns:\n    int: A minimális lépésszám, amely szükséges az összes korong áthelyezéséhez az A rúdról a C rúdra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia."
    },
    "docstring_bertscore": {
      "sq": "0.9187154823209979",
      "hy": "0.8945654047036331",
      "bn": "0.9191804760430006",
      "bg": "0.9293300912531213",
      "zh": "0.9470775171682075",
      "fr": "0.9348899542486688",
      "de": "0.9575697697856134",
      "ha": "0.8993591503195291",
      "hi": "0.9354322151888941",
      "hu": "0.9138148735601052"
    }
  },
  {
    "task_id": "Python/50",
    "prompt": {
      "en": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "sq": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshme për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "hy": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Հաշվում է ընդհանուր ծխախոտների քանակը, որը կարող է ծխել Փիթերը:\n    Փիթերը սկսում է n ծխախոտներով և կարող է փոխանակել k մնացորդներ մեկ նոր ծխախոտի համար:\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը ծխախոտների սկզբնական քանակն է,\n    իսկ k-ն այն մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի փոխանակման համար:\n    Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որը կարող է ծխել Փիթերը:\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "bn": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    পিটার মোট কতগুলি সিগারেট খেতে পারবে তা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k টুকরো অবশিষ্টাংশের বিনিময়ে একটি নতুন সিগারেট পেতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেটের বিনিময়ে প্রয়োজনীয় সিগারেট অবশিষ্টাংশের সংখ্যা।\n    ফাংশনটি পিটার মোট কতগুলি সিগারেট খেতে পারবে তা ফেরত দেয়।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "bg": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "zh": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    计算Peter可以抽的香烟总数。\n    Peter开始时有n支香烟，可以用k个烟蒂换一支新香烟。\n    该函数接受两个参数，n和k，其中n是初始香烟数量，\n    k是换取一支新香烟所需的烟蒂数量。\n    该函数返回Peter可以抽的香烟总数。\n    示例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "fr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n    Exemple:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "de": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist\n    und k die Anzahl der Zigarettenkippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "ha": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da sigari n kuma zai iya musanya k bututun sigari don sabon sigari daya.\n    Aikin yana daukar hujjoji biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya sabon sigari daya.\n    Aikin yana mayar da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "hi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n    पीटर n सिगरेट से शुरू करता है और k बट्स को एक नई सिगरेट के लिए बदल सकता है।\n    यह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,\n    और k वह संख्या है जो एक नई सिगरेट के लिए बट्स के आदान-प्रदान के लिए आवश्यक है।\n    फ़ंक्शन वह कुल संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "hu": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n    Péter n cigarettával kezd, és k csikket cserélhet egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigarettaszám,\n    és k a cigarettacsikkek száma, amely szükséges egy új cigaretta cseréjéhez.\n    A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9851879338558474",
      "hy": "0.9876028820284696",
      "bn": "0.9522419070751146",
      "bg": "0.9974013187249205",
      "zh": "0.9834993769866698",
      "fr": "0.9851879338558474",
      "de": "0.9916900993790244",
      "ha": "0.9950888638289124",
      "hi": "0.9743073588435183",
      "hu": "0.9922478534889704"
    },
    "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total",
    "instruction": {
      "en": "Write a python function 'def total_smoked_cigarettes(n, k):' to solve the following problem:\n\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ",
      "sq": "Shkruani një funksion python 'def total_smoked_cigarettes(n, k):' për të zgjidhur problemin e mëposhtëm:\n\n    Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshme për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hy": "Պայթոն ֆունկցիա 'def total_smoked_cigarettes(n, k):' գրեք հետևյալ խնդիրը լուծելու համար:\n\n    Հաշվում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել։\n    Պետերը սկսում է n ծխախոտներով և կարող է փոխանակել k ծխախոտի մնացորդները մեկ նոր ծխախոտի համար։\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների քանակն է,\n    իսկ k-ն այն ծխախոտի մնացորդների քանակն է, որը անհրաժեշտ է մեկ նոր ծխախոտի փոխանակման համար։\n    Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել։\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "bn": "একটি পাইথন ফাংশন 'def total_smoked_cigarettes(n, k):' লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\n\n    পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k বাট দিয়ে একটি নতুন সিগারেটের জন্য বিনিময় করতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n    ফাংশনটি পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা ফেরত দেয়।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "bg": "Напишете Python функция 'def total_smoked_cigarettes(n, k):', за да решите следния проблем:\n\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "zh": "编写一个 Python 函数 'def total_smoked_cigarettes(n, k):' 来解决以下问题：\n\n    计算 Peter 可以抽的香烟总数。\n    Peter 从 n 支香烟开始，可以用 k 个烟蒂换一支新香烟。\n    该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，\n    k 是换取一支新香烟所需的烟蒂数量。\n    该函数返回 Peter 可以抽的香烟总数。\n    示例：\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "fr": "Écrivez une fonction python 'def total_smoked_cigarettes(n, k):' pour résoudre le problème suivant :\n\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction retourne le nombre total de cigarettes que Peter peut fumer.\n    Exemple :\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "de": "Schreiben Sie eine Python-Funktion 'def total_smoked_cigarettes(n, k):', um das folgende Problem zu lösen:\n\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist\n    und k die Anzahl der Zigarettenkippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "ha": "Rubuta wani aikin python 'def total_smoked_cigarettes(n, k):' don warware matsalar mai zuwa:\n\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da n sigari kuma zai iya musanya k butts don sabon sigari daya.\n    Aikin yana daukar hujjoji biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya don sabon sigari daya.\n    Aikin yana mayar da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hi": "एक पायथन फ़ंक्शन 'def total_smoked_cigarettes(n, k):' लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n    यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n    पीटर n सिगरेट से शुरू करता है और k बट्स के बदले एक नई सिगरेट प्राप्त कर सकता है।\n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,\n    और k वह संख्या है जो एक नई सिगरेट के बदले में सिगरेट बट्स की आवश्यकता होती है।\n    फ़ंक्शन वह कुल संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hu": "Írj egy python függvényt 'def total_smoked_cigarettes(n, k):' a következő probléma megoldására:\n\n    Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n    Péter n cigarettával kezd, és k csikket cserélhet be egy új cigarettára.\n    A függvény két argumentumot vesz, n és k, ahol n a kezdeti cigarettaszám,\n    és k az a csikkszám, amely szükséges egy új cigaretta cseréjéhez.\n    A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14"
    },
    "instruction_bertscore": {
      "sq": "0.9874954229923296",
      "hy": "0.9881074031962981",
      "bn": "0.9907475982210139",
      "bg": "0.9918805859144368",
      "zh": "0.9839288158704672",
      "fr": "0.9866303876829227",
      "de": "0.9926284292990333",
      "ha": "0.9976355039441607",
      "hi": "0.9581811540984387",
      "hu": "0.988368403516978"
    },
    "level": "easy",
    "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k):",
    "docstring": {
      "en": "\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    ",
      "sq": "\n    Llogarit numrin total të cigareve që Pjetri mund të pijë.\n    Pjetri fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve që duhen për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Pjetri mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hy": "\n    Հաշվում է, թե քանի հատ ծխախոտ կարող է ծխել Պետերը:\n    Պետերը սկսում է n ծխախոտով և կարող է փոխանակել k ծխախոտի մնացորդները մեկ նոր ծխախոտի համար:\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների քանակն է,\n    իսկ k-ն այն ծխախոտի մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի փոխանակման համար:\n    Ֆունկցիան վերադարձնում է, թե ընդհանուր քանի հատ ծխախոտ կարող է ծխել Պետերը:\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "bn": "\n    পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k টুকরো সিগারেটের অবশিষ্টাংশের বিনিময়ে একটি নতুন সিগারেট পেতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেটের বিনিময়ে প্রয়োজনীয় সিগারেটের অবশিষ্টাংশের সংখ্যা।\n    ফাংশনটি পিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা প্রদান করে।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "bg": "\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "zh": "\n    计算彼得可以抽的香烟总数。\n    彼得从 n 支香烟开始，可以用 k 个烟蒂换一支新香烟。\n    该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，\n    k 是换取一支新香烟所需的烟蒂数量。\n    该函数返回彼得可以抽的香烟总数。\n    示例:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "fr": "\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction retourne le nombre total de cigarettes que Peter peut fumer.\n    Exemple:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "de": "\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist,\n    und k die Anzahl der benötigten Zigarettenkippen, um eine neue Zigarette einzutauschen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "ha": "\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da n sigari kuma zai iya musanya k butts don sabon sigari daya.\n    Aikin yana daukar hujjoji guda biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya da sabon sigari daya.\n    Aikin yana dawowa da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hi": "\n    पीटर कितनी कुल सिगरेट पी सकता है, इसकी गणना करता है।\n    पीटर n सिगरेट से शुरू करता है और k बट्स को एक नई सिगरेट के लिए बदल सकता है।\n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,\n    और k वह संख्या है जितने सिगरेट बट्स को एक नई सिगरेट के लिए बदलने की आवश्यकता होती है।\n    फ़ंक्शन कुल सिगरेट की संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hu": "\n    Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni.\n    Péter n cigarettával kezd, és k csikket tud beváltani egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma,\n    és k a csikkek száma, amelyeket be kell váltani egy új cigarettára.\n    A függvény visszaadja, hogy Péter összesen hány cigarettát tud elszívni.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14"
    },
    "docstring_bertscore": {
      "sq": "0.9511542071085676",
      "hy": "0.9837899732341238",
      "bn": "0.951190953729059",
      "bg": "0.9957322276330844",
      "zh": "0.9779422948164567",
      "fr": "0.9842970765969059",
      "de": "0.9923934495582689",
      "ha": "0.9961211459191507",
      "hi": "0.9850671665841781",
      "hu": "0.9894600760911457"
    }
  }
]