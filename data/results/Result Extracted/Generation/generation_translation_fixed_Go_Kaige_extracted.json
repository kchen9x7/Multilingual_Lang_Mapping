[
  {
    "task_id": "Go/1",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\nParametrat:\n- a (float64): Gjatësia e anës 'a'.\n- b (float64): Gjatësia e anës 'b'.\n- c (float64): Gjatësia e anës 'c'.\n\nKthen:\n- float64: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthen -1.\n\nShembuj:\n\tcalculateTriangleArea(3, 5, 4)  // Kthen 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը։\nՊարամետրեր:\n- a (float64): 'a' կողմի երկարությունը։\n- b (float64): 'b' կողմի երկարությունը։\n- c (float64): 'c' կողմի երկարությունը։\n\nՎերադարձնում է:\n- float64: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով։\nՀակառակ դեպքում՝ վերադարձնել -1։\n\nՕրինակներ:\n\tcalculateTriangleArea(3, 5, 4)  // Վերադարձնում է 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- a (float64): বাহু 'a' এর দৈর্ঘ্য।\n- b (float64): বাহু 'b' এর দৈর্ঘ্য।\n- c (float64): বাহু 'c' এর দৈর্ঘ্য।\n\nরিটার্নস:\n- float64: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন।\nঅন্যথায়, -1 রিটার্ন করুন।\n\nউদাহরণ:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 রিটার্ন করে\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете площта на триъгълник, като са дадени трите му страни.\nПараметри:\n- a (float64): Дължина на страна 'a'.\n- b (float64): Дължина на страна 'b'.\n- c (float64): Дължина на страна 'c'.\n\nВръща:\n- float64: Ако предоставените страни образуват триъгълник, върнете изчислената площ с 2 знака след десетичната запетая.\nВ противен случай върнете -1.\n\nПримери:\n\tcalculateTriangleArea(3, 5, 4)  // Връща 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定三边的三角形面积。\n参数:\n- a (float64): 边 'a' 的长度。\n- b (float64): 边 'b' 的长度。\n- c (float64): 边 'c' 的长度。\n\n返回:\n- float64: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 -1。\n\n示例:\n\tcalculateTriangleArea(3, 5, 4)  // 返回 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculez l'aire d'un triangle donné par ses trois côtés.\nParamètres :\n- a (float64) : Longueur du côté 'a'.\n- b (float64) : Longueur du côté 'b'.\n- c (float64) : Longueur du côté 'c'.\n\nRenvoie :\n- float64 : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie -1.\n\nExemples :\n\tcalculateTriangleArea(3, 5, 4)  // Renvoie 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\nParameter:\n- a (float64): Länge der Seite 'a'.\n- b (float64): Länge der Seite 'b'.\n- c (float64): Länge der Seite 'c'.\n\nRückgabewerte:\n- float64: Wenn die angegebenen Seiten ein Dreieck bilden, gib die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls gib -1 zurück.\n\nBeispiele:\n\tcalculateTriangleArea(3, 5, 4)  // Gibt 6.00 zurück\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige yanki na alwatika idan aka ba da gefensa uku.\nSigogi:\n- a (float64): Tsawon gefen 'a'.\n- b (float64): Tsawon gefen 'b'.\n- c (float64): Tsawon gefen 'c'.\n\nDawowa:\n- float64: Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare guda 2 na ɗigo.\nIn ba haka ba, dawo da -1.\n\nMisalai:\n\tcalculateTriangleArea(3, 5, 4)  // Dawo da 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nकिसी त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\nपैरामीटर्स:\n- a (float64): भुजा 'a' की लंबाई।\n- b (float64): भुजा 'b' की लंबाई।\n- c (float64): भुजा 'c' की लंबाई।\n\nरिटर्न्स:\n- float64: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\nअन्यथा, -1 लौटाएं।\n\nउदाहरण:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 लौटाता है\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki egy háromszög területét a három oldalának ismeretében.\nParaméterek:\n- a (float64): Az 'a' oldal hossza.\n- b (float64): A 'b' oldal hossza.\n- c (float64): A 'c' oldal hossza.\n\nVisszatérési érték:\n- float64: Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEgyébként térjen vissza -1 értékkel.\n\nPéldák:\n\tcalculateTriangleArea(3, 5, 4)  // Visszatér 6.00\n*/\nfunc calculateTriangleArea(a, b, c float64) float64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9955560424851064",
      "hy": "0.9972867089950634",
      "bn": "0.9961390226534439",
      "bg": "1",
      "zh": "0.9848129196964535",
      "fr": "0.9844051315241888",
      "de": "0.9834991783562888",
      "ha": "0.8636036954294388",
      "hi": "0.9899312273549605",
      "hu": "0.9694538254829308"
    },
    "canonical_solution": "if a+b > c && a+c > b && b+c > a {\n\t\ts := (a + b + c) / 2.0\n\t\treturn math.Sqrt(s * (s - a) * (s - b) * (s - c))\n\t} else {\n\t\treturn -1 // Indicating it's not a triangle\n\t}\n}",
    "instruction": {
      "en": "Write a Go function `func calculateTriangleArea(a, b, c float64) float64` to solve the following problem:\nCalculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n",
      "sq": "Shkruani një funksion Go `func calculateTriangleArea(a, b, c float64) float64` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\nParametrat:\n- a (float64): Gjatësia e anës 'a'.\n- b (float64): Gjatësia e anës 'b'.\n- c (float64): Gjatësia e anës 'c'.\n\nKthen:\n- float64: Nëse anët e dhëna formojnë një trekëndësh, kthe sipërfaqen e llogaritur me 2 shifra dhjetore.\nPërndryshe, kthe -1.\n\nShembuj:\n\tcalculateTriangleArea(3, 5, 4)  // Kthen 6.00",
      "hy": "Գրեք Go ֆունկցիա `func calculateTriangleArea(a, b, c float64) float64` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\nՊարամետրեր:\n- a (float64): 'a' կողմի երկարությունը:\n- b (float64): 'b' կողմի երկարությունը:\n- c (float64): 'c' կողմի երկարությունը:\n\nՎերադարձնում է:\n- float64: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով:\nՀակառակ դեպքում, վերադարձնել -1:\n\nՕրինակներ:\n\tcalculateTriangleArea(3, 5, 4)  // Վերադարձնում է 6.00",
      "bn": "একটি Go ফাংশন `func calculateTriangleArea(a, b, c float64) float64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি বাহুর দৈর্ঘ্য দেওয়া হলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- a (float64): বাহু 'a' এর দৈর্ঘ্য।\n- b (float64): বাহু 'b' এর দৈর্ঘ্য।\n- c (float64): বাহু 'c' এর দৈর্ঘ্য।\n\nরিটার্নস:\n- float64: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান পর্যন্ত গণনা করা ক্ষেত্রফল রিটার্ন করুন।\nঅন্যথায়, -1 রিটার্ন করুন।\n\nউদাহরণসমূহ:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 রিটার্ন করে",
      "bg": "Напишете Go функция `func calculateTriangleArea(a, b, c float64) float64`, за да решите следния проблем:\nИзчислете лицето на триъгълник, дадени неговите три страни.\nПараметри:\n- a (float64): Дължина на страна 'a'.\n- b (float64): Дължина на страна 'b'.\n- c (float64): Дължина на страна 'c'.\n\nВръща:\n- float64: Ако предоставените страни образуват триъгълник, върнете изчисленото лице с 2 знака след десетичната запетая.\nВ противен случай върнете -1.\n\nПримери:\n\tcalculateTriangleArea(3, 5, 4)  // Връща 6.00",
      "zh": "编写一个 Go 函数 `func calculateTriangleArea(a, b, c float64) float64` 来解决以下问题：\n计算给定三边的三角形面积。\n参数：\n- a (float64): 边 'a' 的长度。\n- b (float64): 边 'b' 的长度。\n- c (float64): 边 'c' 的长度。\n\n返回：\n- float64: 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n否则，返回 -1。\n\n示例：\n\tcalculateTriangleArea(3, 5, 4)  // 返回 6.00",
      "fr": "Écrire une fonction Go `func calculateTriangleArea(a, b, c float64) float64` pour résoudre le problème suivant :\nCalculer l'aire d'un triangle donné ses trois côtés.\nParamètres :\n- a (float64) : Longueur du côté 'a'.\n- b (float64) : Longueur du côté 'b'.\n- c (float64) : Longueur du côté 'c'.\n\nRenvoie :\n- float64 : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie -1.\n\nExemples :\n\tcalculateTriangleArea(3, 5, 4)  // Renvoie 6.00",
      "de": "Schreiben Sie eine Go-Funktion `func calculateTriangleArea(a, b, c float64) float64`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\nParameter:\n- a (float64): Länge der Seite 'a'.\n- b (float64): Länge der Seite 'b'.\n- c (float64): Länge der Seite 'c'.\n\nRückgabewerte:\n- float64: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls geben Sie -1 zurück.\n\nBeispiele:\n\tcalculateTriangleArea(3, 5, 4)  // Gibt 6.00 zurück",
      "ha": "Rubuta aikin Go `func calculateTriangleArea(a, b, c float64) float64` don warware matsalar mai zuwa:\nLissafa yanki na alwatika idan aka ba da gefensa uku.\nSigogi:\n- a (float64): Tsawon gefen 'a'.\n- b (float64): Tsawon gefen 'b'.\n- c (float64): Tsawon gefen 'c'.\n\nDawowa:\n- float64: Idan aka bayar da gefen suna samar da alwatika, dawo da yankin da aka lissafa tare da wuraren goma biyu bayan maƙasudin.\nIn ba haka ba, dawo da -1.\n\nMisalai:\n\tcalculateTriangleArea(3, 5, 4)  // Yana dawowa 6.00",
      "hi": "Go फ़ंक्शन `func calculateTriangleArea(a, b, c float64) float64` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nइसके तीन भुजाओं के दिए जाने पर एक त्रिभुज का क्षेत्रफल गणना करें।\nपैरामीटर्स:\n- a (float64): भुजा 'a' की लंबाई।\n- b (float64): भुजा 'b' की लंबाई।\n- c (float64): भुजा 'c' की लंबाई।\n\nवापसी मान:\n- float64: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\nअन्यथा, -1 लौटाएँ।\n\nउदाहरण:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 लौटाता है",
      "hu": "Írj egy Go függvényt `func calculateTriangleArea(a, b, c float64) float64` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\nParaméterek:\n- a (float64): Az 'a' oldal hossza.\n- b (float64): A 'b' oldal hossza.\n- c (float64): A 'c' oldal hossza.\n\nVisszatérési érték:\n- float64: Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel 2 tizedesjegy pontossággal.\nEgyébként térj vissza -1 értékkel.\n\nPéldák:\n\tcalculateTriangleArea(3, 5, 4)  // Visszatér 6.00 értékkel"
    },
    "instruction_bertscore": {
      "sq": "0.9968312495313504",
      "hy": "0.9968312495313504",
      "bn": "0.979828290284383",
      "bg": "1",
      "zh": "0.9849767897608073",
      "fr": "0.9837009868234202",
      "de": "0.9917181062627504",
      "ha": "0.9949095005948378",
      "hi": "0.9741258106752524",
      "hu": "0.9735742141071185"
    },
    "level": "easy",
    "test": "func TestCalculateTriangleArea(t *testing.T) {\n\t// Using a small delta for floating point comparison\n\tconst delta = 1e-6\n\n\tassert := assert.New(t)\n\n\t// Triangle with sides 3, 5, 4 should return area 6.00\n\tassert.InDelta(6.00, calculateTriangleArea(3, 5, 4), delta)\n\n\t// Not a triangle with sides 1, 1, 4 should return -1\n\tassert.Equal(-1.0, calculateTriangleArea(1, 1, 4))\n\n\t// Triangle with sides 7, 24, 25 should return area 84.00\n\tassert.InDelta(84.00, calculateTriangleArea(7, 24, 25), delta)\n\n\t// Triangle with sides 10.5, 6.2, 7.3 should return close to calculated area\n\tassert.InDelta(22.15, calculateTriangleArea(10.5, 6.2, 7.3), 1e-2) // Looser delta for specific precision\n}",
    "entry_point": "calculateTriangleArea",
    "signature": "func calculateTriangleArea(a, b, c float64) float64",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\nParameters:\n- a (float64): Length of side 'a'.\n- b (float64): Length of side 'b'.\n- c (float64): Length of side 'c'.\n\nReturns:\n- float64: If the provided sides form a triangle, return the calculated area with 2 decimal places.\nOtherwise, return -1.\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // Returns 6.00\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\nParametrat:\n- a (float64): Gjatësia e anës 'a'.\n- b (float64): Gjatësia e anës 'b'.\n- c (float64): Gjatësia e anës 'c'.\n\nKthen:\n- float64: Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 shifra pas presjes dhjetore.\nPërndryshe, kthen -1.\n\nShembuj:\n\tcalculateTriangleArea(3, 5, 4)  // Kthen 6.00",
      "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը:\nՊարամետրեր:\n- a (float64): 'a' կողմի երկարությունը:\n- b (float64): 'b' կողմի երկարությունը:\n- c (float64): 'c' կողմի երկարությունը:\n\nՎերադարձնում է:\n- float64: Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնում է հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով:\nՀակառակ դեպքում, վերադարձնում է -1:\n\nՕրինակներ:\n\tcalculateTriangleArea(3, 5, 4)  // Վերադարձնում է 6.00",
      "bn": "ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- a (float64): বাহু 'a' এর দৈর্ঘ্য।\n- b (float64): বাহু 'b' এর দৈর্ঘ্য।\n- c (float64): বাহু 'c' এর দৈর্ঘ্য।\n\nরিটার্নস:\n- float64: যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান সহ গণনা করা ক্ষেত্রফল রিটার্ন করুন। অন্যথায়, -1 রিটার্ন করুন।\n\nউদাহরণসমূহ:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 রিটার্ন করে",
      "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\nПараметри:\n- a (float64): Дължина на страна 'a'.\n- b (float64): Дължина на страна 'b'.\n- c (float64): Дължина на страна 'c'.\n\nВръща:\n- float64: Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\nВ противен случай връща -1.\n\nПримери:\n\tcalculateTriangleArea(3, 5, 4)  // Връща 6.00",
      "zh": "计算给定三边的三角形面积。\n参数：\n- a (float64): 边 'a' 的长度。\n- b (float64): 边 'b' 的长度。\n- c (float64): 边 'c' 的长度。\n\n返回：\n- float64: 如果提供的边构成一个三角形，返回计算出的面积，保留两位小数。\n否则，返回 -1。\n\n示例：\n\tcalculateTriangleArea(3, 5, 4)  // 返回 6.00",
      "fr": "Calculer l'aire d'un triangle donné par ses trois côtés.\nParamètres :\n- a (float64) : Longueur du côté 'a'.\n- b (float64) : Longueur du côté 'b'.\n- c (float64) : Longueur du côté 'c'.\n\nRenvoie :\n- float64 : Si les côtés fournis forment un triangle, renvoie l'aire calculée avec 2 décimales.\nSinon, renvoie -1.\n\nExemples :\n\tcalculateTriangleArea(3, 5, 4)  // Renvoie 6.00",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\nParameter:\n- a (float64): Länge der Seite 'a'.\n- b (float64): Länge der Seite 'b'.\n- c (float64): Länge der Seite 'c'.\n\nRückgabewert:\n- float64: Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\nAndernfalls -1 zurückgeben.\n\nBeispiele:\n\tcalculateTriangleArea(3, 5, 4)  // Gibt 6.00 zurück",
      "ha": "Ƙididdige yanki na alwatika idan aka ba da gefensa uku.\nSigogi:  \n- a (float64): Tsawon gefen 'a'.  \n- b (float64): Tsawon gefen 'b'.  \n- c (float64): Tsawon gefen 'c'.  \n\nDawowa:  \n- float64: Idan gefen da aka bayar sun samar da kusurwa, dawo da yankin da aka lissafa tare da wurare guda 2 na adadi.  \nIn ba haka ba, dawo da -1.  \n\nMisalai:  \n\tcalculateTriangleArea(3, 5, 4)  // Dawo da 6.00  ",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\nParameters:\n- a (float64): भुजा 'a' की लंबाई।\n- b (float64): भुजा 'b' की लंबाई।\n- c (float64): भुजा 'c' की लंबाई।\n\nReturns:\n- float64: यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं। अन्यथा, -1 लौटाएं।\n\nExamples:\n\tcalculateTriangleArea(3, 5, 4)  // 6.00 लौटाता है।",
      "hu": "Számítsa ki egy háromszög területét a három oldalának megadása alapján.\nParaméterek:\n- a (float64): Az 'a' oldal hossza.\n- b (float64): A 'b' oldal hossza.\n- c (float64): A 'c' oldal hossza.\n\nVisszatérési érték:\n- float64: Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegy pontossággal. Ellenkező esetben adja vissza a -1 értéket.\n\nPéldák:\n\tcalculateTriangleArea(3, 5, 4)  // Visszaadja: 6.00"
    },
    "docstring_bertscore": {
      "sq": "0.9921197368932029",
      "hy": "0.9921197368932029",
      "bn": "0.9958367072135087",
      "bg": "0.9943128149302091",
      "zh": "0.9792045908879334",
      "fr": "0.9742819341547457",
      "de": "0.9829952530796032",
      "ha": "0.9958367072135087",
      "hi": "0.9855069342477893",
      "hu": "0.9473458668129856"
    }
  },
  {
    "task_id": "Go/2",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "sq": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit vlerën e funksionit për një hyrje të dhënë.\nParametrat:\n- x (int): Vlera e hyrjes për funksionin.\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "hy": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\nՊարամետրեր:\n- x (int): Ֆունկցիայի մուտքային արժեքը։\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "bn": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\nপ্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\nফেরত দেয়:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" ফেরত দেয়।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে ফেরত দেয়।\n\nফাংশন সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "bg": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислява стойността на функцията за даден вход.\nПараметри:\n- x (int): Входна стойност за функцията.\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "zh": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定输入的函数值。\n参数:\n- x (int): 函数的输入值。\n返回:\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算的函数值，四舍五入到小数点后5位。\n\n函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "fr": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la valeur de la fonction pour une entrée donnée.\nParamètres:\n- x (int): Valeur d'entrée pour la fonction.\nRenvoie:\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "de": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechnet den Wert der Funktion für eine gegebene Eingabe.\nParameter:\n- x (int): Eingabewert für die Funktion.\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "ha": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige ƙimar aikin don wani shigarwar da aka bayar.\nSigogi:\n- x (int): Ƙimar shigarwa don aikin.\nMayar da:\n- string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige an zagaye zuwa wurare 5 na decimal.\n\nMa'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "hi": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\nपैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\nरिटर्न्स:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {",
      "hu": "package main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a függvény értékét egy adott bemenetre.\nParaméterek:\n- x (int): A függvény bemeneti értéke.\nVisszatér:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n\nFüggvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"\n*/\nfunc calculateFunctionValue(x int) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9870326142045184",
      "hy": "0.953587627906626",
      "bn": "0.9840722270055744",
      "bg": "0.9864492367754188",
      "zh": "0.9813297373346257",
      "fr": "0.978297048676985",
      "de": "0.9734683441140268",
      "ha": "0.9851968722229939",
      "hi": "0.9843199190907249",
      "hu": "0.9791684401585851"
    },
    "canonical_solution": "if 0 <= x && x < 10 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Cos(float64(x)+3.0))\n\t} else if 10 <= x && x < 20 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+7.5), 2.0))\n\t} else if 20 <= x && x < 30 {\n\t\treturn fmt.Sprintf(\"%.5f\", math.Pow(math.Cos(float64(x)+4.0), 4.0))\n\t}\n\treturn \"Not define\"\n}",
    "instruction": {
      "en": "Write a Go function `func calculateFunctionValue(x int) string` to solve the following problem:\nCalculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "sq": "Shkruani një funksion Go `func calculateFunctionValue(x int) string` për të zgjidhur problemin e mëposhtëm:\nLlogaritni vlerën e funksionit për një hyrje të dhënë.\nParametrat:\n- x (int): Vlera e hyrjes për funksionin.\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hy": "Գրեք Go ֆունկցիա `func calculateFunctionValue(x int) string` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ֆունկցիայի արժեքը տրված մուտքագրման համար:\nՊարամետրեր:\n- x (int): Մուտքագրման արժեք ֆունկցիայի համար:\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\":\nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան:\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "bn": "Go ফাংশন `func calculateFunctionValue(x int) string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\nপ্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\nরিটার্নস:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\nফাংশন সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "bg": "Напишете Go функция `func calculateFunctionValue(x int) string`, за да решите следния проблем:\nИзчислете стойността на функцията за даден вход.\nПараметри:\n- x (int): Входна стойност за функцията.\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "zh": "编写一个 Go 函数 `func calculateFunctionValue(x int) string` 来解决以下问题：\n计算给定输入的函数值。\n参数：\n- x (int): 函数的输入值。\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留 5 位小数。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "fr": "Écrire une fonction Go `func calculateFunctionValue(x int) string` pour résoudre le problème suivant :\nCalculer la valeur de la fonction pour une entrée donnée.\nParamètres :\n- x (int) : Valeur d'entrée pour la fonction.\nRetourne :\n- string : Si x n'est pas dans le domaine défini, retourne \"Not define\".\nSinon, retourne la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction :\n- Pour 0 <= x < 10 : y = cos(x + 3.0)\n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "de": "Schreiben Sie eine Go-Funktion `func calculateFunctionValue(x int) string`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe.\nParameter:\n- x (int): Eingabewert für die Funktion.\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, gibt \"Not define\" zurück.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "ha": "Rubuta aikin Go `func calculateFunctionValue(x int) string` don warware matsalar mai zuwa:\nƘididdige ƙimar aikin don wani shigarwar da aka bayar.\nSigogi:\n- x (int): Ƙimar shigarwa don aikin.\nMayarwa:\n- string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\nIn ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige tare da zaurawa zuwa wurare 5 na goma.\n\nƘayyade Ayyuka:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hi": "Go फ़ंक्शन `func calculateFunctionValue(x int) string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\nपैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hu": "Írj egy Go függvényt `func calculateFunctionValue(x int) string` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre.\nParaméterek:\n- x (int): A függvény bemeneti értéke.\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, térjen vissza \"Not define\" értékkel.\nEgyébként térjen vissza a kiszámított függvényértékkel, 5 tizedesjegyre kerekítve.\n\nFüggvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\""
    },
    "instruction_bertscore": {
      "sq": "0.9852224955421475",
      "hy": "0.9449243638377893",
      "bn": "0.9769515264758547",
      "bg": "0.9880601291656118",
      "zh": "0.9688442288435347",
      "fr": "0.979532331016641",
      "de": "0.9806812091405468",
      "ha": "0.9757162441361987",
      "hi": "0.9652921217394878",
      "hu": "0.9664878766333178"
    },
    "level": "middle",
    "test": "func TestCalculateFunctionValue(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Not define\", calculateFunctionValue(40)) // the provided test case\n\n\t// Additional test cases based on provided function definitions\n\tassert.Equal(\"Not define\", calculateFunctionValue(40))\n\tassert.Equal(\"-0.14550\", calculateFunctionValue(5))\n\tassert.Equal(\"0.76266\", calculateFunctionValue(15))\n\tassert.Equal(\"0.31314\", calculateFunctionValue(25))\n\tassert.Equal(\"Not define\", calculateFunctionValue(-1))\n}",
    "entry_point": "calculateFunctionValue",
    "signature": "func calculateFunctionValue(x int) string",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\nParameters:\n- x (int): Input value for the function.\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\nOtherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\nParametrat:\n- x (int): Vlera e hyrjes për funksionin.\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\nPërndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërcaktimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hy": "Հաշվել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։ \nՊարամետրեր:\n- x (int): Մուտքային արժեք ֆունկցիայի համար։\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ \nՀակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "bn": "ফাংশনের মান নির্ধারিত ইনপুটের জন্য গণনা করুন।\nপ্যারামিটারসমূহ:\n- x (int): ফাংশনের জন্য ইনপুট মান।\nফেরত দেয়:\n- string: যদি x নির্ধারিত ডোমেইনে না থাকে, তাহলে \"Not define\" ফেরত দেয়।\nঅন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থান পর্যন্ত রাউন্ড করে ফেরত দেয়।\n\nফাংশনের সংজ্ঞা:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "bg": "Изчислява стойността на функцията за даден вход.\nПараметри:\n- x (int): Входна стойност за функцията.\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\nВ противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "zh": "计算给定输入的函数值。\n参数：\n- x (int): 函数的输入值。\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n否则，返回计算后的函数值，保留 5 位小数。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée.\nParamètres:\n- x (int): Valeur d'entrée pour la fonction.\nRenvoie:\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\nSinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction:\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\nParameter:\n- x (int): Eingabewert für die Funktion.\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Nicht definiert\" zurückgegeben.\nAndernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Nicht definiert\"",
      "ha": "Ƙididdige ƙimar aikin don wani shigarwar da aka bayar.\nSigogi:\n- x (int): Darajar shigarwa don aikin.\nDawowa:\n- string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\".\nIn ba haka ba, yana dawowa da darajar aikin da aka lissafa an zagaye zuwa wurare 5 na ƙidaya.\n\nMa'anar Ayyuka:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\nपैरामीटर्स:\n- x (int): फ़ंक्शन के लिए इनपुट मान।\nReturns:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\nअन्यथा, गणना की गई फ़ंक्शन मान को 5 दशमलव स्थानों तक गोल करके लौटाता है।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\"",
      "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\nParaméterek:\n- x (int): A függvény bemeneti értéke.\nVisszatér:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\nEgyébként a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve.\n\nFüggvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\t>>> calculateFunctionValue(40)\n\t\"Not define\""
    },
    "docstring_bertscore": {
      "sq": "0.9854519136322427",
      "hy": "0.9490860675812323",
      "bn": "0.9655445809537831",
      "bg": "0.9847725977291034",
      "zh": "0.9775301367758094",
      "fr": "0.9757990730050903",
      "de": "0.964888703435606",
      "ha": "0.9802134345932096",
      "hi": "0.9902220222327955",
      "hu": "0.9713483620572415"
    }
  },
  {
    "task_id": "Go/3",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nFunksioni kthen dy vlera: numrin e plotë maksimal dhe minimal.\n\nShembull përdorimi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\n\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nՖունկցիան վերադարձնում է երկու արժեք՝ առավելագույն և նվազագույն ամբողջ թիվը։\n\nՕգտագործման օրինակ:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n\nপ্যারামিটার:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nরিটার্নস:\nফাংশনটি দুটি মান রিটার্ন করে: সর্বাধিক এবং সর্বনিম্ন পূর্ণসংখ্যা।\n\nউদাহরণ ব্যবহার:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nНамерете максимума и минимума на три различни цели числа.\n\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nФункцията връща две стойности: максималното и минималното цяло число.\n\nПример за използване:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n找出三个不同整数的最大值和最小值。\n\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回值：\n该函数返回两个值：最大整数和最小整数。\n\n示例用法：\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\n\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRetourne :\nLa fonction retourne deux valeurs : l'entier max et min.\n\nExemple d'utilisation :\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nDie Funktion gibt zwei Werte zurück: die maximale und minimale ganze Zahl.\n\nBeispielverwendung:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu banbanci.\n\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nAikin yana dawowa da ƙimar biyu: mafi girma da mafi ƙanƙanta lamba.\n\nMisalin amfani:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nतीन भिन्न पूर्णांकों में से अधिकतम और न्यूनतम खोजें।\n\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nयह फ़ंक्शन दो मान लौटाता है: अधिकतम और न्यूनतम पूर्णांक।\n\nउदाहरण उपयोग:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTalálja meg három különböző egész szám maximumát és minimumát.\n\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési értékek:\nA függvény két értéket ad vissza: a maximum és minimum egész számot.\n\nPélda használat:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)\n*/\nfunc FindMaxMin(a, b, c int) (int, int) {"
    },
    "prompt_bertscore": {
      "sq": "0.9911647220211871",
      "hy": "0.9911647220211871",
      "bn": "0.9786899395706721",
      "bg": "0.9933715055544847",
      "zh": "0.9805773254512655",
      "fr": "0.9977872575552713",
      "de": "0.989484507628013",
      "ha": "0.9590515524281337",
      "hi": "0.9727723432588806",
      "hu": "0.989484507628013"
    },
    "canonical_solution": "var max, min int\n\tif a > b {\n\t\tif a > c {\n\t\t\tmax = a\n\t\t\tmin = minInt(b, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = b\n\t\t}\n\t} else {\n\t\tif b > c {\n\t\t\tmax = b\n\t\t\tmin = minInt(a, c)\n\t\t} else {\n\t\t\tmax = c\n\t\t\tmin = a\n\t\t}\n\t}\n\treturn max, min\n}\n\n// Helper function to find the minimum of two integers\nfunc minInt(x, y int) int {\n\tif x < y {\n\t\treturn x\n\t}\n\treturn y\n}",
    "instruction": {
      "en": "Write a Go function `func FindMaxMin(a, b, c int) (int, int)` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "sq": "Shkruani një funksion në Go `func FindMaxMin(a, b, c int) (int, int)` për të zgjidhur problemin e mëposhtëm:\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nFunksioni kthen dy vlera: numrin maksimal dhe minimal.\n\nShembull përdorimi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hy": "Գրեք Go ֆունկցիա `func FindMaxMin(a, b, c int) (int, int)` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\n\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nՖունկցիան վերադարձնում է երկու արժեք՝ առավելագույն և նվազագույն ամբողջ թիվը։\n\nՕգտագործման օրինակ:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "bn": "একটি Go ফাংশন `func FindMaxMin(a, b, c int) (int, int)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পৃথক পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজুন।\n\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফাংশনটি দুটি মান ফেরত দেয়: সর্বাধিক এবং সর্বনিম্ন পূর্ণসংখ্যা।\n\nউদাহরণ ব্যবহার:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "bg": "Напишете Go функция `func FindMaxMin(a, b, c int) (int, int)` за решаване на следния проблем:  \nНамерете максимума и минимума на три различни цели числа.\n\nПараметри:  \na (int): Първото цяло число.  \nb (int): Второто цяло число.  \nc (int): Третото цяло число.\n\nВръща:  \nФункцията връща две стойности: максималното и минималното цяло число.\n\nПример за използване:  \nmax, min := FindMaxMin(1, 2, 3)  \nassert.Equal(t, 3, max)  \nassert.Equal(t, 1, min)",
      "zh": "编写一个 Go 函数 `func FindMaxMin(a, b, c int) (int, int)` 来解决以下问题：\n找出三个不同整数的最大值和最小值。\n\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回值：\n该函数返回两个值：最大整数和最小整数。\n\n示例用法：\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "fr": "Écrire une fonction Go `func FindMaxMin(a, b, c int) (int, int)` pour résoudre le problème suivant :\nTrouver le maximum et le minimum de trois entiers distincts.\n\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRetourne :\nLa fonction retourne deux valeurs : l'entier max et min.\n\nExemple d'utilisation :\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "de": "Schreiben Sie eine Go-Funktion `func FindMaxMin(a, b, c int) (int, int)`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nDie Funktion gibt zwei Werte zurück: die maximale und die minimale ganze Zahl.\n\nBeispielverwendung:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "ha": "Rubuta aikin Go `func FindMaxMin(a, b, c int) (int, int)` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanci.\n\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nAikin yana dawowa da ƙimar biyu: mafi girma da mafi ƙanƙanta lamba.\n\nMisalin amfani:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hi": "Go फ़ंक्शन `func FindMaxMin(a, b, c int) (int, int)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम खोजें।\n\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nफ़ंक्शन दो मान लौटाता है: अधिकतम और न्यूनतम पूर्णांक।\n\nउदाहरण उपयोग:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hu": "Írj egy Go függvényt `func FindMaxMin(a, b, c int) (int, int)` a következő probléma megoldására:\nHárom különböző egész szám maximumának és minimumának megtalálása.\n\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési értékek:\nA függvény két értéket ad vissza: a maximum és minimum egész számot.\n\nPélda használat:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)"
    },
    "instruction_bertscore": {
      "sq": "0.9815504156879554",
      "hy": "0.98988315880275",
      "bn": "0.9651322242827547",
      "bg": "0.9881755334169932",
      "zh": "0.9746921058915828",
      "fr": "0.9949676992964811",
      "de": "0.9836815210460788",
      "ha": "0.9549498350597633",
      "hi": "0.9617896722306996",
      "hu": "0.9869628949407752"
    },
    "level": "middle",
    "test": "func TestFindMaxMin(t *testing.T) {\n\tassert := assert.New(t)\n\tvar max, min int\n\n\tmax, min = FindMaxMin(1, 2, 3)\n\tassert.Equal(3, max)\n\tassert.Equal(1, min)\n\n\t// Additional tests\n\tmax, min = FindMaxMin(5, 3, 4)\n\tassert.Equal(5, max)\n\tassert.Equal(3, min)\n\n\tmax, min = FindMaxMin(10, -2, 7)\n\tassert.Equal(10, max)\n\tassert.Equal(-2, min)\n\n\tmax, min = FindMaxMin(-1, -3, -2)\n\tassert.Equal(-1, max)\n\tassert.Equal(-3, min)\n}",
    "entry_point": "FindMaxMin",
    "signature": "func FindMaxMin(a, b, c int) (int, int)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\n\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nThe function returns two values: the max and min integer.\n\nExample usage:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nFunksioni kthen dy vlera: numrin maksimal dhe minimal.\n\nShembull përdorimi:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\n\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nՖունկցիան վերադարձնում է երկու արժեք՝ առավելագույն և նվազագույն ամբողջ թիվը:\n\nՕրինակ օգտագործում:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত দেয়:\nফাংশনটি দুটি মান ফেরত দেয়: সর্বাধিক এবং সর্বনিম্ন পূর্ণসংখ্যা।\n\nব্যবহারের উদাহরণ:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "bg": "Намерете максимума и минимума на три различни цели числа.\n\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nФункцията връща две стойности: максималното и минималното цяло число.\n\nПример за използване:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "zh": "找出三个不同整数的最大值和最小值。\n\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\n该函数返回两个值：最大整数和最小整数。\n\n示例用法：\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.\n\nParamètres:\na (int): Le premier entier.\nb (int): Le deuxième entier.\nc (int): Le troisième entier.\n\nRenvoie:\nLa fonction renvoie deux valeurs : l'entier max et min.\n\nExemple d'utilisation:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nDie Funktion gibt zwei Werte zurück: die maximale und minimale ganze Zahl.\n\nBeispielverwendung:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\n\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nAiki yana dawowa da ƙimar biyu: mafi girma da mafi ƙanƙanta lamba.\n\nMisalin amfani:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम खोजें।\n\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nयह फ़ंक्शन दो मान लौटाता है: अधिकतम और न्यूनतम पूर्णांक।\n\nउदाहरण उपयोग:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)",
      "hu": "Három különböző egész szám maximumának és minimumának meghatározása.\n\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési értékek:\nA függvény két értéket ad vissza: a max és min egész számot.\n\nPélda használat:\nmax, min := FindMaxMin(1, 2, 3)\nassert.Equal(t, 3, max)\nassert.Equal(t, 1, min)"
    },
    "docstring_bertscore": {
      "sq": "0.9862114762093201",
      "hy": "0.9901467413183833",
      "bn": "0.9711447659166808",
      "bg": "0.9901467413183833",
      "zh": "0.9671165417892932",
      "fr": "0.9937073895288148",
      "de": "0.984758693602431",
      "ha": "0.9407316737549049",
      "hi": "0.9643265794572772",
      "hu": "0.973287193206523"
    }
  },
  {
    "task_id": "Go/4",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (float64): koordinata x e pikës A.\n- ya (float64): koordinata y e pikës A.\n- xb (float64): koordinata x e pikës B.\n- yb (float64): koordinata y e pikës B.\n\nKthen:\nfloat64: Distanca midis pikave A dhe B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվարկել երկու կետերի A (xa, ya) և B (xb, yb) միջև հեռավորությունը:\n\nՊարամետրեր:\n- xa (float64): A կետի x-կոորդինատը։\n- ya (float64): A կետի y-կոորդինատը։\n- xb (float64): B կետի x-կոորդինատը։\n- yb (float64): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nfloat64: A և B կետերի միջև հեռավորությունը։\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (float64): বিন্দু A এর x-সমন্বয়।\n- ya (float64): বিন্দু A এর y-সমন্বয়।\n- xb (float64): বিন্দু B এর x-সমন্বয়।\n- yb (float64): বিন্দু B এর y-সমন্বয়।\n\nফেরত দেয়:\nfloat64: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (float64): x-координата на точка A.\n- ya (float64): y-координата на точка A.\n- xb (float64): x-координата на точка B.\n- yb (float64): y-координата на точка B.\n\nВръща:\nfloat64: Разстоянието между точките A и B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数:\n- xa (float64): 点 A 的 x 坐标。\n- ya (float64): 点 A 的 y 坐标。\n- xb (float64): 点 B 的 x 坐标。\n- yb (float64): 点 B 的 y 坐标。\n\n返回值:\nfloat64: 点 A 和 B 之间的距离。\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres:\n- xa (float64): coordonnée x du point A.\n- ya (float64): coordonnée y du point A.\n- xb (float64): coordonnée x du point B.\n- yb (float64): coordonnée y du point B.\n\nRenvoie:\nfloat64: La distance entre les points A et B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (float64): x-Koordinate von Punkt A.\n- ya (float64): y-Koordinate von Punkt A.\n- xb (float64): x-Koordinate von Punkt B.\n- yb (float64): y-Koordinate von Punkt B.\n\nRückgabewert:\nfloat64: Die Entfernung zwischen den Punkten A und B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (float64): x-daftarin maki A.\n- ya (float64): y-daftarin maki A.\n- xb (float64): x-daftarin maki B.\n- yb (float64): y-daftarin maki B.\n\nDawowa:\nfloat64: Nisan tsakanin maki A da B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर:\n- xa (float64): बिंदु A का x-निर्देशांक।\n- ya (float64): बिंदु A का y-निर्देशांक।\n- xb (float64): बिंदु B का x-निर्देशांक।\n- yb (float64): बिंदु B का y-निर्देशांक।\n\nवापसी करता है:\nfloat64: बिंदुओं A और B के बीच की दूरी।\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (float64): A pont x-koordinátája.\n- ya (float64): A pont y-koordinátája.\n- xb (float64): B pont x-koordinátája.\n- yb (float64): B pont y-koordinátája.\n\nVisszatér:\nfloat64: A távolság A és B pontok között.\n   >>> calculateDistance(0, 0, 3, 4)\n   5\n*/\nfunc calculateDistance(xa, ya, xb, yb float64) float64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9777188356377925",
      "hy": "0.9970171675679991",
      "bn": "0.9973365652207031",
      "bg": "1",
      "zh": "0.9802376674996959",
      "fr": "1",
      "de": "0.9957461317597568",
      "ha": "1",
      "hi": "0.9973365652207031",
      "hu": "0.8556809254211003"
    },
    "canonical_solution": "return math.Sqrt((xa-xb)*(xa-xb) + (ya-yb)*(ya-yb))\n}",
    "instruction": {
      "en": "Write a Go function `func calculateDistance(xa, ya, xb, yb float64) float64` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "sq": "Shkruani një funksion Go `func calculateDistance(xa, ya, xb, yb float64) float64` për të zgjidhur problemin në vijim:\nLlogaritni distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (float64): koordinata x e pikës A.\n- ya (float64): koordinata y e pikës A.\n- xb (float64): koordinata x e pikës B.\n- yb (float64): koordinata y e pikës B.\n\nKthen:\nfloat64: Distanca midis pikave A dhe B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hy": "Գրեք Go ֆունկցիա `func calculateDistance(xa, ya, xb, yb float64) float64` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք A (xa, ya) և B (xb, yb) կետերի միջև հեռավորությունը:\n\nՊարամետրեր:\n- xa (float64): A կետի x-կոորդինատը։\n- ya (float64): A կետի y-կոորդինատը։\n- xb (float64): B կետի x-կոորդինատը։\n- yb (float64): B կետի y-կոորդինատը։\n\nՎերադարձնում է:\nfloat64: A և B կետերի միջև հեռավորությունը։\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "bn": "একটি Go ফাংশন `func calculateDistance(xa, ya, xb, yb float64) float64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (float64): বিন্দু A এর x-সমন্বয়।\n- ya (float64): বিন্দু A এর y-সমন্বয়।\n- xb (float64): বিন্দু B এর x-সমন্বয়।\n- yb (float64): বিন্দু B এর y-সমন্বয়।\n\nরিটার্ন করে:\nfloat64: বিন্দু A এবং B এর মধ্যে দূরত্ব।",
      "bg": "Напишете функция на Go `func calculateDistance(xa, ya, xb, yb float64) float64`, за да решите следния проблем:\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (float64): x-координата на точка A.\n- ya (float64): y-координата на точка A.\n- xb (float64): x-координата на точка B.\n- yb (float64): y-координата на точка B.\n\nВръща:\nfloat64: Разстоянието между точките A и B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "zh": "编写一个 Go 函数 `func calculateDistance(xa, ya, xb, yb float64) float64` 来解决以下问题：\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (float64): 点 A 的 x 坐标。\n- ya (float64): 点 A 的 y 坐标。\n- xb (float64): 点 B 的 x 坐标。\n- yb (float64): 点 B 的 y 坐标。\n\n返回：\nfloat64: 点 A 和 B 之间的距离。\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "fr": "Écrire une fonction Go `func calculateDistance(xa, ya, xb, yb float64) float64` pour résoudre le problème suivant :\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (float64): coordonnée x du point A.\n- ya (float64): coordonnée y du point A.\n- xb (float64): coordonnée x du point B.\n- yb (float64): coordonnée y du point B.\n\nRenvoie :\nfloat64: La distance entre les points A et B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "de": "Schreiben Sie eine Go-Funktion `func calculateDistance(xa, ya, xb, yb float64) float64`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (float64): x-Koordinate des Punktes A.\n- ya (float64): y-Koordinate des Punktes A.\n- xb (float64): x-Koordinate des Punktes B.\n- yb (float64): y-Koordinate des Punktes B.\n\nRückgabewert:\nfloat64: Die Entfernung zwischen den Punkten A und B.",
      "ha": "Rubuta aikin Go `func calculateDistance(xa, ya, xb, yb float64) float64` don warware matsalar mai zuwa:\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (float64): x-tsarin maki A.\n- ya (float64): y-tsarin maki A.\n- xb (float64): x-tsarin maki B.\n- yb (float64): y-tsarin maki B.\n\nDawowa:\nfloat64: Nisan tsakanin maki A da B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hi": "Go फ़ंक्शन `func calculateDistance(xa, ya, xb, yb float64) float64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (float64): बिंदु A का x-निर्देशांक।\n- ya (float64): बिंदु A का y-निर्देशांक।\n- xb (float64): बिंदु B का x-निर्देशांक।\n- yb (float64): बिंदु B का y-निर्देशांक।\n\nवापसी:\nfloat64: बिंदुओं A और B के बीच की दूरी।",
      "hu": "Írj egy Go függvényt `func calculateDistance(xa, ya, xb, yb float64) float64` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (float64): A pont x-koordinátája.\n- ya (float64): A pont y-koordinátája.\n- xb (float64): B pont x-koordinátája.\n- yb (float64): B pont y-koordinátája.\n\nVisszatérési érték:\nfloat64: A távolság A és B pontok között.\n   >>> calculateDistance(0, 0, 3, 4)\n   5"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9918364899698471",
      "bn": "0.9688485987119174",
      "bg": "1",
      "zh": "0.997187195174165",
      "fr": "1",
      "de": "0.9676423164078926",
      "ha": "1",
      "hi": "0.9541936491991634",
      "hu": "0.9734679468532648"
    },
    "level": "easy",
    "test": "func TestCalculateDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.InDelta(5, calculateDistance(0, 0, 3, 4), 1e-6)\n\tassert.InDelta(0, calculateDistance(0, 0, 0, 0), 1e-6)\n\tassert.InDelta(4.242640687, calculateDistance(-1, -1, 2, 2), 1e-6)\n\tassert.InDelta(5.68243, calculateDistance(1.5, 3.9, 4.2, -1.1), 1e-6)\n}",
    "entry_point": "calculateDistance",
    "signature": "func calculateDistance(xa, ya, xb, yb float64) float64",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (float64): x-coordinate of point A.\n- ya (float64): y-coordinate of point A.\n- xb (float64): x-coordinate of point B.\n- yb (float64): y-coordinate of point B.\n\nReturns:\nfloat64: The distance between points A and B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (float64): koordinata x e pikës A.\n- ya (float64): koordinata y e pikës A.\n- xb (float64): koordinata x e pikës B.\n- yb (float64): koordinata y e pikës B.\n\nKthen:\nfloat64: Distanca midis pikave A dhe B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hy": "Հաշվարկել երկու կետերի A (xa, ya) և B (xb, yb) միջև հեռավորությունը:\n\nՊարամետրեր:\n- xa (float64): A կետի x-համակարգային կոորդինատը:\n- ya (float64): A կետի y-համակարգային կոորդինատը:\n- xb (float64): B կետի x-համակարգային կոորդինատը:\n- yb (float64): B կետի y-համակարգային կոորդինատը:\n\nՎերադարձնում է:\nfloat64: A և B կետերի միջև հեռավորությունը:\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (float64): বিন্দু A এর x-সমন্বয়।\n- ya (float64): বিন্দু A এর y-সমন্বয়।\n- xb (float64): বিন্দু B এর x-সমন্বয়।\n- yb (float64): বিন্দু B এর y-সমন্বয়।\n\nফেরত দেয়:\nfloat64: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "bg": "Изчисляване на разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (float64): x-координата на точка A.\n- ya (float64): y-координата на точка A.\n- xb (float64): x-координата на точка B.\n- yb (float64): y-координата на точка B.\n\nВръща:\nfloat64: Разстоянието между точките A и B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "zh": "计算两点A (xa, ya)和B (xb, yb)之间的距离。\n\n参数：\n- xa (float64): 点A的x坐标。\n- ya (float64): 点A的y坐标。\n- xb (float64): 点B的x坐标。\n- yb (float64): 点B的y坐标。\n\n返回：\nfloat64: 点A和B之间的距离。\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres:\n- xa (float64): coordonnée x du point A.\n- ya (float64): coordonnée y du point A.\n- xb (float64): coordonnée x du point B.\n- yb (float64): coordonnée y du point B.\n\nRenvoie:\nfloat64: La distance entre les points A et B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "de": "Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (float64): x-Koordinate des Punktes A.\n- ya (float64): y-Koordinate des Punktes A.\n- xb (float64): x-Koordinate des Punktes B.\n- yb (float64): y-Koordinate des Punktes B.\n\nRückgabewert:\nfloat64: Die Entfernung zwischen den Punkten A und B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "ha": "Ƙididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (float64): x-kordine na aya A.\n- ya (float64): y-kordine na aya A.\n- xb (float64): x-kordine na aya B.\n- yb (float64): y-kordine na aya B.\n\nAbin da ya dawo:\nfloat64: Nisan tsakanin maki A da B.\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (float64): बिंदु A का x-निर्देशांक।\n- ya (float64): बिंदु A का y-निर्देशांक।\n- xb (float64): बिंदु B का x-निर्देशांक।\n- yb (float64): बिंदु B का y-निर्देशांक।\n\nरिटर्न्स:\nfloat64: बिंदुओं A और B के बीच की दूरी।\n   >>> calculateDistance(0, 0, 3, 4)\n   5",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (float64): A pont x-koordinátája.\n- ya (float64): A pont y-koordinátája.\n- xb (float64): B pont x-koordinátája.\n- yb (float64): B pont y-koordinátája.\n\nVisszatérési érték:\nfloat64: Az A és B pontok közötti távolság.\n   >>> calculateDistance(0, 0, 3, 4)\n   5"
    },
    "docstring_bertscore": {
      "sq": "0.9668291236279357",
      "hy": "0.9968239002072521",
      "bn": "0.99712482523452",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.9859921882686576",
      "ha": "1",
      "hi": "0.99712482523452",
      "hu": "0.9640832572405095"
    }
  },
  {
    "task_id": "Go/5",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n*/\nfunc processRequest(n int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGjeni faktorialin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\nint: Rezultati pas marrjes së modulo 10007 të daljes.\n\nShembuj:\n    ExtraNumber(1)    // kthen 1\n*/\nfunc processRequest(n int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլոով։\n\nՊարամետրեր:\n- N (int): Թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\nint: Արդյունքը 10007 մոդուլոով վերցնելուց հետո։\n\nՕրինակներ:\n    ExtraNumber(1)    // վերադարձնում է 1\n*/\nfunc processRequest(n int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nরিটার্নস:\nint: আউটপুটের 10007 এর মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\n    ExtraNumber(1)    // 1 রিটার্ন করে\n*/\nfunc processRequest(n int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nНамерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след вземане на модуло 10007 от изхода.\n\nПримери:\n    ExtraNumber(1)    // връща 1\n*/\nfunc processRequest(n int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n找到N的阶乘并对结果取模10007。\n\n参数:\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回:\nint: 对输出取模10007后的结果。\n\n示例:\n    ExtraNumber(1)    // 返回 1\n*/\nfunc processRequest(n int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrouver le factoriel de N et prendre le modulo 10007 du résultat.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir pris le modulo 10007 de la sortie.\n\nExemples:\n    ExtraNumber(1)    // renvoie 1\n*/\nfunc processRequest(n int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFinde die Fakultät von N und nimm das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (int): Eine Ganzzahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach dem Nehmen des Modulo 10007 des Outputs.\n\nBeispiele:\n    ExtraNumber(1)    // gibt 1 zurück\n*/\nfunc processRequest(n int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNemo factorial na N kuma a dauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan daukar modulo 10007 na fitarwa.\n\nMisalai:\n    ExtraNumber(1)    // yana dawowa 1\n*/\nfunc processRequest(n int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nN का फैक्टोरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n\nपैरामीटर्स:\n- N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी मान:\nint: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n    ExtraNumber(1)    // returns 1\n*/\nfunc processRequest(n int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (int): Egy egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n\nVisszatér:\nint: Az eredmény, miután vettük a 10007-es modulóját.\n\nPéldák:\n    ExtraNumber(1)    // visszaadja 1\n*/\nfunc processRequest(n int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9895367474182252",
      "hy": "0.9633445508534407",
      "bn": "0.9764678614980348",
      "bg": "0.9895367474182252",
      "zh": "0.979321981443125",
      "fr": "1",
      "de": "0.9862059145586511",
      "ha": "0.9954017066790424",
      "hi": "0.9711628412813549",
      "hu": "0.9691352223517508"
    },
    "canonical_solution": "if n == 0 || n == 1 {\n\t\treturn 1\n\t}\n\n\ta := make([]int, 10001)\n\ta[1] = 1\n\tfor i := 2; i <= 10000; i++ {\n\t\ta[i] = (a[i-1] * i) % 10007\n\t}\n\treturn a[n]\n}",
    "instruction": {
      "en": "Write a Go function `func processRequest(n int) int` to solve the following problem:\nFind the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n",
      "sq": "Shkruani një funksion Go `func processRequest(n int) int` për të zgjidhur problemin e mëposhtëm:\nGjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n\nKthen:\nint: Rezultati pasi të merret modulo 10007 i daljes.\n\nShembuj:\n    ExtraNumber(1)    // kthen 1",
      "hy": "Գրեք Go ֆունկցիա `func processRequest(n int) int` հետևյալ խնդիրը լուծելու համար:\nԳտնել N-ի ֆակտորիալը և արդյունքը վերցնել 10007 մոդուլով։\n\nՊարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000):\n\nՎերադարձնում է:\nint: Արդյունքը 10007 մոդուլով վերցնելուց հետո։\n\nՕրինակներ:\n    ExtraNumber(1)    // վերադարձնում է 1",
      "bn": "একটি Go ফাংশন `func processRequest(n int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nরিটার্নস:\nint: আউটপুটের 10007 এর মডুলো নেওয়ার পরের ফলাফল।\n\nউদাহরণসমূহ:\n    ExtraNumber(1)    // returns 1",
      "bg": "Напишете функция на Go `func processRequest(n int) int`, за да решите следния проблем:  \nНамерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:  \n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:  \nint: Резултатът след вземане на модуло 10007 от изхода.\n\nПримери:  \n    ExtraNumber(1)    // връща 1",
      "zh": "编写一个 Go 函数 `func processRequest(n int) int` 来解决以下问题：\n找到 N 的阶乘并对结果取模 10007。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 对输出取模 10007 后的结果。\n\n示例：\n    ExtraNumber(1)    // 返回 1",
      "fr": "Écrire une fonction Go `func processRequest(n int) int` pour résoudre le problème suivant :  \nTrouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres :  \n- N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie :  \nint : Le résultat après avoir pris le modulo 10007 de la sortie.\n\nExemples :  \n    ExtraNumber(1)    // renvoie 1",
      "de": "Schreiben Sie eine Go-Funktion `func processRequest(n int) int`, um das folgende Problem zu lösen:  \nFinden Sie die Fakultät von N und nehmen Sie das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach der Modulo-Operation mit 10007 des Outputs.\n\nBeispiele:\n    ExtraNumber(1)    // gibt 1 zurück",
      "ha": "Rubuta aikin Go `func processRequest(n int) int` don magance matsalar mai zuwa:\nNemo factorial na N kuma ɗauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n\nMisalai:\n    ExtraNumber(1)    // yana dawowa 1",
      "hi": "Go फ़ंक्शन `func processRequest(n int) int` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nN का फैक्टोरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n\nपैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n\nवापसी:\nint: आउटपुट का 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n    ExtraNumber(1)    // returns 1",
      "hu": "Írj egy Go függvényt `func processRequest(n int) int` a következő probléma megoldására:\nTaláld meg N faktoriálisát, és vedd az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután az output 10007-es modulóját vettük.\n\nPéldák:\n    ExtraNumber(1)    // visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9877486767281491",
      "hy": "0.968299981599499",
      "bn": "0.9729960010679259",
      "bg": "0.9863540928229032",
      "zh": "0.9761099295514098",
      "fr": "0.999999801369619",
      "de": "0.956895221011619",
      "ha": "0.9947660894597307",
      "hi": "0.9558561854884254",
      "hu": "0.9657706223274009"
    },
    "level": "easy",
    "test": "func TestProcessRequest(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, processRequest(0), \"Factorial of 0 should be 1\")\n\tassert.Equal(1, processRequest(1), \"Factorial of 1 should be 1\")\n\tassert.Equal(2, processRequest(2), \"Factorial of 2 should be 2\")\n\tassert.Equal(6, processRequest(3), \"Factorial of 3 should be 6\")\n\tassert.Equal(24, processRequest(4), \"Factorial of 4 should be 24\")\n\tassert.Equal(6266, processRequest(10), \"Factorial of 10 modulus 10007 should be 6266\")\n\tassert.Equal(6991, processRequest(10000), \"Boundary condition for Factorial of 10000 modulus 10007 should be 6991\")\n}",
    "entry_point": "processRequest",
    "signature": "func processRequest(n int) int",
    "docstring": {
      "en": "Find the factorial of N and take the modulo 10007 of the result.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after taking the modulo 10007 of the output.\n\nExamples:\n    ExtraNumber(1)    // returns 1\n",
      "sq": "Gjeni faktorielin e N dhe merrni modulo 10007 të rezultatit.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën e hyrjes (N <= 10000).\n\nKthen:\nint: Rezultati pas marrjes së modulo 10007 të daljes.\n\nShembuj:\n    ExtraNumber(1)    // kthen 1",
      "hy": "Գտնել N-ի ֆակտորիալը և արդյունքը վերցնել մոդուլո 10007։\n\nՊարամետրեր:\n- N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է:\nint: Արդյունքը մոդուլո 10007 վերցնելուց հետո։\n\nՕրինակներ:\n    ExtraNumber(1)    // վերադարձնում է 1",
      "bn": "N এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলের 10007 এর মডুলো নিন।\n\nপ্যারামিটারসমূহ:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: আউটপুটের 10007 মডুলোর পরে ফলাফল।\n\nউদাহরণসমূহ:\n    ExtraNumber(1)    // returns 1",
      "bg": "Намерете факториела на N и вземете модуло 10007 от резултата.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след вземане на модуло 10007 от изхода.\n\nПримери:\n    ExtraNumber(1)    // връща 1",
      "zh": "找到N的阶乘并对结果取模10007。\n\n参数:\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回:\nint: 对输出取模10007后的结果。\n\n示例:\n    ExtraNumber(1)    // 返回 1",
      "fr": "Trouver la factorielle de N et prendre le modulo 10007 du résultat.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir pris le modulo 10007 de la sortie.\n\nExemples:\n    ExtraNumber(1)    // renvoie 1",
      "de": "Finde die Fakultät von N und nehme das Modulo 10007 des Ergebnisses.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewert:\nint: Das Ergebnis nach dem Nehmen des Modulo 10007 des Outputs.\n\nBeispiele:\n    ExtraNumber(1)    // gibt 1 zurück",
      "ha": "Nemo factorial na N kuma a dauki modulo 10007 na sakamakon.\n\nSigogi:\n- N (int): Lamba mai nuna ƙimar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan ɗaukar modulo 10007 na fitarwa.\n\nMisalai:\n    ExtraNumber(1)    // yana dawowa 1",
      "hi": "N का फैक्टोरियल खोजें और परिणाम का 10007 से मॉड्यूलो लें।\n\nपैरामीटर्स:\n- N (int): इनपुट मान का प्रतिनिधित्व करने वाला एक पूर्णांक (N <= 10000)।\n\nवापसी:\nint: आउटपुट का 10007 से मापांक लेने के बाद का परिणाम।\n\nउदाहरण:\n    ExtraNumber(1)    // returns 1",
      "hu": "Keresse meg N faktoriálisát, és vegye az eredmény 10007-es modulóját.\n\nParaméterek:\n- N (int): Egy egész szám, amely a bemeneti értéket jelöli (N <= 10000).\n\nVisszatér:\nint: Az eredmény, miután az 10007-es modulót alkalmaztuk az eredményre.\n\nPéldák:\n    ExtraNumber(1)    // visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9847378374124223",
      "hy": "0.9559485486156066",
      "bn": "0.9920460450218389",
      "bg": "0.9847378374124223",
      "zh": "0.9877349712318577",
      "fr": "1",
      "de": "0.9802233661122614",
      "ha": "0.9649455117245819",
      "hi": "0.9969804209475076",
      "hu": "0.9504210623721677"
    }
  },
  {
    "task_id": "Go/6",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calculates the area of a triangle given its base and height.\n​\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​\nReturns:\n​float64: The calculated area of the triangle, rounded to a float64 precision.\n​\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n\nParametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n\nKthen:\n​float64: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një saktësi float64.\n\nShembuj:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 հաշվարկում է եռանկյունու մակերեսը, եթե տրված են նրա հիմքը և բարձրությունը։\n​\nՊարամետրեր:\n- base (int): Եռանկյունու հիմքի երկարությունը։\n- height (int): Եռանկյունու բարձրությունը։\n​\nՎերադարձնում է:\n​float64: Եռանկյունու հաշվարկված մակերեսը, կլորացված float64 ճշգրտությամբ։\n​\nՕրինակներ:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 একটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করে।\n\nপ্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n\nফেরত দেয়:\n​float64: ত্রিভুজের গণনা করা ক্ষেত্রফল, float64 প্রিসিশনে রাউন্ড করা।\n\nউদাহরণ:\n\tcalculateTriangleArea2(1, 2) // 1.0 ফেরত দেয়\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 изчислява площта на триъгълник, дадени неговата основа и височина.\n​\nПараметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​\nВръща:\n​float64: Изчислената площ на триъгълника, закръглена до точност float64.\n​\nПримери:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 计算给定底边和高的三角形面积。\n\n参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n\n返回:\n​float64: 计算出的三角形面积，精确到 float64。\n\n示例:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 calcule la surface d'un triangle donné sa base et sa hauteur.\n​\nParamètres:\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n​\nRenvoie:\n​float64 : La surface calculée du triangle, arrondie à une précision float64.\n​\nExemples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 berechnet die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n\nParameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n\nRückgabewert:\n​float64: Die berechnete Fläche des Dreiecks, gerundet auf eine float64-Präzision.\n\nBeispiele:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 yana lissafin yankin wani alwatika idan aka ba shi tushe da tsawo.\n\nSigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon alwatika.\n\nDawowa:\n​float64: Yankin da aka lissafa na alwatika, an zagaye shi zuwa daidaiton float64.\n\nMisalai:\n\tcalculateTriangleArea2(1, 2) // yana dawowa 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 त्रिभुज का क्षेत्रफल गणना करता है जब इसका आधार और ऊँचाई दी जाती है।\n\nपैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n\nवापसी मान:\n​float64: त्रिभुज का गणना किया गया क्षेत्रफल, float64 प्रिसीजन में राउंड किया गया।\n\nउदाहरण:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTriangleArea2 kiszámítja egy háromszög területét az alapja és magassága alapján.\n​\nParaméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​\nVisszatér:\n​float64: A háromszög kiszámított területe, float64 pontosságra kerekítve.\n​\nPéldák:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n*/\nfunc calculateTriangleArea2(base, height int) float64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9858513593285039",
      "hy": "0.9685663449404669",
      "bn": "0.9795762283308497",
      "bg": "0.9685663449404669",
      "zh": "0.9653523067449413",
      "fr": "0.9789592823673553",
      "de": "0.9862023392117926",
      "ha": "0.9797391052432983",
      "hi": "0.9749862774858955",
      "hu": "0.9762881010031982"
    },
    "canonical_solution": "// The area formula is (base * height) / 2, and the result is inherently float64\n\treturn float64(base) * float64(height) / 2.0\n}",
    "instruction": {
      "en": "Write a Go function `func calculateTriangleArea2(base, height int) float64` to solve the following problem:\nCalculateTriangleArea2 calculates the area of a triangle given its base and height.\n\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\nReturns:\nfloat64: The calculated area of the triangle, rounded to a float64 precision.\n\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n",
      "sq": "Shkruani një funksion Go `func calculateTriangleArea2(base, height int) float64` për të zgjidhur problemin në vijim:\nCalculateTriangleArea2 llogarit sipërfaqen e një trekëndëshi duke dhënë bazën dhe lartësinë e tij.\n\nParametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n\nKthen:\nfloat64: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një precizion float64.\n\nShembuj:\n\tcalculateTriangleArea2(1, 2) // kthen 1.0",
      "hy": "Գրեք Go ֆունկցիա `func calculateTriangleArea2(base, height int) float64` հետևյալ խնդիրը լուծելու համար:\nCalculateTriangleArea2 հաշվարկում է եռանկյան մակերեսը՝ տրված նրա հիմքը և բարձրությունը:\n\nՊարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n\nՎերադարձնում է:\nfloat64: Եռանկյան հաշվարկված մակերեսը, կլորացված float64 ճշգրտությամբ:\n\nՕրինակներ:\n\tcalculateTriangleArea2(1, 2) // վերադարձնում է 1.0",
      "bn": "একটি Go ফাংশন `func calculateTriangleArea2(base, height int) float64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nCalculateTriangleArea2 একটি ত্রিভুজের ক্ষেত্রফল গণনা করে তার ভিত্তি এবং উচ্চতা দেওয়া হলে।\n\nপ্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n\nরিটার্নস:\nfloat64: ত্রিভুজের গণিতকৃত ক্ষেত্রফল, float64 প্রিসিশনে রাউন্ড করা।\n\nউদাহরণ:\n\tcalculateTriangleArea2(1, 2) // returns 1.0",
      "bg": "Напишете Go функция `func calculateTriangleArea2(base, height int) float64`, за да решите следния проблем:\nCalculateTriangleArea2 изчислява площта на триъгълник, дадени неговата основа и височина.\n\nПараметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n\nВръща:\nfloat64: Изчислената площ на триъгълника, закръглена до точност float64.\n\nПримери:\n\tcalculateTriangleArea2(1, 2) // връща 1.0",
      "zh": "编写一个 Go 函数 `func calculateTriangleArea2(base, height int) float64` 来解决以下问题：\nCalculateTriangleArea2 计算给定底边和高的三角形面积。\n\n参数：\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n\n返回：\nfloat64: 计算出的三角形面积，精确到 float64。\n\n示例：\n\tcalculateTriangleArea2(1, 2) // 返回 1.0",
      "fr": "Écrire une fonction Go `func calculateTriangleArea2(base, height int) float64` pour résoudre le problème suivant :\nCalculateTriangleArea2 calcule l'aire d'un triangle donné sa base et sa hauteur.\n\nParamètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n\nRenvoie :\nfloat64 : L'aire calculée du triangle, arrondie à une précision float64.\n\nExemples :\n\tcalculateTriangleArea2(1, 2) // returns 1.0",
      "de": "Schreiben Sie eine Go-Funktion `func calculateTriangleArea2(base, height int) float64`, um das folgende Problem zu lösen:\nCalculateTriangleArea2 berechnet die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n\nParameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n\nRückgabewert:\nfloat64: Die berechnete Fläche des Dreiecks, gerundet auf eine float64-Präzision.\n\nBeispiele:\n\tcalculateTriangleArea2(1, 2) // gibt 1.0 zurück",
      "ha": "Rubuta aikin Go `func calculateTriangleArea2(base, height int) float64` don warware matsalar mai zuwa:  \nCalculateTriangleArea2 yana lissafin yanki na alwatika idan aka ba shi tushe da tsawo.\n\nSigogi:  \n- base (int): Tsawon tushe na alwatika.  \n- height (int): Tsawon alwatika.  \n\nDawowa:  \nfloat64: Yankin da aka lissafa na alwatika, an zagaye shi zuwa daidaiton float64.\n\nMisalai:  \n\tcalculateTriangleArea2(1, 2) // returns 1.0",
      "hi": "गो फ़ंक्शन `func calculateTriangleArea2(base, height int) float64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nCalculateTriangleArea2 एक त्रिभुज का क्षेत्रफल गणना करता है जब इसका आधार और ऊँचाई दी जाती है।\n\nपैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n\nवापसी:\nfloat64: त्रिभुज का गणना किया गया क्षेत्रफल, float64 प्रिसिजन तक राउंड किया गया।\n\nउदाहरण:\n\tcalculateTriangleArea2(1, 2) // 1.0 लौटाता है",
      "hu": "Írj egy Go függvényt `func calculateTriangleArea2(base, height int) float64` a következő probléma megoldására:\nCalculateTriangleArea2 kiszámítja egy háromszög területét az alapja és magassága alapján.\n\nParaméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n\nVisszatér:\nfloat64: A háromszög kiszámított területe, float64 precizitásra kerekítve.\n\nPéldák:\n\tcalculateTriangleArea2(1, 2) // returns 1.0"
    },
    "instruction_bertscore": {
      "sq": "0.9894124047996974",
      "hy": "0.9844132753698113",
      "bn": "0.9833724521731885",
      "bg": "0.9894124047996974",
      "zh": "0.9717589310548407",
      "fr": "0.9894124047996974",
      "de": "0.9908765093383055",
      "ha": "0.9894124047996974",
      "hi": "0.9785195147037441",
      "hu": "0.9828506501622098"
    },
    "level": "easy",
    "test": "func TestCalculateTriangleArea2(t *testing.T) {\n\t// Using testify for assert comparison with delta for approximation\n\tassert := assert.New(t)\n\n\t// Adding more comprehensive test cases and correcting the expected values\n\tassert.InDelta(1.0, calculateTriangleArea2(1, 2), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(6.0, calculateTriangleArea2(3, 4), 1e-6)    // Should assert true with close approximate comparison\n\tassert.InDelta(20.0, calculateTriangleArea2(5, 8), 1e-6)   // Additional test case\n\tassert.InDelta(10.5, calculateTriangleArea2(7, 3), 1e-6)   // Additional test case\n\tassert.InDelta(50.0, calculateTriangleArea2(10, 10), 1e-6) // Additional test case\n}",
    "entry_point": "calculateTriangleArea2",
    "signature": "func calculateTriangleArea2(base, height int) float64",
    "docstring": {
      "en": "CalculateTriangleArea2 calculates the area of a triangle given its base and height.\n\nParameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n\nReturns:\nfloat64: The calculated area of the triangle, rounded to a float64 precision.\n\nExamples:\n\tcalculateTriangleArea2(1, 2) // returns 1.0\n",
      "sq": "CalculateTriangleArea2 llogarit sipërfaqen e një trekëndëshi duke dhënë bazën dhe lartësinë e tij.\n\nParametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n\nKthen:\nfloat64: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një precizion float64.\n\nShembuj:\n\tcalculateTriangleArea2(1, 2) // kthen 1.0",
      "hy": "CalculateTriangleArea2-ը հաշվարկում է եռանկյունու մակերեսը՝ տրված նրա հիմքը և բարձրությունը:\n\nՊարամետրեր:\n- base (int): Եռանկյունու հիմքի երկարությունը:\n- height (int): Եռանկյունու բարձրությունը:\n\nՎերադարձնում է:\nfloat64: Եռանկյունու հաշվարկված մակերեսը, կլորացված float64 ճշգրտությամբ:\n\nՕրինակներ:\n\tcalculateTriangleArea2(1, 2) // վերադարձնում է 1.0",
      "bn": "CalculateTriangleArea2 একটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করে।\n\nপ্যারামিটারসমূহ:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n\nরিটার্নস:\nfloat64: ত্রিভুজের গণনা করা ক্ষেত্রফল, float64 প্রিসিশনে রাউন্ড করা।\n\nউদাহরণ:\n\tcalculateTriangleArea2(1, 2) // 1.0 রিটার্ন করে",
      "bg": "CalculateTriangleArea2 изчислява площта на триъгълник, като се дадат неговата основа и височина.\n\nПараметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n\nВръща:\nfloat64: Изчислената площ на триъгълника, закръглена до точност float64.\n\nПримери:\n\tcalculateTriangleArea2(1, 2) // връща 1.0",
      "zh": "CalculateTriangleArea2 计算给定底边和高的三角形面积。\n\n参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n\n返回:\nfloat64: 计算出的三角形面积，四舍五入到 float64 精度。\n\n示例:\n\tcalculateTriangleArea2(1, 2) // 返回 1.0",
      "fr": "CalculateTriangleArea2 calcule l'aire d'un triangle donné sa base et sa hauteur.\n\nParamètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n\nRenvoie:\nfloat64: L'aire calculée du triangle, arrondie à une précision float64.\n\nExemples:\n\tcalculateTriangleArea2(1, 2) // renvoie 1.0",
      "de": "CalculateTriangleArea2 berechnet die Fläche eines Dreiecks anhand seiner Basis und Höhe.\n\nParameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n\nRückgabewert:\nfloat64: Die berechnete Fläche des Dreiecks, gerundet auf eine float64-Präzision.\n\nBeispiele:\n\tcalculateTriangleArea2(1, 2) // gibt 1.0 zurück",
      "ha": "CalculateTriangleArea2 yana lissafin yankin wani alwatika idan aka ba da tushe da tsawo.\n\nSigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon alwatika.\n\nDawowa:\nfloat64: Yankin da aka lissafa na alwatika, an zagaye shi zuwa daidaiton float64.\n\nMisalai:\n\tcalculateTriangleArea2(1, 2) // yana dawowa 1.0",
      "hi": "CalculateTriangleArea2 त्रिभुज का क्षेत्रफल गणना करता है जब इसका आधार और ऊँचाई दी जाती है।\n\nपैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n\nवापसी:\nfloat64: त्रिभुज का गणना किया गया क्षेत्रफल, float64 सटीकता के लिए गोल किया गया।\n\nउदाहरण:\n\tcalculateTriangleArea2(1, 2) // 1.0 लौटाता है",
      "hu": "CalculateTriangleArea2 kiszámítja egy háromszög területét az alapja és magassága alapján.\n\nParaméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n\nVisszatérési érték:\nfloat64: A háromszög kiszámított területe, float64 pontosságra kerekítve.\n\nPéldák:\n\tcalculateTriangleArea2(1, 2) // visszaadja: 1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9799506465991005",
      "hy": "0.985897640207285",
      "bn": "0.9794081870284942",
      "bg": "0.985897640207285",
      "zh": "0.9701961072168581",
      "fr": "0.9902599606355732",
      "de": "0.9840883160664382",
      "ha": "0.978444829680475",
      "hi": "0.9766011424837091",
      "hu": "0.9672514118180159"
    }
  },
  {
    "task_id": "Go/7",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit distancën Hamming midis dy numrave të plotë.\n\nDistanca Hamming mat numrin e bitëve të ndryshëm midis\ndy vlerave të plota kur përfaqësohen në formë binare.\n\nParametrat:\n- x (int): Numri i parë pozitiv i plotë (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv i plotë (y <= 1,000,000,000).\n\nKthen:\n- int: Numri i bitëve që duhet të ndryshohen për të kthyer x në y.\n\nShembuj:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվեք Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև։\n\nՀեմինգի հեռավորությունը չափում է տարբեր բիթերի քանակը\nերկու ամբողջ թվային արժեքների միջև, երբ ներկայացված են երկուական ձևով։\n\nՊարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n\nՎերադարձնում է:\n- int: Բիթերի քանակը, որոնք պետք է փոխել x-ը y-ի վերածելու համար։\n\nՕրինակներ:\n    hammingDistance(1, 2) // վերադարձնում է 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি পূর্ণসংখ্যার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nহ্যামিং দূরত্ব মাপা হয় দুটি পূর্ণসংখ্যার মধ্যে ভিন্ন বিটের সংখ্যা\nযখন সেগুলি বাইনারি রূপে উপস্থাপিত হয়।\n\nপ্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nফেরত দেয়:\n- int: x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nউদাহরণ:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете разстоянието на Хаминг между две цели числа.\n\nРазстоянието на Хаминг измерва броя на различаващите се битове между\nдве цели числа, когато са представени в двоична форма.\n\nПараметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- int: Броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y.\n\nПримери:\n    hammingDistance(1, 2) // връща 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算两个整数之间的汉明距离。\n\n汉明距离测量两个整数值在二进制形式下不同的位数。\n\n参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n\n返回:\n- int: 需要翻转多少个位才能将 x 转换为 y。\n\n示例:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la distance de Hamming entre deux entiers.\n\nLa distance de Hamming mesure le nombre de bits différents entre\ndeux valeurs entières lorsqu'elles sont représentées sous forme binaire.\n\nParamètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie:\n- int: Le nombre de bits qui doivent être inversés pour convertir x en y.\n\nExemples:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Hamming-Distanz zwischen zwei Ganzzahlen.\n\nDie Hamming-Distanz misst die Anzahl der unterschiedlichen Bits zwischen\nzwei Ganzzahlen, wenn sie in binärer Form dargestellt werden.\n\nParameter:\n- x (int): Die erste positive Ganzzahl (x <= 1.000.000.000).\n- y (int): Die zweite positive Ganzzahl (y <= 1.000.000.000).\n\nRückgabewert:\n- int: Die Anzahl der Bits, die umgedreht werden müssen, um x in y zu konvertieren.\n\nBeispiele:\n    hammingDistance(1, 2) // gibt 2 zurück\n*/\nfunc hammingDistance(x int, y int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu.\n\nNisan Hamming yana auna adadin bits da suka bambanta tsakanin\nlambobi biyu idan aka wakilta su a cikin tsarin binary.\n\nSigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nDawowa:\n- int: Adadin bits da ake buƙatar juyawa don canza x zuwa y.\n\nMisalai:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदो पूर्णांकों के बीच हैमिंग दूरी की गणना करें।\n\nहैमिंग दूरी मापती है कि दो पूर्णांक मानों के बीच बाइनरी रूप में\nकितने भिन्न बिट्स होते हैं।\n\nपैरामीटर्स:\n- x (int): पहला सकारात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा सकारात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी मान:\n- int: उन बिट्स की संख्या जिन्हें x को y में बदलने के लिए पलटना आवश्यक है।\n\nउदाहरण:\n    hammingDistance(1, 2) // returns 2\n*/\nfunc hammingDistance(x int, y int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a Hamming-távolságot két egész szám között.\n\nA Hamming-távolság azt méri, hogy hány bit különbözik\nkét egész szám bináris formában való ábrázolásakor.\n\nParaméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- int: Azoknak a biteknek a száma, amelyeket meg kell változtatni, hogy x-ből y legyen.\n\nPéldák:\n    hammingDistance(1, 2) // visszaadja 2\n*/\nfunc hammingDistance(x int, y int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9932709985816811",
      "hy": "0.9932709985816811",
      "bn": "0.975119955732332",
      "bg": "0.9949023499011206",
      "zh": "0.9849513650720348",
      "fr": "0.9931800258671671",
      "de": "0.988442294018723",
      "ha": "0.9771310883403103",
      "hi": "0.9719090956229031",
      "hu": "0.9740094132719659"
    },
    "canonical_solution": "distance := 0\n\txorResult := x ^ y // XOR x and y to get a number where set bits indicate differences\n\n\t// Count the number of bits set in xorResult\n\tfor xorResult != 0 {\n\t\t// If the lowest bit is 1, increment distance\n\t\tdistance += xorResult & 1\n\t\t// Right shift xorResult by 1 to check next bit\n\t\txorResult >>= 1\n\t}\n\n\treturn distance\n}",
    "instruction": {
      "en": "Write a Go function `func hammingDistance(x int, y int) int` to solve the following problem:\nCalculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n",
      "sq": "Shkruani një funksion Go `func hammingDistance(x int, y int) int` për të zgjidhur problemin në vijim:\nLlogaritni distancën Hamming midis dy numrave të plotë.\n\nDistanca Hamming mat numrin e bitëve të ndryshëm midis\ndy vlerave të plota kur përfaqësohen në formë binare.\n\nParametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- int: Numri i bitëve që duhet të ndryshohen për të kthyer x në y.\n\nShembuj:\n    hammingDistance(1, 2) // kthen 2",
      "hy": "Գրեք Go ֆունկցիա `func hammingDistance(x int, y int) int` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկել երկու ամբողջ թվերի միջև Համինգի հեռավորությունը:\n\nՀամինգի հեռավորությունը չափում է տարբեր բիթերի քանակը\nերկու ամբողջ թվերի միջև, երբ դրանք ներկայացված են երկբայական ձևով:\n\nՊարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\n\nՎերադարձնում է:\n- int: Բիթերի քանակը, որոնք պետք է փոխվեն x-ը y-ի վերածելու համար:\n\nՕրինակներ:\n    hammingDistance(1, 2) // վերադարձնում է 2",
      "bn": "একটি Go ফাংশন `func hammingDistance(x int, y int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nহ্যামিং দূরত্ব দুটি পূর্ণসংখ্যার মধ্যে ভিন্ন বিটের সংখ্যা পরিমাপ করে\nযখন বাইনারি আকারে উপস্থাপিত হয়।\n\nপ্যারামিটারসমূহ:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nফেরত দেয়:\n- int: x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nউদাহরণ:\n    hammingDistance(1, 2) // 2 ফেরত দেয়",
      "bg": "Напишете Go функция `func hammingDistance(x int, y int) int`, за да решите следния проблем:  \nИзчислете разстоянието на Хаминг между две цели числа.\n\nРазстоянието на Хаминг измерва броя на различаващите се битове между\nдве цели стойности, когато са представени в двоична форма.\n\nПараметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- int: Броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y.\n\nПримери:\n    hammingDistance(1, 2) // връща 2",
      "zh": "编写一个 Go 函数 `func hammingDistance(x int, y int) int` 来解决以下问题：  \n计算两个整数之间的汉明距离。\n\n汉明距离度量的是当以二进制形式表示时，两个整数值之间不同的位数。\n\n参数：\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n\n返回：\n- int: 将 x 转换为 y 所需翻转的位数。\n\n例子：\n    hammingDistance(1, 2) // 返回 2",
      "fr": "Écrire une fonction Go `func hammingDistance(x int, y int) int` pour résoudre le problème suivant :  \nCalculer la distance de Hamming entre deux entiers.\n\nLa distance de Hamming mesure le nombre de bits différents entre\ndeux valeurs entières lorsqu'elles sont représentées sous forme binaire.\n\nParamètres :  \n- x (int) : Le premier entier positif (x <= 1,000,000,000).  \n- y (int) : Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie :  \n- int : Le nombre de bits qui doivent être inversés pour convertir x en y.\n\nExemples :  \n    hammingDistance(1, 2) // renvoie 2",
      "de": "Schreiben Sie eine Go-Funktion `func hammingDistance(x int, y int) int`, um das folgende Problem zu lösen:\nBerechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen.\n\nDer Hamming-Abstand misst die Anzahl der unterschiedlichen Bits zwischen\nzwei ganzzahligen Werten, wenn diese in binärer Form dargestellt werden.\n\nParameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nRückgabewert:\n- int: Die Anzahl der Bits, die umgekehrt werden müssen, um x in y zu konvertieren.\n\nBeispiele:\n    hammingDistance(1, 2) // gibt 2 zurück",
      "ha": "Rubuta aikin Go `func hammingDistance(x int, y int) int` don warware matsalar mai zuwa:\nƘididdige tazara ta Hamming tsakanin lambobi guda biyu.\n\nTazara ta Hamming tana auna adadin bits da suka bambanta tsakanin\nlambobi guda biyu lokacin da aka wakilta su a cikin tsarin binary.\n\nSigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nMayarwa:\n- int: Adadin bits da ake buƙatar juyawa don canza x zuwa y.\n\nMisalai:\n    hammingDistance(1, 2) // returns 2",
      "hi": "Go फ़ंक्शन `func hammingDistance(x int, y int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के बीच हैमिंग दूरी की गणना करें।\n\nहैमिंग दूरी मापता है कि दो पूर्णांक मानों के बीच कितने भिन्न बिट्स होते हैं जब उन्हें बाइनरी रूप में दर्शाया जाता है।\n\nपैरामीटर्स:\n- x (int): पहला सकारात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा सकारात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी मान:\n- int: वह बिट्स की संख्या जिन्हें x को y में बदलने के लिए उलटना आवश्यक है।\n\nउदाहरण:\n    hammingDistance(1, 2) // 2 लौटाता है",
      "hu": "Írj egy Go függvényt `func hammingDistance(x int, y int) int` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám között.\n\nA Hamming-távolság azt méri, hogy hány különböző bit van két egész szám között, amikor bináris formában vannak ábrázolva.\n\nParaméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- int: Azon bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-ből y legyen.\n\nPéldák:\n    hammingDistance(1, 2) // returns 2"
    },
    "instruction_bertscore": {
      "sq": "0.9862811954730634",
      "hy": "0.9846023714925565",
      "bn": "0.9868321961500541",
      "bg": "0.9994539650825351",
      "zh": "0.9948141580119412",
      "fr": "0.9929222036325839",
      "de": "0.9884168693299505",
      "ha": "0.9775662875051576",
      "hi": "0.9662308489202587",
      "hu": "0.9792919882555887"
    },
    "level": "middle",
    "test": "func TestHammingDistance(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, hammingDistance(1, 2), \"1 and 2 should have a Hamming distance of 2\")\n\tassert.Equal(2, hammingDistance(4, 7), \"4 and 7 should have a Hamming distance of 2\")\n\tassert.Equal(3, hammingDistance(25, 30), \"25 and 30 should have a Hamming distance of 3\")\n\tassert.Equal(0, hammingDistance(0, 0), \"0 and 0 should have a Hamming distance of 0\")\n\tassert.Equal(28, hammingDistance(0xFFFFFFF, 0), \"0xFFFFFFF and 0 should have a Hamming distance of 28\")\n}",
    "entry_point": "hammingDistance",
    "signature": "func hammingDistance(x int, y int) int",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers.\n\nThe Hamming distance measures the number of differing bits between\ntwo integer values when represented in binary form.\n\nParameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n\nReturns:\n- int: The number of bits that need to be flipped to convert x into y.\n\nExamples:\n    hammingDistance(1, 2) // returns 2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë.\n\nDistanca Hamming mat numrin e bitëve që ndryshojnë midis\ndy vlerave të plota kur përfaqësohen në formë binare.\n\nParametrat:\n- x (int): Numri i parë i plotë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë i plotë pozitiv (y <= 1,000,000,000).\n\nKthen:\n- int: Numri i bitëve që duhet të ndryshohen për të kthyer x në y.\n\nShembuj:\n    hammingDistance(1, 2) // kthen 2",
      "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև։\n\nՀեմինգի հեռավորությունը չափում է տարբեր բիթերի քանակը\nերկու ամբողջ թվային արժեքների միջև, երբ ներկայացված են երկուական ձևով։\n\nՊարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n\nՎերադարձնում է:\n- int: Բիթերի քանակը, որոնք պետք է փոխել x-ը y-ի վերածելու համար։\n\nՕրինակներ:\n    hammingDistance(1, 2) // վերադարձնում է 2",
      "bn": "দুটি পূর্ণসংখ্যার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n\nHamming distance দুটি পূর্ণসংখ্যার মধ্যে ভিন্ন বিটের সংখ্যা পরিমাপ করে যখন সেগুলি বাইনারি রূপে উপস্থাপিত হয়।\n\nParameters:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n\nReturns:\n- int: x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n\nExamples:\n    hammingDistance(1, 2) // 2 প্রদান করে",
      "bg": "Изчисляване на разстоянието на Хаминг между две цели числа.\n\nРазстоянието на Хаминг измерва броя на различаващите се битове между\nдве цели стойности, когато са представени в двоична форма.\n\nПараметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n\nВръща:\n- int: Броят на битовете, които трябва да бъдат променени, за да се преобразува x в y.\n\nПримери:\n    hammingDistance(1, 2) // връща 2",
      "zh": "计算两个整数之间的汉明距离。\n\n汉明距离用于衡量两个整数在二进制表示时有多少位不同。\n\n参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n\n返回:\n- int: 将 x 转换为 y 需要翻转的位数。\n\n示例:\n    hammingDistance(1, 2) // 返回 2",
      "fr": "Calculer la distance de Hamming entre deux entiers.\n\nLa distance de Hamming mesure le nombre de bits différents entre\ndeux valeurs entières lorsqu'elles sont représentées sous forme binaire.\n\nParamètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n\nRenvoie:\n- int: Le nombre de bits qui doivent être inversés pour convertir x en y.\n\nExemples:\n    hammingDistance(1, 2) // renvoie 2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen.\n\nDie Hamming-Distanz misst die Anzahl der unterschiedlichen Bits zwischen\nzwei ganzzahligen Werten, wenn sie in binärer Form dargestellt werden.\n\nParameter:\n- x (int): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (int): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n\nGibt zurück:\n- int: Die Anzahl der Bits, die umgedreht werden müssen, um x in y zu konvertieren.\n\nBeispiele:\n    hammingDistance(1, 2) // gibt 2 zurück",
      "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu.\n\nHamming distance yana auna yawan bambancin bits tsakanin\nlambobi guda biyu lokacin da aka wakilta su a cikin tsarin binary.\n\nSigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n\nAbin da ake dawowa da shi:\n- int: Yawan bits da ake bukata a jujjuya don canza x zuwa y.\n\nMisalai:\n    hammingDistance(1, 2) // yana dawowa da 2",
      "hi": "दो पूर्णांकों के बीच हैमिंग दूरी की गणना करें।\n\nहैमिंग दूरी मापता है कि जब दो पूर्णांक मानों को बाइनरी रूप में दर्शाया जाता है तो उनके बीच कितने भिन्न बिट्स होते हैं।\n\nपैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n\nवापसी:\n- int: बिट्स की संख्या जिन्हें x को y में बदलने के लिए उलटना आवश्यक है।\n\nउदाहरण:\n    hammingDistance(1, 2) // 2 लौटाता है",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám között.\n\nA Hamming-távolság azt méri, hogy hány különböző bit van két egész szám között, amikor bináris formában vannak ábrázolva.\n\nParaméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n\nVisszatérési érték:\n- int: Azoknak a biteknek a száma, amelyeket meg kell fordítani, hogy x-et y-ra alakítsuk.\n\nPéldák:\n    hammingDistance(1, 2) // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9841387681832211",
      "hy": "0.9907849407326484",
      "bn": "0.9762420187547981",
      "bg": "0.9892096031806608",
      "zh": "0.9680121661773795",
      "fr": "0.9883934309449883",
      "de": "0.9883934309449883",
      "ha": "0.9654947247281433",
      "hi": "0.9688527699499192",
      "hu": "0.9808438874226143"
    }
  },
  {
    "task_id": "Go/8",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n- count (int): Numri i numrave për t'u vlerësuar.\n- nums ([]int): Një segment i numrave të plotë.\n\nKthen:\nint: Numri i numrave tek në listën e dhënë.\n\nShembuj:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // kthen 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր:\n- count (int): Գնահատման ենթակա թվերի քանակը։\n- nums ([]int): Ամբողջ թվերի կտոր։\n\nՎերադարձնում է:\nint: Մուտքային ցուցակի կենտ թվերի քանակը։\n\nՕրինակներ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // վերադարձնում է 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত সংখ্যার তালিকায় কতগুলি বিজোড় পূর্ণসংখ্যা আছে তা গণনা করুন।\n\nপ্যারামিটার:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- nums ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 ফেরত দেয়\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n- count (int): Броят на числата за оценка.\n- nums ([]int): Срез от цели числа.\n\nВръща:\nint: Броят на нечетните числа в списъка с входни данни.\n\nПримери:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // връща 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定数字列表中奇数的数量。\n\n参数:\n- count (int): 要评估的数字数量。\n- nums ([]int): 整数切片。\n\n返回值:\nint: 输入列表中奇数的数量。\n\n示例:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres:\n- count (int): Le nombre de nombres à évaluer.\n- nums ([]int): Une tranche d'entiers.\n\nRenvoie:\nint: Le nombre de nombres impairs dans la liste d'entrée.\n\nExemples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- nums ([]int): Ein Slice von Ganzzahlen.\n\nRückgabewerte:\nint: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiele:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // gibt 3 zurück\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘirga adadin lambobin da ba su da mafarin biyu a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- count (int): Adadin lambobin da za a tantance.\n- nums ([]int): Wani yanki na lambobi.\n\nDawowa:\nint: Adadin lambobin da ba su da mafarin biyu a cikin jerin shigarwa.\n\nMisalai:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- nums ([]int): पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 लौटाता है\n*/\nfunc countOddNumbers(count int, nums []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n- count (int): Az értékelendő számok száma.\n- nums ([]int): Egy egész számokat tartalmazó szelet.\n\nVisszatér:\nint: A bemeneti listában lévő páratlan számok száma.\n\nPéldák:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n*/\nfunc countOddNumbers(count int, nums []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9760700048448219",
      "hy": "0.9775784039584008",
      "bn": "0.9858608935867935",
      "bg": "0.9932678204955845",
      "zh": "0.9750130925873352",
      "fr": "0.9932678204955845",
      "de": "0.9843447478883542",
      "ha": "0.9842498025662195",
      "hi": "0.9962270159122423",
      "hu": "0.9897000215914359"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range nums {\n\t\tif num%2 != 0 {\n\t\t\tans++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func countOddNumbers(count int, nums []int) int` to solve the following problem:\nCount the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n",
      "sq": "Shkruani një funksion në Go `func countOddNumbers(count int, nums []int) int` për të zgjidhur problemin në vijim: Numëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n- count (int): Numri i numrave për të vlerësuar.\n- nums ([]int): Një segment i numrave të plotë.\n\nKthen:\nint: Numri i numrave tek në listën e dhënë.\n\nShembuj:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // kthen 3",
      "hy": "Գրեք Go ֆունկցիա `func countOddNumbers(count int, nums []int) int` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n\nՊարամետրեր:\n- count (int): Գնահատման ենթակա թվերի քանակը։\n- nums ([]int): Ամբողջ թվերի շերտ։\n\nՎերադարձնում է:\nint: Մուտքային ցուցակում գտնվող կենտ թվերի քանակը։\n\nՕրինակներ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // վերադարձնում է 3",
      "bn": "একটি Go ফাংশন `func countOddNumbers(count int, nums []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়নের জন্য সংখ্যার সংখ্যা।\n- nums ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n\nরিটার্নস:\nint: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণসমূহ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3",
      "bg": "Напишете Go функция `func countOddNumbers(count int, nums []int) int`, за да решите следния проблем:\nПребройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n- count (int): Броят на числата за оценка.\n- nums ([]int): Срез от цели числа.\n\nВръща:\nint: Броят на нечетните числа в списъка на входа.\n\nПримери:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // връща 3",
      "zh": "编写一个 Go 函数 `func countOddNumbers(count int, nums []int) int` 来解决以下问题：\n计算给定数字列表中奇数的数量。\n\n参数：\n- count (int): 要评估的数字数量。\n- nums ([]int): 整数切片。\n\n返回：\nint: 输入列表中奇数的数量。\n\n示例：\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 返回 3",
      "fr": "Écrire une fonction Go `func countOddNumbers(count int, nums []int) int` pour résoudre le problème suivant :\nCompter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres :\n- count (int) : Le nombre de nombres à évaluer.\n- nums ([]int) : Une tranche d'entiers.\n\nRenvoie :\nint : Le nombre de nombres impairs dans la liste d'entrée.\n\nExemples :\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // renvoie 3",
      "de": "Schreiben Sie eine Go-Funktion `func countOddNumbers(count int, nums []int) int`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- nums ([]int): Ein Slice von ganzen Zahlen.\n\nRückgabewert:\nint: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiele:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // gibt 3 zurück",
      "ha": "Rubuta wani aikin Go `func countOddNumbers(count int, nums []int) int` don warware matsalar mai zuwa:\nƘirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- count (int): Adadin lambobin da za a tantance.\n- nums ([]int): Wani yanki na lambobi.\n\nDawowa:\nint: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n\nMisalai:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3",
      "hi": "Go फ़ंक्शन `func countOddNumbers(count int, nums []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- nums ([]int): पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3",
      "hu": "Írj egy Go függvényt `func countOddNumbers(count int, nums []int) int` a következő probléma megoldására:\nSzámold meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n- count (int): Az értékelendő számok száma.\n- nums ([]int): Egy egész számokat tartalmazó szelet.\n\nVisszatér:\nint: A bemeneti listában található páratlan számok száma.\n\nPéldák:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3"
    },
    "instruction_bertscore": {
      "sq": "0.9779738770470412",
      "hy": "0.9801713249524302",
      "bn": "0.9897018092648652",
      "bg": "0.9920208189634475",
      "zh": "0.9730698915696709",
      "fr": "0.9920208189634475",
      "de": "0.9871488129774237",
      "ha": "0.9824674921571935",
      "hi": "0.9700755385755699",
      "hu": "0.9794475158439391"
    },
    "level": "easy",
    "test": "func TestCountOddNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, countOddNumbers(5, []int{1, 4, 3, 2, 5}))\n\tassert.Equal(0, countOddNumbers(4, []int{2, 2, 0, 0}))\n\tassert.Equal(4, countOddNumbers(6, []int{7, 7, 8, 1, 9, 10})) // Additional Test Sample\n}",
    "entry_point": "countOddNumbers",
    "signature": "func countOddNumbers(count int, nums []int) int",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\n\nParameters:\n- count (int): The count of numbers to evaluate.\n- nums ([]int): A slice of integers.\n\nReturns:\nint: The count of odd numbers in the input list.\n\nExamples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3\n",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.\n\nParametrat:\n- count (int): Numri i numrave për të vlerësuar.\n- nums ([]int): Një segment i numrave të plotë.\n\nKthen:\nint: Numri i numrave tek në listën e dhënë të hyrjes.\n\nShembuj:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // kthen 3",
      "hy": "Կանխատեսեք տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը:\n\nՊարամետրեր:\n- count (int): Գնահատվող թվերի քանակը:\n- nums ([]int): Ամբողջ թվերի կտոր:\n\nՎերադարձնում է:\nint: Մուտքային ցուցակում կենտ թվերի քանակը:\n\nՕրինակներ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // վերադարձնում է 3",
      "bn": "দেওয়া সংখ্যার তালিকায় কতগুলি বিজোড় পূর্ণসংখ্যা আছে তা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n- nums ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\nউদাহরণ:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 ফেরত দেয়",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\n\nПараметри:\n- count (int): Броят на числата за оценка.\n- nums ([]int): Срез от цели числа.\n\nВръща:\nint: Броят на нечетните числа в входния списък.\n\nПримери:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // връща 3",
      "zh": "计算给定数字列表中奇数的数量。\n\n参数:\n- count (int): 要评估的数字数量。\n- nums ([]int): 整数切片。\n\n返回:\nint: 输入列表中奇数的数量。\n\n示例:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 返回 3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n\nParamètres:\n- count (int): Le nombre de nombres à évaluer.\n- nums ([]int): Une tranche d'entiers.\n\nRenvoie:\nint: Le nombre de nombres impairs dans la liste d'entrée.\n\nExemples:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // renvoie 3",
      "de": "Zähle die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\nParameter:\n- count (int): Die Anzahl der zu bewertenden Zahlen.\n- nums ([]int): Ein Slice von ganzen Zahlen.\n\nRückgabewerte:\nint: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\nBeispiele:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // gibt 3 zurück",
      "ha": "Ƙirga adadin lambobin da ba su da mafarin biyu a cikin jerin lambobi da aka bayar.\n\nSigogi:\n- count (int): Adadin lambobin da za a tantance.\n- nums ([]int): Wani yanki na lambobi masu lamba.\n\nDawowa:\nint: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n\nMisalai:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // returns 3",
      "hi": "दी गई संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n\nपैरामीटर्स:\n- count (int): मूल्यांकन करने के लिए संख्याओं की गिनती।\n- nums ([]int): पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: इनपुट सूची में विषम संख्याओं की गिनती।\n\nउदाहरण:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // 3 लौटाता है",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n\nParaméterek:\n- count (int): Az értékelendő számok száma.\n- nums ([]int): Egész számok szelete.\n\nVisszatér:\nint: A bemeneti listában található páratlan számok száma.\n\nPéldák:\n\tcountOddNumbers(5, []int{1, 4, 3, 2, 5}) // visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9596551901560987",
      "hy": "0.9668789798535755",
      "bn": "0.9762737996157637",
      "bg": "0.9895297953548889",
      "zh": "0.9704312855880034",
      "fr": "0.9895297953548889",
      "de": "0.9759035525855146",
      "ha": "0.9670567540446017",
      "hi": "0.9939791158900705",
      "hu": "0.9764589231308881"
    }
  },
  {
    "task_id": "Go/9",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\n- size (int): The length of the slice.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLlogarit shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers ([]int): Një prerje e numrave të plotë.\n- size (int): Gjatësia e prerjes.\nKthen:\nint: Shuma e numrave çift në prerjen e dhënë.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվարկել տրված ցուցակի զույգ թվերի գումարը։\nՊարամետրեր:\n- numbers ([]int): Ամբողջ թվերի շերտ։\n- size (int): Շերտի երկարությունը։\nՎերադարձնում է:\nint: Մուտքային շերտի զույգ թվերի գումարը։\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটার:\n- numbers ([]int): পূর্ণসংখ্যার একটি স্লাইস।\n- size (int): স্লাইসের দৈর্ঘ্য।\nরিটার্ন:\nint: ইনপুট স্লাইসের জোড় সংখ্যাগুলির যোগফল।\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nИзчислете сумата на четните числа в даден списък.\nПараметри:\n- numbers ([]int): Срез от цели числа.\n- size (int): Дължината на среза.\nВръща:\nint: Сумата на четните числа в входния срез.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算给定列表中偶数的和。\n参数：\n- numbers ([]int): 整数切片。\n- size (int): 切片的长度。\n返回：\nint: 输入切片中偶数的和。\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculer la somme des nombres pairs dans une liste donnée.\nParamètres :\n- numbers ([]int) : Une tranche d'entiers.\n- size (int) : La longueur de la tranche.\nRenvoie :\nint : La somme des nombres pairs dans la tranche d'entrée.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBerechne die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers ([]int): Ein Slice von ganzen Zahlen.\n- size (int): Die Länge des Slices.\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabeslice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige jimillar lambobin da suka yi lamba biyu a cikin jerin da aka bayar.\nSigogi:\n- numbers ([]int): Wani yanki na lambobi.\n- size (int): Tsawon yankan.\nDawo:\nint: Jimillar lambobin da suka yi lamba biyu a cikin yankan shigarwa.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए सूची में सम संख्याओं का योग गणना करें।\nपैरामीटर्स:\n- numbers ([]int): पूर्णांकों की एक स्लाइस।\n- size (int): स्लाइस की लंबाई।\nवापसी:\nint: इनपुट स्लाइस में सम संख्याओं का योग।\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámítsa ki a páros számok összegét egy adott listában.\nParaméterek:\n- numbers ([]int): Egész számok szelete.\n- size (int): A szelet hossza.\nVisszatér:\nint: A bemeneti szelet páros számainak összege.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n*/\nfunc calculateEvenSum(numbers []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9930604503777841",
      "hy": "0.9758189360431937",
      "bn": "0.9978357233682439",
      "bg": "0.9892707813380195",
      "zh": "0.98108105209757",
      "fr": "1",
      "de": "0.9860203937827645",
      "ha": "0.9822688617761587",
      "hi": "0.997056893644206",
      "hu": "0.9914988183220879"
    },
    "canonical_solution": "ans := 0\n\tfor _, num := range numbers {\n\t\tif num%2 == 0 { // Only sum the even numbers\n\t\t\tans += num\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func calculateEvenSum(numbers []int) int` to solve the following problem:\nCalculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n",
      "sq": "Shkruani një funksion Go `func calculateEvenSum(numbers []int) int` për të zgjidhur problemin e mëposhtëm:\nLlogaritni shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers ([]int): Një segment i numrave të plotë.\nKthen:\nint: Shuma e numrave çift në segmentin e dhënë.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hy": "Գրեք Go ֆունկցիա `func calculateEvenSum(numbers []int) int` հետևյալ խնդիրը լուծելու համար:\nՀաշվել տրված ցուցակի զույգ թվերի գումարը։\nՊարամետրեր:\n- numbers ([]int): Թվերի շերտ։\nՎերադարձնում է:\nint: Մուտքային շերտի զույգ թվերի գումարը։\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "bn": "একটি Go ফাংশন `func calculateEvenSum(numbers []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত তালিকার মধ্যে জোড় সংখ্যাগুলির যোগফল গণনা করুন।\nপ্যারামিটারসমূহ:\n- numbers ([]int): পূর্ণসংখ্যার একটি স্লাইস।\nরিটার্নস:\nint: ইনপুট স্লাইসে জোড় সংখ্যাগুলির যোগফল।\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "bg": "Напишете функция на Go `func calculateEvenSum(numbers []int) int`, за да решите следния проблем:\nИзчислете сумата на четните числа в даден списък.\nПараметри:\n- numbers ([]int): Срез от цели числа.\nВръща:\nint: Сумата на четните числа в входния срез.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "zh": "编写一个 Go 函数 `func calculateEvenSum(numbers []int) int` 来解决以下问题：  \n计算给定列表中偶数的和。  \n参数：  \n- numbers ([]int): 整数切片。  \n返回：  \nint: 输入切片中偶数的和。  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "fr": "Écrire une fonction Go `func calculateEvenSum(numbers []int) int` pour résoudre le problème suivant :\nCalculer la somme des nombres pairs dans une liste donnée.\nParamètres :\n- numbers ([]int) : Une tranche d'entiers.\nRenvoie :\nint : La somme des nombres pairs dans la tranche d'entrée.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "de": "Schreiben Sie eine Go-Funktion `func calculateEvenSum(numbers []int) int`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\nParameter:\n- numbers ([]int): Ein Slice von Ganzzahlen.\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabe-Slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "ha": "Rubuta aikin Go `func calculateEvenSum(numbers []int) int` don warware matsalar mai zuwa: \nƘididdige jimillar lambobin da suka kasance ma'aurata a cikin jerin da aka bayar. \nSigogi: \n- numbers ([]int): Wani yanki na lambobi. \nDawo: \nint: Jimillar lambobin ma'aurata a cikin yankin shigarwa.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hi": "Go फ़ंक्शन `func calculateEvenSum(numbers []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सूची में सम संख्याओं का योग गणना करें।\nपैरामीटर्स:\n- numbers ([]int): पूर्णांकों की एक स्लाइस।\nरिटर्न्स:\nint: इनपुट स्लाइस में सम संख्याओं का योग।\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hu": "Írj egy Go függvényt `func calculateEvenSum(numbers []int) int` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott listában.\nParaméterek:\n- numbers ([]int): Egész számok szelete.\nVisszatérési érték:\nint: A bemeneti szelet páros számainak összege."
    },
    "instruction_bertscore": {
      "sq": "0.989000644019812",
      "hy": "0.9884871844848369",
      "bn": "0.994494958989618",
      "bg": "0.9857252290365467",
      "zh": "0.9923251207071929",
      "fr": "1",
      "de": "0.9837993088620325",
      "ha": "0.9603450334694329",
      "hi": "0.994494958989618",
      "hu": "0.9128231120675979"
    },
    "level": "easy",
    "test": "func TestCalculateEvenSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, calculateEvenSum([]int{1, 4, 3, 2, 5}))\n\tassert.Equal(4, calculateEvenSum([]int{2, 2, 0, 0}))\n\tassert.Equal(0, calculateEvenSum([]int{7, 11, 19})) // Should return 0 because there are no even numbers\n\tassert.Equal(12+14+16+18+20, calculateEvenSum([]int{12, 14, 16, 18, 20}))\n}",
    "entry_point": "calculateEvenSum",
    "signature": "func calculateEvenSum(numbers []int) int",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\nParameters:\n- numbers ([]int): A slice of integers.\nReturns:\nint: The sum of even numbers in the input slice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6\n",
      "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\nParametrat:\n- numbers ([]int): Një segment i numrave të plotë.\nKthen:\nint: Shuma e numrave çift në segmentin e dhënë.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hy": "Հաշվել տրված ցուցակի զույգ թվերի գումարը։ \nՊարամետրեր:\n- numbers ([]int): Թվերի շերտ։\nՎերադարձնում է:\nint: Մուտքագրված շերտի զույգ թվերի գումարը։\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "bn": "প্রদত্ত তালিকার জোড় সংখ্যাগুলির যোগফল গণনা করুন।  \nপ্যারামিটারসমূহ:  \n- numbers ([]int): পূর্ণসংখ্যার একটি স্লাইস।  \nফেরত দেয়:  \nint: ইনপুট স্লাইসে জোড় সংখ্যাগুলির যোগফল।  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "bg": "Изчислете сумата на четните числа в даден списък.  \nПараметри:  \n- numbers ([]int): Списък от цели числа.  \nВръща:  \nint: Сумата на четните числа в входния списък.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "zh": "计算给定列表中偶数的和。  \n参数：  \n- numbers ([]int): 一个整数切片。  \n返回：  \nint: 输入切片中偶数的和。\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "fr": "Calculer la somme des nombres pairs dans une liste donnée.  \nParamètres :  \n- numbers ([]int) : Une tranche d'entiers.  \nRenvoie :  \nint : La somme des nombres pairs dans la tranche d'entrée.  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "de": "Berechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.  \nParameter:  \n- numbers ([]int): Ein Slice von ganzen Zahlen.  \nRückgabewert:  \nint: Die Summe der geraden Zahlen im Eingabeslice.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "ha": "Ƙididdige jimillar lambobin da suka zama ma'aurata a cikin jerin da aka bayar. \nSigogi:\n- numbers ([]int): Wani yanki na lambobi masu cikakken lamba.\nDawowa:\nint: Jimillar lambobin ma'aurata a cikin yanki na shigarwa.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hi": "दिए गए सूची में सम संख्या का योग गणना करें।  \nपैरामीटर्स:  \n- numbers ([]int): पूर्णांकों की एक स्लाइस।  \nवापसी:  \nint: इनपुट स्लाइस में सम संख्याओं का योग।  \n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6",
      "hu": "Számolja ki a páros számok összegét egy adott listában.  \nParaméterek:  \n- numbers ([]int): Egész számok szelete.  \nVisszatér:  \nint: A bemeneti szelet páros számainak összege.\n\n    >>> calculateEvenSum([]int{1,4,3,2,5})\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9867563193444988",
      "hy": "0.9668394524077496",
      "bn": "0.9941062393339328",
      "bg": "0.9665977192340302",
      "zh": "1",
      "fr": "1",
      "de": "0.9805082020786654",
      "ha": "0.9389223496140581",
      "hi": "0.9941062393339328",
      "hu": "0.984576350912641"
    }
  },
  {
    "task_id": "Go/10",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDetermine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n\nArgumentet:\na, b: Përfaqësimi i intervalit të parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\nc, d: Përfaqësimi i intervalit të dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n\nKthen:\nint: 1 nëse intervalet ndërpriten, 0 përndryshe.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՊարզել՝ արդյոք երկու փակ միջակայքեր հատվում են։\n\nԱրգումենտներ:\na, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000։\nc, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000։\n\nՎերադարձնում է:\nint: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুইটি বন্ধ ইন্টারভাল পরস্পরকে ছেদ করে কিনা তা নির্ধারণ করুন।\n\nআর্গুমেন্টসমূহ:\na, b: প্রথম বন্ধ ইন্টারভাল [a, b] কে উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\nc, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] কে উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n\nফেরত দেয়:\nint: ইন্টারভালগুলি ছেদ করলে 1, অন্যথায় 0।\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОпределете дали два затворени интервала се пресичат.\n\nАргументи:\na, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\nc, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n\nВръща:\nint: 1 ако интервалите се пресичат, 0 в противен случай.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n确定两个闭区间是否相交。\n\n参数:\na, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\nc, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n\n返回:\nint: 如果区间相交返回 1，否则返回 0。\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDéterminer si deux intervalles fermés s'intersectent.\n\nArguments:\na, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\nc, d: Représentant le deuxième intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n\nRenvoie:\nint: 1 si les intervalles s'intersectent, 0 sinon.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n\nArgumente:\na, b: Repräsentieren das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\nc, d: Repräsentieren das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n\nRückgabe:\nint: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKayyade ko wasu tazara biyu da aka rufe suna haduwa.\n\nHujojji:\na, b: Wakiltar tazara na farko da aka rufe [a, b] inda 0 <= a <= b <= 1000.\nc, d: Wakiltar tazara na biyu da aka rufe [c, d] inda 0 <= c <= d <= 1000.\n\nDawowa:\nint: 1 idan tazarorin sun hadu, 0 in ba haka ba.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nनिर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n\nआर्गुमेंट्स:\na, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\nc, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n\nवापसी मान:\nint: 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\n\nArgumentumok:\na, b: Az első zárt intervallumot [a, b] képviseli, ahol 0 <= a <= b <= 1000.\nc, d: A második zárt intervallumot [c, d] képviseli, ahol 0 <= c <= d <= 1000.\n\nVisszatér:\nint: 1, ha az intervallumok metszik egymást, különben 0.\n*/\nfunc AreIntervalsIntersecting(a, b, c, d int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9856896741983415",
      "hy": "0.9846335564623789",
      "bn": "0.984241062829454",
      "bg": "0.9864524148615155",
      "zh": "0.9661345131854567",
      "fr": "0.999999801369619",
      "de": "0.9780940484275673",
      "ha": "0.9893337471688075",
      "hi": "0.9695012981439981",
      "hu": "0.9822074849884188"
    },
    "canonical_solution": "if (c <= a && b <= d) ||\n\t\t(a <= c && c <= b && b <= d) ||\n\t\t(a <= c && d <= b) ||\n\t\t(c <= a && a <= d && d <= b) {\n\t\treturn 1 // Yes\n\t} else {\n\t\treturn 0 // No\n\t}\n}",
    "instruction": {
      "en": "Write a Go function `func AreIntervalsIntersecting(a, b, c, d int) int` to solve the following problem:\nDetermine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Shkruani një funksion Go `func AreIntervalsIntersecting(a, b, c, d int) int` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\n\nArgumentet:\na, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\nc, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n\nKthen:\nint: 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Գրեք Go ֆունկցիա `func AreIntervalsIntersecting(a, b, c, d int) int` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք, արդյոք երկու փակ միջակայքերը հատվում են:\n\nԱրգումենտներ:\na, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\nc, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n\nՎերադարձնում է:\nint: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում:",
      "bn": "একটি Go ফাংশন `func AreIntervalsIntersecting(a, b, c, d int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বন্ধ ইন্টারভাল একে অপরকে অতিক্রম করে কিনা নির্ধারণ করুন।\n\nআর্গুমেন্টসমূহ:\na, b: প্রথম বন্ধ ইন্টারভাল [a, b] প্রতিনিধিত্ব করছে যেখানে 0 <= a <= b <= 1000।\nc, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] প্রতিনিধিত্ব করছে যেখানে 0 <= c <= d <= 1000।\n\nরিটার্নস:\nint: ইন্টারভালগুলি অতিক্রম করলে 1, অন্যথায় 0।",
      "bg": "Напишете Go функция `func AreIntervalsIntersecting(a, b, c, d int) int`, за да решите следния проблем:\nОпределете дали два затворени интервала се пресичат.\n\nАргументи:\na, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\nc, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n\nВръща:\nint: 1 ако интервалите се пресичат, 0 в противен случай.",
      "zh": "编写一个 Go 函数 `func AreIntervalsIntersecting(a, b, c, d int) int` 来解决以下问题：\n确定两个闭区间是否相交。\n\n参数：\na, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\nc, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n\n返回：\nint: 如果区间相交则返回 1，否则返回 0。",
      "fr": "Écrire une fonction Go `func AreIntervalsIntersecting(a, b, c, d int) int` pour résoudre le problème suivant :\nDéterminer si deux intervalles fermés s'intersectent.\n\nArguments :\na, b : Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\nc, d : Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n\nRenvoie :\nint : 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Schreiben Sie eine Go-Funktion `func AreIntervalsIntersecting(a, b, c, d int) int`, um das folgende Problem zu lösen:\nBestimmen Sie, ob zwei geschlossene Intervalle sich überschneiden.\n\nArgumente:\na, b: Repräsentieren das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\nc, d: Repräsentieren das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n\nRückgabewert:\nint: 1, wenn sich die Intervalle überschneiden, 0 andernfalls.",
      "ha": "Rubuta aikin Go `func AreIntervalsIntersecting(a, b, c, d int) int` don warware matsalar mai zuwa:\nGano idan tazara biyu masu rufewa suna haduwa.\n\nHujjoji:\na, b: Wakiltar tazara na farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\nc, d: Wakiltar tazara na biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n\nDawowa:\nint: 1 idan tazarorin suna haduwa, 0 in ba haka ba.",
      "hi": "Go फ़ंक्शन `func AreIntervalsIntersecting(a, b, c, d int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n\nआर्गुमेंट्स:\na, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\nc, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n\nरिटर्न्स:\nint: 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।",
      "hu": "Írj egy Go függvényt `func AreIntervalsIntersecting(a, b, c, d int) int` a következő probléma megoldására:\nHatározd meg, hogy két zárt intervallum metszi-e egymást.\n\nArgumentumok:\na, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\nc, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\n\nVisszatérési érték:\nint: 1, ha az intervallumok metszik egymást, 0 különben."
    },
    "instruction_bertscore": {
      "sq": "0.9898507820506414",
      "hy": "0.9839703296201034",
      "bn": "0.9760056486013665",
      "bg": "0.9940259926599947",
      "zh": "0.95949231324365",
      "fr": "1",
      "de": "0.9795412693837876",
      "ha": "0.9884921502443628",
      "hi": "0.9640588257036422",
      "hu": "0.9784684666958181"
    },
    "level": "easy",
    "test": "func TestAreIntervalsIntersecting(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, AreIntervalsIntersecting(1, 1, 1, 2))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 2, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(3, 5, 4, 7))\n\tassert.Equal(0, AreIntervalsIntersecting(3, 5, 6, 7))\n\t// Additional test cases\n\tassert.Equal(1, AreIntervalsIntersecting(0, 0, 0, 0))\n\tassert.Equal(1, AreIntervalsIntersecting(1, 3, 2, 4))\n\tassert.Equal(0, AreIntervalsIntersecting(1, 3, 4, 6))\n\tassert.Equal(1, AreIntervalsIntersecting(10, 20, 20, 30))\n\tassert.Equal(0, AreIntervalsIntersecting(10, 20, 21, 30))\n}",
    "entry_point": "AreIntervalsIntersecting",
    "signature": "func AreIntervalsIntersecting(a, b, c, d int) int",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\n\nArguments:\na, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\nc, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n\nReturns:\nint: 1 if the intervals intersect, 0 otherwise.\n",
      "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n\nArgumentet:\na, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\nc, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n\nKthen:\nint: 1 nëse intervalet ndërpriten, 0 përndryshe.",
      "hy": "Երկու փակ միջակայքերի հատման որոշում։\n\nԱրգումենտներ՝\na, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\nc, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n\nՎերադարձնում է՝\nint: 1, եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։",
      "bn": "দুইটি বন্ধ ইন্টারভাল পরস্পরকে ছেদ করে কিনা তা নির্ধারণ করুন।\n\nআর্গুমেন্টস:\na, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\nc, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n\nরিটার্নস:\nint: ইন্টারভালগুলি যদি ছেদ করে তবে 1, অন্যথায় 0।",
      "bg": "Определете дали два затворени интервала се пресичат.\n\nАргументи:\na, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\nc, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n\nВръща:\nint: 1, ако интервалите се пресичат, 0 в противен случай.",
      "zh": "确定两个闭区间是否相交。\n\n参数：\na, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\nc, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n\n返回：\nint: 如果区间相交返回 1，否则返回 0。",
      "fr": "Déterminer si deux intervalles fermés s'intersectent.\n\nArguments:\na, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\nc, d: Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n\nRenvoie:\nint: 1 si les intervalles s'intersectent, 0 sinon.",
      "de": "Bestimmen, ob zwei abgeschlossene Intervalle sich überschneiden.\n\nArgumente:\na, b: Repräsentiert das erste abgeschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\nc, d: Repräsentiert das zweite abgeschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n\nRückgabewerte:\nint: 1, wenn die Intervalle sich überschneiden, 0 andernfalls.",
      "ha": "Gano ko rukunin tazara biyu masu rufe suna haduwa.\n\nHujojji:\na, b: Wakiltar rukunin tazara na farko mai rufe [a, b] inda 0 <= a <= b <= 1000.\nc, d: Wakiltar rukunin tazara na biyu mai rufe [c, d] inda 0 <= c <= d <= 1000.\n\nDawowa:\nint: 1 idan rukunin tazaran suna haduwa, 0 in ba haka ba.",
      "hi": "दो बंद अंतरालों के प्रतिच्छेदन का निर्धारण करें।\n\nतर्क:\na, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\nc, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n\nवापसी:\nint: 1 यदि अंतराल प्रतिच्छेद करते हैं, अन्यथा 0।",
      "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\n\nArgumentumok:\na, b: Az első zárt intervallumot [a, b] képviseli, ahol 0 <= a <= b <= 1000.\nc, d: A második zárt intervallumot [c, d] képviseli, ahol 0 <= c <= d <= 1000.\n\nVisszatérési érték:\nint: 1, ha az intervallumok metszik egymást, 0 különben."
    },
    "docstring_bertscore": {
      "sq": "0.9844081109799043",
      "hy": "0.9711556905876377",
      "bn": "0.9817206419245024",
      "bg": "0.9782994322415575",
      "zh": "0.9440966710400169",
      "fr": "1",
      "de": "0.9638419213275521",
      "ha": "0.9778604590994703",
      "hi": "0.9721510274270035",
      "hu": "0.9592080731683892"
    }
  },
  {
    "task_id": "Go/11",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nfunc HelloMMCODEEVAL() string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "zh": "包 main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Gibt \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück\nfunc HelloMMCODEEVAL() string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunc HelloMMCODEEVAL() string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nfunc HelloMMCODEEVAL() string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// Visszaadja a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget\nfunc HelloMMCODEEVAL() string {"
    },
    "prompt_bertscore": {
      "sq": "0.9982075594415412",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.9982075594415412",
      "zh": "0.9585794080124137",
      "fr": "0.9982075594415412",
      "de": "0.9982075594415412",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.9693255102567823"
    },
    "canonical_solution": "return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\n}",
    "instruction": {
      "en": "Write a Go function `func HelloMMCODEEVAL() string` to solve the following problem:\nReturn \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Shkruani një funksion Go `func HelloMMCODEEVAL() string` për të zgjidhur problemin e mëposhtëm: Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Գրեք Go ֆունկցիա `func HelloMMCODEEVAL() string`՝ հետևյալ խնդիրը լուծելու համար: Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "নিম্নলিখিত সমস্যার সমাধান করতে একটি Go ফাংশন `func HelloMMCODEEVAL() string` লিখুন: \n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" রিটার্ন করুন।",
      "bg": "Напишете Go функция `func HelloMMCODEEVAL() string`, за да решите следния проблем:  \nВърнете \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "编写一个 Go 函数 `func HelloMMCODEEVAL() string` 来解决以下问题：  \n返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Écrire une fonction Go `func HelloMMCODEEVAL() string` pour résoudre le problème suivant :  \nRetourner \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Schreiben Sie eine Go-Funktion `func HelloMMCODEEVAL() string`, um das folgende Problem zu lösen:  \nGeben Sie \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück.",
      "ha": "Rubuta aikin Go `func HelloMMCODEEVAL() string` don warware matsalar mai zuwa:\nMayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "Go फ़ंक्शन `func HelloMMCODEEVAL() string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं",
      "hu": "Írj egy Go függvényt `func HelloMMCODEEVAL() string` a következő probléma megoldására:  \nAdja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9938243828232443",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.9938243828232443",
      "ha": "0.9800140096906506",
      "hi": "1",
      "hu": "0.9796596530908843"
    },
    "level": "easy",
    "test": "func TestHelloMMCODEEVAL(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\", HelloMMCODEEVAL())\n}",
    "entry_point": "HelloMMCODEEVAL",
    "signature": "func HelloMMCODEEVAL() string",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնում է \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bg": "Върни \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Zurückgeben \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएँ",
      "hu": "Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget."
    },
    "docstring_bertscore": {
      "sq": "0.9081203391662159",
      "hy": "0.9560623638239396",
      "bn": "0.9201458196948301",
      "bg": "0.956679111157053",
      "zh": "0.956679111157053",
      "fr": "0.956679111157053",
      "de": "0.9441356025946998",
      "ha": "0.8762415534227836",
      "hi": "0.956679111157053",
      "hu": "0.956679111157053"
    }
  },
  {
    "task_id": "Go/12",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore llogarit totalin e pikëve për një student bazuar në pikët individuale në lëndë të ndryshme.\n\nParametrat:\n- scores (variadic ints): Lista e pikëve për secilën lëndë.\n\nKthen:\n- int: Totali i pikëve të marra duke mbledhur pikët individuale.\n\nShembuj:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore ֆունկցիան հաշվում է ուսանողի ընդհանուր միավորը՝ հիմնվելով տարբեր առարկաներում ստացված առանձին միավորների վրա։\n\nՊարամետրեր:\n- scores (variadic ints): Յուրաքանչյուր առարկայի համար ստացված միավորների ցուցակ։\n\nՎերադարձնում է:\n- int: Ընդհանուր միավորը, որը ստացվում է առանձին միավորների գումարումով։\n\nՕրինակներ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore বিভিন্ন বিষয়ের পৃথক স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করে।\n\nপ্যারামিটার:\n- scores (variadic ints): প্রতিটি বিষয়ের জন্য স্কোরের তালিকা।\n\nফেরত দেয়:\n- int: পৃথক স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore изчислява общия резултат за студент въз основа на индивидуалните резултати в различни предмети.\n\nПараметри:\n- scores (вариадични int): Списък с резултати за всеки предмет.\n\nВръща:\n- int: Общият резултат, получен чрез сумиране на индивидуалните резултати.\n\nПримери:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // връща 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore 计算学生在不同科目中的总分。\n\n参数:\n- scores (可变参数 int): 每个科目的分数列表。\n\n返回:\n- int: 通过将各个分数相加获得的总分。\n\n示例:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 返回 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore calcule le score total pour un étudiant basé sur les scores individuels dans différentes matières.\n\nParamètres:\n- scores (int variadique): Liste des scores pour chaque matière.\n\nRenvoie:\n- int: Le score total obtenu en additionnant les scores individuels.\n\nExemples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore berechnet die Gesamtpunktzahl für einen Schüler basierend auf den einzelnen Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- scores (variadic ints): Liste der Punktzahlen für jedes Fach.\n\nRückgabewerte:\n- int: Die Gesamtpunktzahl, die durch Summieren der einzelnen Punktzahlen erhalten wird.\n\nBeispiele:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore yana lissafin jimillar maki ga ɗalibi bisa ga maki ɗaya-ɗaya a fannoni daban-daban.\n\nSigogi:\n- scores (variadic ints): Jerin maki don kowane fanni.\n\nDawowa:\n- int: Jimillar maki da aka samu ta hanyar tara maki ɗaya-ɗaya.\n\nMisalai:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore एक छात्र के लिए विभिन्न विषयों में व्यक्तिगत अंकों के आधार पर कुल अंक की गणना करता है।\n\nपैरामीटर्स:\n- scores (variadic ints): प्रत्येक विषय के लिए अंकों की सूची।\n\nवापसी:\n- int: व्यक्तिगत अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCalculateTotalScore kiszámítja a diák összpontszámát a különböző tantárgyakban elért egyéni pontszámok alapján.\n\nParaméterek:\n- scores (variadic ints): Az egyes tantárgyak pontszámainak listája.\n\nVisszatér:\n- int: Az összpontszám, amelyet az egyéni pontszámok összegzésével kapunk.\n\nPéldák:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n*/\nfunc CalculateTotalScore(scores ...int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9867988262460403",
      "hy": "0.9790627687958745",
      "bn": "0.963534044236948",
      "bg": "0.9807123941103693",
      "zh": "0.9684286940864097",
      "fr": "0.9697187984112313",
      "de": "0.987930224896415",
      "ha": "0.9790303920437659",
      "hi": "0.9715922801651523",
      "hu": "0.9867545316710695"
    },
    "canonical_solution": "total := 0\n\tfor _, score := range scores {\n\t\ttotal += score\n\t}\n\treturn total\n}",
    "instruction": {
      "en": "Write a Go function `func CalculateTotalScore(scores ...int) int` to solve the following problem:\nCalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n",
      "sq": "Shkruani një funksion Go `func CalculateTotalScore(scores ...int) int` për të zgjidhur problemin e mëposhtëm:  \nCalculateTotalScore llogarit totalin e pikëve për një student bazuar në pikët individuale në lëndë të ndryshme.\n\nParametrat:  \n- scores (variadic ints): Lista e pikëve për secilën lëndë.\n\nKthen:  \n- int: Totali i pikëve të marra duke mbledhur pikët individuale.\n\nShembuj:  \n\tcalculateTotalScore(100, 100, 100, 100, 100) // kthen 500",
      "hy": "Գրեք Go ֆունկցիա `func CalculateTotalScore(scores ...int) int` հետևյալ խնդիրը լուծելու համար:\nCalculateTotalScore հաշվարկում է ուսանողի ընդհանուր միավորը՝ հիմնվելով տարբեր առարկաներում ստացված առանձին միավորների վրա։\n\nՊարամետրեր:\n- scores (variadic ints): Յուրաքանչյուր առարկայի համար ստացված միավորների ցուցակ։\n\nՎերադարձնում է:\n- int: Ընդհանուր միավորը, որը ստացվում է առանձին միավորների գումարումից։\n\nՕրինակներ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // վերադարձնում է 500",
      "bn": "একটি Go ফাংশন `func CalculateTotalScore(scores ...int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nCalculateTotalScore বিভিন্ন বিষয়ের পৃথক স্কোরের ভিত্তিতে একজন শিক্ষার্থীর মোট স্কোর গণনা করে।\n\nপ্যারামিটারসমূহ:\n- scores (variadic ints): প্রতিটি বিষয়ের জন্য স্কোরের তালিকা।\n\nরিটার্ন:\n- int: পৃথক স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500",
      "bg": "Напишете Go функция `func CalculateTotalScore(scores ...int) int`, за да решите следния проблем:  \nCalculateTotalScore изчислява общия резултат за студент въз основа на индивидуалните резултати в различни предмети.\n\nПараметри:\n- scores (вариадични int): Списък с резултати за всеки предмет.\n\nВръща:\n- int: Общият резултат, получен чрез сумиране на индивидуалните резултати.\n\nПримери:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // връща 500",
      "zh": "编写一个 Go 函数 `func CalculateTotalScore(scores ...int) int` 来解决以下问题：\nCalculateTotalScore 计算学生在不同科目中的总分。\n\n参数：\n- scores (可变参数 int): 每个科目的分数列表。\n\n返回：\n- int: 通过将各个分数相加得到的总分。\n\n示例：\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 返回 500",
      "fr": "Écrire une fonction Go `func CalculateTotalScore(scores ...int) int` pour résoudre le problème suivant :  \nCalculateTotalScore calcule le score total pour un étudiant basé sur les scores individuels dans différentes matières.\n\nParamètres :  \n- scores (entiers variadiques) : Liste des scores pour chaque matière.\n\nRenvoie :  \n- int : Le score total obtenu en additionnant les scores individuels.\n\nExemples :  \n\tcalculateTotalScore(100, 100, 100, 100, 100) // renvoie 500",
      "de": "Schreiben Sie eine Go-Funktion `func CalculateTotalScore(scores ...int) int`, um das folgende Problem zu lösen:\nCalculateTotalScore berechnet die Gesamtpunktzahl für einen Studenten basierend auf den individuellen Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- scores (variadic ints): Liste der Punktzahlen für jedes Fach.\n\nRückgabewert:\n- int: Die Gesamtpunktzahl, die durch Summieren der einzelnen Punktzahlen erhalten wird.\n\nBeispiele:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // gibt 500 zurück",
      "ha": "Rubuta aikin Go `func CalculateTotalScore(scores ...int) int` don warware matsalar mai zuwa:  \nCalculateTotalScore yana ƙididdige jimillar maki ga ɗalibi bisa ga maki ɗaya-ɗaya a fannoni daban-daban.\n\nSigogi:  \n- scores (variadic ints): Jerin maki don kowane fanni.\n\nYana dawowa:  \n- int: Jimillar maki da aka samu ta hanyar tara maki ɗaya-ɗaya.\n\nMisalai:  \n\tcalculateTotalScore(100, 100, 100, 100, 100) // yana dawowa 500",
      "hi": "एक Go फ़ंक्शन `func CalculateTotalScore(scores ...int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nCalculateTotalScore विभिन्न विषयों में व्यक्तिगत अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करता है।\n\nपैरामीटर्स:\n- scores (variadic ints): प्रत्येक विषय के लिए अंकों की सूची।\n\nवापसी:\n- int: व्यक्तिगत अंकों को जोड़कर प्राप्त कुल स्कोर।\n\nउदाहरण:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 लौटाता है",
      "hu": "Írj egy Go függvényt `func CalculateTotalScore(scores ...int) int` a következő probléma megoldására:\nCalculateTotalScore kiszámítja a diák összesített pontszámát a különböző tantárgyak egyéni pontszámai alapján.\n\nParaméterek:\n- scores (változó számú int): Az egyes tantárgyak pontszámainak listája.\n\nVisszatérési érték:\n- int: Az összesített pontszám, amely az egyéni pontszámok összegzésével nyerhető.\n\nPéldák:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // visszatér 500"
    },
    "instruction_bertscore": {
      "sq": "0.9868886071782681",
      "hy": "0.9859182977669126",
      "bn": "0.9641255655116698",
      "bg": "0.9785453366532786",
      "zh": "0.9573689544703872",
      "fr": "0.9708716491427578",
      "de": "0.988647677832713",
      "ha": "0.983625904539389",
      "hi": "0.9718278557970598",
      "hu": "0.9504258295013126"
    },
    "level": "easy",
    "test": "func TestCalculateTotalScore(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(500, CalculateTotalScore(100, 100, 100, 100, 100), \"should return the correct total score\")\n\tassert.Equal(0, CalculateTotalScore(0, 0, 0, 0, 0), \"should handle zero scores correctly\")\n\tassert.Equal(150, CalculateTotalScore(20, 30, 40, 10, 50), \"should return the correct total score for varied inputs\")\n\tassert.Equal(236, CalculateTotalScore(23, 45, 67, 89, 12), \"should return the correct total score for varied inputs\")\n\tassert.Equal(25, CalculateTotalScore(5, 5, 5, 5, 5), \"should return the correct total score for uniform inputs\")\n}",
    "entry_point": "CalculateTotalScore",
    "signature": "func CalculateTotalScore(scores ...int) int",
    "docstring": {
      "en": "CalculateTotalScore computes the total score for a student based on the individual scores in different subjects.\n\nParameters:\n- scores (variadic ints): List of scores for each subject.\n\nReturns:\n- int: The total score obtained by summing up the individual scores.\n\nExamples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // returns 500\n",
      "sq": "CalculateTotalScore llogarit totalin e pikëve për një student bazuar në pikët individuale në lëndë të ndryshme.\n\nParametrat:\n- scores (variadic ints): Lista e pikëve për secilën lëndë.\n\nKthen:\n- int: Totali i pikëve të marra duke mbledhur pikët individuale.\n\nShembuj:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // kthen 500",
      "hy": "CalculateTotalScore-ը հաշվում է ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված առանձին միավորների հիման վրա։\n\nՊարամետրեր:\n- scores (variadic ints): Առարկաների համար յուրաքանչյուր առանձին միավորների ցուցակ։\n\nՎերադարձնում է:\n- int: Ընդհանուր միավորը, որը ստացվում է առանձին միավորների գումարով։\n\nՕրինակներ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // վերադարձնում է 500",
      "bn": "CalculateTotalScore একটি ছাত্রের মোট স্কোর গণনা করে বিভিন্ন বিষয়ে পৃথক স্কোরের ভিত্তিতে।\n\nপ্যারামিটারসমূহ:\n- scores (variadic ints): প্রতিটি বিষয়ের জন্য স্কোরের তালিকা।\n\nফেরত দেয়:\n- int: পৃথক স্কোরগুলির যোগফল দ্বারা প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 ফেরত দেয়",
      "bg": "CalculateTotalScore изчислява общия резултат за студент въз основа на индивидуалните оценки в различни предмети.\n\nПараметри:\n- scores (вариадични цели числа): Списък с оценки за всеки предмет.\n\nВръща:\n- int: Общият резултат, получен чрез сумиране на индивидуалните оценки.\n\nПримери:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // връща 500",
      "zh": "CalculateTotalScore 计算学生在不同科目中的个别分数的总分。\n\n参数：\n- scores (variadic ints): 每个科目的分数列表。\n\n返回：\n- int: 通过将各个分数相加得到的总分。\n\n示例：\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 返回 500",
      "fr": "CalculateTotalScore calcule le score total pour un étudiant basé sur les scores individuels dans différentes matières.\n\nParamètres:\n- scores (variadic ints): Liste des scores pour chaque matière.\n\nRenvoie:\n- int: Le score total obtenu en additionnant les scores individuels.\n\nExemples:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // renvoie 500",
      "de": "CalculateTotalScore berechnet die Gesamtpunktzahl für einen Schüler basierend auf den einzelnen Punktzahlen in verschiedenen Fächern.\n\nParameter:\n- scores (variadic ints): Liste der Punktzahlen für jedes Fach.\n\nRückgabewerte:\n- int: Die Gesamtpunktzahl, die durch Summieren der einzelnen Punktzahlen erhalten wird.\n\nBeispiele:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // gibt 500 zurück",
      "ha": "CalculateTotalScore yana lissafin jimillar maki ga ɗalibi bisa ga maki na kowane fanni daban-daban.\n\nSigogi:\n- scores (variadic ints): Jerin maki don kowane fanni.\n\nDawowa:\n- int: Jimillar maki da aka samu ta hanyar tara maki na kowane fanni.\n\nMisalai:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // yana dawowa 500",
      "hi": "CalculateTotalScore एक छात्र के लिए विभिन्न विषयों में व्यक्तिगत अंकों के आधार पर कुल स्कोर की गणना करता है।\n\nपैरामीटर्स:\n- scores (variadic ints): प्रत्येक विषय के लिए अंकों की सूची।\n\nवापसी:\n- int: व्यक्तिगत अंकों को जोड़कर प्राप्त कुल स्कोर।\n\nउदाहरण:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // 500 लौटाता है",
      "hu": "CalculateTotalScore kiszámítja a diák összpontszámát a különböző tantárgyakban elért egyéni pontszámok alapján.\n\nParaméterek:\n- scores (variadic ints): Az egyes tantárgyak pontszámainak listája.\n\nVisszatér:\n- int: Az összpontszám, amelyet az egyéni pontszámok összegzésével kapunk.\n\nPéldák:\n\tcalculateTotalScore(100, 100, 100, 100, 100) // visszaadja: 500"
    },
    "docstring_bertscore": {
      "sq": "0.9826899581839525",
      "hy": "0.97993137945214",
      "bn": "0.959440669344581",
      "bg": "0.9535332031822223",
      "zh": "0.9442929178564794",
      "fr": "0.974026495484735",
      "de": "0.98241306743279",
      "ha": "0.9633449481142028",
      "hi": "0.9624080086068612",
      "hu": "0.9787471451204101"
    }
  },
  {
    "task_id": "Go/13",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers deshifron një seri numrash për të zbuluar modelin e fshehur që tregon\nvlerat aktuale që përfaqëson secila shifër. Modeli përcaktohet si më poshtë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati që korrespondon me secilin varg të dhënash sipas modelit të paracaktuar.\n\nShembull përdorimi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers-ը վերծանում է թվերի շարք՝ բացահայտելու թաքնված օրինաչափությունը, որը ցույց է տալիս\nյուրաքանչյուր թվանշանի ներկայացրած իրական արժեքները: Օրինաչափությունը սահմանված է հետևյալ կերպ.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- dataStr: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի նախապես սահմանված օրինաչափությանը:\n\nՕրինակ օգտագործում:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers সংখ্যার একটি সিরিজ ডিকোড করে লুকানো প্যাটার্ন প্রকাশ করে যা প্রতিটি সংখ্যার প্রকৃত মান নির্দেশ করে। প্যাটার্নটি নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের জন্য পূর্বনির্ধারিত প্যাটার্ন অনুযায়ী ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers декодира поредица от числа, за да разкрие скрития модел, който показва\nдействителните стойности, които всяка цифра представлява. Моделът е дефиниран по следния начин:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- dataStr: Низ, представляващ поредица от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът, съответстващ на всеки низ от данни според предварително определения модел.\n\nПример за използване:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers 解码一系列数字以揭示隐藏模式，该模式指示每个数字代表的实际值。模式定义如下：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数:\n- dataStr: 表示一系列数字的字符串。长度不超过100。\n\n返回:\nint: 根据预定义模式对应于每个数据字符串的结果。\n\n示例用法:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers décode une série de chiffres pour révéler le motif caché qui indique\nles valeurs réelles que chaque chiffre représente. Le motif est défini comme suit :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- dataStr : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat correspondant à chaque chaîne de données selon le motif prédéfini.\n\nExemple d'utilisation :\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers dekodiert eine Serie von Zahlen, um das verborgene Muster zu enthüllen, das die tatsächlichen Werte angibt, die jede Ziffer darstellt. Das Muster ist wie folgt definiert:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- dataStr: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis, das jedem Datenstring gemäß dem vordefinierten Muster entspricht.\n\nBeispielverwendung:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers yana fassara jerin lambobi don bayyana tsarin ɓoye wanda ke nuna\nainihin ƙimar da kowace lamba ke wakilta. An ayyana tsarin kamar haka:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- dataStr: Wani igiyar rubutu da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nDawowa:\nint: Sakamakon da ya dace da kowace igiyar bayanai bisa tsarin da aka riga aka ayyana.\n\nMisalin amfani:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers संख्याओं की एक श्रृंखला को डिकोड करता है ताकि छिपे हुए पैटर्न का पता चल सके जो दर्शाता है\nप्रत्येक अंक का वास्तविक मान क्या है। पैटर्न निम्नलिखित के रूप में परिभाषित है:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- dataStr: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती है।\n\nवापसी:\nint: पूर्वनिर्धारित पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के अनुरूप परिणाम।\n\nउदाहरण उपयोग:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDecodeNumbers dekódolja a számok sorozatát, hogy felfedje a rejtett mintát, amely jelzi,\nhogy az egyes számjegyek valójában milyen értékeket képviselnek. A minta a következőképpen van meghatározva:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- dataStr: Egy karakterlánc, amely egy számok sorozatát képviseli. A hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az eredmény, amely az egyes adatkarakterláncokhoz tartozik az előre meghatározott minta szerint.\n\nPélda használat:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))\n*/\nfunc DecodeNumbers(dataStr string) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9936599168677474",
      "hy": "0.9826091156188714",
      "bn": "0.9765687657316005",
      "bg": "0.9911188384031681",
      "zh": "0.9890556646353587",
      "fr": "0.9857349619252175",
      "de": "0.993822992410577",
      "ha": "0.9764716354752744",
      "hi": "0.9793078786860716",
      "hu": "0.988909472674917"
    },
    "canonical_solution": "a := []int{1, 0, 0, 0, 1, 0, 1, 0, 2, 1}\n\tans := 0\n\tfor i := 0; i < len(dataStr); i++ {\n\t\tans += a[dataStr[i]-'0']\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func DecodeNumbers(dataStr string) int` to solve the following problem:\nDecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "sq": "Shkruani një funksion Go `func DecodeNumbers(dataStr string) int` për të zgjidhur problemin e mëposhtëm:\nDecodeNumbers dekodon një seri numrash për të zbuluar modelin e fshehur që tregon vlerat aktuale që përfaqëson secila shifër. Modeli është i përcaktuar si më poshtë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati që korrespondon me secilin varg të dhënash sipas modelit të paracaktuar.\n\nShembull përdorimi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hy": "Գրեք Go ֆունկցիա `func DecodeNumbers(dataStr string) int` հետևյալ խնդիրը լուծելու համար:\nDecodeNumbers-ը վերծանում է թվերի շարք, որպեսզի բացահայտի թաքնված օրինաչափությունը, որը ցույց է տալիս, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան: Օրինաչափությունը սահմանված է հետևյալ կերպ.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- dataStr: Թվերի շարք ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի՝ նախապես սահմանված օրինաչափության համաձայն:\n\nՕրինակ օգտագործում:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "bn": "একটি Go ফাংশন `func DecodeNumbers(dataStr string) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nDecodeNumbers একটি সংখ্যার সিরিজ ডিকোড করে লুকানো প্যাটার্ন প্রকাশ করে যা প্রতিটি অঙ্কের প্রকৃত মান নির্দেশ করে। প্যাটার্নটি নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিংয়ের জন্য পূর্বনির্ধারিত প্যাটার্ন অনুযায়ী ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "bg": "Напишете Go функция `func DecodeNumbers(dataStr string) int`, за да решите следния проблем:\nDecodeNumbers декодира серия от числа, за да разкрие скрития модел, който показва действителните стойности, които всяка цифра представлява. Моделът е дефиниран, както следва:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- dataStr: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът, съответстващ на всеки низ от данни според предварително определения модел.\n\nПример за използване:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "zh": "编写一个 Go 函数 `func DecodeNumbers(dataStr string) int` 来解决以下问题：\nDecodeNumbers 解码一系列数字以揭示隐藏的模式，该模式指示每个数字代表的实际值。模式定义如下：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- dataStr: 一个表示一系列数字的字符串。长度不超过 100。\n\n返回：\nint: 根据预定义模式对应于每个数据字符串的结果。\n\n示例用法：\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "fr": "Écrire une fonction Go `func DecodeNumbers(dataStr string) int` pour résoudre le problème suivant :\nDecodeNumbers décode une série de chiffres pour révéler le motif caché qui indique les valeurs réelles que chaque chiffre représente. Le motif est défini comme suit :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- dataStr : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat correspondant à chaque chaîne de données selon le motif prédéfini.\n\nExemple d'utilisation :\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "de": "Schreiben Sie eine Go-Funktion `func DecodeNumbers(dataStr string) int`, um das folgende Problem zu lösen:\nDecodeNumbers dekodiert eine Reihe von Zahlen, um das verborgene Muster zu enthüllen, das die tatsächlichen Werte angibt, die jede Ziffer darstellt. Das Muster ist wie folgt definiert:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- dataStr: Ein String, der eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis, das jedem Datenstring gemäß dem vordefinierten Muster entspricht.\n\nBeispielverwendung:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "ha": "Rubuta aikin Go `func DecodeNumbers(dataStr string) int` don warware matsalar mai zuwa:\nDecodeNumbers yana fassara jerin lambobi don bayyana tsarin ɓoyayyen wanda ke nuna ainihin ƙimar kowace lamba ke wakilta. An ayyana tsarin kamar haka:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- dataStr: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nDawowa:\nint: Sakamakon da ya dace da kowanne kirtani na bayanai bisa tsarin da aka riga aka ayyana.\n\nMisalin amfani:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hi": "Go फ़ंक्शन `func DecodeNumbers(dataStr string) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nDecodeNumbers संख्याओं की एक श्रृंखला को डिकोड करता है ताकि छिपे हुए पैटर्न का पता चल सके जो संकेत करता है कि प्रत्येक अंक का वास्तविक मान क्या है। पैटर्न इस प्रकार परिभाषित है:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- dataStr: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: पूर्वनिर्धारित पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के लिए परिणाम।\n\nउदाहरण उपयोग:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hu": "Írj egy Go függvényt `func DecodeNumbers(dataStr string) int` a következő probléma megoldására:\nDecodeNumbers dekódolja a számok sorozatát, hogy feltárja a rejtett mintát, amely jelzi, hogy az egyes számjegyek valójában milyen értékeket képviselnek. A minta a következőképpen van meghatározva:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- dataStr: Egy karakterlánc, amely számok sorozatát képviseli. A hossza nem haladja meg a 100-at.\n\nVisszatér:\nint: Az eredmény, amely megfelel az egyes adatkarakterláncoknak az előre meghatározott minta szerint.\n\nPélda használat:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))"
    },
    "instruction_bertscore": {
      "sq": "0.9930846832842704",
      "hy": "0.9891815962969348",
      "bn": "0.9726652814835028",
      "bg": "0.996891434536804",
      "zh": "0.9898918985395155",
      "fr": "0.9928640049309406",
      "de": "0.9946856441554116",
      "ha": "0.9734810564584131",
      "hi": "0.958199030832732",
      "hu": "0.9870429429843322"
    },
    "level": "easy",
    "test": "func TestDecodeNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, DecodeNumbers(\"0000\"))\n\tassert.Equal(8, DecodeNumbers(\"8888\"))\n\tassert.Equal(1, DecodeNumbers(\"1234\"))\n\tassert.Equal(3, DecodeNumbers(\"5678\"))\n\tassert.Equal(2, DecodeNumbers(\"9012\"))\n\tassert.Equal(0, DecodeNumbers(\"1357\"))\n\tassert.Equal(4, DecodeNumbers(\"2468\"))\n\n\t// Additional test samples\n\tassert.Equal(4, DecodeNumbers(\"9999\"))\n\tassert.Equal(0, DecodeNumbers(\"1111\"))\n\tassert.Equal(0, DecodeNumbers(\"2222\"))\n\tassert.Equal(0, DecodeNumbers(\"3333\"))\n\tassert.Equal(4, DecodeNumbers(\"4444\"))\n\tassert.Equal(0, DecodeNumbers(\"5555\"))\n\tassert.Equal(4, DecodeNumbers(\"6666\"))\n\tassert.Equal(0, DecodeNumbers(\"7777\"))\n\tassert.Equal(3, DecodeNumbers(\"0001\"))\n\tassert.Equal(1, DecodeNumbers(\"2301\"))\n}",
    "entry_point": "DecodeNumbers",
    "signature": "func DecodeNumbers(dataStr string) int",
    "docstring": {
      "en": "DecodeNumbers decodes a series of numbers to reveal the hidden pattern which indicates\nthe actual values each digit represents. The pattern is defined as follows:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. The length does not exceed 100.\n\nReturns:\nint: The result corresponding to each data string according to the predefined pattern.\n\nExample usage:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "sq": "DecodeNumbers dekodon një seri numrash për të zbuluar modelin e fshehur që tregon vlerat aktuale që përfaqëson secila shifër. Modeli është i përcaktuar si më poshtë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati që korrespondon me secilin varg të dhënash sipas modelit të paracaktuar.\n\nShembull përdorimi:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hy": "DecodeNumbers-ը վերծանում է թվերի շարք՝ բացահայտելու թաքնված օրինաչափությունը, որը ցույց է տալիս, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան: Օրինաչափությունը սահմանված է հետևյալ կերպ.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- dataStr: Թվերի շարքը ներկայացնող տող: Երկարությունը չի գերազանցում 100-ը:\n\nՎերադարձնում է:\nint: Արդյունքը, որը համապատասխանում է յուրաքանչյուր տվյալ տողի՝ նախապես սահմանված օրինաչափության համաձայն:\n\nՕրինակ օգտագործում:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "bn": "DecodeNumbers একটি সংখ্যার সিরিজ ডিকোড করে লুকানো প্যাটার্ন প্রকাশ করে যা প্রতিটি অঙ্কের প্রকৃত মান নির্দেশ করে। প্যাটার্নটি নিম্নরূপ সংজ্ঞায়িত করা হয়েছে:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের জন্য পূর্বনির্ধারিত প্যাটার্ন অনুযায়ী ফলাফল।\n\nউদাহরণ ব্যবহার:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "bg": "DecodeNumbers декодира поредица от числа, за да разкрие скрития модел, който показва действителните стойности, които всяка цифра представлява. Моделът е дефиниран както следва:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- dataStr: Низ, представляващ поредица от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът, съответстващ на всеки низ от данни според предварително дефинирания модел.\n\nПример за използване:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "zh": "DecodeNumbers 解码一系列数字以揭示隐藏的模式，该模式指示每个数字代表的实际值。模式定义如下：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- dataStr: 表示一系列数字的字符串。长度不超过 100。\n\n返回：\nint: 根据预定义模式对应于每个数据字符串的结果。\n\n示例用法：\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "fr": "DecodeNumbers décode une série de chiffres pour révéler le motif caché qui indique les valeurs réelles que chaque chiffre représente. Le motif est défini comme suit :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- dataStr : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat correspondant à chaque chaîne de données selon le motif prédéfini.\n\nExemple d'utilisation :\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "de": "DecodeNumbers dekodiert eine Reihe von Zahlen, um das verborgene Muster zu enthüllen, das die tatsächlichen Werte angibt, die jede Ziffer darstellt. Das Muster ist wie folgt definiert:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- dataStr: Ein String, der eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis, das jedem Datenstring gemäß dem vordefinierten Muster entspricht.\n\nBeispielverwendung:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "ha": "DecodeNumbers yana fassara jerin lambobi don bayyana tsarin ɓoye wanda ke nuna\nainihin ƙimar da kowace lamba ke wakilta. An ayyana tsarin kamar haka:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- dataStr: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nDawowa:\nint: Sakamakon da ya dace da kowanne kirtani na bayanai bisa ga tsarin da aka riga aka ayyana.\n\nMisalin amfani:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hi": "DecodeNumbers संख्याओं की एक श्रृंखला को डिकोड करता है ताकि छिपे हुए पैटर्न का पता चल सके, जो यह दर्शाता है कि प्रत्येक अंक का वास्तविक मान क्या है। पैटर्न निम्नलिखित रूप से परिभाषित है:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- dataStr: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती है।\n\nवापसी:\nint: पूर्वनिर्धारित पैटर्न के अनुसार प्रत्येक डेटा स्ट्रिंग के लिए परिणाम।\n\nउदाहरण उपयोग:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))",
      "hu": "DecodeNumbers dekódol egy számsorozatot, hogy felfedje a rejtett mintát, amely jelzi, hogy az egyes számjegyek valójában milyen értékeket képviselnek. A minta a következőképpen van meghatározva:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- dataStr: Egy számsorozatot reprezentáló karakterlánc. A hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az eredmény, amely megfelel az egyes adatkarakterláncoknak az előre meghatározott minta szerint.\n\nPélda használat:\nassert.Equal(t, 4, DecodeNumbers(\"0000\"))"
    },
    "docstring_bertscore": {
      "sq": "0.9924967373564071",
      "hy": "0.9847718032075793",
      "bn": "0.9660630062482842",
      "bg": "0.9910379958380868",
      "zh": "0.9922109082380979",
      "fr": "0.9898595217874069",
      "de": "0.9934022932635451",
      "ha": "0.9758479360788248",
      "hi": "0.9748339279836418",
      "hu": "0.97925385122243"
    }
  },
  {
    "task_id": "Go/14",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë\nme m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe\nkatrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nArgumentet:\n    n int: Numri i katrorëve.\n    m int: Numri i ngjyrave.\n\nKthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n\nShembuj:\n    CountColoringMethods(1,1) kthen 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների թիվը\nm գույներով, հաշվի առնելով պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\nԱրգումենտներ:\n    n int: Քառակուսիների քանակը:\n    m int: Գույների քանակը:\n\nՎերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների թիվը, որոնք բավարարում են նշված պայմանները:\n\nՕրինակներ:\n    CountColoringMethods(1,1) վերադարձնում է 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods n টি বর্গক্ষেত্র এবং m টি রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nযেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n\nআর্গুমেন্টসমূহ:\n    n int: বর্গক্ষেত্রের সংখ্যা।\n    m int: রঙের সংখ্যা।\n\nফেরত দেয়:\n    int: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n\nউদাহরণ:\n    CountColoringMethods(1,1) 1 ফেরত দেয়\n*/\nfunc CountColoringMethods(n, m int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods брои броя на различните методи за оцветяване на n квадрата\nс m цвята, като се взема предвид изискването съседните квадрати и\nпървият/последният квадрат да са с различни цветове.\n\nАргументи:\n    n int: Броят на квадратите.\n    m int: Броят на цветовете.\n\nВръща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n\nПримери:\n    CountColoringMethods(1,1) връща 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods 计算使用 m 种颜色对 n 个方块进行不同着色的方法数，\n考虑到相邻方块和第一个/最后一个方块必须具有不同颜色的要求。\n\n参数:\n    n int: 方块的数量。\n    m int: 颜色的数量。\n\n返回:\n    int: 满足指定条件的不同着色方法的数量。\n\n示例:\n    CountColoringMethods(1,1) 返回 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods compte le nombre de méthodes de coloration différentes pour n carrés\navec m couleurs, en considérant l'exigence que les carrés adjacents et les\npremier/dernier carrés doivent avoir des couleurs différentes.\n\nArgs:\n    n int: Le nombre de carrés.\n    m int: Le nombre de couleurs.\n\nReturns:\n    int: Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate\nmit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die\nersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\nArgumente:\n    n int: Die Anzahl der Quadrate.\n    m int: Die Anzahl der Farben.\n\nRückgabewerte:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n\nBeispiele:\n    CountColoringMethods(1,1) gibt 1 zurück\n*/\nfunc CountColoringMethods(n, m int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods yana ƙirga adadin hanyoyin launi daban-daban don murabba'i n\ntare da launuka m, la'akari da buƙatar cewa murabba'ai masu makwabtaka da\nmurabba'i na farko/na ƙarshe dole ne su sami launuka daban-daban.\n\nArgs:\n    n int: Yawan murabba'ai.\n    m int: Yawan launuka.\n\nReturns:\n    int: Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan da aka fayyace.\n\nMisalai:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods n वर्गों के लिए विभिन्न रंगाई विधियों की संख्या की गणना करता है\nm रंगों के साथ, इस आवश्यकता पर विचार करते हुए कि आसन्न वर्ग और\nपहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nआर्ग्स:\n    n int: वर्गों की संख्या।\n    m int: रंगों की संख्या।\n\nवापसी:\n    int: निर्दिष्ट शर्तों को पूरा करने वाली विभिन्न रंगाई विधियों की गिनती।\n\nउदाहरण:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCountColoringMethods megszámolja a különböző színezési módszerek számát n négyzetre\nm színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az\nelső/utolsó négyzetek különböző színűek legyenek.\n\nArgs:\n    n int: A négyzetek száma.\n    m int: A színek száma.\n\nReturns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n*/\nfunc CountColoringMethods(n, m int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9709032313733423",
      "hy": "0.9720701848619223",
      "bn": "0.9538351213613955",
      "bg": "0.9772125267965345",
      "zh": "0.9444105070420521",
      "fr": "0.996350365378865",
      "de": "0.9720322464591447",
      "ha": "0.9815116827636536",
      "hi": "0.9772733076931311",
      "hu": "0.9806837913355002"
    },
    "canonical_solution": "const mod = 1000003\n\tf := make([]int, 1111) // slice to store results\n\tif n == 1 {\n\t\treturn m\n\t}\n\tif n == 2 {\n\t\treturn m * (m - 1) % mod\n\t}\n\t// Initialize the first three elements\n\tf[1] = m\n\tf[2] = m * (m - 1) % mod\n\t// Formula derived from the given condition\n\tf[3] = f[2] * (m - 2) % mod\n\tfor i := 4; i <= n; i++ {\n\t\tf[i] = (f[i-1]*(m-2)%mod + f[i-2]*(m-1)%mod) % mod\n\t}\n\treturn f[n]\n}",
    "instruction": {
      "en": "Write a Go function `func CountColoringMethods(n, m int) int` to solve the following problem:\nCountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n",
      "sq": "Shkruani një funksion Go `func CountColoringMethods(n, m int) int` për të zgjidhur problemin e mëposhtëm:\nCountColoringMethods numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë\nme m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe\nkatrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nArgumentet:\n    n int: Numri i katrorëve.\n    m int: Numri i ngjyrave.\n\nKthen:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n\nShembuj:\n    CountColoringMethods(1,1) kthen 1",
      "hy": "Գրեք Go ֆունկցիա `func CountColoringMethods(n, m int) int` հետևյալ խնդիրը լուծելու համար:\nCountColoringMethods հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ։\n\nԱրձանագրություններ:\n    n int: Քառակուսիների քանակը։\n    m int: Գույների քանակը։\n\nՎերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։\n\nՕրինակներ:\n    CountColoringMethods(1,1) վերադարձնում է 1",
      "bn": "একটি Go ফাংশন `func CountColoringMethods(n, m int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nCountColoringMethods nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, এই শর্ত বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\nআর্গুমেন্টসমূহ:\n    n int: বর্গক্ষেত্রের সংখ্যা।\n    m int: রঙের সংখ্যা।\n\nফেরত দেয়:\n    int: নির্দিষ্ট শর্তাবলী পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n\nউদাহরণ:\n    CountColoringMethods(1,1) 1 ফেরত দেয়",
      "bg": "Напишете Go функция `func CountColoringMethods(n, m int) int`, за да решите следния проблем:  \nCountColoringMethods брои броя на различните методи за оцветяване за n квадрата с m цвята, като се взема предвид изискването съседните квадрати и първият/последният квадрат да имат различни цветове.\n\nАргументи:\n    n int: Броят на квадратите.\n    m int: Броят на цветовете.\n\nВръща:\n    int: Броят на различните методи за оцветяване, които удовлетворяват указаните условия.\n\nПримери:\n    CountColoringMethods(1,1) връща 1",
      "zh": "编写一个 Go 函数 `func CountColoringMethods(n, m int) int` 来解决以下问题：\nCountColoringMethods 计算使用 m 种颜色对 n 个方块进行不同着色的方法数量，考虑到相邻方块和首/尾方块必须具有不同颜色的要求。\n\n参数:\n    n int: 方块的数量。\n    m int: 颜色的数量。\n\n返回:\n    int: 满足指定条件的不同着色方法的数量。\n\n示例:\n    CountColoringMethods(1,1) 返回 1",
      "fr": "Écrire une fonction Go `func CountColoringMethods(n, m int) int` pour résoudre le problème suivant :  \nCountColoringMethods compte le nombre de méthodes de coloriage différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\nArgs:\n    n int: Le nombre de carrés.\n    m int: Le nombre de couleurs.\n\nReturns:\n    int: Le compte des différentes méthodes de coloriage satisfaisant les conditions spécifiées.\n\nExemples:\n    CountColoringMethods(1,1) retourne 1",
      "de": "Schreiben Sie eine Go-Funktion `func CountColoringMethods(n, m int) int`, um das folgende Problem zu lösen:\nCountColoringMethods zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\nArgs:\n    n int: Die Anzahl der Quadrate.\n    m int: Die Anzahl der Farben.\n\nReturns:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n\nBeispiele:\n    CountColoringMethods(1,1) gibt 1 zurück",
      "ha": "Rubuta aikin Go `func CountColoringMethods(n, m int) int` don warware matsalar mai zuwa:\nCountColoringMethods yana ƙirga adadin hanyoyin launuka daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabta da kuma murabba'i na farko/na ƙarshe dole ne su sami launuka daban.\n\nArgs:\n    n int: Yawan murabba'ai.\n    m int: Yawan launuka.\n\nReturns:\n    int: Adadin hanyoyin launuka daban-daban da suka cika yanayin da aka fayyace.\n\nMisalai:\n    CountColoringMethods(1,1) yana dawowa 1",
      "hi": "Go फ़ंक्शन `func CountColoringMethods(n, m int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nCountColoringMethods n वर्गों के लिए m रंगों के विभिन्न रंगाई तरीकों की संख्या गिनता है, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nआर्ग्स:\n    n int: वर्गों की संख्या।\n    m int: रंगों की संख्या।\n\nवापसी:\n    int: निर्दिष्ट शर्तों को संतोषजनक बनाने वाले विभिन्न रंगाई तरीकों की गिनती।\n\nउदाहरण:\n    CountColoringMethods(1,1) 1 लौटाता है",
      "hu": "Írj egy Go függvényt `func CountColoringMethods(n, m int) int` a következő probléma megoldására:\nCountColoringMethods megszámolja a különböző színezési módszerek számát n négyzetre\nm színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az\nelső/utolsó négyzetek különböző színűek legyenek.\n\nArgok:\n    n int: A négyzetek száma.\n    m int: A színek száma.\n\nVisszatér:\n    int: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n\nPéldák:\n    CountColoringMethods(1,1) visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9715023006025436",
      "hy": "0.9683454679567561",
      "bn": "0.9560534254567931",
      "bg": "0.9805093938609516",
      "zh": "0.9436624650270746",
      "fr": "1",
      "de": "0.9820571217899754",
      "ha": "0.9814606347557276",
      "hi": "0.987082073169396",
      "hu": "0.9820481834228288"
    },
    "level": "hard",
    "test": "func TestCountColoringMethods(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, CountColoringMethods(1, 1))\n\tassert.Equal(2, CountColoringMethods(2, 2))\n\tassert.Equal(6, CountColoringMethods(3, 3))\n\tassert.Equal(2, CountColoringMethods(4, 2))\n\t// Add your tests here\n\tassert.Equal(6, CountColoringMethods(2, 3))\n\tassert.Equal(67911, CountColoringMethods(1000, 1000))\n\tassert.Equal(501817, CountColoringMethods(999, 66))\n\tassert.Equal(30, CountColoringMethods(5, 3))\n\n\t// Test with unknown expected result, assuming a placeholder value is \"expectedResult\".\n\t// Replace \"expectedResult\" with the actual expected value if known.\n\texpectedResult := 566585 // Placeholder for the expected result of CountColoringMethods(1000, 10)\n\tassert.Equal(expectedResult, CountColoringMethods(1000, 10))\n}",
    "entry_point": "CountColoringMethods",
    "signature": "func CountColoringMethods(n, m int) int",
    "docstring": {
      "en": "CountColoringMethods counts the number of different coloring methods for n squares\nwith m colors, considering the requirement that adjacent squares and the\nfirst/last squares must have different colors.\n\nArgs:\n    n int: The number of squares.\n    m int: The number of colors.\n\nReturns:\n    int: The count of different coloring methods satisfying the specified conditions.\n\nExamples:\n    CountColoringMethods(1,1) returns 1\n",
      "sq": "CountColoringMethods numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nArgs:\n    n int: Numri i katrorëve.\n    m int: Numri i ngjyrave.\n\nReturns:\n    int: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "hy": "CountColoringMethods-ը հաշվում է n քառակուսիների համար տարբեր գունավորման մեթոդների քանակը՝ m գույներով, հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\nԱրգումենտներ:\n    n int: Քառակուսիների քանակը։\n    m int: Գույների քանակը։\n\nՎերադարձնում է:\n    int: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։\n\nՕրինակներ:\n    CountColoringMethods(1,1) վերադարձնում է 1",
      "bn": "CountColoringMethods গণনা করে কতগুলি ভিন্ন রঙ করার পদ্ধতি আছে n স্কোয়ারের জন্য m রঙ দিয়ে, যেখানে শর্ত হল যে সংলগ্ন স্কোয়ার এবং প্রথম/শেষ স্কোয়ারগুলির রঙ ভিন্ন হতে হবে।\n\nArgs:\n    n int: স্কোয়ারের সংখ্যা।\n    m int: রঙের সংখ্যা।\n\nReturns:\n    int: নির্দিষ্ট শর্তগুলি পূরণ করে এমন ভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "bg": "CountColoringMethods брои броя на различните методи за оцветяване за n квадрата с m цвята, като се взема предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\nArgs:\n    n int: Броят на квадратите.\n    m int: Броят на цветовете.\n\nReturns:\n    int: Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n\nExamples:\n    CountColoringMethods(1,1) връща 1",
      "zh": "CountColoringMethods 计算使用 m 种颜色对 n 个方块进行不同着色的方法数量，考虑到相邻方块和首尾方块必须具有不同颜色的要求。\n\n参数：\n    n int: 方块的数量。\n    m int: 颜色的数量。\n\n返回：\n    int: 满足指定条件的不同着色方法的数量。\n\n示例：\n    CountColoringMethods(1,1) 返回 1",
      "fr": "CountColoringMethods compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\nArgs:\n    n int: Le nombre de carrés.\n    m int: Le nombre de couleurs.\n\nReturns:\n    int: Le nombre de méthodes de coloration différentes satisfaisant les conditions spécifiées.\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "de": "CountColoringMethods zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, wobei die Anforderung besteht, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\nArgs:\n    n int: Die Anzahl der Quadrate.\n    m int: Die Anzahl der Farben.\n\nReturns:\n    int: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "ha": "CountColoringMethods yana ƙididdige adadin hanyoyin launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da na farko/na ƙarshe dole ne su sami launuka daban-daban.\n\nArgs:\n    n int: Yawan murabba'ai.\n    m int: Yawan launuka.\n\nReturns:\n    int: Adadin hanyoyin launi daban-daban da suka cika yanayin da aka fayyace.\n\nExamples:\n    CountColoringMethods(1,1) returns 1",
      "hi": "CountColoringMethods विभिन्न रंग भरने की विधियों की संख्या की गणना करता है n वर्गों के लिए m रंगों के साथ, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nआर्ग्स:\n    n int: वर्गों की संख्या।\n    m int: रंगों की संख्या।\n\nरिटर्न्स:\n    int: निर्दिष्ट शर्तों को संतोषजनक बनाने वाली विभिन्न रंग भरने की विधियों की संख्या।\n\nउदाहरण:\n    CountColoringMethods(1,1) 1 लौटाता है",
      "hu": "CountColoringMethods megszámolja az n négyzet különböző színezési módszereit m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\nArgs:\n    n int: A négyzetek száma.\n    m int: A színek száma.\n\nReturns:\n    int: A megadott feltételeknek megfelelő különböző színezési módszerek száma.\n\nExamples:\n    CountColoringMethods(1,1) visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9880921086569584",
      "hy": "0.9540540120412959",
      "bn": "0.9485398340333864",
      "bg": "0.9810111342034458",
      "zh": "0.9214895542225311",
      "fr": "0.9950060349600208",
      "de": "0.9797808176233156",
      "ha": "0.966329369589252",
      "hi": "0.9656498550557316",
      "hu": "0.9655974166351384"
    }
  },
  {
    "task_id": "Go/15",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\nKthen:\n- uint64: Numri i sekuencave të vlefshme.\nShembull:\n    countValidCoinTossSequences(1)\n    // Kthen: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը առանց հաջորդական գլուխների n նետումների դեպքում։\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\nՎերադարձնում է:\n- uint64: Վավեր հաջորդականությունների քանակը։\nՕրինակ:\n    countValidCoinTossSequences(1)\n    // Վերադարձնում է: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nকোনো পরপর হেড না থাকা n টসের বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\nফেরত দেয়:\n- uint64: বৈধ সিকোয়েন্সের সংখ্যা।\nউদাহরণ:\n    countValidCoinTossSequences(1)\n    // ফেরত দেয়: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\nПараметри:\n- n (int): Броят на хвърлянията на монета.\nВръща:\n- uint64: Броят на валидните последователности.\nПример:\n    countValidCoinTossSequences(1)\n    // Връща: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n参数：\n- n (int): 投掷硬币的次数。\n返回：\n- uint64: 有效序列的数量。\n示例:\n    countValidCoinTossSequences(1)\n    // 返回: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCompter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\nParamètres :\n- n (int) : Le nombre de lancers de pièces.\nRenvoie :\n- uint64 : Le compte des séquences valides.\nExemple :\n    countValidCoinTossSequences(1)\n    // Renvoie : 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\nRückgabe:\n- uint64: Die Anzahl der gültigen Sequenzen.\nBeispiel:\n    countValidCoinTossSequences(1)\n    // Gibt zurück: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘididdige adadin jerin jefa tsabar kudi masu inganci ba tare da kanun kai a jere ba a cikin jefa n.\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\nYana dawowa:\n- uint64: Adadin jerin masu inganci.\nMisali:\n    countValidCoinTossSequences(1)\n    // Yana dawowa: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\nरिटर्न्स:\n- uint64: वैध अनुक्रमों की गिनती।\nउदाहरण:\n    countValidCoinTossSequences(1)\n    // रिटर्न करता है: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincs egymást követő fej n dobásban.\nParaméterek:\n- n (int): A pénzfeldobások száma.\nVisszatér:\n- uint64: Az érvényes sorozatok száma.\nPélda:\n    countValidCoinTossSequences(1)\n    // Visszatér: 2\n*/\nfunc CountValidCoinTossSequences(n int) uint64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9926347854712263",
      "hy": "0.9758971964133215",
      "bn": "0.9803214895204926",
      "bg": "0.9926347854712263",
      "zh": "0.9878179987311303",
      "fr": "0.9960053444070074",
      "de": "0.9926347854712263",
      "ha": "0.9846909606424981",
      "hi": "0.986580531457283",
      "hu": "0.9879179098127908"
    },
    "canonical_solution": "var a [41][2]uint64\n\ta[1][0], a[1][1] = 1, 1\n\n\tfor i := 2; i <= n; i++ {\n\t\ta[i][0] = a[i-1][1] + a[i-1][0]\n\t\ta[i][1] = a[i-1][0]\n\t}\n\n\treturn a[n][0] + a[n][1]\n}",
    "instruction": {
      "en": "Write a Go function `func CountValidCoinTossSequences(n int) uint64` to solve the following problem:\nCount the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n",
      "sq": "Shkruani një funksion në Go `func CountValidCoinTossSequences(n int) uint64` për të zgjidhur problemin e mëposhtëm: Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje. Parametrat: - n (int): Numri i hedhjeve të monedhës. Kthen: - uint64: Numri i sekuencave të vlefshme. Shembull: countValidCoinTossSequences(1) // Kthen: 2",
      "hy": "Գրեք Go ֆունկցիա `func CountValidCoinTossSequences(n int) uint64` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ժամանակ չկան հաջորդական գլխիկներ:\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը։\nՎերադարձնում է:\n- uint64: Վավեր հաջորդականությունների քանակը։\nՕրինակ:\n    countValidCoinTossSequences(1)\n    // Վերադարձնում է: 2",
      "bn": "Go ফাংশন `func CountValidCoinTossSequences(n int) uint64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বার টস করার সময় কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\nপ্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\nরিটার্ন:\n- uint64: বৈধ সিকোয়েন্সের সংখ্যা।\nউদাহরণ:\n    countValidCoinTossSequences(1)\n    // রিটার্ন: 2",
      "bg": "Напишете Go функция `func CountValidCoinTossSequences(n int) uint64`, за да решите следния проблем:  \nПребройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.  \nПараметри:  \n- n (int): Броят на хвърлянията на монета.  \nВръща:  \n- uint64: Броят на валидните последователности.  \nПример:  \n    countValidCoinTossSequences(1)  \n    // Връща: 2  ",
      "zh": "编写一个 Go 函数 `func CountValidCoinTossSequences(n int) uint64` 来解决以下问题：\n计算在 n 次投掷中没有连续正面的有效投掷序列的数量。\n参数：\n- n (int): 投掷硬币的次数。\n返回：\n- uint64: 有效序列的数量。\n示例：\n    countValidCoinTossSequences(1)\n    // 返回: 2",
      "fr": "Écrire une fonction Go `func CountValidCoinTossSequences(n int) uint64` pour résoudre le problème suivant :  \nCompter le nombre de séquences valides de lancers de pièce sans têtes consécutives dans n lancers.  \nParamètres :  \n- n (int) : Le nombre de lancers de pièce.  \nRenvoie :  \n- uint64 : Le compte des séquences valides.  \nExemple :  \n    countValidCoinTossSequences(1)  \n    // Renvoie : 2  ",
      "de": "Schreiben Sie eine Go-Funktion `func CountValidCoinTossSequences(n int) uint64`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\nRückgabe:\n- uint64: Die Anzahl der gültigen Sequenzen.\nBeispiel:\n    countValidCoinTossSequences(1)\n    // Gibt zurück: 2",
      "ha": "Rubuta aikin Go `func CountValidCoinTossSequences(n int) uint64` don warware matsalar mai zuwa:  \nƘirga adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.  \nSigogi:  \n- n (int): Yawan jefa tsabar kudi.  \nKomawa:  \n- uint64: Adadin sahihan jerin.  \nMisali:  \n    countValidCoinTossSequences(1)  \n    // Yana dawowa: 2  ",
      "hi": "Go फ़ंक्शन `func CountValidCoinTossSequences(n int) uint64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn बार सिक्का उछालने पर बिना लगातार हेड्स के मान्य सिक्का उछाल अनुक्रमों की संख्या गिनें।\nपैरामीटर्स:\n- n (int): सिक्का उछालने की संख्या।\nवापसी:\n- uint64: मान्य अनुक्रमों की गिनती।\nउदाहरण:\n    countValidCoinTossSequences(1)\n    // Returns: 2",
      "hu": "Írj egy Go függvényt `func CountValidCoinTossSequences(n int) uint64` a következő probléma megoldására:\nSzámold meg az érvényes pénzfeldobás sorozatok számát, ahol n dobás esetén nincs két egymást követő fej.\nParaméterek:\n- n (int): A pénzfeldobások száma.\nVisszatérési érték:\n- uint64: Az érvényes sorozatok száma.\nPélda:\n    countValidCoinTossSequences(1)\n    // Visszatér: 2"
    },
    "instruction_bertscore": {
      "sq": "0.9815784225716814",
      "hy": "0.982646656760887",
      "bn": "0.9749922363973266",
      "bg": "0.9917739213998211",
      "zh": "0.9829529448084428",
      "fr": "0.9958249880210277",
      "de": "0.9903340497676992",
      "ha": "0.9830266366798067",
      "hi": "0.9662965955763813",
      "hu": "0.9756818810802796"
    },
    "level": "easy",
    "test": "func TestCountValidCoinTossSequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(uint64(2), CountValidCoinTossSequences(1))\n\tassert.Equal(uint64(3), CountValidCoinTossSequences(2))\n\tassert.Equal(uint64(5), CountValidCoinTossSequences(3))\n\tassert.Equal(uint64(8), CountValidCoinTossSequences(4))  // Additional test\n\tassert.Equal(uint64(13), CountValidCoinTossSequences(5)) // Additional test\n\t// Feel free to add more tests here\n\tassert.Equal(uint64(267914296), CountValidCoinTossSequences(40)) // Additional test\n\tassert.Equal(uint64(165580141), CountValidCoinTossSequences(39))\n\tassert.Equal(uint64(102334155), CountValidCoinTossSequences(38))\n\t// Use t.Log instead of fmt.Print or fmt.Println in tests\n\tt.Log(\"All tests passed!\")\n}",
    "entry_point": "CountValidCoinTossSequences",
    "signature": "func CountValidCoinTossSequences(n int) uint64",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\nParameters:\n- n (int): The number of coin tosses.\nReturns:\n- uint64: The count of valid sequences.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\nKthen:\n- uint64: Numri i sekuencave të vlefshme.\nShembull:\n    countValidCoinTossSequences(1)\n    // Kthen: 2",
      "hy": "Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների ընթացքում չկան հաջորդական գլուխներ:\nՊարամետրեր:\n- n (int): Մետաղադրամի նետումների քանակը:\nՎերադարձնում է:\n- uint64: Վավեր հաջորդականությունների քանակը:\nՕրինակ:\n    countValidCoinTossSequences(1)\n    // Վերադարձնում է: 2",
      "bn": "nটি টসে পরপর কোনো হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\nপ্যারামিটার:\n- n (int): কয়েন টসের সংখ্যা।\nফেরত দেয়:\n- uint64: বৈধ সিকোয়েন্সের সংখ্যা।\nউদাহরণ:\n    countValidCoinTossSequences(1)\n    // ফেরত দেয়: 2",
      "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\nВръща:\n- uint64: Броят на валидните последователности.\nПример:\n    countValidCoinTossSequences(1)\n    // Връща: 2",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。  \n参数:  \n- n (int): 硬币投掷的次数。  \n返回:  \n- uint64: 有效序列的数量。  \n示例:  \n    countValidCoinTossSequences(1)  \n    // 返回: 2  ",
      "fr": "Compter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\nParamètres :\n- n (int) : Le nombre de lancers de pièces.\nRenvoie :\n- uint64 : Le compte des séquences valides.\nExemple :\n    countValidCoinTossSequences(1)\n    // Renvoie : 2",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\nRückgabewert:\n- uint64: Die Anzahl der gültigen Sequenzen.\nBeispiel:\n    countValidCoinTossSequences(1)\n    // Rückgabe: 2",
      "ha": "Ƙididdige adadin jerin jefa tsabar kudi masu inganci ba tare da kanun kai a jere ba a cikin jefa n.\nParameters:\n- n (int): Yawan jefa tsabar kudi.\nReturns:\n- uint64: Adadin sahihan jerin.\nExample:\n    countValidCoinTossSequences(1)\n    // Returns: 2",
      "hi": "मान्य सिक्का उछाल अनुक्रमों की संख्या की गणना करें जिनमें n उछालों में कोई लगातार हेड्स नहीं हैं।  \nपैरामीटर्स:  \n- n (int): सिक्का उछालों की संख्या।  \nवापसी:  \n- uint64: मान्य अनुक्रमों की संख्या।  \nउदाहरण:  \n    countValidCoinTossSequences(1)  \n    // वापसी: 2  ",
      "hu": "Számolja meg az érvényes pénzfeldobási sorozatok számát, amelyekben nincs egymást követő fej n dobás esetén.  \nParaméterek:  \n- n (int): A pénzfeldobások száma.  \nVisszatér:  \n- uint64: Az érvényes sorozatok száma.  \nPélda:  \n    countValidCoinTossSequences(1)  \n    // Visszatér: 2  "
    },
    "docstring_bertscore": {
      "sq": "0.9785445421317545",
      "hy": "0.9602274442838602",
      "bn": "0.9577624412552173",
      "bg": "0.980824421645273",
      "zh": "0.9786317408690288",
      "fr": "0.9944159040979662",
      "de": "0.9643782233563463",
      "ha": "0.9773807667292711",
      "hi": "0.9758461484053955",
      "hu": "0.9767775262620682"
    }
  },
  {
    "task_id": "Go/16",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (uint64): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\nint: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- n (uint64): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\nint: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը:\n\nՕրինակներ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজুন।\n\nপ্যারামিটার:\n- n (uint64): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\nint: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n\nউদাহরণ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nНамерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (uint64): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\nint: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n找到非负整数的二进制表示中最长连续1的序列的长度。\n\n参数：\n- n (uint64): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\nint: 给定整数的二进制表示中最长连续1的序列的长度。\n\n示例：\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (uint64) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\nint : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nFinde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (uint64): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\nint: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba maras kyau.\n\nSigogi:\n- n (uint64): Lamba maras kyau (0 ≤ n ≤ 2^64 - 1).\n\nAbin da ake dawowa:\nint: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nएक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (uint64): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\nint: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKeresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (uint64): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatér:\nint: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n*/\nfunc findLongestConsecutiveOnesLength(n uint64) int {"
    },
    "prompt_bertscore": {
      "sq": "0.974675619569957",
      "hy": "0.9864929354592465",
      "bn": "0.9971738869386356",
      "bg": "0.9805675925625948",
      "zh": "0.9941372256733743",
      "fr": "1",
      "de": "0.9909716532908213",
      "ha": "0.9683546049542837",
      "hi": "0.9885833215892578",
      "hu": "1"
    },
    "canonical_solution": "max := 0\n\tans := 0\n\tfor n > 0 {\n\t\tif n&1 == 1 {\n\t\t\tans++\n\t\t} else {\n\t\t\tif ans > max {\n\t\t\t\tmax = ans\n\t\t\t}\n\t\t\tans = 0\n\t\t}\n\t\tn >>= 1\n\t}\n\tif ans > max {\n\t\tmax = ans\n\t}\n\treturn max\n}",
    "instruction": {
      "en": "Write a Go function `func findLongestConsecutiveOnesLength(n uint64) int` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "sq": "Shkruani një funksion në Go `func findLongestConsecutiveOnesLength(n uint64) int` për të zgjidhur problemin në vijim:\nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (uint64): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\nint: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hy": "Գրեք Go ֆունկցիա `func findLongestConsecutiveOnesLength(n uint64) int` հետևյալ խնդիրը լուծելու համար:\nԳտեք ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի երկբայական ներկայացման մեջ:\n\nՊարամետրեր:\n- n (uint64): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\nint: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը:\n\nՕրինակներ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "bn": "একটি Go ফাংশন `func findLongestConsecutiveOnesLength(n uint64) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় ধারাবাহিক 1s এর দীর্ঘতম ক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (uint64): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\nint: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় ধারাবাহিক 1s এর দীর্ঘতম ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "bg": "Напишете Go функция `func findLongestConsecutiveOnesLength(n uint64) int`, за да решите следния проблем:  \nНамерете дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (uint64): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\nint: Дължината на най-дългата последователна поредица от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "zh": "编写一个 Go 函数 `func findLongestConsecutiveOnesLength(n uint64) int` 来解决以下问题：\n在一个非负整数的二进制表示中，找到最长连续1序列的长度。\n\n参数：\n- n (uint64): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\nint: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例：\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "fr": "Écrire une fonction Go `func findLongestConsecutiveOnesLength(n uint64) int` pour résoudre le problème suivant :\nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (uint64) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\nint : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "de": "Schreiben Sie eine Go-Funktion `func findLongestConsecutiveOnesLength(n uint64) int`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (uint64): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\nint: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "ha": "Rubuta aikin Go `func findLongestConsecutiveOnesLength(n uint64) int` don warware matsalar mai zuwa: Nemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (uint64): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\nint: Tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hi": "Go फ़ंक्शन `func findLongestConsecutiveOnesLength(n uint64) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (uint64): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\nint: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hu": "Írj egy Go függvényt `func findLongestConsecutiveOnesLength(n uint64) int` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (uint64): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\nint: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n    >>> findLongestConsecutiveOnesLength(7)\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9723834249728143",
      "hy": "0.9862664968248668",
      "bn": "0.9967297494066416",
      "bg": "0.9913069413740081",
      "zh": "0.9795349132115945",
      "fr": "1",
      "de": "0.9822416494139569",
      "ha": "0.9766140534584764",
      "hi": "0.9894713980228648",
      "hu": "0.994887849883305"
    },
    "level": "easy",
    "test": "func TestFindLongestConsecutiveOnesLength(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(3, findLongestConsecutiveOnesLength(7))\n\tassert.Equal(2, findLongestConsecutiveOnesLength(13))\n\tassert.Equal(3, findLongestConsecutiveOnesLength(12345))         // New test sample\n\tassert.Equal(4, findLongestConsecutiveOnesLength(0b11011101111)) // New test sample using binary literal for clarity\n\tassert.Equal(32, findLongestConsecutiveOnesLength(0xFFFFFFFF))   // New test sample: all ones for a 32-bit number\n\tassert.Equal(0, findLongestConsecutiveOnesLength(0))             // New test sample: no ones in a zero\n}",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "func findLongestConsecutiveOnesLength(n uint64) int",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (uint64): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\nint: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave të njëpasnjëshme në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (uint64): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\nint: Gjatësia e sekuencës më të gjatë të njëshave të njëpasnjëshme në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hy": "Բացահայտեք ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ։\n\nՊարամետրեր:\n- n (uint64): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1)։\n\nՎերադարձնում է:\nint: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը։\n\nՕրինակներ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজুন।\n\nপ্যারামিটারসমূহ:\n- n (uint64): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\nint: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে সবচেয়ে দীর্ঘ ক্রমাগত 1-এর ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "bg": "Намерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (uint64): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\nint: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n\nПримери:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "zh": "找到一个非负整数的二进制表示中最长连续1的序列的长度。\n\n参数：\n- n (uint64): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\nint: 给定整数的二进制表示中最长连续1的序列的长度。\n\n示例：\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres:\n- n (uint64): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie:\nint: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "de": "Finden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (uint64): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\nint: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\n    >>> findLongestConsecutiveOnesLength(7)\n    3\n",
      "ha": "Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba maras kyau.\n\nSigogi:\n- n (uint64): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\nint: Tsawon jerin tsararrun 1s mafi tsawo a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (uint64): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\nint: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n    >>> findLongestConsecutiveOnesLength(7)\n    3",
      "hu": "A nemnegatív egész szám bináris ábrázolásában találja meg a leghosszabb egymást követő 1-esek sorozatának hosszát.\n\nParaméterek:\n- n (uint64): Egy nemnegatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatér:\nint: A megadott egész szám bináris ábrázolásában a leghosszabb egymást követő 1-esek sorozatának hossza.\n\nPéldák:\n    >>> findLongestConsecutiveOnesLength(7)\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9624888511719424",
      "hy": "0.9896885010293358",
      "bn": "1",
      "bg": "0.9758737580283594",
      "zh": "0.9934007042204969",
      "fr": "1",
      "de": "0.9809374423320818",
      "ha": "0.9798566944288709",
      "hi": "0.9884041569855643",
      "hu": "1"
    }
  },
  {
    "task_id": "Go/17",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (string): Fjala e parë që do të përdoret në ID.\n- word2 (string): Fjala e dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të fjalës së\n        dytë dhe duke e kombinuar me fjalën e parë.\np.sh.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով։\nՊարամետրեր:\n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում։\n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում։\nՎերադարձնում է:\nstring: Աստվածային ID, որը ձևավորվում է երկրորդ բառի ամեն երկրորդ\n        նիշը շրջելով և այն առաջին բառի հետ համադրելով։\nօր.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটার:\n- word1 (string): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (string): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন:\nstring: দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে\n        একত্রিত করে একটি divine আইডি তৈরি করে।\nযেমন:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще се използва в ID.\n- word2 (string): Втората дума, която ще се използва в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ от втората\n        дума и комбинирането му с първата дума.\nнапр.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n通过以特定方式组合两个单词来创建一个ID。\n参数：\n- word1 (string): 用于ID的第一个单词。\n- word2 (string): 用于ID的第二个单词。\n返回：\nstring: 一个神圣的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (string) : Le premier mot à utiliser dans l'ID.\n- word2 (string) : Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nstring : Un ID divin formé en inversant chaque autre caractère du deuxième\n         mot et en le combinant avec le premier mot.\nex. :\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nErzeugt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (string): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabe:\nstring: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des\n        zweiten Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\nSigogi:\n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nYana dawowa:\nstring: Wani ID mai ban mamaki da aka kafa ta hanyar juyar da kowanne harafi na biyu na kalma ta biyu\n        kuma a haɗa shi da kalma ta farko.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदो शब्दों को एक विशेष तरीके से संयोजित करके एक आईडी बनाता है।\nपैरामीटर्स:\n- word1 (string): आईडी में उपयोग के लिए पहला शब्द।\n- word2 (string): आईडी में उपयोग के लिए दूसरा शब्द।\nवापसी करता है:\nstring: एक दिव्य आईडी जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और पहले शब्द के साथ संयोजित करके बनाई जाती है।\nउदा.:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első szó, amelyet az azonosítóban használunk.\n- word2 (string): A második szó, amelyet az azonosítóban használunk.\nVisszatér:\nstring: Egy isteni azonosító, amelyet a második szó minden második karakterének\n        megfordításával és az első szóval való kombinálásával hozunk létre.\npélda:\n    >>> CreateID(\"fish\",\"cat\")\n\t\"ftiasch\"\n*/\nfunc CreateID(word1, word2 string) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9943974314725299",
      "hy": "0.8802509076639728",
      "bn": "0.9513284059527352",
      "bg": "0.9943974314725299",
      "zh": "0.9577509206931172",
      "fr": "0.9781071580327156",
      "de": "0.9851227830908679",
      "ha": "0.973030562754226",
      "hi": "0.9679007345336189",
      "hu": "0.9461330297063866"
    },
    "canonical_solution": "length1 := len(word1)\n\tlength2 := len(word2)\n\ttotalLength := length1 + length2\n\tid := make([]rune, totalLength)\n\n\tfor i, j, k := 0, 0, length2-1; i < totalLength; i++ {\n\t\tif i&1 == 1 {\n\t\t\tid[i] = rune(word2[k]) // Take character from word2 in reverse\n\t\t\tk--\n\t\t} else {\n\t\t\tid[i] = rune(word1[j]) // Take character from word1\n\t\t\tj++\n\t\t}\n\t}\n\n\treturn string(id)\n}",
    "instruction": {
      "en": "Write a Go function `func CreateID(word1, word2 string) string` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"\n",
      "sq": "Shkruani një funksion Go `func CreateID(word1, word2 string) string` për të zgjidhur problemin e mëposhtëm:\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (string): Fjala e parë që do të përdoret në ID.\n- word2 (string): Fjala e dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter të dytë të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hy": "Գրեք Go ֆունկցիա `func CreateID(word1, word2 string) string` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համատեղելով:\nՊարամետրեր:\n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում:\n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում:\nՎերադարձնում է:\nstring: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ սիմվոլը շրջելով և այն առաջին բառի հետ համատեղելով:\nօր.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "bn": "একটি Go ফাংশন `func CreateID(word1, word2 string) string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে সংযুক্ত করে একটি ID তৈরি করে।\nপ্যারামিটার:\n- word1 (string): ID তৈরিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (string): ID তৈরিতে ব্যবহৃত দ্বিতীয় শব্দ।\nফেরত দেয়:\nstring: একটি অনন্য ID যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টে এবং প্রথম শব্দের সাথে সংযুক্ত করে গঠিত।\nউদাহরণ:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "bg": "Напишете Go функция `func CreateID(word1, word2 string) string`, за да решите следния проблем:\nСъздава ID чрез комбиниране на две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще се използва в ID.\n- word2 (string): Втората дума, която ще се използва в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ на втората\n        дума и комбинирането му с първата дума.\nнапр.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "zh": "编写一个 Go 函数 `func CreateID(word1, word2 string) string` 来解决以下问题：\n通过以特定方式组合两个单词来创建一个 ID。\n参数：\n- word1 (string): 用于 ID 的第一个单词。\n- word2 (string): 用于 ID 的第二个单词。\n返回：\nstring: 一个神奇的 ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "fr": "Écrire une fonction Go `func CreateID(word1, word2 string) string` pour résoudre le problème suivant :\nCrée un ID en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (string) : Le premier mot à utiliser dans l'ID.\n- word2 (string) : Le deuxième mot à utiliser dans l'ID.\nRenvoie :\nstring : Un ID divin formé en inversant chaque autre caractère du deuxième\n        mot et en le combinant avec le premier mot.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "de": "Schreiben Sie eine Go-Funktion `func CreateID(word1, word2 string) string`, um das folgende Problem zu lösen:\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Das erste Wort, das in der ID verwendet wird.\n- word2 (string): Das zweite Wort, das in der ID verwendet wird.\nRückgabe:\nstring: Eine göttliche ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten\n        Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "ha": "Rubuta aikin Go `func CreateID(word1, word2 string) string` don warware matsalar mai zuwa:\nƘirƙirar ID ta hanyar haɗa kalmomi biyu ta wata hanya ta musamman.\nSigogi:\n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nDawowa:\nstring: Wani ID mai ban mamaki da aka ƙirƙira ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu da haɗa ta da kalma ta farko.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hi": "Go फ़ंक्शन `func CreateID(word1, word2 string) string` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदो शब्दों को एक विशेष तरीके से मिलाकर एक ID बनाता है।\nपैरामीटर्स:\n- word1 (string): ID में उपयोग के लिए पहला शब्द।\n- word2 (string): ID में उपयोग के लिए दूसरा शब्द।\nवापसी:\nstring: एक दिव्य ID जो दूसरे शब्द के हर दूसरे अक्षर को उलटकर और पहले शब्द के साथ मिलाकर बनाई जाती है।\nउदा.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hu": "Írj egy Go függvényt `func CreateID(word1, word2 string) string` a következő probléma megoldására:\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első szó, amelyet az azonosítóban használunk.\n- word2 (string): A második szó, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amely a második szó minden második karakterének megfordításával és az első szóval való kombinálásával jön létre.\npélda:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\""
    },
    "instruction_bertscore": {
      "sq": "0.993088258631129",
      "hy": "0.9790019878992778",
      "bn": "0.9519906396431055",
      "bg": "0.993088258631129",
      "zh": "0.953371319421679",
      "fr": "0.9851817763140353",
      "de": "0.9695146063795275",
      "ha": "0.9679607209086915",
      "hi": "0.9449011240832083",
      "hu": "0.9374238820195309"
    },
    "level": "middle",
    "test": "func TestCreateID(t *testing.T) {\n\tassert.Equal(t, \"ftiasch\", CreateID(\"fish\", \"cat\"))\n\tassert.Equal(t, \"imccpac\", CreateID(\"icpc\", \"acm\"))\n\tassert.Equal(t, \"owo\", CreateID(\"oo\", \"w\"))\n\tassert.Equal(t, \"hdellrloow\", CreateID(\"hello\", \"world\"))\n\tassert.Equal(t, \"afbecd\", CreateID(\"abc\", \"def\"))\n\tassert.Equal(t, \"bauaauabnbbn\", CreateID(\"buaanb\", \"nbbuaa\"))\n\tassert.Equal(t, \"xuttuxiesvgooloid\", CreateID(\"xtuisgood\", \"ilovextu\"))\n}",
    "entry_point": "CreateID",
    "signature": "func CreateID(word1, word2 string) string",
    "docstring": {
      "en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\nstring: A divine ID formed by reversing every other character of the second\n        word and combining it with the first word.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"\n",
      "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (string): Fjala e parë që do të përdoret në ID.\n- word2 (string): Fjala e dytë që do të përdoret në ID.\nKthen:\nstring: Një ID hyjnore e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով։  \nՊարամետրեր:  \n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է:  \nstring: Աստվածային ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ սիմվոլը շրջելով և այն առաջին բառի հետ համադրելով։  \nօրինակ:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "bn": "একটি নির্দিষ্ট পদ্ধতিতে দুটি শব্দ একত্রিত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (string): ID তৈরির জন্য ব্যবহৃত প্রথম শব্দ।\n- word2 (string): ID তৈরির জন্য ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন:\nstring: একটি অনন্য ID যা দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে প্রথম শব্দের সাথে মিলিয়ে গঠিত হয়।\nউদাহরণ:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще се използва в ID.\n- word2 (string): Втората дума, която ще се използва в ID.\nВръща:\nstring: Божествено ID, образувано чрез обръщане на всеки втори символ от втората\n        дума и комбинирането му с първата дума.\nнапр.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "zh": "创建一个ID，通过特定方式组合两个单词。\n参数:\n- word1 (string): 用于ID的第一个单词。  \n- word2 (string): 用于ID的第二个单词。  \n返回:  \nstring: 一个神奇的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。  \n例如:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "fr": "Crée un ID en combinant deux mots d'une manière spécifique.  \nParamètres :  \n- word1 (string) : Le premier mot à utiliser dans l'ID.  \n- word2 (string) : Le deuxième mot à utiliser dans l'ID.  \nRenvoie :  \nstring : Un ID divin formé en inversant chaque autre caractère du deuxième  \n         mot et en le combinant avec le premier mot.  \ne.g. :  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (string): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\nstring: Eine göttliche ID, die gebildet wird, indem jedes zweite Zeichen des zweiten\n        Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "ha": "Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a cikin wata hanya ta musamman.\nParameters:\n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nReturns:\nstring: Wani ID mai ban mamaki da aka samar ta hanyar juyar da kowace harafi na biyu na kalma ta biyu\n        kuma a haɗa shi da kalma ta farko.\ne.g.:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\"",
      "hi": "दो शब्दों को एक विशेष तरीके से संयोजित करके एक आईडी बनाता है।\nमापदंड:  \n- word1 (string): ID में उपयोग के लिए पहला शब्द।  \n- word2 (string): ID में उपयोग के लिए दूसरा शब्द।  \nवापसी:  \nstring: एक दिव्य ID जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और पहले शब्द के साथ जोड़कर बनाई जाती है।  \nउदाहरण:  \n    >>> CreateID(\"fish\",\"cat\")  \n    \"ftiasch\"  ",
      "hu": "Létrehoz egy azonosítót két szó meghatározott módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első szó, amelyet az azonosítóban használunk.\n- word2 (string): A második szó, amelyet az azonosítóban használunk.\nVisszatérési érték:\nstring: Egy isteni azonosító, amelyet a második szó minden második karakterének megfordításával és az első szóval való kombinálásával hozunk létre.\npélda:\n    >>> CreateID(\"fish\",\"cat\")\n    \"ftiasch\""
    },
    "docstring_bertscore": {
      "sq": "0.9981487648487548",
      "hy": "0.9711145740987635",
      "bn": "0.916900397899101",
      "bg": "0.992450655108007",
      "zh": "0.9370047719155473",
      "fr": "0.9804223937540583",
      "de": "0.9860164211751439",
      "ha": "0.9617241242049581",
      "hi": "0.9544921906618589",
      "hu": "0.9313873061094996"
    }
  },
  {
    "task_id": "Go/18",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\nint: Numri total i skemave të ndryshme të permutimit.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել տարբեր տեղաշարժման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n\nՎերադարձնում է:\nint: Տարբեր տեղաշարժման սխեմաների ընդհանուր քանակը։\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\nint: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБрой на различните схеми на пермутации за двоична верига с дължина n,\nкъдето броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната верига.\n- m (int): Брой на '1'-ците в двоичната верига.\n\nВръща:\nint: Общият брой на различните схеми на пермутации.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算长度为 n 的二进制字符串的不同排列方案数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回:\nint: 不同排列方案的总数量。\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nint : Le nombre total de différents schémas de permutation.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\nint: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawo:\nint: Jimlar adadin tsarin juyawa daban-daban.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nएक बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें,\nजहां '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\nahol az '1'-ek száma m, és a '0'-ok száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\nint: A különböző permutációs sémák teljes száma.\n*/\nfunc countPermutationsOfBinaryString(n, m int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9951681173509453",
      "hy": "0.9869412442292423",
      "bn": "0.9951681173509453",
      "bg": "0.9861058048466096",
      "zh": "0.9681839814569747",
      "fr": "0.9880416565401756",
      "de": "0.991061434223049",
      "ha": "0.9814278607428569",
      "hi": "0.9951681173509453",
      "hu": "0.9865910588674778"
    },
    "canonical_solution": "factorial := 1.0\n\tvar i int\n\n\t// Calculate n factorial (n!)\n\tfor i = 2; i <= n; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tnumerator := factorial // n!\n\n\t// Calculate (n+m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n+m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator1 := factorial // ((n+m)/2)!\n\n\t// Calculate (n-m)/2 factorial\n\tfactorial = 1.0\n\tfor i = 2; i <= (n-m)/2; i++ {\n\t\tfactorial *= float64(i)\n\t}\n\n\tdenominator2 := factorial // ((n-m)/2)!\n\n\t// Special cases and computation\n\tif (n+m)&1 != 0 {\n\t\treturn 0\n\t} else if n == m {\n\t\treturn 1\n\t} else {\n\t\t// Calculating the number of permutations using the factorial values\n\t\treturn int(numerator/denominator1/denominator2 + 0.5)\n\t}\n}",
    "instruction": {
      "en": "Write a Go function `func countPermutationsOfBinaryString(n, m int) int` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n",
      "sq": "Shkruani një funksion Go `func countPermutationsOfBinaryString(n, m int) int` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\nint: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Գրեք Go ֆունկցիա `func countPermutationsOfBinaryString(n, m int) int` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տարբեր փոխարկման սխեմաների քանակը երկբայնային տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է:\n\nՊարամետրեր:\n- n (int): Երկբայնային տողի երկարությունը:\n- m (int): '1'-երի քանակը երկբայնային տողի մեջ:\n\nՎերադարձնում է:\nint: Տարբեր փոխարկման սխեմաների ընդհանուր քանակը:",
      "bn": "একটি Go ফাংশন `func countPermutationsOfBinaryString(n, m int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদৈর্ঘ্য n এর একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\nint: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Напишете Go функция `func countPermutationsOfBinaryString(n, m int) int`, за да решите следния проблем:\nПребройте броя на различните схеми на пермутации за двоичен низ с дължина n,\nкъдето броят на '1'-ците е m и броят на '0'-ите е n - m.\n\nПараметри:\n- n (int): Дължина на двоичния низ.\n- m (int): Брой на '1'-ците в двоичния низ.\n\nВръща:\nint: Общият брой на различните схеми на пермутации.",
      "zh": "编写一个 Go 函数 `func countPermutationsOfBinaryString(n, m int) int` 来解决以下问题：\n计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\nint: 不同排列方案的总数量。",
      "fr": "Écrire une fonction Go `func countPermutationsOfBinaryString(n, m int) int` pour résoudre le problème suivant :\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nint : Le nombre total de différents schémas de permutation.",
      "de": "Schreiben Sie eine Go-Funktion `func countPermutationsOfBinaryString(n, m int) int`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nbei dem die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\nint: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Rubuta aikin Go `func countPermutationsOfBinaryString(n, m int) int` don warware matsalar mai zuwa:\nƘirga adadin tsarin permutation daban-daban don wani binary string mai tsawon n,\ninda adadin '1's shi ne m kuma adadin '0's shi ne n - m.\n\nSigogi:\n- n (int): Tsawon binary string.\n- m (int): Adadin '1's a cikin binary string.\n\nDawowa:\nint: Jimlar adadin tsarin permutation daban-daban.",
      "hi": "Go फ़ंक्शन `func countPermutationsOfBinaryString(n, m int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n की एक बाइनरी स्ट्रिंग के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें,\nजहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Írj egy Go függvényt `func countPermutationsOfBinaryString(n, m int) int` a következő probléma megoldására:\nSzámold meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\nahol az '1'-ek száma m és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatérési érték:\nint: A különböző permutációs sémák összes száma."
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9940782324502069",
      "bn": "0.9974793804646672",
      "bg": "0.98818645808795",
      "zh": "0.964507928995162",
      "fr": "0.98818645808795",
      "de": "0.9837329663147668",
      "ha": "0.9750772502004095",
      "hi": "0.9885499516852438",
      "hu": "0.9890983701672812"
    },
    "level": "hard",
    "test": "func TestCountPermutationsOfBinaryString(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, countPermutationsOfBinaryString(2, 0))\n\tassert.Equal(0, countPermutationsOfBinaryString(2, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 0))\n\tassert.Equal(3, countPermutationsOfBinaryString(3, 1))\n\tassert.Equal(0, countPermutationsOfBinaryString(3, 2))\n\tassert.Equal(145422675, countPermutationsOfBinaryString(30, 2))\n\tassert.Equal(4, countPermutationsOfBinaryString(4, 2))\n\tassert.Equal(1, countPermutationsOfBinaryString(5, 5))\n\tassert.Equal(13884156, countPermutationsOfBinaryString(33, 17))\n\tassert.Equal(1, countPermutationsOfBinaryString(1000000, 1000000))\n\t// Add more test cases if necessary\n}",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "func countPermutationsOfBinaryString(n, m int) int",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\nint: The total number of different permutation schemes.\n",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\nint: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր փոխակերպման սխեմաների քանակը երկբանական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է:\n\nՊարամետրեր:\n- n (int): Երկբանական տողի երկարությունը:\n- m (int): '1'-երի քանակը երկբանական տողում:\n\nՎերադարձնում է:\nint: Տարբեր փոխակերպման սխեմաների ընդհանուր քանակը:",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\nint: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоична верига с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната верига.\n- m (int): Брой на '1'-ците в двоичната верига.\n\nВръща:\nint: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回：\nint: 不同排列方案的总数量。",
      "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nint : Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabe:\nint: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙirga adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n,\ninda adadin '1's shine m kuma adadin '0's shine n - m.\n\nMa'auni:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawo:\nint: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहां '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\nint: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\nint: A különböző permutációs sémák teljes száma."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9539364228557232",
      "bn": "0.9646994086824797",
      "bg": "1",
      "zh": "0.9608616710905046",
      "fr": "0.9850904063387592",
      "de": "1",
      "ha": "0.9963775777410667",
      "hi": "0.9963775777410667",
      "hu": "0.983329945271647"
    }
  },
  {
    "task_id": "Go/19",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n*/\nfunc answerQuestions() string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPërgjigju një serie pyetjesh duke ofruar zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresës së tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\nDuhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.\n*/\nfunc answerQuestions() string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՊատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nԵթե 21! = 51,090,942,171,709,440,000, ապա որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերոնշյալներից ոչ մեկը\nՀարց 3:\nՈր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահավաքման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈր հայտարարությունը ֆունկցիաների մասին սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են կույտում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձի արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\nՀարց 5:\nՈր հայտարարությունը ցուցիչների մասին սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահավաքումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցի ընտրանքները:\n*/\nfunc answerQuestions() string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nপ্রতিটি প্রশ্নের জন্য পছন্দগুলি A, B, C, বা D প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\nপ্রশ্ন ১:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন ২:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশন টাইপটি রিটার্ন ভ্যালু টাইপের সমান।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়ার কথা, যা প্রশ্নের পছন্দগুলির প্রতিনিধিত্ব করে।\n*/\nfunc answerQuestions() string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за дереференция на указател са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи имат разпределено пространство в стека.\n    C. Типът на функцията е същият като типа на върнатата стойност.\n    D. Функцията може да извика сама себе си от своето тяло.\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Дереференцията на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\nТрябва да върнете само низове, подобни на \"AAAAA\", които означават изборите на въпросите.\n*/\nfunc answerQuestions() string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n通过为每个问题提供选择A、B、C或D来回答一系列问题。\n问题1：\n像1e6这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n问题2：\n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n问题3：\n关于表达式中的左值，哪个说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n问题4：\n关于函数，哪个说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其体内调用自身。\n问题5：\n关于指针，哪个说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4]，p是一个int指针数组。\n    D. 函数名可以赋值给函数指针。\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。\n*/\nfunc answerQuestions() string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nRépondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonction peuvent être assignés à des pointeurs de fonction.\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n*/\nfunc answerQuestions() string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBeantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Der Inkrement-Operator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operator-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\nDu sollst nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n*/\nfunc answerQuestions() string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\nTambaya ta 1:\nConstant kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanin sunan canji ƙimar hagu ne.\n    B. Aiki mai ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Bayanin cirewa mai nuna alama ƙimar hagu ne.\n    D. Bayanin aiki mai ƙaruwa na farko ƙimar hagu ne.\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin aiki na aiki canje-canje ne na gida.\n    B. Canje-canje na gida suna samun sarari a cikin tsari.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Ayyuka na iya kiran kansu daga cikin jikinsu.\nTambaya ta 5:\nWane bayani game da masu nuna alama ba daidai ba ne?\n    A. Rage masu nuna alama biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p tsari ne na masu nuna alama na int.\n    D. Ana iya sanya sunayen ayyuka ga masu nuna alama na aiki.\nAna tsammanin ka mayar da igiyoyi makamancin \"AAAAA\", wanda ke nufin zaɓuɓɓukan tambayar.\n*/\nfunc answerQuestions() string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nप्रश्न 2:\nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\nप्रश्न 4:\nफंक्शनों के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से खुद को कॉल कर सकता है।\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर आता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने की आवश्यकता है, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n*/\nfunc answerQuestions() string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVálaszolj egy sor kérdésre azáltal, hogy választ adsz A, B, C vagy D lehetőségek közül minden kérdésre.\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n2. kérdés:\nAdott, hogy 21! = 51,090,942,171,709,440,000, melyik adattípussal tárolható ez az érték?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementálás művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferencia kifejezések balértékek.\n    D. A prefix inkrementálás művelet kifejezések balértékek.\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása az címértékeik különbségével egyenlő.\n    B. A pointer dereferencia a pointer típusának megfelelően történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvény pointerekhez.\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik.\n*/\nfunc answerQuestions() string {"
    },
    "prompt_bertscore": {
      "sq": "0.958780421958021",
      "hy": "0.9475238396343929",
      "bn": "0.9518090914748396",
      "bg": "0.9458191937043515",
      "zh": "0.9444009727837623",
      "fr": "0.9679221866147707",
      "de": "0.9477729221322106",
      "ha": "0.9269681773922355",
      "hi": "0.8948657338397579",
      "hu": "0.9367904497344106"
    },
    "canonical_solution": "return \"DDDBA\"\n}",
    "instruction": {
      "en": "Write a Go function `func answerQuestions() string` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Shkruani një funksion Go `func answerQuestions() string` për të zgjidhur problemin e mëposhtëm: \nPërgjigjuni një serie pyetjesh duke ofruar zgjedhje A, B, C, ose D për secilën pyetje. \nPyetja 1: \nKonstantet si 1e6 i përkasin cilit lloj të dhënash? \n    A. unsigned int \n    B. int \n    C. float \n    D. double \nPyetja 2: \nDuke dhënë 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë? \n    A. int \n    B. long long \n    C. double \n    D. Asnjë nga të mësipërmet \nPyetja 3: \nCila deklaratë rreth vlerave të majta në shprehje është e pasaktë? \n    A. Shprehjet e emrave të variablave janë vlera të majta. \n    B. Operacioni i inkrementit kërkon që operandi të jetë një vlerë e majtë. \n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta. \n    D. Shprehjet e operacionit të inkrementit prefiks janë vlera të majta. \nPyetja 4: \nCila deklaratë rreth funksioneve është e pasaktë? \n    A. Parametrat formalë të një funksioni janë variabla lokale. \n    B. Variablat lokale alokohen hapësirë në stack. \n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit. \n    D. Një funksion mund të thërrasë veten nga brenda trupit të tij. \nPyetja 5: \nCila deklaratë rreth treguesve është e pasaktë? \n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre. \n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit. \n    C. int *p[4], p është një varg treguesish int. \n    D. Emrat e funksioneve mund të caktohen në tregues të funksioneve. \nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Գրեք Go ֆունկցիա `func answerQuestions() string`՝ հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք հարցերի շարքին՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր հայտարարությունը արտահայտություններում ձախ արժեքների մասին սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահավաքման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները հատկացվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահավաքումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\nԴուք պետք է վերադարձնեք միայն \"AAAAA\" նման տողեր, որոնք ներկայացնում են հարցերի ընտրանքները:",
      "bn": "একটি Go ফাংশন `func answerQuestions() string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলোর উত্তর দিন।\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন 2:\n21! = 51,090,942,171,709,440,000 প্রদত্ত, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\nপ্রশ্ন 3:\nএক্সপ্রেশনগুলিতে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ড একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ পায়।\n    C. ফাংশন টাইপটি রিটার্ন ভ্যালু টাইপের সমান।\n    D. একটি ফাংশন তার দেহের ভিতরে নিজেকে কল করতে পারে।\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\nআপনার কেবল \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়া উচিত, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।",
      "bg": "Напишете Go функция `func answerQuestions() string`, за да решите следния проблем:\nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Никой от горните\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкремент изисква операндът да бъде лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите с префикс инкремент операция са леви стойности.\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи се разпределят в стека.\n    C. Типът на функцията е същият като типа на върнатата стойност.\n    D. Функцията може да извика сама себе си от тялото си.\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.",
      "zh": "编写一个 Go 函数 `func answerQuestions() string` 来解决以下问题：  \n通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n\n问题 1：  \n像 1e6 这样的常量属于哪种数据类型？  \nA. unsigned int  \nB. int  \nC. float  \nD. double  \n\n问题 2：  \n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？  \nA. int  \nB. long long  \nC. double  \nD. 以上都不是  \n\n问题 3：  \n关于表达式中的左值，哪个说法不正确？  \nA. 变量名表达式是左值。  \nB. 自增操作要求操作数是左值。  \nC. 指针解引用表达式是左值。  \nD. 前缀自增操作表达式是左值。  \n\n问题 4：  \n关于函数的哪个说法不正确？  \nA. 函数的形式参数是局部变量。  \nB. 局部变量在栈中分配空间。  \nC. 函数类型与返回值类型相同。  \nD. 函数可以在其主体内调用自身。  \n\n问题 5：  \n关于指针的哪个说法不正确？  \nA. 两个指针相减等于它们地址值的差。  \nB. 指针解引用涉及根据指针的类型进行解析。  \nC. int *p[4]，p 是一个 int 指针数组。  \nD. 函数名可以赋值给函数指针。  \n\n你应该只返回类似于 \"AAAAA\" 的字符串，这些字符串代表问题的选择。",
      "fr": "Écrire une fonction Go `func answerQuestions() string` pour résoudre le problème suivant :\nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de noms de variables sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrément préfixé sont des valeurs à gauche.\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Schreiben Sie eine Go-Funktion `func answerQuestions() string`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nAngenommen, 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrementierungsoperator-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\nSie sollen nur Zeichenfolgen ähnlich zu \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Fragen stehen.",
      "ha": "Rubuta aikin Go `func answerQuestions() string` don warware matsalar mai zuwa: \n\nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya. \nTambaya ta 1: \nDindindin kamar 1e6 suna cikin wane nau'in bayanai? \n    A. unsigned int \n    B. int \n    C. float \n    D. double \nTambaya ta 2: \nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima? \n    A. int \n    B. long long \n    C. double \n    D. Babu ɗaya daga cikin abubuwan da ke sama \nTambaya ta 3: \nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne? \n    A. Maganganun sunan canji ƙimar hagu ne. \n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu. \n    C. Maganganun cirewa mai nuna alama ƙimar hagu ne. \n    D. Maganganun aikin ƙaruwa na farko ƙimar hagu ne. \nTambaya ta 4: \nWane bayani game da ayyuka ba daidai ba ne? \n    A. Sigogin tsari na aiki canje-canje na gida ne. \n    B. Ana ware sarari ga canje-canje na gida a cikin tsari. \n    C. Nau'in aiki daidai yake da nau'in ƙimar dawowa. \n    D. Aiki na iya kiran kansa daga cikin jikinsa. \nTambaya ta 5: \nWane bayani game da masu nuna alama ba daidai ba ne? \n    A. Rage masu nuna alama biyu daidai yake da bambancin a cikin ƙimar adireshinsu. \n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama. \n    C. int *p[4], p tsari ne na masu nuna alama na int. \n    D. Ana iya ba da sunayen ayyuka ga masu nuna alama na aiki. \nAna tsammanin ku dawo da kirtani mai kama da \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.",
      "hi": "गो फ़ंक्शन `func answerQuestions() string` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nप्रश्न 2:\nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\nप्रश्न 4:\nफंक्शन्स के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n    B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही होता है जो रिटर्न मान प्रकार होता है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों का अंतर मिलता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स का ऐरे है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों का प्रतिनिधित्व करते हैं।",
      "hu": "Írj egy Go függvényt `func answerQuestions() string` a következő probléma megoldására:\nVálaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdéshez.\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n2. kérdés:\nAdott, hogy 21! = 51,090,942,171,709,440,000, mely adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálás kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény hívhatja önmagát a saját törzsén belül.\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálása a pointer típusán alapuló feloldást igényel.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvény pointerekhez.\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "instruction_bertscore": {
      "sq": "0.9568880703179017",
      "hy": "0.9406303722605771",
      "bn": "0.941517455542279",
      "bg": "0.9254184631594012",
      "zh": "0.9503499526957573",
      "fr": "0.9595828886974019",
      "de": "0.9470566609781988",
      "ha": "0.9222783154656207",
      "hi": "0.9401568374321899",
      "hu": "0.9377891632902541"
    },
    "level": "easy",
    "test": "func TestAnswerQuestions(t *testing.T) {\n\texpectedAnswers := \"DDDBA\"\n\tactualAnswers := answerQuestions()\n\n\tassert.Equal(t, expectedAnswers, actualAnswers, \"they should be equal\")\n}",
    "entry_point": "answerQuestions",
    "signature": "func answerQuestions() string",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit lloj të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke dhënë 21! = 51,090,942,171,709,440,000, cili lloj të dhënash mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementit kërkon që operand të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementit prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të alokuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten brenda trupit të tij.\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՏրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահանել արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են նշանակվել ֆունկցիայի ցուցիչներին:\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:",
      "bn": "একটি সিরিজ প্রশ্নের উত্তর দিন প্রতিটি প্রশ্নের জন্য বিকল্প A, B, C, বা D প্রদান করে।  \nপ্রশ্ন ১:  \nযেমন 1e6 ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nপ্রশ্ন ২:  \nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?  \n    A. int  \n    B. long long  \n    C. double  \n    D. উপরোক্ত কোনোটিই নয়  \nপ্রশ্ন ৩:  \nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?  \n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।  \n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।  \n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।  \n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।  \nপ্রশ্ন ৪:  \nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?  \n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।  \n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।  \n    C. ফাংশন টাইপটি রিটার্ন ভ্যালু টাইপের সমান।  \n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।  \nপ্রশ্ন ৫:  \nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?  \n    A. দুটি পয়েন্টার বিয়োগ করা তাদের ঠিকানা মানের পার্থক্যের সমান।  \n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান জড়িত।  \n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।  \n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।  \nআপনার শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।",
      "bg": "Отговорете на поредица от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията на инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за разименование на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи заемат място в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от тялото си.\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименоването на указател включва разрешаване въз основа на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.",
      "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1：常量如1e6属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题2：给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题3：关于表达式中的左值，哪种说法不正确？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题4：关于函数，哪种说法不正确？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题5：关于指针，哪种说法不正确？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4]，p是一个int指针的数组。\n    D. 函数名可以赋值给函数指针。\n\n你应该只返回类似于“AAAAA”的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.  \nQuestion 1 :  \nLes constantes comme 1e6 appartiennent à quel type de données ?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nQuestion 2 :  \nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Aucun des précédents  \nQuestion 3 :  \nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?  \n    A. Les expressions de nom de variable sont des valeurs à gauche.  \n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.  \n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.  \n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.  \nQuestion 4 :  \nQuelle affirmation concernant les fonctions est incorrecte ?  \n    A. Les paramètres formels d'une fonction sont des variables locales.  \n    B. Les variables locales sont allouées dans la pile.  \n    C. Le type de la fonction est le même que le type de la valeur de retour.  \n    D. Une fonction peut s'appeler elle-même depuis son corps.  \nQuestion 5 :  \nQuelle affirmation concernant les pointeurs est incorrecte ?  \n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.  \n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.  \n    C. int *p[4], p est un tableau de pointeurs int.  \n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.  \nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworte eine Reihe von Fragen, indem du für jede Frage die Auswahlmöglichkeiten A, B, C oder D angibst.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nAngenommen 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamen-Ausdrücke sind linke Werte.\n    B. Für die Inkrement-Operation muss der Operand ein linker Wert sein.\n    C. Zeiger-Dereferenzierungs-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicher zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern ergibt die Differenz ihrer Adresswerte.\n    B. Die Dereferenzierung eines Zeigers erfolgt basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\nEs wird erwartet, dass du nur Zeichenfolgen wie \"AAAAA\" zurückgibst, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\nTambaya ta 1:\nKwatankwacin 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙimar?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\nTambaya ta 3:\nWane bayanin game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanin sunan m canji ƙimar hagu ne.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Bayanin cirewa mai nuna alama ƙimar hagu ne.\n    D. Bayanin aikin ƙaruwa na farko ƙimar hagu ne.\nTambaya ta 4:\nWane bayanin game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki canje-canje na gida ne.\n    B. Canje-canje na gida ana ware musu sarari a cikin tsari.\n    C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\nTambaya ta 5:\nWane bayanin game da masu nuna alama ba daidai ba ne?\n    A. Rage masu nuna alama biyu yana daidai da bambanci a cikin ƙimar adireshin su.\n    B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n    C. int *p[4], p jerin masu nuna alama int ne.\n    D. Ana iya sanya sunayen aiki ga masu nuna alama na aiki.\nAna tsammanin ka dawo da kirtani makamancin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n\nप्रश्न 1: \n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2: \nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3: \nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेटर का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n\nप्रश्न 4: \nकार्यात्मकताओं के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार रिटर्न मान प्रकार के समान होता है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से खुद को कॉल कर सकता है।\n\nप्रश्न 5: \nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p int पॉइंटर्स का एक सरणी है।\n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को असाइन किया जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszoljon egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nKérdés 2:\nAdott 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem a fentiek közül\nKérdés 3:\nMelyik állítás helytelen a balértékekről a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementálás művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferencia kifejezések balértékek.\n    D. A prefix inkrementálás művelet kifejezések balértékek.\nKérdés 4:\nMelyik állítás helytelen a függvényekről?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\nKérdés 5:\nMelyik állítás helytelen a pointerekről?\n    A. Két pointer kivonása egyenlő a címértékek különbségével.\n    B. A pointer dereferencia a pointer típusának alapján történő feloldást jelenti.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\nCsak olyan karakterláncokat kell visszaadnia, mint például \"AAAAA\", amelyek a kérdés választási lehetőségeit jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9559854938664791",
      "hy": "0.9268476087509473",
      "bn": "0.9539318543569594",
      "bg": "0.9387870823245733",
      "zh": "0.9496402463443196",
      "fr": "0.954248272553948",
      "de": "0.9284525422297092",
      "ha": "0.904847705008285",
      "hi": "0.9406917490483169",
      "hu": "0.9403884404564766"
    }
  },
  {
    "task_id": "Go/20",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square përcakton nëse është e mundur të montohet katrorët prej druri nga n kovë,\nku secila kovë përmban një numër specifik katrorësh me një gjatësi anësore prej 1, në një katror më të madh.\nFunksioni merr gjatësinë e listës dhe një varg numrash si hyrje.\n\nShembuj përdorimi:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square որոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\nորտեղ յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ քառակուսիներ, որոնց կողի երկարությունը 1 է, մեկ մեծ քառակուսի մեջ:\nՖունկցիան ընդունում է ցուցակի երկարությունը և թվերի զանգվածը որպես մուտքեր:\n\nՕգտագործման օրինակներ:\n    IsSquare(1, []int{9})             // Արդյունք: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা সম্ভব কিনা,\nযেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের নির্দিষ্ট সংখ্যক বর্গক্ষেত্র রয়েছে, একটি একক বড় বর্গক্ষেত্রে।\nফাংশনটি তালিকার দৈর্ঘ্য এবং সংখ্যার একটি অ্যারে ইনপুট হিসেবে নেয়।\n\nব্যবহারের উদাহরণ:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square определя дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа определен брой квадрати със страна с дължина 1, в един по-голям квадрат.\nФункцията приема дължината на списъка и масив от числа като входни данни.\n\nПримери за употреба:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square 确定是否可以从 n 个桶中组装木方块，\n其中每个桶包含一定数量的边长为 1 的方块，组成一个更大的方块。\n该函数接受列表的长度和一个数字数组作为输入。\n\n使用示例:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square détermine s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient un nombre spécifique de carrés avec une longueur de côté de 1, en un seul carré plus grand.\nLa fonction prend la longueur de la liste et un tableau de nombres en entrée.\n\nExemples d'utilisation :\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern,\nwobei jeder Eimer eine bestimmte Anzahl von Quadraten mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nDie Funktion nimmt die Länge der Liste und ein Array von Zahlen als Eingaben.\n\nVerwendungsbeispiele:\n    IsSquare(1, []int{9})             // Ausgabe: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square yana tantance ko yana yiwuwa a tara murabba'ai na katako daga kwanduna n,\ninda kowanne kwando ya ƙunshi adadi na murabba'ai tare da tsawon gefe na 1, cikin babban murabba'i guda.\nAikin yana ɗaukar tsawon jerin da kuma jerin lambobi a matsayin shigarwa.\n\nMisalan amfani:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एकत्र करना संभव है,\nजहां प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्गों की एक विशिष्ट संख्या होती है, एक बड़े वर्ग में।\nयह फ़ंक्शन सूची की लंबाई और संख्याओं की एक array को इनपुट के रूप में लेता है।\n\nउपयोग के उदाहरण:\n    IsSquare(1, []int{9})             // Output: true\n*/\nfunc IsSquare(length int, squares []int) bool {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nIs_Square meghatározza, hogy lehetséges-e a fa négyzetek összeszerelése n vödörből,\nahol minden vödör egy adott számú, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté.\nA függvény a lista hosszát és egy számokból álló tömböt vesz bemenetként.\n\nHasználati példák:\n    IsSquare(1, []int{9})             // Kimenet: true\n*/\nfunc IsSquare(length int, squares []int) bool {"
    },
    "prompt_bertscore": {
      "sq": "0.9889988563463827",
      "hy": "0.9672474392103952",
      "bn": "0.9771350609479309",
      "bg": "0.9773664653418366",
      "zh": "0.9627470706672877",
      "fr": "0.9943767739129024",
      "de": "0.9955995425385531",
      "ha": "0.9605528008479953",
      "hi": "0.9771928623888121",
      "hu": "0.9735758031501668"
    },
    "canonical_solution": "sum := 0\n\tfor _, square := range squares {\n\t\tsum += square\n\t}\n\troot := int(math.Sqrt(float64(sum)))\n\treturn root*root == sum\n}",
    "instruction": {
      "en": "Write a Go function `func IsSquare(length int, squares []int) bool` to solve the following problem:\nIs_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n",
      "sq": "Shkruani një funksion Go `func IsSquare(length int, squares []int) bool` për të zgjidhur problemin në vijim:  \nIs_Square përcakton nëse është e mundur të montohet katrorët prej druri nga n kovë,  \nku secila kovë përmban një numër specifik të katrorëve me një gjatësi anësore prej 1, në një katror më të madh.  \nFunksioni merr gjatësinë e listës dhe një varg numrash si hyrje.\n\nShembuj përdorimi:  \n    IsSquare(1, []int{9})             // Output: true",
      "hy": "Գրեք Go ֆունկցիա `func IsSquare(length int, squares []int) bool` հետևյալ խնդիրը լուծելու համար:\nIs_Square որոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից,\nորտեղ յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ քառակուսիներ 1 կողքի երկարությամբ, մեկ մեծ քառակուսի մեջ:\nՖունկցիան ընդունում է ցուցակի երկարությունը և թվերի զանգվածը որպես մուտքեր:\n\nՕգտագործման օրինակներ:\n    IsSquare(1, []int{9})             // Արդյունք: true",
      "bn": "একটি Go ফাংশন `func IsSquare(length int, squares []int) bool` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nIs_Square নির্ধারণ করে যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের নির্দিষ্ট সংখ্যক বর্গক্ষেত্র থাকে, একটি একক বড় বর্গক্ষেত্রে।\nফাংশনটি তালিকার দৈর্ঘ্য এবং একটি সংখ্যার অ্যারে ইনপুট হিসাবে নেয়।\n\nব্যবহারের উদাহরণ:\n    IsSquare(1, []int{9})             // Output: true",
      "bg": "Напишете Go функция `func IsSquare(length int, squares []int) bool`, за да решите следния проблем:\nIs_Square определя дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа определен брой квадрати със страна с дължина 1, в един по-голям квадрат.\nФункцията приема дължината на списъка и масив от числа като входни данни.\n\nПримери за употреба:\n    IsSquare(1, []int{9})             // Output: true",
      "zh": "编写一个 Go 函数 `func IsSquare(length int, squares []int) bool` 来解决以下问题：\nIs_Square 确定是否可以从 n 个桶中组装木方块，其中每个桶包含一定数量的边长为 1 的方块，组合成一个更大的正方形。\n该函数接受列表的长度和一个数字数组作为输入。\n\n使用示例：\n    IsSquare(1, []int{9})             // 输出: true",
      "fr": "Écrire une fonction Go `func IsSquare(length int, squares []int) bool` pour résoudre le problème suivant :\nIs_Square détermine s'il est possible d'assembler les carrés en bois à partir de n seaux,\noù chaque seau contient un nombre spécifique de carrés avec une longueur de côté de 1, en un seul carré plus grand.\nLa fonction prend la longueur de la liste et un tableau de nombres en entrée.\n\nExemples d'utilisation :\n    IsSquare(1, []int{9})             // Sortie : true",
      "de": "Schreiben Sie eine Go-Funktion `func IsSquare(length int, squares []int) bool`, um das folgende Problem zu lösen:\nIs_Square bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer eine bestimmte Anzahl von Quadraten mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen.\nDie Funktion nimmt die Länge der Liste und ein Array von Zahlen als Eingaben.\n\nVerwendungsbeispiele:\n    IsSquare(1, []int{9})             // Ausgabe: true",
      "ha": "Rubuta aikin Go `func IsSquare(length int, squares []int) bool` don warware matsalar mai zuwa:\nIs_Square yana tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowace guga tana dauke da adadin murabba'ai tare da tsawon gefe na 1, cikin murabba'i guda mafi girma.\nAikin yana daukar tsawon jerin da kuma jerin lambobi a matsayin shigarwa.\n\nMisalan amfani:\n    IsSquare(1, []int{9})             // Fitarwa: true",
      "hi": "गो फ़ंक्शन `func IsSquare(length int, squares []int) bool` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nIs_Square यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है, जहां प्रत्येक बाल्टी में 1 की साइड लंबाई वाले वर्गों की एक विशिष्ट संख्या होती है, एक बड़े वर्ग में।\nयह फ़ंक्शन सूची की लंबाई और संख्याओं की एक array को इनपुट के रूप में लेता है।\n\nउपयोग के उदाहरण:\n    IsSquare(1, []int{9})             // Output: true",
      "hu": "Írj egy Go függvényt `func IsSquare(length int, squares []int) bool` a következő probléma megoldására:\nIs_Square meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani,\nahol minden vödör egy adott számú négyzetet tartalmaz, amelyek oldalhossza 1, egyetlen nagyobb négyzetté.\nA függvény bemenetként a lista hosszát és egy számokból álló tömböt vesz.\n\nHasználati példák:\n    IsSquare(1, []int{9})             // Output: true"
    },
    "instruction_bertscore": {
      "sq": "0.988391246010797",
      "hy": "0.9764895122095675",
      "bn": "0.9731608642841849",
      "bg": "0.9757909291594679",
      "zh": "0.9370397308626094",
      "fr": "0.9896755900545686",
      "de": "0.9951919529966695",
      "ha": "0.9680536799270159",
      "hi": "0.9750925447397492",
      "hu": "0.9804907226051344"
    },
    "level": "easy",
    "test": "func TestIsSquare(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.True(IsSquare(1, []int{9}))\n\tassert.True(IsSquare(2, []int{14, 2}))\n\tassert.False(IsSquare(2, []int{7, 7}))\n\tassert.False(IsSquare(7, []int{1, 2, 3, 4, 5, 6, 7}))\n\tassert.True(IsSquare(6, []int{1, 3, 5, 7, 9, 11}))\n\tassert.False(IsSquare(4, []int{2, 2, 2, 2}))\n\n\t// Additional test cases\n\tassert.False(IsSquare(3, []int{4, 5, 6}))\n\tassert.False(IsSquare(4, []int{16, 9, 4, 1}))\n\tassert.False(IsSquare(5, []int{1, 1, 1, 1, 1}))\n\tassert.False(IsSquare(2, []int{25, 25}))\n\tassert.True(IsSquare(3, []int{10, 10, 5}))\n}",
    "entry_point": "IsSquare",
    "signature": "func IsSquare(length int, squares []int) bool",
    "docstring": {
      "en": "Is_Square determines if it is possible to assemble the wooden squares from n buckets,\nwhere each bucket contains a specific number of squares with a side length of 1, into a single larger square.\nThe function takes the length of the list and an array of numbers as inputs.\n\nUsage examples:\n    IsSquare(1, []int{9})             // Output: true\n",
      "sq": "Is_Square përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë,\nku secila kovë përmban një numër specifik katrorësh me një gjatësi anësore prej 1, në një katror më të madh.\nFunksioni merr si input gjatësinë e listës dhe një varg numrash.\n\nShembuj përdorimi:\n    IsSquare(1, []int{9})             // Dalje: true",
      "hy": "Is_Square-ը որոշում է, արդյոք հնարավոր է հավաքել փայտե քառակուսիներ n դույլերից, որտեղ յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ քառակուսիներ, որոնց կողային երկարությունը 1 է, մեկ մեծ քառակուսի մեջ:\nՖունկցիան ընդունում է ցուցակի երկարությունը և թվերի զանգվածը որպես մուտքային տվյալներ:\n\nՕգտագործման օրինակներ:\n    IsSquare(1, []int{9})             // Արդյունք: true",
      "bn": "Is_Square নির্ধারণ করে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করা, যেখানে প্রতিটি বালতিতে 1 পাশের দৈর্ঘ্যের নির্দিষ্ট সংখ্যক বর্গক্ষেত্র রয়েছে, একটি একক বৃহত্তর বর্গক্ষেত্রে।\nফাংশনটি তালিকার দৈর্ঘ্য এবং সংখ্যার একটি অ্যারে ইনপুট হিসেবে গ্রহণ করে।\n\nব্যবহারের উদাহরণ:\n    IsSquare(1, []int{9})             // আউটপুট: true",
      "bg": "Is_Square определя дали е възможно да се сглобят дървените квадрати от n кофи,\nкъдето всяка кофа съдържа определен брой квадрати с дължина на страната 1, в един по-голям квадрат.\nФункцията приема дължината на списъка и масив от числа като входни данни.\n\nПримери за използване:\n    IsSquare(1, []int{9})             // Изход: true",
      "zh": "Is_Square 确定是否可以从 n 个桶中组装木制正方形，其中每个桶包含一定数量的边长为 1 的正方形，组装成一个更大的正方形。该函数接受列表的长度和一个数字数组作为输入。\n\n使用示例:\n    IsSquare(1, []int{9})             // 输出: true",
      "fr": "Is_Square détermine s'il est possible d'assembler les carrés en bois à partir de n seaux, où chaque seau contient un nombre spécifique de carrés avec une longueur de côté de 1, en un seul carré plus grand. La fonction prend la longueur de la liste et un tableau de nombres en entrée.\n\nExemples d'utilisation :\n    IsSquare(1, []int{9})             // Sortie : true",
      "de": "Is_Square bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern, wobei jeder Eimer eine bestimmte Anzahl von Quadraten mit einer Seitenlänge von 1 enthält, zu einem einzigen größeren Quadrat zusammenzusetzen. Die Funktion nimmt die Länge der Liste und ein Array von Zahlen als Eingaben.\n\nVerwendungsbeispiele:\n    IsSquare(1, []int{9})             // Ausgabe: true",
      "ha": "Is_Square yana tantance ko yana yiwuwa a tara murabba'ai na katako daga guga n,\ninda kowanne guga yana dauke da adadin murabba'ai tare da tsawon gefe 1, zuwa cikin babban murabba'i guda.\nAikin yana daukar tsawon jerin da kuma jerin lambobi a matsayin shigarwa.\n\nMisalan amfani:\n    IsSquare(1, []int{9})             // Fitarwa: true",
      "hi": "Is_Square निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को इकट्ठा करना संभव है,\nजहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्गों की एक विशिष्ट संख्या होती है, एक बड़े वर्ग में।\n\nयह फ़ंक्शन सूची की लंबाई और संख्याओं की एक array को इनपुट के रूप में लेता है।\n\nउदाहरण उपयोग:\n    IsSquare(1, []int{9})             // आउटपुट: true",
      "hu": "Is_Square meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből összeállítani, ahol minden vödör egy adott számú, 1 oldalhosszúságú négyzetet tartalmaz, egyetlen nagyobb négyzetté. A függvény a lista hosszát és egy számokból álló tömböt vesz bemenetként.\n\nHasználati példák:\n    IsSquare(1, []int{9})             // Kimenet: true"
    },
    "docstring_bertscore": {
      "sq": "0.9750671200509767",
      "hy": "0.9533447029506202",
      "bn": "0.9785300421139389",
      "bg": "0.9674125010570352",
      "zh": "0.9412260647733007",
      "fr": "0.9911031466030663",
      "de": "0.9921356273236857",
      "ha": "0.940299652676154",
      "hi": "0.9644415864478963",
      "hu": "0.9586534971445397"
    }
  },
  {
    "task_id": "Go/21",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven integers c and d, where a + b = c and a * b = d, find\nand return the possible value of a where a <= b. If there are\nmultiple groups, output the group with the smallest a. If no\nvalid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni\ndhe ktheni vlerën e mundshme të a ku a <= b. Nëse ka\ngrupe të shumta, jepni grupin me a më të vogël. Nëse nuk ekziston\nasnjë çift i vlefshëm, kthe -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a, ose -1 nëse nuk ekzistojnë çifte të vlefshme.\n\nShembuj:\n    findIntegers(7,11) // kthen -1\n*/\nfunc findIntegers(c int, d int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել\nև վերադարձնել a-ի հնարավոր արժեքը, որտեղ a <= b։ Եթե կան\nմի քանի խումբ, արդյունք տալ ամենափոքր a-ով խմբին։ Եթե\nոչ մի վավեր զույգ չկա, վերադարձնել -1։\n\nՊարամետրեր:\n- c (int): a-ի և b-ի գումարը։\n- d (int): a-ի և b-ի արտադրյալը։\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը, կամ -1, եթե վավեր զույգեր չկան։\n\nՕրինակներ:\n    findIntegers(7,11) // վերադարձնում է -1\n*/\nfunc findIntegers(c int, d int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান\nঅনুসন্ধান এবং ফেরত দিন যেখানে a <= b। যদি একাধিক গ্রুপ থাকে, তাহলে\nসবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন। যদি কোন বৈধ জোড়া না থাকে, তাহলে -1 ফেরত দিন।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত:\n- int: a এর একটি সম্ভাব্য মান, অথবা যদি কোন বৈধ জোড়া না থাকে তাহলে -1।\n\nউদাহরণ:\n    findIntegers(7,11) // -1 ফেরত দেয়\n*/\nfunc findIntegers(c int, d int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете\nи върнете възможната стойност на a, където a <= b. Ако има\nняколко групи, изведете групата с най-малкото a. Ако не съществува\nвалидна двойка, върнете -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a, или -1 ако не съществуват валидни двойки.\n\nПримери:\n    findIntegers(7,11) // връща -1\n*/\nfunc findIntegers(c int, d int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回可能的 a 值，其中 a <= b。\n如果有多个组合，输出 a 最小的组合。如果不存在有效组合，返回 -1。\n\n参数：\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回：\n- int: 可能的 a 值，或者如果不存在有效组合则返回 -1。\n\n示例：\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver\net retourner la valeur possible de a où a <= b. S'il y a\nplusieurs groupes, sortir le groupe avec le plus petit a. Si aucun\ncouple valide n'existe, retourner -1.\n\nParamètres :\n- c (int) : La somme de a et b.\n- d (int) : Le produit de a et b.\n\nRenvoie :\n- int : Une valeur possible de a, ou -1 si aucun couple valide n'existe.\n\nExemples :\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d, finde\nund gib den möglichen Wert von a zurück, wobei a <= b. Wenn es mehrere Gruppen gibt,\ngib die Gruppe mit dem kleinsten a aus. Wenn kein gültiges Paar existiert, gib -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Paare existieren.\n\nBeispiele:\n    findIntegers(7,11) // gibt -1 zurück\n*/\nfunc findIntegers(c int, d int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo\nkuma dawo da yiwuwar ƙimar a inda a <= b. Idan akwai\nkungiyoyi da yawa, fitar da ƙungiyar tare da ƙaramin a. Idan babu\namsoshin da suka dace, dawo da -1.\n\nSigogi:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nDawowa:\n- int: Yiwuwar ƙimar a, ko -1 idan babu amsoshin da suka dace.\n\nMisalai:\n    findIntegers(7,11) // returns -1\n*/\nfunc findIntegers(c int, d int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का\nसंभव मान खोजें और लौटाएँ जहाँ a <= b। यदि कई समूह हैं, तो\nसबसे छोटे a वाले समूह को आउटपुट करें। यदि कोई वैध जोड़ी\nमौजूद नहीं है, तो -1 लौटाएँ।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nरिटर्न्स:\n- int: a का एक संभावित मान, या -1 यदि कोई वैध जोड़ी मौजूद नहीं है।\n\nउदाहरण:\n    findIntegers(7,11) // -1 लौटाता है\n*/\nfunc findIntegers(c int, d int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott c és d egész számok, ahol a + b = c és a * b = d, találd meg\nés add vissza a lehetséges a értékét, ahol a <= b. Ha több csoport van,\nadd vissza azt a csoportot, ahol a a legkisebb. Ha nem létezik érvényes pár,\ntérj vissza -1 értékkel.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\n- int: a lehetséges a értéke, vagy -1, ha nem létezik érvényes pár.\n\nPéldák:\n    findIntegers(7,11) // visszaadja -1\n*/\nfunc findIntegers(c int, d int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.8764876564648858",
      "hy": "0.981405216879419",
      "bn": "0.9891907332944624",
      "bg": "0.9881451429686948",
      "zh": "0.9762491694485154",
      "fr": "0.9922754631119343",
      "de": "0.9773765954912693",
      "ha": "0.9775859519128801",
      "hi": "0.9816926350407764",
      "hu": "0.9794429473451752"
    },
    "canonical_solution": "for i := 0; i <= c/2; i++ {\n\t\tif i*(c-i) != d {\n\t\t\tcontinue\n\t\t}\n\t\treturn i\n\t}\n\treturn -1 // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a Go function `func findIntegers(c int, d int) int` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the possible value of a where a <= b. If there are multiple groups, output the group with the smallest a. If no valid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n",
      "sq": "Shkruani një funksion Go `func findIntegers(c int, d int) int` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a ku a <= b. Nëse ka grupe të shumta, jepni grupin me a më të vogël. Nëse nuk ekziston asnjë çift i vlefshëm, ktheni -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a, ose -1 nëse nuk ekzistojnë çifte të vlefshme.\n\nShembuj:\n    findIntegers(7,11) // kthen -1",
      "hy": "Գրեք Go ֆունկցիա `func findIntegers(c int, d int) int` հետևյալ խնդիրը լուծելու համար:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը, որտեղ a <= b: Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որի a-ն ամենափոքրն է: Եթե ոչ մի վավեր զույգ չկա, վերադարձնել -1:\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը:\n- d (int): a և b-ի արտադրյալը:\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը, կամ -1, եթե վավեր զույգեր չկան:\n\nՕրինակներ:\n    findIntegers(7,11) // վերադարձնում է -1",
      "bn": "একটি Go ফাংশন `func findIntegers(c int, d int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন যেখানে a <= b। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন। যদি কোনো বৈধ জোড়া না থাকে, তাহলে -1 ফেরত দিন।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nরিটার্নস:\n- int: a এর একটি সম্ভাব্য মান, অথবা যদি কোনো বৈধ জোড়া না থাকে তবে -1।\n\nউদাহরণসমূহ:\n    findIntegers(7,11) // -1 ফেরত দেয়",
      "bg": "Напишете Go функция `func findIntegers(c int, d int) int`, за да решите следния проблем:\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a, където a <= b. Ако има множество групи, изведете групата с най-малката a. Ако не съществува валидна двойка, върнете -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a, или -1 ако не съществуват валидни двойки.\n\nПримери:\n    findIntegers(7,11) // връща -1",
      "zh": "编写一个 Go 函数 `func findIntegers(c int, d int) int` 来解决以下问题：\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值，其中 a <= b。如果有多个组合，输出 a 最小的组合。如果不存在有效的组合，则返回 -1。\n\n参数：\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回：\n- int: a 的可能值，如果不存在有效组合则返回 -1。\n\n示例：\n    findIntegers(7,11) // 返回 -1",
      "fr": "Écrire une fonction Go `func findIntegers(c int, d int) int` pour résoudre le problème suivant :  \nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouvez et renvoyez la valeur possible de a où a <= b. S'il y a plusieurs groupes, affichez le groupe avec le plus petit a. Si aucun couple valide n'existe, renvoyez -1.\n\nParamètres :  \n- c (int) : La somme de a et b.  \n- d (int) : Le produit de a et b.  \n\nRenvoie :  \n- int : Une valeur possible de a, ou -1 si aucun couple valide n'existe.  \n\nExemples :  \n    findIntegers(7,11) // returns -1  ",
      "de": "Schreiben Sie eine Go-Funktion `func findIntegers(c int, d int) int`, um das folgende Problem zu lösen:\nGegeben sind die Ganzzahlen c und d, wobei a + b = c und a * b = d, finden und geben Sie den möglichen Wert von a zurück, wobei a <= b. Wenn es mehrere Gruppen gibt, geben Sie die Gruppe mit dem kleinsten a aus. Wenn kein gültiges Paar existiert, geben Sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewerte:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Paare existieren.\n\nBeispiele:\n    findIntegers(7,11) // gibt -1 zurück",
      "ha": "Rubuta aikin Go `func findIntegers(c int, d int) int` don warware matsalar mai zuwa:\nAn ba da lambobi c da d, inda a + b = c da a * b = d, nemo kuma dawo da wata kima ta a inda a <= b. Idan akwai kungiyoyi da yawa, fitar da kungiyar da ke da karamin a. Idan babu wani sahihin nau'i, dawo da -1.\n\nSigogi:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nDawowa:\n- int: Wata kima ta a, ko -1 idan babu sahihan nau'i.\n\nMisalai:\n    findIntegers(7,11) // returns -1",
      "hi": "Go फ़ंक्शन `func findIntegers(c int, d int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ जहाँ a <= b। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें। यदि कोई मान्य जोड़ी मौजूद नहीं है, तो -1 लौटाएँ।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी मान:\n- int: a का एक संभावित मान, या -1 यदि कोई मान्य जोड़ी मौजूद नहीं है।\n\nउदाहरण:\n    findIntegers(7,11) // -1 लौटाता है",
      "hu": "Írj egy Go függvényt `func findIntegers(c int, d int) int` a következő probléma megoldására:\nAdottak az egész számok c és d, ahol a + b = c és a * b = d, találd meg és add vissza a lehetséges a értéket, ahol a <= b. Ha több csoport van, add vissza azt a csoportot, amelyikben a legkisebb az a. Ha nem létezik érvényes pár, térj vissza -1-gyel.\n\nParaméterek:\n- c (int): Az a és b összege.\n- d (int): Az a és b szorzata.\n\nVisszatérési érték:\n- int: Egy lehetséges a érték, vagy -1, ha nem létezik érvényes pár.\n\nPéldák:\n    findIntegers(7,11) // visszatér -1-gyel"
    },
    "instruction_bertscore": {
      "sq": "0.9802775922062839",
      "hy": "0.9819190736751562",
      "bn": "0.9886335750756595",
      "bg": "0.9870618128705305",
      "zh": "0.9683269953313198",
      "fr": "0.9843773232708439",
      "de": "0.975638182396452",
      "ha": "0.9706126351258882",
      "hi": "0.9853760368266874",
      "hu": "0.9707083749695471"
    },
    "level": "easy",
    "test": "func TestFindIntegers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, findIntegers(5, 6))\n\tassert.Equal(3, findIntegers(6, 9))\n\tassert.Equal(3, findIntegers(7, 12))\n\tassert.Equal(-1, findIntegers(7, 11))\n\tassert.Equal(1, findIntegers(9, 8))\n\tassert.Equal(5, findIntegers(10, 25))\n\tassert.Equal(-1, findIntegers(10000, 8765))\n}",
    "entry_point": "findIntegers",
    "signature": "func findIntegers(c int, d int) int",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a where a <= b. If there are multiple groups, output the group with the smallest a. If no valid pair exists, return -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a, or -1 if no valid pairs exist.\n\nExamples:\n    findIntegers(7,11) // returns -1\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni vlerën e mundshme të a ku a <= b. Nëse ka disa grupe, jepni grupin me a më të vogël. Nëse nuk ekziston asnjë çift i vlefshëm, kthe -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a, ose -1 nëse nuk ekzistojnë çifte të vlefshme.\n\nShembuj:\n    findIntegers(7,11) // kthen -1",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը, որտեղ a <= b: Եթե կան բազմաթիվ խմբեր, վերադարձնել այն խումբը, որտեղ a-ն ամենափոքրն է: Եթե վավեր զույգ չի գոյություն ունենում, վերադարձնել -1:\n\nՊարամետրեր:\n- c (int): a-ի և b-ի գումարը:\n- d (int): a-ի և b-ի արտադրյալը:\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը, կամ -1, եթե վավեր զույգեր չկան:\n\nՕրինակներ:\n    findIntegers(7,11) // վերադարձնում է -1",
      "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন যেখানে a <= b। যদি একাধিক গ্রুপ থাকে, তাহলে সবচেয়ে ছোট a সহ গ্রুপটি আউটপুট করুন। যদি কোনো বৈধ জোড়া না থাকে, তাহলে -1 ফেরত দিন।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত দেয়:\n- int: a এর একটি সম্ভাব্য মান, অথবা যদি কোনো বৈধ জোড়া না থাকে তবে -1।\n\nউদাহরণ:\n    findIntegers(7,11) // -1 ফেরত দেয়",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете възможната стойност на a, където a <= b. Ако има множество групи, изведете групата с най-малката a. Ако не съществува валидна двойка, върнете -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a, или -1 ако не съществуват валидни двойки.\n\nПримери:\n    findIntegers(7,11) // връща -1",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值，其中 a <= b。如果有多个组合，输出 a 最小的组合。如果不存在有效的组合，返回 -1。\n\n参数:\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回:\n- int: a 的可能值，如果不存在有效组合则返回 -1。\n\n示例:\n    findIntegers(7,11) // 返回 -1",
      "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, trouvez et renvoyez la valeur possible de a où a <= b. S'il y a plusieurs groupes, affichez le groupe avec le plus petit a. Si aucun couple valide n'existe, renvoyez -1.\n\nParamètres:\n- c (int): La somme de a et b.\n- d (int): Le produit de a et b.\n\nRenvoie:\n- int: Une valeur possible de a, ou -1 si aucun couple valide n'existe.\n\nExemples:\n    findIntegers(7,11) // renvoie -1",
      "de": "Gegeben sind ganze Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den möglichen Wert von a zurück, wobei a <= b. Wenn es mehrere Gruppen gibt, gib die Gruppe mit dem kleinsten a aus. Wenn kein gültiges Paar existiert, gib -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Paare existieren.\n\nBeispiele:\n    findIntegers(7,11) // gibt -1 zurück",
      "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da yiwuwar ƙimar a inda a <= b. Idan akwai rukuni da yawa, fitar da rukunin da ke da ƙaramin a. Idan babu ma'aurata masu inganci, dawo da -1.\n\nParameters:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nReturns:\n- int: Yiwuwar ƙimar a, ko -1 idan babu ma'aurata masu inganci.\n\nExamples:\n    findIntegers(7,11) // returns -1",
      "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ जहाँ a <= b। यदि कई समूह हैं, तो सबसे छोटे a वाले समूह को आउटपुट करें। यदि कोई वैध जोड़ी मौजूद नहीं है, तो -1 लौटाएँ।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान, या -1 यदि कोई वैध जोड़ी मौजूद नहीं है।\n\nउदाहरण:\n    findIntegers(7,11) // -1 लौटाता है",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, találja meg és adja vissza a lehetséges a értékét, ahol a <= b. Ha több csoport létezik, adja meg a legkisebb a értékű csoportot. Ha nem létezik érvényes pár, adjon vissza -1-et.\n\nParaméterek:\n- c (int): a és b összege.\n- d (int): a és b szorzata.\n\nVisszatérési érték:\n- int: a lehetséges a értéke, vagy -1, ha nem létezik érvényes pár.\n\nPéldák:\n    findIntegers(7,11) // visszaadja -1"
    },
    "docstring_bertscore": {
      "sq": "0.97159565688163",
      "hy": "0.9693559007050806",
      "bn": "0.9973645721044291",
      "bg": "0.9933766699443917",
      "zh": "0.9627685227484395",
      "fr": "0.9934479782511831",
      "de": "0.9744156124011822",
      "ha": "0.9779073358693946",
      "hi": "0.9811366686042597",
      "hu": "0.9554374726452038"
    }
  },
  {
    "task_id": "Go/22",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur tre shifra a, b, c ku dy janë identike dhe i treti është i ndryshëm,\ngjej vlerën unike.\n\nShembuj:\n    extraNumber(0, 0, 1) duhet të kthejë 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԵրեք թվանշանների դեպքում a, b, c, որտեղ երկուսը նույնական են և երրորդը տարբեր է,\nգտեք եզակի արժեքը։\n\nՕրինակներ:\n    extraNumber(0, 0, 1) պետք է վերադարձնի 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতিনটি সংখ্যা a, b, c দেওয়া আছে যেখানে দুটি অভিন্ন এবং তৃতীয়টি ভিন্ন,\nঅনন্য মানটি খুঁজে বের করুন।\n\nউদাহরণ:\n    extraNumber(0, 0, 1) 1 রিটার্ন করা উচিত\n*/\nfunc extraNumber(a, b, c int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са три цифри a, b, c, където две са идентични, а третата е различна,\nнамерете уникалната стойност.\n\nПримери:\n    extraNumber(0, 0, 1) трябва да върне 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定三个数字 a, b, c，其中两个是相同的，第三个是不同的，\n找出唯一的值。\n\n例子:\n    extraNumber(0, 0, 1) 应该返回 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné trois chiffres a, b, c où deux sont identiques et le troisième est différent,\ntrouvez la valeur unique.\n\nExemples :\n    extraNumber(0, 0, 1) devrait retourner 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind drei Ziffern a, b, c, wobei zwei identisch sind und die dritte unterschiedlich ist,\nfinden Sie den einzigartigen Wert.\n\nBeispiele:\n    extraNumber(0, 0, 1) sollte 1 zurückgeben\n*/\nfunc extraNumber(a, b, c int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da lambobi uku a, b, c inda biyu suna daidai kuma na uku ya bambanta,\nnemo ƙimar da ta bambanta.\n\nMisalai:\n    extraNumber(0, 0, 1) ya kamata ya dawo da 1\n*/\nfunc extraNumber(a, b, c int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nतीन अंक a, b, c दिए गए हैं जहाँ दो समान हैं और तीसरा अलग है,\nअद्वितीय मान खोजें।\n\nउदाहरण:\n    extraNumber(0, 0, 1) को 1 लौटाना चाहिए\n*/\nfunc extraNumber(a, b, c int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott három számjegy a, b, c, ahol kettő azonos és a harmadik eltérő,\ntaláld meg az egyedi értéket.\n\nPéldák:\n    extraNumber(0, 0, 1) vissza kell adnia 1-et\n*/\nfunc extraNumber(a, b, c int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9910091944328369",
      "hy": "0.9855124958984584",
      "bn": "0.9770510402967532",
      "bg": "0.997779908231173",
      "zh": "0.9837158841019978",
      "fr": "0.9925058743539347",
      "de": "0.997779908231173",
      "ha": "0.9679261592223914",
      "hi": "0.9698731342172954",
      "hu": "0.997779908231173"
    },
    "canonical_solution": "if a == b {\n\t\treturn c\n\t} else if a == c {\n\t\treturn b\n\t}\n\treturn a\n}",
    "instruction": {
      "en": "Write a Go function `func extraNumber(a, b, c int) int` to solve the following problem:\nGiven three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n",
      "sq": "Shkruani një funksion në Go `func extraNumber(a, b, c int) int` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh tre shifra a, b, c ku dy janë identike dhe e treta është e ndryshme,\ngjeni vlerën unike.\n\nShembuj:\n    extraNumber(0, 0, 1) duhet të kthejë 1",
      "hy": "Գրեք Go ֆունկցիա `func extraNumber(a, b, c int) int`՝ լուծելու համար հետևյալ խնդիրը:\nԵրեք թվանշան a, b, c տրված են, որտեղ երկուսը նույնական են, իսկ երրորդը՝ տարբեր,\nգտեք եզակի արժեքը:\n\nՕրինակներ:\n    extraNumber(0, 0, 1) պետք է վերադարձնի 1",
      "bn": "একটি Go ফাংশন `func extraNumber(a, b, c int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি সংখ্যা a, b, c দেওয়া হয়েছে যেখানে দুটি অভিন্ন এবং তৃতীয়টি আলাদা,\nঅনন্য মানটি খুঁজে বের করুন।\n\nউদাহরণ:\n    extraNumber(0, 0, 1) 1 রিটার্ন করা উচিত",
      "bg": "Напишете функция на Go `func extraNumber(a, b, c int) int`, за да решите следния проблем:\nДадени са три цифри a, b, c, където две са идентични, а третата е различна,\nнамерете уникалната стойност.\n\nПримери:\n    extraNumber(0, 0, 1) трябва да върне 1",
      "zh": "编写一个 Go 函数 `func extraNumber(a, b, c int) int` 来解决以下问题：\n给定三个数字 a, b, c，其中两个是相同的，第三个是不同的，\n找出唯一的值。\n\n示例：\n    extraNumber(0, 0, 1) 应返回 1",
      "fr": "Écrivez une fonction Go `func extraNumber(a, b, c int) int` pour résoudre le problème suivant :  \nÉtant donné trois chiffres a, b, c où deux sont identiques et le troisième est différent,  \ntrouvez la valeur unique.\n\nExemples :  \n    extraNumber(0, 0, 1) devrait retourner 1",
      "de": "Schreiben Sie eine Go-Funktion `func extraNumber(a, b, c int) int`, um das folgende Problem zu lösen:\nGegeben sind drei Ziffern a, b, c, von denen zwei identisch sind und die dritte unterschiedlich ist,\nfinden Sie den einzigartigen Wert.\n\nBeispiele:\n    extraNumber(0, 0, 1) sollte 1 zurückgeben",
      "ha": "Rubuta wani aikin Go `func extraNumber(a, b, c int) int` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku a, b, c inda biyu suna daidai kuma na uku ya bambanta,\nnemo ƙimar da ta bambanta.\n\nMisalai:\n    extraNumber(0, 0, 1) yakamata ya dawo da 1",
      "hi": "Go फ़ंक्शन `func extraNumber(a, b, c int) int` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए तीन अंक a, b, c जहाँ दो समान हैं और तीसरा अलग है,\nअद्वितीय मान खोजें।\n\nउदाहरण:\n    extraNumber(0, 0, 1) को 1 लौटाना चाहिए",
      "hu": "Írj egy Go függvényt `func extraNumber(a, b, c int) int` a következő probléma megoldására:\nAdott három számjegy a, b, c, ahol kettő azonos és a harmadik eltérő,\ntaláld meg az egyedi értéket.\n\nPéldák:\n    extraNumber(0, 0, 1) értéke 1 kell legyen"
    },
    "instruction_bertscore": {
      "sq": "0.9847505497568085",
      "hy": "0.9646382305251209",
      "bn": "0.9657678415020663",
      "bg": "0.9823646016198174",
      "zh": "0.9817933406439611",
      "fr": "0.991209811117682",
      "de": "0.9983547445538881",
      "ha": "0.968453125623277",
      "hi": "0.9636923526506328",
      "hu": "0.9804017361944307"
    },
    "level": "easy",
    "test": "func TestExtraNumber(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(7, extraNumber(2, 7, 2), \"Extra number should be 7\")\n\tassert.Equal(3, extraNumber(3, 2, 2), \"Extra number should be 3\")\n\tassert.Equal(1, extraNumber(5, 5, 1), \"Extra number should be 1\")\n\tassert.Equal(3, extraNumber(500000000, 3, 500000000), \"Extra number should be 3\")\n\tassert.Equal(3, extraNumber(500000000, 500000000, 3), \"Extra number should be 3\")\n}",
    "entry_point": "extraNumber",
    "signature": "func extraNumber(a, b, c int) int",
    "docstring": {
      "en": "Given three digits a, b, c where two are identical and the third is different,\nfind the unique value.\n\nExamples:\n    extraNumber(0, 0, 1) should return 1\n",
      "sq": "Duke pasur tre shifra a, b, c ku dy janë identike dhe e treta është e ndryshme, gjeni vlerën unike.\n\nShembuj:\n    extraNumber(0, 0, 1) duhet të kthejë 1",
      "hy": "Երեք թվանշան a, b, c ունենալիս, որտեղ երկուսը նույնական են և երրորդը տարբեր է,\nգտնել եզակի արժեքը։\n\nՕրինակներ:\n    extraNumber(0, 0, 1) պետք է վերադարձնի 1",
      "bn": "তিনটি সংখ্যা a, b, c দেওয়া আছে যেখানে দুটি সংখ্যা অভিন্ন এবং তৃতীয়টি ভিন্ন, অনন্য মানটি খুঁজে বের করুন।\n\nউদাহরণ:\n    extraNumber(0, 0, 1) 1 ফেরত দেওয়া উচিত",
      "bg": "Дадени са три цифри a, b, c, където две са идентични и третата е различна, намерете уникалната стойност.\n\nПримери:\n    extraNumber(0, 0, 1) трябва да върне 1",
      "zh": "给定三个数字 a, b, c，其中两个是相同的，第三个是不同的，找出唯一的值。\n\n示例：\n    extraNumber(0, 0, 1) 应返回 1",
      "fr": "Étant donné trois chiffres a, b, c où deux sont identiques et le troisième est différent, trouvez la valeur unique.\n\nExemples :\n    extraNumber(0, 0, 1) devrait retourner 1",
      "de": "Gegeben drei Ziffern a, b, c, wobei zwei identisch sind und die dritte unterschiedlich ist, finde den einzigartigen Wert.\n\nBeispiele:\n    extraNumber(0, 0, 1) sollte 1 zurückgeben",
      "ha": "An ba da lambobi uku a, b, c inda biyu suna daidai kuma na uku ya bambanta, gano ƙimar da ta bambanta.\n\nMisalai:\n    extraNumber(0, 0, 1) ya kamata ya dawo da 1",
      "hi": "तीन अंक a, b, c दिए गए हैं जहाँ दो समान हैं और तीसरा अलग है, अद्वितीय मान खोजें।\n\nउदाहरण:\n    extraNumber(0, 0, 1) को 1 लौटाना चाहिए",
      "hu": "Három számjegy, a, b, c adott, ahol kettő azonos és a harmadik eltérő, \ntaláld meg az egyedi értéket.\n\nPéldák:\n    extraNumber(0, 0, 1) vissza kell adnia 1"
    },
    "docstring_bertscore": {
      "sq": "0.9996440543571855",
      "hy": "0.9816745596761023",
      "bn": "0.9329392052765252",
      "bg": "0.9953303983722508",
      "zh": "0.9677491795528893",
      "fr": "0.9845272892085253",
      "de": "0.9953303983722508",
      "ha": "0.9493923556287881",
      "hi": "0.9471744487941525",
      "hu": "0.957971797676828"
    }
  },
  {
    "task_id": "Go/23",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "sq": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nNumëroni numrin e trekëndëshave me kënde të mprehta që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges: Një listë e plotë me numra të plotë që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënde të mprehta që mund të formohen.\n\nShembuj:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "hy": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՀաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողեր տրված կողերի բազմությունից:\n\nԱրգումենտներ:\n- edges: Կողերի երկարությունները ներկայացնող ամբողջ թվերի շերտ:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "bn": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো 3টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges: প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "bg": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges: Срез от цели числа, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "zh": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n计算可以通过从给定的边集合中选择任意3条边形成的锐角三角形的数量。\n\n参数:\n- edges: 一个整数切片，表示边的长度。\n\n返回:\nint: 可以形成的不同锐角三角形的数量。\n\n示例:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "fr": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nComptez le nombre de triangles aigus qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArguments:\n- edges: Une tranche d'entiers représentant les longueurs des côtés.\n\nRenvoie:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n\nExemples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "de": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgumente:\n- edges: Ein Slice von ganzen Zahlen, das die Längen der Kanten darstellt.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "ha": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nƘirga adadin kusurwa masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane gefuna 3 daga cikin wani saitin gefuna da aka bayar.\n\nHujojji:\n- edges: Wani yanki na lambobi masu nuna tsawon gefuna.\n\nDawowa:\nint: Adadin kusurwa masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "hi": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्रकोण त्रिभुजों की संख्या गिनें।\n\nतर्क:\n- edges: किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्रकोण त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {",
      "hu": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSzámolja meg a hegyesszögű háromszögek számát, amelyek bármely 3 él kiválasztásával képezhetők a megadott élek halmazából.\n\nArgumentumok:\n- edges: Egészek szelete, amely az élek hosszát reprezentálja.\n\nVisszatér:\nint: Azoknak a különböző hegyesszögű háromszögeknek a száma, amelyek képezhetők.\n\nPéldák:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n*/\nfunc countAcuteTriangles(edges []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9785266653974614",
      "hy": "0.9618121174637565",
      "bn": "0.9802275373502631",
      "bg": "0.9763423270972207",
      "zh": "0.9565823781614889",
      "fr": "0.9634976948772186",
      "de": "0.9706573269616211",
      "ha": "0.9614329320663609",
      "hi": "0.9891559729777814",
      "hu": "0.9849511664416538"
    },
    "canonical_solution": "sort.Ints(edges) // Sorting the edges\n\n\tsum := 0\n\tedgesCount := len(edges)\n\tfor i := 0; i < edgesCount-2; i++ {\n\t\tfor j := i + 1; j < edgesCount-1; j++ {\n\t\t\tfor k := j + 1; k < edgesCount; k++ {\n\t\t\t\tx, y, z := edges[i], edges[j], edges[k]\n\t\t\t\tif x+y > z && x*x+y*y > z*z {\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sum\n}",
    "instruction": {
      "en": "Write a Go function `func countAcuteTriangles(edges []int) int` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n",
      "sq": "Shkruani një funksion Go `func countAcuteTriangles(edges []int) int` për të zgjidhur problemin e mëposhtëm: Numëroni numrin e trekëndëshave me kënde të mprehta që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges: Një prerje e numrave të plotë që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshme me kënde të mprehta që mund të formohen.\n\nShembuj:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hy": "Գրեք Go ֆունկցիա `func countAcuteTriangles(edges []int) int` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել ցանկացած 3 կող ընտրելով տրված կողերի հավաքածուից:\n\nԱրգումենտներ:\n- edges: Անթիվների կտոր, որը ներկայացնում է կողերի երկարությունները:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "bn": "একটি Go ফাংশন `func countAcuteTriangles(edges []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তের একটি সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণী ত্রিভুজ গঠন করা যেতে পারে তা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges: প্রান্তের দৈর্ঘ্যগুলি উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা।\n\nউদাহরণসমূহ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "bg": "Напишете функция на Go `func countAcuteTriangles(edges []int) int`, за да решите следния проблем:  \nПребройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges: Срез от цели числа, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "zh": "编写一个 Go 函数 `func countAcuteTriangles(edges []int) int` 来解决以下问题：  \n计算可以通过从给定的一组边中选择任意 3 条边形成的锐角三角形的数量。\n\n参数：  \n- edges: 一个整数切片，表示边的长度。\n\n返回：  \nint: 可以形成的不同锐角三角形的数量。\n\n示例：  \n>>> countAcuteTriangles([]int{1, 1, 1, 1})  \n4  ",
      "fr": "Écrire une fonction Go `func countAcuteTriangles(edges []int) int` pour résoudre le problème suivant :  \nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quels 3 côtés parmi un ensemble donné de côtés.\n\nArguments :  \n- edges : Une tranche d'entiers représentant les longueurs des côtés.\n\nRenvoie :  \nint : Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :  \n>>> countAcuteTriangles([]int{1, 1, 1, 1})  \n4  ",
      "de": "Schreiben Sie eine Go-Funktion `func countAcuteTriangles(edges []int) int`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie beliebige 3 Kanten aus einem gegebenen Satz von Kanten auswählen.\n\nArgumente:\n- edges: Ein Slice von ganzen Zahlen, die die Längen der Kanten darstellen.\n\nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "ha": "Rubuta aikin Go `func countAcuteTriangles(edges []int) int` don warware matsalar mai zuwa:  \nƘirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane gefuna 3 daga cikin saitin gefuna da aka bayar.\n\nHujojji:  \n- edges: Wani yanki na lambobi masu nuni da tsawon gefuna.\n\nMayarwa:  \nint: Adadin kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:  \n>>> countAcuteTriangles([]int{1, 1, 1, 1})  \n4  ",
      "hi": "Go फ़ंक्शन `func countAcuteTriangles(edges []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीव्रकोण त्रिभुजों की संख्या गिनें जो किन्हीं 3 किनारों का चयन करके दिए गए किनारों के सेट से बनाए जा सकते हैं।\n\nतर्क:\n- edges: किनारों की लंबाई को दर्शाने वाले पूर्णांकों की एक स्लाइस।\n\nवापसी:\nint: विभिन्न तीव्रकोण त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hu": "Írj egy Go függvényt `func countAcuteTriangles(edges []int) int` a következő probléma megoldására:\nSzámold meg, hány hegyesszögű háromszög alakítható ki egy adott élkészlet bármely 3 élének kiválasztásával.\n\nArgumentumok:\n- edges: Egészek szelete, amely az élek hosszát reprezentálja.\n\nVisszatér:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nPéldák:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9903332552461751",
      "hy": "0.9630350847197884",
      "bn": "0.9802732223379012",
      "bg": "0.9699770179065766",
      "zh": "0.9542407245994686",
      "fr": "0.9616500350728321",
      "de": "0.967524925852701",
      "ha": "0.9644370179491326",
      "hi": "0.9691201264427921",
      "hu": "0.9630170093551141"
    },
    "level": "middle",
    "test": "func TestCountAcuteTriangles(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(4, countAcuteTriangles([]int{1, 1, 1, 1}))\n\tassert.Equal(0, countAcuteTriangles([]int{1, 2, 3}))\n\t// Additional tests to ensure correctness\n\tassert.Equal(0, countAcuteTriangles([]int{3, 4, 5, 7, 10}))\n\tassert.Equal(4, countAcuteTriangles([]int{6, 8, 10, 5, 5, 5}))\n}",
    "entry_point": "countAcuteTriangles",
    "signature": "func countAcuteTriangles(edges []int) int",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArguments:\n- edges: A slice of integers representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4\n",
      "sq": "Numëroni numrin e trekëndëshave këndakut që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges: Një segment i numrave të plotë që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm këndakut që mund të formohen.\n\nShembuj:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hy": "Սուր անկյուն ունեցող եռանկյունիների քանակը հաշվել, որոնք կարելի է կազմել՝ ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից:\n\nԱրձանագրություններ:\n- edges: Թվերի զանգված, որը ներկայացնում է կողերի երկարությունները:\n\nՎերադարձնում է:\nint: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարելի է կազմել:\n\nՕրինակներ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "bn": "তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো ৩টি প্রান্ত নির্বাচন করে গঠন করা যেতে পারে।\n\nআর্গুমেন্টসমূহ:\n- edges: প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\nফেরত দেয়:\nint: ভিন্ন তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা যা গঠন করা যেতে পারে।\n\nউদাহরণ:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges: Списък от цели числа, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges: 一个整数切片，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant n'importe quelles 3 arêtes parmi un ensemble donné d'arêtes.\n\nArguments:\n- edges: Une tranche d'entiers représentant les longueurs des arêtes.\n\nRenvoie:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\nArgumente:\n- edges: Ein Slice von Ganzzahlen, das die Längen der Kanten darstellt.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "ha": "Ƙirga yawan kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane gefuna 3 daga cikin wani saitin gefuna da aka bayar.\n\nHuɗa:\n- edges: Wani yanki na lambobi masu wakiltar tsawon gefuna.\n\nDawowa:\nint: Yawan kusurwoyi masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hi": "तीक्ष्ण कोण वाले त्रिभुजों की संख्या गिनें जो किनारों के दिए गए सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nतर्क:\n- edges: किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\nवापसी:\nint: विशिष्ट तीक्ष्ण कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n\nArgumentumok:\n- edges: Egész számok szelete, amely az élek hosszát reprezentálja.\n\nVisszatér:\nint: Azoknak a különböző hegyesszögű háromszögeknek a száma, amelyek kialakíthatók.\n\nPéldák:\n>>> countAcuteTriangles([]int{1, 1, 1, 1})\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9363703464785218",
      "hy": "0.9052868767807533",
      "bn": "0.9877087520215612",
      "bg": "0.9538768337414127",
      "zh": "0.9328704791646871",
      "fr": "0.9648573198354025",
      "de": "0.9608759724779391",
      "ha": "0.9305590174205841",
      "hi": "0.9839196788729396",
      "hu": "0.9845322549680512"
    }
  },
  {
    "task_id": "Go/24",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "sq": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar lexon një numër të plotë dhe një karakter, pastaj i kthen ato\nsi një varg i formatuar i ndarë me presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (rune): Karakteri i dhënë si hyrje.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembuj:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "hy": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք\nորպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (rune): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, որոնք բաժանված են ստորակետով։\n\nՕրինակներ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "bn": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে\nকমা দ্বারা পৃথক একটি বিন্যাসিত স্ট্রিং হিসাবে ফেরত দেয়।\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (rune): ইনপুট অক্ষর।\nফেরত দেয়:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "bg": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar чете цяло число и символ, след което ги връща\nкато форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (rune): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПримери:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "zh": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar 读取一个整数和一个字符，然后将它们作为格式化字符串返回，中间用逗号分隔。\n参数:\n- integer_value (int): 输入的整数。\n- char_value (rune): 输入的字符。\n返回:\n- string: 一个包含整数和字符的字符串，中间用逗号分隔。\n\n示例:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "fr": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar lit un entier et un caractère, puis les renvoie\ncomme une chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (rune) : Le caractère d'entrée.\nRenvoie :\n- string : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemples :\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "de": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar liest eine Ganzzahl und ein Zeichen und gibt sie dann\nals formatierter String getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (rune): Das Eingabezeichen.\nRückgabe:\n- string: Ein String, der die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n\nBeispiele:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "ha": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar yana karanta cikakken lamba da harafi, sannan yana mayar da su\na matsayin kirtani mai tsara wanda aka raba shi da alamar rubutu.\nSigogi:\n- integer_value (int): Cikakken lamban shigarwa.\n- char_value (rune): Harafin shigarwa.\nYana dawowa:\n- string: Kirtani mai dauke da cikakken lamba da harafi da aka raba su da alamar rubutu.\n\nMisalai:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "hi": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें\nएक स्वरूपित स्ट्रिंग के रूप में अल्पविराम द्वारा अलग करके लौटाता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (rune): इनपुट वर्ण।\nवापसी:\n- string: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम द्वारा अलग होते हैं।\n\nउदाहरण:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {",
      "hu": "package main\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nprocessIntegerAndChar beolvas egy egész számot és egy karaktert, majd visszaadja\nőket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (rune): A bemeneti karakter.\nVisszatér:\n- string: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza vesszővel elválasztva.\n\nPéldák:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n*/\nfunc processIntegerAndChar(integerValue int, charValue rune) string {"
    },
    "prompt_bertscore": {
      "sq": "0.979885893094883",
      "hy": "0.9940257940296137",
      "bn": "0.9882551841997881",
      "bg": "0.990571214442655",
      "zh": "0.992962724230315",
      "fr": "0.9958512072313243",
      "de": "0.9933230397415123",
      "ha": "0.999999801369619",
      "hi": "0.9778256987827892",
      "hu": "0.9911913384922458"
    },
    "canonical_solution": "return fmt.Sprintf(\"%d,%c\", integerValue, charValue)\n}",
    "instruction": {
      "en": "Write a Go function `func processIntegerAndChar(integerValue int, charValue rune) string` to solve the following problem:\nprocessIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n",
      "sq": "Shkruani një funksion Go `func processIntegerAndChar(integerValue int, charValue rune) string` për të zgjidhur problemin në vijim:\nprocessIntegerAndChar lexon një numër të plotë dhe një karakter, pastaj i kthen ato\nsi një varg i formatuar i ndarë me presje.\nParametrat:\n- integer_value (int): Numri i plotë i dhënë.\n- char_value (rune): Karakteri i dhënë.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembuj:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hy": "Գրեք Go ֆունկցիա `func processIntegerAndChar(integerValue int, charValue rune) string` հետևյալ խնդիրը լուծելու համար:\nprocessIntegerAndChar-ը կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք\nորպես ձևավորված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (rune): Մուտքային սիմվոլը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը ստորակետով բաժանված։\n\nՕրինակներ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "bn": "একটি Go ফাংশন `func processIntegerAndChar(integerValue int, charValue rune) string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nprocessIntegerAndChar একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক একটি বিন্যাসিত স্ট্রিং হিসেবে ফেরত দেয়।\nপ্যারামিটারসমূহ:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (rune): ইনপুট অক্ষর।\nফেরত দেয়:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // আউটপুট: \"234,H\"",
      "bg": "Напишете функция на Go `func processIntegerAndChar(integerValue int, charValue rune) string`, за да решите следния проблем:\nprocessIntegerAndChar чете цяло число и символ, след което ги връща\nкато форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (rune): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПримери:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "zh": "编写一个 Go 函数 `func processIntegerAndChar(integerValue int, charValue rune) string` 来解决以下问题：\nprocessIntegerAndChar 读取一个整数和一个字符，然后返回它们\n作为一个以逗号分隔的格式化字符串。\n参数：\n- integer_value (int): 输入的整数。\n- char_value (rune): 输入的字符。\n返回：\n- string: 包含整数和字符的字符串，以逗号分隔。\n\n示例：\n    fmt.Println(processIntegerAndChar(234, 'H')) // 输出: \"234,H\"",
      "fr": "Écrire une fonction Go `func processIntegerAndChar(integerValue int, charValue rune) string` pour résoudre le problème suivant :\nprocessIntegerAndChar lit un entier et un caractère, puis les renvoie\nsous forme de chaîne formatée séparée par une virgule.\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (rune) : Le caractère d'entrée.\nRenvoie :\n- string : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemples :\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "de": "Schreiben Sie eine Go-Funktion `func processIntegerAndChar(integerValue int, charValue rune) string`, um das folgende Problem zu lösen:\nprocessIntegerAndChar liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (rune): Das Eingabezeichen.\nRückgabewert:\n- string: Eine Zeichenkette, die die Ganzzahl und das Zeichen getrennt durch ein Komma enthält.\n\nBeispiele:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ausgabe: \"234,H\"",
      "ha": "Rubuta aikin Go `func processIntegerAndChar(integerValue int, charValue rune) string` don warware matsalar mai zuwa:\nprocessIntegerAndChar yana karanta lamba da harafi, sannan ya mayar da su\na matsayin jeren rubutu da aka raba da alamar koma.\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (rune): Harafin shigarwa.\nDawowa:\n- string: Jeren rubutu da ke dauke da lamba da harafi da aka raba da alamar koma.\n\nMisalai:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hi": "Go फ़ंक्शन `func processIntegerAndChar(integerValue int, charValue rune) string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nprocessIntegerAndChar एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक स्वरूपित स्ट्रिंग के रूप में लौटाता है जो अल्पविराम से अलग होता है।\nपैरामीटर्स:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (rune): इनपुट वर्ण।\nवापसी:\n- string: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग होते हैं।\n\nउदाहरण:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hu": "Írj egy Go függvényt `func processIntegerAndChar(integerValue int, charValue rune) string` a következő probléma megoldására:\nprocessIntegerAndChar beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott sztringként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (rune): A bemeneti karakter.\nVisszatérési érték:\n- string: Egy sztring, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n\nPéldák:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Kimenet: \"234,H\""
    },
    "instruction_bertscore": {
      "sq": "0.9903201456410268",
      "hy": "0.999999801369619",
      "bn": "0.9900595425811091",
      "bg": "0.9881044237405826",
      "zh": "0.9915874074720293",
      "fr": "0.9961199541368645",
      "de": "0.9890765208253673",
      "ha": "0.9724312948946437",
      "hi": "0.9687391533719673",
      "hu": "0.9829122255803306"
    },
    "level": "easy",
    "test": "func TestProcessIntegerAndChar(t *testing.T) {\n\tassert := assert.New(t)\n\n\t// Test 1\n\toutput1 := processIntegerAndChar(234, 'H')\n\tassert.Equal(\"234,H\", output1)\n\n\t// Additional tests can be added here with different input values\n\t// Test 2\n\toutput2 := processIntegerAndChar(123, 'A')\n\tassert.Equal(\"123,A\", output2)\n\n\t// Test 3\n\toutput3 := processIntegerAndChar(0, 'Z')\n\tassert.Equal(\"0,Z\", output3)\n}",
    "entry_point": "processIntegerAndChar",
    "signature": "func processIntegerAndChar(integerValue int, charValue rune) string",
    "docstring": {
      "en": "processIntegerAndChar reads an integer and a character, then returns them\nas a formatted string separated by a comma.\nParameters:\n- integer_value (int): The input integer.\n- char_value (rune): The input character.\nReturns:\n- string: A string containing the integer and character separated by a comma.\n\nExamples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"\n",
      "sq": "processIntegerAndChar lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\nParametrat:\n- integer_value (int): Numri i plotë hyrës.\n- char_value (rune): Karakteri hyrës.\nKthen:\n- string: Një varg që përmban numrin e plotë dhe karakterin të ndarë nga një presje.\n\nShembuj:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hy": "processIntegerAndChar-ը կարդում է ամբողջ թիվ և նիշ, այնուհետև վերադարձնում է դրանք\nորպես ձևաչափված տող, որը բաժանված է ստորակետով։\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (rune): Մուտքային նիշը։\nՎերադարձնում է:\n- string: Տող, որը պարունակում է ամբողջ թիվը և նիշը, բաժանված ստորակետով։\n\nՕրինակներ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Արդյունք: \"234,H\"",
      "bn": "processIntegerAndChar একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি বিন্যাসিত স্ট্রিং হিসেবে কমা দ্বারা পৃথক করে ফেরত দেয়।\nParameters:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (rune): ইনপুট অক্ষর।\nReturns:\n- string: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "bg": "processIntegerAndChar чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (rune): Входният символ.\nВръща:\n- string: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПримери:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "zh": "processIntegerAndChar 读取一个整数和一个字符，然后返回它们作为以逗号分隔的格式化字符串。  \n参数:  \n- integer_value (int): 输入的整数。  \n- char_value (rune): 输入的字符。  \n返回:  \n- string: 包含整数和字符并以逗号分隔的字符串。  \n\n示例:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // 输出: \"234,H\"  ",
      "fr": "processIntegerAndChar lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\nParamètres:\n- integer_value (int): L'entier d'entrée.\n- char_value (rune): Le caractère d'entrée.\nRenvoie:\n- string: Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemples:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Sortie: \"234,H\"",
      "de": "processIntegerAndChar liest eine Ganzzahl und ein Zeichen ein und gibt sie als formatierten String, getrennt durch ein Komma, zurück.\nParameter:\n- integer_value (int): Die Eingabeganzzahl.\n- char_value (rune): Das Eingabezeichen.\nRückgabewert:\n- string: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n\nBeispiele:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Ausgabe: \"234,H\"",
      "ha": "processIntegerAndChar yana karanta lamba da harafi, sannan yana mayar da su\na matsayin kirtani mai tsari da aka raba da alamar rubutu.\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (rune): Harafin shigarwa.\nDawowa:\n- string: Kirtani mai dauke da lamba da harafi da aka raba da alamar rubutu.\n\nMisalai:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Fitarwa: \"234,H\"",
      "hi": "processIntegerAndChar एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक प्रारूपित स्ट्रिंग के रूप में लौटाता है जो अल्पविराम द्वारा अलग किया गया है।  \nParameters:  \n- integer_value (int): इनपुट पूर्णांक।  \n- char_value (rune): इनपुट वर्ण।  \nReturns:  \n- string: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम द्वारा अलग किए गए हैं।  \n\nExamples:  \n    fmt.Println(processIntegerAndChar(234, 'H')) // Output: \"234,H\"",
      "hu": "processIntegerAndChar beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (rune): A bemeneti karakter.\nVisszatér:\n- string: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n\nPéldák:\n    fmt.Println(processIntegerAndChar(234, 'H')) // Kimenet: \"234,H\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9939612391557773",
      "bn": "0.9859685512533145",
      "bg": "0.9919771202796198",
      "zh": "0.9983934774781899",
      "fr": "0.9960565910453144",
      "de": "0.9851414543466852",
      "ha": "0.9857860099331434",
      "hi": "0.9768150674040837",
      "hu": "0.988078005899905"
    }
  },
  {
    "task_id": "Go/25",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik.\nVetëm shkronjat zëvendësohen dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (str): Teksti hyrës që do të përpunohet.\n\nKthen:\nstr: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tkthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբենական կարգով:\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով:\n\nՕրինակ:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tվերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে স্থানান্তরিত হয়।\nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nফেরত দেয়:\nstr: ৫টি অবস্থানে স্থানান্তরিত অক্ষর সহ রূপান্তরিত টেক্সট।\n\nউদাহরণ:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tফেরত দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nПремества всички символи с 5 позиции в азбучен ред.\nСамо буквите се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (str): Входният текст, който ще бъде обработен.\n\nВръща:\nstr: Преобразуваният текст със символи, преместени с 5 позиции.\n\nПример:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n将所有字符按字母顺序移动5个位置。\n只有字母会被替换，并且所有字母都是大写。\n\n参数：\ntext (str): 要处理的输入文本。\n\n返回：\nstr: 字符移动5个位置后的转换文本。\n\n示例:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique.\nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :\ntext (str) : Le texte d'entrée à traiter.\n\nRenvoie :\nstr : Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\trenvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (str): Der Eingabetext, der verarbeitet werden soll.\n\nRückgabe:\nstr: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa.\nHaruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (str): Rubutun shigarwa da za a sarrafa.\n\nDawowa:\nstr: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\nMisali:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।\nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (str): इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\nवापसी:\nstr: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\nउदाहरण:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tवापसी \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nMinden karaktert 5 pozícióval eltol az ábécében.\nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n\tshift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tvisszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nfunc shiftCharacters(text string) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9938347116030581",
      "hy": "0.9811414357334046",
      "bn": "0.962663248646491",
      "bg": "0.9854687972146307",
      "zh": "0.9641722436512131",
      "fr": "0.9936094647509646",
      "de": "1",
      "ha": "0.8556127952004053",
      "hi": "0.9753684423390067",
      "hu": "0.9717907119158062"
    },
    "canonical_solution": "runes := []rune(text)\n\tfor i, r := range runes {\n\t\tif 'A' <= r && r <= 'E' {\n\t\t\trunes[i] = r + 'V' - 'A'\n\t\t} else if 'F' <= r && r <= 'Z' {\n\t\t\trunes[i] = r + 'A' - 'F'\n\t\t}\n\t}\n\treturn string(runes)\n}",
    "instruction": {
      "en": "Write a Go function `func shiftCharacters(text string) string` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "sq": "Shkruani një funksion Go `func shiftCharacters(text string) string` për të zgjidhur problemin e mëposhtëm:\nZhvendos të gjitha karakteret me 5 pozicione në rendin alfabetik.\nVetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (str): Teksti hyrës që do të përpunohet.\n\nKthen:\nstr: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tkthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Գրեք Go ֆունկցիա `func shiftCharacters(text string) string` հետևյալ խնդիրը լուծելու համար:\nՏեղաշարժում է բոլոր նիշերը 5 դիրքով այբբենական կարգով:\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը՝ նիշերը 5 դիրքով տեղաշարժված:\n\nՕրինակ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tվերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "Go ফাংশন `func shiftCharacters(text string) string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবর্ণানুক্রমিক ক্রমে সব অক্ষরকে ৫ অবস্থানে সরিয়ে দেয়।\nশুধুমাত্র অক্ষর প্রতিস্থাপিত হয়, এবং সব অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nরিটার্নস:\nstr: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে সরানো হয়েছে।\n\nউদাহরণ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tফিরিয়ে দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Напишете Go функция `func shiftCharacters(text string) string`, за да решите следния проблем:\nПремества всички символи с 5 позиции в азбучен ред.\nСамо буквите се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (str): Входният текст, който ще бъде обработен.\n\nВръща:\nstr: Преобразуваният текст със символи, преместени с 5 позиции.\n\nПример:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "编写一个 Go 函数 `func shiftCharacters(text string) string` 来解决以下问题：\n将所有字符在字母表中移动5个位置。\n只有字母被替换，且所有字母都是大写。\n\n参数：\ntext (str): 要处理的输入文本。\n\n返回：\nstr: 字符移动5个位置后的转换文本。\n\n示例：\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Écrire une fonction Go `func shiftCharacters(text string) string` pour résoudre le problème suivant :\nDécale tous les caractères de 5 positions dans l'ordre alphabétique.\nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :\ntext (str) : Le texte d'entrée à traiter.\n\nRenvoie :\nstr : Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\trenvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Schreiben Sie eine Go-Funktion `func shiftCharacters(text string) string`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.\nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (str): Der zu verarbeitende Eingabetext.\n\nRückgabewert:\nstr: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tgibt \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" zurück.",
      "ha": "Rubuta aikin Go `func shiftCharacters(text string) string` don warware matsalar mai zuwa:\nCanza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa.\nHaruffa kawai ake maye gurbin, kuma duk haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (str): Rubutun shigarwa da za a sarrafa.\n\nDawowa:\nstr: Rubutun da aka sauya tare da haruffa da aka matsar da wurare 5.\n\nMisali:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tyana dawowa \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "Go फ़ंक्शन `func shiftCharacters(text string) string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।\nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (str): इनपुट टेक्स्ट जिसे प्रोसेस करना है।\n\nवापसी:\nstr: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\nउदाहरण:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\t\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\" लौटाता है।",
      "hu": "Írj egy Go függvényt `func shiftCharacters(text string) string` a következő probléma megoldására:\nAz összes karaktert 5 pozícióval eltolja ábécé sorrendben.\nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tvisszatér \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "sq": "0.9916048869455605",
      "hy": "0.9969228181370076",
      "bn": "0.9719130682305237",
      "bg": "0.9939002596287996",
      "zh": "0.9641515860915855",
      "fr": "0.9905289061714945",
      "de": "0.9837107197120909",
      "ha": "0.97550728497535",
      "hi": "0.9565960836577804",
      "hu": "0.9862317365081857"
    },
    "level": "easy",
    "test": "func TestShiftCharacters(t *testing.T) {\n\tassert := assert.New(t)\n\n\ttest1 := \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\"\n\texpected1 := \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\tassert.Equal(expected1, shiftCharacters(test1), \"Test case 1 failed\")\n\n\ttest2 := \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\"\n\texpected2 := \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\"\n\tassert.Equal(expected2, shiftCharacters(test2), \"Test case 2 failed\")\n\n\ttest3 := \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\"\n\texpected3 := \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\"\n\tassert.Equal(expected3, shiftCharacters(test3), \"Test case 3 failed\")\n}",
    "entry_point": "shiftCharacters",
    "signature": "func shiftCharacters(text string) string",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order.\nOnly letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (str): The input text to be processed.\n\nReturns:\nstr: The transformed text with characters shifted by 5 positions.\n\nExample:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (str): Teksti hyrës që do të përpunohet.\n\nKthen:\nstr: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tkthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Բոլոր նիշերը տեղափոխում է այբբենական կարգով 5 դիրքով:\nՄիայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (str): Մուտքային տեքստը, որը պետք է մշակվի:\n\nՎերադարձնում է:\nstr: Փոխակերպված տեքստը, որտեղ նիշերը տեղափոխված են 5 դիրքով:\n\nՕրինակ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tվերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে সরিয়ে দেয়। \nশুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (str): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n\nরিটার্নস:\nstr: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫টি অবস্থানে সরানো হয়েছে।\n\nউদাহরণ:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tফিরিয়ে দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Изместява всички символи с 5 позиции в азбучен ред.  \nСамо букви се заменят, и всички букви са с главни букви.\n\nПараметри:  \ntext (str): Входният текст, който ще бъде обработен.\n\nВръща:  \nstr: Преобразуваният текст със символи, изместени с 5 позиции.\n\nПример:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "将所有字符在字母表中向后移动5个位置。  \n仅替换字母，且所有字母均为大写。\n\n参数：  \ntext (str): 要处理的输入文本。\n\n返回：  \nstr: 转换后的文本，其中字符向后移动5个位置。\n\n示例：  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\t返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique.  \nSeules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :  \ntext (str) : Le texte d'entrée à traiter.\n\nRenvoie :  \nstr : Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\trenvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge.  \nNur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:  \ntext (str): Der zu verarbeitende Eingabetext.\n\nRückgabewert:  \nstr: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tgibt zurück \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa.\nHaruffa kawai ake maye gurbinsu, kuma dukkan haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (str): Rubutun da za a sarrafa.\n\nAbubuwan da ake mayarwa:\nstr: Rubutun da aka canza tare da haruffa da aka matsar da su wurare 5.\n\nMisali:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\treturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है।  \nकेवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:  \ntext (str): वह इनपुट टेक्स्ट जिसे प्रोसेस किया जाना है।\n\nरिटर्न्स:  \nstr: परिवर्तित टेक्स्ट जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n\nउदाहरण:  \n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\tरिटर्न करता है \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Az összes karaktert 5 pozícióval eltolja ábécé sorrendben. \nCsak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (str): A feldolgozandó bemeneti szöveg.\n\nVisszatér:\nstr: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\n\tshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") \n\tvisszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.9847354538478499",
      "hy": "0.9767979851913147",
      "bn": "0.9408697218697242",
      "bg": "0.9923970249051276",
      "zh": "0.9499123699663374",
      "fr": "0.9839973433519242",
      "de": "0.9837246238387634",
      "ha": "0.9566759330709564",
      "hi": "0.9769092182046942",
      "hu": "0.9791988306068834"
    }
  },
  {
    "task_id": "Go/26",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "sq": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa në të cilën i përket numri i plotë x.\n\nShembuj:\n    classifyInteger(\"24\") // kthen 6\n*/\nfunc classifyInteger(x string) int {",
      "hy": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԴասակարգեք ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (string): Ամբողջ թիվը, որը պետք է դասակարգվի որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\n    classifyInteger(\"24\") // վերադարձնում է 6\n*/\nfunc classifyInteger(x string) int {",
      "bn": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (string): পূর্ণসংখ্যাটি একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করা হবে।\n\nফেরত:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\nউদাহরণ:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "bg": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, сумирайте цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:\n- x (string): Цялото число, което трябва да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nПримери:\n    classifyInteger(\"24\") // връща 6\n*/\nfunc classifyInteger(x string) int {",
      "zh": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n根据以下方法对整数x进行分类：\n如果x是个位数，x属于它自己的类。\n否则，将x的各位数字相加，得到一个新的x，并迭代直到确定类。\n\n参数:\n- x (string): 要分类的整数，作为字符串。\n\n返回:\nint: 整数x所属的类。\n\n示例:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "fr": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRetourne :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "de": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKlassifiziere die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als String zu klassifizierende ganze Zahl.\n\nRückgabewerte:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\n    classifyInteger(\"24\") // gibt 6 zurück\n*/\nfunc classifyInteger(x string) int {",
      "ha": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda, x tana cikin ajin kanta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin kirtani.\n\nDawowa:\nint: Aji da lambar x take ciki.\n\nMisalai:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "hi": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nपूरे x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपने स्वयं के वर्ग का है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक वर्ग निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nवापसी:\nint: वह वर्ग जिसमें पूर्णांक x है।\n\nउदाहरण:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {",
      "hu": "package main\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nOsztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összegezze x számjegyeit, kapjon egy új x-et, és ismételje, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám karakterláncként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\n    classifyInteger(\"24\") // returns 6\n*/\nfunc classifyInteger(x string) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9878658686529597",
      "hy": "0.9843270697844422",
      "bn": "0.9452596519209762",
      "bg": "1",
      "zh": "0.9696190859599518",
      "fr": "0.9853299545782873",
      "de": "0.9911140712740233",
      "ha": "0.9673046447601332",
      "hi": "0.9735908990591254",
      "hu": "0.9852896326109372"
    },
    "canonical_solution": "var n int\n\tfor _, ch := range x {\n\t\tdigit, _ := strconv.Atoi(string(ch))\n\t\tn += digit\n\t}\n\n\tfor n > 9 {\n\t\tt := n\n\t\ta := 0\n\t\tfor t > 0 {\n\t\t\ta += t % 10\n\t\t\tt /= 10\n\t\t}\n\t\tn = a\n\t}\n\treturn n\n}",
    "instruction": {
      "en": "Write a Go function `func classifyInteger(x string) int` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n",
      "sq": "Shkruani një funksion Go `func classifyInteger(x string) int` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri, dhe iteroni derisa klasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një string.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nShembuj:\n    classifyInteger(\"24\") // kthen 6",
      "hy": "Գրեք Go ֆունկցիա `func classifyInteger(x string) int` հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (string): Ամբողջ թիվը, որը պետք է դասակարգվի որպես տող:\n\nՎերադարձնում է:\nint: Դասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակներ:\n    classifyInteger(\"24\") // վերադարձնում է 6",
      "bn": "Go ফাংশন `func classifyInteger(x string) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি একক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (string): পূর্ণসংখ্যাটি একটি স্ট্রিং হিসাবে শ্রেণীবদ্ধ করতে হবে।\n\nরিটার্ন:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\nউদাহরণ:\n    classifyInteger(\"24\") // 6 রিটার্ন করে",
      "bg": "Напишете Go функция `func classifyInteger(x string) int`, за да решите следния проблем:\nКласифицирайте целочисленото x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и повтаряйте, докато класът бъде определен.\n\nПараметри:\n- x (string): Целочисленото число, което трябва да бъде класифицирано като низ.\n\nВръща:\nint: Класът, към който принадлежи целочисленото x.\n\nПримери:\n    classifyInteger(\"24\") // връща 6",
      "zh": "编写一个 Go 函数 `func classifyInteger(x string) int` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是个位数，则 x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类别。\n\n示例：\n    classifyInteger(\"24\") // returns 6",
      "fr": "Écrire une fonction Go `func classifyInteger(x string) int` pour résoudre le problème suivant :\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string) : L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nExemples :\n    classifyInteger(\"24\") // returns 6",
      "de": "Schreiben Sie eine Go-Funktion `func classifyInteger(x string) int`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als String zu klassifizierende ganze Zahl.\n\nRückgabewert:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\n    classifyInteger(\"24\") // returns 6",
      "ha": "Rubuta wani aikin Go `func classifyInteger(x string) int` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai lamba daya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nSigogi:\n- x (string): Lambar da za a rarraba a matsayin rubutu.\n\nYana dawowa:\nint: Ajin da lambar x take ciki.\n\nMisalai:\n    classifyInteger(\"24\") // returns 6",
      "hi": "Go फ़ंक्शन `func classifyInteger(x string) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक अंक की संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि वर्ग निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): पूर्णांक जिसे एक स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nवापसी:\nint: वह वर्ग जिसमें पूर्णांक x संबंधित है।\n\nउदाहरण:\n    classifyInteger(\"24\") // returns 6",
      "hu": "Írj egy Go függvényt `func classifyInteger(x string) int` a következő probléma megoldására:\nOsztályozd az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEllenkező esetben add össze x számjegyeit, kapj egy új x-et, és iterálj, amíg az osztály meghatározásra kerül.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám sztringként.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nPéldák:\n    classifyInteger(\"24\") // returns 6"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9838561171510084",
      "bn": "0.9694595857639807",
      "bg": "0.9861008390870837",
      "zh": "0.9612730346096279",
      "fr": "0.9757144564627694",
      "de": "0.9824144578454572",
      "ha": "0.9496861299623387",
      "hi": "0.9725635827284129",
      "hu": "0.9973798666437688"
    },
    "level": "easy",
    "test": "func TestClassifyInteger(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, classifyInteger(\"24\"))\n\tassert.Equal(3, classifyInteger(\"39\"))\n\tassert.Equal(9, classifyInteger(\"123456789\"))\n\tassert.Equal(9, classifyInteger(\"123456789012345678901234567890\"))\n\tassert.Equal(6, classifyInteger(\"12345\"))\n\tassert.Equal(9, classifyInteger(\"999999999\"))\n}",
    "entry_point": "classifyInteger",
    "signature": "func classifyInteger(x string) int",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The integer to be classified as a string.\n\nReturns:\nint: The class to which the integer x belongs.\n\nExamples:\n    classifyInteger(\"24\") // returns 6\n",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (string): Numri i plotë që do të klasifikohet si një varg.\n\nKthen:\nint: Klasa në të cilën i përket numri i plotë x.\n\nShembuj:\n    classifyInteger(\"24\") // kthen 6",
      "hy": "Դասակարգեք ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։  \nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի։  \n\nՊարամետրեր:  \n- x (string): Թիվը, որը պետք է դասակարգվի որպես տող։  \n\nՎերադարձնում է:  \nint: Դասը, որին պատկանում է թիվ x-ը։  \n\nՕրինակներ:  \n    classifyInteger(\"24\") // վերադարձնում է 6  ",
      "bn": "নিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজের শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nParameters:\n- x (string): যেটি একটি স্ট্রিং হিসেবে শ্রেণীবদ্ধ করা হবে এমন পূর্ণসংখ্যা।\n\nReturns:\nint: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n\nExamples:\n    classifyInteger(\"24\") // 6 রিটার্ন করে",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:  \nАко x е едноцифрено число, x принадлежи на своя собствен клас.  \nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:  \n- x (string): Цялото число, което трябва да бъде класифицирано като низ.\n\nВръща:  \nint: Класът, към който принадлежи цялото число x.\n\nПримери:  \n    classifyInteger(\"24\") // връща 6",
      "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一位数，x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数，作为字符串。\n\n返回：\nint: 整数 x 所属的类别。\n\n示例：\n    classifyInteger(\"24\") // 返回 6",
      "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string): L'entier à classer sous forme de chaîne.\n\nRenvoie :\nint: La classe à laquelle appartient l'entier x.\n\nExemples :\n    classifyInteger(\"24\") // renvoie 6",
      "de": "Classifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und wiederholen den Vorgang, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die als Zeichenfolge zu klassifizierende ganze Zahl.\n\nRückgabewerte:\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nBeispiele:\n    classifyInteger(\"24\") // gibt 6 zurück",
      "ha": "Rarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai ɗigo ɗaya, x na cikin ajin sa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma ci gaba da maimaitawa har sai an tantance ajin.\n\nParameters:\n- x (string): Lambar da za a tantance a matsayin kirtani.\n\nReturns:\nint: Aji wanda lambar x take ciki.\n\nExamples:\n    classifyInteger(\"24\") // returns 6",
      "hi": "पूरे x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एक एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nParameters:\n- x (string): उस पूर्णांक को एक स्ट्रिंग के रूप में वर्गीकृत किया जाना है।\n\nReturns:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nExamples:\n    classifyInteger(\"24\") // returns 6",
      "hu": "Az egész szám x osztályozása a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összeadjuk x számjegyeit, kapunk egy új x-et, és iterálunk, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám, mint string.\n\nVisszatér:\nint: Az osztály, amelyhez az egész szám x tartozik.\n\nPéldák:\n    classifyInteger(\"24\") // visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9882448554199743",
      "hy": "0.9810562232999407",
      "bn": "0.9538232035385333",
      "bg": "0.998315217108062",
      "zh": "0.9343554398933039",
      "fr": "0.9814475251505794",
      "de": "0.9773261433744865",
      "ha": "0.9645734770209036",
      "hi": "0.9561348639130174",
      "hu": "0.9593415527844446"
    }
  },
  {
    "task_id": "Go/27",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transformon shkronjën e dhënë.\n\nParametrat:\n- letter (rune): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- rune: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\n  dhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n\nShembuj:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase փոխակերպում է տրված տառի ռեգիստրը։\n\nՊարամետրեր:\n- letter (rune): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- rune: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n  և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\n\t- TransformLetterCase('b') վերադարձնում է 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nপ্যারামিটার:\n- letter (rune): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nরিটার্ন:\n- rune: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n  এবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nউদাহরণ:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase променя регистъра на дадена буква.\n\nПараметри:\n- letter (rune): Входната буква, която ще бъде трансформирана.\n\nВръща:\n- rune: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\n  и ако входът е с главни букви, връща версията с малки букви.\n\nПримери:\n\t- TransformLetterCase('b') връща 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase 转换给定字母的大小写。\n\n参数:\n- letter (rune): 要转换的输入字母。\n\n返回:\n- rune: 大小写反转的字母。如果输入是小写字母，则返回大写版本，\n  如果输入是大写字母，则返回小写版本。\n\n示例:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase transforme la casse d'une lettre donnée.\n\nParamètres :\n- letter (rune) : La lettre d'entrée à transformer.\n\nRenvoie :\n- rune : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\n  et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples :\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase wandelt den Fall eines gegebenen Buchstabens um.\n\nParameter:\n- letter (rune): Der Eingabebuchstabe, der umgewandelt werden soll.\n\nRückgabewerte:\n- rune: Der Buchstabe mit umgekehrtem Fall. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben,\n  und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase yana sauya yanayin harafin da aka bayar.\n\nSigogi:\n- letter (rune): Harafin shigarwa da za a sauya.\n\nYana dawowa:\n- rune: Harafin da aka juya yanayinsa. Idan shigarwar tana cikin ƙananan haruffa, yana dawowa da babba,\n  kuma idan shigarwar tana cikin manyan haruffa, yana dawowa da ƙananan haruffa.\n\nMisalai:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase एक दिए गए अक्षर के केस को बदलता है।\n\nपैरामीटर्स:\n- letter (rune): इनपुट अक्षर जिसे बदला जाना है।\n\nवापसी:\n- rune: अक्षर जिसका केस उलट गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\n  और यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n\nउदाहरण:\n\t- TransformLetterCase('b') returns 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nTransformLetterCase átalakítja egy adott betű esetét.\n\nParaméterek:\n- letter (rune): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- rune: A betű az esetének megfordításával. Ha a bemenet kisbetűs, akkor nagybetűs változatát adja vissza,\n  és ha a bemenet nagybetűs, akkor kisbetűs változatát adja vissza.\n\nPéldák:\n\t- TransformLetterCase('b') visszaadja 'B'\n*/\nfunc TransformLetterCase(letter rune) rune {"
    },
    "prompt_bertscore": {
      "sq": "0.9875232312456745",
      "hy": "0.9778249042612651",
      "bn": "0.9616679118071252",
      "bg": "0.9879677660384306",
      "zh": "0.9793853445346752",
      "fr": "0.9889917056526655",
      "de": "0.9733527412322646",
      "ha": "0.9675050628145975",
      "hi": "0.9720993835279345",
      "hu": "0.9976360998353038"
    },
    "canonical_solution": "if letter >= 'A' && letter <= 'Z' {\n\t\treturn letter + 'a' - 'A'\n\t} else if letter >= 'a' && letter <= 'z' {\n\t\treturn letter + 'A' - 'a'\n\t}\n\t// Non-alphabetic characters are returned unchanged\n\treturn letter\n}",
    "instruction": {
      "en": "Write a Go function `func TransformLetterCase(letter rune) rune` to solve the following problem:\nTransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "sq": "Shkruani një funksion Go `func TransformLetterCase(letter rune) rune` për të zgjidhur problemin e mëposhtëm:\nTransformLetterCase transformon shkronjën e dhënë në rastin tjetër.\n\nParametrat:\n- letter (rune): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- rune: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\n  dhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n\nShembuj:\n\t- TransformLetterCase('b') kthen 'B'",
      "hy": "Գրեք Go ֆունկցիա `func TransformLetterCase(letter rune) rune` հետևյալ խնդիրը լուծելու համար:\nTransformLetterCase-ը փոխակերպում է տրված տառի գրությունը։\n\nՊարամետրեր:\n- letter (rune): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- rune: Տառը իր գրությունը փոխված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n  իսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\n\t- TransformLetterCase('b') վերադարձնում է 'B'",
      "bn": "একটি Go ফাংশন `func TransformLetterCase(letter rune) rune` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nTransformLetterCase একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nপ্যারামিটারসমূহ:\n- letter (rune): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nফেরত দেয়:\n- rune: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n  এবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nউদাহরণ:\n\t- TransformLetterCase('b') 'B' ফেরত দেয়।",
      "bg": "Напишете Go функция `func TransformLetterCase(letter rune) rune`, за да решите следния проблем:\nTransformLetterCase преобразува регистъра на дадена буква.\n\nПараметри:\n- letter (rune): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- rune: Буквата с обърнат регистър. Ако входът е малка буква, връща главната версия,\n  и ако входът е главна буква, връща малката версия.\n\nПримери:\n\t- TransformLetterCase('b') връща 'B'",
      "zh": "编写一个 Go 函数 `func TransformLetterCase(letter rune) rune` 来解决以下问题：\nTransformLetterCase 转换给定字母的大小写。\n\n参数：\n- letter (rune): 要转换的输入字母。\n\n返回：\n- rune: 大小写已反转的字母。如果输入是小写，则返回大写版本，\n  如果输入是大写，则返回小写版本。\n\n示例：\n\t- TransformLetterCase('b') 返回 'B'",
      "fr": "Écrire une fonction Go `func TransformLetterCase(letter rune) rune` pour résoudre le problème suivant :\nTransformLetterCase transforme la casse d'une lettre donnée.\n\nParamètres :\n- letter (rune) : La lettre d'entrée à transformer.\n\nRenvoie :\n- rune : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\n  et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples :\n\t- TransformLetterCase('b') renvoie 'B'",
      "de": "Schreiben Sie eine Go-Funktion `func TransformLetterCase(letter rune) rune`, um das folgende Problem zu lösen:  \nTransformLetterCase wandelt den Fall eines gegebenen Buchstabens um.\n\nParameter:\n- letter (rune): Der zu transformierende Eingabebuchstabe.\n\nRückgabewert:\n- rune: Der Buchstabe mit umgekehrtem Fall. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\n\t- TransformLetterCase('b') gibt 'B' zurück.",
      "ha": "Rubuta aikin Go `func TransformLetterCase(letter rune) rune` don warware matsalar mai zuwa:\nTransformLetterCase yana sauya yanayin harafin da aka bayar.\n\nSigogi:\n- letter (rune): Harafin shigar da za a sauya.\n\nDawowa:\n- rune: Harafin tare da yanayinsa da aka juya. Idan shigarwa yana cikin ƙananan haruffa, yana dawo da sigar manyan haruffa,\n  kuma idan shigarwa yana cikin manyan haruffa, yana dawo da sigar ƙananan haruffa.\n\nMisalai:\n\t- TransformLetterCase('b') yana dawowa 'B'",
      "hi": "Go फ़ंक्शन `func TransformLetterCase(letter rune) rune` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nTransformLetterCase दिए गए अक्षर के केस को बदलता है।\n\nपैरामीटर्स:\n- letter (rune): वह इनपुट अक्षर जिसे बदला जाना है।\n\nवापसी:\n- rune: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है,\n  और यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n\nउदाहरण:\n\t- TransformLetterCase('b') 'B' लौटाता है।",
      "hu": "Írj egy Go függvényt `func TransformLetterCase(letter rune) rune` a következő probléma megoldására:\nTransformLetterCase átalakítja a megadott betű esetét.\n\nParaméterek:\n- letter (rune): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- rune: A betű az esetének megfordításával. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza,\n  és ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n\nPéldák:\n\t- TransformLetterCase('b') visszaadja 'B'"
    },
    "instruction_bertscore": {
      "sq": "0.9846629537587721",
      "hy": "0.9761291966983703",
      "bn": "0.958335887165265",
      "bg": "0.9729477338853344",
      "zh": "0.9683899611621078",
      "fr": "0.984627597550948",
      "de": "0.9601406428073479",
      "ha": "0.9763155119957809",
      "hi": "0.9693272979302116",
      "hu": "0.9891792127323624"
    },
    "level": "easy",
    "test": "func TestTransformLetterCase(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(rune('B'), TransformLetterCase('b'), \"Lowercase 'b' should transform to uppercase 'B'\")\n\tassert.Equal(rune('b'), TransformLetterCase('B'), \"Uppercase 'B' should transform to lowercase 'b'\")\n\n\t// Additional test cases\n\tassert.Equal(rune('Z'), TransformLetterCase('z'), \"Lowercase 'z' should transform to uppercase 'Z'\")\n\tassert.Equal(rune('z'), TransformLetterCase('Z'), \"Uppercase 'Z' should transform to lowercase 'z'\")\n\tassert.Equal(rune('M'), TransformLetterCase('m'), \"Lowercase 'm' should transform to uppercase 'M'\")\n\tassert.Equal(rune('m'), TransformLetterCase('M'), \"Uppercase 'M' should transform to lowercase 'm'\")\n\tassert.Equal(rune('1'), TransformLetterCase('1'), \"Non-alphabetic '1' should remain unchanged\")\n\tassert.Equal(rune('!'), TransformLetterCase('!'), \"Non-alphabetic '!' should remain unchanged\")\n}",
    "entry_point": "TransformLetterCase",
    "signature": "func TransformLetterCase(letter rune) rune",
    "docstring": {
      "en": "TransformLetterCase transforms the case of a given letter.\n\nParameters:\n- letter (rune): The input letter to be transformed.\n\nReturns:\n- rune: The letter with its case reversed. If the input is lowercase, it returns the uppercase version,\n  and if the input is uppercase, it returns the lowercase version.\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "sq": "TransformLetterCase transformon shkronjën e dhënë në një rast tjetër.\n\nParametrat:\n- letter (rune): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- rune: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha,\n  dhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n\nShembuj:\n\t- TransformLetterCase('b') kthen 'B'",
      "hy": "TransformLetterCase-ը փոխակերպում է տրված տառի գրությունը։\n\nՊարամետրեր:\n- letter (rune): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- rune: Տառը՝ հակառակ գրությամբ։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n  և եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\n\t- TransformLetterCase('b') վերադարձնում է 'B'",
      "bn": "TransformLetterCase একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nParameters:\n- letter (rune): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nReturns:\n- rune: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুটটি ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n  এবং যদি ইনপুটটি বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "bg": "TransformLetterCase трансформира регистъра на дадена буква.\n\nПараметри:\n- letter (rune): Входната буква, която ще бъде трансформирана.\n\nВръща:\n- rune: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви,\n  и ако входът е с главни букви, връща версията с малки букви.\n\nПримери:\n\t- TransformLetterCase('b') връща 'B'",
      "zh": "TransformLetterCase 转换给定字母的大小写。\n\n参数：\n- letter (rune): 要转换的输入字母。\n\n返回：\n- rune: 大小写已反转的字母。如果输入是小写，则返回大写版本；如果输入是大写，则返回小写版本。\n\n示例：\n\t- TransformLetterCase('b') 返回 'B'",
      "fr": "TransformLetterCase transforme la casse d'une lettre donnée.\n\nParamètres :\n- letter (rune) : La lettre d'entrée à transformer.\n\nRenvoie :\n- rune : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule,\n  et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples :\n\t- TransformLetterCase('b') renvoie 'B'",
      "de": "TransformLetterCase verwandelt die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nParameter:\n- letter (rune): Der Eingabebuchstabe, der umgewandelt werden soll.\n\nRückgabewerte:\n- rune: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\n\t- TransformLetterCase('b') gibt 'B' zurück.",
      "ha": "TransformLetterCase yana sauya yanayin harafin da aka bayar.\n\nSigogi:\n- letter (rune): Harafin shigarwa da za a sauya.\n\nDawowa:\n- rune: Harafin tare da yanayinsa da aka juya. Idan shigarwar harafi ne ƙaramin, zai dawo da babbar sigar,\n  kuma idan shigarwar babba ce, zai dawo da ƙaramin sigar.\n\nMisalai:\n\t- TransformLetterCase('b') yana dawowa 'B'",
      "hi": "TransformLetterCase एक दिए गए अक्षर के केस को बदलता है।\n\nParameters:\n- letter (rune): इनपुट अक्षर जिसे बदला जाना है।\n\nReturns:\n- rune: अक्षर जिसके केस को उलट दिया गया है। यदि इनपुट लोअरकेस में है, तो यह अपरकेस संस्करण लौटाता है,\n  और यदि इनपुट अपरकेस में है, तो यह लोअरकेस संस्करण लौटाता है।\n\nExamples:\n\t- TransformLetterCase('b') returns 'B'",
      "hu": "TransformLetterCase átalakítja egy adott betű kis- vagy nagybetűs formáját.\n\nParaméterek:\n- letter (rune): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- rune: A betű, amelynek kis- vagy nagybetűs formája megfordult. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza, és ha a bemenet nagybetűs, akkor a kisbetűs változatot.\n\nPéldák:\n\t- TransformLetterCase('b') visszaadja 'B'"
    },
    "docstring_bertscore": {
      "sq": "0.9845040494539442",
      "hy": "0.9721752603334898",
      "bn": "0.9507025216220942",
      "bg": "0.9829261297070031",
      "zh": "0.9630503792591281",
      "fr": "0.9850445227207402",
      "de": "0.9716532596921301",
      "ha": "0.9845674125454944",
      "hi": "0.9583724351553754",
      "hu": "0.9410216741112158"
    }
  },
  {
    "task_id": "Go/28",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo kthen kodin ASCII për një karakter të dhënë.\n\nParametrat:\n- character: Karakteri hyrës për të cilin informacioni ASCII duhet të shfaqet.\n\nKthen:\n- Kodi përkatës ASCII.\n\nShembuj:\n\tDisplayASCIIInfo('A') // kthen 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo ֆունկցիան վերադարձնում է տրված սիմվոլի ASCII կոդը։\n\nՊարամետրեր:\n- character: Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\nՎերադարձնում է:\n- Համապատասխանող ASCII կոդը։\n\nՕրինակներ:\n\tDisplayASCIIInfo('A') // վերադարձնում է 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo নির্দিষ্ট অক্ষরের জন্য ASCII কোড প্রদান করে।\n\nপ্যারামিটার:\n- character: ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nরিটার্নস:\n- সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo връща ASCII кода за даден символ.\n\nПараметри:\n- character: Входният символ, за който трябва да се покаже ASCII информацията.\n\nВръща:\n- Съответния ASCII код.\n\nПримери:\n\tDisplayASCIIInfo('A') // връща 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo 返回给定字符的 ASCII 码。\n\n参数:\n- character: 要显示 ASCII 信息的输入字符。\n\n返回:\n- 对应的 ASCII 码。\n\n示例:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo retourne le code ASCII pour un caractère donné.\n\nParamètres :\n- character : Le caractère d'entrée pour lequel l'information ASCII doit être affichée.\n\nRetourne :\n- Le code ASCII correspondant.\n\nExemples :\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo gibt den ASCII-Code für ein gegebenes Zeichen zurück.\n\nParameter:\n- character: Das Eingabezeichen, für das die ASCII-Information angezeigt werden soll.\n\nRückgabewerte:\n- Der entsprechende ASCII-Code.\n\nBeispiele:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo yana dawo da lambar ASCII don wata alama da aka bayar.\n\nSigogi:\n- character: Alamar shigarwa wanda za a nuna bayanin ASCII.\n\nDawowa:\n- Lambar ASCII mai dacewa.\n\nMisalai:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo दिए गए वर्ण के लिए ASCII कोड लौटाता है।\n\nपैरामीटर्स:\n- character: इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n- संबंधित ASCII कोड।\n\nउदाहरण:\n\tDisplayASCIIInfo('A') // returns 65\n*/\nfunc DisplayASCIIInfo(character rune) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDisplayASCIIInfo visszaadja a megadott karakter ASCII kódját.\n\nParaméterek:\n- character: Az a bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n\nVisszatér:\n- A megfelelő ASCII kód.\n\nPéldák:\n\tDisplayASCIIInfo('A') // visszaadja a 65-öt\n*/\nfunc DisplayASCIIInfo(character rune) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9879461153268978",
      "hy": "0.968384796772201",
      "bn": "0.9643758397917739",
      "bg": "0.9835611510351716",
      "zh": "0.9777063219237873",
      "fr": "0.9864909491554362",
      "de": "0.9798978109177452",
      "ha": "0.9877744986776836",
      "hi": "0.9800154001033178",
      "hu": "0.9777428699138977"
    },
    "canonical_solution": "return int(character)\n}",
    "instruction": {
      "en": "Write a Go function `func DisplayASCIIInfo(character rune) int` to solve the following problem:\nDisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n",
      "sq": "Shkruani një funksion në Go `func DisplayASCIIInfo(character rune) int` për të zgjidhur problemin në vijim:  \nDisplayASCIIInfo kthen kodin ASCII për një karakter të dhënë.\n\nParametrat:  \n- character: Karakteri i hyrjes për të cilin informacioni ASCII duhet të shfaqet.\n\nKthen:  \n- Kodi përkatës ASCII.\n\nShembuj:  \n\tDisplayASCIIInfo('A') // kthen 65",
      "hy": "Գրեք Go ֆունկցիա `func DisplayASCIIInfo(character rune) int` հետևյալ խնդիրը լուծելու համար:\nDisplayASCIIInfo վերադարձնում է տրված սիմվոլի ASCII կոդը։\n\nՊարամետրեր:\n- character: Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\nՎերադարձնում է:\n- Համապատասխան ASCII կոդը։\n\nՕրինակներ:\n\tDisplayASCIIInfo('A') // վերադարձնում է 65",
      "bn": "একটি Go ফাংশন `func DisplayASCIIInfo(character rune) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nDisplayASCIIInfo একটি প্রদত্ত অক্ষরের জন্য ASCII কোড প্রদান করে।\n\nপ্যারামিটার:\n- character: ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nফেরত দেয়:\n- সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n\tDisplayASCIIInfo('A') // returns 65",
      "bg": "Напишете Go функция `func DisplayASCIIInfo(character rune) int`, за да решите следния проблем:  \nDisplayASCIIInfo връща ASCII кода за даден символ.\n\nПараметри:\n- character: Входният символ, за който трябва да се покаже ASCII информация.\n\nВръща:\n- Съответният ASCII код.\n\nПримери:\n\tDisplayASCIIInfo('A') // връща 65",
      "zh": "编写一个 Go 函数 `func DisplayASCIIInfo(character rune) int` 来解决以下问题：\n\nDisplayASCIIInfo 返回给定字符的 ASCII 码。\n\n参数：\n- character: 要显示其 ASCII 信息的输入字符。\n\n返回：\n- 对应的 ASCII 码。\n\n示例：\n\tDisplayASCIIInfo('A') // 返回 65",
      "fr": "Écrire une fonction Go `func DisplayASCIIInfo(character rune) int` pour résoudre le problème suivant :  \nDisplayASCIIInfo retourne le code ASCII pour un caractère donné.\n\nParamètres :  \n- character : Le caractère d'entrée pour lequel l'information ASCII doit être affichée.\n\nRetourne :  \n- Le code ASCII correspondant.\n\nExemples :  \n\tDisplayASCIIInfo('A') // retourne 65",
      "de": "Schreiben Sie eine Go-Funktion `func DisplayASCIIInfo(character rune) int`, um das folgende Problem zu lösen:  \nDisplayASCIIInfo gibt den ASCII-Code für ein gegebenes Zeichen zurück.\n\nParameter:\n- character: Das Eingabezeichen, für das die ASCII-Information angezeigt werden soll.\n\nRückgabewerte:\n- Der entsprechende ASCII-Code.\n\nBeispiele:\n\tDisplayASCIIInfo('A') // gibt 65 zurück",
      "ha": "Rubuta aikin Go `func DisplayASCIIInfo(character rune) int` don warware matsalar mai zuwa:\nDisplayASCIIInfo yana dawowa da lambar ASCII don wata alama da aka bayar.\n\nSigogi:\n- character: Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n\nDawowa:\n- Lambar ASCII da ta dace.\n\nMisalai:\n\tDisplayASCIIInfo('A') // returns 65",
      "hi": "Go फ़ंक्शन `func DisplayASCIIInfo(character rune) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nDisplayASCIIInfo दिए गए वर्ण के लिए ASCII कोड लौटाता है।\n\nपैरामीटर्स:\n- character: वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n- संबंधित ASCII कोड।\n\nउदाहरण:\n\tDisplayASCIIInfo('A') // returns 65",
      "hu": "Írj egy Go függvényt `func DisplayASCIIInfo(character rune) int` a következő probléma megoldására:\nDisplayASCIIInfo visszaadja a megadott karakter ASCII kódját.\n\nParaméterek:\n- character: Az a bemeneti karakter, amelynek az ASCII információját kell megjeleníteni.\n\nVisszatér:\n- A megfelelő ASCII kód.\n\nPéldák:\n\tDisplayASCIIInfo('A') // visszaadja 65"
    },
    "instruction_bertscore": {
      "sq": "0.9800706193492456",
      "hy": "0.9778328494765065",
      "bn": "0.9639678529891281",
      "bg": "0.9873069227607275",
      "zh": "0.9744757974066358",
      "fr": "0.9845233166009046",
      "de": "0.9787825013282343",
      "ha": "0.9752661476927736",
      "hi": "0.9867700248407902",
      "hu": "0.9738501117063759"
    },
    "level": "easy",
    "test": "func TestDisplayASCIIInfo(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(65, DisplayASCIIInfo('A'), \"ASCII value for 'A' should be 65\")\n\tassert.Equal(66, DisplayASCIIInfo('B'), \"ASCII value for 'B' should be 66\") // Additional test case\n\tassert.Equal(48, DisplayASCIIInfo('0'), \"ASCII value for '0' should be 48\") // Additional test case\n\tassert.Equal(32, DisplayASCIIInfo(' '), \"ASCII value for ' ' should be 32\") // Additional test case\n}",
    "entry_point": "DisplayASCIIInfo",
    "signature": "func DisplayASCIIInfo(character rune) int",
    "docstring": {
      "en": "DisplayASCIIInfo returns ASCII code for a given character.\n\nParameters:\n- character: The input character for which ASCII information is to be displayed.\n\nReturns:\n- The corresponding ASCII code.\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65\n",
      "sq": "DisplayASCIIInfo kthen kodin ASCII për një karakter të dhënë.\n\nParametrat:\n- character: Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n\nKthen:\n- Kodi përkatës ASCII.\n\nShembuj:\n\tDisplayASCIIInfo('A') // kthen 65",
      "hy": "DisplayASCIIInfo վերադարձնում է ASCII կոդը տրված սիմվոլի համար:\n\nՊարամետրեր:\n- character: Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\nՎերադարձնում է:\n- Համապատասխան ASCII կոդը:\n\nՕրինակներ:\n\tDisplayASCIIInfo('A') // վերադարձնում է 65",
      "bn": "DisplayASCIIInfo একটি প্রদত্ত অক্ষরের জন্য ASCII কোড প্রদান করে।\n\nParameters:\n- character: ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শিত হবে।\n\nReturns:\n- সংশ্লিষ্ট ASCII কোড।\n\nExamples:\n\tDisplayASCIIInfo('A') // 65 প্রদান করে",
      "bg": "DisplayASCIIInfo връща ASCII код за даден символ.\n\nПараметри:\n- character: Входният символ, за който ще се покаже ASCII информация.\n\nВръща:\n- Съответният ASCII код.\n\nПримери:\n\tDisplayASCIIInfo('A') // връща 65",
      "zh": "DisplayASCIIInfo 返回给定字符的 ASCII 码。\n\n参数:\n- character: 要显示其 ASCII 信息的输入字符。\n\n返回:\n- 对应的 ASCII 码。\n\n示例:\n\tDisplayASCIIInfo('A') // 返回 65",
      "fr": "DisplayASCIIInfo renvoie le code ASCII pour un caractère donné.\n\nParamètres:\n- character: Le caractère d'entrée pour lequel l'information ASCII doit être affichée.\n\nRenvoie:\n- Le code ASCII correspondant.\n\nExemples:\n\tDisplayASCIIInfo('A') // renvoie 65",
      "de": "DisplayASCIIInfo gibt den ASCII-Code für ein gegebenes Zeichen zurück.\n\nParameter:\n- character: Das Eingabezeichen, für das die ASCII-Information angezeigt werden soll.\n\nRückgabewert:\n- Der entsprechende ASCII-Code.\n\nBeispiele:\n\tDisplayASCIIInfo('A') // gibt 65 zurück",
      "ha": "DisplayASCIIInfo yana mayar da lambar ASCII don wata alama da aka bayar.\n\nSigogi:\n- character: Harafin shigarwa wanda za a nuna bayanin ASCII ɗinsa.\n\nDawowa:\n- Lambar ASCII da ta dace.\n\nMisalai:\n\tDisplayASCIIInfo('A') // yana mayar da 65",
      "hi": "DisplayASCIIInfo दिए गए वर्ण के लिए ASCII कोड लौटाता है।\n\nParameters:\n- character: वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nReturns:\n- संबंधित ASCII कोड।\n\nExamples:\n\tDisplayASCIIInfo('A') // returns 65",
      "hu": "DisplayASCIIInfo visszaadja az ASCII kódot egy adott karakterhez.\n\nParaméterek:\n- character: Az a bemeneti karakter, amelyhez az ASCII információt meg kell jeleníteni.\n\nVisszatér:\n- A megfelelő ASCII kód.\n\nPéldák:\n\tDisplayASCIIInfo('A') // visszaadja a 65-öt"
    },
    "docstring_bertscore": {
      "sq": "0.9725689457487009",
      "hy": "0.9714842252378694",
      "bn": "0.9628708173946725",
      "bg": "0.9813976689249396",
      "zh": "0.9460605296173089",
      "fr": "0.9709455396445028",
      "de": "0.9619801587661121",
      "ha": "0.9725689457487009",
      "hi": "0.9726364800782528",
      "hu": "0.9740902558370471"
    }
  },
  {
    "task_id": "Go/29",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\t Example:\n\t\tevaluateIntegerGrade(90) // Returns 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVlerësoni notën për një numër të plotë hyrës.\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n\t Shembull:\n\t\tevaluateIntegerGrade(90) // Kthen 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԳնահատել գնահատականը մուտքային ամբողջ թվի համար։\nՊարամետրեր:\n- score (int): Գնահատման ենթակա ամբողջ թիվը։\nՎերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխանող գնահատականը։\n         Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n         Հակառակ դեպքում, վերադարձնում է 'B'։\n\t Օրինակ:\n\t\tevaluateIntegerGrade(90) // Վերադարձնում է 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\nপ্যারামিটার:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\nরিটার্নস:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n         যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তাহলে 'A' রিটার্ন করে।\n         অন্যথায়, 'B' রিটার্ন করে।\n\t উদাহরণ:\n\t\tevaluateIntegerGrade(90) // Returns 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОценете оценката за входно цяло число.\nПараметри:\n- score (int): Цялочислената оценка, която трябва да бъде оценена.\nВръща:\n    char: Оценката, съответстваща на входната оценка.\n         Ако оценката е между 90 и 100 (включително), връща 'A'.\n         В противен случай връща 'B'.\n\t Пример:\n\t\tevaluateIntegerGrade(90) // Връща 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n评估输入整数的等级。\n参数:\n- score (int): 要评估的整数分数。\n返回:\n    char: 与输入分数对应的等级。\n         如果分数在90到100之间（包括90和100），返回 'A'。\n         否则，返回 'B'。\n\t 示例:\n\t\tevaluateIntegerGrade(90) // 返回 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉvaluer la note pour un entier en entrée.\nParamètres :\n- score (int) : Le score entier à évaluer.\nRenvoie :\n    char : La note correspondant au score d'entrée.\n         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n         Sinon, renvoie 'B'.\n\t Exemple :\n\t\tevaluateIntegerGrade(90) // Renvoie 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBewerten Sie die Note für eine Eingabezahl.\nParameter:\n- score (int): Die zu bewertende Ganzzahl.\nRückgabe:\n    char: Die Note, die der Eingabepunktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n\t Beispiel:\n\t\tevaluateIntegerGrade(90) // Gibt 'A' zurück\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKimanta darajar don wani cikakken lamba.\nSigogi:\n- score (int): Cikakken lambar da za a kimanta.\nAbubuwan da ake dawowa da su:\n    char: Darajar da ta dace da cikakken lambar da aka shigar.\n         Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa da 'A'.\n         In ba haka ba, yana dawowa da 'B'.\n\t Misali:\n\t\tevaluateIntegerGrade(90) // Yana dawowa da 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nइनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n\t उदाहरण:\n\t\tevaluateIntegerGrade(90) // 'A' लौटाता है\n*/\nfunc evaluateIntegerGrade(score int) rune {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉrtékelje ki a bemeneti egész szám osztályzatát.\nParaméterek:\n- score (int): Az értékelendő egész szám.\nVisszatér:\n    char: Az osztályzat, amely megfelel a bemeneti pontszámnak.\n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n         Egyébként 'B'-t ad vissza.\n\t Példa:\n\t\tevaluateIntegerGrade(90) // Visszatér 'A'\n*/\nfunc evaluateIntegerGrade(score int) rune {"
    },
    "prompt_bertscore": {
      "sq": "0.9851619132759318",
      "hy": "0.9885761708955405",
      "bn": "0.989672411968472",
      "bg": "0.9869555456166769",
      "zh": "0.9741331599993507",
      "fr": "0.9924043742292259",
      "de": "0.9740415913936936",
      "ha": "0.9782535486235384",
      "hi": "0.9760872856879719",
      "hu": "0.9885072461533214"
    },
    "canonical_solution": "if 90 <= score && score <= 100 {\n\t\treturn 'A'\n\t}\n\treturn 'B'\n}",
    "instruction": {
      "en": "Write a Go function `func evaluateIntegerGrade(score int) rune` to solve the following problem:\nEvaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n     Example:\n        evaluateIntegerGrade(90) // Returns 'A'",
      "sq": "Shkruani një funksion Go `func evaluateIntegerGrade(score int) rune` për të zgjidhur problemin e mëposhtëm:\nVlerësoni notën për një numër të plotë hyrës.\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n     Shembull:\n        evaluateIntegerGrade(90) // Kthen 'A'",
      "hy": "Գրեք Go ֆունկցիա `func evaluateIntegerGrade(score int) rune` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվի գնահատականը:\nՊարամետրեր:\n- score (int): Գնահատվող ամբողջ թվային գնահատականը։\nՎերադարձնում է:\n    char: Մուտքային գնահատականին համապատասխան գնահատականը։\n         Եթե գնահատականը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A'։\n         Հակառակ դեպքում, վերադարձնում է 'B'։\n     Օրինակ:\n        evaluateIntegerGrade(90) // Վերադարձնում է 'A'",
      "bn": "একটি Go ফাংশন `func evaluateIntegerGrade(score int) rune` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।\nরিটার্নস:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n         যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তবে 'A' রিটার্ন করে।\n         অন্যথায়, 'B' রিটার্ন করে।\n     উদাহরণ:\n        evaluateIntegerGrade(90) // Returns 'A'",
      "bg": "Напишете Go функция `func evaluateIntegerGrade(score int) rune`, за да решите следния проблем:\nОценете оценката за входящо цяло число.\nПараметри:\n- score (int): Целочислената оценка, която трябва да бъде оценена.\nВръща:\n    char: Оценката, съответстваща на входящата оценка.\n         Ако оценката е между 90 и 100 (включително), връща 'A'.\n         В противен случай връща 'B'.\n     Пример:\n        evaluateIntegerGrade(90) // Връща 'A'",
      "zh": "编写一个 Go 函数 `func evaluateIntegerGrade(score int) rune` 来解决以下问题：\n评估输入整数的等级。\n参数：\n- score (int): 要评估的整数分数。\n返回：\n    char: 与输入分数对应的等级。\n         如果分数在 90 到 100 之间（包括 90 和 100），返回 'A'。\n         否则，返回 'B'。\n     示例：\n        evaluateIntegerGrade(90) // 返回 'A'",
      "fr": "Écrire une fonction Go `func evaluateIntegerGrade(score int) rune` pour résoudre le problème suivant :  \nÉvaluer la note pour un entier en entrée.  \nParamètres :  \n- score (int) : Le score entier à évaluer.  \nRenvoie :  \n    char : La note correspondant au score d'entrée.  \n         Si le score est entre 90 et 100 (inclus), renvoie 'A'.  \n         Sinon, renvoie 'B'.  \n     Exemple :  \n        evaluateIntegerGrade(90) // Renvoie 'A'  ",
      "de": "Schreiben Sie eine Go-Funktion `func evaluateIntegerGrade(score int) rune`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine eingegebene ganze Zahl.\nParameter:\n- score (int): Die zu bewertende ganze Zahl.\nRückgabe:\n    char: Die Note, die der eingegebenen Punktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n     Beispiel:\n        evaluateIntegerGrade(90) // Gibt 'A' zurück",
      "ha": "Rubuta aikin Go `func evaluateIntegerGrade(score int) rune` don warware matsalar mai zuwa:\nKimanta darajar wani shigarwar cikakken lamba.\nSigogi:\n- score (int): Cikakken lamban da za a kimanta.\nAna dawowa:\n    char: Darajar da ta dace da shigarwar lamban.\n         Idan lamban yana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n         In ba haka ba, yana dawowa 'B'.\n     Misali:\n        evaluateIntegerGrade(90) // Yana dawowa 'A'",
      "hi": "Go फ़ंक्शन `func evaluateIntegerGrade(score int) rune` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nइनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\nरिटर्न करता है:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n     उदाहरण:\n        evaluateIntegerGrade(90) // 'A' लौटाता है",
      "hu": "Írj egy Go függvényt `func evaluateIntegerGrade(score int) rune` a következő probléma megoldására:  \nÉrtékeld ki az osztályzatot egy bemeneti egész szám alapján.  \nParaméterek:  \n- score (int): Az értékelendő egész szám.  \nVisszatér:  \n    char: A bemeneti pontszámnak megfelelő osztályzat.  \n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.  \n         Egyébként 'B'-t ad vissza.  \n     Példa:  \n        evaluateIntegerGrade(90) // Visszaadja: 'A'  "
    },
    "instruction_bertscore": {
      "sq": "0.9936712387994664",
      "hy": "0.9724050756843471",
      "bn": "0.984838145754845",
      "bg": "0.9877566219433905",
      "zh": "0.9713263140849466",
      "fr": "0.9910463383140904",
      "de": "0.968584420305141",
      "ha": "0.973082008022914",
      "hi": "0.9645305728586",
      "hu": "0.9877752931992078"
    },
    "level": "easy",
    "test": "func TestEvaluateIntegerGrade(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal('A', evaluateIntegerGrade(90))\n\tassert.Equal('B', evaluateIntegerGrade(89))\n\tassert.Equal('A', evaluateIntegerGrade(95))\n\tassert.Equal('A', evaluateIntegerGrade(100))\n\tassert.Equal('B', evaluateIntegerGrade(101))\n}",
    "entry_point": "evaluateIntegerGrade",
    "signature": "func evaluateIntegerGrade(score int) rune",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\nParameters:\n- score (int): The integer score to be evaluated.\nReturns:\n    char: The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n     Example:\n        evaluateIntegerGrade(90) // Returns 'A'",
      "sq": "Vlerësoni notën për një numër të plotë hyrës.\nParametrat:\n- score (int): Nota e plotë që do të vlerësohet.\nKthen:\n    char: Nota që korrespondon me notën hyrëse.\n         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n     Shembull:\n        evaluateIntegerGrade(90) // Kthen 'A'",
      "hy": "Գնահատել մուտքային ամբողջ թվի գնահատականը։  \nՊարամետրեր:  \n- score (int): Գնահատվող ամբողջ թվային միավորը։  \nՎերադարձնում է:  \n    char: Մուտքային միավորին համապատասխան գնահատականը։  \n         Եթե միավորը 90-ից 100 է (ներառյալ), վերադարձնում է 'A':  \n         Հակառակ դեպքում, վերադարձնում է 'B':  \n     Օրինակ:  \n        evaluateIntegerGrade(90) // Վերադարձնում է 'A'  ",
      "bn": "ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\nপ্যারামিটারসমূহ:\n- score (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n\nফেরত দেয়:\n    char: ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n         যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তবে 'A' ফেরত দেয়।\n         অন্যথায়, 'B' ফেরত দেয়।\n     উদাহরণ:\n        evaluateIntegerGrade(90) // 'A' ফেরত দেয়।",
      "bg": "Оценете оценката за входящо цяло число.  \nПараметри:  \n- score (int): Цялочислената оценка, която трябва да бъде оценена.  \nВръща:  \n    char: Оценката, съответстваща на входящата оценка.  \n         Ако оценката е между 90 и 100 (включително), връща 'A'.  \n         В противен случай връща 'B'.  \n     Пример:  \n        evaluateIntegerGrade(90) // Връща 'A'  ",
      "zh": "评估输入整数的等级。\n参数：\n- score (int): 要评估的整数分数。\n返回：\n    char: 与输入分数对应的等级。\n         如果分数在90到100之间（包括90和100），返回 'A'。\n         否则，返回 'B'。\n     示例：\n        evaluateIntegerGrade(90) // 返回 'A'",
      "fr": "Évaluer la note pour un entier en entrée.\nParamètres :\n- score (int): Le score entier à évaluer.\nRenvoie :\n    char: La note correspondant au score d'entrée.\n         Si le score est entre 90 et 100 (inclus), renvoie 'A'.\n         Sinon, renvoie 'B'.\n     Exemple :\n        evaluateIntegerGrade(90) // Renvoie 'A'",
      "de": "Bewerten Sie die Note für eine Eingabe als Ganzzahl.\nParameter:\n- score (int): Die zu bewertende Ganzzahl.\nRückgabewert:\n    char: Die Note, die der Eingabepunktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n     Beispiel:\n        evaluateIntegerGrade(90) // Gibt 'A' zurück",
      "ha": "Kimanta darajar don wani cikakken lamba.\nSigogi:\n- score (int): Makircin cikakken lamba da za a tantance.\nDawowa:\n    char: Matsayin da ya dace da makircin da aka shigar.\n         Idan makircin yana tsakanin 90 da 100 (ciki har da), ya dawo da 'A'.\n         In ba haka ba, ya dawo da 'B'.\n     Misali:\n        evaluateIntegerGrade(90) // Ya dawo da 'A'",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\nपैरामीटर्स:\n- score (int): मूल्यांकन के लिए पूर्णांक स्कोर।\n\nवापसी:\n    char: इनपुट स्कोर के अनुरूप ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n     उदाहरण:\n        evaluateIntegerGrade(90) // 'A' लौटाता है।",
      "hu": "Értékeli a bemeneti egész szám osztályzatát.\nParaméterek:\n- score (int): Az értékelendő egész szám pontszám.\nVisszatér:\n    char: Az osztályzat, amely megfelel a bemeneti pontszámnak.\n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n         Egyébként 'B'-t ad vissza.\n     Példa:\n        evaluateIntegerGrade(90) // Visszaadja: 'A'"
    },
    "docstring_bertscore": {
      "sq": "0.9817683132159507",
      "hy": "0.9786835833984789",
      "bn": "0.9748373047001193",
      "bg": "0.9679140427691483",
      "zh": "0.9650746214722545",
      "fr": "0.9941282873062277",
      "de": "0.9544010193169639",
      "ha": "0.9897933778705222",
      "hi": "0.9668398496685117",
      "hu": "0.9865280930366898"
    }
  },
  {
    "task_id": "Go/30",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n//\n// Args:\n//\n//\ts (string): The three-character string to be checked.\n//\n// Returns:\n//\n//\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n//\tExamples:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n//\n// Argumentet:\n//\n//\ts (string): Vargu me tre karaktere që do të kontrollohet.\n//\n// Kthen:\n//\n//\tstr: Kthen \"Yes\" nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe \"No\".\n//\tShembuj:\n//\t    checkTwoEqualDigits(\"112\") // kthen \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n//\n// Արձանագրություններ:\n//\n//\ts (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n//\n// Վերադարձնում է:\n//\n//\tstr: Վերադարձնում է \"Yes\", եթե մուտքագրումը ունի հենց երկու նույն նիշ, հակառակ դեպքում՝ \"No\".\n//\tՕրինակներ:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা তা পরীক্ষা করে।\n//\n// আর্গুমেন্টসমূহ:\n//\n//\ts (string): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n//\n// রিটার্নস:\n//\n//\tstr: \"Yes\" রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n//\tউদাহরণসমূহ:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits проверява дали низ от три знака има точно два еднакви знака.\n//\n// Аргументи:\n//\n//\ts (string): Низът от три знака, който трябва да бъде проверен.\n//\n// Връща:\n//\n//\tstr: Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n//\tПримери:\n//\t    checkTwoEqualDigits(\"112\") // връща \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits 检查一个三字符字符串是否有且仅有两个字符相同。\n//\n// 参数:\n//\n//\ts (string): 要检查的三字符字符串。\n//\n// 返回:\n//\n//\tstr: 如果输入有且仅有两个相同字符，则返回 \"Yes\"，否则返回 \"No\"。\n//\t示例:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n//\n// Args:\n//\n//\ts (string): La chaîne de trois caractères à vérifier.\n//\n// Returns:\n//\n//\tstr: Renvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n//\tExamples:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n//\n// Argumente:\n//\n//\ts (string): Der dreistellige String, der überprüft werden soll.\n//\n// Rückgabewerte:\n//\n//\tstr: Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n//\tBeispiele:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits yana duba idan wani igiyar haruffa guda uku yana da daidai haruffa biyu da suke iri ɗaya.\n//\n// Args:\n//\n//\ts (string): Igiyar haruffa guda uku da za a duba.\n//\n// Returns:\n//\n//\tstr: Yana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu da suke iri ɗaya, in ba haka ba \"No\".\n//\tMisalai:\n//\t    checkTwoEqualDigits(\"112\") // yana dawowa \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits यह जांचता है कि क्या एक तीन-अक्षर की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n//\n// तर्क:\n//\n//\ts (string): तीन-अक्षर की स्ट्रिंग जिसे जांचा जाना है।\n//\n// वापसी:\n//\n//\tstr: \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n//\tउदाहरण:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n// CheckTwoEqualDigits ellenőrzi, hogy egy három karakterből álló string pontosan két azonos karaktert tartalmaz-e.\n//\n// Arg:\n//\n//\ts (string): Az ellenőrizendő három karakterből álló string.\n//\n// Visszatér:\n//\n//\tstr: \"Yes\"-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben \"No\"-t.\n//\tPéldák:\n//\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"\nfunc CheckTwoEqualDigits(s string) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9810711205785183",
      "hy": "0.9287397617606856",
      "bn": "0.974749510071702",
      "bg": "0.9646316757225468",
      "zh": "0.9598212451546438",
      "fr": "0.9715992322284885",
      "de": "0.9598075396583524",
      "ha": "0.9772558282196001",
      "hi": "0.9757100865943866",
      "hu": "0.9704084430941844"
    },
    "canonical_solution": "if (s[0] == s[1] && s[1] != s[2]) ||\n\t\t(s[0] == s[2] && s[0] != s[1]) ||\n\t\t(s[1] == s[2] && s[0] != s[1]) {\n\t\treturn \"Yes\"\n\t} else {\n\t\treturn \"No\"\n\t}\n}",
    "instruction": {
      "en": "Write a Go function `func CheckTwoEqualDigits(s string) string` to solve the following problem:\nCheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n\n\ts (string): The three-character string to be checked.\n\nReturns:\n\n\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "sq": "Shkruani një funksion Go `func CheckTwoEqualDigits(s string) string` për të zgjidhur problemin e mëposhtëm:  \nCheckTwoEqualDigits kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgumentet:\n\n\ts (string): Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n\n\tstr: Kthen \"Yes\" nëse inputi ka saktësisht dy karaktere të barabarta, përndryshe \"No\".\n\tShembuj:\n\t    checkTwoEqualDigits(\"112\") // kthen \"Yes\"",
      "hy": "Գրեք Go ֆունկցիա `func CheckTwoEqualDigits(s string) string` հետևյալ խնդիրը լուծելու համար:\nCheckTwoEqualDigits ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի ճիշտ երկու նիշ, որոնք նույնն են:\n\nԱրգումենտներ:\n\n\ts (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգվի:\n\nՎերադարձնում է:\n\n\tstr: Վերադարձնում է \"Yes\", եթե մուտքագրումը ունի ճիշտ երկու հավասար նիշեր, հակառակ դեպքում՝ \"No\":\n\tՕրինակներ:\n\t    checkTwoEqualDigits(\"112\") // վերադարձնում է \"Yes\"",
      "bn": "একটি Go ফাংশন `func CheckTwoEqualDigits(s string) string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nCheckTwoEqualDigits পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n\nArgs:\n\n\ts (string): তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nReturns:\n\n\tstr: \"Yes\" রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "bg": "Напишете Go функция `func CheckTwoEqualDigits(s string) string`, за да решите следния проблем:  \nCheckTwoEqualDigits проверява дали низ с три знака има точно два еднакви знака.\n\nАргументи:\n\n\ts (string): Низът с три знака, който ще бъде проверен.\n\nВръща:\n\n\tstr: Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n\tПримери:\n\t    checkTwoEqualDigits(\"112\") // връща \"Yes\"",
      "zh": "编写一个 Go 函数 `func CheckTwoEqualDigits(s string) string` 来解决以下问题：\n\nCheckTwoEqualDigits 检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n\n\ts (string): 要检查的三字符字符串。\n\n返回：\n\n\tstr: 如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\t示例:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "fr": "Écrire une fonction Go `func CheckTwoEqualDigits(s string) string` pour résoudre le problème suivant :  \nCheckTwoEqualDigits vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n\n\ts (string): La chaîne de trois caractères à vérifier.\n\nReturns:\n\n\tstr: Renvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n\tExemples :\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "de": "Schreiben Sie eine Go-Funktion `func CheckTwoEqualDigits(s string) string`, um das folgende Problem zu lösen:\nCheckTwoEqualDigits überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgumente:\n\n\ts (string): Der dreistellige String, der überprüft werden soll.\n\nRückgabewerte:\n\n\tstr: Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n\tBeispiele:\n\t    checkTwoEqualDigits(\"112\") // gibt \"Yes\" zurück",
      "ha": "Rubuta aikin Go `func CheckTwoEqualDigits(s string) string` don warware matsalar mai zuwa:\nCheckTwoEqualDigits yana duba idan wani igiyar haruffa guda uku yana da daidai haruffa biyu da suke daidai.\n\nArgs:\n\n\ts (string): Igiyar haruffa guda uku da za a duba.\n\nReturns:\n\n\tstr: Yana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu masu daidai, in ba haka ba \"No\".\n\tMisalai:\n\t    checkTwoEqualDigits(\"112\") // yana dawowa \"Yes\"",
      "hi": "Go फ़ंक्शन `func CheckTwoEqualDigits(s string) string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nCheckTwoEqualDigits जाँच करता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nआर्ग्स:\n\n\ts (string): तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n\nरिटर्न्स:\n\n\tstr: \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n\tउदाहरण:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "hu": "Írj egy Go függvényt `func CheckTwoEqualDigits(s string) string` a következő probléma megoldására:\nCheckTwoEqualDigits ellenőrzi, hogy egy három karakterből álló string pontosan két azonos karaktert tartalmaz-e.\n\nArgs:\n\n\ts (string): A három karakterből álló string, amelyet ellenőrizni kell.\n\nVisszatér:\n\n\tstr: \"Yes\"-t ad vissza, ha a bemenet pontosan két egyenlő karaktert tartalmaz, különben \"No\"-t.\n\tPéldák:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\""
    },
    "instruction_bertscore": {
      "sq": "0.9830693422117293",
      "hy": "0.9583376748386943",
      "bn": "0.9759031553247526",
      "bg": "0.9590732031396665",
      "zh": "0.9614055210737781",
      "fr": "0.9676651589017116",
      "de": "0.9526737295234844",
      "ha": "0.9752264216165667",
      "hi": "0.9659777938148202",
      "hu": "0.9800438042478058"
    },
    "level": "easy",
    "test": "func TestCheckTwoEqualDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"112\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"123\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"232\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"444\")) // All three characters are equal, not two.\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"121\"))\n\n\t// Additional test cases to cover more scenarios\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"787\"))\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"999\")) // All three characters are equal\n\tassert.Equal(\"No\", CheckTwoEqualDigits(\"890\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"556\"))\n\tassert.Equal(\"Yes\", CheckTwoEqualDigits(\"353\")) // No two characters are equal\n}",
    "entry_point": "CheckTwoEqualDigits",
    "signature": "func CheckTwoEqualDigits(s string) string",
    "docstring": {
      "en": "CheckTwoEqualDigits checks if a three-character string has exactly two characters that are the same.\n\nArgs:\n\n\ts (string): The three-character string to be checked.\n\nReturns:\n\n\tstr: Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "sq": "CheckTwoEqualDigits kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nArgs:\n\n\ts (string): Vargu me tre karaktere që do të kontrollohet.\n\nReturns:\n\n\tstr: Kthen \"Yes\" nëse hyrja ka saktësisht dy karaktere të barabartë, përndryshe \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // kthen \"Yes\"",
      "hy": "CheckTwoEqualDigits-ը ստուգում է, արդյոք երեք նիշից բաղկացած տողում կա՞ն երկու նույնական նիշ։\n\nԱրգումենտներ:\n\n\ts (string): Երեք նիշից բաղկացած տողը, որը պետք է ստուգել։\n\nՎերադարձնում է:\n\n\tstr: Վերադարձնում է \"Yes\", եթե մուտքում կա երկու նույնական նիշ, հակառակ դեպքում՝ \"No\"։\n\tՕրինակներ:\n\t    checkTwoEqualDigits(\"112\") // վերադարձնում է \"Yes\"",
      "bn": "CheckTwoEqualDigits একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই আছে কিনা তা পরীক্ষা করে।\n\nArgs:\n\n\ts (string): যে তিন-অক্ষরের স্ট্রিংটি পরীক্ষা করা হবে।\n\nReturns:\n\n\tstr: \"Yes\" ফেরত দেয় যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" ফেরত দেয়",
      "bg": "CheckTwoEqualDigits проверява дали низ от три знака има точно два еднакви знака.\n\nArgs:\n\n\ts (string): Низът от три знака, който ще бъде проверен.\n\nReturns:\n\n\tstr: Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // връща \"Yes\"",
      "zh": "CheckTwoEqualDigits 检查一个三字符字符串是否有且仅有两个字符相同。\n\nArgs:\n\n\ts (string): 要检查的三字符字符串。\n\nReturns:\n\n\tstr: 如果输入有且仅有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "fr": "CheckTwoEqualDigits vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nArgs:\n\n\ts (string): La chaîne de trois caractères à vérifier.\n\nReturns:\n\n\tstr: Renvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "de": "CheckTwoEqualDigits überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nArgs:\n\n\ts (string): Der dreistellige String, der überprüft werden soll.\n\nReturns:\n\n\tstr: Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // gibt \"Yes\" zurück",
      "ha": "CheckTwoEqualDigits yana duba idan wani igiyar haruffa mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n\nArgs:\n\n\ts (string): Igiyar haruffa mai haruffa uku da za a duba.\n\nReturns:\n\n\tstr: Yana dawowa da \"Yes\" idan shigarwar tana da daidai haruffa biyu da suke daidai, in ba haka ba \"No\".\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // returns \"Yes\"",
      "hi": "CheckTwoEqualDigits यह जांचता है कि क्या एक तीन-अक्षर की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nArgs:\n\n\ts (string): तीन-अक्षर की स्ट्रिंग जिसे जांचा जाना है।\n\nReturns:\n\n\tstr: \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n\tExamples:\n\t    checkTwoEqualDigits(\"112\") // \"Yes\" लौटाता है",
      "hu": "CheckTwoEqualDigits ellenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nArgs:\n\n\ts (string): A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nReturns:\n\n\tstr: \"Yes\"-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-t.\n\tPéldák:\n\t    checkTwoEqualDigits(\"112\") // visszaadja \"Yes\""
    },
    "docstring_bertscore": {
      "sq": "0.9835031509639094",
      "hy": "0.8992187186401374",
      "bn": "0.97091812865192",
      "bg": "0.9575451396183651",
      "zh": "0.9630080709879676",
      "fr": "0.9594392789319137",
      "de": "0.9537705664875591",
      "ha": "0.9734655632886924",
      "hi": "0.9625204334025269",
      "hu": "0.9630990437024816"
    }
  },
  {
    "task_id": "Go/31",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a string consisting of lowercase English letters,\nin each round, you can change one of the characters to another character.\nThe question is: what is the minimum number of rounds needed to make\nthe string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes,\nnë çdo raund, ju mund të ndryshoni një nga karakteret në një karakter tjetër.\nPyetja është: cili është numri minimal i raundeve të nevojshëm për ta bërë\nvargun të përbërë nga i njëjti karakter?\n\nPër shembull:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով տող, որը բաղկացած է փոքրատառ անգլերեն տառերից,\nյուրաքանչյուր փուլում, դուք կարող եք փոխել տառերից մեկը մեկ այլ տառի:\nՀարցն այն է՝ ինչ է նվազագույն փուլերի քանակը, որը անհրաժեշտ է դարձնելու համար\nտողը բաղկացած նույն տառից:\n\nՕրինակ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত,\nপ্রতিটি রাউন্ডে, আপনি অক্ষরগুলির মধ্যে একটি অন্য অক্ষরে পরিবর্তন করতে পারেন।\nপ্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е низ, състоящ се от малки букви на английската азбука,\nвъв всеки рунд можете да промените един от символите на друг символ.\nВъпросът е: какъв е минималният брой рундове, необходими, за да се направи\nнизът съставен от един и същ символ?\n\nНапример:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由小写英文字母组成的字符串，\n在每一轮中，你可以将其中一个字符更改为另一个字符。\n问题是：需要最少多少轮才能使字符串由相同的字符组成？\n\n例如：\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une chaîne composée de lettres minuscules anglaises,\nà chaque tour, vous pouvez changer l'un des caractères pour un autre caractère.\nLa question est : quel est le nombre minimum de tours nécessaires pour rendre\nla chaîne composée du même caractère ?\n\nPar exemple :\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht,\nin jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern.\nDie Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden,\num den String aus demselben Zeichen bestehen zu lassen?\n\nZum Beispiel:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Turanci,\na kowace zagaye, za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi.\nTambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don yin\nkirtanin ya ƙunshi harafi ɗaya iri ɗaya?\n\nAlal misali:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए एक स्ट्रिंग में छोटे अंग्रेजी अक्षर होते हैं,\nप्रत्येक राउंड में, आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं।\nप्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy kisbetűs angol betűkből álló karakterlánc,\nminden körben megváltoztathatsz egy karaktert egy másik karakterre.\nA kérdés az: mi a minimális körök száma, amire szükség van ahhoz,\nhogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldául:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0\n*/\nfunc minRoundsToSameChar(s string) int {"
    },
    "prompt_bertscore": {
      "sq": "0.996663804120138",
      "hy": "0.960750636707506",
      "bn": "0.9841091722564469",
      "bg": "0.9892119867452331",
      "zh": "0.9897949669135705",
      "fr": "0.9981874977730566",
      "de": "0.9791102414569418",
      "ha": "0.9956782001694429",
      "hi": "0.9776407738980457",
      "hu": "0.9867769769041265"
    },
    "canonical_solution": "var charCount [26]int\n\tfor _, ch := range s {\n\t\tcharCount[ch-'a']++\n\t}\n\tmaxCount := 0\n\tfor _, count := range charCount {\n\t\tif count > 0 {\n\t\t\tmaxCount++\n\t\t}\n\t}\n\n\tif maxCount == 0 {\n\t\treturn 0\n\t}\n\treturn maxCount - 1\n}",
    "instruction": {
      "en": "Write a Go function `func minRoundsToSameChar(s string) int` to solve the following problem:\nGiven a string consisting of lowercase English letters, in each round, you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "sq": "Shkruani një funksion në Go `func minRoundsToSameChar(s string) int` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund, ju mund të ndryshoni njërin nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nPër shembull:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hy": "Գրեք Go ֆունկցիա `func minRoundsToSameChar(s string) int` հետևյալ խնդիրը լուծելու համար:\nՏրված է փոքրատառ անգլերեն տառերից բաղկացած տող, յուրաքանչյուր փուլում դուք կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\n\nՕրինակ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "bn": "Go ফাংশন `func minRoundsToSameChar(s string) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং দেওয়া আছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে, আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "bg": "Напишете Go функция `func minRoundsToSameChar(s string) int`, за да решите следния проблем:  \nДаден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да направите низа съставен от един и същ символ?\n\nНапример:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "zh": "编写一个 Go 函数 `func minRoundsToSameChar(s string) int` 来解决以下问题：  \n给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？\n\n例如：\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "fr": "Écrire une fonction Go `func minRoundsToSameChar(s string) int` pour résoudre le problème suivant :\nÉtant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nPar exemple :\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "de": "Schreiben Sie eine Go-Funktion `func minRoundsToSameChar(s string) int`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus kleinen englischen Buchstaben besteht. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\n\nZum Beispiel:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "ha": "Rubuta aikin Go `func minRoundsToSameChar(s string) int` don warware matsalar mai zuwa: \n\nAn ba da wani kirtani da ya ƙunshi ƙananan haruffan Turanci, a kowace zagaye, za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtanin ya ƙunshi harafi iri ɗaya? \n\nMisali:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hi": "Go फ़ंक्शन `func minRoundsToSameChar(s string) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में, आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hu": "Írj egy Go függvényt `func minRoundsToSameChar(s string) int` a következő probléma megoldására:\nAdott egy kisbetűs angol betűkből álló string, minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés: mi a minimális körök száma, amire szükség van ahhoz, hogy a string azonos karakterekből álljon?\n\nPéldául:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0"
    },
    "instruction_bertscore": {
      "sq": "0.992085771098046",
      "hy": "0.9681386937300988",
      "bn": "0.978171514276171",
      "bg": "0.9980538195266202",
      "zh": "0.9917413460173314",
      "fr": "0.9910946054966818",
      "de": "0.9898335012074914",
      "ha": "0.9918865448258679",
      "hi": "0.9594682789675448",
      "hu": "0.9754739150713362"
    },
    "level": "easy",
    "test": "func TestMinRoundsToSameChar(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, minRoundsToSameChar(\"aab\"), \"They should be equal\")\n\tassert.Equal(2, minRoundsToSameChar(\"abc\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"aaa\"), \"They should be equal\")\n\tassert.Equal(1, minRoundsToSameChar(\"abab\"), \"They should be equal\")\n\tassert.Equal(0, minRoundsToSameChar(\"zzzzz\"), \"They should be equal\")\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "func minRoundsToSameChar(s string) int",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round, you can change one of the characters to another character. The question is: what is the minimum number of rounds needed to make the string composed of the same character?\n\nFor example:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në secilën raund, ju mund të ndryshoni njërën nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal i raundeve të nevojshëm për ta bërë vargun të përbërë nga i njëjti karakter?\n\nPër shembull:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում կարող եք փոխել տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն փուլերի քանակը, որպեսզի տողը կազմված լինի նույն տառից:\n\nՕրինակ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "bn": "প্রদত্ত একটি স্ট্রিং যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে, আপনি একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণস্বরূপ:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nНапример:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最小轮数是多少？\n\n例如：\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nPar exemple :\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "de": "Angenommen, ein String besteht aus Kleinbuchstaben des englischen Alphabets. In jeder Runde kann man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen zusammengesetzt zu machen?\n\nBeispiel:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "ha": "An ba da wata igiyar kirtani da ke kunshe da ƙananan haruffan Ingilishi, a kowace zagaye, za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafin guda?\n\nMisali:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hi": "दिए गए स्ट्रिंग में छोटे अक्षरों वाले अंग्रेजी अक्षर शामिल हैं, प्रत्येक राउंड में, आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से बना हुआ बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण के लिए:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc. Minden körben megváltoztathatsz egy karaktert egy másik karakterre. A kérdés az: mi a minimális körök száma ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon?\n\nPéldául:\n\t>>> minRoundsToSameChar(\"aab\")\n\t1\n\t>>> minRoundsToSameChar(\"abc\")\n\t2\n\t>>> minRoundsToSameChar(\"aaa\")\n\t0"
    },
    "docstring_bertscore": {
      "sq": "0.9945905002028959",
      "hy": "0.945731200445553",
      "bn": "0.9870812786478719",
      "bg": "0.9973212706813634",
      "zh": "0.9936269442244956",
      "fr": "0.9888226711984047",
      "de": "0.9368232237472814",
      "ha": "0.9580464827000972",
      "hi": "0.9495168968776969",
      "hu": "0.9741961258301387"
    }
  },
  {
    "task_id": "Go/32",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of n events, each occurring with a periodicity of a_i years,\nthe problem is to find the year Y_n when the nth event occurs, under the\ncondition that the countdown for event i+1 can only commence in the year\nimmediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh,\nproblemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, nën\nkushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin\nmenjëherë pas ndodhjes së ngjarjes i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ,\nխնդիրը գտնելն է Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության հետհաշվարկը կարող է սկսվել միայն\ni իրադարձության տեղի ունենալուց անմիջապես հետո հաջորդող տարում։\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nnটি ঘটনাবলীর একটি ক্রম দেওয়া আছে, প্রতিটি a_i বছর পরপর ঘটে,\nসমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন nতম ঘটনা ঘটে,\nএই শর্তের অধীনে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র\nঘটনা i ঘটার পরের বছরেই শুরু হতে পারে।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години,\nпроблемът е да се намери годината Y_n, когато се случва n-тото събитие, при\nусловие, че отброяването за събитие i+1 може да започне само в годината,\nнепосредствено следваща след настъпването на събитие i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，\n问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在\n事件 i 发生的年份的下一年开始。\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années,\nle problème est de trouver l'année Y_n lorsque le nième événement se produit, sous la\ncondition que le compte à rebours pour l'événement i+1 ne peut commencer que l'année\nsuivant immédiatement la survenue de l'événement i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten,\nbesteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der\nBedingung, dass der Countdown für Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten von Ereignis i beginnen kann.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaituwa na shekaru a_i,\nmatsalar ita ce gano shekarar Y_n lokacin da abin da ya faru na nth ya faru, a ƙarƙashin\nsharadi cewa ƙidayar lokaci don abin da ya faru i+1 zai iya farawa ne kawai a cikin shekarar\nnan take bayan faruwar abin da ya faru na i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n घटनाओं के अनुक्रम में, प्रत्येक a_i वर्षों की आवधिकता के साथ घटित होती है,\nसमस्या यह है कि वर्ष Y_n का पता लगाना है जब nth घटना घटित होती है, इस\nशर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत\nबाद के वर्ष में ही शुरू हो सकती है।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy n eseményből álló sorozat, amelyek mindegyike a_i évek periodicitásával fordul elő,\na feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel,\nhogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n*/\nfunc apocalypseYear(n int, signs []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9918511886180437",
      "hy": "0.9723369454636521",
      "bn": "0.9577685987970294",
      "bg": "0.9936809716881371",
      "zh": "0.9765296355465366",
      "fr": "0.999231697686157",
      "de": "0.9849096526920175",
      "ha": "0.9648408335137765",
      "hi": "0.9876869026796473",
      "hu": "0.974340132856389"
    },
    "canonical_solution": "year := 0\n\tfor i := 0; i < n; i++ {\n\t\tperiod := signs[i]\n\t\tnextOccurrence := (year/period + 1) * period\n\t\tyear = nextOccurrence\n\t}\n\treturn year\n}",
    "instruction": {
      "en": "Write a Go function `func apocalypseYear(n int, signs []int) int` to solve the following problem:\nGiven a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the nth event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n",
      "sq": "Shkruani një funksion Go `func apocalypseYear(n int, signs []int) int` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n",
      "hy": "Գրեք Go ֆունկցիա `func apocalypseYear(n int, signs []int) int` հետևյալ խնդիրը լուծելու համար:\nՏրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնելն է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, այն պայմանով, որ i+1 իրադարձության համար հետհաշվարկը կարող է սկսվել միայն i իրադարձության տեղի ունենալուց անմիջապես հետո տարում:\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "bn": "Go ফাংশন `func apocalypseYear(n int, signs []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nধরা যাক n সংখ্যক ঘটনা রয়েছে, প্রতিটি ঘটনা a_i বছর পরপর ঘটে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন nth ঘটনা ঘটে, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i এর ঘটনার পরবর্তী বছরেই শুরু হতে পারে।",
      "bg": "Напишете Go функция `func apocalypseYear(n int, signs []int) int`, за да решите следния проблем:  \nДадена е последователност от n събития, всяко от които се случва с периодичност от a_i години. Проблемът е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща след събитието i.",
      "zh": "编写一个 Go 函数 `func apocalypseYear(n int, signs []int) int` 来解决以下问题：  \n给定一个 n 个事件的序列，每个事件以 a_i 年的周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生后的下一年开始。",
      "fr": "Écrire une fonction Go `func apocalypseYear(n int, signs []int) int` pour résoudre le problème suivant :  \nÉtant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le nième événement se produit, à la condition que le compte à rebours pour l'événement i+1 ne puisse commencer que l'année suivant immédiatement la survenue de l'événement i.",
      "de": "Schreiben Sie eine Go-Funktion `func apocalypseYear(n int, signs []int) int`, um das folgende Problem zu lösen: Gegeben ist eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten. Das Problem besteht darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für Ereignis i+1 erst im Jahr unmittelbar nach dem Eintreten von Ereignis i beginnen kann.",
      "ha": "Rubuta aikin Go `func apocalypseYear(n int, signs []int) int` don warware matsalar mai zuwa:\nAn ba da jerin abubuwan n, kowanne yana faruwa tare da maimaitawa na a_i shekaru, matsalar ita ce a nemo shekarar Y_n lokacin da abin n ya faru, a karkashin yanayin cewa ƙidayar don abin i+1 zai iya farawa ne kawai a shekarar da ta biyo bayan faruwar abin i.",
      "hi": "Go फ़ंक्शन `func apocalypseYear(n int, signs []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, समस्या यह है कि वर्ष Y_n का पता लगाना है जब nth घटना होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है।",
      "hu": "Írj egy Go függvényt `func apocalypseYear(n int, signs []int) int` a következő probléma megoldására:  \nAdott egy n eseményből álló sorozat, ahol minden esemény a_i évenkénti periodicitással fordul elő. A probléma az, hogy meg kell találni az Y_n évet, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36"
    },
    "instruction_bertscore": {
      "sq": "0.9883016637089502",
      "hy": "0.9561445968016881",
      "bn": "0.8758802447596812",
      "bg": "0.8943236715299137",
      "zh": "0.8874957521818393",
      "fr": "0.9090968061193834",
      "de": "0.8954725496538194",
      "ha": "0.8767337595069881",
      "hi": "0.8867979636532638",
      "hu": "0.9590946552208183"
    },
    "level": "easy",
    "test": "func TestApocalypseYear(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(36, apocalypseYear(6, []int{3, 2, 4, 5, 9, 18}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(5, apocalypseYear(5, []int{1, 1, 1, 1, 1}))\n\tassert.Equal(2012, apocalypseYear(6, []int{50, 30, 711, 200, 503, 1006}))\n\tassert.Equal(2, apocalypseYear(2, []int{1, 2}))\n\tassert.Equal(6, apocalypseYear(3, []int{3, 1, 2}))\n\tassert.Equal(4, apocalypseYear(3, []int{2, 3, 4}))\n\tassert.Equal(4, apocalypseYear(4, []int{1, 2, 3, 4}))\n\tassert.Equal(13, apocalypseYear(4, []int{5, 7, 11, 13}))\n\tassert.Equal(10, apocalypseYear(5, []int{2, 2, 2, 2, 2}))\n\tassert.Equal(15, apocalypseYear(3, []int{6, 10, 15}))\n\tassert.Equal(14, apocalypseYear(3, []int{4, 6, 14}))\n\tassert.Equal(800, apocalypseYear(4, []int{50, 30, 711, 200}))\n\tassert.Equal(6, apocalypseYear(6, []int{1, 1, 1, 1, 1, 1}))\n\tassert.Equal(1999998, apocalypseYear(2, []int{1000000, 999999}))\n}",
    "entry_point": "apocalypseYear",
    "signature": "func apocalypseYear(n int, signs []int) int",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the problem is to find the year Y_n when the nth event occurs, under the condition that the countdown for event i+1 can only commence in the year immediately following the occurrence of event i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36\n",
      "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodicitet prej a_i vitesh, problemi është të gjendet viti Y_n kur ndodh ngjarja e n-të, me kushtin që numërimi mbrapsht për ngjarjen i+1 mund të fillojë vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնել Y_n տարին, երբ տեղի կունենա n-րդ իրադարձությունը, այն պայմանով, որ իրադարձություն i+1-ի հետհաշվարկը կարող է սկսվել միայն իրադարձություն i-ի տեղի ունենալուց անմիջապես հետո:\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "bn": "প্রতিটি a_i বছর পরপর ঘটে এমন nটি ঘটনার একটি ক্রম দেওয়া হয়েছে, সমস্যাটি হল Y_n বছরটি খুঁজে বের করা যখন nতম ঘটনা ঘটে, এই শর্তে যে ঘটনা i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ঘটনা i ঘটার পরের বছরেই শুরু হতে পারে।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "bg": "Като се има предвид последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато се случва n-тото събитие, при условие че отброяването за събитие i+1 може да започне само в годината, непосредствено следваща след настъпването на събитие i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "zh": "给定一个由 n 个事件组成的序列，每个事件以 a_i 年的周期发生，问题是找到第 n 个事件发生的年份 Y_n，条件是事件 i+1 的倒计时只能在事件 i 发生的下一年开始。",
      "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, le problème est de trouver l'année Y_n lorsque le nième événement se produit, à condition que le compte à rebours pour l'événement i+1 ne puisse commencer que l'année suivant immédiatement la survenue de l'événement i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "de": "Angenommen, es gibt eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht das Problem darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt, unter der Bedingung, dass der Countdown für das Ereignis i+1 erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i beginnen kann.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "ha": "An ba da jerin abubuwan n, kowanne yana faruwa da maimaituwar shekaru a_i, matsalar ita ce nemo shekarar Y_n lokacin da abin n na faruwa, a karkashin yanayin cewa ƙidayar don abin i+1 na iya farawa kawai a cikin shekarar da ke biye da faruwar abin i.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "hi": "दिए गए n घटनाओं के अनुक्रम में, प्रत्येक घटना a_i वर्षों की आवधिकता के साथ होती है, समस्या यह है कि nth घटना किस वर्ष Y_n में होती है, इस शर्त के तहत कि घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू हो सकती है।\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36",
      "hu": "Adott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenkénti periodicitással következik be, a feladat az Y_n év megtalálása, amikor az n-edik esemény bekövetkezik, azzal a feltétellel, hogy az i+1 esemény visszaszámlálása csak az i esemény bekövetkezését követő évben kezdődhet meg.\n\n    >>> apocalypseYear(6, []int{3, 2, 4, 5, 9, 18})\n    36"
    },
    "docstring_bertscore": {
      "sq": "0.9837117128639961",
      "hy": "0.9462091051423229",
      "bn": "0.9288488098398737",
      "bg": "0.9749020582043367",
      "zh": "0.8669347269193939",
      "fr": "0.9721812192449208",
      "de": "0.9581102430524093",
      "ha": "0.9295056805099561",
      "hi": "0.9638482774997452",
      "hu": "0.9357957087861879"
    }
  },
  {
    "task_id": "Go/33",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: New Modulo Operation \"⊕\".\nIn this operation, for x ⊕ y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! ⊕ p,\nwhere n! is the factorial of n (product of all positive integers ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblemi: Operacioni i Ri Modulo \"⊕\".\nNë këtë operacion, për x ⊕ y:\n- Nëse x nuk është shumëfish i y, rezultati është x % y.\n- Nëse x është shumëfish i y, vazhdo të pjestosh x me y (x = x / y) derisa x të mos jetë më shumëfish.\n  Le të jetë vlera përfundimtare x'. Rezultati është x' % y.\n\nShembuj:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDuke pasur një numër të thjeshtë p dhe një numër të plotë n, llogarit vlerën e n! ⊕ p,\nku n! është faktoriali i n (prodhimi i të gjithë numrave të plotë pozitivë ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԽնդիր: Նոր Մոդուլո Գործողություն \"⊕\".\nԱյս գործողության համար, x ⊕ y:\n- Եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n- Եթե x-ը y-ի բազմապատիկ է, շարունակեք բաժանել x-ը y-ի վրա (x = x / y), մինչև x-ը այլևս բազմապատիկ չլինի:\n  Թող վերջնական արժեքը լինի x': Արդյունքը x' % y է:\n\nՕրինակներ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nՏրված է պարզ թիվ p և ամբողջ թիվ n, հաշվեք n! ⊕ p-ի արժեքը,\nորտեղ n! n-ի ֆակտորիալն է (բոլոր դրական ամբողջ թվերի արտադրյալը ≤ n):\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nসমস্যা: নতুন মডুলো অপারেশন \"⊕\"।\nএই অপারেশনে, x ⊕ y এর জন্য:\n- যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হবে x % y।\n- যদি x, y এর গুণিতক হয়, তাহলে x কে y দ্বারা ভাগ করতে থাকুন (x = x / y) যতক্ষণ না x আর গুণিতক থাকে।\n  চূড়ান্ত মানটি হোক x'। ফলাফল হবে x' % y।\n\nউদাহরণসমূহ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nএকটি মৌলিক সংখ্যা p এবং একটি পূর্ণসংখ্যা n দেওয়া আছে, n! ⊕ p এর মান গণনা করুন,\nযেখানে n! হল n এর ফ্যাক্টরিয়াল (সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল ≤ n)।\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nПроблем: Нова операция за модуло \"⊕\".\nВ тази операция, за x ⊕ y:\n- Ако x не е кратно на y, резултатът е x % y.\n- Ако x е кратно на y, продължете да делите x на y (x = x / y), докато x вече не е кратно.\n  Нека крайната стойност бъде x'. Резултатът е x' % y.\n\nПримери:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nДадено е просто число p и цяло число n, изчислете стойността на n! ⊕ p,\nкъдето n! е факториелът на n (произведението на всички положителни цели числа ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n问题: 新的模运算 \"⊕\"。\n在此运算中，对于 x ⊕ y:\n- 如果 x 不是 y 的倍数，结果是 x % y。\n- 如果 x 是 y 的倍数，继续将 x 除以 y (x = x / y)，直到 x 不再是倍数。\n  令最终值为 x'。结果是 x' % y。\n\n例子:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\n给定一个质数 p 和一个整数 n，计算 n! ⊕ p 的值，\n其中 n! 是 n 的阶乘（所有小于等于 n 的正整数的乘积）。\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblème : Nouvelle opération de modulo \"⊕\".\nDans cette opération, pour x ⊕ y :\n- Si x n'est pas un multiple de y, le résultat est x % y.\n- Si x est un multiple de y, continuez à diviser x par y (x = x / y) jusqu'à ce que x ne soit plus un multiple.\n  Que la valeur finale soit x'. Le résultat est x' % y.\n\nExemples :\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nÉtant donné un nombre premier p et un entier n, calculez la valeur de n! ⊕ p,\noù n! est la factorielle de n (produit de tous les entiers positifs ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProblem: Neue Modulo-Operation \"⊕\".\nIn dieser Operation, für x ⊕ y:\n- Wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n- Wenn x ein Vielfaches von y ist, teile x durch y (x = x / y), bis x kein Vielfaches mehr ist.\n  Der Endwert sei x'. Das Ergebnis ist x' % y.\n\nBeispiele:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGegeben sei eine Primzahl p und eine ganze Zahl n, berechne den Wert von n! ⊕ p,\nwobei n! die Fakultät von n ist (Produkt aller positiven ganzen Zahlen ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nMatsala: Sabon Aiki na Modulo \"⊕\".\nA cikin wannan aikin, don x ⊕ y:\n- Idan x ba ya rabuwa da y, sakamakon shi ne x % y.\n- Idan x yana rabuwa da y, ci gaba da raba x da y (x = x / y) har sai x ba ya rabuwa da y.\n  Bari ƙimar ƙarshe ta zama x'. Sakamakon shi ne x' % y.\n\nMisalai:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nAn ba da lambar farko p da kuma cikakken lamba n, ƙididdige ƙimar n! ⊕ p,\ninda n! shine factorial na n (samfurin duk lambobin kirki ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nसमस्या: नया माड्यूलो ऑपरेशन \"⊕\"।\nइस ऑपरेशन में, x ⊕ y के लिए:\n- यदि x, y का गुणज नहीं है, तो परिणाम x % y है।\n- यदि x, y का गुणज है, तो x को y से विभाजित करते रहें (x = x / y) जब तक कि x अब गुणज न रहे।\n  अंतिम मान को x' मान लें। परिणाम x' % y है।\n\nउदाहरण:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nदिया गया एक अभाज्य संख्या p और एक पूर्णांक n, n! ⊕ p का मान गणना करें,\nजहाँ n! n का फैक्टरियल है (सभी धनात्मक पूर्णांकों का गुणनफल ≤ n)।\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nProbléma: Új Modulo Művelet \"⊕\".\nEbben a műveletben, x ⊕ y esetén:\n- Ha x nem többszöröse y-nak, az eredmény x % y.\n- Ha x többszöröse y-nak, osszuk el x-et y-nal (x = x / y), amíg x már nem többszöröse.\n  Legyen a végső érték x'. Az eredmény x' % y.\n\nPéldák:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nAdott egy prímszám p és egy egész szám n, számítsuk ki az n! ⊕ p értékét,\nahol n! az n faktoriálisa (az összes pozitív egész szám szorzata ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nfunc newModuloFactorial(n, p uint64) uint64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9945124384631492",
      "hy": "0.9871374910457048",
      "bn": "0.9833607329807074",
      "bg": "0.9958802072669554",
      "zh": "0.9835643291212681",
      "fr": "0.997084900527932",
      "de": "0.9890467262682121",
      "ha": "0.9717350954091164",
      "hi": "0.9903984060111546",
      "hu": "0.9957089878785033"
    },
    "canonical_solution": "pj := make([]uint64, p)\n\tpj[0] = 1\n\tpj[1] = 1\n\tfor i := uint64(2); i < p; i++ {\n\t\tpj[i] = i * pj[i-1] % p\n\t}\n\n\tvar ans uint64 = 1\n\tfor n > 0 {\n\t\tans = ans * pj[n%p] % p\n\t\tif (n/p)&1 == 1 {\n\t\t\tans = p - ans\n\t\t}\n\t\tn /= p\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func newModuloFactorial(n, p uint64) uint64` to solve the following problem:\nProblem: New Modulo Operation \"⊕\".\nIn this operation, for x ⊕ y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! ⊕ p,\nwhere n! is the factorial of n (product of all positive integers ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "sq": "Shkruani një funksion Go `func newModuloFactorial(n, p uint64) uint64` për të zgjidhur problemin në vijim:\nProblem: Operacioni i ri Modulo \"⊕\".\nNë këtë operacion, për x ⊕ y:\n- Nëse x nuk është shumëfish i y, rezultati është x % y.\n- Nëse x është shumëfish i y, vazhdoni të ndani x me y (x = x / y) derisa x të mos jetë më shumëfish.\n  Le të jetë vlera përfundimtare x'. Rezultati është x' % y.\n\nShembuj:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDuke pasur një numër të plotë prim p dhe një numër të plotë n, llogaritni vlerën e n! ⊕ p,\nku n! është faktoriali i n (prodhimi i të gjithë numrave të plotë pozitivë ≤ n).",
      "hy": "Գրեք Go ֆունկցիա `func newModuloFactorial(n, p uint64) uint64` հետևյալ խնդիրը լուծելու համար:\nԽնդիր: Նոր Մոդուլո Գործողություն \"⊕\".\nԱյս գործողության մեջ, x ⊕ y-ի համար:\n- Եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n- Եթե x-ը y-ի բազմապատիկ է, շարունակեք բաժանել x-ը y-ով (x = x / y) մինչև x-ը այլևս բազմապատիկ չլինի:\n  Թող վերջնական արժեքը լինի x'. Արդյունքը x' % y է:\n\nՕրինակներ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nՏրված է պարզ թիվ p և ամբողջ թիվ n, հաշվեք n! ⊕ p-ի արժեքը,\nորտեղ n! -ը n-ի ֆակտորիալն է (բոլոր դրական ամբողջ թվերի արտադրյալը ≤ n):\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bn": "একটি Go ফাংশন `func newModuloFactorial(n, p uint64) uint64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসমস্যা: নতুন মডুলো অপারেশন \"⊕\"।\nএই অপারেশনে, x ⊕ y এর জন্য:\n- যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হবে x % y।\n- যদি x, y এর গুণিতক হয়, তাহলে x কে y দ্বারা ভাগ করতে থাকুন (x = x / y) যতক্ষণ না x আর গুণিতক থাকে।\n  চূড়ান্ত মানটিকে x' বলা হোক। ফলাফল হবে x' % y।\n\nউদাহরণ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nএকটি মৌলিক সংখ্যা p এবং একটি পূর্ণসংখ্যা n দেওয়া হলে, n! ⊕ p এর মান গণনা করুন,\nযেখানে n! হল n এর ফ্যাক্টোরিয়াল (n এর সমান বা ছোট সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল)।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bg": "Напишете функция на Go `func newModuloFactorial(n, p uint64) uint64`, за да решите следния проблем:\nПроблем: Нова операция за модул \"⊕\".\nВ тази операция, за x ⊕ y:\n- Ако x не е кратно на y, резултатът е x % y.\n- Ако x е кратно на y, продължете да делите x на y (x = x / y), докато x вече не е кратно.\n  Нека крайната стойност бъде x'. Резултатът е x' % y.\n\nПримери:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nДадено е просто число p и цяло число n, изчислете стойността на n! ⊕ p,\nкъдето n! е факториелът на n (произведение на всички положителни цели числа ≤ n).",
      "zh": "编写一个 Go 函数 `func newModuloFactorial(n, p uint64) uint64` 来解决以下问题：  \n问题：新模运算 \"⊕\"。  \n在此运算中，对于 x ⊕ y：  \n- 如果 x 不是 y 的倍数，结果是 x % y。  \n- 如果 x 是 y 的倍数，继续将 x 除以 y (x = x / y)，直到 x 不再是倍数。  \n  令最终值为 x'。结果是 x' % y。  \n\n示例：  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\n给定一个素数 p 和一个整数 n，计算 n! ⊕ p 的值，  \n其中 n! 是 n 的阶乘（所有小于等于 n 的正整数的乘积）。  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "fr": "Écrire une fonction Go `func newModuloFactorial(n, p uint64) uint64` pour résoudre le problème suivant :  \nProblème : Nouvelle opération Modulo \"⊕\".  \nDans cette opération, pour x ⊕ y :  \n- Si x n'est pas un multiple de y, le résultat est x % y.  \n- Si x est un multiple de y, continuez à diviser x par y (x = x / y) jusqu'à ce que x ne soit plus un multiple.  \n  Laissez la valeur finale être x'. Le résultat est x' % y.  \n\nExemples :  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nÉtant donné un nombre premier p et un entier n, calculez la valeur de n! ⊕ p,  \noù n! est la factorielle de n (produit de tous les entiers positifs ≤ n).  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "de": "Schreiben Sie eine Go-Funktion `func newModuloFactorial(n, p uint64) uint64`, um das folgende Problem zu lösen:\nProblem: Neue Modulo-Operation \"⊕\".\nIn dieser Operation, für x ⊕ y:\n- Wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n- Wenn x ein Vielfaches von y ist, teilen Sie x solange durch y (x = x / y), bis x kein Vielfaches mehr ist.\n  Der endgültige Wert sei x'. Das Ergebnis ist x' % y.\n\nBeispiele:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGegeben eine Primzahl p und eine ganze Zahl n, berechnen Sie den Wert von n! ⊕ p,\nwobei n! die Fakultät von n ist (Produkt aller positiven ganzen Zahlen ≤ n).",
      "ha": "Rubuta aikin Go `func newModuloFactorial(n, p uint64) uint64` don warware matsalar mai zuwa:\nMatsala: Sabon Aiki na Modulo \"⊕\".\nA cikin wannan aikin, don x ⊕ y:\n- Idan x ba shi ne sau na y ba, sakamakon shi ne x % y.\n- Idan x shi ne sau na y, ci gaba da raba x da y (x = x / y) har sai x ba shi ne sau na y ba.\n  Bari ƙimar ƙarshe ta zama x'. Sakamakon shi ne x' % y.\n\nMisalai:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nAn ba da lamba mai firamare p da kuma cikakken lamba n, ƙididdige ƙimar n! ⊕ p,\ninda n! shine factorial na n (samfurin duk lambobin da suka dace ≤ n).",
      "hi": "Go फ़ंक्शन `func newModuloFactorial(n, p uint64) uint64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसमस्या: नया माड्यूलो ऑपरेशन \"⊕\"।\nइस ऑपरेशन में, x ⊕ y के लिए:\n- यदि x, y का गुणज नहीं है, तो परिणाम x % y है।\n- यदि x, y का गुणज है, तो x को y से तब तक विभाजित करते रहें (x = x / y) जब तक x अब गुणज न रहे।\n  अंतिम मान को x' मान लें। परिणाम x' % y है।\n\nउदाहरण:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nदिए गए एक अभाज्य संख्या p और एक पूर्णांक n के लिए, n! ⊕ p का मान गणना करें,\nजहाँ n! n का फैक्टोरियल है (सभी सकारात्मक पूर्णांकों का गुणनफल जो n से छोटे या बराबर हैं)।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hu": "Írj egy Go függvényt `func newModuloFactorial(n, p uint64) uint64` a következő probléma megoldására:\nProbléma: Új Modulo Művelet \"⊕\".\nEbben a műveletben, x ⊕ y esetén:\n- Ha x nem többszöröse y-nak, az eredmény x % y.\n- Ha x többszöröse y-nak, oszd x-et y-nal (x = x / y), amíg x már nem többszöröse.\n  Legyen a végső érték x'. Az eredmény x' % y.\n\nPéldák:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nAdott egy prímszám p és egy egész szám n, számítsd ki az n! ⊕ p értékét,\nahol n! az n faktoriálisa (az összes pozitív egész szám szorzata ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "instruction_bertscore": {
      "sq": "0.97147091700234",
      "hy": "0.9803820717867082",
      "bn": "0.975085989937175",
      "bg": "0.9674271997052318",
      "zh": "0.9812183056908651",
      "fr": "0.9974648804468518",
      "de": "0.97141331419184",
      "ha": "0.9677166041703996",
      "hi": "0.9651014365736943",
      "hu": "0.9782561308184918"
    },
    "level": "middle",
    "test": "func TestNewModuloFactorial(t *testing.T) {\n\t// Test cases\n\tassert.Equal(t, uint64(6), newModuloFactorial(3, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(10, 3))\n\tassert.Equal(t, uint64(4), newModuloFactorial(11, 7))\n\tassert.Equal(t, uint64(1), newModuloFactorial(45, 7))\n\tassert.Equal(t, uint64(2), newModuloFactorial(14, 7))\n\tassert.Equal(t, uint64(3152), newModuloFactorial(1919, 10007))\n\tassert.Equal(t, uint64(3679), newModuloFactorial(810, 10007))\n\tassert.Equal(t, uint64(1), newModuloFactorial(1, 2))\n\tassert.Equal(t, uint64(10), newModuloFactorial(5, 11))\n\tassert.Equal(t, uint64(5), newModuloFactorial(6, 13))\n\tassert.Equal(t, uint64(13), newModuloFactorial(8, 17))\n\tassert.Equal(t, uint64(16), newModuloFactorial(15, 19))\n\tassert.Equal(t, uint64(1), newModuloFactorial(21, 23))\n\tassert.Equal(t, uint64(28), newModuloFactorial(30, 29))\n\tassert.Equal(t, uint64(100), newModuloFactorial(100, 101))\n}",
    "entry_point": "newModuloFactorial",
    "signature": "func newModuloFactorial(n, p uint64) uint64",
    "docstring": {
      "en": "Problem: New Modulo Operation \"⊕\".\nIn this operation, for x ⊕ y:\n- If x is not a multiple of y, the result is x % y.\n- If x is a multiple of y, keep dividing x by y (x = x / y) until x is no longer a multiple.\n  Let the final value be x'. The result is x' % y.\n\nExamples:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGiven a prime number p and an integer n, calculate the value of n! ⊕ p,\nwhere n! is the factorial of n (product of all positive integers ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6\n",
      "sq": "Problemë: Operacioni i Ri Modulo \"⊕\".\nNë këtë operacion, për x ⊕ y:\n- Nëse x nuk është shumëfish i y, rezultati është x % y.\n- Nëse x është shumëfish i y, vazhdoni të ndani x me y (x = x / y) derisa x të mos jetë më shumëfish.\n  Le të jetë vlera përfundimtare x'. Rezultati është x' % y.\n\nShembuj:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nDuke pasur një numër të thjeshtë p dhe një numër të plotë n, llogaritni vlerën e n! ⊕ p,\nku n! është faktoriali i n (prodhimi i të gjithë numrave të plotë pozitivë ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hy": "Խնդիր: Նոր Մոդուլո Գործողություն \"⊕\".\nԱյս գործողության մեջ, x ⊕ y-ի համար՝\n- Եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է։\n- Եթե x-ը y-ի բազմապատիկ է, շարունակեք բաժանել x-ը y-ի վրա (x = x / y), մինչև x-ը այլևս բազմապատիկ չլինի։\n  Թող վերջնական արժեքը լինի x': Արդյունքը x' % y է։\n\nՕրինակներ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nՏրված է պարզ թիվ p և ամբողջ թիվ n, հաշվեք n! ⊕ p-ի արժեքը,\nորտեղ n! n-ի ֆակտորիալն է (բոլոր դրական ամբողջ թվերի արտադրյալը ≤ n):\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bn": "সমস্যা: নতুন মডুলো অপারেশন \"⊕\"।\nএই অপারেশনে, x ⊕ y এর জন্য:\n- যদি x, y এর গুণিতক না হয়, তাহলে ফলাফল হবে x % y।\n- যদি x, y এর গুণিতক হয়, তাহলে x কে y দিয়ে ভাগ করতে থাকুন (x = x / y) যতক্ষণ না x আর গুণিতক থাকে।\n  চূড়ান্ত মানটিকে x' বলুন। ফলাফল হবে x' % y।\n\nউদাহরণসমূহ:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nএকটি মৌলিক সংখ্যা p এবং একটি পূর্ণসংখ্যা n দেওয়া আছে, n! ⊕ p এর মান গণনা করুন,\nযেখানে n! হল n এর ফ্যাক্টোরিয়াল (n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল)।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "bg": "Проблем: Нова операция за модул \"⊕\".\nВ тази операция, за x ⊕ y:\n- Ако x не е кратно на y, резултатът е x % y.\n- Ако x е кратно на y, продължавайте да делите x на y (x = x / y), докато x вече не е кратно.\n  Нека крайната стойност бъде x'. Резултатът е x' % y.\n\nПримери:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nДадено е просто число p и цяло число n, изчислете стойността на n! ⊕ p,\nкъдето n! е факториелът на n (произведение на всички положителни цели числа ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "zh": "问题：新的模运算 \"⊕\"。\n在此运算中，对于 x ⊕ y：\n- 如果 x 不是 y 的倍数，结果是 x % y。\n- 如果 x 是 y 的倍数，继续将 x 除以 y（x = x / y），直到 x 不再是倍数。\n  设最终值为 x'。结果是 x' % y。\n\n示例：\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\n给定一个素数 p 和一个整数 n，计算 n! ⊕ p 的值，\n其中 n! 是 n 的阶乘（所有小于等于 n 的正整数的乘积）。\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "fr": "Problème : Nouvelle opération de modulo \"⊕\".\nDans cette opération, pour x ⊕ y :\n- Si x n'est pas un multiple de y, le résultat est x % y.\n- Si x est un multiple de y, continuez à diviser x par y (x = x / y) jusqu'à ce que x ne soit plus un multiple.\n  Laissez la valeur finale être x'. Le résultat est x' % y.\n\nExemples :\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nÉtant donné un nombre premier p et un entier n, calculez la valeur de n! ⊕ p,\noù n! est la factorielle de n (produit de tous les entiers positifs ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "de": "Problem: Neue Modulo-Operation \"⊕\".\nIn dieser Operation, für x ⊕ y:\n- Wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n- Wenn x ein Vielfaches von y ist, teile x durch y (x = x / y), bis x kein Vielfaches mehr ist.\n  Der Endwert sei x'. Das Ergebnis ist x' % y.\n\nBeispiele:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nGegeben eine Primzahl p und eine ganze Zahl n, berechne den Wert von n! ⊕ p,\nwobei n! die Fakultät von n ist (Produkt aller positiven ganzen Zahlen ≤ n).\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "ha": "Matsala: Sabon Aiki na Modulo \"⊕\".  \nA cikin wannan aikin, don x ⊕ y:  \n- Idan x ba ya raba y, sakamakon shi ne x % y.  \n- Idan x yana raba y, ci gaba da raba x da y (x = x / y) har sai x ba ya raba y.  \n  Bari ƙimar ƙarshe ta zama x'. Sakamakon shi ne x' % y.  \n\nMisalai:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nAn ba da lamba mai firamare p da kuma cikakken lamba n, a lissafta ƙimar n! ⊕ p,  \ninda n! shine factorial na n (samfurin duk lambobin da suka fi ko daidai da n).  \n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hi": "समस्या: नया मॉड्यूलो ऑपरेशन \"⊕\"।\nइस ऑपरेशन में, x ⊕ y के लिए:\n- यदि x, y का गुणज नहीं है, तो परिणाम x % y है।\n- यदि x, y का गुणज है, तो x को y से विभाजित करते रहें (x = x / y) जब तक कि x अब गुणज न रहे।\n  अंतिम मान को x' मान लें। परिणाम x' % y है।\n\nउदाहरण:\n- 4⊕5 = 4\n- 20⊕5 = 4\n- 100⊕5 = 4\n\nएक अभाज्य संख्या p और एक पूर्णांक n दिए गए हैं, n! ⊕ p का मान गणना करें,\nजहाँ n! n का फैक्टोरियल है (सभी धनात्मक पूर्णांकों का गुणनफल जो n से कम या उसके बराबर हैं)।\n\n    >>> newModuloFactorial(3, 7)\n    6",
      "hu": "Probléma: Új Modulo Művelet \"⊕\".  \nEbben a műveletben, x ⊕ y esetén:  \n- Ha x nem osztható maradék nélkül y-nal, az eredmény x % y.  \n- Ha x osztható maradék nélkül y-nal, folyamatosan oszd el x-et y-nal (x = x / y), amíg x már nem osztható maradék nélkül.  \n  Legyen a végső érték x'. Az eredmény x' % y.  \n\nPéldák:  \n- 4⊕5 = 4  \n- 20⊕5 = 4  \n- 100⊕5 = 4  \n\nAdott egy prímszám p és egy egész szám n, számítsd ki az n! ⊕ p értékét,  \nahol n! az n faktoriálisa (az összes pozitív egész szám szorzata, amely ≤ n).  \n\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "sq": "0.9965056943368342",
      "hy": "0.9889058973280583",
      "bn": "0.9631894205258524",
      "bg": "0.9651824777691566",
      "zh": "0.9798882766594555",
      "fr": "0.9929418680403063",
      "de": "0.9866597849793158",
      "ha": "0.9352083587494677",
      "hi": "0.9733064603534834",
      "hu": "0.9482867789279479"
    }
  },
  {
    "task_id": "Go/34",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni të paktën një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë që të gjitha elementet në varg të jenë të barabarta.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն:\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由 n 个整数组成的数组 a。你可以最多执行一次操作，在该操作中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找出使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu einem Kostenaufwand von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba ku wani jerin a na lambobi n. Kuna iya aiwatar da akalla aiki daya inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin duk abubuwan daga a[i] zuwa a[j] da x, a kan farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nआपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहां आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i]-től az a[j]-ig terjedő összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n*/\nfunc makeEqualAgain(n int, a []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9906421254886844",
      "hy": "0.9762924708715809",
      "bn": "0.9962768721378821",
      "bg": "0.9882706773695088",
      "zh": "0.9870050045815545",
      "fr": "0.9986211078948558",
      "de": "0.9886329791845164",
      "ha": "0.9765340054149193",
      "hi": "0.9970827155937406",
      "hu": "0.9807477503181935"
    },
    "canonical_solution": "p, q, c, d := 1, 0, 0, 0\n\tk := n\n\tfor p = 1; p < k; p++ {\n\t\tif a[p] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor q = k - 1; q > p; q-- {\n\t\tif a[q] != a[p-1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor d = k - 2; d >= 0; d-- {\n\t\tif a[d] != a[d+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tfor c = 0; c < d; c++ {\n\t\tif a[c] != a[c+1] {\n\t\t\tbreak\n\t\t}\n\t}\n\tif q-p+1 < d-c+1 {\n\t\treturn q - p + 1\n\t}\n\treturn d - c + 1\n}",
    "instruction": {
      "en": "Write a Go function `func makeEqualAgain(n int, a []int) int` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n",
      "sq": "Shkruani një funksion Go `func makeEqualAgain(n int, a []int) int` për të zgjidhur problemin në vijim:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hy": "Գրեք Go ֆունկցիա `func makeEqualAgain(n int, a []int) int` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j] բոլոր տարրերը x-ով, արժեքով (j - i + 1):\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "bn": "Go ফাংশন `func makeEqualAgain(n int, a []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের করুন।",
      "bg": "Напишете Go функция `func makeEqualAgain(n int, a []int) int`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "zh": "编写一个 Go 函数 `func makeEqualAgain(n int, a []int) int` 来解决以下问题：\n给定一个包含 n 个整数的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "fr": "Écrire une fonction Go `func makeEqualAgain(n int, a []int) int` pour résoudre le problème suivant :  \nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1).  \nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.  \n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "de": "Schreiben Sie eine Go-Funktion `func makeEqualAgain(n int, a []int) int`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "ha": "Rubuta aikin Go `func makeEqualAgain(n int, a []int) int` don warware matsalar mai zuwa:\nAn baka wani tsari a na lambobi n. Zaka iya aiwatar da akalla aiki daya inda zaka zabi lambobi uku i, j, x (1 <= i <= j <= n) kuma ka maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan kudin (j - i + 1).\nNemo mafi karancin kudi don sanya dukkan abubuwa a cikin jerin su zama daidai.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hi": "Go फ़ंक्शन `func makeEqualAgain(n int, a []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।",
      "hu": "Írj egy Go függvényt `func makeEqualAgain(n int, a []int) int`, hogy megoldja a következő problémát:\nAdott egy a tömb n egész számmal. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1"
    },
    "instruction_bertscore": {
      "sq": "0.9968284687060159",
      "hy": "0.9691125784883128",
      "bn": "0.909624169781031",
      "bg": "0.9988699917622925",
      "zh": "0.9854223177054685",
      "fr": "0.9977771274058386",
      "de": "0.988835780803553",
      "ha": "0.9801973455323458",
      "hi": "0.9231322274736896",
      "hu": "0.9710533959414047"
    },
    "level": "middle",
    "test": "func TestMakeEqualAgain(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, makeEqualAgain(3, []int{1, 2, 1}))\n\tassert.Equal(1, makeEqualAgain(5, []int{5, 5, 1, 5, 5}))\n\tassert.Equal(0, makeEqualAgain(4, []int{1, 1, 1, 1}))\n\tassert.Equal(1, makeEqualAgain(6, []int{2, 2, 2, 3, 2, 2}))\n\tassert.Equal(0, makeEqualAgain(1, []int{1}))\n\tassert.Equal(1, makeEqualAgain(2, []int{1, 2}))\n\tassert.Equal(2, makeEqualAgain(4, []int{1, 2, 2, 1}))\n\tassert.Equal(2, makeEqualAgain(7, []int{4, 4, 4, 3, 3, 4, 4}))\n\tassert.Equal(3, makeEqualAgain(6, []int{5, 4, 4, 4, 5, 5}))\n\tassert.Equal(5, makeEqualAgain(7, []int{1, 2, 1, 2, 1, 2, 1}))\n\tassert.Equal(4, makeEqualAgain(6, []int{1, 2, 3, 4, 5, 1}))\n\tassert.Equal(0, makeEqualAgain(7, []int{1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(2, makeEqualAgain(8, []int{8, 8, 8, 1, 2, 8, 8, 8}))\n\tassert.Equal(2, makeEqualAgain(3, []int{1, 2, 3}))\n\tassert.Equal(6, makeEqualAgain(7, []int{4, 3, 2, 7, 1, 1, 3}))\n\tassert.Equal(7, makeEqualAgain(9, []int{9, 9, 2, 9, 2, 5, 5, 5, 3}))\n}",
    "entry_point": "makeEqualAgain",
    "signature": "func makeEqualAgain(n int, a []int) int",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1\n",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1).\nGjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hy": "Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը x-ով՝ արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար։\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "bg": "Даден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "zh": "你有一个包含 n 个整数的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找到使数组中所有元素相等的最小代价。\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "fr": "Vous disposez d'un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1).\nFinde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "ha": "An ba ku wani tsari a na lambobi n. Kuna iya yin aiki ɗaya kawai inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwa a cikin tsari su zama daidai.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hi": "आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1",
      "hu": "Meg van adva egy `a` tömb, amely `n` egész számot tartalmaz. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot `i`, `j`, `x` (1 <= i <= j <= n), és az `a[i]`-től `a[j]`-ig terjedő összes elemet `x`-szel helyettesíted, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen.\n    >>> makeEqualAgain(3, []int{1, 2, 1})\n    1\n    >>> makeEqualAgain(5, []int{5, 5, 1, 5, 5})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9958786182239071",
      "hy": "0.9564449259378128",
      "bn": "0.9968525029821211",
      "bg": "0.9876114231348541",
      "zh": "0.9886035818881233",
      "fr": "0.9927418472466042",
      "de": "0.9853247901883804",
      "ha": "0.9717640954447475",
      "hi": "0.9862208118372288",
      "hu": "0.9275499657782866"
    }
  },
  {
    "task_id": "Go/35",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh,\npërcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, duke marrë radhën me Dan për të lëvizur\nnjë numër pozitiv gurësh nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Lojtari i detyruar të\nlëvizë gurët vetëm në grumbullin e fundit humbet. Duke supozuar lojë optimale, gjeni fituesin.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրը պարունակում է քարերի դրական քանակ,\nորոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Չարլին առաջինն է գնում, հերթով Դանի հետ տեղափոխելով\nքարերի դրական քանակ ձախից աջ հարևան կույտ: Խաղացողը, որը ստիպված է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով օպտիմալ խաղ, պարզեք հաղթողին:\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n১ থেকে N পর্যন্ত নম্বরযুক্ত Nটি পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে,\nচার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, ড্যানের সাথে পালা করে\nবামদিকের প্রথম খালি না হওয়া স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরাতে। যে খেলোয়াড়কে\nশুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয় সে হেরে যায়। সর্বোত্তম খেলার অনুমান করে, বিজয়ী নির্ধারণ করুন।\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни,\nопределете победителя в игра, играна от Чарли и Дан. Чарли започва пръв, като се редува с Дан да премества\nположителен брой камъни от най-лявата непразна купчина към съседната дясна купчина. Играчът, който е принуден\nда премества камъни само в последната купчина, губи. Приемайки оптимална игра, определете победителя.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个从1到N编号的N堆石头的序列，每堆包含一个正数的石头，\n确定由Charlie和Dan进行的游戏的赢家。Charlie先开始，与Dan轮流移动\n从最左边非空堆到相邻右边堆的正数石头。被迫只能在最后一堆移动石头的玩家输掉比赛。\n假设最佳玩法，找出赢家。\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres,\ndéterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, en alternant avec Dan pour déplacer\nun nombre positif de pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Le joueur forcé de\nne déplacer des pierres que dans le dernier tas perd. En supposant un jeu optimal, trouvez le gagnant.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält,\nbestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, abwechselnd mit Dan,\neine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen zu bewegen.\nDer Spieler, der gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert. Angenommen, es wird optimal gespielt,\nfinden Sie heraus, wer der Gewinner ist.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne dauke da adadi mai kyau na duwatsu,\ntantance wanda ya yi nasara a wasan da Charlie da Dan suka buga. Charlie ne zai fara, suna juyawa da Dan don motsa\nwani adadi mai kyau na duwatsu daga mafi hagu tarin da ba komai ba zuwa tarin da ke kusa da shi a dama. Dan wasan da aka tilasta\nmotsa duwatsu a cikin tarin karshe kawai ya yi rashin nasara. Idan aka yi la'akari da wasa mafi kyau, gano wanda ya yi nasara.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदी गई N पत्थरों के ढेरों की अनुक्रमणिका, जिन्हें 1 से N तक गिना गया है, प्रत्येक में सकारात्मक संख्या में पत्थर हैं,\nचार्ली और डैन द्वारा खेले गए खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, डैन के साथ बारी-बारी से\nबाईं ओर के सबसे पहले गैर-खाली ढेर से दाईं ओर के सटे हुए ढेर में सकारात्मक संख्या में पत्थर ले जाता है। \nजिस खिलाड़ी को केवल अंतिम ढेर में पत्थर ले जाने के लिए मजबूर किया जाता है, वह हार जाता है। \nसर्वोत्तम खेल मानते हुए, विजेता का पता लगाएं।\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz,\nhatározd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd először, és felváltva Dan-nel\npozitív számú követ mozgatnak a legbaloldalibb nem üres halomból a szomszédos jobb halomba. Az a játékos, akit\narra kényszerítenek, hogy csak az utolsó halomban mozgasson köveket, veszít. Feltételezve az optimális játékot, derítsd ki, ki a győztes.\n\t>>> GameWinner(3, []int{1, 2, 2})\n\t\"Dan\"\n*/\nfunc GameWinner(n int, piles []int) string {"
    },
    "prompt_bertscore": {
      "sq": "0.9869015181530353",
      "hy": "0.9732824260773782",
      "bn": "0.9631993520449041",
      "bg": "0.9830026024037015",
      "zh": "0.9736212895074238",
      "fr": "0.9792681526098646",
      "de": "0.9610442124106756",
      "ha": "0.968123200560378",
      "hi": "0.9617668297368805",
      "hu": "0.9637404212028432"
    },
    "canonical_solution": "if n == 2 { // With only two piles, Charlie always wins.\n\t\treturn \"Charlie\"\n\t}\n\tif piles[0] == 1 { // If the first pile has only one stone, Dan wins.\n\t\treturn \"Dan\"\n\t}\n\treturn \"Charlie\" // In all other scenarios, Charlie wins.\n}",
    "instruction": {
      "en": "Write a Go function `func GameWinner(n int, piles []int) string` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "sq": "Shkruani një funksion Go `func GameWinner(n int, piles []int) string` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej N grumbujsh gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh,\npërcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, duke marrë radhën me Dan për të lëvizur\nnjë numër pozitiv gurësh nga grumbulli më i majtë jo-bosh në grumbullin fqinjë në të djathtë. Lojtari i detyruar të\nlëvizë gurët vetëm në grumbullin e fundit humbet. Duke supozuar lojë optimale, gjeni fituesin.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hy": "Գրեք Go ֆունկցիա `func GameWinner(n int, piles []int) string`՝ լուծելու հետևյալ խնդիրը:\nՏրված է N քարերի կույտերի հաջորդականություն, համարակալված 1-ից N, որոնցից յուրաքանչյուրը պարունակում է քարերի դրական քանակ,\nորոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Չարլին առաջինն է սկսում, հերթափոխով Դենի հետ տեղափոխելով\nդրական քանակի քարեր ձախից առաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Խաղացողը, որը ստիպված է\nմիայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով օպտիմալ խաղ, պարզեք հաղթողին:\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "bn": "Go ফাংশন `func GameWinner(n int, piles []int) string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রত্যেকটি পাথরের একটি ধনুক N পাথরের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রত্যেকটিতে একটি ধনাত্মক সংখ্যক পাথর রয়েছে,\nচার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, ড্যানের সাথে পালাক্রমে বাঁয়ে সবচেয়ে বাম নন-খালি ধনুক থেকে ডানপাশের সংলগ্ন ধনুকে একটি ধনাত্মক সংখ্যক পাথর সরিয়ে নেয়। যে খেলোয়াড়কে শুধুমাত্র শেষ ধনুকে পাথর সরাতে বাধ্য করা হয় সে হেরে যায়। সর্বোত্তম খেলার ধরণ ধরে নিয়ে, বিজয়ী নির্ধারণ করুন।\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "bg": "Напишете Go функция `func GameWinner(n int, piles []int) string`, за да решите следния проблем:  \nДадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни,  \nопределете победителя в игра, играна от Чарли и Дан. Чарли започва пръв, като се редува с Дан да премества  \nположителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, принуден да  \nпремества камъни само в последната купчина, губи. Приемайки оптимална игра, намерете победителя.  \n    >>> GameWinner(3, []int{1, 2, 2})  \n    \"Dan\"",
      "zh": "编写一个 Go 函数 `func GameWinner(n int, piles []int) string` 来解决以下问题：\n给定一个编号从 1 到 N 的石堆序列，每个石堆包含正数个石头，确定由 Charlie 和 Dan 玩的游戏的获胜者。Charlie 先开始，与 Dan 轮流移动正数个石头从最左边的非空堆到相邻的右边堆。被迫只能在最后一个堆中移动石头的玩家输掉游戏。在假设最优玩法的情况下，找出获胜者。\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "fr": "Écrire une fonction Go `func GameWinner(n int, piles []int) string` pour résoudre le problème suivant :  \nÉtant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres,  \ndéterminer le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer  \nun nombre positif de pierres de la pile la plus à gauche non vide vers la pile adjacente à droite. Le joueur forcé  \nde ne déplacer des pierres que dans la dernière pile perd. En supposant un jeu optimal, déterminez le gagnant.  \n    >>> GameWinner(3, []int{1, 2, 2})  \n    \"Dan\"",
      "de": "Schreiben Sie eine Go-Funktion `func GameWinner(n int, piles []int) string`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab, um eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen zu bewegen. Der Spieler, der gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert. Angenommen, es wird optimal gespielt, finden Sie den Gewinner heraus.",
      "ha": "Rubuta aikin Go `func GameWinner(n int, piles []int) string` don warware matsalar mai zuwa:\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne dauke da adadin duwatsu masu kyau,\ngano wanda ya lashe wasan da Charlie da Dan suka buga. Charlie ne ke fara wasa, yana juyawa da Dan don motsa\nwani adadi mai kyau na duwatsu daga mafi hagu wanda ba komai a ciki zuwa makwabcin tarin dama. Dan wasan da aka tilasta\nmotsa duwatsu a cikin tarin karshe kadai ya yi asara. Idan aka yi wasa cikin hikima, gano wanda zai yi nasara.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hi": "Go फ़ंक्शन `func GameWinner(n int, piles []int) string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पत्थरों के N ढेरों की एक अनुक्रमणिका, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है,\nCharlie और Dan द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। Charlie पहले जाता है, Dan के साथ बारी-बारी से\nबाएँ से दाएँ सबसे निकटतम गैर-खाली ढेर से एक सकारात्मक संख्या में पत्थरों को दाएँ के निकटतम ढेर में ले जाता है। खिलाड़ी जो केवल अंतिम ढेर में पत्थरों को ले जाने के लिए मजबूर होता है, हार जाता है। इष्टतम खेल मानते हुए, विजेता का पता लगाएं।\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hu": "Írj egy Go függvényt `func GameWinner(n int, piles []int) string` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, 1-től N-ig számozva, mindegyik pozitív számú követ tartalmaz,\nhatározd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, és felváltva következik Dan, hogy\npozitív számú követ mozgasson a baloldali nem üres halomból a szomszédos jobb halomba. Az a játékos veszít,\naki kénytelen csak az utolsó halomban köveket mozgatni. Feltételezve az optimális játékot, derítsd ki, ki a győztes.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\""
    },
    "instruction_bertscore": {
      "sq": "0.983984829637919",
      "hy": "0.9374423546449672",
      "bn": "0.9758139702836679",
      "bg": "0.9856690166387139",
      "zh": "0.9721200410875621",
      "fr": "0.9826252046797352",
      "de": "0.9182918037182505",
      "ha": "0.9505467954033628",
      "hi": "0.9569041593787655",
      "hu": "0.9569508375183087"
    },
    "level": "middle",
    "test": "func TestGameWinner(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(\"Dan\", GameWinner(3, []int{1, 2, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(5, []int{5, 5, 5, 5, 5}))\n\tassert.Equal(\"Charlie\", GameWinner(3, []int{2, 1, 2}))\n\tassert.Equal(\"Charlie\", GameWinner(4, []int{3, 3, 3, 3}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(2, []int{2, 1}))\n\tassert.Equal(\"Dan\", GameWinner(11, []int{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{2, 2, 2, 2, 2, 2, 2, 2, 2, 1}))\n\tassert.Equal(\"Charlie\", GameWinner(10, []int{10, 10, 10, 10, 10, 10, 10, 10, 10, 10}))\n\tassert.Equal(\"Dan\", GameWinner(10, []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}))\n}",
    "entry_point": "GameWinner",
    "signature": "func GameWinner(n int, piles []int) string",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\ndetermine the winner of a game played by Charlie and Dan. Charlie goes first, taking turns with Dan to move\na positive number of stones from the leftmost non-empty pile to the adjacent right pile. The player forced to\nonly move stones in the last pile loses. Assuming optimal play, find out the winner.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon i pari, duke marrë radhën me Dan për të lëvizur një numër pozitiv gurësh nga grumbulli më i majtë jo-bosh në grumbullin fqinj në të djathtë. Lojtari i detyruar të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë optimale, gjeni fituesin.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hy": "Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրը պարունակում է դրական քանակությամբ քարեր, որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Չարլին առաջինն է խաղում, հերթափոխով Դանի հետ, տեղափոխելով դրական քանակությամբ քարեր ձախից առաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Խաղացողը, որը ստիպված է տեղափոխել քարերը միայն վերջին կույտում, պարտվում է: Ենթադրելով օպտիմալ խաղ, պարզեք հաղթողին:\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "bn": "একটি N সংখ্যক পাথরের স্তূপের ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি প্রথমে যায়, ড্যানের সাথে পালা করে বাম দিকের প্রথম খালি নয় এমন স্তূপ থেকে ডান পাশের সংলগ্ন স্তূপে একটি ধনাত্মক সংখ্যক পাথর সরায়। যে খেলোয়াড়কে শুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয় সে হারে। সর্বোত্তম খেলার অনুমান করে, বিজয়ী কে তা খুঁজে বের করুন।\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва първи, като се редува с Дан да премества положителен брой камъни от най-лявата непразна купчина в съседната дясна купчина. Играчът, принуден да премества камъни само в последната купчина, губи. При оптимална игра, определете победителя.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定由Charlie和Dan进行的游戏的赢家。Charlie先开始，轮流与Dan移动正数个石头从最左边的非空堆到相邻的右边堆。被迫只能在最后一堆移动石头的玩家输掉比赛。在假设最佳玩法的情况下，找出赢家。\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer un nombre positif de pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Le joueur forcé de ne déplacer des pierres que dans le dernier tas perd. En supposant un jeu optimal, trouvez le gagnant.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab, um eine positive Anzahl von Steinen vom linken, nicht leeren Haufen zum benachbarten rechten Haufen zu bewegen. Der Spieler, der gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert. Angenommen, es wird optimal gespielt, finden Sie den Gewinner heraus.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "ha": "An ba da jerin N na tarin duwatsu da aka lissafa daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, a tantance wanda zai yi nasara a wasan da Charlie da Dan suka buga. Charlie ne zai fara, yana yin juyi tare da Dan don motsa adadin duwatsu masu kyau daga tarin farko da ba komai ba zuwa tarin da ke kusa da shi a dama. Dan wasan da aka tilasta shi don kawai motsa duwatsu a cikin tarin karshe zai yi rashin nasara. Idan aka yi wasa da hikima, gano wanda zai yi nasara.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hi": "N पत्थरों के ढेरों की एक अनुक्रमणिका दी गई है, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में सकारात्मक संख्या में पत्थर हैं, चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली पहले जाता है, डैन के साथ बारी-बारी से बाएँ से सबसे पहले गैर-खाली ढेर से दाएँ के समीपवर्ती ढेर में एक सकारात्मक संख्या में पत्थर ले जाता है। वह खिलाड़ी जिसे केवल अंतिम ढेर में पत्थर ले जाने के लिए मजबूर किया जाता है, हार जाता है। इष्टतम खेल मानते हुए, विजेता का पता लगाएं।\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\"",
      "hu": "Adott egy N kőhalomból álló sorozat, amelyeket 1-től N-ig számoztak, és mindegyik pozitív számú követ tartalmaz. Határozzuk meg a győztest egy Charlie és Dan által játszott játékban. Charlie kezd, és Dan-nel felváltva lépnek, hogy egy pozitív számú követ mozgassanak a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. Az a játékos veszít, akit arra kényszerítenek, hogy csak az utolsó halomban mozgassa a köveket. Feltételezve az optimális játékot, derítsük ki, ki a győztes.\n    >>> GameWinner(3, []int{1, 2, 2})\n    \"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.9821977520997481",
      "hy": "0.9605261843769367",
      "bn": "0.9456588989868563",
      "bg": "0.9709387862115476",
      "zh": "0.9633664001953546",
      "fr": "0.9820555327469271",
      "de": "0.9322737935000583",
      "ha": "0.9011003442396809",
      "hi": "0.9357589621656964",
      "hu": "0.9527992639242985"
    }
  },
  {
    "task_id": "Go/36",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përballë derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլում խաղացողը կարող է ընտրել մի թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այն դիրքում դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրը կայանում է որոշելու բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nnটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি টার্নে, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে যেতে এবং তারপর সেই অবস্থানের দরজা খুলতে C_i খরচ দিতে হবে। এটি গ্যারান্টি দেওয়া হয় যে C_i >= C_{i+1} 1 <= i < n এর জন্য।\nসকল দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定 n 个门按圆形排列，玩家从门 1 前开始。每一轮，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben sind n Türen, die in einem Kreis angeordnet sind. Der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kostenaufwand C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba n kofofi da aka shirya a cikin da'ira, dan wasan yana farawa a gaban kofa ta 1. Kowanne juyi, dan wasan zai iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama sannan ya buɗe kofa a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk kofofin.\n\nMisali:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} के लिए 1 <= i < n।\nकार्य यह है कि सभी दरवाजे खोलने के लिए आवश्यक न्यूनतम कुल लागत निर्धारित करें।\n\nउदाहरण:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és kifizethet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk az összes ajtó kinyitásához szükséges minimális összköltséget.\n\nPélda:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n*/\nfunc MinTotalCost(n int, C []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9892227127858091",
      "hy": "0.9768818072121115",
      "bn": "0.9769511292150926",
      "bg": "0.9877965466499785",
      "zh": "0.9913470647109771",
      "fr": "0.9977493191524937",
      "de": "0.9818733886875182",
      "ha": "0.9869477990318165",
      "hi": "0.9796906394303257",
      "hu": "0.9813227852712895"
    },
    "canonical_solution": "return int64(C[n-2]) * int64(n-1) + int64(C[n-1])\n}",
    "instruction": {
      "en": "Write a Go function `func MinTotalCost(n int, C []int) int64` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n",
      "sq": "Shkruani një funksion Go `func MinTotalCost(n int, C []int) int64` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1. Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja minimale totale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hy": "Գրեք Go ֆունկցիա `func MinTotalCost(n int, C []int) int64`՝ լուծելու հետևյալ խնդիրը:\nՏրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այնուհետև այդ դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1}՝ 1 <= i < n-ի համար:\nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "bn": "একটি Go ফাংশন `func MinTotalCost(n int, C []int) int64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবৃত্তাকারে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে এবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "bg": "Напишете Go функция `func MinTotalCost(n int, C []int) int64`, за да решите следния проблем:  \nДадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:  \n    >>> MinTotalCost(3, []int{1, 1, 1})  \n    3  ",
      "zh": "编写一个 Go 函数 `func MinTotalCost(n int, C []int) int64` 来解决以下问题：\n\n给定 n 个门按圆形排列，玩家从门 1 前面开始。每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开当前位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n\n任务是确定打开所有门所需的最小总代价。\n\n示例:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "fr": "Écrire une fonction Go `func MinTotalCost(n int, C []int) int64` pour résoudre le problème suivant :\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "de": "Schreiben Sie eine Go-Funktion `func MinTotalCost(n int, C []int) int64`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, und der Spieler beginnt vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n gilt.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "ha": "Rubuta aikin Go `func MinTotalCost(n int, C []int) int64` don warware matsalar mai zuwa:\nAn ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasan yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasan zai iya zaɓar lamba i kuma ya biya kuɗin C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\nAikin shi ne ƙayyade mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hi": "Go फ़ंक्शन `func MinTotalCost(n int, C []int) int64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} के लिए 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hu": "Írj egy Go függvényt `func MinTotalCost(n int, C []int) int64` a következő probléma megoldására:\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az adott pozícióban lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9960736732580834",
      "hy": "0.9819482723411683",
      "bn": "0.9636901677164414",
      "bg": "0.9809356546586525",
      "zh": "0.984918193798402",
      "fr": "0.9934914783046298",
      "de": "0.9807711887031556",
      "ha": "0.9948961923593086",
      "hi": "0.9614345211094092",
      "hu": "0.9736477073481014"
    },
    "level": "easy",
    "test": "func TestMinTotalCost(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(15), MinTotalCost(5, []int{4, 3, 3, 3, 3})) // Note the 0-indexed array for slice in Golang\n\tassert.Equal(int64(3), MinTotalCost(3, []int{1, 1, 1}))\n\tassert.Equal(int64(11), MinTotalCost(4, []int{5, 4, 3, 2}))\n\tassert.Equal(int64(391), MinTotalCost(4, []int{100, 99, 98, 97}))\n\tassert.Equal(int64(35), MinTotalCost(6, []int{10, 9, 8, 7, 6, 5}))\n\tassert.Equal(int64(14), MinTotalCost(7, []int{2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(56), MinTotalCost(8, []int{9, 7, 7, 7, 7, 7, 7, 7}))\n\tassert.Equal(int64(18), MinTotalCost(9, []int{3, 2, 2, 2, 2, 2, 2, 2, 2}))\n\tassert.Equal(int64(50), MinTotalCost(10, []int{6, 5, 5, 5, 5, 5, 5, 5, 5, 5}))\n\tassert.Equal(int64(11), MinTotalCost(11, []int{8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}))\n}",
    "entry_point": "MinTotalCost",
    "signature": "func MinTotalCost(n int, C []int) int64",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1. Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3\n",
      "sq": "Duke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përpara derës 1. Në çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n. Detyra është të përcaktohet kostoja minimale totale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց։ Ամեն քայլափոխի, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ աջ գնալու i քայլ և այնուհետև բացելու այդ դիրքի դուռը։ Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար։  \nԽնդիրը կայանում է որոշել բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը։\n\nՕրինակ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "bn": "নিচে n দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে এবং তারপর সেই অবস্থানে দরজা খুলতে C_i খরচ দিতে পারে। এটি নিশ্চিত করা হয়েছে যে C_i >= C_{i+1} যেখানে 1 <= i < n। কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. Всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n. Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "zh": "给定 n 个门按圆形排列，玩家从门 1 前面开始。每一轮，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.  \nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "ha": "An ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowace juyawa, ɗan wasan zai iya zaɓar wani lamba i kuma ya biya wani farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shi ne a tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hi": "दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह सुनिश्चित है कि C_i >= C_{i+1} जहाँ 1 <= i < n। कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd. Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést jobbra lépjen, majd kinyissa az adott pozícióban lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat az, hogy meghatározzuk a minimális összköltséget, amely szükséges az összes ajtó kinyitásához.\n\nPélda:\n    >>> MinTotalCost(3, []int{1, 1, 1})\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9926190936711246",
      "hy": "0.9759420868794354",
      "bn": "0.9713618689231519",
      "bg": "1",
      "zh": "0.9911859754719579",
      "fr": "0.9975091750218225",
      "de": "0.9879163207697426",
      "ha": "0.9859308114809179",
      "hi": "0.9641358942914837",
      "hu": "0.978109541597288"
    }
  },
  {
    "task_id": "Go/37",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ձեռքսեղմումների ընդհանուր քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի արդեն դասարանում գտնվող յուրաքանչյուր ուսանողի հետ, որի ID համարը փոքր է։ Հաջորդականությունը ներկայացնում է ուսանողների դասարան մտնելու կարգը։\n\nՕրինակներ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nশ্রেণীকক্ষে প্রবেশ করা শিক্ষার্থীদের একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত রয়েছে, মোট কতগুলি করমর্দন ঘটে তা গণনা করুন। প্রতিটি শিক্ষার্থী ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি শিক্ষার্থীর সাথে করমর্দন করবে যার আইডি নম্বর ছোট। ক্রমটি শিক্ষার্থীরা শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е последователност от студентски ID-та, които влизат в класна стая, където ID-тата варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък ID номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中所有ID号较小的学生握手。序列表示学生进入教室的顺序。\n\n例子:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Student wird jedem Studenten die Hand schütteln, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da jerin lambobin dalibai da ke shiga aji, inda lambobin ke daga 0 zuwa N-1, a ƙididdige jimillar yawan gaisuwar hannu da ke faruwa. Kowanne dalibi zai gaisa da kowanne dalibi da ke cikin aji wanda ke da ƙaramin lamba. Jerin yana wakiltar tsarin da dalibai ke shiga aji.\n\nMisalai:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nछात्र आईडी के अनुक्रम को एक कक्षा में प्रवेश करते हुए दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हाथ मिलाने की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी नंबर के साथ हैं। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy osztályterembe belépő diákok azonosítóinak sorozata adott, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások összesített számát. Minden diák kezet fog minden olyan diákkal, aki már bent van az osztályteremben és kisebb azonosítóval rendelkezik. A sorozat azt a sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n*/\nfunc CountHandshakes(n int, order []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9969109003141454",
      "hy": "0.9828321775367735",
      "bn": "0.965954156799477",
      "bg": "0.9969109003141454",
      "zh": "0.9864943258719138",
      "fr": "0.9960283855312074",
      "de": "0.9930948134337031",
      "ha": "0.9508731451194031",
      "hi": "0.9605925269242023",
      "hu": "0.9704314842183844"
    },
    "canonical_solution": "var ans int64 = 0\n\ttr := make([]int, 10000) // N should be defined as a constant representing the maximum possible value of n\n\tfor i := 0; i < 10000; i++ {\n\t\ttr[i] = 0\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tx := order[i] + 1 // Convert 0-indexed to 1-indexed\n\t\tfor j := x - 1; j > 0; j -= j & (-j) {\n\t\t\tans += int64(tr[j])\n\t\t}\n\t\tfor j := x; j <= n; j += j & (-j) {\n\t\t\ttr[j]++\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func CountHandshakes(n int, order []int) int64` to solve the following problem:\nGiven a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n",
      "sq": "Shkruani një funksion Go `func CountHandshakes(n int, order []int) int64` për të zgjidhur problemin në vijim:  \nDuke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hy": "Գրեք Go ֆունկցիա `func CountHandshakes(n int, order []int) int64`՝ հետևյալ խնդիրը լուծելու համար:\nՈւնենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջ ձեռքսեղմումների քանակը։ Յուրաքանչյուր ուսանող ձեռք կսեղմի դասարանում արդեն գտնվող յուրաքանչյուր ուսանողի հետ, որի ID-ն ավելի փոքր է։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "bn": "একটি Go ফাংশন `func CountHandshakes(n int, order []int) int64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nশ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির একটি ক্রম দেওয়া হয়েছে, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত। মোট কতগুলি হ্যান্ডশেক ঘটে তা গণনা করুন। প্রতিটি ছাত্র তাদের চেয়ে ছোট আইডি নম্বর সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করবে। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\nউদাহরণ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "bg": "Напишете Go функция `func CountHandshakes(n int, order []int) int64`, за да решите следния проблем:  \nДадена е последователност от идентификатори на ученици, влизащи в класната стая, където идентификаторите варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки ученик ще се ръкува с всеки ученик, който вече е в класната стая с по-малък идентификатор. Последователността представлява реда, в който учениците влизат в класната стая.\n\nПримери:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "zh": "编写一个 Go 函数 `func CountHandshakes(n int, order []int) int64` 来解决以下问题：  \n给定一个进入教室的学生 ID 序列，其中 ID 范围从 0 到 N-1，计算发生的握手总数。每个学生将与教室中已经存在的 ID 较小的每个学生握手。序列表示学生进入教室的顺序。  \n\n示例:  \n    >>> CountHandshakes(3, []int{2, 1, 0})  \n    0  ",
      "fr": "Écrire une fonction Go `func CountHandshakes(n int, order []int) int64` pour résoudre le problème suivant :  \nÉtant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :  \n    >>> CountHandshakes(3, []int{2, 1, 0})  \n    0  ",
      "de": "Schreiben Sie eine Go-Funktion `func CountHandshakes(n int, order []int) int64`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von Schüler-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen. Berechnen Sie die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Schüler wird jedem Schüler die Hand schütteln, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Schüler den Klassenraum betreten.\n\nBeispiele:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "ha": "Rubuta aikin Go `func CountHandshakes(n int, order []int) int64` don warware matsalar mai zuwa:  \nAn ba da jerin lambar ID na ɗalibai suna shiga aji, inda lambobin ID ke tsakanin 0 zuwa N-1, lissafa jimillar yawan musabaha da ke faruwa. Kowanne ɗalibi zai yi musabaha da kowane ɗalibi da ke cikin aji wanda ke da lambar ID ƙasa da tasa. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.",
      "hi": "गो फ़ंक्शन `func CountHandshakes(n int, order []int) int64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक कक्षा में प्रवेश करने वाले छात्र आईडी की अनुक्रमणिका दी गई है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हैंडशेक की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों के साथ हैंडशेक करेगा जो पहले से ही कक्षा में छोटे आईडी नंबर के साथ हैं। अनुक्रमणिका यह दर्शाती है कि छात्र किस क्रम में कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hu": "Írj egy Go függvényt `func CountHandshakes(n int, order []int) int64` a következő probléma megoldására:  \nAdott egy diákazonosító sorozat, amely egy osztályterembe belépő diákokat jelöl, ahol az azonosítók 0-tól N-1-ig terjednek. Számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden olyan diákkal, aki már az osztályteremben van, és kisebb azonosítóval rendelkezik. A sorozat azt az sorrendet jelenti, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0"
    },
    "instruction_bertscore": {
      "sq": "0.9906504679646878",
      "hy": "0.9777377055239908",
      "bn": "0.9602355881294826",
      "bg": "0.9842003436013419",
      "zh": "0.9888312123047893",
      "fr": "0.9970835101152647",
      "de": "0.9781085484453829",
      "ha": "0.9291270910037036",
      "hi": "0.9724346716111213",
      "hu": "0.9662749448648484"
    },
    "level": "hard",
    "test": "func TestCountHandshakes(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), CountHandshakes(4, []int{2, 1, 3, 0}))\n\tassert.Equal(int64(15), CountHandshakes(6, []int{0, 1, 2, 3, 4, 5}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{1, 2, 0}))\n\tassert.Equal(int64(0), CountHandshakes(4, []int{3, 2, 1, 0}))\n\tassert.Equal(int64(6), CountHandshakes(4, []int{0, 1, 2, 3}))\n\tassert.Equal(int64(0), CountHandshakes(6, []int{5, 4, 3, 2, 1, 0}))\n\tassert.Equal(int64(5), CountHandshakes(4, []int{0, 2, 1, 3}))\n\tassert.Equal(int64(3), CountHandshakes(5, []int{3, 1, 4, 2, 0}))\n\tassert.Equal(int64(4), CountHandshakes(4, []int{1, 0, 3, 2}))\n\tassert.Equal(int64(1), CountHandshakes(3, []int{2, 0, 1}))\n\tassert.Equal(int64(7), CountHandshakes(5, []int{1, 3, 0, 2, 4}))\n\tassert.Equal(int64(0), CountHandshakes(5, []int{4, 3, 2, 1, 0}))\n}\n\n// To run tests in Go, you can use the following command:\n// go test -v",
    "entry_point": "CountHandshakes",
    "signature": "func CountHandshakes(n int, order []int) int64",
    "docstring": {
      "en": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Each student will shake hands with every student already in the classroom with a smaller ID number. The sequence represents the order in which students enter the classroom.\n\nExamples:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0\n",
      "sq": "Duke pasur një sekuencë të ID-ve të studentëve që hyjnë në një klasë, ku ID-të variojnë nga 0 deri në N-1, llogaritni numrin total të shtrëngimeve të duarve që ndodhin. Çdo student do të shtrëngojë duart me çdo student që tashmë është në klasë me një numër ID më të vogël. Sekuenca përfaqëson rendin në të cilin studentët hyjnë në klasë.\n\nShembuj:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hy": "Ունենալով ուսանողների ID-ների հաջորդականություն, որոնք մտնում են դասարան, որտեղ ID-ները տատանվում են 0-ից մինչև N-1, հաշվեք տեղի ունեցող ողջունումների ընդհանուր թիվը։ Յուրաքանչյուր ուսանող ողջունում է բոլոր այն ուսանողներին, որոնք արդեն դասարանում են և ունեն ավելի փոքր ID։ Հաջորդականությունը ներկայացնում է այն կարգը, որով ուսանողները մտնում են դասարան։\n\nՕրինակներ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "bn": "প্রদত্ত একটি শ্রেণীকক্ষে প্রবেশ করা ছাত্রদের আইডির ক্রম, যেখানে আইডিগুলি 0 থেকে N-1 পর্যন্ত বিস্তৃত, মোট কতগুলি করমর্দন ঘটে তা গণনা করুন। প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে উপস্থিত প্রতিটি ছাত্রের সাথে করমর্দন করবে যার আইডি নম্বর ছোট। ক্রমটি ছাত্রদের শ্রেণীকক্ষে প্রবেশের ক্রম নির্দেশ করে।\n\nউদাহরণ:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "bg": "Дадена е последователност от студентски идентификационни номера, влизащи в класната стая, където идентификационните номера варират от 0 до N-1, изчислете общия брой ръкостискания, които се случват. Всеки студент ще се ръкува с всеки студент, който вече е в класната стая с по-малък идентификационен номер. Последователността представлява реда, в който студентите влизат в класната стая.\n\nПримери:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "zh": "给定一个进入教室的学生ID序列，其中ID范围从0到N-1，计算发生的握手总数。每个学生将与教室中ID号较小的每个学生握手。该序列表示学生进入教室的顺序。\n\n示例：\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "fr": "Étant donné une séquence d'IDs d'étudiants entrant dans une salle de classe, où les IDs vont de 0 à N-1, calculez le nombre total de poignées de main qui se produisent. Chaque étudiant serrera la main de chaque étudiant déjà dans la salle de classe avec un numéro d'ID plus petit. La séquence représente l'ordre dans lequel les étudiants entrent dans la salle de classe.\n\nExemples :\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "de": "Gegeben eine Sequenz von Studenten-IDs, die einen Klassenraum betreten, wobei die IDs von 0 bis N-1 reichen, berechne die Gesamtanzahl der Händedrucke, die stattfinden. Jeder Student wird jedem Studenten die Hand schütteln, der sich bereits im Klassenraum befindet und eine kleinere ID-Nummer hat. Die Sequenz repräsentiert die Reihenfolge, in der die Studenten den Klassenraum betreten.\n\nBeispiele:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "ha": "An ba da jerin lambobin ID na ɗalibai da ke shiga aji, inda lambobin ID ɗin ke tsakanin 0 zuwa N-1, a lissafta jimillar yawan musabaha da ke faruwa. Kowane ɗalibi zai yi musabaha da kowane ɗalibi da ke riga shi a cikin aji da ke da ƙaramin lamba na ID. Jerin yana wakiltar tsarin da ɗalibai ke shiga aji.\n\nMisalai:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hi": "छात्र आईडी के अनुक्रम को एक कक्षा में प्रवेश करते हुए दिया गया है, जहाँ आईडी 0 से N-1 तक होती हैं, कुल हाथ मिलाने की संख्या की गणना करें। प्रत्येक छात्र उन सभी छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी नंबर के साथ हैं। अनुक्रम उस क्रम का प्रतिनिधित्व करता है जिसमें छात्र कक्षा में प्रवेश करते हैं।\n\nउदाहरण:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0",
      "hu": "Adott egy tanulói azonosítók sorozata, akik belépnek egy osztályterembe, ahol az azonosítók 0-tól N-1-ig terjednek, számítsd ki a kézfogások teljes számát, amelyek megtörténnek. Minden diák kezet fog minden olyan diákkal, aki már az osztályteremben van, és kisebb azonosítóval rendelkezik. A sorozat azt az sorrendet képviseli, amelyben a diákok belépnek az osztályterembe.\n\nPéldák:\n    >>> CountHandshakes(3, []int{2, 1, 0})\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9794504952996546",
      "hy": "0.9379113209745905",
      "bn": "0.9776822876476821",
      "bg": "0.9731564944158021",
      "zh": "0.9824597455723332",
      "fr": "1",
      "de": "1",
      "ha": "0.9229447203939927",
      "hi": "0.9984129432555312",
      "hu": "0.9643194287635599"
    }
  },
  {
    "task_id": "Go/38",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjej shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n դրական ամբողջ թվեր, որոնք ներկայացնում են յուրաքանչյուր թվի քանակը 1-ից n,\nգտեք մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը այդ թվերից կազմված\nհաջորդականության բոլոր նախածանցների համար։ Մոդան հաջորդականության ամենահաճախ հանդիպող\nտարրերի մեջ ամենամեծ թիվն է։\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tՀաջորդականություն, որը հասնում է իր առավելագույն արժեքին, սա է՝ (3,2,3,1,2,2)։\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nn টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\nএই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজুন।\nমোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, конструирана от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tПоследователност, която достига своята максимална стойност, е (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n众数是序列中最频繁元素中最大的数字。\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\t达到最大值的序列是 (3,2,3,1,2,2)。\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\ntrouvez la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes d'une\nséquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\nles éléments les plus fréquents dans une séquence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\nSequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter\nden häufigsten Elementen in einer Sequenz.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (abu mafi yawan lokaci) don dukkan gabanin\njerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin\nabubuwan da suka fi yawan lokaci a cikin jeri.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tWani jeri da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\nजो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में से सबसे बड़ा संख्या है।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n*/\nfunc MaxModeSum(n int, counts []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát\nreprezentálják, keresse meg a módusz (leggyakoribb elem) maximális összegét\naz ezekből a számokból felépített sorozat minden prefixére. A módusz a legnagyobb\nszám a sorozat leggyakoribb elemei között.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n*/\nfunc MaxModeSum(n int, counts []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9946741235933115",
      "hy": "0.9721742671815846",
      "bn": "0.9825125812536885",
      "bg": "0.9897600079665084",
      "zh": "0.9834072124898696",
      "fr": "1",
      "de": "1",
      "ha": "0.9508425560407238",
      "hi": "0.984929515730121",
      "hu": "0.9690446468979989"
    },
    "canonical_solution": "ans := int64(0)\n\tmx := 0\n\tf := make([]int64, 100002)\n\tfor i := 0; i <= n; i++ {\n\t\tf[i] = 0\n\t}\n\n\tfor i := n; i > 0; i-- {\n\t\tfor mx < counts[i-1] {\n\t\t\tmx++\n\t\t\tf[mx] = f[mx-1] + int64(i)\n\t\t}\n\t\tans += f[counts[i-1]]\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func MaxModeSum(n int, counts []int) int64` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).",
      "sq": "Shkruani një funksion Go `func MaxModeSum(n int, counts []int) int64` për të zgjidhur problemin në vijim:\nDuke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër\nelementet më të shpeshta në një sekuencë.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Գրեք Go ֆունկցիա `func MaxModeSum(n int, counts []int) int64` հետևյալ խնդիրը լուծելու համար:\nՏրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\nգտնել մոդայի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար\nայդ թվերից կառուցված հաջորդականության։ Մոդան հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ ամենամեծ թիվն է։\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tՀաջորդականություն, որը հասնում է իր առավելագույն արժեքին, (3,2,3,1,2,2) է։",
      "bn": "Go ফাংশন `func MaxModeSum(n int, counts []int) int64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\nএই সংখ্যাগুলি থেকে গঠিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল ক্রমে সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tযে ক্রমটি তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Напишете функция на Go `func MaxModeSum(n int, counts []int) int64`, за да решите следния проблем:\nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\nнамерете максималната сума на модата (най-често срещания елемент) за всички префикси на\nпоследователност, изградена от тези числа. Модата е най-голямото число сред\nнай-често срещаните елементи в последователност.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tПоследователност, която достига своята максимална стойност, е (3,2,3,1,2,2).",
      "zh": "编写一个 Go 函数 `func MaxModeSum(n int, counts []int) int64` 来解决以下问题：  \n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，  \n找出从这些数字构造的序列的所有前缀中众数（最频繁元素）的最大和。  \n众数是在序列中最频繁元素中最大的数字。\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\t达到其最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Écrire une fonction Go `func MaxModeSum(n int, counts []int) int64` pour résoudre le problème suivant :\nÉtant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\ntrouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Schreiben Sie eine Go-Funktion `func MaxModeSum(n int, counts []int) int64`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen. Finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).",
      "ha": "Rubuta aikin Go `func MaxModeSum(n int, counts []int) int64` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n da ke wakiltar adadin kowace lamba daga 1 zuwa n,\nnemo mafi girman jimlar yanayin (mafi yawan abu) don dukkan farkon jerin\njerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a tsakanin\nmafi yawan abubuwa a cikin jerin.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tWani jeri da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).",
      "hi": "गो फ़ंक्शन `func MaxModeSum(n int, counts []int) int64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, \nउन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। \nमोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या होती है।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Írj egy Go függvényt `func MaxModeSum(n int, counts []int) int64` a következő probléma megoldására:\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát képviselik,\ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét az ezekből a számokból\nfelépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "instruction_bertscore": {
      "sq": "0.9936557456297457",
      "hy": "0.9789998029650865",
      "bn": "0.8970695379173399",
      "bg": "0.989621562590927",
      "zh": "0.9875444846964453",
      "fr": "0.9999996027392379",
      "de": "0.9918776064587214",
      "ha": "0.9405215228117699",
      "hi": "0.9496183970024058",
      "hu": "0.967838165963593"
    },
    "level": "middle",
    "test": "func TestMaxModeSum(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(17), MaxModeSum(3, []int{1, 3, 2}))\n\tassert.Equal(int64(37), MaxModeSum(4, []int{4, 1, 2, 3}))\n\tassert.Equal(int64(4), MaxModeSum(2, []int{1, 1}))\n\tassert.Equal(int64(75), MaxModeSum(5, []int{1, 2, 3, 4, 5}))\n\tassert.Equal(int64(100000), MaxModeSum(1, []int{100000}))\n\tassert.Equal(int64(62), MaxModeSum(5, []int{5, 3, 2, 4, 1}))\n\tassert.Equal(int64(900000), MaxModeSum(3, []int{100000, 100000, 100000}))\n\tassert.Equal(int64(27), MaxModeSum(3, []int{2, 2, 5}))\n\tassert.Equal(int64(64), MaxModeSum(4, []int{4, 4, 4, 4}))\n\tassert.Equal(int64(126), MaxModeSum(6, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(int64(16), MaxModeSum(3, []int{3, 1, 2}))\n}",
    "entry_point": "MaxModeSum",
    "signature": "func MaxModeSum(n int, counts []int) int64",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tA sequence that reaches its maximum value is (3,2,3,1,2,2).",
      "sq": "Duke pasur parasysh n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\n    >>> MaxModeSum(3, []int{1, 2, 3})\n    17\n    Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n յուրաքանչյուր թվի քանակը, գտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների համար, որոնք կառուցված են այս թվերից։ Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի շարքում։\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tՀաջորդականությունը, որը հասնում է իր մաքսիմալ արժեքին, (3,2,3,1,2,2) է։",
      "bn": "প্রদত্ত n টি ধনাত্মক পূর্ণসংখ্যা যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tএকটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tПоследователност, която достига максималната си стойност, е (3,2,3,1,2,2).",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是在序列中最频繁元素中最大的数字。\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\t达到其最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\ntrouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\nSequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl unter\nden häufigsten Elementen in einer Sequenz.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEine Sequenz, die ihren Maximalwert erreicht, ist (3,2,3,1,2,2).",
      "ha": "An ba da n lambobi masu kyau da ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimlar yanayin (abin da aka fi samu) don dukkan gaban wani jeri da aka gina daga wadannan lambobin. Yanayin shi ne mafi girman lamba a cikin abubuwan da aka fi samu a cikin jeri.\n    >>> MaxModeSum(3, []int{1, 2, 3})\n    17\n    Wani jeri da ya kai darajarsa mafi girma shi ne (3,2,3,1,2,2).",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी उपक्रमों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित अनुक्रम का हिस्सा हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या होता है।\n    >>> MaxModeSum(3, []int{1, 2, 3})\n    17\n    एक अनुक्रम जो अपनी अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát képviselik, \ntalálja meg a módusz (a leggyakoribb elem) maximális összegét a \nezekből a számokból felépített sorozat összes prefixére. A módusz a legnagyobb szám a \nsorozat leggyakoribb elemei között.\n\t>>> MaxModeSum(3, []int{1, 2, 3})\n\t17\n\tEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "sq": "0.9863826955977723",
      "hy": "0.9572436186999541",
      "bn": "0.9738121733035983",
      "bg": "0.9825590607628506",
      "zh": "0.9790276112184313",
      "fr": "1",
      "de": "1",
      "ha": "0.9702962169288997",
      "hi": "0.9459939884396622",
      "hu": "0.9690146537104626"
    }
  },
  {
    "task_id": "Go/39",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një varg A me numra të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një palë indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) kthen 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով ամբողջ թվերի A զանգված, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը։\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է։\nԵնթազանգվածի XOR-ի գումարը արդյունքն է L-ից R բոլոր տարրերի XOR-ի։\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR-ի գումարների գումարն է։\n\nՕրինակ դեպքեր:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) վերադարձնում է 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে (L, R) জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 প্রদান করে\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се определя от двойка индекси (L, R) такива, че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) връща 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n子数组的异或和是从L到R的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 返回 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) retourne 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) gibt 39 zurück\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani jeri A na lambobin tsari, aikin shi ne lissafin jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR sums don dukkan yiwuwar ƙananan jerin.\n\nMisalan lokuta:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए पूर्णांकों की एक सरणी A के लिए, कार्य यह है कि सभी उप-सरणियों के XOR का योग गणना करें।\nएक उप-सरणी को (L, R) इंडेक्स की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n सरणी का आकार है।\nएक उप-सरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-सरणियों के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) visszaadja 39\n*/\nfunc sumOfXorSubarrays(A []int) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9920035381202975",
      "hy": "0.9747226949702622",
      "bn": "0.9683244131363664",
      "bg": "0.9880053071804462",
      "zh": "0.9687355780251086",
      "fr": "0.9922706959827894",
      "de": "0.9935689441532334",
      "ha": "0.9786943094390548",
      "hi": "0.9793430362635147",
      "hu": "0.9695652571266913"
    },
    "canonical_solution": "n := len(A)\n\tq := make([]int64, n+1)\n\tw := make([][2]int64, 21)\n\tvar ans int64\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = q[i-1] ^ int64(A[i-1])\n\t}\n\n\tfor i := 0; i <= n; i++ {\n\t\tfor j := 20; j >= 0; j-- {\n\t\t\tw[j][(q[i]>>j)&1]++\n\t\t}\n\t}\n\n\tfor i := 0; i <= 20; i++ {\n\t\tans += w[i][0] * w[i][1] * (1 << i)\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func sumOfXorSubarrays(A []int) int64` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n",
      "sq": "Shkruani një funksion Go `func sumOfXorSubarrays(A []int) int64` për të zgjidhur problemin në vijim:\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementëve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nRastet e shembullit:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) kthen 39",
      "hy": "Գրեք Go ֆունկցիա `func sumOfXorSubarrays(A []int) int64` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի A զանգվածը, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակներ:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) վերադարձնում է 39",
      "bn": "একটি Go ফাংশন `func sumOfXorSubarrays(A []int) int64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে (L, R) জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 ফেরত দেয়",
      "bg": "Напишете функция на Go `func sumOfXorSubarrays(A []int) int64`, за да решите следния проблем:\nДаден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се определя от двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) връща 39",
      "zh": "编写一个 Go 函数 `func sumOfXorSubarrays(A []int) int64` 来解决以下问题：\n给定一个整数数组 A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例案例：\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 返回 39",
      "fr": "Écrire une fonction Go `func sumOfXorSubarrays(A []int) int64` pour résoudre le problème suivant :\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) retourne 39",
      "de": "Schreiben Sie eine Go-Funktion `func sumOfXorSubarrays(A []int) int64`, um das folgende Problem zu lösen:\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) gibt 39 zurück.",
      "ha": "Rubuta aikin Go `func sumOfXorSubarrays(A []int) int64` don warware matsalar mai zuwa:\nAn ba da jerin A na lambobi, aikin shine a ƙididdige jumlar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomin (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJumlar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jumlar XOR sums don dukkan ƙaramin jerin masu yuwuwa.\n\nMisalan lokuta:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39",
      "hi": "Go फ़ंक्शन `func sumOfXorSubarrays(A []int) int64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी उप-श्रृंखलाओं के XOR का योग गणना करें।\nएक उप-श्रृंखला को (L, R) सूचकांकों की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, और n array का आकार है।\nएक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों के XOR का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 लौटाता है",
      "hu": "Írj egy Go függvényt `func sumOfXorSubarrays(A []int) int64` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az összes L és R közötti elem XOR-ának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) visszaadja 39"
    },
    "instruction_bertscore": {
      "sq": "0.9956696590630584",
      "hy": "0.9837440896161047",
      "bn": "0.9678878235588517",
      "bg": "0.9931802244975482",
      "zh": "0.9669107607145411",
      "fr": "0.9914668388307412",
      "de": "0.9912028590543458",
      "ha": "0.9731429875498917",
      "hi": "0.9663720751211745",
      "hu": "0.9609589999772117"
    },
    "level": "middle",
    "test": "func TestSumOfXorSubarrays(t *testing.T) {\n\tassert.Equal(t, int64(39), sumOfXorSubarrays([]int{1, 2, 3, 4, 5}))\n\tassert.Equal(t, int64(4), sumOfXorSubarrays([]int{1, 1, 1}))\n\tassert.Equal(t, int64(9), sumOfXorSubarrays([]int{2, 3, 1}))\n\tassert.Equal(t, int64(74), sumOfXorSubarrays([]int{4, 5, 7, 9}))\n\tassert.Equal(t, int64(0), sumOfXorSubarrays([]int{0, 0, 0, 0}))\n\tassert.Equal(t, int64(72), sumOfXorSubarrays([]int{8, 8, 8, 8, 8}))\n\tassert.Equal(t, int64(125), sumOfXorSubarrays([]int{3, 6, 9, 12, 15}))\n\tassert.Equal(t, int64(390), sumOfXorSubarrays([]int{10, 20, 30, 40, 50}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{16, 16, 16, 16, 16, 16}))\n\tassert.Equal(t, int64(192), sumOfXorSubarrays([]int{1, 3, 5, 7, 9, 11, 13}))\n\tassert.Equal(t, int64(218), sumOfXorSubarrays([]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}))\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "func sumOfXorSubarrays(A []int) int64",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) kthen 39",
      "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես, որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR-ի գումարների գումարն է:\n\nՕրինակային դեպքեր:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) վերադարձնում է 39",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা। একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার। একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল। চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 প্রদান করে",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= n, където n е размерът на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) връща 39",
      "zh": "给定一个整数数组 A，任务是计算所有子数组的异或和之和。  \n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= n，n 是数组的大小。  \n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和的总和。\n\n示例案例：  \n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 返回 39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) retourne 39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, sodass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel Fälle:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) gibt 39 zurück",
      "ha": "An ba da wani tsari A na lambobin cikakke, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan tsaruka.\nAna ayyana wani ƙaramin tsari ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\nJimillar XOR na wani ƙaramin tsari ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n\nMisalan lokuta:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) returns 39",
      "hi": "Provided an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nएक उप-ऐरे को (L, R) सूचकांक की जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n ऐरे का आकार है।\nएक उप-ऐरे का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\nअंतिम परिणाम सभी संभावित उप-ऐरे के लिए XOR योगों का योग है।\n\nउदाहरण मामले:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) 39 लौटाता है।",
      "hu": "Egy A egész számokat tartalmazó tömb esetén a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    sumOfXorSubarrays([]int{1, 2, 3, 4, 5}) visszaadja 39"
    },
    "docstring_bertscore": {
      "sq": "0.9926256484736987",
      "hy": "0.9696971476996985",
      "bn": "0.9625988924030358",
      "bg": "0.9815458471891917",
      "zh": "0.9570942486534159",
      "fr": "0.9910975849523973",
      "de": "0.9926182991496004",
      "ha": "0.9639223666318711",
      "hi": "0.9861417569455769",
      "hu": "0.961382281319197"
    }
  },
  {
    "task_id": "Go/40",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "sq": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n,\nqë mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme ligjore të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "hy": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է երկու դրական ամբողջ թիվ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n,\nորոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "bn": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন,\nযা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "bg": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n,\nкоито могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.\nРазличните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "zh": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定两个正整数 n 和 k，找到多少个正整数 x，其中 1 <= x <= n，\n可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n同一个数字的不同合法表示只计为一次。\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "fr": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n,\nqui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nDifférentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "de": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n,\ndie als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.\nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "ha": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n,\nwanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nDaban-daban halaltattun wakilcin lamba daya ana kirga su sau daya kawai.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "hi": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए दो धनात्मक पूर्णांक n और k के लिए, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n,\nजो x = a^b के रूप में व्यक्त किए जा सकते हैं, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {",
      "hu": "package main\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKét pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n,\namelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző érvényes ábrázolásait csak egyszer számoljuk.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nfunc countPowerNumbers(n int, k int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9458690499299912",
      "bn": "0.9448057815003115",
      "bg": "0.9925676484024366",
      "zh": "0.9732717000368023",
      "fr": "0.999999801369619",
      "de": "0.9884041569855643",
      "ha": "0.960550814544185",
      "hi": "0.9779814250015205",
      "hu": "0.9745812701389653"
    },
    "canonical_solution": "count := 0\n\tx := 0\n\tmp := make([]bool, n+1)\n\tcbrtN := int(math.Cbrt(float64(n)))\n\n\tfor i := 2; i <= cbrtN; i++ {\n\t\tt := int64(i) * int64(i)\n\t\tm := 2\n\t\tfor t <= int64(n)/int64(i) {\n\t\t\tt *= int64(i)\n\t\t\tm++\n\t\t\tif m < k || mp[t] {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif int(math.Sqrt(float64(t)))*int(math.Sqrt(float64(t))) == int(t) {\n\t\t\t\tx++\n\t\t\t}\n\t\t\tmp[t] = true\n\t\t\tcount++\n\t\t}\n\t}\n\tif k == 1 {\n\t\tcount = n\n\t} else if k >= 3 {\n\t\tcount += 1\n\t} else {\n\t\tcount += int(math.Sqrt(float64(n))) - x\n\t}\n\treturn count\n}",
    "instruction": {
      "en": "Write a Go function `func countPowerNumbers(n int, k int) int` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Shkruani një funksion Go `func countPowerNumbers(n int, k int) int` për të zgjidhur problemin në vijim:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n,  \nqë mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.  \nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.  \n",
      "hy": "Գրեք Go ֆունկցիա `func countPowerNumbers(n int, k int) int` հետևյալ խնդիրը լուծելու համար:\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n,\nորոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k:\nՆույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "একটি Go ফাংশন `func countPowerNumbers(n int, k int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন,\nযা x = a^b হিসাবে প্রকাশ করা যেতে পারে যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k।\nএকই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।",
      "bg": "Напишете Go функция `func countPowerNumbers(n int, k int) int`, за да решите следния проблем:  \nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n,  \nкоито могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k.  \nРазличните легални представяния на едно и също число се броят само веднъж.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "zh": "编写一个 Go 函数 `func countPowerNumbers(n int, k int) int` 来解决以下问题：\n给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，\n可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。\n同一个数字的不同合法表示只计算一次。",
      "fr": "Écrire une fonction Go `func countPowerNumbers(n int, k int) int` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n,  \nqui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.  \nDifférentes représentations légales du même nombre sont comptées une seule fois.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "de": "Schreiben Sie eine Go-Funktion `func countPowerNumbers(n int, k int) int`, um das folgende Problem zu lösen:  \nGegeben sind zwei positive ganze Zahlen n und k. Finden Sie die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n,  \ndie als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k.  \nVerschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.  \n    >>> countPowerNumbers(99, 1)  \n    99  ",
      "ha": "Rubuta aikin Go `func countPowerNumbers(n int, k int) int` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n,\nwanda za a iya bayyana shi azaman x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k.\nAna kirga wakilci daban-daban na doka na lamba ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "Go में एक फ़ंक्शन `func countPowerNumbers(n int, k int) int` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nदिए गए दो धनात्मक पूर्णांक n और k के लिए, उन धनात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n,\nजो x = a^b के रूप में व्यक्त किए जा सकते हैं, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है।\nएक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।",
      "hu": "Írj egy Go függvényt `func countPowerNumbers(n int, k int) int` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát, ahol 1 <= x <= n,\namelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k.\nUgyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "instruction_bertscore": {
      "sq": "0.9621994467067746",
      "hy": "0.9513697210719904",
      "bn": "0.9385036367708366",
      "bg": "0.9928401692852165",
      "zh": "0.9371845324103839",
      "fr": "1",
      "de": "0.9782207746106676",
      "ha": "0.9551212530785963",
      "hi": "0.9385133696595073",
      "hu": "0.9668088633290702"
    },
    "level": "hard",
    "test": "func TestCountPowerNumbers(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(99, countPowerNumbers(99, 1))\n\tassert.Equal(7, countPowerNumbers(99, 3))\n\tassert.Equal(12, countPowerNumbers(99, 2))\n\tassert.Equal(10, countPowerNumbers(10, 1))\n\tassert.Equal(4, countPowerNumbers(10, 2))\n\tassert.Equal(500, countPowerNumbers(500, 1))\n\tassert.Equal(30, countPowerNumbers(500, 2))\n\tassert.Equal(13, countPowerNumbers(500, 3))\n\tassert.Equal(1000, countPowerNumbers(1000, 1))\n\tassert.Equal(41, countPowerNumbers(1000, 2))\n\tassert.Equal(17, countPowerNumbers(1000, 3))\n\tassert.Equal(1, countPowerNumbers(1000, 93))\n\tassert.Equal(10, countPowerNumbers(50, 2))\n\tassert.Equal(5, countPowerNumbers(50, 3))\n\tassert.Equal(1, countPowerNumbers(2, 3))\n}",
    "entry_point": "countPowerNumbers",
    "signature": "func countPowerNumbers(n int, k int) int",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n,\nthat can be expressed as x = a^b with a and b being positive integers and b >= k.\nDifferent legal representations of the same number are counted only once.\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n,\nqë mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k.\nPërfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hy": "Տրված են երկու դրական ամբողջ թվեր n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x-এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে কেবল একবার গণনা করা হয়।\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n， 可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。 同一个数字的不同合法表示只计数一次。\n    >>> countPowerNumbers(99, 1)\n    99",
      "fr": "Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n,\nqui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k.\nLes différentes représentations légales du même nombre sont comptées une seule fois.\n    >>> countPowerNumbers(99, 1)\n    99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "An ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya daban-daban halattattun wakilcin wannan lambar ɗaya sau ɗaya kawai.\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या ज्ञात करें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Két pozitív egész szám, n és k esetén találja meg azon pozitív egész számok x számát, ahol 1 <= x <= n, amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Ugyanazon szám különböző jogszerű ábrázolásait csak egyszer számoljuk.\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "sq": "0.9902889606712043",
      "hy": "0.9820237518859616",
      "bn": "0.960448917158714",
      "bg": "0.989427500708656",
      "zh": "0.9593522788250205",
      "fr": "1",
      "de": "0.9813478126992998",
      "ha": "0.9729727613133449",
      "hi": "0.9564385697656197",
      "hu": "0.9526675719816724"
    }
  },
  {
    "task_id": "Go/41",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\nmodulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է երեք ամբողջ թիվ՝ n, m և k, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')',\nայնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվել\nմոդուլո 1,000,000,007 (10^9 + 7)։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত ক্রমের সংখ্যা খুঁজে বের করুন,\nযেমন দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা\nমডুলো হিসাবে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подпоследователност е с дължина 2 * k. Резултатът трябва да бъде изчислен\nпо модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长的平衡子序列的长度为 2 * k。结果应计算为模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné trois entiers n, m, et k, trouver le nombre de séquences composées de n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé\nmodulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen bestehend aus n '(' und m ')',\nso dass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte berechnet werden\nmodulo 1,000,000,007 (10^9 + 7).\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba lambobi guda uku n, m, da k, nemo adadin jerin lambobi da suka ƙunshi n '(' da m ')',\ninda mafi tsayin daidaitaccen subsequence yake da tsawon 2 * k. Dole ne a lissafa sakamakon\nmodulo 1,000,000,007 (10^9 + 7).\n\nAlal misali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए तीन पूर्णांक n, m, और k के लिए, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने हों,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से\nमॉड्यूलो में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott három egész szám: n, m és k. Találja meg azon sorozatok számát, amelyek n '(' és m ')'\nkarakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt\n1,000,000,007 (10^9 + 7) maradékkal kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nfunc countBalancedSubsequences(n, m, k int64) int64 {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9965930917044896",
      "bn": "0.9774367804967229",
      "bg": "0.9936511771309818",
      "zh": "0.9896070625731116",
      "fr": "0.9960683102377954",
      "de": "0.9963819476094495",
      "ha": "0.9824496154229004",
      "hi": "0.9885829243284957",
      "hu": "0.950314596487933"
    },
    "canonical_solution": "const P int64 = 1e9 + 7\n\tvar C [4002][4002]int64\n\n\t// Compute binomial coefficients only once.\n\tif C[0][0] == 0 {\n\t\tfor i := int64(0); i <= 4000; i++ {\n\t\t\tC[i][0] = 1\n\t\t}\n\t\tfor i := int64(1); i <= 4000; i++ {\n\t\t\tfor j := int64(1); j <= i; j++ {\n\t\t\t\tC[i][j] = (C[i-1][j-1] + C[i-1][j]) % P\n\t\t\t}\n\t\t}\n\t}\n\n\t// Calculate the number of balanced subsequences.\n\tif k > n || k > m {\n\t\treturn 0\n\t}\n\treturn (C[n+m][k] - C[n+m][k-1] + P) % P\n}",
    "instruction": {
      "en": "Write a Go function `func countBalancedSubsequences(n, m, k int64) int64` to solve the following problem:\nGiven three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Shkruani një funksion Go `func countBalancedSubsequences(n, m, k int64) int64` për të zgjidhur problemin e mëposhtëm:\nDuke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\nmodulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Գրեք Go ֆունկցիա `func countBalancedSubsequences(n, m, k int64) int64` հետևյալ խնդիրը լուծելու համար:\nԵրեք ամբողջ թիվ n, m և k ունենալով, գտնել n '(' և m ')' բաղկացած հաջորդականությունների քանակը,\nայնպես որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի\nմոդուլո 1,000,000,007 (10^9 + 7)։\n\nՕրինակ՝\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "Go ভাষায় একটি ফাংশন `func countBalancedSubsequences(n, m, k int64) int64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n সংখ্যক '(' এবং m সংখ্যক ')' নিয়ে গঠিত এমন ক্রমের সংখ্যা খুঁজুন, যাতে দীর্ঘতম সুষম উপক্রমের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো হিসেবে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Напишете функция на Go `func countBalancedSubsequences(n, m, k int64) int64`, за да решите следния проблем:\nДадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен\nмодул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "编写一个 Go 函数 `func countBalancedSubsequences(n, m, k int64) int64` 来解决以下问题：  \n给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，  \n使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模进行计算。  \n\n例如：  \n    >>> countBalancedSubsequences(2, 2, 2)  \n    2  ",
      "fr": "Écrire une fonction Go `func countBalancedSubsequences(n, m, k int64) int64` pour résoudre le problème suivant :\nÉtant donné trois entiers n, m et k, trouver le nombre de séquences consistant en n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé\nmodulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Schreiben Sie eine Go-Funktion `func countBalancedSubsequences(n, m, k int64) int64`, um das folgende Problem zu lösen:\nGegeben sind drei ganze Zahlen n, m und k. Finden Sie die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "Rubuta aikin Go `func countBalancedSubsequences(n, m, k int64) int64` don warware matsalar mai zuwa:\nAn ba da lambobi guda uku n, m, da k, nemo yawan jerin da ke kunshe da n '(' da m ')',\nta yadda mafi tsayin daidaitaccen subsequence shine tsawon 2 * k. Sakamakon ya kamata a ƙididdige\nmodulo 1,000,000,007 (10^9 + 7).",
      "hi": "Go फ़ंक्शन `func countBalancedSubsequences(n, m, k int64) int64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तीन पूर्णांक n, m, और k के लिए, n '(' और m ')' से बनी अनुक्रमों की संख्या खोजें,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Írj egy Go függvényt `func countBalancedSubsequences(n, m, k int64) int64` a következő probléma megoldására:\nAdott három egész szám: n, m és k. Találd meg azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modullal kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9878138274931286",
      "bn": "0.9600222591002512",
      "bg": "0.9833941028847213",
      "zh": "0.9838181787482307",
      "fr": "0.9974035036591119",
      "de": "0.9834906372499043",
      "ha": "0.9478007303855556",
      "hi": "0.9631059957658178",
      "hu": "0.9673300694489058"
    },
    "level": "hard",
    "test": "func TestCountBalancedSubsequences(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(int64(2), countBalancedSubsequences(2, 2, 2))\n\tassert.Equal(int64(0), countBalancedSubsequences(3, 2, 3))\n\tassert.Equal(int64(4), countBalancedSubsequences(3, 2, 1))\n\tassert.Equal(int64(14), countBalancedSubsequences(4, 3, 2))\n\tassert.Equal(int64(35), countBalancedSubsequences(5, 5, 2))\n\tassert.Equal(int64(6), countBalancedSubsequences(6, 1, 1))\n\tassert.Equal(int64(6), countBalancedSubsequences(1, 6, 1))\n\tassert.Equal(int64(27), countBalancedSubsequences(7, 2, 2))\n\tassert.Equal(int64(110), countBalancedSubsequences(8, 3, 3))\n\tassert.Equal(int64(10659), countBalancedSubsequences(10, 10, 5))\n\tassert.Equal(int64(574221648), countBalancedSubsequences(20, 20, 10))\n\tassert.Equal(int64(854104531), countBalancedSubsequences(2000, 2000, 1000))\n\tassert.Equal(int64(334874485), countBalancedSubsequences(2000, 1999, 1000))\n\tassert.Equal(int64(259428024), countBalancedSubsequences(2000, 2000, 1999))\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "func countBalancedSubsequences(n, m, k int64) int64",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated\nmodulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet\nmodulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')'-ից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n '(' এবং m ')' নিয়ে গঠিত কতগুলি ক্রম আছে তা খুঁজে বের করুন, যাতে দীর্ঘতম সুষম উপধারা দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива, че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен\nмодуло 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应计算为模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Étant donné trois entiers n, m, et k, trouvez le nombre de séquences composées de n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé\nmodulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen bestehend aus n '(' und m ')',\nso dass die längste balancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte berechnet werden\nmodulo 1,000,000,007 (10^9 + 7).\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "An ba da lambobi guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jerin lambobi masu daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige\nmodulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ऐसे कि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित किया जाना चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg azon sorozatok számát, amelyek n '(' és m ')' karakterekből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9996007529341199",
      "hy": "0.982714985611963",
      "bn": "0.945526015261944",
      "bg": "0.9880237798058824",
      "zh": "0.9732657411253713",
      "fr": "0.9942174723473123",
      "de": "0.9948824868630172",
      "ha": "0.9791024948720815",
      "hi": "0.9507386723514426",
      "hu": "0.9635034551582686"
    }
  },
  {
    "task_id": "Go/42",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë\nnë (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të\nprerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që\nështë paralele me boshtet, kalon përmes pikave me koordinata të plota dhe pret (jo vetëm prek skajin)\nletrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet.\nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՈւնենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝\nիր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, անհրաժեշտ է հաշվարկել գործողությունների\nսպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի k-ից պակաս։ Յուրաքանչյուր գործողության ժամանակ պատահականորեն\nընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը\n(ոչ միայն հպվում է եզրին)։ Գծի երկայնքով թղթի ներքևի կամ աջ մասը ապա հեռացվում է։\nՊատասխանը պետք է լինի 10^9+7 մոդուլով։\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি আয়তাকার কাগজ যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক ব্যবস্থায় রাখা হয়েছে যার নিচের-বাম\nকোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত, আপনাকে এমন অপারেশনগুলির প্রত্যাশিত সংখ্যা গণনা করতে হবে\nযাতে কাগজের অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা\nঅক্ষের সমান্তরাল, পূর্ণসংখ্যার স্থানাঙ্কযুক্ত বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র\nপ্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডান অংশটি তারপর বাতিল করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долния ляв\nъгъл в (0,0) и горния десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за\nрязане на хартията така, че останалата площ да е по-малка от k. При всяка операция се избира произволна линия, която\nе успоредна на осите, минава през точки с цели координати и пресича (не само докосва\nръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.\nОтговорът трябва да бъде по модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)，\n你需要计算期望的操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，\n该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应对 10^9+7 取模。\n\n例如:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche\nà (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour\ncouper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard qui\nest parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (sans juste toucher le bord)\nle papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée.\nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem mit seiner\nunteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m) platziert ist. Sie müssen die erwartete\nAnzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist.\nBei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit\nganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder\nrechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAna ba da takarda mai kusurwa huɗu mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsa ya kamata ta zama modulo 10^9+7.\n\nAlal misali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिया गया एक आयताकार कागज जिसका आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, \nजिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है, आपको उन अपेक्षित ऑपरेशनों की संख्या \nकी गणना करनी है जिससे कागज को इस प्रकार काटा जाए कि शेष क्षेत्रफल k से कम हो जाए। प्रत्येक ऑपरेशन में, \nएक रेखा को यादृच्छिक रूप से चुना जाता है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं \nसे गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज के निचले या \nदाहिने हिस्से को फिर हटा दिया जाता है। उत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el úgy, hogy az alsó-bal sarok a (0,0) pontban van, és a jobb-felső sarok az (n,m) pontban. Ki kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét eldobja.\nA válasz legyen modulo 10^9+7.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n*/\nfunc expectedCuts(n int, m int, k int64) int64 {"
    },
    "prompt_bertscore": {
      "sq": "0.9661899310617654",
      "hy": "0.95148671436642",
      "bn": "0.9668879182207221",
      "bg": "0.9531643465646407",
      "zh": "0.9487920946173006",
      "fr": "0.9759357307072423",
      "de": "0.9667911852251581",
      "ha": "0.9520782356411418",
      "hi": "0.9656548208152574",
      "hu": "0.9440879313032514"
    },
    "canonical_solution": "const MD int64 = 1000000007\n\tconst N int = 1000000\n\tvv := make([]int64, N*2+1)\n\tvar ans int64 = 1\n\n\tvv[1] = 1\n\tfor i := 2; i <= N*2; i++ {\n\t\tvv[i] = (vv[int64(i)-MD%int64(i)] * (MD/int64(i) + 1)) % MD\n\t}\n\n\tif int64(n)*int64(m) < k {\n\t\treturn 0\n\t}\n\n\tfor i := (k + int64(m) - 1) / int64(m); int64(i) < int64(n); i++ {\n\t\tans = (ans + vv[i+(k+int64(i)-1)/int64(i)-1]) % MD\n\t}\n\tfor j := (k + int64(n) - 1) / int64(n); int64(j) < int64(m); j++ {\n\t\tans = (ans + vv[(k+int64(j)-1)/int64(j)+int64(j)-1]) % MD\n\t}\n\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func expectedCuts(n int, m int, k int64) int64` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "sq": "Shkruani një funksion Go `func expectedCuts(n int, m int, k int64) int64` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një letër drejtkëndore me madhësi n x m të vendosur në një sistem koordinativ kartesian me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilin operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë.  \nPërgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hy": "Գրեք Go ֆունկցիա `func expectedCuts(n int, m int, k int64) int64`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է n x m չափի ուղղանկյուն թուղթ, որը տեղադրված է հարթ Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերին աջ անկյունը (n,m) կետում, դուք պետք է հաշվեք գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ՝\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bn": "একটি Go ফাংশন `func expectedCuts(n int, m int, k int64) int64` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি আয়তাকার কাগজের টুকরো, যার আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক ব্যবস্থায় রাখা হয়েছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ অবস্থিত। আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট ক্ষেত্রফল k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্কযুক্ত বিন্দুর মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ করা নয়)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডানদিকের অংশটি পরিত্যাগ করা হয়।\nউত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bg": "Напишете Go функция `func expectedCuts(n int, m int, k int64) int64`, за да решите следния проблем:  \nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля.  \nОтговорът трябва да бъде модул 10^9+7.\n\nНапример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "zh": "编写一个 Go 函数 `func expectedCuts(n int, m int, k int64) int64` 来解决以下问题：\n给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 位置，右上角在 (n,m) 位置。你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的直线，该直线通过具有整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n答案应为模 10^9+7 的结果。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "fr": "Écrire une fonction Go `func expectedCuts(n int, m int, k int64) int64` pour résoudre le problème suivant :  \nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de telle sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie aléatoirement qui est parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée.  \nLa réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "de": "Schreiben Sie eine Go-Funktion `func expectedCuts(n int, m int, k int64) int64`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen.\nDie Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "ha": "Rubuta aikin Go `func expectedCuts(n int, m int, k int64) int64` don warware matsalar mai zuwa:\nAn ba da takarda mai murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar lissafin adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin.\nAmsar ya kamata ta zama modulo 10^9+7.\n\nAlal misali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hi": "Go फ़ंक्शन `func expectedCuts(n int, m int, k int64) int64` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक आयताकार कागज़ का आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है। आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज़ का शेष क्षेत्रफल k से कम हो जाए। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से होकर गुजरती है, और कागज़ को काटती है (सिर्फ किनारे को छूती नहीं)। इस रेखा के साथ कागज़ का निचला या दायां भाग फिर त्याग दिया जाता है।\nउत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hu": "Írj egy Go függvényt `func expectedCuts(n int, m int, k int64) int64` a következő probléma megoldására:\nAdott egy n x m méretű téglalap alakú papír, amely egy derékszögű koordináta-rendszer síkjára van helyezve, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban található. Ki kell számítanod a várható műveletek számát, hogy a papírt úgy vágd el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választanak egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír alsó vagy jobb oldali része ezen a vonalon el lesz dobva.\nA válasznak modulo 10^9+7 formában kell lennie.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9693995993889082",
      "hy": "0.9498325205531614",
      "bn": "0.950530706342499",
      "bg": "0.9480305457364129",
      "zh": "0.9411946811730972",
      "fr": "0.9778608563602323",
      "de": "0.9614758362286645",
      "ha": "0.9683118994223612",
      "hi": "0.9370762788527198",
      "hu": "0.9481499225954149"
    },
    "level": "hard",
    "test": "func TestExpectedCuts(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(int64(0), expectedCuts(2, 4, 10))\n\tassert.Equal(int64(1), expectedCuts(2, 4, 8))\n\tassert.Equal(int64(833333342), expectedCuts(2, 4, 2))\n\tassert.Equal(int64(250000003), expectedCuts(2, 4, 6))\n\tassert.Equal(int64(666666673), expectedCuts(3, 3, 4))\n\tassert.Equal(int64(666666673), expectedCuts(5, 5, 12))\n\tassert.Equal(int64(722222229), expectedCuts(6, 7, 20))\n\tassert.Equal(int64(72727275), expectedCuts(8, 8, 30))\n\tassert.Equal(int64(714285721), expectedCuts(10, 10, 50))\n\tassert.Equal(int64(945634929), expectedCuts(1, 10, 5))\n\tassert.Equal(int64(945634929), expectedCuts(10, 1, 5))\n}",
    "entry_point": "expectedCuts",
    "signature": "func expectedCuts(n int, m int, k int64) int64",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\ncorner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to\ncut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that\nis parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching\nthe edge) the paper. The bottom or right part of the paper along this line is then discarded.\nThe answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "sq": "Duke pasur një letër drejtkëndëshe me përmasa n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվել սպասվող գործողությունների քանակը՝ թուղթը կտրելու համար, որպեսզի մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է (ոչ միայն դիպչում է եզրին) թուղթը: Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը ապա հեռացվում է:\nՊատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bn": "একটি আয়তাকার কাগজের টুকরো, আকার n x m, একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ রয়েছে, আপনাকে কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের সাথে কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 এর মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nПример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角位于 (0,0)，右上角位于 (n,m)，你需要计算期望的操作次数，以便切割纸张使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应对 10^9+7 取模。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie aléatoirement, elle est parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est alors éliminée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "de": "Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "ha": "An ba takarda mai murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar lissafin yawan ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A cikin kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ƙasa ko ɓangaren dama na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hi": "दिए गए n x m आकार के आयताकार कागज को एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाईं कोने पर (0,0) और ऊपरी-दाईं कोने पर (n,m) है। आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है जिससे कागज का शेष क्षेत्रफल k से कम हो जाए। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं)। इस रेखा के साथ कागज के नीचे या दाईं ओर का हिस्सा फिर त्याग दिया जाता है। उत्तर को 10^9+7 के माड्यूलो में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hu": "Egy n x m méretű téglalap alakú papírlapot kaptunk, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk, hogy a megmaradó terület kisebb legyen, mint k. Minden egyes művelet során véletlenszerűen kiválasztunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb részét ezután elvetjük. A válasz legyen modulo 10^9+7.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9517254680844239",
      "hy": "0.9425217307487913",
      "bn": "0.9447753910520131",
      "bg": "0.9548213212032336",
      "zh": "0.9427024843955331",
      "fr": "0.9658613964115338",
      "de": "0.9623019399833885",
      "ha": "0.9445829182127904",
      "hi": "0.9343258439665297",
      "hu": "0.9248358802518258"
    }
  },
  {
    "task_id": "Go/43",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 ≤ x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara bosh dhe duke renditur secilin segment. Kjo përfshin zgjedhjen e k-1 pikave të ndarjes me 1 ≤ x1 < x2 < ... < x(k-1) < n, dhe ndarjen e p në segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Rezultati duhet të jetë modulo 998244353.\nShembull:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճիշտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով։ Սա ներառում է k-1 կոտրման կետերի ընտրություն 1 ≤ x1 < x2 < ... < x(k-1) < n, և p-ն բաժանելով հատվածների [1, x1], (x1, x2], ..., (x(k-1), n]։ Արդյունքը պետք է լինի 998244353 մոդուլով։\nՕրինակ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল সবচেয়ে ছোট লেক্সিকোগ্রাফিক permutation যা p কে ঠিক k টি অ-খালি সন্নিহিত segment এ বিভক্ত করে এবং প্রতিটি segment কে সাজিয়ে পাওয়া যায়। এটি 1 ≤ x1 < x2 < ... < x(k-1) < n সহ k-1 টি breakpoints নির্বাচন করা এবং p কে segment গুলিতে [1, x1], (x1, x2], ..., (x(k-1), n] এ বিভক্ত করার সাথে জড়িত। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\nউদাহরণ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент. Това включва избиране на k-1 точки на прекъсване с 1 ≤ x1 < x2 < ... < x(k-1) < n, и разделяне на p на сегменти [1, x1], (x1, x2], ..., (x(k-1), n]. Резултатът трябва да бъде модуло 998244353.\nПример:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找到 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是可以通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序而获得的字典序最小的排列。这涉及选择 k-1 个断点，满足 1 ≤ x1 < x2 < ... < x(k-1) < n，并将 p 划分为段 [1, x1], (x1, x2], ..., (x(k-1), n]。结果应对 998244353 取模。\n示例:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la plus petite permutation lexicographique qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment. Cela implique de choisir k-1 points de rupture avec 1 ≤ x1 < x2 < ... < x(k-1) < n, et de diviser p en segments [1, x1], (x1, x2], ..., (x(k-1), n]. Le résultat doit être modulo 998244353.\nExemple:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird. Dies beinhaltet die Wahl von k-1 Trennpunkten mit 1 ≤ x1 < x2 < ... < x(k-1) < n, und die Unterteilung von p in Segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Das Ergebnis sollte modulo 998244353 sein.\nBeispiel:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba permutation q na abubuwa n da kuma cikakken lamba k, nemo yawan permutations p na abubuwa n da suke cika f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically da za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike kuma a jera kowane sashe. Wannan yana nufin zaɓar k-1 wuraren tsagewa tare da 1 ≤ x1 < x2 < ... < x(k-1) < n, da kuma raba p zuwa sassa [1, x1], (x1, x2], ..., (x(k-1), n]. Sakamakon ya kasance modulo 998244353.\nMisali:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों p की संख्या खोजें ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जिसे p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है। इसमें k-1 ब्रेकपॉइंट्स का चयन करना शामिल है जहाँ 1 ≤ x1 < x2 < ... < x(k-1) < n, और p को खंडों में विभाजित करना [1, x1], (x1, x2], ..., (x(k-1), n]। परिणाम 998244353 के मापांक में होना चाहिए।\nउदाहरण:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy q permutáció n elemről és egy egész szám k, találja meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk. Ez magában foglalja k-1 töréspont kiválasztását 1 ≤ x1 < x2 < ... < x(k-1) < n, és p szegmensekre osztását [1, x1], (x1, x2], ..., (x(k-1), n]. Az eredménynek modulo 998244353-nak kell lennie.\nPélda:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n*/\nfunc CountPermutations(n int, k int, qq []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.8928422861481554",
      "hy": "0.9938430540790616",
      "bn": "0.9891273702029123",
      "bg": "0.9964111462754617",
      "zh": "0.9874942312100434",
      "fr": "0.9933812384431554",
      "de": "0.9934060672407848",
      "ha": "0.9707067859264988",
      "hi": "0.992074647796708",
      "hu": "0.9877296082115697"
    },
    "canonical_solution": "const N = 505\n\tconst P = 998244353\n\tq := make([]int, N)\n\tm := 0\n\tdp := make([][]int, N)\n\tfor i := range dp {\n\t\tdp[i] = make([]int, N)\n\t}\n\tjc := make([]int, N)\n\tf := make([]int, N)\n\tans := 0\n\n\tfor i := 1; i <= n; i++ {\n\t\tq[i] = qq[i-1]\n\t}\n\tdp[0][0] = 1\n\tf[0] = 1\n\tjc[0] = 1\n\tfor i := jc[0]; i <= n; i++ {\n\t\tjc[i] = jc[i-1] * i % P\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tf[i] = jc[i]\n\t\tfor j := 1; j < i; j++ {\n\t\t\tf[i] = (f[i] + P - f[j]*jc[i-j]%P) % P\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 0; j < i; j++ {\n\t\t\tfor k := 1; k <= n; k++ {\n\t\t\t\tdp[i][k] = (dp[i][k] + dp[j][k-1]*f[i-j]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\tfor i := 1; i <= n; i++ {\n\t\tif q[i] > q[i+1] {\n\t\t\tm = i\n\t\t\tbreak\n\t\t}\n\t}\n\tif m == n {\n\t\tfor i := k; i <= n; i++ {\n\t\t\tans = (ans + dp[n][i]) % P\n\t\t}\n\t} else {\n\t\tfor i := m + 1; i <= n; i++ {\n\t\t\tif (i != m+1) && (q[i-1] > q[i] || q[i] < q[m]) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc := k + i - n - 1\n\t\t\tif c >= 0 {\n\t\t\t\tans = (ans + dp[m][c]*jc[i-m-1]%P) % P\n\t\t\t}\n\t\t}\n\t}\n\treturn ans\n}",
    "instruction": {
      "en": "Write a Go function `func CountPermutations(n int, k int, qq []int) int` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 ≤ x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n",
      "sq": "Shkruani një funksion Go `func CountPermutations(n int, k int, qq []int) int` për të zgjidhur problemin në vijim:  \nDuke pasur parasysh një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografikisht që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment. Kjo përfshin zgjedhjen e k-1 pikave të ndarjes me 1 ≤ x1 < x2 < ... < x(k-1) < n, dhe ndarjen e p në segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Rezultati duhet të jetë modulo 998244353.  \nShembull:  \n\t>>> CountPermutations(2, 1, []int{1, 2})  \n\t2  ",
      "hy": "Գրեք Go ֆունկցիա `func CountPermutations(n int, k int, qq []int) int` հետևյալ խնդիրը լուծելու համար:\nՈւնենալով n տարրերի q փոխատեղում և k ամբողջ թիվ, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարող է ստացվել p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով։ Սա ներառում է ընտրել k-1 կոտրման կետեր 1 ≤ x1 < x2 < ... < x(k-1) < n, և p-ն բաժանել հատվածների [1, x1], (x1, x2], ..., (x(k-1), n]։ Արդյունքը պետք է լինի 998244353 մոդուլով։\nՕրինակ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "bn": "একটি Go ফাংশন `func CountPermutations(n int, k int, qq []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, f(p) = q এমন n উপাদানের permutation p এর সংখ্যা খুঁজে বের করুন, যেখানে f(p) হল lexicographically সবচেয়ে ছোট permutation যা ঠিক k টি খালি নয় এমন ধারাবাহিক segment এ p কে ভাগ করে এবং প্রতিটি segment কে সাজিয়ে পাওয়া যায়। এটি 1 ≤ x1 < x2 < ... < x(k-1) < n শর্তে k-1 টি breakpoint নির্বাচন করে এবং p কে segment গুলিতে ভাগ করে [1, x1], (x1, x2], ..., (x(k-1), n]। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\nউদাহরণ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "bg": "Напишете функция на Go `func CountPermutations(n int, k int, qq []int) int`, за да решите следния проблем:\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент. Това включва избиране на k-1 точки на прекъсване с 1 ≤ x1 < x2 < ... < x(k-1) < n, и разделяне на p на сегменти [1, x1], (x1, x2], ..., (x(k-1), n]. Резултатът трябва да бъде модуло 998244353.\nПример:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "zh": "编写一个 Go 函数 `func CountPermutations(n int, k int, qq []int) int` 来解决以下问题：  \n给定一个 n 元素的排列 q 和一个整数 k，找到 n 元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是可以通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序而获得的字典序最小的排列。这涉及选择 k-1 个断点，满足 1 ≤ x1 < x2 < ... < x(k-1) < n，并将 p 划分为段 [1, x1], (x1, x2], ..., (x(k-1), n]。结果应对 998244353 取模。  \n示例:  \n\t>>> CountPermutations(2, 1, []int{1, 2})  \n\t2  ",
      "fr": "Écrire une fonction Go `func CountPermutations(n int, k int, qq []int) int` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment. Cela implique de choisir k-1 points de rupture avec 1 ≤ x1 < x2 < ... < x(k-1) < n, et de diviser p en segments [1, x1], (x1, x2], ..., (x(k-1), n]. Le résultat doit être modulo 998244353.\nExemple :\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "de": "Schreiben Sie eine Go-Funktion `func CountPermutations(n int, k int, qq []int) int`, um das folgende Problem zu lösen:\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird. Dies beinhaltet die Wahl von k-1 Trennpunkten mit 1 ≤ x1 < x2 < ... < x(k-1) < n, und das Teilen von p in Segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Das Ergebnis sollte modulo 998244353 sein.\nBeispiel:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "ha": "Rubuta aikin Go `func CountPermutations(n int, k int, qq []int) int` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n irin wanda f(p) = q, inda f(p) shine permutation mafi ƙarancin lexicographically wanda za a iya samu ta hanyar raba p zuwa k madaidaiciya ba tare da komai ba kuma a tsara kowane yanki. Wannan ya haɗa da zaɓar k-1 wuraren tsayawa tare da 1 ≤ x1 < x2 < ... < x(k-1) < n, da raba p zuwa sassa [1, x1], (x1, x2], ..., (x(k-1), n]. Sakamakon ya kasance modulo 998244353.\nMisali:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hi": "Go फ़ंक्शन `func CountPermutations(n int, k int, qq []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के एक क्रम q और एक पूर्णांक k के लिए, n तत्वों के क्रम p की संख्या खोजें ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटा क्रम है जिसे p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है। इसमें 1 ≤ x1 < x2 < ... < x(k-1) < n के साथ k-1 ब्रेकपॉइंट्स का चयन करना शामिल है, और p को खंडों में विभाजित करना [1, x1], (x1, x2], ..., (x(k-1), n]। परिणाम 998244353 के मापांक में होना चाहिए।\nउदाहरण:\n    >>> CountPermutations(2, 1, []int{1, 2})\n    2",
      "hu": "Írj egy Go függvényt `func CountPermutations(n int, k int, qq []int) int` a következő probléma megoldására:\nAdott egy q permutáció n elemről és egy egész szám k, találd meg az n elem p permutációinak számát úgy, hogy f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, egymást követő szegmensre osztjuk, és minden szegmenst sorba rendezünk. Ez magában foglalja k-1 töréspont kiválasztását 1 ≤ x1 < x2 < ... < x(k-1) < n feltétellel, és p felosztását szegmensekre [1, x1], (x1, x2], ..., (x(k-1), n]. Az eredménynek modulo 998244353 kell lennie.\nPélda:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2"
    },
    "instruction_bertscore": {
      "sq": "0.9812933879748963",
      "hy": "0.9935917866470524",
      "bn": "0.9840607064434743",
      "bg": "0.9912330508722631",
      "zh": "0.9814777169684967",
      "fr": "0.9971619691157735",
      "de": "0.9982901896800517",
      "ha": "0.9695169899440998",
      "hi": "0.9766853617652679",
      "hu": "0.9857242358846415"
    },
    "level": "hard",
    "test": "func TestCountPermutations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, CountPermutations(2, 1, []int{1, 2}))\n\tassert.Equal(1, CountPermutations(3, 3, []int{3, 1, 2}))\n\tassert.Equal(13, CountPermutations(6, 3, []int{1, 2, 3, 6, 5, 4}))\n\tassert.Equal(720, CountPermutations(6, 1, []int{1, 2, 3, 4, 5, 6}))\n\tassert.Equal(0, CountPermutations(6, 3, []int{1, 2, 5, 3, 4, 5}))\n\tassert.Equal(1, CountPermutations(9, 9, []int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(29093, CountPermutations(9, 2, []int{1, 2, 3, 4, 5, 6, 7, 9, 8}))\n}",
    "entry_point": "CountPermutations",
    "signature": "func CountPermutations(n int, k int, qq []int) int",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment. This involves choosing k-1 breakpoints with 1 ≤ x1 < x2 < ... < x(k-1) < n, and dividing p into segments [1, x1], (x1, x2], ..., (x(k-1), n]. The result should be modulo 998244353.\nExample:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2\n",
      "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara jo-bosh dhe duke renditur secilin segment. Kjo përfshin zgjedhjen e k-1 pikave të ndarjes me 1 ≤ x1 < x2 < ... < x(k-1) < n, dhe ndarjen e p në segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Rezultati duhet të jetë modulo 998244353.\nShembull:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը տեսակավորելով: Սա ներառում է k-1 բաժանման կետերի ընտրությունը 1 ≤ x1 < x2 < ... < x(k-1) < n պայմանով, և p-ն բաժանելով հատվածների [1, x1], (x1, x2], ..., (x(k-1), n]: Արդյունքը պետք է լինի մոդուլո 998244353:\nՕրինակ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "bn": "একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের পারমুটেশনের সংখ্যা খুঁজে বের করুন যেখানে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পারমুটেশন যা ঠিক k টি খালি নয় এমন সংলগ্ন সেগমেন্টে p কে ভাগ করে এবং প্রতিটি সেগমেন্টকে সর্ট করে পাওয়া যেতে পারে। এটি 1 ≤ x1 < x2 < ... < x(k-1) < n সহ k-1 টি ব্রেকপয়েন্ট নির্বাচন করা এবং p কে সেগমেন্টে ভাগ করা জড়িত [1, x1], (x1, x2], ..., (x(k-1), n]। ফলাফলটি 998244353 মডুলোতে হওয়া উচিত।\nউদাহরণ:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент. Това включва избиране на k-1 точки на прекъсване с 1 ≤ x1 < x2 < ... < x(k-1) < n, и разделяне на p на сегменти [1, x1], (x1, x2], ..., (x(k-1), n]. Резултатът трябва да бъде модуло 998244353.\nПример:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出 n 个元素的排列 p 的数量，使得 f(p) = q，其中 f(p) 是通过将 p 精确地分成 k 个非空连续段并对每个段进行排序后可以得到的字典序最小的排列。这涉及选择 k-1 个断点，满足 1 ≤ x1 < x2 < ... < x(k-1) < n，并将 p 分成段 [1, x1], (x1, x2], ..., (x(k-1), n]。结果应对 998244353 取模。\n示例：\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment. Cela implique de choisir k-1 points de rupture avec 1 ≤ x1 < x2 < ... < x(k-1) < n, et de diviser p en segments [1, x1], (x1, x2], ..., (x(k-1), n]. Le résultat doit être modulo 998244353.\nExemple :\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird. Dies beinhaltet die Auswahl von k-1 Trennpunkten mit 1 ≤ x1 < x2 < ... < x(k-1) < n und die Unterteilung von p in Segmente [1, x1], (x1, x2], ..., (x(k-1), n]. Das Ergebnis sollte modulo 998244353 sein.\nBeispiel:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "ha": "An ba da permutation q na abubuwa n da kuma integer k, nemo yawan permutations p na abubuwa n da suke da f(p) = q, inda f(p) shine permutation mafi ƙarami a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa k sassa masu cike da abubuwa masu ci gaba kuma a jera kowane sashe. Wannan ya haɗa da zaɓar k-1 wuraren tsayawa tare da 1 ≤ x1 < x2 < ... < x(k-1) < n, da kuma raba p zuwa sassa [1, x1], (x1, x2], ..., (x(k-1), n]. Sakamakon ya kasance modulo 998244353.\nMisali:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है। इसमें k-1 ब्रेकपॉइंट्स का चयन करना शामिल है जहाँ 1 ≤ x1 < x2 < ... < x(k-1) < n, और p को खंडों में विभाजित करना [1, x1], (x1, x2], ..., (x(k-1), n]। परिणाम 998244353 के मापांक में होना चाहिए।\nउदाहरण:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2",
      "hu": "Adott egy q permutáció n elemre és egy egész k, határozd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst sorba rendezünk. Ez magában foglalja k-1 töréspont kiválasztását, ahol 1 ≤ x1 < x2 < ... < x(k-1) < n, és p felosztását szegmensekre [1, x1], (x1, x2], ..., (x(k-1), n]. Az eredménynek modulo 998244353 kell lennie.\nPélda:\n\t>>> CountPermutations(2, 1, []int{1, 2})\n\t2"
    },
    "docstring_bertscore": {
      "sq": "0.989256877211347",
      "hy": "0.98514046119478",
      "bn": "0.9673449667274834",
      "bg": "0.9960726801061782",
      "zh": "0.9884063419197556",
      "fr": "0.9966165300894517",
      "de": "0.997585846348902",
      "ha": "0.9648980390635146",
      "hi": "0.9974245584795016",
      "hu": "0.9808240243845109"
    }
  },
  {
    "task_id": "Go/44",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës,\ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i tresheve\ntë kenë bashkësinë më të madhe të përbashkët (GCD) 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները,\nգտնել եղանակների քանակը, որով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների\nմեծագույն ընդհանուր բաժանարարը (GCD) լինի 1:\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nকিরার বন্ধুদের উচ্চতা উপস্থাপনকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে,\nতিনটি (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গসাগু (GCD) 1 হয়।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\nнамерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД)\nна максималната и минималната стойности на тройката да е 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个由 n 个不同整数组成的数组，表示Kira朋友的身高，\n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\ntrouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\ndes valeurs maximale et minimale du triplet soit 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben ein Array von n verschiedenen ganzen Zahlen, das die Größen von Kiras Freunden darstellt,\nfinde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, so dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\nnemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda babbar raba mai yawa (GCD)\nna mafi girma da ƙananan ƙimar triplet ɗin shine 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nकिरा के दोस्तों की ऊंचाईयों का प्रतिनिधित्व करने वाले n विशिष्ट पूर्णांकों की एक सरणी दी गई है,\nऐसे ट्रिपलेट (a, b, c) चुनने के तरीकों की संख्या खोजें कि ट्रिपलेट के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\ntaláld meg, hányféleképpen lehet választani egy hármast (a, b, c) úgy, hogy a hármas\nmaximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n*/\nfunc countTriplets(heights []int, n int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9816550938987608",
      "hy": "0.9948789115161585",
      "bn": "0.9483988064628516",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "0.9969281811572954",
      "ha": "0.9639855310930403",
      "hi": "0.9941781435318674",
      "hu": "0.9752176818798012"
    },
    "canonical_solution": "count := 0\n\tfor i := 0; i < n; i++ {\n\t\tfor j := i + 1; j < n; j++ {\n\t\t\tfor k := j + 1; k < n; k++ {\n\t\t\t\tminVal := minInt(minInt(heights[i], heights[j]), heights[k])\n\t\t\t\tmaxVal := maxInt(maxInt(heights[i], heights[j]), heights[k])\n\t\t\t\ta, b := minVal, maxVal\n\t\t\t\tfor b != 0 {\n\t\t\t\t\tt := b\n\t\t\t\t\tb = a % b\n\t\t\t\t\ta = t\n\t\t\t\t}\n\t\t\t\tif a == 1 {\n\t\t\t\t\tcount++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn count\n}\n\n// Helper functions\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "en": "Write a Go function `func countTriplets(heights []int, n int) int` to solve the following problem:\nGiven an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n",
      "sq": "Shkruani një funksion Go `func countTriplets(heights []int, n int) int` për të zgjidhur problemin në vijim:  \nDuke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës,  \ngjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i tresheve të kenë bashkëndarësin më të madh (GCD) 1.",
      "hy": "Գրեք Go ֆունկցիա `func countTriplets(heights []int, n int) int` հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարբեր ամբողջ թվերի զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\nգտեք եռյակ (a, b, c) ընտրելու եղանակների քանակը այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD)\nհավասար լինի 1:",
      "bn": "একটি Go ফাংশন `func countTriplets(heights []int, n int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nKira এর বন্ধুদের উচ্চতা উপস্থাপনকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া আছে,\nত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসর (GCD) হয় 1।",
      "bg": "Напишете Go функция `func countTriplets(heights []int, n int) int`, за да решите следния проблем:  \nДаден е масив от n различни цели числа, представляващи височините на приятелите на Кира,  \nнамерете броя на начините за избор на тройка (a, b, c) така, че най-големият общ делител (НОД)  \nна максималните и минималните стойности на тройката да е 1.",
      "zh": "编写一个 Go 函数 `func countTriplets(heights []int, n int) int` 来解决以下问题：  \n给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，  \n找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "fr": "Écrire une fonction Go `func countTriplets(heights []int, n int) int` pour résoudre le problème suivant :  \nÉtant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,  \ntrouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)  \ndes valeurs maximale et minimale du triplet soit 1.  \n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "de": "Schreiben Sie eine Go-Funktion `func countTriplets(heights []int, n int) int`, um das folgende Problem zu lösen:\nGegeben ist ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen,\nfinden Sie die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD)\nder maximalen und minimalen Werte des Tripels 1 ist.",
      "ha": "Rubuta aikin Go `func countTriplets(heights []int, n int) int` don warware matsalar mai zuwa:\nAn ba da jerin lambobi na n masu banbanci da ke wakiltar tsayin abokan Kira,\nnemo yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin da ke raba su gaba ɗaya (GCD)\nna mafi girma da ƙananan ƙimomi na triplet ɗin ya zama 1.",
      "hi": "Go फ़ंक्शन `func countTriplets(heights []int, n int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nKira के दोस्तों की ऊँचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है,\nतरीकों की संख्या खोजें जिससे एक triplet (a, b, c) चुना जा सके ताकि triplet के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hu": "Írj egy Go függvényt `func countTriplets(heights []int, n int) int` a következő probléma megoldására:\nAdott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\ntaláld meg, hányféleképpen lehet választani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen."
    },
    "instruction_bertscore": {
      "sq": "0.9537640116849849",
      "hy": "0.9540903614010252",
      "bn": "0.9598019780076835",
      "bg": "0.9598019780076835",
      "zh": "0.9902980976687319",
      "fr": "0.999999801369619",
      "de": "0.9559084252786376",
      "ha": "0.9263913547657101",
      "hi": "0.966158746091943",
      "hu": "0.9384706641275847"
    },
    "level": "hard",
    "test": "func TestCountTriplets(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(1, countTriplets([]int{1, 5, 7}, 3))\n\tassert.Equal(3, countTriplets([]int{1, 6, 2, 3}, 4))\n\tassert.Equal(0, countTriplets([]int{16, 4, 8, 2}, 4))\n\tassert.Equal(77, countTriplets([]int{10, 1, 6, 7, 9, 8, 4, 3, 5, 2}, 10))\n\tassert.Equal(7, countTriplets([]int{4, 5, 9, 11, 14}, 5))\n\tassert.Equal(104, countTriplets([]int{15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}, 11))\n\tassert.Equal(4, countTriplets([]int{3, 7, 11, 13}, 4))\n\tassert.Equal(10, countTriplets([]int{5, 12, 13, 17, 19}, 5))\n\tassert.Equal(87, countTriplets([]int{2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, 11))\n\tassert.Equal(122, countTriplets([]int{1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}, 11))\n}",
    "entry_point": "countTriplets",
    "signature": "func countTriplets(heights []int, n int) int",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends,\nfind the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD)\nof the maximum and minimum values of the triplet is 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1\n",
      "sq": "Duke pasur një varg me n numra të plotë të ndryshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori i përbashkët më i madh (GCD) i vlerave maksimale dhe minimale të tresheve të jetë 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hy": "Տրված է n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները, \nգտեք եղանակների քանակը, որոնցով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "bn": "Kira এর বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হয়েছে, এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গসাগু (GCD) 1 হয়।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouvez le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand diviseur commun (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "de": "Angenommen, ein Array von n verschiedenen ganzen Zahlen repräsentiert die Größen von Kiras Freunden, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) auszuwählen, so dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira, gano yawan hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman rabo na kowa (GCD) na mafi girma da mafi ƙanƙanta na triplet ɗin zai zama 1.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hi": "Kira के दोस्तों की ऊँचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों की एक array दी गई है, यह पता करें कि (a, b, c) तिकड़ी चुनने के कितने तरीके हैं ताकि तिकड़ी के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n    >>> countTriplets([]int{1, 5, 7})\n    1",
      "hu": "Egy n különböző egész számot tartalmazó tömböt kapunk, amely Kira barátainak magasságát jelképezi. Meg kell találni, hányféleképpen választhatunk ki egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\n    >>> countTriplets([]int{1, 5, 7})\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9808826203469162",
      "hy": "0.9845131864514718",
      "bn": "0.900525706547347",
      "bg": "0.996191461074037",
      "zh": "0.9949893500080139",
      "fr": "1",
      "de": "0.989399096564168",
      "ha": "0.9084895930445598",
      "hi": "0.9318727587607488",
      "hu": "0.9249473118955864"
    }
  },
  {
    "task_id": "Go/45",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë.\nJu mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës\nngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë.\nGjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՁեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով:\nԴուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները\nընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը:\nԳտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնից:\n\nՕրինակներ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nআপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়।\nআপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন।\nদুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং তাদের একই রঙ থাকে।\nসমস্ত পিক্সেল একই রঙের করতে প্রয়োজনীয় সর্বনিম্ন অপারেশন সংখ্যা খুঁজুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен от цяло число.\nМожете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия\nцвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят.\nНамерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个 1 x n 像素图像，其中每个像素的颜色由一个整数表示。\n你可以执行一个操作，选择一种颜色并将所有相连的相同颜色的像素更改为所选颜色。\n如果两个像素相邻且具有相同的颜色，则它们是相连的。\n找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nOn vous donne une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier.\nVous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même\ncouleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur.\nTrouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nSie haben ein 1 mal n Pixel-Bild, bei dem jeder Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird.\nSie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben\nFarbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben.\nFinden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu ändern.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba.\nKuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya\nzuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya.\nNemo mafi ƙarancin adadin ayyuka da ake buƙata don yin duk pixels su zama launi ɗaya.\n\nLura: Ga kowanne launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nआपको 1 बाय n पिक्सल की छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा प्रदर्शित होता है।\nआप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सल को चुने हुए रंग में बदल देते हैं।\nदो पिक्सल जुड़े हुए माने जाते हैं यदि वे आसन्न हैं और उनका रंग समान है।\nसभी पिक्सल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy 1 x n képpontból álló képet kap, ahol minden képpont színe egy egész számmal van reprezentálva.\nVégrehajthat egy műveletet, ahol kiválaszt egy színt, és az összes összekapcsolt, azonos színű képpontot\na választott színre változtatja. Két képpont akkor van összekapcsolva, ha szomszédosak és azonos színűek.\nKeresse meg a minimális műveletszámot, amely szükséges ahhoz, hogy az összes képpont azonos színű legyen.\n\nMegjegyzés: Minden színhez legfeljebb 20 képpont tartozik.\n\nPéldák:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n*/\nfunc minOperations(pixels []int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9795138583912048",
      "hy": "0.9927380732693645",
      "bn": "0.9936086702294404",
      "bg": "0.986854045491968",
      "zh": "0.9646426003935037",
      "fr": "0.9906607967445016",
      "de": "0.9892302607402884",
      "ha": "0.99034954293742",
      "hi": "0.9771978281483379",
      "hu": "0.9668470003622289"
    },
    "canonical_solution": "n := len(pixels)\n\tconst inf = 1000000000\n\tpre := make([]int, n+1)\n\tu := make([]int, n+1)\n\tf := make([][]int, n+1)\n\tfor i := range f {\n\t\tf[i] = make([]int, n+1)\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tpre[i] = u[pixels[i-1]]\n\t\tu[pixels[i-1]] = i\n\t}\n\n\tfor i := 1; i <= n; i++ {\n\t\tfor j := 1; j <= n; j++ {\n\t\t\tif i != j {\n\t\t\t\tf[i][j] = inf\n\t\t\t} else {\n\t\t\t\tf[i][j] = 0\n\t\t\t}\n\t\t}\n\t}\n\n\tfor len := 2; len <= n; len++ {\n\t\tfor i := 1; i <= n-len+1; i++ {\n\t\t\tj := i + len - 1\n\t\t\tf[i][j] = f[i][j-1] + 1\n\t\t\tfor l := pre[j]; l >= i; l = pre[l] {\n\t\t\t\tf[i][j] = min(f[i][j], f[i][l]+f[l+1][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn f[1][n]\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}",
    "instruction": {
      "en": "Write a Go function `func minOperations(pixels []int) int` to solve the following problem:\nYou are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n",
      "sq": "Shkruani një funksion Go `func minOperations(pixels []int) int` për të zgjidhur problemin e mëposhtëm:\nJu jepet një imazh 1 me n pikselë, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë.\nJu mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë pikselët e lidhur të së njëjtës\nngjyrë në ngjyrën e zgjedhur. Dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë.\nGjeni numrin minimal të operacioneve të nevojshme për t'i bërë të gjithë pikselët të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hy": "Գրեք Go ֆունկցիա `func minOperations(pixels []int) int` հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է 1x n պիքսելային պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով:\nԴուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում բոլոր միացված նույն գույնի պիքսելները ընտրված գույնով: Երկու պիքսելները միացված են, եթե նրանք հարակից են և ունեն նույն գույնը:\nԳտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույն դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել այդ գույնի:\n\nՕրինակներ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "bn": "Go ফাংশন `func minOperations(pixels []int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে একটি 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সংযুক্ত সমস্ত পিক্সেল নির্বাচনকৃত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেল একই রঙের করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক ২০টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "bg": "Напишете Go функция `func minOperations(pixels []int) int`, за да решите следния проблем:\nДадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен от цяло число.\nМожете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия\nцвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят.\nНамерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "zh": "编写一个 Go 函数 `func minOperations(pixels []int) int` 来解决以下问题：\n给定一个 1 x n 的像素图像，其中每个像素的颜色由一个整数表示。\n你可以执行一个操作，选择一种颜色并将所有相连的相同颜色的像素更改为所选颜色。如果两个像素相邻且颜色相同，则它们是相连的。\n找出将所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "fr": "Écrivez une fonction Go `func minOperations(pixels []int) int` pour résoudre le problème suivant :  \nOn vous donne une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier.  \nVous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur.  \nTrouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :  \n\t>>> minOperations([]int{1, 2, 3, 2, 1})  \n\t2  ",
      "de": "Schreiben Sie eine Go-Funktion `func minOperations(pixels []int) int`, um das folgende Problem zu lösen:\nSie haben ein 1x n Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird.\nSie können eine Operation durchführen, bei der Sie eine Farbe auswählen und alle verbundenen Pixel derselben\nFarbe in die gewählte Farbe ändern. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben.\nFinden Sie die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "ha": "Rubuta aikin Go `func minOperations(pixels []int) int` don warware matsalar mai zuwa:  \nAn ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba.  \nKuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa da juna kuma suna da launi ɗaya.  \nNemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.  \n\nLura: Ga kowane launi, akwai a kalla pixels 20 na wannan launi.  \n\nMisalai:  \n\t>>> minOperations([]int{1, 2, 3, 2, 1})  \n\t2  ",
      "hi": "Go फ़ंक्शन `func minOperations(pixels []int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको 1 बाई n पिक्सल छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है।\nआप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सल्स को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है।\nसभी पिक्सल्स को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशन्स की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hu": "Írj egy Go függvényt `func minOperations(pixels []int) int`, hogy megoldja a következő problémát:\nAdott egy 1 x n pixel kép, ahol minden pixel színe egy egész számmal van reprezentálva.\nVégezhetsz egy műveletet, ahol kiválasztasz egy színt, és megváltoztatod az összes összekapcsolt, azonos színű pixelt a kiválasztott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek.\nTaláld meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden színből legfeljebb 20 pixel van.\n\nPéldák:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2"
    },
    "instruction_bertscore": {
      "sq": "0.9831207874804173",
      "hy": "0.9904881869433824",
      "bn": "0.9887195820306477",
      "bg": "0.9836332538634873",
      "zh": "0.9623261728898749",
      "fr": "0.9980039633009804",
      "de": "0.9870963745568305",
      "ha": "0.978695898482103",
      "hi": "0.975444517774943",
      "hu": "0.9566008507869252"
    },
    "level": "hard",
    "test": "func TestMinOperations(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.Equal(2, minOperations([]int{1, 2, 3, 2, 1}))\n\tassert.Equal(1, minOperations([]int{1, 1, 2, 2}))\n\tassert.Equal(3, minOperations([]int{1, 2, 1, 4, 2}))\n\tassert.Equal(0, minOperations([]int{5, 5, 5, 5, 5}))\n\tassert.Equal(1, minOperations([]int{1, 1, 1, 2, 2, 2}))\n\tassert.Equal(2, minOperations([]int{1, 3, 3, 3, 2, 2, 2}))\n\tassert.Equal(1, minOperations([]int{4, 4, 4, 4, 3, 3, 3, 3}))\n\tassert.Equal(8, minOperations([]int{1, 2, 3, 4, 5, 6, 7, 8, 9}))\n\tassert.Equal(5, minOperations([]int{1, 2, 1, 2, 1, 2, 1, 2, 1, 2}))\n\tassert.Equal(0, minOperations([]int{3, 3, 3}))\n\tassert.Equal(1, minOperations([]int{2, 1, 1, 2}))\n}",
    "entry_point": "minOperations",
    "signature": "func minOperations(pixels []int) int",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer.\nYou can perform an operation where you pick a color and change all connected pixels of the same\ncolor to the chosen color. Two pixels are connected if they are adjacent and have the same color.\nFind the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2\n",
      "sq": "Ju jepet një imazh me përmasa 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë.\nJu mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës\nngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë.\nGjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hy": "Ձեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով:\nԴուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը:\nԳտեք նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলগুলি নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে করার জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল রয়েছে।\n\nউদাহরণ:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "bg": "Дадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "zh": "你有一个 1 x n 像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的相同颜色的像素更改为所选颜色。如果两个像素相邻且颜色相同，则它们是连接的。找出使所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier.\nVous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur à la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur.\nTrouvez le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "de": "Du hast ein 1 mal n Pixel Bild, wobei jedes Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und dieselbe Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in dieselbe Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "ha": "An ba ku hoto na pixel 1 ta n, inda kowanne pixel yana da launi da aka wakilta da lamba.\nKuna iya aiwatar da aiki inda kuke zaɓar launi kuma ku canza duk pixels masu alaƙa na launi ɗaya\nzuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya.\nNemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hi": "आपको 1 बाई n पिक्सल की छवि दी गई है, जहाँ प्रत्येक पिक्सल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जिसमें आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े हुए पिक्सल को चुने गए रंग में बदल देते हैं। दो पिक्सल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सल को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सल होते हैं।\n\nउदाहरण:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2",
      "hu": "Egy 1 x n pixeles képet kapunk, ahol minden pixel színe egy egész számmal van reprezentálva.\nVégezhetünk egy olyan műveletet, ahol kiválasztunk egy színt, és az összes összekapcsolt, azonos színű pixelt megváltoztatjuk a választott színre. Két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek.\nTaláljuk meg a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel van az adott színből.\n\nPéldák:\n\t>>> minOperations([]int{1, 2, 3, 2, 1})\n\t2"
    },
    "docstring_bertscore": {
      "sq": "0.977818945349834",
      "hy": "0.9835561852756457",
      "bn": "0.9873293679937845",
      "bg": "0.9771257253200223",
      "zh": "0.9574619134887115",
      "fr": "0.9793211869216009",
      "de": "0.9922601685725946",
      "ha": "0.9750939351524164",
      "hi": "0.9629925778182469",
      "hu": "0.9737116663307946"
    }
  },
  {
    "task_id": "Go/46",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjitha numrave nga 1 deri në n\nqë janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve 3 dhe 5,\nai duhet të numërohet vetëm një herë.\n\nPër shembull:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը,\nորոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի,\nայն պետք է հաշվել միայն մեկ անգամ։\n\nՕրինակ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন\nযেগুলি 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়েরই গুণিতক হয়,\nতাহলে এটি কেবল একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\nкоито са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5,\nтрябва да се брои само веднъж.\n\nНапример:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。\n如果一个数字同时是 3 和 5 的倍数，则只计算一次。\n\n例如:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n\nqui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et 5,\nil ne doit être compté qu'une seule fois.\n\nPar exemple:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen,\ndie Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist,\nsollte sie nur einmal gezählt werden.\n\nZum Beispiel:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani lamba n, rubuta wata aiki don ƙididdige jumlar duk lambobin daga 1 zuwa n\nwadanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5,\nya kamata a kirga shi sau daya kawai.\n\nMisali:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे\nजो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों के गुणज है,\nतो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy egész számot adva n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét,\namelyek 3 vagy 5 többszörösei. Ha egy szám 3 és 5 többszöröse is, akkor azt csak egyszer kell számolni.\n\nPéldául:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n*/\nfunc sumOfMultiples(n int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9939995748193171",
      "hy": "0.9902653236558612",
      "bn": "0.9945597124938355",
      "bg": "0.9896136173756857",
      "zh": "0.9855109068554101",
      "fr": "0.9945597124938355",
      "de": "0.9984079774960054",
      "ha": "0.9905545294906479",
      "hi": "0.9887694382562874",
      "hu": "0.9927692582391869"
    },
    "canonical_solution": "sum := 0\n\tfor i := 1; i <= n; i++ {\n\t\tif i%3 == 0 || i%5 == 0 {\n\t\t\tsum += i\n\t\t}\n\t}\n\treturn sum\n}",
    "instruction": {
      "en": "Write a Go function `func sumOfMultiples(n int) int` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n",
      "sq": "Shkruani një funksion në Go `func sumOfMultiples(n int) int` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n  \nqë janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,  \nai duhet të numërohet vetëm një herë.\n\nPër shembull:  \n\t>>> sumOfMultiples(10)  \n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hy": "Գրեք Go ֆունկցիա `func sumOfMultiples(n int) int` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը,\nորոնք բազմապատիկ են կամ 3-ի, կամ 5-ի: Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի,\nայն պետք է հաշվել միայն մեկ անգամ:\n\nՕրինակ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি Go ফাংশন `func sumOfMultiples(n int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা ৩ বা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়ের গুণিতক হয়, তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "bg": "Напишете Go функция `func sumOfMultiples(n int) int`, за да решите следния проблем:  \nДадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\n\nНапример:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "zh": "编写一个 Go 函数 `func sumOfMultiples(n int) int` 来解决以下问题：  \n给定一个整数 n，编写一个函数计算从 1 到 n 的所有 3 或 5 的倍数的和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n\n例如：  \n\t>>> sumOfMultiples(10)  \n\t33 // (3 + 5 + 6 + 9 + 10)  ",
      "fr": "Écrire une fonction Go `func sumOfMultiples(n int) int` pour résoudre le problème suivant :  \nÉtant donné un entier n, écrire une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois. \n\nPar exemple :  \n\t>>> sumOfMultiples(10)  \n\t33 // (3 + 5 + 6 + 9 + 10)",
      "de": "Schreiben Sie eine Go-Funktion `func sumOfMultiples(n int) int`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen,\ndie Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist,\nsollte sie nur einmal gezählt werden.\n\nZum Beispiel:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "ha": "Rubuta aikin Go `func sumOfMultiples(n int) int` don warware matsalar mai zuwa:\nAn ba da cikakken lamba n, rubuta aiki don lissafin jimillar duk lambobin daga 1 zuwa n\nwadanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5,\nya kamata a kirga shi sau daya kawai.\n\nMisali:",
      "hi": "Go फ़ंक्शन `func sumOfMultiples(n int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hu": "Írj egy Go függvényt `func sumOfMultiples(n int) int` a következő probléma megoldására:\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3-mal vagy 5-tel oszthatók. Ha egy szám 3-mal és 5-tel is osztható, akkor csak egyszer kell számolni.\n\nPéldául:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "sq": "0.9870896211238753",
      "hy": "0.9911909412314838",
      "bn": "0.9906542419419275",
      "bg": "0.9906542419419275",
      "zh": "0.9699456343063732",
      "fr": "0.9913949346328066",
      "de": "0.9948461375032878",
      "ha": "0.91736658340339",
      "hi": "0.9706038953891227",
      "hu": "0.9603994581938364"
    },
    "level": "easy",
    "test": "func TestSumOfMultiples(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(33, sumOfMultiples(10))\n\tassert.Equal(60, sumOfMultiples(15))\n\tassert.Equal(98, sumOfMultiples(20))\n\tassert.Equal(8, sumOfMultiples(5))\n\tassert.Equal(3, sumOfMultiples(3))\n\tassert.Equal(14, sumOfMultiples(6))\n\tassert.Equal(23, sumOfMultiples(9))\n\tassert.Equal(45, sumOfMultiples(12))\n\tassert.Equal(60, sumOfMultiples(17))\n\tassert.Equal(119, sumOfMultiples(21))\n\tassert.Equal(168, sumOfMultiples(25))\n}",
    "entry_point": "sumOfMultiples",
    "signature": "func sumOfMultiples(n int) int",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n\nthat are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\nit should only be counted once.\n\nFor example:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)\n",
      "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n\nqë janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,\nduhet të numërohet vetëm një herë.\n\nPër shembull:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hy": "Տրված ամբողջ թիվ n-ի դեպքում, գրեք ֆունկցիա, որը կհաշվարկի 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\n\nՕրինակ՝\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা হয় ৩ অথবা ৫ এর গুণিতক। যদি কোনো সংখ্যা ৩ এবং ৫ উভয়ের গুণিতক হয়, তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\nкоито са кратни на 3 или 5. Ако едно число е кратно както на 3, така и на 5,\nто трябва да бъде преброено само веднъж.\n\nНапример:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 的所有数字中是 3 或 5 的倍数的总和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n\n例如：\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\n\nPar exemple :\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "de": "Gegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\n\nZum Beispiel:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "ha": "An ba da wani lamba n, rubuta wata aiki don lissafa jimillar dukkan lambobi daga 1 zuwa n\nwanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5,\nya kamata a kirga ta sau daya kawai.\n\nMisali:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hi": "एक पूर्णांक n दिया गया है, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)",
      "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az 1-től n-ig terjedő összes szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám 3-nak és 5-nek is többszöröse, akkor csak egyszer kell számolni.\n\nPéldául:\n\t>>> sumOfMultiples(10)\n\t33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "sq": "0.9900519946266297",
      "hy": "0.9829642667401618",
      "bn": "0.9944238493132076",
      "bg": "0.9900519946266297",
      "zh": "0.9860144348713336",
      "fr": "0.9908419476520054",
      "de": "0.9952773640605145",
      "ha": "0.970730422941842",
      "hi": "0.9677390494034566",
      "hu": "0.9877226561482335"
    }
  },
  {
    "task_id": "Go/47",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the\nsame forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "sq": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet\nnjësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "hy": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՍահմանել՝ արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն է, որը կարդացվում է\nնույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը)։\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "bn": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "bg": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от знаци, която се чете\nпо един и същ начин напред и назад (като се игнорират интервали, пунктуация и главни букви).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "zh": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "fr": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit\nde la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "de": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nBestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "ha": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGano idan wani kirtani da aka bayar kalma ce ta palindrome. Kalmar palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa\ndaidai daga gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "hi": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nनिर्धारित करें कि कोई दिया गया स्ट्रिंग पलिंड्रोम है या नहीं। एक पलिंड्रोम वह शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान पढ़ता है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {",
      "hu": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nHatározza meg, hogy egy adott sztring palindróm-e. A palindróm egy szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue\n*/\nfunc IsPalindrome(str string) bool {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9971488595106253",
      "bn": "0.9991516496426",
      "bg": "0.9991516496426",
      "zh": "0.9885261160395197",
      "fr": "1",
      "de": "0.9944931713161888",
      "ha": "1",
      "hi": "0.9991516496426",
      "hu": "0.9991516496426"
    },
    "canonical_solution": "str = strings.ToLower(str)\n\tstart := 0\n\tend := len(str) - 1\n\n\tfor start < end {\n\t\t// Skip non-alphanumeric characters\n\t\tfor !unicode.IsLetter(rune(str[start])) && !unicode.IsNumber(rune(str[start])) && start < end {\n\t\t\tstart++\n\t\t}\n\t\tfor !unicode.IsLetter(rune(str[end])) && !unicode.IsNumber(rune(str[end])) && start < end {\n\t\t\tend--\n\t\t}\n\t\tif str[start] != str[end] {\n\t\t\treturn false\n\t\t}\n\t\tstart++\n\t\tend--\n\t}\n\treturn true\n}",
    "instruction": {
      "en": "Write a Go function `func IsPalindrome(str string) bool` to solve the following problem:\nDetermine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "sq": "Shkruani një funksion Go `func IsPalindrome(str string) bool` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).  \n\t>>> IsPalindrome(\"racecar\")  \n\ttrue",
      "hy": "Գրեք Go ֆունկցիա `func IsPalindrome(str string) bool` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք՝ արդյոք տրված տողը պալինդրոմ է։ Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "bn": "একটি Go ফাংশন `func IsPalindrome(str string) bool` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)। \n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "bg": "Напишете Go функция `func IsPalindrome(str string) bool`, за да решите следния проблем:  \nОпределете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).",
      "zh": "编写一个 Go 函数 `func IsPalindrome(str string) bool` 来解决以下问题：\n确定给定的字符串是否是回文。回文是一个单词、短语、数字或其他字符序列，正反读都是一样的（忽略空格、标点和大小写）。\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "fr": "Écrire une fonction Go `func IsPalindrome(str string) bool` pour résoudre le problème suivant :  \nDéterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).  \n\t>>> IsPalindrome(\"racecar\")  \n\ttrue",
      "de": "Schreiben Sie eine Go-Funktion `func IsPalindrome(str string) bool`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).",
      "ha": "Rubuta aikin Go `func IsPalindrome(str string) bool` don warware matsalar mai zuwa:\nGano idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ake karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "hi": "Go फ़ंक्शन `func IsPalindrome(str string) bool` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को अनदेखा करते हुए)।",
      "hu": "Írj egy Go függvényt `func IsPalindrome(str string) bool` a következő probléma megoldására:\nHatározd meg, hogy egy adott string palindróm-e. Egy palindróm olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátra olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9624658100477423",
      "bn": "0.965071046125396",
      "bg": "0.965071046125396",
      "zh": "0.9624658100477423",
      "fr": "1",
      "de": "0.9443713768569881",
      "ha": "0.9659970609617806",
      "hi": "0.9375144574732828",
      "hu": "0.965071046125396"
    },
    "level": "hard",
    "test": "func TestIsPalindrome(t *testing.T) {\n\tassert := assert.New(t)\n\n\tassert.True(IsPalindrome(\"A man a plan a canal Panama\"))\n\tassert.True(IsPalindrome(\"No lemon, no melon\"))\n\tassert.True(IsPalindrome(\"Was it a car or a cat I saw\"))\n\tassert.True(IsPalindrome(\"Madam, in Eden, I'm Adam\"))\n\tassert.True(IsPalindrome(\"Never odd or even\"))\n\tassert.True(IsPalindrome(\"Eva, can I see bees in a cave\"))\n\tassert.False(IsPalindrome(\"hello\"))\n\tassert.False(IsPalindrome(\"GitHub\"))\n\tassert.False(IsPalindrome(\"programming\"))\n}",
    "entry_point": "IsPalindrome",
    "signature": "func IsPalindrome(str string) bool",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe shkronjat e mëdha).\n    >>> IsPalindrome(\"racecar\")\n    true",
      "hy": "Տեղորոշեք, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরগুলির ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "zh": "确定给定的字符串是否是回文。回文是一个单词、短语、数字或其他字符序列，正向和反向读取时相同（忽略空格、标点和大小写）。\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même manière à l'envers et à l'endroit (en ignorant les espaces, la ponctuation et la capitalisation).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion und Groß-/Kleinschreibung).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "ha": "Gano idan wani kirtani da aka bayar kalma ce ta palindrome. Kalmar palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue",
      "hi": "दिया गया स्ट्रिंग एक पैलिंड्रोम है या नहीं, यह निर्धारित करें। एक पैलिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों की अनुक्रमणिका है जो आगे और पीछे से समान रूप से पढ़ी जाती है (स्पेस, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n    >>> IsPalindrome(\"racecar\")\n    true",
      "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm egy olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n\t>>> IsPalindrome(\"racecar\")\n\ttrue"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9940649242146775",
      "bn": "0.9702388127487807",
      "bg": "1",
      "zh": "0.9790834263555022",
      "fr": "0.9830476915001964",
      "de": "0.9691769347317681",
      "ha": "0.981616360974459",
      "hi": "0.9657674442413042",
      "hu": "1"
    }
  },
  {
    "task_id": "Go/48",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n*/\nfunc addDigits(num int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDuke pasur një numër të plotë jo-negativ num, shtoni në mënyrë të përsëritur të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    addDigits(38) // kthen 2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n*/\nfunc addDigits(num int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    addDigits(38) // վերադարձնում է 2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը:\n*/\nfunc addDigits(num int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলটি শুধুমাত্র এক অঙ্কের হয়।\nউদাহরণস্বরূপ:\n    addDigits(38) // 2 প্রদান করে\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর শুধুমাত্র এক অঙ্ক রয়েছে, 2 হল ফলাফল।\n*/\nfunc addDigits(num int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    addDigits(38) // връща 2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n*/\nfunc addDigits(num int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n给定一个非负整数 num，重复将所有位上的数字相加，直到结果只有一位数字。\n例如:\n    addDigits(38) // 返回 2\n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，2 是结果。\n*/\nfunc addDigits(num int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nÉtant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    addDigits(38) // retourne 2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n*/\nfunc addDigits(num int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nGegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    addDigits(38) // gibt 2 zurück\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n*/\nfunc addDigits(num int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAn ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nAlal misali:\n    addDigits(38) // returns 2\n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n*/\nfunc addDigits(num int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nदिया गया एक गैर-ऋणात्मक पूर्णांक num, इसकी सभी अंकों को तब तक बार-बार जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    addDigits(38) // 2 लौटाता है\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n*/\nfunc addDigits(num int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    addDigits(38) // visszaadja a 2-t\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény.\n*/\nfunc addDigits(num int) int {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.986125866515094",
      "bn": "0.9884581844492057",
      "bg": "0.9638476816086021",
      "zh": "0.9943036779326815",
      "fr": "1",
      "de": "1",
      "ha": "0.9880660880770429",
      "hi": "0.9962814406366458",
      "hu": "0.9719321367471031"
    },
    "canonical_solution": "for num >= 10 {\n\t\tsum := 0\n\t\tfor num > 0 {\n\t\t\tsum += num % 10\n\t\t\tnum /= 10\n\t\t}\n\t\tnum = sum\n\t}\n\treturn num\n}",
    "instruction": {
      "en": "Write a Go function `func addDigits(num int) int` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Shkruani një funksion në Go `func addDigits(num int) int` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    addDigits(38) // kthen 2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Գրեք Go ֆունկցիա `func addDigits(num int) int`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n    addDigits(38) // վերադարձնում է 2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը։",
      "bn": "একটি Go ফাংশন `func addDigits(num int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    addDigits(38) // 2 রিটার্ন করে\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর শুধুমাত্র একটি অঙ্ক আছে, 2 হল ফলাফল।",
      "bg": "Напишете Go функция `func addDigits(num int) int`, за да решите следния проблем:\nДадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не остане само една цифра.\nНапример:\n    addDigits(38) // връща 2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.",
      "zh": "编写一个 Go 函数 `func addDigits(num int) int` 来解决以下问题：  \n给定一个非负整数 num，重复将其所有数字相加，直到结果只有一位数字。  \n例如：  \n    addDigits(38) // 返回 2  \n    因为 3 + 8 = 11，且 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。",
      "fr": "Écrire une fonction Go `func addDigits(num int) int` pour résoudre le problème suivant :  \nÉtant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.  \nPar exemple :  \n    addDigits(38) // retourne 2  \n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Schreiben Sie eine Go-Funktion `func addDigits(num int) int`, um das folgende Problem zu lösen:\nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    addDigits(38) // gibt 2 zurück\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "Rubuta aikin Go `func addDigits(num int) int` don warware matsalar mai zuwa:\nAn ba da lamba mai kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nAlal misali:\n    addDigits(38) // yana dawowa 2\n    Domin 3 + 8 = 11, kuma 1 + 1 = 2. Tunda 2 yana da lamba ɗaya kawai, 2 shine sakamakon.",
      "hi": "Go फ़ंक्शन `func addDigits(num int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक गैर-ऋणात्मक पूर्णांक num के सभी अंकों को तब तक जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n    addDigits(38) // 2 लौटाता है\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Írj egy Go függvényt `func addDigits(num int) int` a következő probléma megoldására:\nAdott egy nem negatív egész szám num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    addDigits(38) // visszaadja a 2-t\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény."
    },
    "instruction_bertscore": {
      "sq": "0.9939330336416704",
      "hy": "0.9952431996349765",
      "bn": "1",
      "bg": "0.9847010907919308",
      "zh": "0.9675151929640302",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.9507672751263115",
      "hu": "0.9740523174342695"
    },
    "level": "easy",
    "test": "func TestAddDigits(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(2, addDigits(38))\n\tassert.Equal(0, addDigits(0))\n\tassert.Equal(9, addDigits(9))\n\tassert.Equal(6, addDigits(123))\n\tassert.Equal(6, addDigits(456))\n\tassert.Equal(9, addDigits(9999))\n\tassert.Equal(1, addDigits(100))\n\tassert.Equal(2, addDigits(1010))\n\tassert.Equal(1, addDigits(1234))\n\tassert.Equal(3, addDigits(9876))\n\tassert.Equal(1, addDigits(199))\n}",
    "entry_point": "addDigits",
    "signature": "func addDigits(num int) int",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n    addDigits(38) // returns 2\n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n    addDigits(38) // kthen 2\n    Sepse 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան։ Օրինակ՝\n    addDigits(38) // վերադարձնում է 2\n    Քանի որ 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է։",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, এর সমস্ত অঙ্কগুলি বারবার যোগ করুন যতক্ষণ না ফলাফলটি কেবল একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n    addDigits(38) // 2 ফেরত দেয়\n    কারণ 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর কেবল একটি অঙ্ক রয়েছে, তাই 2 হল ফলাফল।",
      "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът не стане едноцифрено число.\nНапример:\n    addDigits(38) // връща 2\n    Защото 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.",
      "zh": "给定一个非负整数 num，重复相加其所有位数，直到结果只有一位数字。\n\n例如：\n    addDigits(38) // 返回 2\n    因为 3 + 8 = 11，而 1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。",
      "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n    addDigits(38) // renvoie 2\n    Parce que 3 + 8 = 11, et 1 + 1 = 2. Comme 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Angenommen, eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n    addDigits(38) // gibt 2 zurück\n    Weil 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.\nAn ba da wani lamba mara tabbatacce num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba ɗaya kawai.  \n\nFor example:  \nMisali:  \n    addDigits(38) // returns 2  \n    Because 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.  \n    Saboda 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.  ",
      "hi": "दिया गया एक गैर-ऋणात्मक पूर्णांक num, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण के लिए:\n    addDigits(38) // 2 लौटाता है\n    क्योंकि 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Adott egy nemnegatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n    addDigits(38) // visszaadja a 2-t\n    Mert 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény."
    },
    "docstring_bertscore": {
      "sq": "0.9936382661562146",
      "hy": "0.9963150091710408",
      "bn": "0.9767487248568181",
      "bg": "0.9430105601165182",
      "zh": "0.9559306718813135",
      "fr": "0.999999801369619",
      "de": "0.9774326092587212",
      "ha": "0.999999801369619",
      "hi": "0.9948741443870137",
      "hu": "0.9523835305367925"
    }
  },
  {
    "task_id": "Go/49",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nYou are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh,\ndhe ju dhe kundërshtari juaj merrni radhën për të hequr 1 deri në 3 gurë nga grumbulli.\nAi që heq gurin e fundit fiton lojën.\nDuke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju\nashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nKëtu janë disa raste:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից,\nև դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։\nՆա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։\nՏրված է քարերի քանակը n, որոշեք՝ արդյոք կարող եք հաղթել խաղը, եթե դուք և ձեր\nմրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nতুমি একটি খেলা খেলছো যার নাম নিম। এই খেলায়, তুমি n সংখ্যক পাথর দিয়ে শুরু করো,\nএবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালাক্রমে ১ থেকে ৩টি পাথর সরিয়ে নাও।\nযে শেষ পাথরটি সরায় সেই খেলাটি জিতে যায়।\nপাথরের সংখ্যা n দেওয়া আছে, যদি তুমি এবং তোমার প্রতিদ্বন্দ্বী উভয়েই সর্বোত্তমভাবে খেলা খেলো,\nতবে তুমি কি খেলাটি জিততে পারবে তা নির্ধারণ করো। নোট: তুমি সর্বদা প্রথম পালা নাও।\n\nএখানে কিছু উদাহরণ দেওয়া হল:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка,\nи вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината.\nТози, който премахне последния камък, печели играта.\nДаден е броят на камъните n, определете дали можете да спечелите играта, ако и вие,\nи вашият противник играете оптимално. Забележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石子开始，\n你和你的对手轮流从堆中移走 1 到 3 个石子。\n移走最后一个石子的人赢得游戏。\n给定石子数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n注意：你总是先走。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres,\net vous et votre adversaire retirez à tour de rôle de 1 à 3 pierres du tas.\nCelui qui retire la dernière pierre gagne la partie.\nÉtant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et\nvotre adversaire jouez de manière optimale. Remarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nDu spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen,\nund du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen.\nDerjenige, der den letzten Stein entfernt, gewinnt das Spiel.\nGegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du\nals auch dein Gegner optimal spielen. Hinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nKana wasa mai suna Nim. A cikin wannan wasan, ka fara da tarin duwatsu n,\nkai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin.\nWanda ya cire dutse na ƙarshe shi ne ya lashe wasan.\nAn ba da adadin duwatsu n, tantance ko za ka iya lashe wasan idan kai da\nabokin hamayyarka kuna wasa da hikima. Lura: Kai ne kullum ke fara wasa.\n\nGa wasu misalai:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं,\nऔर आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं।\nजो अंतिम पत्थर हटाता है वह खेल जीतता है।\nदिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही अनुकूल रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz,\nés te és az ellenfeled felváltva távolítotok el 1-3 követ a halomból.\nAz nyeri a játékot, aki az utolsó követ eltávolítja.\nAdott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha mindketten\noptimálisan játszotok. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true\n*/\nfunc canWinNim(n int) bool {"
    },
    "prompt_bertscore": {
      "sq": "0.9973097501192635",
      "hy": "0.9773124378781951",
      "bn": "0.9722161781919829",
      "bg": "0.9900595425811091",
      "zh": "0.9830790751003999",
      "fr": "0.9828562118128789",
      "de": "0.9889414521662636",
      "ha": "0.982077779349603",
      "hi": "0.9889861440019965",
      "hu": "0.9735360770739597"
    },
    "canonical_solution": "return n%4 != 0\n}",
    "instruction": {
      "en": "Write a Go function `func canWinNim(n int) bool` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Shkruani një funksion Go `func canWinNim(n int) bool` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh,\ndhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli.\nAi që heq gurin e fundit fiton lojën.\nDuke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju\nashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Գրեք Go ֆունկցիա `func canWinNim(n int) bool` հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով,\nև դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։\nԱյն, ով հեռացնում է վերջին քարը, հաղթում է խաղը։\nՏրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե թե՛ դուք,\nթե՛ ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ առաջինն եք խաղում։\n\nԱհա մի քանի դեպքեր:\n    >>> canWinNim(1)\n    true",
      "bn": "একটি Go ফাংশন লিখুন `func canWinNim(n int) bool` নিম্নলিখিত সমস্যাটি সমাধান করতে:\nআপনি একটি Nim নামক খেলা খেলছেন। এই খেলায়, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালা করে পাথরের স্তূপ থেকে 1 থেকে 3 পাথর সরিয়ে নেন। যে ব্যক্তি শেষ পাথরটি সরায় সে খেলাটি জেতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি খেলাটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন। লক্ষ্য করুন: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে দেওয়া হল:\n    >>> canWinNim(1)\n    true",
      "bg": "Напишете Go функция `func canWinNim(n int) bool`, за да решите следния проблем:\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка,\nи вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината.\nТози, който премахне последния камък, печели играта.\nКато се има предвид броят на камъните n, определете дали можете да спечелите играта, ако и вие,\nи вашият противник играете оптимално. Забележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "编写一个 Go 函数 `func canWinNim(n int) bool` 来解决以下问题：\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你开始时有一堆 n 个石头，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，如果你和你的对手都采取最优策略，确定你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Écrivez une fonction Go `func canWinNim(n int) bool` pour résoudre le problème suivant :  \nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres,  \net vous et votre adversaire jouez à tour de rôle pour retirer 1 à 3 pierres du tas.  \nCelui qui retire la dernière pierre gagne la partie.  \nÉtant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous jouez toujours en premier.\n\nVoici quelques cas :  \n    >>> canWinNim(1)  \n    true  ",
      "de": "Schreiben Sie eine Go-Funktion `func canWinNim(n int) bool`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Angesichts der Anzahl der Steine n, bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen. Hinweis: Sie sind immer am Zug.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Rubuta aikin Go `func canWinNim(n int) bool` don warware matsalar mai zuwa:\nKana wasa mai suna Nim. A cikin wannan wasan, ka fara da tarin duwatsu n,\nkuma kai da abokin hamayyarka kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin.\nWanda ya cire dutse na karshe shi ne ya lashe wasan.\nAn ba da yawan duwatsu n, tantance idan zaka iya lashe wasan idan kai da\nabokin hamayyarka kuna wasa da hikima. Lura: Kai ne kullum ke fara juyawa.\n\nGa wasu lokuta:",
      "hi": "Go फ़ंक्शन `func canWinNim(n int) bool` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम रूप से खेलते हैं। नोट: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Írj egy Go függvényt `func canWinNim(n int) bool`, hogy megoldja a következő problémát:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te és az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő köveket a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszotok. Megjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "instruction_bertscore": {
      "sq": "0.9999996027392379",
      "hy": "0.9844677000942148",
      "bn": "0.9806377090871001",
      "bg": "0.9886353627490889",
      "zh": "0.9810544356265113",
      "fr": "0.9859604074076921",
      "de": "0.9836207401494821",
      "ha": "0.9716685542314698",
      "hi": "0.9903525223931354",
      "hu": "0.984525302904715"
    },
    "level": "easy",
    "test": "func TestCanWinNim(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(true, canWinNim(1))\n\tassert.Equal(true, canWinNim(2))\n\tassert.Equal(true, canWinNim(3))\n\tassert.Equal(false, canWinNim(4))\n\tassert.Equal(true, canWinNim(5))\n\tassert.Equal(true, canWinNim(6))\n\tassert.Equal(true, canWinNim(7))\n\tassert.Equal(false, canWinNim(8))\n\tassert.Equal(true, canWinNim(9))\n\tassert.Equal(true, canWinNim(10))\n\tassert.Equal(true, canWinNim(11))\n\tassert.Equal(false, canWinNim(12))\n\tassert.Equal(true, canWinNim(13))\n\tassert.Equal(true, canWinNim(14))\n\tassert.Equal(true, canWinNim(15))\n\tassert.Equal(false, canWinNim(16))\n\tassert.Equal(true, canWinNim(17))\n\tassert.Equal(true, canWinNim(18))\n\tassert.Equal(true, canWinNim(19))\n\tassert.Equal(false, canWinNim(20))\n}",
    "entry_point": "canWinNim",
    "signature": "func canWinNim(n int) bool",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones,\nand you and your opponent take turns to remove 1 to 3 stones from the pile.\nThe one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both you\nand your opponent play optimally. Note: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. Shënim: Ju gjithmonë merrni lëvizjen e parë.\n\nJa disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Դուք խաղում եք մի խաղ, որը կոչվում է Նիմ։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. Դուք միշտ կատարում եք առաջին քայլը։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true",
      "bn": "আপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি n সংখ্যক পাথর দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালা করে 1 থেকে 3 পাথর সরান। যে ব্যক্তি শেষ পাথরটি সরায় সে খেলায় জিতে যায়। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করুন আপনি খেলাটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন। লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n\nএখানে কিছু উদাহরণ রয়েছে:\n    >>> canWinNim(1)\n    true",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. Забележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移走 1 到 3 个石头。移走最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。注意：你总是先走。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire retirez tour à tour de 1 à 3 pierres du tas. Celui qui retire la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale. Remarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen. Hinweis: Du bist immer derjenige, der den ersten Zug macht.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true",
      "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna yin juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. An ba da yawan duwatsu n, tantance idan za ka iya cin nasara idan kai da abokin hamayyarka kuna wasa da hikima. Lura: Kai ne kullum ke yin juyawa na farko.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर के साथ शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम रूप से खेलते हैं। ध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ उदाहरण हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te és az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő köveket a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik. Megjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "sq": "0.9905438034500721",
      "hy": "0.9730776381545313",
      "bn": "0.9625810156687425",
      "bg": "0.9821749096059291",
      "zh": "0.959867724663806",
      "fr": "0.9780644525007932",
      "de": "0.971761115989032",
      "ha": "0.9675269121565113",
      "hi": "0.9805816953196483",
      "hu": "0.9664300751924366"
    }
  },
  {
    "task_id": "Go/50",
    "prompt": {
      "en": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "sq": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct llogarit shumën e dy numrave të plotë nëse shuma është çift,\nose produktin e dy numrave të plotë nëse shuma është tek.\n\nShembuj:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "hy": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct հաշվարկում է երկու ամբողջ թվերի գումարը, եթե գումարը զույգ է,\nկամ երկու ամբողջ թվերի արտադրյալը, եթե գումարը կենտ է։\n\nՕրինակներ:\n\tEvenSumOrOddProduct(2, 3) // վերադարձնում է 6\n\tEvenSumOrOddProduct(5, 5) // վերադարձնում է 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "bn": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct দুটি পূর্ণসংখ্যার যোগফল গণনা করে যদি যোগফলটি জোড় হয়,\nঅথবা দুটি পূর্ণসংখ্যার গুণফল যদি যোগফলটি বিজোড় হয়।\n\nউদাহরণ:\n\tEvenSumOrOddProduct(2, 3) // 6 প্রদান করে\n\tEvenSumOrOddProduct(5, 5) // 10 প্রদান করে\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "bg": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct изчислява сумата на две цели числа, ако сумата е четна,\nили произведението на двете цели числа, ако сумата е нечетна.\n\nПримери:\n\tEvenSumOrOddProduct(2, 3) // връща 6\n\tEvenSumOrOddProduct(5, 5) // връща 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "zh": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct 计算两个整数的和，如果和是偶数，\n则返回和；如果和是奇数，则返回两个整数的乘积。\n\n例子:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "fr": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct calcule la somme de deux entiers si la somme est paire,\nou le produit des deux entiers si la somme est impaire.\n\nExemples :\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "de": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct berechnet die Summe von zwei ganzen Zahlen, wenn die Summe gerade ist,\noder das Produkt der beiden ganzen Zahlen, wenn die Summe ungerade ist.\n\nBeispiele:\n\tEvenSumOrOddProduct(2, 3) // gibt 6 zurück\n\tEvenSumOrOddProduct(5, 5) // gibt 10 zurück\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "ha": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct yana lissafin jumlar lambobi biyu idan jumlar lambobin ta zama lamba mai mafarin biyu,\nko kuma yana lissafin ninkin lambobi biyun idan jumlar ta zama lamba mai mafarin daya.\n\nMisalai:\n\tEvenSumOrOddProduct(2, 3) // yana dawowa da 6\n\tEvenSumOrOddProduct(5, 5) // yana dawowa da 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "hi": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct दो पूर्णांकों का योग गणना करता है यदि योग सम है,\nया दो पूर्णांकों का गुणनफल यदि योग विषम है।\n\nउदाहरण:\n\tEvenSumOrOddProduct(2, 3) // 6 लौटाता है\n\tEvenSumOrOddProduct(5, 5) // 10 लौटाता है\n*/\nfunc EvenSumOrOddProduct(a, b int) int {",
      "hu": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n/*\nEvenSumOrOddProduct kiszámítja két egész szám összegét, ha az összeg páros,\nvagy a két egész szám szorzatát, ha az összeg páratlan.\n\nPéldák:\n\tEvenSumOrOddProduct(2, 3) // visszaadja 6\n\tEvenSumOrOddProduct(5, 5) // visszaadja 10\n*/\nfunc EvenSumOrOddProduct(a, b int) int {"
    },
    "prompt_bertscore": {
      "sq": "0.9946137399574769",
      "hy": "0.9887519587827563",
      "bn": "0.9930956079552273",
      "bg": "0.9946137399574769",
      "zh": "0.9513679333985611",
      "fr": "0.9946137399574769",
      "de": "0.9946137399574769",
      "ha": "0.9553721232498434",
      "hi": "0.9873857790219984",
      "hu": "0.9946137399574769"
    },
    "canonical_solution": "sum := a + b\n\tif sum%2 == 0 {\n\t\treturn sum\n\t} else {\n\t\treturn a * b\n\t}\n}",
    "instruction": {
      "en": "Write a Go function `func EvenSumOrOddProduct(a, b int) int` to solve the following problem:\nEvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10",
      "sq": "Shkruani një funksion në Go `func EvenSumOrOddProduct(a, b int) int` për të zgjidhur problemin e mëposhtëm:\nEvenSumOrOddProduct llogarit shumën e dy numrave të plotë nëse shuma është çift,\nose produktin e dy numrave të plotë nëse shuma është tek.\n\nShembuj:\n\tEvenSumOrOddProduct(2, 3) // kthen 6\n\tEvenSumOrOddProduct(5, 5) // kthen 10",
      "hy": "Գրեք Go ֆունկցիա `func EvenSumOrOddProduct(a, b int) int` հետևյալ խնդիրը լուծելու համար:\nEvenSumOrOddProduct հաշվարկում է երկու ամբողջ թվերի գումարը, եթե գումարը զույգ է,\nկամ երկու ամբողջ թվերի արտադրյալը, եթե գումարը կենտ է:\n\nՕրինակներ:\n\tEvenSumOrOddProduct(2, 3) // վերադարձնում է 6\n\tEvenSumOrOddProduct(5, 5) // վերադարձնում է 10",
      "bn": "একটি Go ফাংশন `func EvenSumOrOddProduct(a, b int) int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nEvenSumOrOddProduct দুটি পূর্ণসংখ্যার যোগফল গণনা করে যদি যোগফলটি জোড় হয়,\nঅথবা দুটি পূর্ণসংখ্যার গুণফল যদি যোগফলটি বিজোড় হয়।\n\nউদাহরণ:\n\tEvenSumOrOddProduct(2, 3) // 6 প্রদান করে\n\tEvenSumOrOddProduct(5, 5) // 10 প্রদান করে",
      "bg": "Напишете функция на Go `func EvenSumOrOddProduct(a, b int) int`, за да решите следния проблем:\nEvenSumOrOddProduct изчислява сумата на две цели числа, ако сумата е четна,\nили произведението на двете цели числа, ако сумата е нечетна.\n\nПримери:\n\tEvenSumOrOddProduct(2, 3) // връща 6\n\tEvenSumOrOddProduct(5, 5) // връща 10",
      "zh": "编写一个 Go 函数 `func EvenSumOrOddProduct(a, b int) int` 来解决以下问题：\nEvenSumOrOddProduct 计算两个整数的和，如果和是偶数，则返回和；如果和是奇数，则返回两个整数的乘积。\n\n示例：\n\tEvenSumOrOddProduct(2, 3) // 返回 6\n\tEvenSumOrOddProduct(5, 5) // 返回 10",
      "fr": "Écrire une fonction Go `func EvenSumOrOddProduct(a, b int) int` pour résoudre le problème suivant :\nEvenSumOrOddProduct calcule la somme de deux entiers si la somme est paire,\nou le produit des deux entiers si la somme est impaire.\n\nExemples :\n\tEvenSumOrOddProduct(2, 3) // retourne 6\n\tEvenSumOrOddProduct(5, 5) // retourne 10",
      "de": "Schreiben Sie eine Go-Funktion `func EvenSumOrOddProduct(a, b int) int`, um das folgende Problem zu lösen:\nEvenSumOrOddProduct berechnet die Summe von zwei ganzen Zahlen, wenn die Summe gerade ist,\noder das Produkt der beiden ganzen Zahlen, wenn die Summe ungerade ist.\n\nBeispiele:\n\tEvenSumOrOddProduct(2, 3) // gibt 6 zurück\n\tEvenSumOrOddProduct(5, 5) // gibt 10 zurück",
      "ha": "Rubuta aikin Go `func EvenSumOrOddProduct(a, b int) int` don warware matsalar mai zuwa:\nEvenSumOrOddProduct yana lissafin jimillar lambobi biyu idan jimillar ta kasance lamba mai mafarin biyu,\nko kuma samfurin lambobi biyun idan jimillar ta kasance lamba mai mafarin daya.\n\nMisalai:\n\tEvenSumOrOddProduct(2, 3) // yana dawowa 6\n\tEvenSumOrOddProduct(5, 5) // yana dawowa 10",
      "hi": "Go फ़ंक्शन `func EvenSumOrOddProduct(a, b int) int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nEvenSumOrOddProduct दो पूर्णांकों का योग गणना करता है यदि योग सम है,\nया दो पूर्णांकों का गुणनफल यदि योग विषम है।\n\nउदाहरण:\n\tEvenSumOrOddProduct(2, 3) // 6 लौटाता है\n\tEvenSumOrOddProduct(5, 5) // 10 लौटाता है",
      "hu": "Írj egy Go függvényt `func EvenSumOrOddProduct(a, b int) int` a következő probléma megoldására:\nEvenSumOrOddProduct kiszámítja két egész szám összegét, ha az összeg páros,\nvagy a két egész szám szorzatát, ha az összeg páratlan.\n\nPéldák:\n\tEvenSumOrOddProduct(2, 3) // visszaadja 6\n\tEvenSumOrOddProduct(5, 5) // visszaadja 10"
    },
    "instruction_bertscore": {
      "sq": "0.9910471328356145",
      "hy": "0.9823487111893346",
      "bn": "0.9922466617066842",
      "bg": "0.9939711706748291",
      "zh": "0.9435224306084451",
      "fr": "0.9939711706748291",
      "de": "0.9939711706748291",
      "ha": "0.9671250828956778",
      "hi": "0.987258059686993",
      "hu": "0.9939711706748291"
    },
    "level": "easy",
    "test": "func TestEvenSumOrOddProduct(t *testing.T) {\n\tassert := assert.New(t)\n\tassert.Equal(6, EvenSumOrOddProduct(2, 3))\n\tassert.Equal(10, EvenSumOrOddProduct(5, 5))\n\tassert.Equal(2, EvenSumOrOddProduct(1, 1))\n\tassert.Equal(0, EvenSumOrOddProduct(0, 0))\n\tassert.Equal(-2, EvenSumOrOddProduct(-1, -1))\n\tassert.Equal(300, EvenSumOrOddProduct(100, 200))\n\tassert.Equal(12, EvenSumOrOddProduct(3, 4))\n\tassert.Equal(0, EvenSumOrOddProduct(-5, 5))\n\tassert.Equal(56, EvenSumOrOddProduct(7, 8))\n\tassert.Equal(90, EvenSumOrOddProduct(9, 10))\n\tassert.Equal(154, EvenSumOrOddProduct(11, 14))\n}",
    "entry_point": "EvenSumOrOddProduct",
    "signature": "func EvenSumOrOddProduct(a, b int) int",
    "docstring": {
      "en": "EvenSumOrOddProduct computes the sum of two integers if the sum is even,\nor the product of the two integers if the sum is odd.\n\nExamples:\n\tEvenSumOrOddProduct(2, 3) // returns 6\n\tEvenSumOrOddProduct(5, 5) // returns 10",
      "sq": "EvenSumOrOddProduct llogarit shumën e dy numrave të plotë nëse shuma është çift,\nose prodhimin e dy numrave të plotë nëse shuma është tek.\n\nShembuj:\n\tEvenSumOrOddProduct(2, 3) // kthen 6\n\tEvenSumOrOddProduct(5, 5) // kthen 10",
      "hy": "EvenSumOrOddProduct հաշվարկում է երկու ամբողջ թվերի գումարը, եթե գումարը զույգ է, կամ երկու ամբողջ թվերի արտադրյալը, եթե գումարը կենտ է։\n\nՕրինակներ:\n\tEvenSumOrOddProduct(2, 3) // վերադարձնում է 6\n\tEvenSumOrOddProduct(5, 5) // վերադարձնում է 10",
      "bn": "EvenSumOrOddProduct দুটি পূর্ণসংখ্যার যোগফল গণনা করে যদি যোগফল জোড় হয়, অথবা দুটি পূর্ণসংখ্যার গুণফল যদি যোগফল বিজোড় হয়।\n\nউদাহরণ:\n\tEvenSumOrOddProduct(2, 3) // 6 ফেরত দেয়\n\tEvenSumOrOddProduct(5, 5) // 10 ফেরত দেয়",
      "bg": "EvenSumOrOddProduct изчислява сумата на две цели числа, ако сумата е четна,\nили произведението на двете цели числа, ако сумата е нечетна.\n\nПримери:\n\tEvenSumOrOddProduct(2, 3) // връща 6\n\tEvenSumOrOddProduct(5, 5) // връща 10",
      "zh": "EvenSumOrOddProduct 计算两个整数的和，如果和是偶数，则返回和；如果和是奇数，则返回两个整数的乘积。\n\n示例:\n\tEvenSumOrOddProduct(2, 3) // 返回 6\n\tEvenSumOrOddProduct(5, 5) // 返回 10",
      "fr": "EvenSumOrOddProduct calcule la somme de deux entiers si la somme est paire, ou le produit des deux entiers si la somme est impaire.\n\nExemples :\n\tEvenSumOrOddProduct(2, 3) // retourne 6\n\tEvenSumOrOddProduct(5, 5) // retourne 10",
      "de": "EvenSumOrOddProduct berechnet die Summe von zwei ganzen Zahlen, wenn die Summe gerade ist, oder das Produkt der beiden ganzen Zahlen, wenn die Summe ungerade ist.\n\nBeispiele:\n\tEvenSumOrOddProduct(2, 3) // gibt 6 zurück\n\tEvenSumOrOddProduct(5, 5) // gibt 10 zurück",
      "ha": "EvenSumOrOddProduct yana ƙididdige jumlar lambobi biyu idan jumlar ta zama lamba mai mafarin biyu, ko kuma samfurin lambobi biyun idan jumlar ta zama lamba mai mafarin ɗaya.\n\nMisalai:\n\tEvenSumOrOddProduct(2, 3) // yana dawowa 6\n\tEvenSumOrOddProduct(5, 5) // yana dawowa 10",
      "hi": "EvenSumOrOddProduct दो पूर्णांकों का योग गणना करता है यदि योग सम है, या दो पूर्णांकों का गुणनफल यदि योग विषम है।\n\nउदाहरण:\n\tEvenSumOrOddProduct(2, 3) // 6 लौटाता है\n\tEvenSumOrOddProduct(5, 5) // 10 लौटाता है",
      "hu": "EvenSumOrOddProduct kiszámítja két egész szám összegét, ha az összeg páros,\nvagy a két egész szám szorzatát, ha az összeg páratlan.\n\nPéldák:\n\tEvenSumOrOddProduct(2, 3) // visszatérési érték 6\n\tEvenSumOrOddProduct(5, 5) // visszatérési érték 10"
    },
    "docstring_bertscore": {
      "sq": "0.9835625414478388",
      "hy": "0.9835625414478388",
      "bn": "0.981479504641926",
      "bg": "0.9921121889387235",
      "zh": "0.9272919449133222",
      "fr": "0.9921121889387235",
      "de": "0.9921121889387235",
      "ha": "0.9514338786850647",
      "hi": "0.981479504641926",
      "hu": "0.9690134619281764"
    }
  }
]