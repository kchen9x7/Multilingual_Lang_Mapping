[
  {
    "task_id": "Java/1",
    "prompt": {
      "en": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "sq": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Llogarit mesataren e bilancit të llogarisë bazuar në bilancet përmbyllëse nga dymbëdhjetë muajt e kaluar.\n         *\n         * @param closingBalances Një listë e bilanceve përmbyllëse nga dymbëdhjetë muajt e kaluar.\n         * @return Mesatarja e bilancit të llogarisë.\n         *\n         * Shembull:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "hy": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Հաշվել միջին հաշվի մնացորդը վերջին տասներկու ամիսների փակման մնացորդների հիման վրա:\n         *\n         * @param closingBalances Վերջին տասներկու ամիսների փակման մնացորդների ցուցակ:\n         * @return Միջին հաշվի մնացորդը:\n         *\n         * Օրինակ:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Արդյունք: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "bn": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * গত বারো মাসের সমাপনী ব্যালেন্সের উপর ভিত্তি করে গড় অ্যাকাউন্ট ব্যালেন্স হিসাব করুন।\n         *\n         * @param closingBalances গত বারো মাসের সমাপনী ব্যালেন্সের একটি তালিকা।\n         * @return গড় অ্যাকাউন্ট ব্যালেন্স।\n         *\n         * উদাহরণ:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * আউটপুট: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "bg": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Изчисляване на средния баланс на сметката въз основа на крайните салда от последните дванадесет месеца.\n         *\n         * @param closingBalances Списък с крайните салда от последните дванадесет месеца.\n         * @return Средният баланс на сметката.\n         *\n         * Пример:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "zh": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * 根据过去十二个月的期末余额计算平均账户余额。\n         *\n         * @param closingBalances 过去十二个月的期末余额列表。\n         * @return 平均账户余额。\n         *\n         * 示例:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * 输出: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "fr": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculer le solde moyen du compte basé sur les soldes de clôture des douze derniers mois.\n         *\n         * @param closingBalances Une liste de soldes de clôture des douze derniers mois.\n         * @return Le solde moyen du compte.\n         *\n         * Exemple:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Sortie: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "de": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Berechne den durchschnittlichen Kontostand basierend auf den Schlussbilanzen der letzten zwölf Monate.\n         *\n         * @param closingBalances Eine Liste von Schlussbilanzen der letzten zwölf Monate.\n         * @return Der durchschnittliche Kontostand.\n         *\n         * Beispiel:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Ausgabe: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "ha": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Lissafa matsakaicin ma'auni na asusu bisa ga ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n         *\n         * @param closingBalances Jerin ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n         * @return Matsakaicin ma'auni na asusu.\n         *\n         * Misali:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Fitarwa: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "hi": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * पिछले बारह महीनों के समापन शेष के आधार पर औसत खाता शेष की गणना करें।\n         *\n         * @param closingBalances पिछले बारह महीनों के समापन शेष की सूची।\n         * @return औसत खाता शेष।\n         *\n         * उदाहरण:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "hu": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Számítsa ki az átlagos számlaegyenleget az elmúlt tizenkét hónap záró egyenlegei alapján.\n         *\n         * @param closingBalances Az elmúlt tizenkét hónap záró egyenlegeinek listája.\n         * @return Az átlagos számlaegyenleg.\n         *\n         * Példa:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Kimenet: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)"
    },
    "prompt_bertscore": {
      "sq": "0.9991274167361137",
      "hy": "0.9845149741249012",
      "bn": "0.9883703898207883",
      "bg": "0.9889476097080757",
      "zh": "0.9818310804163577",
      "fr": "0.9964468997440479",
      "de": "0.9964468997440479",
      "ha": "0.975644141307883",
      "hi": "0.9804740376531274",
      "hu": "0.9945583220811682"
    },
    "canonical_solution": "    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }",
    "instruction": {
      "en": "Write a Java function `public static double calculateAverageBalance(List<Double> closingBalances)` to solve the following problem:\nCalculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "sq": "Shkruani një funksion Java `public static double calculateAverageBalance(List<Double> closingBalances)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni mesataren e bilancit të llogarisë bazuar në bilancet përfundimtare nga dymbëdhjetë muajt e kaluar.\n\n@param closingBalances Një listë e bilanceve përfundimtare nga dymbëdhjetë muajt e kaluar.\n@return Mesatarja e bilancit të llogarisë.\n\nShembull:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "hy": "Գրեք Java ֆունկցիա `public static double calculateAverageBalance(List<Double> closingBalances)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք միջին հաշվի մնացորդը՝ հիմնվելով վերջին տասներկու ամիսների փակման մնացորդների վրա։\n\n@param closingBalances Վերջին տասներկու ամիսների փակման մնացորդների ցուցակ։\n@return Միջին հաշվի մնացորդը։\n\nՕրինակ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nԵլք: 1581.42",
      "bn": "একটি জাভা ফাংশন `public static double calculateAverageBalance(List<Double> closingBalances)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nগত বারো মাসের ক্লোজিং ব্যালেন্সের ভিত্তিতে গড় অ্যাকাউন্ট ব্যালেন্স গণনা করুন।\n\n@param closingBalances গত বারো মাসের ক্লোজিং ব্যালেন্সের একটি তালিকা।\n@return গড় অ্যাকাউন্ট ব্যালেন্স।\n\nউদাহরণ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nআউটপুট: 1581.42",
      "bg": "Напишете Java функция `public static double calculateAverageBalance(List<Double> closingBalances)` за решаване на следния проблем:\nИзчислете средния баланс на сметката въз основа на крайните салда от последните дванадесет месеца.\n\n@param closingBalances Списък с крайните салда от последните дванадесет месеца.\n@return Средният баланс на сметката.\n\nПример:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nИзход: 1581.42",
      "zh": "编写一个 Java 函数 `public static double calculateAverageBalance(List<Double> closingBalances)` 来解决以下问题：\n根据过去十二个月的期末余额计算平均账户余额。\n\n@param closingBalances 过去十二个月的期末余额列表。\n@return 平均账户余额。\n\n示例：\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n输出: 1581.42",
      "fr": "Écrire une fonction Java `public static double calculateAverageBalance(List<Double> closingBalances)` pour résoudre le problème suivant :  \nCalculer le solde moyen du compte basé sur les soldes de clôture des douze derniers mois.\n\n@param closingBalances Une liste de soldes de clôture des douze derniers mois.  \n@return Le solde moyen du compte.\n\nExemple :  \ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))  \nSortie : 1581.42",
      "de": "Schreiben Sie eine Java-Funktion `public static double calculateAverageBalance(List<Double> closingBalances)`, um das folgende Problem zu lösen:\nBerechnen Sie den durchschnittlichen Kontostand basierend auf den Schlussbilanzen der letzten zwölf Monate.\n\n@param closingBalances Eine Liste von Schlussbilanzen der letzten zwölf Monate.\n@return Der durchschnittliche Kontostand.\n\nBeispiel:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nAusgabe: 1581.42",
      "ha": "Rubuta aikin Java `public static double calculateAverageBalance(List<Double> closingBalances)` don warware matsalar mai zuwa:\nƘididdige matsakaicin ma'auni na asusu bisa ga ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n\n@param closingBalances Jerin ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n@return Matsakaicin ma'auni na asusu.\n\nMisali:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nFitarwa: 1581.42",
      "hi": "Java फ़ंक्शन `public static double calculateAverageBalance(List<Double> closingBalances)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nपिछले बारह महीनों के समापन संतुलनों के आधार पर औसत खाता संतुलन की गणना करें।\n\n@param closingBalances पिछले बारह महीनों के समापन संतुलनों की सूची।\n@return औसत खाता संतुलन।\n\nउदाहरण:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nआउटपुट: 1581.42",
      "hu": "Írj egy Java függvényt `public static double calculateAverageBalance(List<Double> closingBalances)` a következő probléma megoldására:\nSzámítsd ki az átlagos számlaegyenleget az elmúlt tizenkét hónap záró egyenlegei alapján.\n\n@param closingBalances Az elmúlt tizenkét hónap záró egyenlegeinek listája.\n@return Az átlagos számlaegyenleg.\n\nPélda:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nKimenet: 1581.42"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9786913299833393",
      "bn": "0.9959827005435694",
      "bg": "0.9885729928094439",
      "zh": "0.98025574286437",
      "fr": "0.9948936101643551",
      "de": "0.9793440294154199",
      "ha": "0.9774983559148437",
      "hi": "0.964217134117327",
      "hu": "0.9954215697171458"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "calculateAverageBalance",
    "signature": "public static double calculateAverageBalance(List<Double> closingBalances)",
    "docstring": {
      "en": "Calculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "sq": "Llogaritni bilancin mesatar të llogarisë bazuar në bilancet përfundimtare nga dymbëdhjetë muajt e kaluar.\n\n@param closingBalances Një listë e bilanceve përfundimtare nga dymbëdhjetë muajt e kaluar.\n@return Bilanci mesatar i llogarisë.\n\nShembull:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "hy": "Հաշվարկել միջին հաշվի մնացորդը վերջին տասներկու ամիսների փակման մնացորդների հիման վրա։\n\n@param closingBalances Վերջին տասներկու ամիսների փակման մնացորդների ցուցակ։\n@return Միջին հաշվի մնացորդը։\n\nՕրինակ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "bn": "গত বারো মাসের সমাপনী ব্যালেন্সের উপর ভিত্তি করে গড় অ্যাকাউন্ট ব্যালেন্স হিসাব করুন।\n\n@param closingBalances গত বারো মাসের সমাপনী ব্যালেন্সের একটি তালিকা।\n@return গড় অ্যাকাউন্ট ব্যালেন্স।\n\nউদাহরণ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nআউটপুট: 1581.42",
      "bg": "Изчислява средния баланс на сметката въз основа на крайните салда от последните дванадесет месеца.\n\n@param closingBalances Списък с крайните салда от последните дванадесет месеца.\n@return Средният баланс на сметката.\n\nПример:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nИзход: 1581.42",
      "zh": "计算基于过去十二个月的期末余额的平均账户余额。\n\n@param closingBalances 过去十二个月的期末余额列表。\n@return 平均账户余额。\n\n示例：\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n输出: 1581.42",
      "fr": "Calculer le solde moyen du compte basé sur les soldes de clôture des douze derniers mois.\n\n@param closingBalances Une liste de soldes de clôture des douze derniers mois.\n@return Le solde moyen du compte.\n\nExemple:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nSortie: 1581.42",
      "de": "Berechnen Sie den durchschnittlichen Kontostand basierend auf den Schlussbilanzen der letzten zwölf Monate.\n\n@param closingBalances Eine Liste von Schlussbilanzen der letzten zwölf Monate.\n@return Der durchschnittliche Kontostand.\n\nBeispiel:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nAusgabe: 1581.42",
      "ha": "Lissafa matsakaicin ma'auni na asusu bisa ga ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n\n@param closingBalances Jerin lambobi na rufe ma'auni daga watanni goma sha biyu da suka gabata.\n@return Matsakaicin ma'aunin asusu.\n\nMisali:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "hi": "पिछले बारह महीनों के समापन संतुलनों के आधार पर औसत खाता शेष की गणना करें।\n\n@param closingBalances पिछले बारह महीनों के समापन संतुलनों की एक सूची।\n@return औसत खाता शेष।\n\nउदाहरण:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nआउटपुट: 1581.42",
      "hu": "Számítsa ki az átlagos számlaegyenleget az elmúlt tizenkét hónap záróegyenlegei alapján.\n\n@param closingBalances Az elmúlt tizenkét hónap záróegyenlegeinek listája.\n@return Az átlagos számlaegyenleg.\n\nPélda:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nKimenet: 1581.42"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9824595469419521",
      "bn": "0.9919568599807542",
      "bg": "0.9838505555003394",
      "zh": "0.9607220339326371",
      "fr": "0.9942635545957125",
      "de": "0.993845239013253",
      "ha": "0.982965259892067",
      "hi": "0.9825648210439006",
      "hu": "0.9824595469419521"
    }
  },
  {
    "task_id": "Java/2",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një numër të plotë pozitiv Y që tregon vitin e fillimit, dhe një numër të plotë pozitiv N,\n     * kjo funksion gjen vitin e N-të i brishtë pas vitit të fillimit Y.\n     *\n     * @param Y Viti i fillimit.\n     * @param N Pozicioni i vitit të brishtë për të gjetur.\n     * @return Viti i N-të i brishtë pas vitit të fillimit Y.\n     *\n     * Shembull:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "hy": "class Solution {\n    /**\n     * Տրված է դրական ամբողջ թիվ Y, որը ցույց է տալիս մեկնարկային տարին, և դրական ամբողջ թիվ N,\n     * այս ֆունկցիան գտնում է N-րդ նահանջ տարին մեկնարկային տարուց Y հետո:\n     *\n     * @param Y Մեկնարկային տարի:\n     * @param N Գտնվող նահանջ տարվա դիրքը:\n     * @return N-րդ նահանջ տարին մեկնարկային տարուց Y հետո:\n     *\n     * Օրինակ:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "bn": "class Solution {\n    /**\n     * প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যা Y যা শুরু বছরের নির্দেশ করে, এবং একটি ধনাত্মক পূর্ণসংখ্যা N,\n     * এই ফাংশনটি শুরু বছর Y এর পরে N তম অধিবর্ষ খুঁজে বের করে।\n     *\n     * @param Y শুরু বছর।\n     * @param N খুঁজে বের করার জন্য অধিবর্ষের অবস্থান।\n     * @return শুরু বছর Y এর পরে N তম অধিবর্ষ।\n     *\n     * উদাহরণ:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "bg": "class Solution {\n    /**\n     * Като се даде положително цяло число Y, указващо началната година, и положително цяло число N,\n     * тази функция намира N-тата високосна година след началната година Y.\n     *\n     * @param Y Началната година.\n     * @param N Позицията на високосната година, която да се намери.\n     * @return N-тата високосна година след началната година Y.\n     *\n     * Пример:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "zh": "class Solution {\n    /**\n     * 给定一个表示起始年份的正整数Y，以及一个正整数N，\n     * 此函数查找起始年份Y之后的第N个闰年。\n     *\n     * @param Y 起始年份。\n     * @param N 要查找的闰年的位置。\n     * @return 起始年份Y之后的第N个闰年。\n     *\n     * 例子:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un entier positif Y indiquant l'année de départ, et un entier positif N,\n     * cette fonction trouve la Nième année bissextile après l'année de départ Y.\n     *\n     * @param Y L'année de départ.\n     * @param N La position de l'année bissextile à trouver.\n     * @return La Nième année bissextile après l'année de départ Y.\n     *\n     * Exemple:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "de": "class Solution {\n    /**\n     * Gegeben ist eine positive Ganzzahl Y, die das Startjahr angibt, und eine positive Ganzzahl N,\n     * diese Funktion findet das N-te Schaltjahr nach dem Startjahr Y.\n     *\n     * @param Y Das Startjahr.\n     * @param N Die Position des zu findenden Schaltjahres.\n     * @return Das N-te Schaltjahr nach dem Startjahr Y.\n     *\n     * Beispiel:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "ha": "class Solution {\n    /**\n     * An ba da lamba mai kyau Y da ke nuna shekarar farawa, da kuma lamba mai kyau N,\n     * wannan aikin yana nemo shekarar tsalle-tsalle ta N bayan shekarar farawa Y.\n     *\n     * @param Y Shekarar farawa.\n     * @param N Matsayin shekarar tsalle-tsalle da za a nema.\n     * @return Shekarar tsalle-tsalle ta N bayan shekarar farawa Y.\n     *\n     * Misali:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक धनात्मक पूर्णांक Y जो प्रारंभ वर्ष को दर्शाता है, और एक धनात्मक पूर्णांक N,\n     * यह फ़ंक्शन प्रारंभ वर्ष Y के बाद Nवें लीप वर्ष को खोजता है।\n     *\n     * @param Y प्रारंभ वर्ष।\n     * @param N खोजने के लिए लीप वर्ष की स्थिति।\n     * @return प्रारंभ वर्ष Y के बाद Nवां लीप वर्ष।\n     *\n     * उदाहरण:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "hu": "class Solution {\n    /**\n     * Adott egy pozitív egész szám Y, amely a kezdő évet jelzi, és egy pozitív egész szám N,\n     * ez a függvény megkeresi az N-edik szökőévet a kezdő év Y után.\n     *\n     * @param Y A kezdő év.\n     * @param N A megtalálandó szökőév pozíciója.\n     * @return Az N-edik szökőév a kezdő év Y után.\n     *\n     * Példa:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) "
    },
    "prompt_bertscore": {
      "sq": "0.9844307548433423",
      "hy": "0.9662944106421898",
      "bn": "0.9841918024949574",
      "bg": "0.9716763008163302",
      "zh": "0.9853994752116495",
      "fr": "0.9963197763001856",
      "de": "0.9731950287097229",
      "ha": "0.9853994752116495",
      "hi": "0.9681043306741797",
      "hu": "0.9884961228519834"
    },
    "canonical_solution": "    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }",
    "instruction": {
      "en": "Write a Java function `public static int findNthLeapYear(int Y, int N)` to solve the following problem:\nGiven a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "sq": "Shkruani një funksion Java `public static int findNthLeapYear(int Y, int N)` për të zgjidhur problemin në vijim:\nDuke pasur një numër të plotë pozitiv Y që tregon vitin e fillimit, dhe një numër të plotë pozitiv N,\nky funksion gjen vitin e N-të të brishtë pas vitit të fillimit Y.\n\n@param Y Viti i fillimit.\n@param N Pozicioni i vitit të brishtë për të gjetur.\n@return Viti i N-të i brishtë pas vitit të fillimit Y.\n\nShembull:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hy": "Գրեք Java ֆունկցիա `public static int findNthLeapYear(int Y, int N)` հետևյալ խնդիրը լուծելու համար:\nՏրված է դրական ամբողջ թիվ Y, որը ցույց է տալիս մեկնարկային տարին, և դրական ամբողջ թիվ N,\nայս ֆունկցիան գտնում է N-րդ նահանջ տարին մեկնարկային տարուց Y հետո:\n\n@param Y Մեկնարկային տարին։\n@param N Գտնվող նահանջ տարվա դիրքը։\n@return N-րդ նահանջ տարին մեկնարկային տարուց Y հետո։\n\nՕրինակ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "bn": "একটি জাভা ফাংশন `public static int findNthLeapYear(int Y, int N)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ধনাত্মক পূর্ণসংখ্যা Y দেওয়া হয়েছে যা শুরু বছরের নির্দেশ করে, এবং একটি ধনাত্মক পূর্ণসংখ্যা N দেওয়া হয়েছে,\nএই ফাংশনটি শুরু বছর Y এর পরে N তম লিপ বছর খুঁজে বের করে।\n\n@param Y শুরু বছর।\n@param N খুঁজে বের করার জন্য লিপ বছরের অবস্থান।\n@return শুরু বছর Y এর পরে N তম লিপ বছর।\n\nউদাহরণ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "bg": "Напишете Java функция `public static int findNthLeapYear(int Y, int N)`, за да решите следния проблем:\nДадено е положително цяло число Y, което указва началната година, и положително цяло число N, тази функция намира N-тата високосна година след началната година Y.\n\n@param Y Началната година.\n@param N Позицията на високосната година, която да се намери.\n@return N-тата високосна година след началната година Y.\n\nПример:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "zh": "编写一个 Java 函数 `public static int findNthLeapYear(int Y, int N)` 来解决以下问题：\n给定一个表示起始年份的正整数 Y 和一个正整数 N，\n此函数查找起始年份 Y 之后的第 N 个闰年。\n\n@param Y 起始年份。\n@param N 要查找的闰年的位置。\n@return 起始年份 Y 之后的第 N 个闰年。\n\n示例：\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "fr": "Écrire une fonction Java `public static int findNthLeapYear(int Y, int N)` pour résoudre le problème suivant :\nÉtant donné un entier positif Y indiquant l'année de départ, et un entier positif N,\ncette fonction trouve la Nième année bissextile après l'année de départ Y.\n\n@param Y L'année de départ.\n@param N La position de l'année bissextile à trouver.\n@return La Nième année bissextile après l'année de départ Y.\n\nExemple :\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "de": "Schreiben Sie eine Java-Funktion `public static int findNthLeapYear(int Y, int N)`, um das folgende Problem zu lösen:\nGegeben ist eine positive Ganzzahl Y, die das Startjahr angibt, und eine positive Ganzzahl N. Diese Funktion findet das N-te Schaltjahr nach dem Startjahr Y.\n\n@param Y Das Startjahr.\n@param N Die Position des zu findenden Schaltjahres.\n@return Das N-te Schaltjahr nach dem Startjahr Y.\n\nBeispiel:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "ha": "Rubuta aikin Java `public static int findNthLeapYear(int Y, int N)` don warware matsalar mai zuwa:\nAn ba da cikakken lamba Y da ke nuna shekarar farawa, da cikakken lamba N,\nwannan aikin yana nemo shekarar tsalle ta N bayan shekarar farawa Y.\n\n@param Y Shekarar farawa.\n@param N Matsayin shekarar tsalle da za a nema.\n@return Shekarar tsalle ta N bayan shekarar farawa Y.\n\nMisali:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hi": "एक जावा फ़ंक्शन `public static int findNthLeapYear(int Y, int N)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया एक धनात्मक पूर्णांक Y जो प्रारंभिक वर्ष को दर्शाता है, और एक धनात्मक पूर्णांक N,\nयह फ़ंक्शन प्रारंभिक वर्ष Y के बाद Nवें लीप वर्ष को खोजता है।\n\n@param Y प्रारंभिक वर्ष।\n@param N खोजने के लिए लीप वर्ष की स्थिति।\n@return प्रारंभिक वर्ष Y के बाद Nवां लीप वर्ष।\n\nउदाहरण:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hu": "Írj egy Java függvényt `public static int findNthLeapYear(int Y, int N)` a következő probléma megoldására:\nAdott egy pozitív egész szám Y, amely a kezdő évet jelzi, és egy pozitív egész szám N,\nez a függvény megkeresi az Y kezdő év utáni N-edik szökőévet.\n\n@param Y A kezdő év.\n@param N A megtalálandó szökőév pozíciója.\n@return Az Y kezdő év utáni N-edik szökőév.\n\nPélda:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032"
    },
    "instruction_bertscore": {
      "sq": "0.9852371941903441",
      "hy": "0.9779597742899878",
      "bn": "0.9574597285545201",
      "bg": "0.976412443621726",
      "zh": "0.9849203787325933",
      "fr": "0.9963247420597114",
      "de": "0.9757676894048868",
      "ha": "0.9630495847376039",
      "hi": "0.9707145325113592",
      "hu": "0.9779597742899878"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "findNthLeapYear",
    "signature": "public static int findNthLeapYear(int Y, int N)",
    "docstring": {
      "en": "Given a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "sq": "Duke pasur një numër të plotë pozitiv Y që tregon vitin e fillimit, dhe një numër të plotë pozitiv N, kjo funksion gjen vitin e N-të i brishtë pas vitit të fillimit Y.\n\n@param Y Viti i fillimit.\n@param N Pozicioni i vitit të brishtë për të gjetur.\n@return Viti i N-të i brishtë pas vitit të fillimit Y.\n\nShembull:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hy": "Տրված է դրական ամբողջ թիվ Y, որը ցույց է տալիս մեկնարկային տարին, և դրական ամբողջ թիվ N,  \nայս ֆունկցիան գտնում է N-րդ նահանջ տարին մեկնարկային տարուց Y հետո։\n\n@param Y Մեկնարկային տարին։\n@param N Նահանջ տարվա գտնվելու դիրքը։\n@return N-րդ նահանջ տարին մեկնարկային տարուց Y հետո։\n\nՕրինակ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "bn": "প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যা Y যা শুরু বছরের নির্দেশ করে, এবং একটি ধনাত্মক পূর্ণসংখ্যা N, এই ফাংশনটি শুরু বছর Y এর পরবর্তী N তম অধিবর্ষ খুঁজে বের করে।\n\n@param Y শুরু বছর।\n@param N খুঁজে বের করার জন্য অধিবর্ষের অবস্থান।\n@return শুরু বছর Y এর পরবর্তী N তম অধিবর্ষ।\n\nউদাহরণ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "bg": "Дадено е положително цяло число Y, указващо началната година, и положително цяло число N, тази функция намира N-тата високосна година след началната година Y.\n\n@param Y Началната година.\n@param N Позицията на високосната година, която да се намери.\n@return N-тата високосна година след началната година Y.\n\nПример:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "zh": "给定一个正整数 Y 表示起始年份，以及一个正整数 N，此函数查找起始年份 Y 之后的第 N 个闰年。\n\n@param Y 起始年份。\n@param N 要查找的闰年的位置。\n@return 起始年份 Y 之后的第 N 个闰年。\n\n示例：\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "fr": "Étant donné un entier positif Y indiquant l'année de départ, et un entier positif N, cette fonction trouve la Nième année bissextile après l'année de départ Y.\n\n@param Y L'année de départ.\n@param N La position de l'année bissextile à trouver.\n@return La Nième année bissextile après l'année de départ Y.\n\nExemple :\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "de": "Angenommen, eine positive Ganzzahl Y gibt das Startjahr an, und eine positive Ganzzahl N,\ndiese Funktion findet das N-te Schaltjahr nach dem Startjahr Y.\n\n@param Y Das Startjahr.\n@param N Die Position des zu findenden Schaltjahres.\n@return Das N-te Schaltjahr nach dem Startjahr Y.\n\nBeispiel:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "ha": "An ba da lamba mai kyau Y da ke nuna shekarar farawa, da kuma lamba mai kyau N, wannan aikin yana nemo shekarar tsalle-ta-tsalle ta N bayan shekarar farawa Y.\n\n@param Y Shekarar farawa.\n@param N Matsayin shekarar tsalle-ta-tsalle da za a nema.\n@return Shekarar tsalle-ta-tsalle ta N bayan shekarar farawa Y.\n\nMisali:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hi": "एक सकारात्मक पूर्णांक Y दिया गया है जो प्रारंभिक वर्ष को दर्शाता है, और एक सकारात्मक पूर्णांक N, यह फ़ंक्शन प्रारंभिक वर्ष Y के बाद Nवां लीप वर्ष खोजता है।\n\n@param Y प्रारंभिक वर्ष।\n@param N खोजने के लिए लीप वर्ष की स्थिति।\n@return प्रारंभिक वर्ष Y के बाद Nवां लीप वर्ष।\n\nउदाहरण:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hu": "Adott egy pozitív egész szám Y, amely az induló évet jelzi, és egy pozitív egész szám N, ez a függvény megkeresi az N-edik szökőévet az induló év Y után.\n\n@param Y Az induló év.\n@param N A keresendő szökőév pozíciója.\n@return Az N-edik szökőév az induló év Y után.\n\nPélda:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032"
    },
    "docstring_bertscore": {
      "sq": "0.9818132036820646",
      "hy": "0.9674675216725819",
      "bn": "0.9738070089136913",
      "bg": "0.9747491128109398",
      "zh": "0.9796683928276498",
      "fr": "0.9945358768481113",
      "de": "0.9630605094085608",
      "ha": "0.9810478808239371",
      "hi": "0.967821282381205",
      "hu": "0.9674675216725819"
    }
  },
  {
    "task_id": "Java/3",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Calculate the time needed to obtain the reverse seating order.\n     * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n     * \n     * @param N the number of people\n     * @return the time needed in minutes\n     * \n     * Example:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "sq": "class Solution {\n    /**\n     * Llogarit kohën e nevojshme për të marrë rendin e kundërt të ulëseve.\n     * Për çdo person, personi që fillimisht ishte në të majtë të tij do të jetë në të djathtë, dhe personi që fillimisht ishte në të djathtë të tij do të jetë në të majtë.\n     * \n     * @param N numri i njerëzve\n     * @return koha e nevojshme në minuta\n     * \n     * Shembull:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "hy": "class Solution {\n    /**\n     * Հաշվարկել ժամանակը, որը անհրաժեշտ է հակառակ նստեցման կարգը ստանալու համար:\n     * Յուրաքանչյուր անձի համար, այն անձը, որը սկզբնապես նրա ձախ կողմում էր, կլինի նրա աջ կողմում, իսկ այն անձը, որը սկզբնապես նրա աջ կողմում էր, կլինի նրա ձախ կողմում:\n     * \n     * @param N մարդկանց քանակը\n     * @return անհրաժեշտ ժամանակը րոպեներով\n     * \n     * Օրինակ:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "bn": "class Solution {\n    /**\n     * বিপরীত আসন বিন্যাস পেতে প্রয়োজনীয় সময় গণনা করুন।\n     * প্রতিটি ব্যক্তির জন্য, যে ব্যক্তি মূলত তাদের বাম পাশে ছিল সে তাদের ডান পাশে থাকবে, এবং যে ব্যক্তি মূলত তাদের ডান পাশে ছিল সে তাদের বাম পাশে থাকবে।\n     * \n     * @param N মানুষের সংখ্যা\n     * @return প্রয়োজনীয় সময় মিনিটে\n     * \n     * উদাহরণ:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "bg": "class Solution {\n    /**\n     * Изчислете времето, необходимо за получаване на обратния ред на сядане.\n     * За всеки човек, човекът, който първоначално е бил отляво, ще бъде отдясно, и човекът, който първоначално е бил отдясно, ще бъде отляво.\n     * \n     * @param N броят на хората\n     * @return времето, необходимо в минути\n     * \n     * Пример:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "zh": "class Solution {\n    /**\n     * 计算获得反向座位顺序所需的时间。\n     * 对于每个人，原本在他们左边的人将会在他们的右边，而原本在他们右边的人将会在他们的左边。\n     * \n     * @param N 人数\n     * @return 所需时间（分钟）\n     * \n     * 示例:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "fr": "class Solution {\n    /**\n     * Calculer le temps nécessaire pour obtenir l'ordre de placement inversé.\n     * Pour chaque personne, la personne qui était à l'origine à sa gauche sera à sa droite, et la personne qui était à l'origine à sa droite sera à sa gauche.\n     * \n     * @param N le nombre de personnes\n     * @return le temps nécessaire en minutes\n     * \n     * Exemple:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "de": "class Solution {\n    /**\n     * Berechne die benötigte Zeit, um die umgekehrte Sitzordnung zu erhalten.\n     * Für jede Person wird die Person, die ursprünglich links von ihr war, rechts von ihr sein, und die Person, die ursprünglich rechts von ihr war, wird links von ihr sein.\n     * \n     * @param N die Anzahl der Personen\n     * @return die benötigte Zeit in Minuten\n     * \n     * Beispiel:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "ha": "class Solution {\n    /**\n     * Lissafa lokacin da ake buƙata don samun tsarin zama na baya.\n     * Ga kowane mutum, mutumin da ke a gefensu na hagu a asali zai kasance a gefensu na dama, kuma mutumin da ke a gefensu na dama a asali zai kasance a gefensu na hagu.\n     * \n     * @param N adadin mutanen\n     * @return lokacin da ake buƙata a cikin mintuna\n     * \n     * Misali:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "hi": "class Solution {\n    /**\n     * उलटी बैठने की व्यवस्था प्राप्त करने के लिए आवश्यक समय की गणना करें।\n     * प्रत्येक व्यक्ति के लिए, जो व्यक्ति मूल रूप से उनकी बाईं ओर था, वह उनकी दाईं ओर होगा, और जो व्यक्ति मूल रूप से उनकी दाईं ओर था, वह उनकी बाईं ओर होगा।\n     * \n     * @param N लोगों की संख्या\n     * @return आवश्यक समय मिनटों में\n     * \n     * उदाहरण:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "hu": "class Solution {\n    /**\n     * Számítsa ki a fordított ülésrend eléréséhez szükséges időt.\n     * Minden személy esetében az a személy, aki eredetileg a balján volt, a jobbján lesz, és az a személy, aki eredetileg a jobbján volt, a balján lesz.\n     * \n     * @param N a személyek száma\n     * @return a szükséges idő percekben\n     * \n     * Példa:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) "
    },
    "prompt_bertscore": {
      "sq": "0.9872604432515654",
      "hy": "0.9934817454159591",
      "bn": "0.9820046833693822",
      "bg": "0.9860293321499112",
      "zh": "0.9530114011712437",
      "fr": "0.9987253888448991",
      "de": "0.9883701911904073",
      "ha": "0.9492680130102602",
      "hi": "0.9755545590060363",
      "hu": "0.9894473637467595"
    },
    "canonical_solution": "    {\n        return N / 2;\n    }",
    "instruction": {
      "en": "Write a Java function `public static int calculateTimeNeeded(int N)` to solve the following problem:\nCalculate the time needed to obtain the reverse seating order.\nFor each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n\n@param N the number of people\n@return the time needed in minutes\n\nExample:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "sq": "Shkruani një funksion Java `public static int calculateTimeNeeded(int N)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni kohën e nevojshme për të marrë renditjen e kundërt të uljes.  \nPër secilin person, personi që fillimisht ishte në të majtë do të jetë në të djathtë, dhe personi që fillimisht ishte në të djathtë do të jetë në të majtë.\n\n@param N numri i njerëzve  \n@return koha e nevojshme në minuta\n\nShembull:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "hy": "Գրեք Java ֆունկցիա `public static int calculateTimeNeeded(int N)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ժամանակը, որը անհրաժեշտ է հակառակ նստատեղերի կարգը ստանալու համար:\nՅուրաքանչյուր անձի համար, այն անձը, ով սկզբում նրա ձախում էր, կլինի նրա աջում, իսկ այն անձը, ով սկզբում նրա աջում էր, կլինի նրա ձախում:\n\n@param N մարդկանց քանակը\n@return անհրաժեշտ ժամանակը րոպեներով\n\nՕրինակ:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "bn": "একটি জাভা ফাংশন `public static int calculateTimeNeeded(int N)` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করতে:\nউল্টো আসন বিন্যাস পেতে যে সময় প্রয়োজন তা গণনা করুন।\nপ্রতিটি ব্যক্তির জন্য, যে ব্যক্তি মূলত তার বাম পাশে ছিল সে তার ডান পাশে থাকবে, এবং যে ব্যক্তি মূলত তার ডান পাশে ছিল সে তার বাম পাশে থাকবে।\n\n@param N মানুষের সংখ্যা\n@return প্রয়োজনীয় সময় মিনিটে\n\nউদাহরণ:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "bg": "Напишете Java функция `public static int calculateTimeNeeded(int N)`, за да решите следния проблем:  \nИзчислете времето, необходимо за получаване на обратния ред на сядане.  \nЗа всеки човек, човекът, който първоначално е бил отляво, ще бъде отдясно, и човекът, който първоначално е бил отдясно, ще бъде отляво.\n\n@param N броят на хората  \n@return необходимото време в минути  \n\nПример:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "zh": "编写一个 Java 函数 `public static int calculateTimeNeeded(int N)` 来解决以下问题：  \n计算获得反向座位顺序所需的时间。  \n对于每个人，原本在他们左边的人将会在他们的右边，原本在他们右边的人将会在他们的左边。\n\n@param N 人数  \n@return 所需时间（分钟）\n\n示例:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "fr": "Écrire une fonction Java `public static int calculateTimeNeeded(int N)` pour résoudre le problème suivant :  \nCalculer le temps nécessaire pour obtenir l'ordre de placement inversé.  \nPour chaque personne, la personne qui était à l'origine à sa gauche sera à sa droite, et la personne qui était à l'origine à sa droite sera à sa gauche.\n\n@param N le nombre de personnes  \n@return le temps nécessaire en minutes\n\nExemple :  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "de": "Schreiben Sie eine Java-Funktion `public static int calculateTimeNeeded(int N)`, um das folgende Problem zu lösen:\nBerechnen Sie die benötigte Zeit, um die umgekehrte Sitzordnung zu erhalten.\nFür jede Person wird die Person, die ursprünglich links von ihr saß, rechts von ihr sein, und die Person, die ursprünglich rechts von ihr saß, wird links von ihr sein.\n\n@param N die Anzahl der Personen\n@return die benötigte Zeit in Minuten\n\nBeispiel:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "ha": "Rubuta aikin Java `public static int calculateTimeNeeded(int N)` don warware matsalar mai zuwa:\nƘididdige lokacin da ake buƙata don samun tsarin zama na baya.\nGa kowane mutum, mutumin da ke a gefen hagu na asali zai kasance a gefen dama, kuma mutumin da ke a gefen dama na asali zai kasance a gefen hagu.\n\n@param N adadin mutanen\n@return lokacin da ake buƙata a cikin mintuna\n\nMisali:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "hi": "Java फ़ंक्शन `public static int calculateTimeNeeded(int N)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउल्टी बैठने की व्यवस्था प्राप्त करने के लिए आवश्यक समय की गणना करें।\nप्रत्येक व्यक्ति के लिए, जो व्यक्ति मूल रूप से उनके बाईं ओर था वह उनके दाईं ओर होगा, और जो व्यक्ति मूल रूप से उनके दाईं ओर था वह उनके बाईं ओर होगा।\n\n@param N लोगों की संख्या\n@return आवश्यक समय मिनटों में\n\nउदाहरण:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "hu": "Írj egy Java függvényt `public static int calculateTimeNeeded(int N)` a következő probléma megoldására:\nSzámítsd ki az időt, amely szükséges a fordított ülésrend eléréséhez.\nMinden személy esetében az a személy, aki eredetileg a bal oldalukon volt, a jobb oldalukra kerül, és az a személy, aki eredetileg a jobb oldalukon volt, a bal oldalukra kerül.\n\n@param N a személyek száma\n@return a szükséges idő percekben\n\nPélda:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6"
    },
    "instruction_bertscore": {
      "sq": "0.9668430277546082",
      "hy": "0.9841667750669469",
      "bn": "0.9826591704748922",
      "bg": "0.9762654571397602",
      "zh": "0.9554827603720798",
      "fr": "0.993589204452099",
      "de": "0.9820225601036754",
      "ha": "0.9371269295998838",
      "hi": "0.9692601608614217",
      "hu": "0.9714276155792745"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert calculateTimeNeeded(7) == 3;\n        assert calculateTimeNeeded(8) == 4;\n        assert calculateTimeNeeded(9) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "calculateTimeNeeded",
    "signature": "public static int calculateTimeNeeded(int N)",
    "docstring": {
      "en": "Calculate the time needed to obtain the reverse seating order.\nFor each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n\n@param N the number of people\n@return the time needed in minutes\n\nExample:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "sq": "Llogaritni kohën e nevojshme për të marrë rendin e kundërt të uljes. Për secilin person, personi që ishte fillimisht në të majtë të tij do të jetë në të djathtë, dhe personi që ishte fillimisht në të djathtë të tij do të jetë në të majtë.\n\n@param N numri i personave\n@return koha e nevojshme në minuta\n\nShembull:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "hy": "Հաշվարկել ժամանակը, որը անհրաժեշտ է հակառակ նստատեղերի կարգը ստանալու համար։\nՅուրաքանչյուր անձի համար, այն անձը, ով սկզբնապես նրանց ձախ կողմում էր, կլինի նրանց աջ կողմում, և այն անձը, ով սկզբնապես նրանց աջ կողմում էր, կլինի նրանց ձախ կողմում։\n\n@param N մարդկանց քանակը  \n@return անհրաժեշտ ժամանակը րոպեներով  \n\nՕրինակ:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "bn": "বিপরীত আসন বিন্যাস পেতে প্রয়োজনীয় সময় গণনা করুন।\nপ্রত্যেক ব্যক্তির জন্য, যে ব্যক্তি মূলত তাদের বাম দিকে ছিল সে তাদের ডান দিকে থাকবে, এবং যে ব্যক্তি মূলত তাদের ডান দিকে ছিল সে তাদের বাম দিকে থাকবে।\n\n@param N মানুষের সংখ্যা\n@return প্রয়োজনীয় সময় মিনিটে\n\nউদাহরণ:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "bg": "Изчислете времето, необходимо за получаване на обратния ред на сядане. За всеки човек, човекът, който първоначално е бил отляво, ще бъде отдясно, и човекът, който първоначално е бил отдясно, ще бъде отляво.\n\n@param N броят на хората\n@return времето, необходимо в минути\n\nПример:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "zh": "计算获得反向座次顺序所需的时间。\n对于每个人，原本在他们左边的人将会在他们的右边，而原本在他们右边的人将会在他们的左边。\n\n@param N 人数  \n@return 所需时间（分钟）\n\n示例：  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6  ",
      "fr": "Calculez le temps nécessaire pour obtenir l'ordre de placement inversé.\nPour chaque personne, la personne qui était à l'origine à sa gauche sera à sa droite, et la personne qui était à l'origine à sa droite sera à sa gauche.\n\n@param N le nombre de personnes  \n@return le temps nécessaire en minutes\n\nExemple :  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "de": "Berechne die benötigte Zeit, um die umgekehrte Sitzordnung zu erhalten.\nFür jede Person wird die Person, die ursprünglich links von ihr war, rechts von ihr sein, und die Person, die ursprünglich rechts von ihr war, wird links von ihr sein.\n\n@param N die Anzahl der Personen\n@return die benötigte Zeit in Minuten\n\nBeispiel:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "ha": "Ƙididdige lokacin da ake buƙata don samun tsarin zama na baya.\nGa kowane mutum, mutumin da ke a asalin gefen hagu zai kasance a gefen dama, kuma mutumin da ke a asalin gefen dama zai kasance a gefen hagu.\n\n@param N adadin mutanen\n@return lokacin da ake buƙata a cikin mintuna\n\nMisali:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "hi": "उलटी बैठने की व्यवस्था प्राप्त करने के लिए आवश्यक समय की गणना करें।\nप्रत्येक व्यक्ति के लिए, जो व्यक्ति मूल रूप से उनकी बाईं ओर था, वह उनकी दाईं ओर होगा, और जो व्यक्ति मूल रूप से उनकी दाईं ओर था, वह उनकी बाईं ओर होगा।\n\n@param N लोगों की संख्या  \n@return आवश्यक समय मिनटों में  \n\nउदाहरण:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6  ",
      "hu": "Számítsa ki a szükséges időt a fordított ülésrend eléréséhez.\nMinden személy esetében az a személy, aki eredetileg a bal oldalukon volt, a jobb oldalukon lesz, és az a személy, aki eredetileg a jobb oldalukon volt, a bal oldalukon lesz.\n\n@param N a személyek száma  \n@return a szükséges idő percekben\n\nPélda:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9661412666184119",
      "hy": "0.990105028938366",
      "bn": "0.9801010097975439",
      "bg": "0.9783602131381541",
      "zh": "0.9582671610534269",
      "fr": "0.9918998530613973",
      "de": "0.990441111543077",
      "ha": "0.935175187475835",
      "hi": "0.9801010097975439",
      "hu": "0.9919115722538783"
    }
  },
  {
    "task_id": "Java/4",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "sq": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Duke pasur një varg të numrave të plotë të dallueshëm, kthe të gjitha permutacionet e mundshme të vargut.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "hy": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Տրված է տարբեր ամբողջ թվերի զանգված, վերադարձնել զանգվածի բոլոր հնարավոր փոխատեղումները։\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "bn": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * ভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হলে, অ্যারের সমস্ত সম্ভাব্য বিন্যাসগুলি ফেরত দিন।\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "bg": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Като се даде масив от различни цели числа, върнете всички възможни пермутации на масива.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "zh": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * 给定一个不同整数的数组，返回数组的所有可能排列。\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "fr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Étant donné un tableau d'entiers distincts, retourner toutes les permutations possibles du tableau.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "de": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Gegeben ein Array von verschiedenen ganzen Zahlen, gebe alle möglichen Permutationen des Arrays zurück.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "ha": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * An ba da wani tsararren jerin lambobi, dawo da dukkan yiwuwar juyawar jerin.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "hi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * दिए गए भिन्न पूर्णांकों के एक array के सभी संभावित क्रमचयों को लौटाएं।\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "hu": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Adott egy különböző egész számokat tartalmazó tömb, adja vissza a tömb összes lehetséges permutációját.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9810895932039545",
      "hi": "0.9735692483475926",
      "hu": "0.9971083389128941"
    },
    "canonical_solution": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }",
    "instruction": {
      "en": "Write a Java function `public List<List<Integer>> permute(int[] nums)` to solve the following problem:\nGiven an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "sq": "Shkruani një funksion Java `public List<List<Integer>> permute(int[] nums)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg të numrave të plotë të ndryshëm, ktheni të gjitha permutacionet e mundshme të vargut.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hy": "Գրեք Java ֆունկցիա `public List<List<Integer>> permute(int[] nums)` հետևյալ խնդիրը լուծելու համար:\nՏրված է տարբեր ամբողջ թվերի զանգված, վերադարձնել զանգվածի բոլոր հնարավոր փոխատեղումները։\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "bn": "Java ফাংশন `public List<List<Integer>> permute(int[] nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্বতন্ত্র পূর্ণসংখ্যার অ্যারের দেওয়া হয়েছে, অ্যারের সমস্ত সম্ভাব্য বিন্যাস ফেরত দিন।\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "bg": "Напишете Java функция `public List<List<Integer>> permute(int[] nums)`, за да решите следния проблем:\nДаден е масив от различни цели числа, върнете всички възможни пермутации на масива.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "zh": "编写一个 Java 函数 `public List<List<Integer>> permute(int[] nums)` 来解决以下问题：\n给定一个不同整数的数组，返回该数组的所有可能排列。\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "fr": "Écrire une fonction Java `public List<List<Integer>> permute(int[] nums)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers distincts, retourner toutes les permutations possibles du tableau.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "de": "Schreiben Sie eine Java-Funktion `public List<List<Integer>> permute(int[] nums)`, um das folgende Problem zu lösen:\nGegeben ein Array von verschiedenen ganzen Zahlen, geben Sie alle möglichen Permutationen des Arrays zurück.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "ha": "Rubuta aikin Java `public List<List<Integer>> permute(int[] nums)` don warware matsalar mai zuwa:\nAn ba da jerin lambobi masu ma'ana daban-daban, dawo da duk yiwuwar permutations na jerin.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hi": "Java फ़ंक्शन `public List<List<Integer>> permute(int[] nums)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए भिन्न पूर्णांकों की एक array के लिए, array के सभी संभावित क्रमचयों को लौटाएं।\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hu": "Írj egy Java függvényt `public List<List<Integer>> permute(int[] nums)` a következő probléma megoldására:\nAdott egy tömb különböző egész számokkal, add vissza a tömb összes lehetséges permutációját.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]"
    },
    "instruction_bertscore": {
      "sq": "0.8334528793965562",
      "hy": "0.8334528793965562",
      "bn": "0.8334528793965562",
      "bg": "0.8334528793965562",
      "zh": "1",
      "fr": "1",
      "de": "0.8334528793965562",
      "ha": "0.8311421656407759",
      "hi": "0.8358687741878821",
      "hu": "0.8367785013330219"
    },
    "level": "hard",
    "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "permute",
    "signature": "public List<List<Integer>> permute(int[] nums)",
    "docstring": {
      "en": "Given an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "sq": "Duke pasur një varg të numrave të plotë të ndryshëm, kthe të gjitha permutacionet e mundshme të vargut.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hy": "Տրված է տարբեր ամբողջ թվերի զանգված, վերադարձնել զանգվածի բոլոր հնարավոր փոխադրումները:\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "bn": "বিভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হলে, অ্যারের সমস্ত সম্ভাব্য বিন্যাসগুলি ফেরত দিন।  \n>>> permute(new int[]{1,2,3})  \n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n>>> permute(new int[]{0,1})  \n[[0,1],[1,0]]  \n>>> permute(new int[]{1})  \n[[1]]  ",
      "bg": "Даден е масив от различни цели числа, върнете всички възможни пермутации на масива.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "zh": "给定一个不同整数的数组，返回该数组的所有可能排列。\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "fr": "Étant donné un tableau d'entiers distincts, renvoyez toutes les permutations possibles du tableau.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "de": "Gegeben ein Array von unterschiedlichen ganzen Zahlen, gib alle möglichen Permutationen des Arrays zurück.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "ha": "An bayar da wani tsararraki na lambobi masu bambanta, dawo da dukkan yiwuwar juyawa na tsararrakin.\n\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hi": "दिए गए भिन्न पूर्णांकों के एक array के लिए, array के सभी संभावित क्रमचयों को लौटाएं।\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hu": "Adott egy különböző egész számokat tartalmazó tömb, adja vissza a tömb összes lehetséges permutációját.  \n>>> permute(new int[]{1,2,3})  \n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n>>> permute(new int[]{0,1})  \n[[0,1],[1,0]]  \n>>> permute(new int[]{1})  \n[[1]]  "
    },
    "docstring_bertscore": {
      "sq": "0.9863403873266118",
      "hy": "0.9688539617322054",
      "bn": "0.9705820460472089",
      "bg": "0.999999801369619",
      "zh": "0.9751517365932976",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9942792463958142",
      "hi": "0.9796689887187929",
      "hu": "0.9955741178497807"
    }
  },
  {
    "task_id": "Java/5",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një numër vargjesh që janë të ndjeshme ndaj shkronjave të mëdha dhe të vogla, gjen vargun më të madh X, të tillë që ose X, ose inversi i tij mund të gjendet si një nënvarg i ndonjërit prej vargjeve të dhëna.\n     * \n     * Shembull:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է մեծատառ-փոքրատառ զգայուն տողերի քանակ, գտնում է ամենամեծ տողը X, այնպես, որ կա՛մ X, կա՛մ նրա հակադարձը կարող է գտնվել որպես ենթատող տրված ցանկացած տողի մեջ:\n     * \n     * Օրինակ:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * কিছু কেস-সেনসিটিভ স্ট্রিং দেওয়া হলে, সবচেয়ে বড় স্ট্রিং X খুঁজে বের করে, যাতে হয় X, অথবা তার বিপরীত কোনো একটি প্রদত্ত স্ট্রিং এর সাবস্ট্রিং হিসেবে পাওয়া যায়।\n     * \n     * উদাহরণ:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Като се даде брой низове, чувствителни към малки и големи букви, намира най-големия низ X, такъв че или X, или неговият обратен низ може да бъде намерен като подниз на който и да е от дадените низове.\n     * \n     * Пример:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定若干个区分大小写的字符串，找到最大的字符串X，使得X或其逆可以作为任何给定字符串的子字符串。\n     * \n     * 示例：\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un certain nombre de chaînes sensibles à la casse, trouve la plus grande chaîne X, telle que soit X, soit son inverse puisse être trouvée comme sous-chaîne de l'une des chaînes données.\n     * \n     * Exemple :\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben eine Anzahl von groß-/kleinbuchstabensensitiven Zeichenfolgen, findet die größte Zeichenfolge X, so dass entweder X oder ihr Inverses als Teilzeichenfolge in einer der gegebenen Zeichenfolgen gefunden werden kann.\n     * \n     * Beispiel:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da adadin igiyoyi masu bambancin manya da ƙananan haruffa, nemo mafi girman igiya X, ta yadda ko dai X, ko kuma akasin sa za a iya samun sa a matsayin wani ɓangare na kowane daga cikin igiyoyin da aka bayar.\n     * \n     * Misali:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए केस-सेंसिटिव स्ट्रिंग्स की संख्या के आधार पर, सबसे बड़ा स्ट्रिंग X खोजता है, ऐसा कि या तो X, या उसका उल्टा किसी भी दिए गए स्ट्रिंग्स के सबस्ट्रिंग के रूप में पाया जा सकता है।\n     * \n     * उदाहरण:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy számú kis- és nagybetűérzékeny sztring, megkeresi a legnagyobb X sztringet, úgy, hogy X vagy annak inverze bármelyik adott sztring al-sztringjeként megtalálható.\n     * \n     * Példa:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) "
    },
    "prompt_bertscore": {
      "sq": "0.9883203349647676",
      "hy": "0.9779073358693946",
      "bn": "0.978143507392445",
      "bg": "0.9869885182599286",
      "zh": "0.9660810816129584",
      "fr": "0.9850183035104435",
      "de": "0.9802565373858941",
      "ha": "0.9386718767035731",
      "hi": "0.9823707591616295",
      "hu": "0.9826875746193802"
    },
    "canonical_solution": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }",
    "instruction": {
      "en": "Write a Java function `public int findLargestSubstring(List<String> strings)` to solve the following problem:\nGiven a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "sq": "Shkruani një funksion Java `public int findLargestSubstring(List<String> strings)` për të zgjidhur problemin në vijim:  \nDuke pasur disa vargje që janë të ndjeshme ndaj shkronjave të mëdha e të vogla, gjeni vargun më të madh X, të tillë që ose X, ose inversi i tij mund të gjendet si një nënvarg në cilindo nga vargjet e dhëna.",
      "hy": "Գրեք Java ֆունկցիա `public int findLargestSubstring(List<String> strings)` լուծելու հետևյալ խնդիրը:\nՏրված են մեծատառ-փոքրատառ զգայուն մի քանի տողեր, գտնել ամենամեծ տողը X, այնպես, որ կա՛մ X-ը, կա՛մ նրա հակադարձը կարող են գտնվել որպես ենթատող տրված տողերից որևէ մեկում:\n\nՕրինակ:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "bn": "একটি জাভা ফাংশন `public int findLargestSubstring(List<String> strings)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সংখ্যা সংবেদনশীল স্ট্রিংগুলির একটি তালিকা দেওয়া হয়েছে, সবচেয়ে বড় স্ট্রিং X খুঁজে বের করুন, যাতে হয় X, অথবা তার বিপরীত যেকোনো প্রদত্ত স্ট্রিংয়ের একটি সাবস্ট্রিং হিসাবে পাওয়া যায়।",
      "bg": "Напишете Java функция `public int findLargestSubstring(List<String> strings)` за решаване на следния проблем:  \nДадени са няколко стринга, чувствителни към големината на буквите, намерете най-големия стринг X, такъв че или X, или неговият обратен може да бъде намерен като подстринг на някой от дадените стрингове.",
      "zh": "编写一个 Java 函数 `public int findLargestSubstring(List<String> strings)` 来解决以下问题：  \n给定若干个区分大小写的字符串，找到最大的字符串 X，使得 X 或其逆序可以作为任何给定字符串的子串找到。  \n\n示例:  \n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))  \n2  \n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))  \n2  ",
      "fr": "Écrire une fonction Java `public int findLargestSubstring(List<String> strings)` pour résoudre le problème suivant :  \nÉtant donné un certain nombre de chaînes sensibles à la casse, trouve la plus grande chaîne X, telle que soit X, soit son inverse puisse être trouvé comme sous-chaîne de l'une des chaînes données.\n\nExemple :  \n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))  \n2  \n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))  \n2",
      "de": "Schreiben Sie eine Java-Funktion `public int findLargestSubstring(List<String> strings)`, um das folgende Problem zu lösen:  \nGegeben ist eine Anzahl von Groß-/Kleinschreibung beachtenden Zeichenfolgen. Finden Sie die größte Zeichenfolge X, so dass entweder X oder ihr Inverses als Teilzeichenfolge in einer der gegebenen Zeichenfolgen gefunden werden kann.\n\nBeispiel:  \n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))  \n2  \n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))  \n2",
      "ha": "Rubuta aikin Java `public int findLargestSubstring(List<String> strings)` don warware matsalar mai zuwa:  \nAn ba da adadin kirtani masu bambancin manya da ƙananan haruffa, nemo mafi girman kirtani X, ta yadda ko dai X, ko kuma akasin sa za a iya samun su a matsayin kirtani a cikin kowane daga cikin kirtanin da aka bayar.\n\nMisali:  \n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))  \n2  \n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))  \n2",
      "hi": "Java फ़ंक्शन `public int findLargestSubstring(List<String> strings)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए केस-सेंसिटिव स्ट्रिंग्स की संख्या के आधार पर, सबसे बड़ा स्ट्रिंग X खोजें, ऐसा कि X या उसका उल्टा किसी भी दिए गए स्ट्रिंग का सबस्ट्रिंग हो सकता है।\n\nउदाहरण:  \n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))  \n2  \n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))  \n2",
      "hu": "Írj egy Java függvényt `public int findLargestSubstring(List<String> strings)` a következő probléma megoldására:  \nAdott egy számú kis- és nagybetű érzékeny karakterlánc, találja meg a legnagyobb X karakterláncot, úgy hogy X vagy annak inverze bármelyik adott karakterláncban megtalálható legyen alkarakterláncként."
    },
    "instruction_bertscore": {
      "sq": "0.8431268894485522",
      "hy": "0.9731344464435072",
      "bn": "0.8312847447616332",
      "bg": "0.8412643323655881",
      "zh": "0.9653409848132224",
      "fr": "0.985869434693178",
      "de": "0.9787836931105205",
      "ha": "0.943408019508969",
      "hi": "0.9504641651648523",
      "hu": "0.8403526189166379"
    },
    "level": "hard",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "findLargestSubstring",
    "signature": "public int findLargestSubstring(List<String> strings)",
    "docstring": {
      "en": "Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "sq": "Duke pasur një numër vargjesh që janë të ndjeshme ndaj shkronjave të mëdha dhe të vogla, gjen vargun më të madh X, i tillë që ose X, ose inversi i tij mund të gjendet si një nënvarg i ndonjërit prej vargjeve të dhëna.\n\nShembull:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "hy": "Տրված է մի քանի մեծատառ-փոքրատառ զգայուն տողեր, գտնում է ամենամեծ տողը X-ը, այնպես, որ կամ X-ը, կամ նրա հակադարձը կարող է գտնվել որպես ենթատող տրված տողերից որևէ մեկում:\n\nՕրինակ:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "bn": "প্রদত্ত কেস-সংবেদনশীল স্ট্রিংগুলির মধ্যে, বৃহত্তম স্ট্রিং X খুঁজে বের করে, যাতে হয় X, অথবা এর বিপরীত কোনো প্রদত্ত স্ট্রিংয়ের সাবস্ট্রিং হিসাবে পাওয়া যায়।\n\nউদাহরণ:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "bg": "Даден е брой низове, чувствителни към малки и големи букви, намира най-големия низ X, така че или X, или неговото обръщение да може да бъде намерено като подниз на който и да е от дадените низове.\n\nПример:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "zh": "给定若干个区分大小写的字符串，找到最大的字符串X，使得X或其逆序可以作为任意给定字符串的子串。\n\n例子：\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "fr": "Étant donné un certain nombre de chaînes sensibles à la casse, trouve la plus grande chaîne X, de sorte que soit X, soit son inverse puisse être trouvé comme une sous-chaîne de l'une des chaînes données.\n\nExemple :\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "de": "Angesichts einer Anzahl von groß- und kleinschreibungssensitiven Zeichenfolgen wird die größte Zeichenfolge X gefunden, sodass entweder X oder ihr Inverses als Teilzeichenfolge in einer der angegebenen Zeichenfolgen gefunden werden kann.\n\nBeispiel:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "ha": "An ba da adadin igiyoyin haruffa masu bambanci da manyan-baki da ƙananan-baki, yana nemo mafi girman igiya X, ta yadda ko dai X, ko kuma akasin sa za a iya samun sa a matsayin wani ɓangare na kowane daga cikin igiyoyin da aka bayar.\n\nMisali:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "hi": "दिए गए केस-सेंसिटिव स्ट्रिंग्स में से, सबसे बड़ी स्ट्रिंग X ढूंढें, ताकि या तो X, या उसका उल्टा किसी भी दिए गए स्ट्रिंग्स के उपस्ट्रिंग के रूप में पाया जा सके।\n\nउदाहरण:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "hu": "Adott egy számú kis- és nagybetűérzékeny sztring, megkeresi a legnagyobb X sztringet, úgy, hogy X vagy annak inverze bármelyik megadott sztring al-sztringjeként megtalálható legyen.\n\nPélda:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9839089528323637",
      "hy": "0.9668901031549134",
      "bn": "0.9638723117758504",
      "bg": "0.9789547138685916",
      "zh": "0.9560029733400102",
      "fr": "0.9841989531886747",
      "de": "0.9729536927967655",
      "ha": "0.9159096295584991",
      "hi": "0.9548568760414389",
      "hu": "0.9574660847267131"
    }
  },
  {
    "task_id": "Java/6",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Duke pasur një rrjet që përfaqëson një tokë të ndarë në parcela katrore, përcaktoni numrin e depozitave të veçanta të naftës.\n     * \n     * Parametrat:\n     *     grid (char[][]): Rrjeti që përfaqëson tokën. Çdo karakter është ose '*' për mungesën e naftës ose '@' për një xhep nafte.\n     * \n     * Kthen:\n     *     int: Numri i depozitave të veçanta të naftës në rrjet.\n     * \n     * Shembull:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Տրված է ցանց, որը ներկայացնում է հողը բաժանված քառակուսի հողամասերի, որոշեք տարբեր նավթի հանքավայրերի քանակը։\n     * \n     * Պարամետրեր:\n     *     grid (char[][]): Ցանցը, որը ներկայացնում է հողը։ Յուրաքանչյուր սիմվոլ կամ '*' է՝ նավթի բացակայության համար, կամ '@'՝ նավթի գրպանի համար։\n     * \n     * Վերադարձնում է:\n     *     int: Ցանցում տարբեր նավթի հանքավայրերի քանակը։\n     * \n     * Օրինակ:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * একটি গ্রিড দেওয়া আছে যা বর্গাকার প্লটে বিভক্ত জমি উপস্থাপন করে, স্বতন্ত্র তেলের ভাণ্ডারের সংখ্যা নির্ধারণ করুন।\n     * \n     * প্যারামিটার:\n     *     grid (char[][]): জমি উপস্থাপনকারী গ্রিড। প্রতিটি অক্ষর হয় '*' তেলের অনুপস্থিতির জন্য বা '@' তেলের পকেটের জন্য।\n     * \n     * রিটার্নস:\n     *     int: গ্রিডে স্বতন্ত্র তেলের ভাণ্ডারের সংখ্যা।\n     * \n     * উদাহরণ:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Дадена е мрежа, представляваща земя, разделена на квадратни парцели, определете броя на различните нефтени находища.\n     * \n     * Параметри:\n     *     grid (char[][]): Мрежата, представляваща земята. Всеки символ е или '*' за отсъствие на нефт, или '@' за нефтено находище.\n     * \n     * Връща:\n     *     int: Броят на различните нефтени находища в мрежата.\n     * \n     * Пример:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * 给定一个表示土地分为方形地块的网格，确定不同油藏的数量。\n     * \n     * 参数:\n     *     grid (char[][]): 表示土地的网格。每个字符要么是 '*' 表示没有油，要么是 '@' 表示一个油袋。\n     * \n     * 返回:\n     *     int: 网格中不同油藏的数量。\n     * \n     * 示例:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "fr": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Étant donné une grille représentant un terrain divisé en parcelles carrées, déterminez le nombre de dépôts de pétrole distincts.\n     * \n     * Paramètres:\n     *     grid (char[][]): La grille représentant le terrain. Chaque caractère est soit '*' pour l'absence de pétrole, soit '@' pour une poche de pétrole.\n     * \n     * Renvoie:\n     *     int: Le nombre de dépôts de pétrole distincts dans la grille.\n     * \n     * Exemple:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Gegeben ein Gitter, das ein in quadratische Parzellen unterteiltes Land darstellt, bestimmen Sie die Anzahl der unterschiedlichen Ölvorkommen.\n     * \n     * Parameter:\n     *     grid (char[][]): Das Gitter, das das Land darstellt. Jedes Zeichen ist entweder '*' für das Fehlen von Öl oder '@' für eine Öltasche.\n     * \n     * Rückgabe:\n     *     int: Die Anzahl der unterschiedlichen Ölvorkommen im Gitter.\n     * \n     * Beispiel:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * An ba da grid da ke wakiltar ƙasa da aka raba zuwa filaye masu murabba'i, tantance adadin wuraren mai daban-daban.\n     * \n     * Sigogi:\n     *     grid (char[][]): Grid da ke wakiltar ƙasar. Kowanne hali ko dai '*' don rashin mai ko '@' don aljihun mai.\n     * \n     * Komawa:\n     *     int: Adadin wuraren mai daban-daban a cikin grid.\n     * \n     * Misali:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * एक ग्रिड दिया गया है जो वर्गाकार भूखंडों में विभाजित भूमि का प्रतिनिधित्व करता है, अद्वितीय तेल भंडारों की संख्या निर्धारित करें।\n     * \n     * पैरामीटर:\n     *     grid (char[][]): भूमि का प्रतिनिधित्व करने वाला ग्रिड। प्रत्येक वर्ण या तो '*' तेल की अनुपस्थिति के लिए है या '@' तेल की जेब के लिए है।\n     * \n     * रिटर्न करता है:\n     *     int: ग्रिड में अद्वितीय तेल भंडारों की संख्या।\n     * \n     * उदाहरण:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Adott egy rács, amely négyzet alakú parcellákra osztott földet ábrázol, határozza meg a különálló olajlerakódások számát.\n     * \n     * Paraméterek:\n     *     grid (char[][]): A rács, amely a földet ábrázolja. Minden karakter vagy '*' az olaj hiányára, vagy '@' egy olajzsebre utal.\n     * \n     * Visszatérési érték:\n     *     int: A különálló olajlerakódások száma a rácsban.\n     * \n     * Példa:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) "
    },
    "prompt_bertscore": {
      "sq": "0.9904111183555407",
      "hy": "0.9904111183555407",
      "bn": "0.9847565086682396",
      "bg": "0.9965801807297223",
      "zh": "0.9914571059420705",
      "fr": "0.9930842860235083",
      "de": "0.9989164712714547",
      "ha": "0.9836916511955115",
      "hi": "0.9879910057930117",
      "hu": "0.9909281532373746"
    },
    "canonical_solution": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }",
    "instruction": {
      "en": "Write a Java function `public static int countOilDeposits(char[][] grid)` to solve the following problem:\nGiven a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "sq": "Shkruani një funksion Java `public static int countOilDeposits(char[][] grid)` për të zgjidhur problemin në vijim:  \nDuke pasur një rrjetë që përfaqëson një tokë të ndarë në parcela katrore, përcaktoni numrin e depozitave të veçanta të naftës.\n\nParametrat:  \ngrid (char[][]): Rrjeta që përfaqëson tokën. Çdo karakter është ose '*' për mungesën e naftës ose '@' për një xhep nafte.\n\nKthen:  \nint: Numri i depozitave të veçanta të naftës në rrjetë.\n\nShembull:  \n>>> countOilDeposits(new char[][] {{'*'}})  \n0  \n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})  \n1  \n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})  \n2  ",
      "hy": "Գրեք Java ֆունկցիա `public static int countOilDeposits(char[][] grid)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ցանց, որը ներկայացնում է հողը բաժանված քառակուսի հատվածների, որոշեք տարբեր նավթի հանքավայրերի քանակը:\n\nՊարամետրեր:\ngrid (char[][]): Ցանցը, որը ներկայացնում է հողը։ Յուրաքանչյուր սիմվոլ կարող է լինել '*' նավթի բացակայության համար կամ '@' նավթի գրպանի համար։\n\nՎերադարձնում է:\nint: Ցանցում տարբեր նավթի հանքավայրերի քանակը։\n\nՕրինակ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "bn": "Java ফাংশন `public static int countOilDeposits(char[][] grid)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি গ্রিড দেওয়া আছে যা বর্গাকার প্লটগুলিতে বিভক্ত জমি উপস্থাপন করে, স্বতন্ত্র তেল জমার সংখ্যা নির্ধারণ করুন।\n\nParameters:\ngrid (char[][]): জমি উপস্থাপনকারী গ্রিড। প্রতিটি অক্ষর হয় '*' তেলের অনুপস্থিতির জন্য বা '@' তেলের পকেটের জন্য।\n\nReturns:\nint: গ্রিডে স্বতন্ত্র তেল জমার সংখ্যা।\n\nউদাহরণ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "bg": "Напишете Java функция `public static int countOilDeposits(char[][] grid)`, за да решите следния проблем:  \nДадена е мрежа, представляваща земя, разделена на квадратни парцели, определете броя на отделните нефтени находища.\n\nПараметри:  \ngrid (char[][]): Мрежата, представляваща земята. Всеки символ е или '*' за отсъствие на нефт, или '@' за нефтено находище.\n\nВръща:  \nint: Броят на отделните нефтени находища в мрежата.\n\nПример:  \n>>> countOilDeposits(new char[][] {{'*'}})  \n0  \n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})  \n1  \n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})  \n2",
      "zh": "编写一个 Java 函数 `public static int countOilDeposits(char[][] grid)` 来解决以下问题：  \n给定一个代表土地的网格，该土地被划分为方形地块，确定不同油田的数量。\n\n参数：  \ngrid (char[][]): 代表土地的网格。每个字符要么是 '*' 表示没有油，要么是 '@' 表示一个油井。\n\n返回：  \nint: 网格中不同油田的数量。\n\n示例：  \n>>> countOilDeposits(new char[][] {{'*'}})  \n0  \n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})  \n1  \n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})  \n2  ",
      "fr": "Écrire une fonction Java `public static int countOilDeposits(char[][] grid)` pour résoudre le problème suivant :  \nÉtant donné une grille représentant un terrain divisé en parcelles carrées, déterminer le nombre de gisements de pétrole distincts.\n\nParamètres :  \ngrid (char[][]) : La grille représentant le terrain. Chaque caractère est soit '*' pour l'absence de pétrole, soit '@' pour une poche de pétrole.\n\nRenvoie :  \nint : Le nombre de gisements de pétrole distincts dans la grille.\n\nExemple :  \n>>> countOilDeposits(new char[][] {{'*'}})  \n0  \n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})  \n1  \n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})  \n2",
      "de": "Schreiben Sie eine Java-Funktion `public static int countOilDeposits(char[][] grid)`, um das folgende Problem zu lösen:\nGegeben ist ein Gitter, das ein in quadratische Parzellen unterteiltes Land darstellt. Bestimmen Sie die Anzahl der unterschiedlichen Ölvorkommen.\n\nParameter:\ngrid (char[][]): Das Gitter, das das Land darstellt. Jedes Zeichen ist entweder '*' für das Fehlen von Öl oder '@' für eine Öltasche.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen Ölvorkommen im Gitter.\n\nBeispiel:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "ha": "Rubuta aikin Java `public static int countOilDeposits(char[][] grid)` don warware matsalar mai zuwa:\nAn ba da grid da ke wakiltar ƙasa da aka raba zuwa filaye masu kusurwa huɗu, a tantance adadin wuraren mai na daban-daban.\n\nSigogi:\ngrid (char[][]): Grid da ke wakiltar ƙasa. Kowanne hali ko dai '*' don rashin mai ko '@' don aljihun mai.\n\nKomawa:\nint: Adadin wuraren mai na daban-daban a cikin grid.\n\nMisali:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hi": "Java फ़ंक्शन `public static int countOilDeposits(char[][] grid)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए ग्रिड के आधार पर, जो भूमि को वर्गाकार भूखंडों में विभाजित करता है, यह निर्धारित करें कि कितने भिन्न तेल भंडार हैं।\n\nपैरामीटर्स:\ngrid (char[][]): भूमि का प्रतिनिधित्व करने वाला ग्रिड। प्रत्येक वर्ण या तो '*' है तेल की अनुपस्थिति के लिए या '@' है तेल के भंडार के लिए।\n\nवापसी:\nint: ग्रिड में भिन्न तेल भंडारों की संख्या।\n\nउदाहरण:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hu": "Írj egy Java függvényt `public static int countOilDeposits(char[][] grid)` a következő probléma megoldására:  \nAdott egy rács, amely egy földterületet ábrázol négyzet alakú parcellákra osztva, határozd meg a különálló olajlerakódások számát.\n\nParaméterek:  \ngrid (char[][]): A földterületet ábrázoló rács. Minden karakter lehet '*' az olaj hiányára vagy '@' egy olajzsebre.\n\nVisszatérési érték:  \nint: A különálló olajlerakódások száma a rácsban.\n\nPélda:  \n>>> countOilDeposits(new char[][] {{'*'}})  \n0  \n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})  \n1  \n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})  \n2  "
    },
    "instruction_bertscore": {
      "sq": "0.9956235768146583",
      "hy": "0.991773325508678",
      "bn": "0.988926753518067",
      "bg": "0.992394244079793",
      "zh": "0.9705349706469036",
      "fr": "0.9966177218717379",
      "de": "0.9795223994975892",
      "ha": "0.980101804319068",
      "hi": "0.966477547853504",
      "hu": "0.9756469221332176"
    },
    "level": "middle",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countOilDeposits",
    "signature": "public static int countOilDeposits(char[][] grid)",
    "docstring": {
      "en": "Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "sq": "Duke pasur një rrjetë që përfaqëson një tokë të ndarë në parcela katrore, përcaktoni numrin e depozitave të veçanta të naftës.\n\nParametrat:\ngrid (char[][]): Rrjeta që përfaqëson tokën. Çdo karakter është ose '*' për mungesë të naftës ose '@' për një xhep nafte.\n\nKthen:\nint: Numri i depozitave të veçanta të naftës në rrjetë.\n\nShembull:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hy": "Տրված ցանցը ներկայացնում է հողը բաժանված քառակուսի հողամասերի, որոշեք տարբեր նավթի հանքավայրերի քանակը:\n\nՊարամետրեր:\ngrid (char[][]): Ցանցը, որը ներկայացնում է հողը: Յուրաքանչյուր սիմվոլ կարող է լինել '*'՝ նավթի բացակայության համար կամ '@'՝ նավթի գրպանի համար:\n\nՎերադարձնում է:\nint: Ցանցում տարբեր նավթի հանքավայրերի քանակը:\n\nՕրինակ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "bn": "একটি গ্রিড দেওয়া হয়েছে যা বর্গাকার প্লটগুলিতে বিভক্ত জমি উপস্থাপন করে, স্বতন্ত্র তেলের সঞ্চয়গুলির সংখ্যা নির্ধারণ করুন।\n\nপ্যারামিটারসমূহ:\ngrid (char[][]): জমি উপস্থাপনকারী গ্রিড। প্রতিটি অক্ষর হয় '*' তেলের অনুপস্থিতির জন্য বা '@' তেলের পকেটের জন্য।\n\nরিটার্নস:\nint: গ্রিডে স্বতন্ত্র তেলের সঞ্চয়গুলির সংখ্যা।\n\nউদাহরণ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "bg": "Дадена е мрежа, представляваща земя, разделена на квадратни парцели, определете броя на различните петролни находища.\n\nПараметри:\ngrid (char[][]): Мрежата, представляваща земята. Всеки символ е или '*' за липса на петрол, или '@' за петролен джоб.\n\nВръща:\nint: Броят на различните петролни находища в мрежата.\n\nПример:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "zh": "给定一个表示土地分为正方形地块的网格，确定不同油田的数量。\n\n参数：\ngrid (char[][]): 表示土地的网格。每个字符要么是 '*' 表示没有油，要么是 '@' 表示有一个油袋。\n\n返回：\nint: 网格中不同油田的数量。\n\n示例：\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "fr": "Étant donné une grille représentant un terrain divisé en parcelles carrées, déterminez le nombre de gisements de pétrole distincts.\n\nParamètres :\ngrid (char[][]) : La grille représentant le terrain. Chaque caractère est soit '*' pour l'absence de pétrole, soit '@' pour une poche de pétrole.\n\nRenvoie :\nint : Le nombre de gisements de pétrole distincts dans la grille.\n\nExemple :\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "de": "Gegeben ein Raster, das ein in quadratische Parzellen unterteiltes Land darstellt, bestimmen Sie die Anzahl der unterschiedlichen Ölvorkommen.\n\nParameter:\ngrid (char[][]): Das Raster, das das Land darstellt. Jedes Zeichen ist entweder '*' für das Fehlen von Öl oder '@' für eine Ölquelle.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen Ölvorkommen im Raster.\n\nBeispiel:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "ha": "An ba da grid da ke wakiltar ƙasa da aka raba zuwa filaye masu siffar murabba'i, a tantance adadin wuraren mai na musamman.\n\nSigogi:\ngrid (char[][]): Grid da ke wakiltar ƙasar. Kowanne hali ko dai '*' don rashin mai ko '@' don aljihun mai.\n\nDawowa:\nint: Adadin wuraren mai na musamman a cikin grid.\n\nMisali:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hi": "दिए गए ग्रिड जो एक भूमि को वर्ग भूखंडों में विभाजित करता है, उसमें विभिन्न तेल भंडारों की संख्या निर्धारित करें।\n\nपैरामीटर्स:\ngrid (char[][]): ग्रिड जो भूमि का प्रतिनिधित्व करता है। प्रत्येक वर्ण या तो '*' तेल की अनुपस्थिति के लिए है या '@' तेल के भंडार के लिए है।\n\nरिटर्न्स:\nint: ग्रिड में विभिन्न तेल भंडारों की संख्या।\n\nउदाहरण:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hu": "Adott egy rács, amely négyzet alakú parcellákra osztott földet ábrázol, határozza meg a különálló olajlerakódások számát.\n\nParaméterek:\ngrid (char[][]): A földet ábrázoló rács. Minden karakter vagy '*' az olaj hiányát jelzi, vagy '@' egy olajzsebet.\n\nVisszatérési érték:\nint: A rácsban található különálló olajlerakódások száma.\n\nPélda:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9999561026857913",
      "hy": "0.985304927150277",
      "bn": "0.9857619756570382",
      "bg": "0.9865479560747933",
      "zh": "0.9803925991969031",
      "fr": "0.9846031660140806",
      "de": "0.987207210309448",
      "ha": "0.984969440436709",
      "hi": "0.9739194337093571",
      "hu": "0.9815204225004192"
    }
  },
  {
    "task_id": "Java/7",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n     *\n     * Example:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N the number of triangles\n     * @return the maximum number of regions\n     */\n    public static int maxRegions(int N) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur parasysh numrin e trekëndëshave N, përcaktoni numrin maksimal të rajoneve në të cilat mund të ndahet plani.\n     *\n     * Shembull:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N numri i trekëndëshave\n     * @return numri maksimal i rajoneve\n     */\n    public static int maxRegions(int N) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է եռանկյունների քանակը N, որոշեք առավելագույն քանակը, թե քանի մասի կարելի է բաժանել հարթությունը։\n     *\n     * Օրինակ:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N եռանկյունների քանակը\n     * @return առավելագույն մասերի քանակը\n     */\n    public static int maxRegions(int N) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * প্রদত্ত ত্রিভুজের সংখ্যা N, নির্ধারণ করুন সমতলকে সর্বাধিক কতগুলো অঞ্চলে ভাগ করা যেতে পারে।\n     *\n     * উদাহরণ:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N ত্রিভুজের সংখ্যা\n     * @return সর্বাধিক অঞ্চলের সংখ্যা\n     */\n    public static int maxRegions(int N) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е броят на триъгълниците N, определете максималния брой региони, на които може да бъде разделена равнината.\n     *\n     * Пример:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N броят на триъгълниците\n     * @return максималният брой региони\n     */\n    public static int maxRegions(int N) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定三角形的数量 N，确定平面可以被划分的最大区域数。\n     *\n     * 示例:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N 三角形的数量\n     * @return 最大区域数\n     */\n    public static int maxRegions(int N) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné le nombre de triangles N, déterminez le nombre maximum de régions dans lesquelles le plan peut être divisé.\n     *\n     * Exemple:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N le nombre de triangles\n     * @return le nombre maximum de régions\n     */\n    public static int maxRegions(int N) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben die Anzahl der Dreiecke N, bestimme die maximale Anzahl der Regionen, in die die Ebene unterteilt werden kann.\n     *\n     * Beispiel:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N die Anzahl der Dreiecke\n     * @return die maximale Anzahl der Regionen\n     */\n    public static int maxRegions(int N) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Idan aka ba da adadin alwatika N, tantance yawan yankuna mafi yawa da za a iya raba filin.\n     *\n     * Misali:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N adadin alwatika\n     * @return yawan yankuna mafi yawa\n     */\n    public static int maxRegions(int N) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए त्रिभुजों की संख्या N के लिए, यह निर्धारित करें कि विमान को अधिकतम कितने क्षेत्रों में विभाजित किया जा सकता है।\n     *\n     * उदाहरण:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N त्रिभुजों की संख्या\n     * @return अधिकतम क्षेत्रों की संख्या\n     */\n    public static int maxRegions(int N) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott a háromszögek száma N, határozza meg, hogy a síkot legfeljebb hány részre lehet osztani.\n     *\n     * Példa:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N a háromszögek száma\n     * @return a maximális régiók száma\n     */\n    public static int maxRegions(int N) "
    },
    "prompt_bertscore": {
      "sq": "0.9923016823222308",
      "hy": "0.9923016823222308",
      "bn": "0.9796362147059222",
      "bg": "0.9923016823222308",
      "zh": "0.9843783164227492",
      "fr": "0.9923016823222308",
      "de": "0.9923016823222308",
      "ha": "0.9447932677863062",
      "hi": "0.9731123984712123",
      "hu": "1"
    },
    "canonical_solution": "    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }",
    "instruction": {
      "en": "Write a Java function `public static int maxRegions(int N)` to solve the following problem:\nGiven the number of triangles N, determine the maximum number of regions the plane can be divided into.\n\nExample:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N the number of triangles\n@return the maximum number of regions",
      "sq": "Shkruani një funksion Java `public static int maxRegions(int N)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur parasysh numrin e trekëndëshave N, përcaktoni numrin maksimal të rajoneve në të cilat mund të ndahet plani.\n\nShembull:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N numri i trekëndëshave\n@return numri maksimal i rajoneve",
      "hy": "Գրեք Java ֆունկցիա `public static int maxRegions(int N)` հետևյալ խնդիրը լուծելու համար. Տրված է եռանկյունների քանակը N, որոշեք հարթությունը առավելագույն քանի հատվածի կարելի է բաժանել։\n\nՕրինակ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N եռանկյունների քանակը\n@return առավելագույն հատվածների քանակը",
      "bn": "একটি জাভা ফাংশন `public static int maxRegions(int N)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: প্রদত্ত ত্রিভুজের সংখ্যা N, নির্ধারণ করুন সমতলকে সর্বাধিক কতটি অঞ্চলে ভাগ করা যেতে পারে।\n\nউদাহরণ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N ত্রিভুজের সংখ্যা\n@return সর্বাধিক অঞ্চলের সংখ্যা",
      "bg": "Напишете Java функция `public static int maxRegions(int N)`, за да решите следния проблем:  \nДаден е броят на триъгълниците N, определете максималния брой региони, на които може да бъде разделена равнината.\n\nПример:  \n>>> maxRegions(1)  \n2  \n>>> maxRegions(2)  \n8  \n\n@param N броят на триъгълниците  \n@return максималният брой региони",
      "zh": "编写一个 Java 函数 `public static int maxRegions(int N)` 来解决以下问题：  \n给定三角形的数量 N，确定平面可以被分成的最大区域数。\n\n示例：\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N 三角形的数量  \n@return 最大区域数",
      "fr": "Écrire une fonction Java `public static int maxRegions(int N)` pour résoudre le problème suivant :  \nÉtant donné le nombre de triangles N, déterminer le nombre maximum de régions dans lesquelles le plan peut être divisé.\n\nExemple :\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N le nombre de triangles\n@return le nombre maximum de régions",
      "de": "Schreiben Sie eine Java-Funktion `public static int maxRegions(int N)`, um das folgende Problem zu lösen:  \nGegeben ist die Anzahl der Dreiecke N, bestimmen Sie die maximale Anzahl von Regionen, in die die Ebene unterteilt werden kann.\n\nBeispiel:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N die Anzahl der Dreiecke\n@return die maximale Anzahl von Regionen",
      "ha": "Rubuta aikin Java `public static int maxRegions(int N)` don warware matsalar mai zuwa:\nAn ba da adadin alwatika N, tantance yawan yankuna mafi girma da jirgin zai iya rabuwa zuwa.\n\nMisali:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N adadin alwatika\n@return yawan yankuna mafi girma",
      "hi": "Java फ़ंक्शन `public static int maxRegions(int N)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए त्रिभुजों की संख्या N के आधार पर, यह निर्धारित करें कि विमान को अधिकतम कितने क्षेत्रों में विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N त्रिभुजों की संख्या\n@return अधिकतम क्षेत्रों की संख्या",
      "hu": "Írj egy Java függvényt `public static int maxRegions(int N)` a következő probléma megoldására:\nAdott a háromszögek száma N, határozd meg, hogy a síkot legfeljebb hány részre lehet osztani.\n\nPélda:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N a háromszögek száma\n@return a maximális régiók száma"
    },
    "instruction_bertscore": {
      "sq": "0.9939630268292067",
      "hy": "0.9806116885071846",
      "bn": "0.9757160455058177",
      "bg": "0.9939630268292067",
      "zh": "0.9757160455058177",
      "fr": "0.9939630268292067",
      "de": "0.9939630268292067",
      "ha": "0.9647740937057487",
      "hi": "0.9265373480957707",
      "hu": "1"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert maxRegions(3) == 13;\n        assert maxRegions(4) == 21;\n        assert maxRegions(5) == 31;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "maxRegions",
    "signature": "public static int maxRegions(int N)",
    "docstring": {
      "en": "Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n\nExample:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N the number of triangles\n@return the maximum number of regions",
      "sq": "Duke pasur parasysh numrin e trekëndëshave N, përcaktoni numrin maksimal të rajoneve në të cilat mund të ndahet plani.\n\nShembull:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N numri i trekëndëshave\n@return numri maksimal i rajoneve",
      "hy": "Տրված է եռանկյունների քանակը N, որոշեք հարթությունը բաժանելու առավելագույն շրջանների քանակը։\n\nՕրինակ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N եռանկյունների քանակը\n@return առավելագույն շրջանների քանակը",
      "bn": "ত্রিভুজের সংখ্যা N দেওয়া হলে, সমতলকে সর্বাধিক কতটি অঞ্চলে ভাগ করা যেতে পারে তা নির্ধারণ করুন।\n\nউদাহরণ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N ত্রিভুজের সংখ্যা\n@return সর্বাধিক অঞ্চলের সংখ্যা",
      "bg": "Даден е броят на триъгълниците N, определете максималния брой региони, на които равнината може да бъде разделена.\n\nПример:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N броят на триъгълниците\n@return максималният брой региони",
      "zh": "给定三角形的数量 N，确定平面可以被划分的最大区域数。\n\n示例：\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N 三角形的数量\n@return 最大的区域数",
      "fr": "Étant donné le nombre de triangles N, déterminez le nombre maximal de régions dans lesquelles le plan peut être divisé.\n\nExemple :\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N le nombre de triangles\n@return le nombre maximal de régions",
      "de": "Gegeben die Anzahl der Dreiecke N, bestimme die maximale Anzahl der Regionen, in die die Ebene unterteilt werden kann.\n\nBeispiel:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N die Anzahl der Dreiecke\n@return die maximale Anzahl der Regionen",
      "ha": "Idan aka ba da adadin alwatika N, tantance yawan yankuna mafi yawa da za a iya raba filin.\n\nMisali:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N yawan alwatika\n@return mafi yawan yankuna",
      "hi": "त्रिभुजों की संख्या N दी गई है, यह निर्धारित करें कि विमान को अधिकतम कितने क्षेत्रों में विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N त्रिभुजों की संख्या\n@return अधिकतम क्षेत्रों की संख्या",
      "hu": "Adott a háromszögek száma N, határozza meg, hogy a síkot legfeljebb hány régióra lehet felosztani.\n\nPélda:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N a háromszögek száma\n@return a régiók maximális száma"
    },
    "docstring_bertscore": {
      "sq": "0.9578887701775555",
      "hy": "0.9560361446136431",
      "bn": "0.9135060033175959",
      "bg": "0.9889132466521566",
      "zh": "0.9660524788380893",
      "fr": "0.9889132466521566",
      "de": "1",
      "ha": "0.9840366721673691",
      "hi": "0.91094446592377",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/8",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Numëron numrin e fjalëve në listën e dhënë të fjalëve që kanë parashtesën e dhënë.\n     * \n     * @param wordList: një listë fjalësh\n     * @param prefix: vargu i parashtesës\n     * @return numrin e fjalëve me parashtesën e dhënë\n     * \n     * Shembull:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Հաշվել տրված բառերի ցուցակում այն բառերի քանակը, որոնք ունեն տրված նախածանցը։\n     * \n     * @param wordList: բառերի ցուցակ\n     * @param prefix: նախածանցի տող\n     * @return այն բառերի քանակը, որոնք ունեն տրված նախածանցը\n     * \n     * Օրինակ:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * প্রদত্ত শব্দ তালিকায় প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা গণনা করুন।\n     * \n     * @param wordList: শব্দের একটি তালিকা\n     * @param prefix: উপসর্গ স্ট্রিং\n     * @return প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা\n     * \n     * উদাহরণ:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Пребройте броя на думите в дадения списък от думи, които имат дадения префикс.\n     * \n     * @param wordList: списък от думи\n     * @param prefix: префикс низ\n     * @return броя на думите с дадения префикс\n     * \n     * Пример:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * 计算给定单词列表中具有给定前缀的单词数量。\n     * \n     * @param wordList: 单词列表\n     * @param prefix: 前缀字符串\n     * @return 具有给定前缀的单词数量\n     * \n     * 示例:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "fr": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Compter le nombre de mots dans la liste de mots donnée qui ont le préfixe donné.\n     * \n     * @param wordList: une liste de mots\n     * @param prefix: la chaîne de caractères préfixe\n     * @return le nombre de mots avec le préfixe donné\n     * \n     * Exemple:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Zählt die Anzahl der Wörter in der gegebenen Wortliste, die das gegebene Präfix haben.\n     * \n     * @param wordList: eine Liste von Wörtern\n     * @param prefix: der Präfix-String\n     * @return die Anzahl der Wörter mit dem gegebenen Präfix\n     * \n     * Beispiel:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Ƙididdige yawan kalmomin da ke cikin jerin kalmomin da aka bayar waɗanda ke da farkon da aka bayar.\n     * \n     * @param wordList: jerin kalmomi\n     * @param prefix: farkon kirtani\n     * @return yawan kalmomin da ke da farkon da aka bayar\n     * \n     * Misali:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * दिए गए शब्द सूची में उन शब्दों की संख्या गिनें जिनके पास दिया गया उपसर्ग है।\n     * \n     * @param wordList: शब्दों की एक सूची\n     * @param prefix: उपसर्ग स्ट्रिंग\n     * @return दिए गए उपसर्ग वाले शब्दों की संख्या\n     * \n     * उदाहरण:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Számolja meg a szavak számát a megadott szavak listájában, amelyek a megadott előtaggal rendelkeznek.\n     * \n     * @param wordList: egy szavak listája\n     * @param prefix: az előtag string\n     * @return a megadott előtaggal rendelkező szavak száma\n     * \n     * Példa:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) "
    },
    "prompt_bertscore": {
      "sq": "0.988863787687279",
      "hy": "0.986228161161327",
      "bn": "0.9782610965780177",
      "bg": "0.9920625313434648",
      "zh": "0.9717960749360942",
      "fr": "1",
      "de": "0.9944055753181523",
      "ha": "0.9920625313434648",
      "hi": "0.9893917472400697",
      "hu": "0.988863787687279"
    },
    "canonical_solution": "    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }",
    "instruction": {
      "en": "Write a Java function `public static int countPrefixWords(List<String> wordList, String prefix)` to solve the following problem:\nCount the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "sq": "Shkruani një funksion Java `public static int countPrefixWords(List<String> wordList, String prefix)` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e fjalëve në listën e dhënë të fjalëve që kanë parashtesën e dhënë.\n\n@param wordList: një listë fjalësh\n@param prefix: stringu i parashtesës\n@return numri i fjalëve me parashtesën e dhënë\n\nShembull:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hy": "Գրեք Java ֆունկցիա `public static int countPrefixWords(List<String> wordList, String prefix)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված բառերի ցանկում այն բառերի քանակը, որոնք ունեն տրված նախածանցը։\n\n@param wordList: բառերի ցանկ\n@param prefix: նախածանցի տող\n@return այն բառերի քանակը, որոնք ունեն տրված նախածանցը\n\nՕրինակ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "bn": "একটি জাভা ফাংশন `public static int countPrefixWords(List<String> wordList, String prefix)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত শব্দ তালিকায় কতগুলি শব্দ প্রদত্ত উপসর্গ রয়েছে তা গণনা করুন।\n\n@param wordList: শব্দের একটি তালিকা\n@param prefix: উপসর্গ স্ট্রিং\n@return প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা\n\nউদাহরণ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "bg": "Напишете Java функция `public static int countPrefixWords(List<String> wordList, String prefix)` за решаване на следния проблем:  \nБройте броя на думите в дадения списък с думи, които имат дадения префикс.\n\n@param wordList: списък с думи  \n@param prefix: префикс низ  \n@return броят на думите с дадения префикс\n\nПример:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")  \n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")  \n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")  \n1",
      "zh": "编写一个 Java 函数 `public static int countPrefixWords(List<String> wordList, String prefix)` 来解决以下问题：\n计算给定单词列表中具有给定前缀的单词数量。\n\n@param wordList: 单词列表\n@param prefix: 前缀字符串\n@return 具有给定前缀的单词数量\n\n示例:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "fr": "Écrire une fonction Java `public static int countPrefixWords(List<String> wordList, String prefix)` pour résoudre le problème suivant :  \nCompter le nombre de mots dans la liste de mots donnée qui ont le préfixe donné.\n\n@param wordList: une liste de mots  \n@param prefix: la chaîne de caractères préfixe  \n@return le nombre de mots avec le préfixe donné  \n\nExemple:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")  \n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")  \n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")  \n1",
      "de": "Schreiben Sie eine Java-Funktion `public static int countPrefixWords(List<String> wordList, String prefix)`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der Wörter in der gegebenen Wortliste, die das gegebene Präfix haben.\n\n@param wordList: eine Liste von Wörtern\n@param prefix: der Präfix-String\n@return die Anzahl der Wörter mit dem gegebenen Präfix\n\nBeispiel:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "ha": "Rubuta aikin Java `public static int countPrefixWords(List<String> wordList, String prefix)` don warware matsalar mai zuwa: \n\nƘididdige adadin kalmomin da ke cikin jerin kalmomin da aka bayar waɗanda ke da farkon haruffa da aka bayar.\n\n@param wordList: jerin kalmomi\n@param prefix: farkon haruffa\n@return adadin kalmomin da ke da farkon haruffa da aka bayar\n\nMisali:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hi": "Java फ़ंक्शन `public static int countPrefixWords(List<String> wordList, String prefix)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए शब्द सूची में उन शब्दों की संख्या गिनें जिनका दिया गया उपसर्ग है।\n\n@param wordList: शब्दों की एक सूची\n@param prefix: उपसर्ग स्ट्रिंग\n@return दिए गए उपसर्ग वाले शब्दों की संख्या\n\nउदाहरण:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hu": "Írj egy Java függvényt `public static int countPrefixWords(List<String> wordList, String prefix)` a következő probléma megoldására:\nSzámold meg, hány szó van az adott szavak listájában, amelyek az adott előtaggal kezdődnek.\n\n@param wordList: egy szavak listája\n@param prefix: az előtag string\n@return az előtaggal kezdődő szavak száma\n\nPélda:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9954527546869683",
      "hy": "0.985567516514005",
      "bn": "0.9758783265271231",
      "bg": "0.9915317909653396",
      "zh": "0.9730577751164278",
      "fr": "1",
      "de": "0.9989871836871032",
      "ha": "0.9755591275048001",
      "hi": "0.980722524259802",
      "hu": "0.9858954552730936"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countPrefixWords",
    "signature": "public static int countPrefixWords(List<String> wordList, String prefix)",
    "docstring": {
      "en": "Count the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "sq": "Numëroni numrin e fjalëve në listën e dhënë të fjalëve që kanë parashtesën e dhënë.\n\n@param wordList: një listë fjalësh\n@param prefix: vargu i parashtesës\n@return numri i fjalëve me parashtesën e dhënë\n\nShembull:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hy": "Հաշվել տրված բառերի ցուցակում այն բառերի քանակը, որոնք ունեն տրված նախածանցը։\n\n@param wordList: բառերի ցուցակ\n@param prefix: նախածանցի տող\n@return տրված նախածանցով բառերի քանակը\n\nՕրինակ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "bn": "প্রদত্ত শব্দ তালিকায় প্রদত্ত উপসর্গ সহ কতগুলি শব্দ রয়েছে তা গণনা করুন।\n\n@param wordList: শব্দের একটি তালিকা\n@param prefix: উপসর্গ স্ট্রিং\n@return প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা\n\nউদাহরণ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "bg": "Бройте броя на думите в дадения списък от думи, които имат дадения префикс.\n\n@param wordList: списък от думи\n@param prefix: префикс низ\n@return броят на думите с дадения префикс\n\nПример:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "zh": "计算给定单词列表中具有给定前缀的单词数量。\n\n@param wordList: 单词列表\n@param prefix: 前缀字符串\n@return 具有给定前缀的单词数量\n\n示例：\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "fr": "Compter le nombre de mots dans la liste de mots donnée qui ont le préfixe donné.\n\n@param wordList: une liste de mots\n@param prefix: la chaîne de caractères préfixe\n@return le nombre de mots avec le préfixe donné\n\nExemple :\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "de": "Zähle die Anzahl der Wörter in der gegebenen Wortliste, die das gegebene Präfix haben.\n\n@param wordList: eine Liste von Wörtern\n@param prefix: der Präfix-String\n@return die Anzahl der Wörter mit dem gegebenen Präfix\n\nBeispiel:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "ha": "Ƙididdige yawan kalmomin da ke cikin jerin kalmomin da aka bayar waɗanda ke da farkon da aka bayar.\n\n@param wordList: jerin kalmomi\n@param prefix: farkon kalma\n@return yawan kalmomin da ke da farkon da aka bayar\n\nMisali:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hi": "दिए गए शब्द सूची में उन शब्दों की संख्या गिनें जिनके पास दिया गया उपसर्ग है।\n\n@param wordList: शब्दों की एक सूची\n@param prefix: उपसर्ग स्ट्रिंग\n@return उन शब्दों की संख्या जिनके पास दिया गया उपसर्ग है\n\nउदाहरण:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hu": "Számolja meg a megadott szólajstromban azon szavak számát, amelyek a megadott előtaggal rendelkeznek.\n\n@param wordList: szavak listája\n@param prefix: az előtag string\n@return azon szavak száma, amelyek a megadott előtaggal rendelkeznek\n\nPélda:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9933375397593278",
      "hy": "0.9734866181090821",
      "bn": "0.9623680839002732",
      "bg": "0.9885306845382835",
      "zh": "0.9647971348299489",
      "fr": "0.9933375397593278",
      "de": "0.999999801369619",
      "ha": "0.9778018631370651",
      "hi": "0.9847628648404327",
      "hu": "0.9891577606512106"
    }
  },
  {
    "task_id": "Java/9",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n   /**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "sq": "import java.util.*;\n\nclass Solution {\n   /**\n     * Duke pasur një listë numrash, përcaktoni sa artikuj në listë janë dyfishi i ndonjë artikulli tjetër në të njëjtën listë.\n     * \n     * Shembull:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "hy": "import java.util.*;\n\nclass Solution {\n   /**\n     * Տրված թվերի ցուցակի դեպքում որոշեք, թե քանի տարր ցուցակում կրկնակի են ցուցակի որևէ այլ տարրի:\n     * \n     * Օրինակ:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "bn": "import java.util.*;\n\nclass Solution {\n   /**\n     * একটি সংখ্যার তালিকা দেওয়া হলে, তালিকায় কতগুলি আইটেম একই তালিকার অন্য কোন আইটেমের দ্বিগুণ তা নির্ধারণ করুন।\n     * \n     * উদাহরণ:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "bg": "import java.util.*;\n\nclass Solution {\n   /**\n     * Даден е списък от числа, определете колко елементи в списъка са два пъти някой друг елемент в същия списък.\n     * \n     * Пример:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "zh": "import java.util.*;\n\nclass Solution {\n   /**\n     * 给定一个数字列表，确定列表中有多少项是列表中其他某项的两倍。\n     * \n     * 示例:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "fr": "import java.util.*;\n\nclass Solution {\n   /**\n     * Étant donné une liste de nombres, déterminez combien d'éléments dans la liste sont le double d'un autre élément dans la même liste.\n     * \n     * Exemple:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "de": "import java.util.*;\n\nclass Solution {\n   /**\n     * Gegeben eine Liste von Zahlen, bestimme, wie viele Elemente in der Liste das Doppelte eines anderen Elements in derselben Liste sind.\n     * \n     * Beispiel:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "ha": "import java.util.*;\n\nclass Solution {\n   /**\n     * An ba da jerin lambobi, tantance yawan abubuwan da ke cikin jerin waɗanda suke ninki biyu na wani abu a cikin wannan jerin.\n     * \n     * Misali:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "hi": "import java.util.*;\n\nclass Solution {\n   /**\n     * दिए गए संख्याओं की सूची में, यह निर्धारित करें कि सूची में कितनी वस्तुएं किसी अन्य वस्तु के दोगुने हैं।\n     * \n     * उदाहरण:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "hu": "import java.util.*;\n\nclass Solution {\n   /**\n     * Adott egy számok listája, határozza meg, hogy hány elem van a listában, amely kétszerese egy másik elemnek ugyanabban a listában.\n     * \n     * Példa:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) "
    },
    "prompt_bertscore": {
      "sq": "0.9935707318266628",
      "hy": "0.9828977255625151",
      "bn": "0.9935707318266628",
      "bg": "0.9953153024632921",
      "zh": "0.9900186247226158",
      "fr": "0.9868161070891903",
      "de": "0.9868161070891903",
      "ha": "0.9749098047891971",
      "hi": "0.9705856213940676",
      "hu": "0.9868161070891903"
    },
    "canonical_solution": "    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }",
    "instruction": {
      "en": "Write a Java function `public static int countDoubles(int[] numbers)` to solve the following problem:\nGiven a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "sq": "Shkruani një funksion Java `public static int countDoubles(int[] numbers)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një listë numrash, përcaktoni sa artikuj në listë janë dyfishi i ndonjë artikulli tjetër në të njëjtën listë.\n\nShembull:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hy": "Գրեք Java ֆունկցիա `public static int countDoubles(int[] numbers)` հետևյալ խնդիրը լուծելու համար:\nՏրված է թվերի ցուցակ, որոշեք, թե ցուցակի քանի տարր է կրկնակի ինչ-որ այլ տարրի նույն ցուցակում:\n\nՕրինակ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "bn": "একটি জাভা ফাংশন `public static int countDoubles(int[] numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সংখ্যার তালিকা দেওয়া হলে, তালিকায় কতগুলি আইটেম একই তালিকার অন্য কোন আইটেমের দ্বিগুণ তা নির্ধারণ করুন।\n\nউদাহরণ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "bg": "Напишете Java функция `public static int countDoubles(int[] numbers)`, за да решите следния проблем:  \nДаден е списък с числа, определете колко елементи в списъка са два пъти някой друг елемент в същия списък.\n\nПример:  \n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})  \n3  \n>>> countDoubles(new int[] {2, 4, 8, 10})  \n2  \n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})  \n0",
      "zh": "编写一个 Java 函数 `public static int countDoubles(int[] numbers)` 来解决以下问题：\n给定一个数字列表，确定列表中有多少项是列表中其他某项的两倍。\n\n示例:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "fr": "Écrire une fonction Java `public static int countDoubles(int[] numbers)` pour résoudre le problème suivant :  \nÉtant donné une liste de nombres, déterminez combien d'éléments dans la liste sont le double d'un autre élément dans la même liste.\n\nExemple :  \n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})  \n3  \n>>> countDoubles(new int[] {2, 4, 8, 10})  \n2  \n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})  \n0",
      "de": "Schreiben Sie eine Java-Funktion `public static int countDoubles(int[] numbers)`, um das folgende Problem zu lösen:\nGegeben eine Liste von Zahlen, bestimmen Sie, wie viele Elemente in der Liste doppelt so groß wie ein anderes Element in derselben Liste sind.\n\nBeispiel:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "ha": "Rubuta wani aikin Java `public static int countDoubles(int[] numbers)` don warware matsalar mai zuwa:\nAn ba da jerin lambobi, tantance yawan abubuwan da ke cikin jerin waɗanda suke ninki biyu na wani abu a cikin wannan jerin.\n\nMisali:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hi": "एक जावा फ़ंक्शन `public static int countDoubles(int[] numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक सूची दी गई है, यह निर्धारित करें कि सूची में कितनी वस्तुएं सूची में किसी अन्य वस्तु की दोगुनी हैं।\n\nउदाहरण:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hu": "Írj egy Java függvényt `public static int countDoubles(int[] numbers)` a következő probléma megoldására:\nAdott egy számokból álló lista, határozd meg, hogy hány elem van a listában, amely kétszerese a lista egy másik elemének.\n\nPélda:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9945118425720061",
      "hy": "0.9907754064743588",
      "bn": "0.9945118425720061",
      "bg": "0.9935669578494231",
      "zh": "0.9888649794695652",
      "fr": "0.9861584418975838",
      "de": "0.9769521223669978",
      "ha": "0.971072464457984",
      "hi": "0.9866323739867331",
      "hu": "0.9764587245005071"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countDoubles",
    "signature": "public static int countDoubles(int[] numbers)",
    "docstring": {
      "en": "Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "sq": "Duke pasur një listë numrash, përcaktoni sa artikuj në listë janë dyfishi i ndonjë artikulli tjetër në të njëjtën listë.\n\nShembull:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hy": "Հաշվի առնելով թվերի ցուցակը, որոշեք, թե ցուցակի քանի տարր է կրկնակի որևէ այլ տարրի նույն ցուցակում:\n\nՕրինակ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "bn": "একটি সংখ্যার তালিকা দেওয়া হলে, তালিকায় কতগুলি আইটেম আছে যা একই তালিকার অন্য কোনো আইটেমের দ্বিগুণ তা নির্ধারণ করুন।\n\nউদাহরণ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "bg": "Даден е списък от числа, определете колко елемента в списъка са два пъти по-големи от някой друг елемент в същия списък.\n\nПример:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "zh": "给定一个数字列表，确定列表中有多少项是列表中其他某项的两倍。\n\n示例：\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "fr": "Étant donné une liste de nombres, déterminez combien d'éléments dans la liste sont le double d'un autre élément dans la même liste.\n\nExemple :\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "de": "Gegeben eine Liste von Zahlen, bestimmen Sie, wie viele Elemente in der Liste das Doppelte eines anderen Elements in derselben Liste sind.\n\nBeispiel:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "ha": "An ba da jerin lambobi, tantance yawan abubuwan da ke cikin jerin waɗanda suka ninka wasu abubuwa a cikin wannan jerin.\n\nMisali:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hi": "संख्या की एक सूची दी गई है, यह निर्धारित करें कि सूची में कितनी वस्तुएं सूची में किसी अन्य वस्तु का दोगुना हैं।\n\nउदाहरण:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hu": "Adott egy számokból álló lista, határozza meg, hogy a listában hány elem kétszerese egy másik elemnek ugyanabban a listában.\n\nPélda:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0"
    },
    "docstring_bertscore": {
      "sq": "0.988191622477857",
      "hy": "0.9816014636958814",
      "bn": "0.9882470403541657",
      "bg": "0.9686305025535411",
      "zh": "0.9848582074233294",
      "fr": "0.9845284809908115",
      "de": "0.9845284809908115",
      "ha": "0.9711531083926842",
      "hi": "0.9701845866547582",
      "hu": "0.9845284809908115"
    }
  },
  {
    "task_id": "Java/10",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur parasysh madhësinë e hapësirës n-teresting, koordinatat e fillimit dhe përfundimit të n-tersections, dhe rrugët midis n-tersections ngjitur, përcaktoni nëse është e mundur të udhëtohet nga n-tersection i fillimit në n-tersection i përfundimit.\n     * \n     * Parametrat:\n     * - n: madhësia e hapësirës n-teresting\n     * - start: koordinatat e n-tersection të fillimit\n     * - end: koordinatat e n-tersection të përfundimit\n     * - paths: rrugët midis n-tersections ngjitur në hapësirën n-teresting\n     * \n     * Dalja:\n     * - Nëse udhëtimi është i mundur, kthe \"mund të udhëtohet\"\n     * - Nëse udhëtimi nuk është i mundur, kthe \"nuk mund të udhëtohet\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է n-հետաքրքիր տարածքի չափը, մեկնարկային և վերջնական n-հատվածի կոորդինատները, և հարակից n-հատվածների միջև ուղիները, որոշեք՝ արդյոք հնարավոր է ճանապարհորդել մեկնարկային n-հատվածից մինչև վերջնական n-հատված:\n     * \n     * Պարամետրեր:\n     * - n: n-հետաքրքիր տարածքի չափը\n     * - start: մեկնարկային n-հատվածի կոորդինատները\n     * - end: վերջնական n-հատվածի կոորդինատները\n     * - paths: n-հետաքրքիր տարածքում հարակից n-հատվածների միջև ուղիներ\n     * \n     * Ելք:\n     * - Եթե ճանապարհորդությունը հնարավոր է, վերադարձնել \"can be travelled\"\n     * - Եթե ճանապարհորդությունը հնարավոր չէ, վերադարձնել \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * n-আকর্ষণীয় স্থানের আকার, প্রারম্ভিক এবং সমাপ্তি n-সংযোগের স্থানাঙ্ক এবং সংলগ্ন n-সংযোগগুলির মধ্যে পথগুলি দেওয়া হয়েছে, তাহলে প্রারম্ভিক n-সংযোগ থেকে সমাপ্তি n-সংযোগে ভ্রমণ করা সম্ভব কিনা তা নির্ধারণ করুন।\n     * \n     * প্যারামিটার:\n     * - n: n-আকর্ষণীয় স্থানের আকার\n     * - start: প্রারম্ভিক n-সংযোগের স্থানাঙ্ক\n     * - end: সমাপ্তি n-সংযোগের স্থানাঙ্ক\n     * - paths: n-আকর্ষণীয় স্থানের সংলগ্ন n-সংযোগগুলির মধ্যে পথগুলি\n     * \n     * আউটপুট:\n     * - যদি ভ্রমণ সম্ভব হয়, তাহলে \"can be travelled\" ফেরত দিন\n     * - যদি ভ্রমণ সম্ভব না হয়, তাহলে \"cannot be travelled\" ফেরত দিন\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Като се има предвид размерът на n-интересното пространство, началните и крайните координати на n-терсекциите и пътищата между съседните n-терсекции, определете дали е възможно да се пътува от началната n-терсекция до крайната n-терсекция.\n     * \n     * Параметри:\n     * - n: размерът на n-интересното пространство\n     * - start: началните координати на n-терсекцията\n     * - end: крайните координати на n-терсекцията\n     * - paths: пътища между съседните n-терсекции в n-интересното пространство\n     * \n     * Изход:\n     * - Ако пътуването е възможно, върнете \"can be travelled\"\n     * - Ако пътуването не е възможно, върнете \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定n维空间的大小，起始和结束n维交点的坐标，以及相邻n维交点之间的路径，确定是否可以从起始n维交点到达结束n维交点。\n     * \n     * 参数:\n     * - n: n维空间的大小\n     * - start: 起始n维交点的坐标\n     * - end: 结束n维交点的坐标\n     * - paths: n维空间中相邻n维交点之间的路径\n     * \n     * 输出:\n     * - 如果可以旅行，返回 \"can be travelled\"\n     * - 如果不能旅行，返回 \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné la taille de l'espace n-teressant, les coordonnées de départ et d'arrivée des n-tersections, et les chemins entre les n-tersections adjacentes, déterminez s'il est possible de voyager de la n-tersection de départ à la n-tersection d'arrivée.\n     * \n     * Paramètres :\n     * - n : la taille de l'espace n-teressant\n     * - start : les coordonnées de la n-tersection de départ\n     * - end : les coordonnées de la n-tersection d'arrivée\n     * - paths : chemins entre les n-tersections adjacentes dans l'espace n-teressant\n     * \n     * Sortie :\n     * - Si le voyage est possible, retournez \"can be travelled\"\n     * - Si le voyage n'est pas possible, retournez \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben die Größe des n-teressanten Raums, die Start- und Endkoordinaten der n-tersection und die Wege zwischen benachbarten n-tersections, bestimmen Sie, ob es möglich ist, von der Start-n-tersection zur End-n-tersection zu reisen.\n     * \n     * Parameter:\n     * - n: die Größe des n-teressanten Raums\n     * - start: die Startkoordinaten der n-tersection\n     * - end: die Endkoordinaten der n-tersection\n     * - paths: Wege zwischen benachbarten n-tersections im n-teressanten Raum\n     * \n     * Ausgabe:\n     * - Wenn die Reise möglich ist, geben Sie \"can be travelled\" zurück\n     * - Wenn die Reise nicht möglich ist, geben Sie \"cannot be travelled\" zurück\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da girman sararin n-teresting, da farawa da ƙarewar n-tersection coordinates, da kuma hanyoyi tsakanin n-tersections masu makwabtaka, tantance idan yana yiwuwa a yi tafiya daga farawa n-tersection zuwa ƙarewa n-tersection.\n     * \n     * Sigogi:\n     * - n: girman sararin n-teresting\n     * - start: farawa n-tersection coordinates\n     * - end: ƙarewa n-tersection coordinates\n     * - paths: hanyoyi tsakanin n-tersections masu makwabtaka a cikin sararin n-teresting\n     * \n     * Fitarwa:\n     * - Idan tafiya tana yiwuwa, dawo da \"can be travelled\"\n     * - Idan tafiya ba ta yiwuwa, dawo da \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए n-रोचक स्थान का आकार, प्रारंभिक और अंतिम n-चौराहे के निर्देशांक, और आसन्न n-चौराहों के बीच के रास्ते, यह निर्धारित करें कि क्या प्रारंभिक n-चौराहे से अंतिम n-चौराहे तक यात्रा करना संभव है।\n     * \n     * पैरामीटर्स:\n     * - n: n-रोचक स्थान का आकार\n     * - start: प्रारंभिक n-चौराहे के निर्देशांक\n     * - end: अंतिम n-चौराहे के निर्देशांक\n     * - paths: n-रोचक स्थान में आसन्न n-चौराहों के बीच के रास्ते\n     * \n     * आउटपुट:\n     * - यदि यात्रा संभव है, तो \"can be travelled\" लौटाएं\n     * - यदि यात्रा संभव नहीं है, तो \"cannot be travelled\" लौटाएं\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott az n-teresting tér mérete, a kezdő és végső n-tersection koordináták, valamint az utak a szomszédos n-tersections között, határozza meg, hogy lehetséges-e az utazás a kezdő n-tersection-től a végső n-tersection-ig.\n     * \n     * Paraméterek:\n     * - n: az n-teresting tér mérete\n     * - start: a kezdő n-tersection koordináták\n     * - end: a végső n-tersection koordináták\n     * - paths: utak a szomszédos n-tersections között az n-teresting térben\n     * \n     * Kimenet:\n     * - Ha az utazás lehetséges, adja vissza, hogy \"can be travelled\"\n     * - Ha az utazás nem lehetséges, adja vissza, hogy \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) "
    },
    "prompt_bertscore": {
      "sq": "0.9654118958592518",
      "hy": "0.9087831687477294",
      "bn": "0.8975522097432547",
      "bg": "0.9295340846544441",
      "zh": "0.8873650533911184",
      "fr": "0.9709453410141218",
      "de": "0.9648561280531162",
      "ha": "0.9762779708537653",
      "hi": "0.9026200652849788",
      "hu": "0.9949768362940087"
    },
    "canonical_solution": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }",
    "instruction": {
      "en": "Write a Java function `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` to solve the following problem:\nGiven the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"",
      "sq": "Shkruani një funksion Java `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` për të zgjidhur problemin në vijim:  \nDuke pasur madhësinë e hapësirës n-teresting, koordinatat e fillimit dhe mbarimit të n-tersections, dhe rrugët midis n-tersections ngjitur, përcaktoni nëse është e mundur të udhëtohet nga n-tersection i fillimit në n-tersection e mbarimit.\n\nParametrat:\n- n: madhësia e hapësirës n-teresting\n- start: koordinatat e n-tersection të fillimit\n- end: koordinatat e n-tersection të mbarimit\n- paths: rrugët midis n-tersections ngjitur në hapësirën n-teresting\n\nDalja:\n- Nëse udhëtimi është i mundur, kthe \"can be travelled\"\n- Nëse udhëtimi nuk është i mundur, kthe \"cannot be travelled\"",
      "hy": "Գրեք Java ֆունկցիա `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n-հետաքրքիր տարածքի չափը, մեկնարկային և ավարտական n-հատվածների կոորդինատները և ուղիները հարակից n-հատվածների միջև, որոշեք՝ արդյոք հնարավոր է ճանապարհորդել մեկնարկային n-հատվածից մինչև ավարտական n-հատվածը:\n\nՊարամետրեր:\n- n: n-հետաքրքիր տարածքի չափը\n- start: մեկնարկային n-հատվածի կոորդինատները\n- end: ավարտական n-հատվածի կոորդինատները\n- paths: ուղիներ հարակից n-հատվածների միջև n-հետաքրքիր տարածքում\n\nԵլք:\n- Եթե ճանապարհորդությունը հնարավոր է, վերադարձնել \"can be travelled\"\n- Եթե ճանապարհորդությունը հնարավոր չէ, վերադարձնել \"cannot be travelled\"",
      "bn": "একটি জাভা ফাংশন `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn-আকর্ষণীয় স্থানের আকার, প্রারম্ভিক এবং সমাপ্তি n-সংযোগস্থলের স্থানাঙ্ক, এবং সংলগ্ন n-সংযোগস্থলের মধ্যে পথগুলি দেওয়া হলে, প্রারম্ভিক n-সংযোগস্থল থেকে সমাপ্তি n-সংযোগস্থলে ভ্রমণ করা সম্ভব কিনা তা নির্ধারণ করুন।\n\nপ্যারামিটারসমূহ:\n- n: n-আকর্ষণীয় স্থানের আকার\n- start: প্রারম্ভিক n-সংযোগস্থলের স্থানাঙ্ক\n- end: সমাপ্তি n-সংযোগস্থলের স্থানাঙ্ক\n- paths: n-আকর্ষণীয় স্থানের সংলগ্ন n-সংযোগস্থলের মধ্যে পথগুলি\n\nআউটপুট:\n- যদি ভ্রমণ সম্ভব হয়, তাহলে \"can be travelled\" ফেরত দিন\n- যদি ভ্রমণ সম্ভব না হয়, তাহলে \"cannot be travelled\" ফেরত দিন",
      "bg": "Напишете Java функция `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)`, за да решите следния проблем:  \nДадени са размерът на n-интересното пространство, началните и крайните координати на n-пресечението и пътищата между съседни n-пресечения. Определете дали е възможно да се пътува от началното n-пресечение до крайното n-пресечение.\n\nПараметри:\n- n: размерът на n-интересното пространство\n- start: началните координати на n-пресечението\n- end: крайните координати на n-пресечението\n- paths: пътища между съседни n-пресечения в n-интересното пространство\n\nИзход:\n- Ако пътуването е възможно, върнете \"can be travelled\"\n- Ако пътуването не е възможно, върнете \"cannot be travelled\"",
      "zh": "编写一个 Java 函数 `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` 来解决以下问题：\n给定 n-有趣空间的大小、起始和结束 n-交点坐标，以及相邻 n-交点之间的路径，确定是否可以从起始 n-交点旅行到结束 n-交点。\n\n参数：\n- n: n-有趣空间的大小\n- start: 起始 n-交点坐标\n- end: 结束 n-交点坐标\n- paths: n-有趣空间中相邻 n-交点之间的路径\n\n输出：\n- 如果可以旅行，返回 \"can be travelled\"\n- 如果无法旅行，返回 \"cannot be travelled\"",
      "fr": "Écrire une fonction Java `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` pour résoudre le problème suivant :  \nÉtant donné la taille de l'espace n-téressant, les coordonnées de départ et d'arrivée des n-tersections, et les chemins entre les n-tersections adjacentes, déterminer s'il est possible de voyager de la n-tersection de départ à la n-tersection d'arrivée.\n\nParamètres :\n- n : la taille de l'espace n-téressant\n- start : les coordonnées de la n-tersection de départ\n- end : les coordonnées de la n-tersection d'arrivée\n- paths : chemins entre les n-tersections adjacentes dans l'espace n-téressant\n\nSortie :\n- Si le voyage est possible, retourner \"can be travelled\"\n- Si le voyage n'est pas possible, retourner \"cannot be travelled\"",
      "de": "Schreiben Sie eine Java-Funktion `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)`, um das folgende Problem zu lösen:  \nGegeben die Größe des n-teressanten Raums, die Start- und Endkoordinaten der n-tersection und die Pfade zwischen benachbarten n-tersections, bestimmen Sie, ob es möglich ist, von der Start-n-tersection zur End-n-tersection zu reisen.\n\nParameter:\n- n: die Größe des n-teressanten Raums\n- start: die Startkoordinaten der n-tersection\n- end: die Endkoordinaten der n-tersection\n- paths: Pfade zwischen benachbarten n-tersections im n-teressanten Raum\n\nAusgabe:\n- Wenn eine Reise möglich ist, geben Sie \"can be travelled\" zurück\n- Wenn eine Reise nicht möglich ist, geben Sie \"cannot be travelled\" zurück",
      "ha": "Rubuta aikin Java `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` don warware matsalar mai zuwa:\nAn ba da girman sararin n-teresting, da farawa da ƙarewar haɗin n-tersection, da hanyoyin tsakanin makwabta n-tersections, tantance ko yana yiwuwa a yi tafiya daga farawa n-tersection zuwa ƙarewa n-tersection.\n\nSigogi:\n- n: girman sararin n-teresting\n- start: farawa n-tersection haɗin kai\n- end: ƙarewa n-tersection haɗin kai\n- paths: hanyoyi tsakanin makwabta n-tersections a cikin sararin n-teresting\n\nFitarwa:\n- Idan tafiya tana yiwuwa, mayar da \"can be travelled\"\n- Idan tafiya ba ta yiwu ba, mayar da \"cannot be travelled\"",
      "hi": "Java फ़ंक्शन `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n-रोचक स्थान का आकार, प्रारंभिक और अंतिम n-इंटरसेक्शन निर्देशांक, और निकटवर्ती n-इंटरसेक्शनों के बीच के रास्ते, यह निर्धारित करें कि क्या प्रारंभिक n-इंटरसेक्शन से अंतिम n-इंटरसेक्शन तक यात्रा करना संभव है।\n\nपैरामीटर्स:\n- n: n-रोचक स्थान का आकार\n- start: प्रारंभिक n-इंटरसेक्शन निर्देशांक\n- end: अंतिम n-इंटरसेक्शन निर्देशांक\n- paths: n-रोचक स्थान में निकटवर्ती n-इंटरसेक्शनों के बीच के रास्ते\n\nआउटपुट:\n- यदि यात्रा संभव है, तो \"can be travelled\" लौटाएँ\n- यदि यात्रा संभव नहीं है, तो \"cannot be travelled\" लौटाएँ",
      "hu": "Írj egy Java függvényt `public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)` a következő probléma megoldására:\nAdott az n-érdekes tér mérete, a kezdő és végpont n-kereszteződés koordinátái, valamint az utak a szomszédos n-kereszteződések között, határozd meg, hogy lehetséges-e eljutni a kezdő n-kereszteződésből a végső n-kereszteződésbe.\n\nParaméterek:\n- n: az n-érdekes tér mérete\n- start: a kezdő n-kereszteződés koordinátái\n- end: a végső n-kereszteződés koordinátái\n- paths: utak a szomszédos n-kereszteződések között az n-érdekes térben\n\nKimenet:\n- Ha az utazás lehetséges, térj vissza az \"can be travelled\" értékkel\n- Ha az utazás nem lehetséges, térj vissza a \"cannot be travelled\" értékkel"
    },
    "instruction_bertscore": {
      "sq": "0.9722479590529485",
      "hy": "0.8963667836292385",
      "bn": "0.8716619313576432",
      "bg": "0.9144937922024824",
      "zh": "0.8783978848392984",
      "fr": "0.9709713615940373",
      "de": "0.9650640940620597",
      "ha": "0.9654828069052813",
      "hi": "0.8584494356719645",
      "hu": "0.9143456139382303"
    },
    "level": "hard",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "canTravelMaze",
    "signature": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)",
    "docstring": {
      "en": "Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"",
      "sq": "Duke pasur parasysh madhësinë e hapësirës n-teresting, koordinatat e fillimit dhe mbarimit të n-tersection, dhe rrugët midis n-tersections ngjitur, përcaktoni nëse është e mundur të udhëtohet nga n-tersection i fillimit në n-tersection i mbarimit.\n\nParametra:\n- n: madhësia e hapësirës n-teresting\n- start: koordinatat e fillimit të n-tersection\n- end: koordinatat e mbarimit të n-tersection\n- paths: rrugët midis n-tersections ngjitur në hapësirën n-teresting\n\nDalje:\n- Nëse udhëtimi është i mundur, kthe \"mund të udhëtohet\"\n- Nëse udhëtimi nuk është i mundur, kthe \"nuk mund të udhëtohet\"",
      "hy": "Տրված n-հետաքրքիր տարածքի չափը, մեկնարկային և վերջնական n-հատվածների կոորդինատները և հարակից n-հատվածների միջև ուղիները, որոշեք՝ արդյոք հնարավոր է ճանապարհորդել մեկնարկային n-հատվածից մինչև վերջնական n-հատված:\n\nՊարամետրեր:\n- n: n-հետաքրքիր տարածքի չափը\n- start: մեկնարկային n-հատվածի կոորդինատները\n- end: վերջնական n-հատվածի կոորդինատները\n- paths: n-հետաքրքիր տարածքում հարակից n-հատվածների միջև ուղիներ\n\nԵլք:\n- Եթե ճանապարհորդությունը հնարավոր է, վերադարձնել \"կարող է ճանապարհորդվել\"\n- Եթե ճանապարհորդությունը հնարավոր չէ, վերադարձնել \"չի կարող ճանապարհորդվել\"",
      "bn": "n-teresting স্থানের আকার, শুরু এবং শেষ n-tersection এর স্থানাঙ্ক, এবং সংলগ্ন n-tersections এর মধ্যে পথগুলি দেওয়া হলে, শুরু n-tersection থেকে শেষ n-tersection এ ভ্রমণ করা সম্ভব কিনা তা নির্ধারণ করুন।\n\nপ্যারামিটারসমূহ:\n- n: n-teresting স্থানের আকার\n- start: শুরু n-tersection এর স্থানাঙ্ক\n- end: শেষ n-tersection এর স্থানাঙ্ক\n- paths: n-teresting স্থানে সংলগ্ন n-tersections এর মধ্যে পথগুলি\n\nআউটপুট:\n- যদি ভ্রমণ সম্ভব হয়, তাহলে \"can be travelled\" ফেরত দিন\n- যদি ভ্রমণ সম্ভব না হয়, তাহলে \"cannot be travelled\" ফেরত দিন",
      "bg": "Дадени размера на n-интересното пространство, началните и крайните координати на n-терсекциите и пътищата между съседните n-терсекции, определете дали е възможно да се пътува от началната n-терсекция до крайната n-терсекция.\n\nПараметри:\n- n: размерът на n-интересното пространство\n- start: началните координати на n-терсекцията\n- end: крайните координати на n-терсекцията\n- paths: пътища между съседните n-терсекции в n-интересното пространство\n\nИзход:\n- Ако пътуването е възможно, върнете \"може да се пътува\"\n- Ако пътуването не е възможно, върнете \"не може да се пътува\"",
      "zh": "给定n-teresting空间的大小、起始和结束n-tersection坐标，以及相邻n-tersections之间的路径，确定是否可以从起始n-tersection到达结束n-tersection。\n\n参数：\n- n: n-teresting空间的大小\n- start: 起始n-tersection坐标\n- end: 结束n-tersection坐标\n- paths: n-teresting空间中相邻n-tersections之间的路径\n\n输出：\n- 如果可以旅行，返回\"can be travelled\"\n- 如果无法旅行，返回\"cannot be travelled\"",
      "fr": "Étant donné la taille de l'espace n-téressant, les coordonnées de départ et d'arrivée des n-tersections, et les chemins entre les n-tersections adjacentes, déterminez s'il est possible de voyager de la n-tersection de départ à la n-tersection d'arrivée.\n\nParamètres:\n- n: la taille de l'espace n-téressant\n- start: les coordonnées de la n-tersection de départ\n- end: les coordonnées de la n-tersection d'arrivée\n- paths: chemins entre les n-tersections adjacentes dans l'espace n-téressant\n\nSortie:\n- Si le voyage est possible, retournez \"can be travelled\"\n- Si le voyage n'est pas possible, retournez \"cannot be travelled\"",
      "de": "Angesichts der Größe des n-teressanten Raums, der Start- und Endkoordinaten der n-tersektion sowie der Pfade zwischen benachbarten n-tersektionen, bestimmen Sie, ob es möglich ist, von der Start-n-tersektion zur End-n-tersektion zu reisen.\n\nParameter:\n- n: die Größe des n-teressanten Raums\n- start: die Startkoordinaten der n-tersektion\n- end: die Endkoordinaten der n-tersektion\n- paths: Pfade zwischen benachbarten n-tersektionen im n-teressanten Raum\n\nAusgabe:\n- Wenn eine Reise möglich ist, geben Sie \"kann gereist werden\" zurück\n- Wenn eine Reise nicht möglich ist, geben Sie \"kann nicht gereist werden\" zurück",
      "ha": "An ba da girman sararin n-teresting, da farawa da ƙarshen daidaitattun n-tersection, da hanyoyin da ke tsakanin n-tersections masu makwabtaka, tantance ko zai yiwu a yi tafiya daga farawa n-tersection zuwa ƙarshen n-tersection.\n\nSigogi:\n- n: girman sararin n-teresting\n- start: farawa daidaitattun n-tersection\n- end: ƙarshen daidaitattun n-tersection\n- paths: hanyoyi tsakanin n-tersections masu makwabtaka a cikin sararin n-teresting\n\nFitarwa:\n- Idan tafiya zai yiwu, mayar da \"can be travelled\"\n- Idan tafiya ba zai yiwu ba, mayar da \"cannot be travelled\"",
      "hi": "n-teresting स्थान के आकार, प्रारंभिक और अंतिम n-tersection निर्देशांक, और आसन्न n-tersections के बीच के रास्तों को देखते हुए, यह निर्धारित करें कि क्या प्रारंभिक n-tersection से अंतिम n-tersection तक यात्रा करना संभव है।\n\nपैरामीटर्स:\n- n: n-teresting स्थान का आकार\n- start: प्रारंभिक n-tersection निर्देशांक\n- end: अंतिम n-tersection निर्देशांक\n- paths: n-teresting स्थान में आसन्न n-tersections के बीच के रास्ते\n\nआउटपुट:\n- यदि यात्रा संभव है, तो \"can be travelled\" लौटाएं\n- यदि यात्रा संभव नहीं है, तो \"cannot be travelled\" लौटाएं",
      "hu": "A n-teresting tér mérete, a kezdő és végső n-tersection koordinátái, valamint a szomszédos n-tersections közötti utak alapján határozza meg, hogy lehetséges-e utazni a kezdő n-tersection-től a végső n-tersection-ig.\n\nParaméterek:\n- n: a n-teresting tér mérete\n- start: a kezdő n-tersection koordinátái\n- end: a végső n-tersection koordinátái\n- paths: utak a szomszédos n-tersections között a n-teresting térben\n\nKimenet:\n- Ha az utazás lehetséges, adja vissza, hogy \"can be travelled\"\n- Ha az utazás nem lehetséges, adja vissza, hogy \"cannot be travelled\""
    },
    "docstring_bertscore": {
      "sq": "0.9478382715275712",
      "hy": "0.8712112390230751",
      "bn": "0.9009535563880962",
      "bg": "0.9013031458587175",
      "zh": "0.9466433111552652",
      "fr": "0.9676683369878082",
      "de": "0.9513238374539713",
      "ha": "0.9724863155101904",
      "hi": "0.9225919528372748",
      "hu": "0.916746260723418"
    }
  },
  {
    "task_id": "Java/11",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Vlera e përafërt llogaritet duke numëruar numrin e shkronjave të përbashkëta\n     * dhe duke e pjesëtuar atë me shumën e gjatësive të dy fjalëve.\n     *\n     * @param word1 Fjala e parë.\n     * @param word2 Fjala e dytë.\n     * @return Vlera e përafërt si një thyesë e reduktuar.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Մոտավոր արժեքը հաշվարկվում է ընդհանուր տառերի քանակը հաշվելով\n     * և այն բաժանելով երկու բառերի երկարությունների գումարին։\n     *\n     * @param word1 Առաջին բառը։\n     * @param word2 Երկրորդ բառը։\n     * @return Մոտավոր արժեքը որպես կրճատված կոտորակ։\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * আনুমানিক মানটি সাধারণ অক্ষরের সংখ্যা গণনা করে এবং \n     * এটি দুটি শব্দের দৈর্ঘ্যের যোগফল দ্বারা ভাগ করে হিসাব করা হয়।\n     *\n     * @param word1 প্রথম শব্দ।\n     * @param word2 দ্বিতীয় শব্দ।\n     * @return আনুমানিক মান একটি হ্রাসকৃত ভগ্নাংশ হিসাবে।\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Приблизителната стойност се изчислява чрез преброяване на броя на общите букви\n     * и разделянето му на сумата от дължините на двете думи.\n     *\n     * @param word1 Първата дума.\n     * @param word2 Втората дума.\n     * @return Приблизителната стойност като съкратена дроб.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 通过计算共同字母的数量并将其除以两个单词长度之和来计算近似值。\n     *\n     * @param word1 第一个单词。\n     * @param word2 第二个单词。\n     * @return 作为约分的分数形式的近似值。\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * La valeur approximative est calculée en comptant le nombre de lettres communes\n     * et en le divisant par la somme des longueurs des deux mots.\n     *\n     * @param word1 Le premier mot.\n     * @param word2 Le second mot.\n     * @return La valeur approximative sous forme de fraction réduite.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Der ungefähre Wert wird berechnet, indem die Anzahl der gemeinsamen Buchstaben\n     * gezählt und durch die Summe der Längen der beiden Wörter geteilt wird.\n     *\n     * @param word1 Das erste Wort.\n     * @param word2 Das zweite Wort.\n     * @return Der ungefähre Wert als gekürzter Bruch.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ana ƙididdige kimar kusan ta hanyar ƙidaya yawan haruffa masu kama\n     * sannan a raba shi da jimillar tsawon kalmomin biyu.\n     *\n     * @param word1 Kalma ta farko.\n     * @param word2 Kalma ta biyu.\n     * @return Kimar kusan a matsayin ƙananan kason.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * अनुमानित मान की गणना सामान्य अक्षरों की संख्या गिनकर\n     * और इसे दोनों शब्दों की लंबाई के योग से विभाजित करके की जाती है।\n     *\n     * @param word1 पहला शब्द।\n     * @param word2 दूसरा शब्द।\n     * @return अनुमानित मान एक घटित भिन्न के रूप में।\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Az approximált értéket úgy számítjuk ki, hogy megszámoljuk a közös betűk számát\n     * és elosztjuk a két szó hosszának összegével.\n     *\n     * @param word1 Az első szó.\n     * @param word2 A második szó.\n     * @return Az approximált érték egyszerűsített tört formájában.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9962589954035889",
      "bn": "0.9891813976665538",
      "bg": "1",
      "zh": "0.9874207379690605",
      "fr": "1",
      "de": "0.9959330429483106",
      "ha": "0.9744583179331048",
      "hi": "0.9779710962217067",
      "hu": "0.9879443276534685"
    },
    "canonical_solution": "    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }",
    "instruction": {
      "en": "Write a Java function `public static String appx(String word1, String word2)` to solve the following problem:\nThe approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "sq": "Shkruani një funksion Java `public static String appx(String word1, String word2)` për të zgjidhur problemin në vijim:\nVlera e përafërt llogaritet duke numëruar numrin e shkronjave të përbashkëta\ndhe duke e pjesëtuar me shumën e gjatësive të dy fjalëve.\n\n@param word1 Fjala e parë.\n@param word2 Fjala e dytë.\n@return Vlera e përafërt si një thyesë e reduktuar.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hy": "Գրեք Java ֆունկցիա `public static String appx(String word1, String word2)` հետևյալ խնդիրը լուծելու համար:\nՄոտավոր արժեքը հաշվարկվում է ընդհանուր տառերի քանակը հաշվելով և այն բաժանելով երկու բառերի երկարությունների գումարի վրա։\n\n@param word1 Առաջին բառը։\n@param word2 Երկրորդ բառը։\n@return Մոտավոր արժեքը որպես կրճատված կոտորակ։\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "bn": "একটি জাভা ফাংশন `public static String appx(String word1, String word2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআনুমানিক মানটি সাধারণ অক্ষরের সংখ্যা গণনা করে এবং এটি দুটি শব্দের দৈর্ঘ্যের যোগফল দ্বারা ভাগ করে গণনা করা হয়।\n\n@param word1 প্রথম শব্দ।\n@param word2 দ্বিতীয় শব্দ।\n@return আনুমানিক মান একটি হ্রাসকৃত ভগ্নাংশ হিসাবে। \n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "bg": "Напишете Java функция `public static String appx(String word1, String word2)` за решаване на следния проблем:\nПриблизителната стойност се изчислява чрез броене на броя на общите букви\nи разделянето му на сумата от дължините на двете думи.\n\n@param word1 Първата дума.\n@param word2 Втората дума.\n@return Приблизителната стойност като съкратена дроб.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "zh": "编写一个 Java 函数 `public static String appx(String word1, String word2)` 来解决以下问题：\n近似值通过计算共同字母的数量并将其除以两个单词长度的总和来计算。\n\n@param word1 第一个单词。\n@param word2 第二个单词。\n@return 作为约分的近似值。\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "fr": "Écrire une fonction Java `public static String appx(String word1, String word2)` pour résoudre le problème suivant :\nLa valeur approximative est calculée en comptant le nombre de lettres communes\net en le divisant par la somme des longueurs des deux mots.\n\n@param word1 Le premier mot.\n@param word2 Le deuxième mot.\n@return La valeur approximative sous forme de fraction réduite.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "de": "Schreiben Sie eine Java-Funktion `public static String appx(String word1, String word2)`, um das folgende Problem zu lösen:\nDer ungefähre Wert wird berechnet, indem die Anzahl der gemeinsamen Buchstaben gezählt und durch die Summe der Längen der beiden Wörter geteilt wird.\n\n@param word1 Das erste Wort.\n@param word2 Das zweite Wort.\n@return Der ungefähre Wert als gekürzter Bruch.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "ha": "Rubuta aikin Java `public static String appx(String word1, String word2)` don warware matsalar mai zuwa:\nAna ƙididdige kimar kusan ta hanyar ƙidaya yawan haruffa na gama gari\nkuma a raba shi da jimillar tsawon kalmomin biyu.\n\n@param word1 Kalma ta farko.\n@param word2 Kalma ta biyu.\n@return Kimar kusan a matsayin ƙananan kaso.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hi": "Java फ़ंक्शन `public static String appx(String word1, String word2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nअनुमानित मान की गणना सामान्य अक्षरों की संख्या को गिनकर और उसे दो शब्दों की लंबाई के योग से विभाजित करके की जाती है।\n\n@param word1 पहला शब्द।\n@param word2 दूसरा शब्द।\n@return अनुमानित मान एक घटित भिन्न के रूप में।\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hu": "Írj egy Java függvényt `public static String appx(String word1, String word2)` a következő probléma megoldására:\nAz hozzávetőleges értéket úgy számítjuk ki, hogy megszámoljuk a közös betűk számát, és elosztjuk a két szó hosszának összegével.\n\n@param word1 Az első szó.\n@param word2 A második szó.\n@return Az hozzávetőleges érték egyszerűsített tört formájában.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\""
    },
    "instruction_bertscore": {
      "sq": "0.8602275067717364",
      "hy": "0.8602275067717364",
      "bn": "0.9890534797011673",
      "bg": "0.8602275067717364",
      "zh": "0.8504105974498492",
      "fr": "0.8602275067717364",
      "de": "0.9954473916666804",
      "ha": "0.8401549136162558",
      "hi": "0.9743729068692598",
      "hu": "0.9907744133224535"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0/10\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "appx",
    "signature": "public static String appx(String word1, String word2)",
    "docstring": {
      "en": "The approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "sq": "Vlera e përafërt llogaritet duke numëruar numrin e shkronjave të përbashkëta dhe duke e pjesëtuar atë me shumën e gjatësive të dy fjalëve.\n\n@param word1 Fjala e parë.\n@param word2 Fjala e dytë.\n@return Vlera e përafërt si një thyesë e reduktuar.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hy": "Մոտավոր արժեքը հաշվարկվում է ընդհանուր տառերի քանակը հաշվելով\nև այն բաժանելով երկու բառերի երկարությունների գումարին։\n\n@param word1 Առաջին բառը։\n@param word2 Երկրորդ բառը։\n@return Մոտավոր արժեքը որպես կրճատված կոտորակ։\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "bn": "আনুমানিক মানটি সাধারণ অক্ষরের সংখ্যা গণনা করে এবং এটি দুটি শব্দের দৈর্ঘ্যের যোগফল দ্বারা ভাগ করে গণনা করা হয়।\n\n@param word1 প্রথম শব্দ।\n@param word2 দ্বিতীয় শব্দ।\n@return আনুমানিক মান একটি হ্রাসকৃত ভগ্নাংশ হিসেবে।\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "bg": "Приблизителната стойност се изчислява чрез броене на броя на общите букви и разделянето му на сумата от дължините на двете думи.\n\n@param word1 Първата дума.\n@param word2 Втората дума.\n@return Приблизителната стойност като съкратена дроб.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "zh": "通过计算共同字母的数量并将其除以两个单词长度之和来计算近似值。\n\n@param word1 第一个单词。\n@param word2 第二个单词。\n@return 作为约分分数的近似值。\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "fr": "La valeur approximative est calculée en comptant le nombre de lettres communes et en le divisant par la somme des longueurs des deux mots.\n\n@param word1 Le premier mot.\n@param word2 Le deuxième mot.\n@return La valeur approximative sous forme de fraction réduite.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "de": "Der ungefähre Wert wird berechnet, indem die Anzahl der gemeinsamen Buchstaben gezählt und durch die Summe der Längen der beiden Wörter geteilt wird.\n\n@param word1 Das erste Wort.\n@param word2 Das zweite Wort.\n@return Der ungefähre Wert als gekürzter Bruch.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "ha": "An kimanta darajar ta hanyar ƙididdige adadin haruffa masu kama da raba shi da jumlar tsawon kalmomin biyu.\n\n@param word1 Kalma ta farko.\n@param word2 Kalma ta biyu.\n@return Kimanta darajar a matsayin ƙananan rabon.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hi": "अनुमानित मान की गणना सामान्य अक्षरों की संख्या को गिनकर और उसे दो शब्दों की लंबाई के योग से विभाजित करके की जाती है।\n\n@param word1 पहला शब्द।\n@param word2 दूसरा शब्द।\n@return घटे हुए भिन्न के रूप में अनुमानित मान।\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hu": "Az hozzávetőleges értéket úgy számítjuk ki, hogy megszámoljuk a közös betűk számát, és elosztjuk a két szó hosszának összegével.\n\n@param word1 Az első szó.\n@param word2 A második szó.\n@return Az hozzávetőleges érték egyszerűsített tört formájában.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9900460357151987",
      "bn": "0.9806091063122311",
      "bg": "0.999999801369619",
      "zh": "0.9781611854963571",
      "fr": "0.999999801369619",
      "de": "0.9960283855312074",
      "ha": "0.9592491896572634",
      "hi": "0.9849408376618399",
      "hu": "0.9930739572436945"
    }
  },
  {
    "task_id": "Java/12",
    "prompt": {
      "en": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "sq": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Duke pasur një datë në formatin \"MM dd yyyy\", kthe ditën e javës për atë datë.\n     * \n     * Shembull:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "hy": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Տրված ամսաթիվը \"MM dd yyyy\" ձևաչափով, վերադարձնում է օրվա անունը:\n     * \n     * Օրինակ:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "bn": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * \"MM dd yyyy\" বিন্যাসে একটি তারিখ দেওয়া হলে, তারিখের সপ্তাহের দিনটি ফেরত দিন।\n     * \n     * উদাহরণ:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "bg": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Като се даде дата във формат \"MM dd yyyy\", върнете деня от седмицата на датата.\n     * \n     * Пример:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "zh": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * 给定一个格式为 \"MM dd yyyy\" 的日期，返回该日期的星期。\n     * \n     * 示例:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "fr": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Étant donné une date au format \"MM dd yyyy\", retourne le jour de la semaine de la date.\n     * \n     * Exemple:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "de": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Gegeben ein Datum im Format \"MM dd yyyy\", gib den Wochentag des Datums zurück.\n     * \n     * Beispiel:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "ha": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * An ba da wata rana a cikin tsarin \"MM dd yyyy\", mayar da ranar mako na ranar.\n     * \n     * Misali:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "hi": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * दिए गए दिनांक को \"MM dd yyyy\" प्रारूप में, दिनांक का सप्ताह का दिन लौटाएं।\n     * \n     * उदाहरण:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "hu": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Adott egy dátum \"MM dd yyyy\" formátumban, adja vissza a dátum hétköznapját.\n     * \n     * Példa:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) "
    },
    "prompt_bertscore": {
      "sq": "0.9809465793296094",
      "hy": "0.980756490054959",
      "bn": "0.9821890123629826",
      "bg": "0.9821890123629826",
      "zh": "0.9809465793296094",
      "fr": "0.9824462387064228",
      "de": "1",
      "ha": "0.9837699115656393",
      "hi": "0.9682920363842576",
      "hu": "0.9945221713518199"
    },
    "canonical_solution": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }",
    "instruction": {
      "en": "Write a Java function `public static String convertDatesToWeekdays(String date)` to solve the following problem:\nGiven a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "sq": "Shkruani një funksion Java `public static String convertDatesToWeekdays(String date)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një datë në formatin \"MM dd yyyy\", kthejeni ditën e javës të datës.\n\nShembull:  \n>>> convertDatesToWeekdays(\"11 15 1997\")  \n\"November 15, 1997 is a Saturday\"  \n>>> convertDatesToWeekdays(\"01 01 2000\")  \n\"January 1, 2000 is a Saturday\"  \n>>> convertDatesToWeekdays(\"07 04 1998\")  \n\"July 4, 1998 is a Saturday\"",
      "hy": "Գրեք Java ֆունկցիա `public static String convertDatesToWeekdays(String date)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամսաթիվ \"MM dd yyyy\" ձևաչափով, վերադարձնել ամսաթվի շաբաթվա օրը:\n\nՕրինակ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "bn": "একটি জাভা ফাংশন `public static String convertDatesToWeekdays(String date)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\"MM dd yyyy\" ফরম্যাটে একটি তারিখ দেওয়া হলে, তারিখটির সপ্তাহের দিনটি ফেরত দিন।\n\nউদাহরণ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "bg": "Напишете Java функция `public static String convertDatesToWeekdays(String date)`, за да решите следния проблем:  \nДадена е дата във формат \"MM dd yyyy\", върнете деня от седмицата за тази дата.\n\nПример:  \n>>> convertDatesToWeekdays(\"11 15 1997\")  \n\"November 15, 1997 is a Saturday\"  \n>>> convertDatesToWeekdays(\"01 01 2000\")  \n\"January 1, 2000 is a Saturday\"  \n>>> convertDatesToWeekdays(\"07 04 1998\")  \n\"July 4, 1998 is a Saturday\"",
      "zh": "编写一个 Java 函数 `public static String convertDatesToWeekdays(String date)` 来解决以下问题：  \n给定一个格式为 \"MM dd yyyy\" 的日期，返回该日期的星期几。  \n\n示例:  \n>>> convertDatesToWeekdays(\"11 15 1997\")  \n\"November 15, 1997 is a Saturday\"  \n>>> convertDatesToWeekdays(\"01 01 2000\")  \n\"January 1, 2000 is a Saturday\"  \n>>> convertDatesToWeekdays(\"07 04 1998\")  \n\"July 4, 1998 is a Saturday\"",
      "fr": "Écrire une fonction Java `public static String convertDatesToWeekdays(String date)` pour résoudre le problème suivant :  \nÉtant donné une date au format \"MM dd yyyy\", retourner le jour de la semaine de la date.\n\nExemple :  \n>>> convertDatesToWeekdays(\"11 15 1997\")  \n\"November 15, 1997 is a Saturday\"  \n>>> convertDatesToWeekdays(\"01 01 2000\")  \n\"January 1, 2000 is a Saturday\"  \n>>> convertDatesToWeekdays(\"07 04 1998\")  \n\"July 4, 1998 is a Saturday\"",
      "de": "Schreiben Sie eine Java-Funktion `public static String convertDatesToWeekdays(String date)`, um das folgende Problem zu lösen:\nGegeben ist ein Datum im Format \"MM dd yyyy\", geben Sie den Wochentag des Datums zurück.\n\nBeispiel:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "ha": "Rubuta wani aikin Java `public static String convertDatesToWeekdays(String date)` don warware matsalar mai zuwa:  \nAn ba da wata rana a cikin tsarin \"MM dd yyyy\", dawo da ranar mako na ranar. \n\nMisali:  \n>>> convertDatesToWeekdays(\"11 15 1997\")  \n\"November 15, 1997 is a Saturday\"  \n>>> convertDatesToWeekdays(\"01 01 2000\")  \n\"January 1, 2000 is a Saturday\"  \n>>> convertDatesToWeekdays(\"07 04 1998\")  \n\"July 4, 1998 is a Saturday\"",
      "hi": "एक जावा फ़ंक्शन `public static String convertDatesToWeekdays(String date)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए तिथि प्रारूप \"MM dd yyyy\" में, तिथि का सप्ताह का दिन लौटाएं।\n\nउदाहरण:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "hu": "Írj egy Java függvényt `public static String convertDatesToWeekdays(String date)` a következő probléma megoldására:  \nAdott egy dátum \"MM dd yyyy\" formátumban, add vissza a dátum hétköznapját.\n\nPélda:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\""
    },
    "instruction_bertscore": {
      "sq": "0.9806295652414777",
      "hy": "0.9704928610061243",
      "bn": "0.9788933370808518",
      "bg": "0.9759637375909682",
      "zh": "0.977146780140412",
      "fr": "0.9806295652414777",
      "de": "0.999999801369619",
      "ha": "0.9788933370808518",
      "hi": "0.9700495179956544",
      "hu": "0.999999801369619"
    },
    "level": "hard",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "convertDatesToWeekdays",
    "signature": "public static String convertDatesToWeekdays(String date)",
    "docstring": {
      "en": "Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "sq": "Dhënë një datë në formatin \"MM dd yyyy\", kthe ditën e javës për atë datë.\n\nShembull:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 është një e Shtunë\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 është një e Shtunë\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 është një e Shtunë\"",
      "hy": "Տրված ամսաթիվը \"MM dd yyyy\" ձևաչափով, վերադարձնել ամսաթվի շաբաթվա օրը:\n\nՕրինակ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "bn": "প্রদত্ত তারিখ \"MM dd yyyy\" বিন্যাসে থাকলে, তারিখের সপ্তাহের দিনটি ফেরত দিন।\n\nউদাহরণ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "bg": "Дадена е дата във формат \"MM dd yyyy\", върнете деня от седмицата на датата.\n\nПример:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 е събота\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 е събота\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 е събота\"",
      "zh": "给定格式为“MM dd yyyy”的日期，返回该日期的星期几。\n\n例子：\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "fr": "Étant donné une date au format \"MM dd yyyy\", retourner le jour de la semaine de la date.\n\nExemple :\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "de": "Gegeben ein Datum im Format \"MM dd yyyy\", gib den Wochentag des Datums zurück.\n\nBeispiel:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "ha": "An ba da wata rana a cikin tsarin \"MM dd yyyy\", mayar da ranar mako na ranar.\n\nMisali:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 rana ce ta Asabar\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 rana ce ta Asabar\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 rana ce ta Asabar\"",
      "hi": "दिए गए दिनांक को \"MM dd yyyy\" प्रारूप में लेते हुए, उस दिनांक का सप्ताह का दिन लौटाएं।\n\nउदाहरण:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "hu": "Adott egy dátum \"MM dd yyyy\" formátumban, adja vissza a dátum hét napját.\n\nPélda:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\""
    },
    "docstring_bertscore": {
      "sq": "0.972893905052074",
      "hy": "0.9531716958887388",
      "bn": "0.972893905052074",
      "bg": "0.9678913989057103",
      "zh": "0.972893905052074",
      "fr": "0.974840681416597",
      "de": "1",
      "ha": "1",
      "hi": "0.9596371147914246",
      "hu": "0.9706094570397917"
    }
  },
  {
    "task_id": "Java/13",
    "prompt": {
      "en": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "sq": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Duke pasur një varg të numrave të plotë nums dhe një numër të plotë target,\n     * gjeni dy numra të tillë që shuma e tyre të jetë e barabartë me target dhe ktheni indeksat e tyre.\n     * Ju mund të supozoni se secili input do të ketë saktësisht një zgjidhje,\n     * dhe nuk mund të përdorni të njëjtin element dy herë.\n     * Ju mund ta ktheni përgjigjen në çfarëdo rendi.\n     *\n     * Shembull 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Shpjegim: Sepse nums[0] + nums[1] == 9, ne kthejmë [0, 1].\n     *\n     * Shembull 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Shembull 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "hy": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված nums և ամբողջ թիվ target,\n     * գտնել երկու թիվ, որոնք գումարվում են target-ի և վերադարձնել նրանց ինդեքսները:\n     * Կարող եք ենթադրել, որ յուրաքանչյուր մուտք կունենա ճիշտ մեկ լուծում,\n     * և դուք չեք կարող օգտագործել նույն տարրը երկու անգամ:\n     * Դուք կարող եք վերադարձնել պատասխանը ցանկացած կարգով:\n     *\n     * Օրինակ 1:\n     * Մուտքագրում: nums = [2,7,11,15], target = 9\n     * Ելք: [0,1]\n     * Բացատրություն: Քանի որ nums[0] + nums[1] == 9, մենք վերադարձնում ենք [0, 1]:\n     *\n     * Օրինակ 2:\n     * Մուտքագրում: nums = [3,2,4], target = 6\n     * Ելք: [1,2]\n     *\n     * Օրինակ 3:\n     * Մուտքագրում: nums = [3,3], target = 6\n     * Ելք: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "bn": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে nums এবং একটি পূর্ণসংখ্যা target দেওয়া আছে,\n     * দুটি সংখ্যা খুঁজুন যাদের যোগফল target এর সমান এবং তাদের সূচক ফেরত দিন।\n     * আপনি ধরে নিতে পারেন যে প্রতিটি ইনপুটের ঠিক একটি সমাধান থাকবে,\n     * এবং আপনি একই উপাদান দুবার ব্যবহার করতে পারবেন না।\n     * আপনি যেকোনো ক্রমে উত্তরটি ফেরত দিতে পারেন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: nums = [2,7,11,15], target = 9\n     * আউটপুট: [0,1]\n     * ব্যাখ্যা: কারণ nums[0] + nums[1] == 9, আমরা [0, 1] ফেরত দিই।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: nums = [3,2,4], target = 6\n     * আউটপুট: [1,2]\n     *\n     * উদাহরণ 3:\n     * ইনপুট: nums = [3,3], target = 6\n     * আউটপুট: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "bg": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Даден е масив от цели числа nums и цяло число target,\n     * намерете две числа, така че тяхната сума да е равна на target и върнете техните индекси.\n     * Може да приемете, че всяко въведено число ще има точно едно решение,\n     * и не може да използвате един и същ елемент два пъти.\n     * Можете да върнете отговора в произволен ред.\n     *\n     * Пример 1:\n     * Вход: nums = [2,7,11,15], target = 9\n     * Изход: [0,1]\n     * Обяснение: Тъй като nums[0] + nums[1] == 9, връщаме [0, 1].\n     *\n     * Пример 2:\n     * Вход: nums = [3,2,4], target = 6\n     * Изход: [1,2]\n     *\n     * Пример 3:\n     * Вход: nums = [3,3], target = 6\n     * Изход: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "zh": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * 给定一个整数数组 nums 和一个整数 target，\n     * 找到两个数使得它们的和等于 target，并返回它们的索引。\n     * 你可以假设每种输入只会对应一个答案，\n     * 并且你不能重复使用相同的元素。\n     * 你可以按任意顺序返回答案。\n     *\n     * 示例 1:\n     * 输入: nums = [2,7,11,15], target = 9\n     * 输出: [0,1]\n     * 解释: 因为 nums[0] + nums[1] == 9，我们返回 [0, 1]。\n     *\n     * 示例 2:\n     * 输入: nums = [3,2,4], target = 6\n     * 输出: [1,2]\n     *\n     * 示例 3:\n     * 输入: nums = [3,3], target = 6\n     * 输出: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "fr": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Étant donné un tableau d'entiers nums et un entier target,\n     * trouver deux nombres tels qu'ils s'additionnent pour atteindre target et retourner leurs indices.\n     * Vous pouvez supposer que chaque entrée a exactement une solution,\n     * et vous ne pouvez pas utiliser le même élément deux fois.\n     * Vous pouvez retourner la réponse dans n'importe quel ordre.\n     *\n     * Exemple 1 :\n     * Entrée : nums = [2,7,11,15], target = 9\n     * Sortie : [0,1]\n     * Explication : Parce que nums[0] + nums[1] == 9, nous retournons [0, 1].\n     *\n     * Exemple 2 :\n     * Entrée : nums = [3,2,4], target = 6\n     * Sortie : [1,2]\n     *\n     * Exemple 3 :\n     * Entrée : nums = [3,3], target = 6\n     * Sortie : [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "de": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Gegeben ein Array von ganzen Zahlen nums und eine ganze Zahl target,\n     * finde zwei Zahlen, so dass sie zusammen target ergeben und gib ihre Indizes zurück.\n     * Du kannst annehmen, dass es genau eine Lösung für jede Eingabe gibt,\n     * und dass du dasselbe Element nicht zweimal verwenden darfst.\n     * Du kannst die Antwort in beliebiger Reihenfolge zurückgeben.\n     *\n     * Beispiel 1:\n     * Eingabe: nums = [2,7,11,15], target = 9\n     * Ausgabe: [0,1]\n     * Erklärung: Da nums[0] + nums[1] == 9, geben wir [0, 1] zurück.\n     *\n     * Beispiel 2:\n     * Eingabe: nums = [3,2,4], target = 6\n     * Ausgabe: [1,2]\n     *\n     * Beispiel 3:\n     * Eingabe: nums = [3,3], target = 6\n     * Ausgabe: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "ha": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * An ba da wani jerin lambobi nums da kuma wani lamba target,\n     * nemo lambobi biyu da za su haɗu su zama target kuma a mayar da alamunsu.\n     * Za ka iya ɗauka cewa kowanne shigarwa zai yi daidai da mafita guda ɗaya,\n     * kuma ba za ka iya amfani da abu guda sau biyu ba.\n     * Za ka iya mayar da amsar a kowane tsari.\n     *\n     * Misali na 1:\n     * Shigarwa: nums = [2,7,11,15], target = 9\n     * Fitarwa: [0,1]\n     * Bayani: Domin nums[0] + nums[1] == 9, mun mayar da [0, 1].\n     *\n     * Misali na 2:\n     * Shigarwa: nums = [3,2,4], target = 6\n     * Fitarwa: [1,2]\n     *\n     * Misali na 3:\n     * Shigarwa: nums = [3,3], target = 6\n     * Fitarwa: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "hi": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * दिए गए पूर्णांकों के एक array nums और एक पूर्णांक target के लिए,\n     * दो संख्याएँ खोजें ताकि उनका योग target के बराबर हो और उनके सूचकांक लौटाएँ।\n     * आप मान सकते हैं कि प्रत्येक इनपुट में ठीक एक समाधान होगा,\n     * और आप एक ही तत्व का दो बार उपयोग नहीं कर सकते।\n     * आप उत्तर को किसी भी क्रम में लौटा सकते हैं।\n     *\n     * उदाहरण 1:\n     * इनपुट: nums = [2,7,11,15], target = 9\n     * आउटपुट: [0,1]\n     * व्याख्या: क्योंकि nums[0] + nums[1] == 9, हम [0, 1] लौटाते हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: nums = [3,2,4], target = 6\n     * आउटपुट: [1,2]\n     *\n     * उदाहरण 3:\n     * इनपुट: nums = [3,3], target = 6\n     * आउटपुट: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "hu": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb nums és egy egész szám target,\n     * találj két számot úgy, hogy összegük a target legyen, és add vissza az indexeiket.\n     * Feltételezheted, hogy minden bemenetnek pontosan egy megoldása van,\n     * és nem használhatod ugyanazt az elemet kétszer.\n     * A választ bármilyen sorrendben visszaadhatod.\n     *\n     * 1. példa:\n     * Bemenet: nums = [2,7,11,15], target = 9\n     * Kimenet: [0,1]\n     * Magyarázat: Mivel nums[0] + nums[1] == 9, visszaadjuk [0, 1].\n     *\n     * 2. példa:\n     * Bemenet: nums = [3,2,4], target = 6\n     * Kimenet: [1,2]\n     *\n     * 3. példa:\n     * Bemenet: nums = [3,3], target = 6\n     * Kimenet: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) "
    },
    "prompt_bertscore": {
      "sq": "0.9271431707579272",
      "hy": "0.980631352914907",
      "bn": "0.9861669830039683",
      "bg": "0.9903916525781994",
      "zh": "0.9871563609319031",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.8944150415051897",
      "hi": "0.9639317022597799",
      "hu": "0.9879520742383289"
    },
    "canonical_solution": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }",
    "instruction": {
      "en": "Write a Java function `public int[] twoSum(int[] nums, int target)` to solve the following problem:\nGiven an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "sq": "Shkruani një funksion Java `public int[] twoSum(int[] nums, int target)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg të numrave të plotë nums dhe një numër të plotë target,\ngjeni dy numra të tillë që ata të shtohen deri te target dhe ktheni indeksat e tyre.\nMund të supozoni se çdo hyrje do të ketë saktësisht një zgjidhje,\ndhe nuk mund të përdorni të njëjtin element dy herë.\nMund ta ktheni përgjigjen në çdo renditje.\n\nShembulli 1:\nHyrja: nums = [2,7,11,15], target = 9\nDalja: [0,1]\nShpjegimi: Sepse nums[0] + nums[1] == 9, ne kthejmë [0, 1].\n\nShembulli 2:\nHyrja: nums = [3,2,4], target = 6\nDalja: [1,2]\n\nShembulli 3:\nHyrja: nums = [3,3], target = 6\nDalja: [0,1]",
      "hy": "Գրեք Java ֆունկցիա `public int[] twoSum(int[] nums, int target)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի զանգված nums և ամբողջ թիվ target,\nգտեք երկու թիվ, այնպես, որ նրանց գումարը լինի target և վերադարձրեք նրանց ինդեքսները:\nԿարող եք ենթադրել, որ յուրաքանչյուր մուտք կունենա ճիշտ մեկ լուծում,\nև չեք կարող օգտագործել նույն տարրը երկու անգամ:\nԿարող եք պատասխանը վերադարձնել ցանկացած կարգով:\n\nՕրինակ 1:\nՄուտքագրում: nums = [2,7,11,15], target = 9\nԵլք: [0,1]\nԲացատրություն: Քանի որ nums[0] + nums[1] == 9, մենք վերադարձնում ենք [0, 1]:\n\nՕրինակ 2:\nՄուտքագրում: nums = [3,2,4], target = 6\nԵլք: [1,2]\n\nՕրինակ 3:\nՄուտքագրում: nums = [3,3], target = 6\nԵլք: [0,1]",
      "bn": "একটি জাভা ফাংশন `public int[] twoSum(int[] nums, int target)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে `nums` এবং একটি পূর্ণসংখ্যা `target` দেওয়া আছে,\nদুটি সংখ্যা খুঁজুন যেগুলি যোগ করলে `target` হয় এবং তাদের সূচকগুলি ফেরত দিন।\nআপনি ধরে নিতে পারেন যে প্রতিটি ইনপুটের ঠিক একটি সমাধান থাকবে,\nএবং আপনি একই উপাদান দুবার ব্যবহার করতে পারবেন না।\nআপনি যেকোনো ক্রমে উত্তরটি ফেরত দিতে পারেন।\n\nউদাহরণ ১:\nইনপুট: nums = [2,7,11,15], target = 9\nআউটপুট: [0,1]\nব্যাখ্যা: কারণ nums[0] + nums[1] == 9, আমরা [0, 1] ফেরত দেই।\n\nউদাহরণ ২:\nইনপুট: nums = [3,2,4], target = 6\nআউটপুট: [1,2]\n\nউদাহরণ ৩:\nইনপুট: nums = [3,3], target = 6\nআউটপুট: [0,1]",
      "bg": "Напишете Java функция `public int[] twoSum(int[] nums, int target)`, за да решите следния проблем:\nДаден е масив от цели числа nums и цяло число target,\nнамерете две числа, така че тяхната сума да е равна на target и върнете техните индекси.\nМожете да приемете, че всеки вход ще има точно едно решение,\nи не можете да използвате един и същ елемент два пъти.\nМожете да върнете отговора в произволен ред.\n\nПример 1:\nВход: nums = [2,7,11,15], target = 9\nИзход: [0,1]\nОбяснение: Тъй като nums[0] + nums[1] == 9, връщаме [0, 1].\n\nПример 2:\nВход: nums = [3,2,4], target = 6\nИзход: [1,2]\n\nПример 3:\nВход: nums = [3,3], target = 6\nИзход: [0,1]",
      "zh": "编写一个 Java 函数 `public int[] twoSum(int[] nums, int target)` 来解决以下问题：\n给定一个整数数组 nums 和一个整数 target，\n找到两个数字使得它们的和等于 target，并返回它们的索引。\n你可以假设每个输入只会有一个解决方案，\n并且你不能使用同一个元素两次。\n你可以以任何顺序返回答案。\n\n示例 1：\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9，我们返回 [0, 1]。\n\n示例 2：\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n\n示例 3：\n输入：nums = [3,3], target = 6\n输出：[0,1]",
      "fr": "Écrire une fonction Java `public int[] twoSum(int[] nums, int target)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers nums et un entier target,  \ntrouver deux nombres tels qu'ils s'additionnent pour donner target et retourner leurs indices.  \nVous pouvez supposer que chaque entrée a exactement une solution,  \net vous ne pouvez pas utiliser le même élément deux fois.  \nVous pouvez retourner la réponse dans n'importe quel ordre.\n\nExemple 1 :  \nEntrée : nums = [2,7,11,15], target = 9  \nSortie : [0,1]  \nExplication : Parce que nums[0] + nums[1] == 9, nous retournons [0, 1].\n\nExemple 2 :  \nEntrée : nums = [3,2,4], target = 6  \nSortie : [1,2]\n\nExemple 3 :  \nEntrée : nums = [3,3], target = 6  \nSortie : [0,1]",
      "de": "Schreiben Sie eine Java-Funktion `public int[] twoSum(int[] nums, int target)`, um das folgende Problem zu lösen:\nGegeben ein Array von ganzen Zahlen nums und eine ganze Zahl target,\nfinden Sie zwei Zahlen, so dass sie zusammen target ergeben und geben Sie deren Indizes zurück.\nSie können davon ausgehen, dass jede Eingabe genau eine Lösung hat,\nund Sie dürfen dasselbe Element nicht zweimal verwenden.\nSie können die Antwort in beliebiger Reihenfolge zurückgeben.\n\nBeispiel 1:\nEingabe: nums = [2,7,11,15], target = 9\nAusgabe: [0,1]\nErläuterung: Da nums[0] + nums[1] == 9, geben wir [0, 1] zurück.\n\nBeispiel 2:\nEingabe: nums = [3,2,4], target = 6\nAusgabe: [1,2]\n\nBeispiel 3:\nEingabe: nums = [3,3], target = 6\nAusgabe: [0,1]",
      "ha": "Rubuta aikin Java `public int[] twoSum(int[] nums, int target)` don warware matsalar mai zuwa:  \nAn ba da jerin lambobin integers nums da integer target,  \nnemo lambobi biyu da za su hade su zama target kuma dawo da alamun su.  \nZa ka iya ɗauka cewa kowanne shigarwa zai sami madaidaicin mafita guda ɗaya,  \nkuma ba za ka iya amfani da abu ɗaya sau biyu ba.  \nZa ka iya dawo da amsar a kowanne tsari.  \n\nMisali 1:  \nShigarwa: nums = [2,7,11,15], target = 9  \nFitarwa: [0,1]  \nBayani: Saboda nums[0] + nums[1] == 9, muna dawo da [0, 1].  \n\nMisali 2:  \nShigarwa: nums = [3,2,4], target = 6  \nFitarwa: [1,2]  \n\nMisali 3:  \nShigarwa: nums = [3,3], target = 6  \nFitarwa: [0,1]",
      "hi": "Java फ़ंक्शन `public int[] twoSum(int[] nums, int target)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array nums और एक पूर्णांक target के लिए,\nऐसे दो संख्याएँ खोजें जिनका योग target के बराबर हो और उनके सूचकांक लौटाएँ।\nआप मान सकते हैं कि प्रत्येक इनपुट के लिए ठीक एक समाधान होगा,\nऔर आप एक ही तत्व का दो बार उपयोग नहीं कर सकते।\nआप उत्तर को किसी भी क्रम में लौटा सकते हैं।\n\nउदाहरण 1:\nइनपुट: nums = [2,7,11,15], target = 9\nआउटपुट: [0,1]\nव्याख्या: क्योंकि nums[0] + nums[1] == 9, हम [0, 1] लौटाते हैं।\n\nउदाहरण 2:\nइनपुट: nums = [3,2,4], target = 6\nआउटपुट: [1,2]\n\nउदाहरण 3:\nइनपुट: nums = [3,3], target = 6\nआउटपुट: [0,1]",
      "hu": "Írj egy Java függvényt `public int[] twoSum(int[] nums, int target)` a következő probléma megoldására:\nAdott egy egész számokat tartalmazó tömb, nums és egy egész szám, target,\ntalálj két számot úgy, hogy összegük target legyen, és add vissza az indexeiket.\nFeltételezheted, hogy minden bemenetnek pontosan egy megoldása van,\nés nem használhatod ugyanazt az elemet kétszer.\nA választ bármilyen sorrendben visszaadhatod.\n\n1. példa:\nBemenet: nums = [2,7,11,15], target = 9\nKimenet: [0,1]\nMagyarázat: Mivel nums[0] + nums[1] == 9, visszaadjuk [0, 1].\n\n2. példa:\nBemenet: nums = [3,2,4], target = 6\nKimenet: [1,2]\n\n3. példa:\nBemenet: nums = [3,3], target = 6\nKimenet: [0,1]"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9904017827276321",
      "bn": "0.975746038693354",
      "bg": "0.9883978008133711",
      "zh": "0.9868981414365577",
      "fr": "0.9968946126229006",
      "de": "0.999999801369619",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.9649780871070717"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "twoSum",
    "signature": "public int[] twoSum(int[] nums, int target)",
    "docstring": {
      "en": "Given an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "sq": "Duke pasur një varg numrash të plotë nums dhe një numër të plotë target, gjeni dy numra të tillë që ata të shtohen deri në target dhe ktheni indeksat e tyre. Ju mund të supozoni se secili input do të ketë saktësisht një zgjidhje, dhe nuk mund të përdorni të njëjtin element dy herë. Ju mund ta ktheni përgjigjen në çdo renditje.\n\nShembulli 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nShpjegim: Sepse nums[0] + nums[1] == 9, ne kthejmë [0, 1].\n\nShembulli 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nShembulli 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "hy": "Տրված է ամբողջ թվերի զանգված nums և ամբողջ թիվ target, \nգտեք երկու թիվ, որոնք գումարվում են՝ կազմելով target և վերադարձեք դրանց ինդեքսները։ \nԿարող եք ենթադրել, որ յուրաքանչյուր մուտք կունենա ճիշտ մեկ լուծում, \nև չեք կարող օգտագործել նույն տարրը երկու անգամ։ \nԿարող եք վերադարձնել պատասխանը ցանկացած կարգով։\n\nՕրինակ 1:\nՄուտքագրում: nums = [2,7,11,15], target = 9\nԵլք: [0,1]\nԲացատրություն: Քանի որ nums[0] + nums[1] == 9, մենք վերադարձնում ենք [0, 1]։\n\nՕրինակ 2:\nՄուտքագրում: nums = [3,2,4], target = 6\nԵլք: [1,2]\n\nՕրինակ 3:\nՄուտքագրում: nums = [3,3], target = 6\nԵլք: [0,1]",
      "bn": "একটি পূর্ণসংখ্যার অ্যারের nums এবং একটি পূর্ণসংখ্যা target দেওয়া আছে, \nএমন দুটি সংখ্যা খুঁজুন যেগুলি একত্রে যোগ করলে target হয় এবং তাদের সূচকগুলি ফেরত দিন। \nআপনি ধরে নিতে পারেন যে প্রতিটি ইনপুটের ঠিক একটি সমাধান থাকবে, \nএবং আপনি একই উপাদান দুবার ব্যবহার করতে পারবেন না। \nআপনি যেকোনো ক্রমে উত্তর ফেরত দিতে পারেন।\n\nউদাহরণ ১:\nইনপুট: nums = [2,7,11,15], target = 9\nআউটপুট: [0,1]\nব্যাখ্যা: কারণ nums[0] + nums[1] == 9, আমরা [0, 1] ফেরত দিই।\n\nউদাহরণ ২:\nইনপুট: nums = [3,2,4], target = 6\nআউটপুট: [1,2]\n\nউদাহরণ ৩:\nইনপুট: nums = [3,3], target = 6\nআউটপুট: [0,1]",
      "bg": "Даден е масив от цели числа nums и цяло число target, намерете две числа, така че тяхната сума да е равна на target и върнете техните индекси. Може да приемете, че всяко входно множество ще има точно едно решение и не може да използвате един и същ елемент два пъти. Можете да върнете отговора в произволен ред.\n\nПример 1:\nВход: nums = [2,7,11,15], target = 9\nИзход: [0,1]\nОбяснение: Тъй като nums[0] + nums[1] == 9, връщаме [0, 1].\n\nПример 2:\nВход: nums = [3,2,4], target = 6\nИзход: [1,2]\n\nПример 3:\nВход: nums = [3,3], target = 6\nИзход: [0,1]",
      "zh": "给定一个整数数组 nums 和一个整数 target，找到两个数，使得它们的和等于 target，并返回它们的索引。  \n你可以假设每个输入只会有一个解决方案，并且你不能重复使用相同的元素。  \n你可以以任何顺序返回答案。\n\n示例 1:  \n输入: nums = [2,7,11,15], target = 9  \n输出: [0,1]  \n解释: 因为 nums[0] + nums[1] == 9，我们返回 [0, 1]。\n\n示例 2:  \n输入: nums = [3,2,4], target = 6  \n输出: [1,2]\n\n示例 3:  \n输入: nums = [3,3], target = 6  \n输出: [0,1]",
      "fr": "Étant donné un tableau d'entiers nums et un entier target, trouvez deux nombres tels qu'ils s'additionnent pour donner target et retournez leurs indices. Vous pouvez supposer que chaque entrée aurait exactement une solution, et vous ne pouvez pas utiliser le même élément deux fois. Vous pouvez retourner la réponse dans n'importe quel ordre.\n\nExemple 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplication: Parce que nums[0] + nums[1] == 9, nous retournons [0, 1].\n\nExemple 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExemple 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "de": "Gegeben ein Array von ganzen Zahlen nums und eine ganze Zahl target, finde zwei Zahlen, so dass sie zusammen target ergeben und gib ihre Indizes zurück. Du kannst davon ausgehen, dass jede Eingabe genau eine Lösung hat, und du darfst dasselbe Element nicht zweimal verwenden. Du kannst die Antwort in beliebiger Reihenfolge zurückgeben.\n\nBeispiel 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nErklärung: Da nums[0] + nums[1] == 9, geben wir [0, 1] zurück.\n\nBeispiel 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nBeispiel 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "ha": "An ba da jerin lambobin cikakku nums da kuma wani cikakken lamba target, nemo lambobi biyu da za su haɗa su zama target kuma dawo da alamun su. Za ka iya ɗauka cewa kowace shigarwa za ta sami daidai mafita guda ɗaya, kuma ba za ka iya amfani da abu ɗaya sau biyu ba. Za ka iya dawo da amsar a kowane tsari.\n\nMisali na 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nBayani: Domin nums[0] + nums[1] == 9, mun dawo da [0, 1].\n\nMisali na 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nMisali na 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "hi": "दिए गए पूर्णांकों के एक array nums और एक पूर्णांक target के लिए, दो संख्याएँ खोजें जो target के लिए जोड़ती हैं और उनके सूचकांक लौटाएँ। आप मान सकते हैं कि प्रत्येक इनपुट में ठीक एक समाधान होगा, और आप एक ही तत्व का दो बार उपयोग नहीं कर सकते। आप उत्तर को किसी भी क्रम में लौटा सकते हैं।\n\nउदाहरण 1:\nइनपुट: nums = [2,7,11,15], target = 9\nआउटपुट: [0,1]\nव्याख्या: क्योंकि nums[0] + nums[1] == 9, हम [0, 1] लौटाते हैं।\n\nउदाहरण 2:\nइनपुट: nums = [3,2,4], target = 6\nआउटपुट: [1,2]\n\nउदाहरण 3:\nइनपुट: nums = [3,3], target = 6\nआउटपुट: [0,1]",
      "hu": "Adott egy egész számokat tartalmazó tömb, nums, és egy egész szám, target. Találj két számot, amelyek összege a target, és add vissza az indexeiket. Feltételezheted, hogy minden bemenetnek pontosan egy megoldása van, és nem használhatod ugyanazt az elemet kétszer. A választ bármilyen sorrendben visszaadhatod.\n\nPélda 1:\nBemenet: nums = [2,7,11,15], target = 9\nKimenet: [0,1]\nMagyarázat: Mivel nums[0] + nums[1] == 9, visszaadjuk [0, 1].\n\nPélda 2:\nBemenet: nums = [3,2,4], target = 6\nKimenet: [1,2]\n\nPélda 3:\nBemenet: nums = [3,3], target = 6\nKimenet: [0,1]"
    },
    "docstring_bertscore": {
      "sq": "0.996829064597159",
      "hy": "0.9915768800618345",
      "bn": "0.9734854263267959",
      "bg": "0.984229343636973",
      "zh": "0.9844303575825802",
      "fr": "1",
      "de": "1",
      "ha": "0.9641921066893165",
      "hi": "0.992490579814595",
      "hu": "0.9700979838086269"
    }
  },
  {
    "task_id": "Java/14",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "sq": "class Solution {\n    /**\n     * Kërko për vlerën e synuar në vargun e rrotulluar dhe të renditur.\n     * Nëse vlera e synuar ekziston, kthe indeksin e saj; përndryshe, kthe -1.\n     * Vargu nums është rrotulluar në një pikë të panjohur k, ku 0 <= k < nums.length.\n     * Kompleksiteti kohor i algoritmit duhet të jetë O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "hy": "class Solution {\n    /**\n     * Որոնել թիրախ արժեքը պտտված սորտավորված զանգվածում:\n     * Եթե թիրախ արժեքը գոյություն ունի, վերադարձնել դրա ինդեքսը; հակառակ դեպքում վերադարձնել -1:\n     * Զանգվածը nums պտտված է որոշ անհայտ պիվոտ k-ում, որտեղ 0 <= k < nums.length:\n     * Ալգորիթմի ժամանակային բարդությունը պետք է լինի O(log n):\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "bn": "class Solution {\n    /**\n     * ঘোরানো সাজানো অ্যারেতে লক্ষ্য মানটি সন্ধান করুন।\n     * যদি লক্ষ্য মানটি থাকে, তবে এর সূচক ফেরত দিন; অন্যথায়, -1 ফেরত দিন।\n     * অ্যারে nums একটি অজানা পিভট k তে ঘোরানো হয়, যেখানে 0 <= k < nums.length।\n     * অ্যালগরিদমের সময় জটিলতা অবশ্যই O(log n) হতে হবে।\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "bg": "class Solution {\n    /**\n     * Търсене на целевата стойност в завъртения сортиран масив.\n     * Ако целевата стойност съществува, върнете нейния индекс; в противен случай върнете -1.\n     * Масивът nums е завъртян около някакъв неизвестен индекс k, където 0 <= k < nums.length.\n     * Времевата сложност на алгоритъма трябва да бъде O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "zh": "class Solution {\n    /**\n     * 在旋转排序数组中搜索目标值。\n     * 如果目标值存在，返回其索引；否则，返回-1。\n     * 数组 nums 在某个未知的轴 k 处旋转，其中 0 <= k < nums.length。\n     * 算法的时间复杂度必须是 O(log n)。\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "fr": "class Solution {\n    /**\n     * Rechercher la valeur cible dans le tableau trié pivoté.\n     * Si la valeur cible existe, retourner son index ; sinon, retourner -1.\n     * Le tableau nums est pivoté à un pivot inconnu k, où 0 <= k < nums.length.\n     * La complexité temporelle de l'algorithme doit être O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "de": "class Solution {\n    /**\n     * Suche nach dem Zielwert im gedrehten sortierten Array.\n     * Wenn der Zielwert existiert, gib seinen Index zurück; andernfalls gib -1 zurück.\n     * Das Array nums ist an einem unbekannten Drehpunkt k gedreht, wobei 0 <= k < nums.length.\n     * Die Zeitkomplexität des Algorithmus muss O(log n) sein.\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "ha": "class Solution {\n    /**\n     * Nemo darajar da ake nema a cikin jujjuyawar jerin lambobi da aka tsara.\n     * Idan darajar da ake nema ta wanzu, dawo da ma'aunin ta; in ba haka ba, dawo da -1.\n     * Jerin lambobi nums an jujjuya shi a wani wuri da ba a sani ba k, inda 0 <= k < nums.length.\n     * Rikitarwa na lokaci na wannan dabarar dole ne ya zama O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "hi": "class Solution {\n    /**\n     * घुमाए गए क्रमबद्ध array में लक्ष्य मान खोजें।\n     * यदि लक्ष्य मान मौजूद है, तो उसका सूचकांक लौटाएं; अन्यथा, -1 लौटाएं।\n     * array nums को किसी अज्ञात धुरी k पर घुमाया गया है, जहाँ 0 <= k < nums.length।\n     * एल्गोरिदम की समय जटिलता O(log n) होनी चाहिए।\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "hu": "class Solution {\n    /**\n     * Keresse meg a célértéket a forgatott rendezett tömbben.\n     * Ha a célérték létezik, adja vissza az indexét; ellenkező esetben adja vissza -1-et.\n     * A nums tömb egy ismeretlen k csúcsnál van elforgatva, ahol 0 <= k < nums.length.\n     * Az algoritmus időbonyolultságának O(log n) kell lennie.\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) "
    },
    "prompt_bertscore": {
      "sq": "0.9875583888231177",
      "hy": "0.9918088803468833",
      "bn": "0.98515774203793",
      "bg": "0.9874896627112797",
      "zh": "0.9935232591655954",
      "fr": "0.9986119708973282",
      "de": "0.9986119708973282",
      "ha": "0.9896219598516892",
      "hi": "0.983460842692749",
      "hu": "0.9834006576872955"
    },
    "canonical_solution": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }",
    "instruction": {
      "en": "Write a Java function `public int search(int[] nums, int target)` to solve the following problem:\nSearch for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "sq": "Shkruani një funksion Java `public int search(int[] nums, int target)` për të zgjidhur problemin e mëposhtëm:\nKërkoni për vlerën e synuar në vargun e radhitur të rrotulluar.\nNëse vlera e synuar ekziston, ktheni indeksin e saj; përndryshe, ktheni -1.\nVargu nums është rrotulluar në një pikë të panjohur k, ku 0 <= k < nums.length.\nKompleksiteti kohor i algoritmit duhet të jetë O(log n).",
      "hy": "Գրեք Java ֆունկցիա `public int search(int[] nums, int target)` հետևյալ խնդիրը լուծելու համար:\nՈրոնել թիրախային արժեքը պտտված դասավորված զանգվածում:\nԵթե թիրախային արժեքը գոյություն ունի, վերադարձնել դրա ինդեքսը, հակառակ դեպքում՝ վերադարձնել -1:\nԶանգվածը nums պտտված է ինչ-որ անհայտ պիվոտում k, որտեղ 0 <= k < nums.length:\nԱլգորիթմի ժամանակային բարդությունը պետք է լինի O(log n):",
      "bn": "Java ফাংশন `public int search(int[] nums, int target)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nঘূর্ণিত সাজানো অ্যারেতে লক্ষ্য মানটি অনুসন্ধান করুন।\nযদি লক্ষ্য মানটি থাকে, তবে এর সূচক ফেরত দিন; অন্যথায়, -1 ফেরত দিন।\nঅ্যারে nums অজানা একটি পিভট k-তে ঘূর্ণিত হয়, যেখানে 0 <= k < nums.length।\nঅ্যালগরিদমের সময় জটিলতা অবশ্যই O(log n) হতে হবে। \n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "bg": "Напишете Java функция `public int search(int[] nums, int target)`, за да решите следния проблем:\nТърсене на целевата стойност в завъртян сортиран масив.\nАко целевата стойност съществува, върнете нейния индекс; в противен случай върнете -1.\nМасивът nums е завъртян на някакъв неизвестен индекс k, където 0 <= k < nums.length.\nВремевата сложност на алгоритъма трябва да бъде O(log n).",
      "zh": "编写一个 Java 函数 `public int search(int[] nums, int target)` 来解决以下问题：\n在旋转排序数组中搜索目标值。\n如果目标值存在，返回其索引；否则，返回 -1。\n数组 nums 在某个未知的枢轴 k 处旋转，其中 0 <= k < nums.length。\n算法的时间复杂度必须是 O(log n)。",
      "fr": "Écrire une fonction Java `public int search(int[] nums, int target)` pour résoudre le problème suivant :\nRechercher la valeur cible dans le tableau trié pivoté.\nSi la valeur cible existe, retourner son indice ; sinon, retourner -1.\nLe tableau nums est pivoté à un pivot inconnu k, où 0 <= k < nums.length.\nLa complexité temporelle de l'algorithme doit être O(log n).",
      "de": "Schreiben Sie eine Java-Funktion `public int search(int[] nums, int target)`, um das folgende Problem zu lösen:\nSuchen Sie den Zielwert im gedrehten sortierten Array.\nWenn der Zielwert existiert, geben Sie seinen Index zurück; andernfalls geben Sie -1 zurück.\nDas Array nums wird an einem unbekannten Drehpunkt k gedreht, wobei 0 <= k < nums.length.\nDie Zeitkomplexität des Algorithmus muss O(log n) sein.",
      "ha": "Rubuta aikin Java `public int search(int[] nums, int target)` don warware matsalar mai zuwa:\nNemo darajar target a cikin jujjuyawar jerin da aka tsara.\nIdan darajar target tana nan, dawo da index ɗinta; in ba haka ba, dawo da -1.\nJerin nums an jujjuya shi a wani wuri da ba a sani ba k, inda 0 <= k < nums.length.\nWannan algorithm ya kamata ya kasance da rikitarwa na lokaci O(log n).",
      "hi": "Java फ़ंक्शन `public int search(int[] nums, int target)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nघुमाए गए क्रमबद्ध सरणी में लक्ष्य मान खोजें।\nयदि लक्ष्य मान मौजूद है, तो उसका सूचकांक लौटाएं; अन्यथा, -1 लौटाएं।\nसरणी nums को किसी अज्ञात धुरी k पर घुमाया गया है, जहाँ 0 <= k < nums.length।\nएल्गोरिदम की समय जटिलता O(log n) होनी चाहिए।",
      "hu": "Írj egy Java függvényt `public int search(int[] nums, int target)` a következő probléma megoldására:\nKeresd meg a célértéket az elforgatott rendezett tömbben.\nHa a célérték létezik, add vissza az indexét; ellenkező esetben add vissza -1-et.\nA nums tömb egy ismeretlen k forgáspontnál van elforgatva, ahol 0 <= k < nums.length.\nAz algoritmus időbeli összetettsége O(log n) kell, hogy legyen.\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1"
    },
    "instruction_bertscore": {
      "sq": "0.8532959704360144",
      "hy": "0.8546186501433257",
      "bn": "0.9919733463023802",
      "bg": "0.8514572489987744",
      "zh": "0.8572844684871949",
      "fr": "0.8620790086246151",
      "de": "0.860297095476351",
      "ha": "0.8337086313014019",
      "hi": "0.8501200692736475",
      "hu": "0.9852721531374061"
    },
    "level": "middle",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "search",
    "signature": "public int search(int[] nums, int target)",
    "docstring": {
      "en": "Search for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "sq": "Kërkoni për vlerën e synuar në vargun e radhitur të rrotulluar.  \nNëse vlera e synuar ekziston, kthe indeksin e saj; përndryshe, kthe -1.  \nVargu nums është rrotulluar në një pikë të panjohur k, ku 0 <= k < nums.length.  \nKompleksiteti kohor i algoritmit duhet të jetë O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "hy": "Փնտրեք թիրախ արժեքը պտտված դասավորված զանգվածում։  \nԵթե թիրախ արժեքը գոյություն ունի, վերադարձնել դրա ինդեքսը; հակառակ դեպքում, վերադարձնել -1։  \nԶանգվածը `nums` պտտված է որոշ անհայտ պիվոտ `k`-ով, որտեղ 0 <= k < `nums.length`։  \nԱլգորիթմի ժամանակային բարդությունը պետք է լինի O(log n)։\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "bn": "ঘূর্ণিত সর্ট করা অ্যারেতে লক্ষ্য মানটি সন্ধান করুন।  \nযদি লক্ষ্য মানটি বিদ্যমান থাকে, তাহলে এর সূচক ফেরত দিন; অন্যথায়, -1 ফেরত দিন।  \nঅ্যারেটি nums অজানা কোনো পিভট k তে ঘূর্ণিত হয়, যেখানে 0 <= k < nums.length।  \nঅ্যালগরিদমের সময় জটিলতা অবশ্যই O(log n) হতে হবে।\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "bg": "Търсене на целевата стойност в завъртян сортиран масив.  \nАко целевата стойност съществува, върнете нейния индекс; в противен случай върнете -1.  \nМасивът nums е завъртян около някакъв неизвестен връх k, където 0 <= k < nums.length.  \nВремевата сложност на алгоритъма трябва да бъде O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "zh": "在旋转排序数组中搜索目标值。  \n如果目标值存在，返回其索引；否则，返回 -1。  \n数组 nums 在某个未知的枢轴 k 处旋转，其中 0 <= k < nums.length。  \n算法的时间复杂度必须是 O(log n)。\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "fr": "Rechercher la valeur cible dans le tableau trié pivoté.  \nSi la valeur cible existe, retourner son indice ; sinon, retourner -1.  \nLe tableau nums est pivoté à un certain pivot inconnu k, où 0 <= k < nums.length.  \nLa complexité temporelle de l'algorithme doit être O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "de": "Suche nach dem Zielwert im gedrehten sortierten Array.\nWenn der Zielwert existiert, gib seinen Index zurück; andernfalls gib -1 zurück.\nDas Array nums wird an einem unbekannten Drehpunkt k gedreht, wobei 0 <= k < nums.length.\nDie Zeitkomplexität des Algorithmus muss O(log n) sein.\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "ha": "Nemo darajar da ake nufi a cikin jujjuyawar jerin da aka tsara.\nIdan darajar da ake nufi tana nan, dawo da ma'aunin ta; in ba haka ba, dawo da -1.\nAn jujjuya jerin nums a wani wuri da ba a sani ba k, inda 0 <= k < nums.length.\nWajibi ne rikitarwa na lokaci na algorithm ya zama O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "hi": "घुमाए गए क्रमबद्ध array में लक्षित मान की खोज करें।  \nयदि लक्षित मान मौजूद है, तो उसका सूचकांक लौटाएं; अन्यथा, -1 लौटाएं।  \narray nums को किसी अज्ञात धुरी k पर घुमाया गया है, जहाँ 0 <= k < nums.length।  \nएल्गोरिदम की समय जटिलता O(log n) होनी चाहिए।\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "hu": "Keresd meg a célértéket az elforgatott rendezett tömbben.\nHa a célérték létezik, add vissza az indexét; ellenkező esetben add vissza -1-et.\nA nums tömb egy ismeretlen k csomópontnál van elforgatva, ahol 0 <= k < nums.length.\nAz algoritmus időbonyolultságának O(log n) kell lennie.\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.9899552616310657",
      "hy": "0.9520204342002607",
      "bn": "0.9779164728669222",
      "bg": "0.9906621871571689",
      "zh": "0.9928268610496871",
      "fr": "1",
      "de": "0.9982969431130069",
      "ha": "0.9838128157279428",
      "hi": "0.9858217634017297",
      "hu": "0.9763254435148327"
    }
  },
  {
    "task_id": "Java/15",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "sq": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg të plotë arr, llogaritni mesataren e elementeve të mbetura pasi të hiqni 5% më të vogla dhe 5% më të mëdha të elementeve.\n     * Kthejeni mesataren me një gabim brenda 10^-5.\n     *\n     * Shembull 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Shembull 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Shembull 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Shembull 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Shembull 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "hy": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված arr, հաշվարկել մնացած տարրերի միջինը՝ հեռացնելուց հետո ամենափոքր 5%-ը և ամենամեծ 5%-ը:\n     * Վերադարձնել միջինը՝ սխալով 10^-5-ի սահմաններում:\n     *\n     * Օրինակ 1:\n     * Մուտք: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Ելք: 2.00000\n     *\n     * Օրինակ 2:\n     * Մուտք: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Ելք: 4.00000\n     *\n     * Օրինակ 3:\n     * Մուտք: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Ելք: 4.77778\n     *\n     * Օրինակ 4:\n     * Մուտք: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Ելք: 5.27778\n     *\n     * Օրինակ 5:\n     * Մուտք: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Ելք: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "bn": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে arr দেওয়া আছে, উপাদানগুলির ক্ষুদ্রতম 5% এবং বৃহত্তম 5% অপসারণের পরে অবশিষ্ট উপাদানগুলির গড় গণনা করুন।\n     * 10^-5 এর মধ্যে ত্রুটি সহ গড় ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * আউটপুট: 2.00000\n     *\n     * উদাহরণ 2:\n     * ইনপুট: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * আউটপুট: 4.00000\n     *\n     * উদাহরণ 3:\n     * ইনপুট: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * আউটপুট: 4.77778\n     *\n     * উদাহরণ 4:\n     * ইনপুট: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * আউটপুট: 5.27778\n     *\n     * উদাহরণ 5:\n     * ইনপুট: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * আউটপুট: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "bg": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Даден е масив от цели числа arr, изчислете средната стойност на останалите елементи след премахване на най-малките 5% и най-големите 5% от елементите.\n     * Върнете средната стойност с грешка в рамките на 10^-5.\n     *\n     * Пример 1:\n     * Вход: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Изход: 2.00000\n     *\n     * Пример 2:\n     * Вход: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Изход: 4.00000\n     *\n     * Пример 3:\n     * Вход: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Изход: 4.77778\n     *\n     * Пример 4:\n     * Вход: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Изход: 5.27778\n     *\n     * Пример 5:\n     * Вход: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Изход: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "zh": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个整数数组 arr，计算去掉最小的 5% 和最大的 5% 元素后的剩余元素的平均值。\n     * 返回误差在 10^-5 以内的平均值。\n     *\n     * 示例 1:\n     * 输入: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * 输出: 2.00000\n     *\n     * 示例 2:\n     * 输入: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * 输出: 4.00000\n     *\n     * 示例 3:\n     * 输入: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * 输出: 4.77778\n     *\n     * 示例 4:\n     * 输入: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * 输出: 5.27778\n     *\n     * 示例 5:\n     * 输入: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * 输出: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "fr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un tableau d'entiers arr, calculez la moyenne des éléments restants après avoir retiré les 5% les plus petits et les 5% les plus grands des éléments.\n     * Retournez la moyenne avec une erreur inférieure à 10^-5.\n     *\n     * Exemple 1 :\n     * Entrée : arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Sortie : 2.00000\n     *\n     * Exemple 2 :\n     * Entrée : arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Sortie : 4.00000\n     *\n     * Exemple 3 :\n     * Entrée : arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Sortie : 4.77778\n     *\n     * Exemple 4 :\n     * Entrée : arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Sortie : 5.27778\n     *\n     * Exemple 5 :\n     * Entrée : arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Sortie : 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "de": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein Integer-Array arr, berechne den Mittelwert der verbleibenden Elemente, nachdem die kleinsten 5% und die größten 5% der Elemente entfernt wurden.\n     * Gib den Mittelwert mit einem Fehler innerhalb von 10^-5 zurück.\n     *\n     * Beispiel 1:\n     * Eingabe: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Ausgabe: 2.00000\n     *\n     * Beispiel 2:\n     * Eingabe: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Ausgabe: 4.00000\n     *\n     * Beispiel 3:\n     * Eingabe: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Ausgabe: 4.77778\n     *\n     * Beispiel 4:\n     * Eingabe: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Ausgabe: 5.27778\n     *\n     * Beispiel 5:\n     * Eingabe: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Ausgabe: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "ha": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani jerin lambobi na integer arr, a lissafta matsakaicin sauran abubuwan bayan cire kashi 5% mafi ƙanƙanta da mafi girma na abubuwan.\n     * Mayar da matsakaicin tare da kuskure cikin 10^-5.\n     *\n     * Misali 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Misali 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Misali 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Misali 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Misali 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "hi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए पूर्णांक सरणी arr के लिए, सबसे छोटे 5% और सबसे बड़े 5% तत्वों को हटाने के बाद शेष तत्वों का औसत गणना करें।\n     * 10^-5 की त्रुटि के भीतर औसत लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * आउटपुट: 2.00000\n     *\n     * उदाहरण 2:\n     * इनपुट: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * आउटपुट: 4.00000\n     *\n     * उदाहरण 3:\n     * इनपुट: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * आउटपुट: 4.77778\n     *\n     * उदाहरण 4:\n     * इनपुट: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * आउटपुट: 5.27778\n     *\n     * उदाहरण 5:\n     * इनपुट: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * आउटपुट: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "hu": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb, arr, számítsuk ki a megmaradt elemek átlagát, miután eltávolítottuk a legkisebb 5%-ot és a legnagyobb 5%-ot az elemek közül.\n     * Az átlagot 10^-5 hibahatáron belül adjuk vissza.\n     *\n     * Példa 1:\n     * Bemenet: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Kimenet: 2.00000\n     *\n     * Példa 2:\n     * Bemenet: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Kimenet: 4.00000\n     *\n     * Példa 3:\n     * Bemenet: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Kimenet: 4.77778\n     *\n     * Példa 4:\n     * Bemenet: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Kimenet: 5.27778\n     *\n     * Példa 5:\n     * Bemenet: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Kimenet: 5.29167\n     */\n  public double trimMean(int[] arr) "
    },
    "prompt_bertscore": {
      "sq": "0.944626815526999",
      "hy": "0.9431873411556392",
      "bn": "0.9891845757526503",
      "bg": "0.9595705736137778",
      "zh": "0.9580681334116299",
      "fr": "0.9585897367922276",
      "de": "0.9477246549496192",
      "ha": "0.9295175983328182",
      "hi": "0.94327771797901",
      "hu": "0.937765923535673"
    },
    "canonical_solution": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }",
    "instruction": {
      "en": "Write a Java function `public double trimMean(int[] arr)` to solve the following problem:\nGiven an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "sq": "Shkruani një funksion në Java `public double trimMean(int[] arr)` për të zgjidhur problemin e mëposhtëm: \nDuke pasur një varg të plotë arr, llogaritni mesataren e elementeve të mbetura pasi të keni hequr 5% të elementeve më të vegjël dhe 5% të elementeve më të mëdhenj. \nKtheni mesataren me një gabim brenda 10^-5.\n\nShembulli 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nShembulli 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nShembulli 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nShembulli 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nShembulli 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "hy": "Գրեք Java ֆունկցիա `public double trimMean(int[] arr)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի զանգված arr, հաշվարկել մնացած տարրերի միջինը՝ հեռացնելուց հետո ամենափոքր 5% և ամենամեծ 5% տարրերը:\nՎերադարձնել միջինը՝ սխալով 10^-5-ի սահմաններում:\n\nՕրինակ 1:\nՄուտք: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nԵլք: 2.00000\n\nՕրինակ 2:\nՄուտք: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nԵլք: 4.00000\n\nՕրինակ 3:\nՄուտք: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nԵլք: 4.77778\n\nՕրինակ 4:\nՄուտք: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nԵլք: 5.27778\n\nՕրինակ 5:\nՄուտք: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nԵլք: 5.29167",
      "bn": "একটি জাভা ফাংশন `public double trimMean(int[] arr)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে arr দেওয়া হয়েছে, সবচেয়ে ছোট 5% এবং সবচেয়ে বড় 5% উপাদানগুলি সরানোর পরে অবশিষ্ট উপাদানগুলির গড় গণনা করুন।\n10^-5 এর মধ্যে একটি ত্রুটির সাথে গড় ফেরত দিন।\n\nউদাহরণ 1:\nইনপুট: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nআউটপুট: 2.00000\n\nউদাহরণ 2:\nইনপুট: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nআউটপুট: 4.00000\n\nউদাহরণ 3:\nইনপুট: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nআউটপুট: 4.77778\n\nউদাহরণ 4:\nইনপুট: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nআউটপুট: 5.27778\n\nউদাহরণ 5:\nইনপুট: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nআউটপুট: 5.29167",
      "bg": "Напишете Java функция `public double trimMean(int[] arr)`, за да решите следния проблем:\nДаден е масив от цели числа arr, изчислете средната стойност на останалите елементи след премахване на най-малките 5% и най-големите 5% от елементите.\nВърнете средната стойност с грешка в рамките на 10^-5.\n\nПример 1:\nВход: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nИзход: 2.00000\n\nПример 2:\nВход: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nИзход: 4.00000\n\nПример 3:\nВход: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nИзход: 4.77778\n\nПример 4:\nВход: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nИзход: 5.27778\n\nПример 5:\nВход: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nИзход: 5.29167",
      "zh": "编写一个 Java 函数 `public double trimMean(int[] arr)` 来解决以下问题：  \n给定一个整数数组 arr，计算去掉最小 5% 和最大 5% 元素后的剩余元素的平均值。  \n返回误差在 10^-5 以内的平均值。\n\n示例 1：  \n输入: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]  \n输出: 2.00000\n\n示例 2：  \n输入: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]  \n输出: 4.00000\n\n示例 3：  \n输入: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]  \n输出: 4.77778\n\n示例 4：  \n输入: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]  \n输出: 5.27778\n\n示例 5：  \n输入: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]  \n输出: 5.29167",
      "fr": "Écrire une fonction Java `public double trimMean(int[] arr)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers arr, calculer la moyenne des éléments restants après avoir supprimé les 5% les plus petits et les 5% les plus grands des éléments.  \nRetourner la moyenne avec une erreur inférieure à 10^-5.\n\nExemple 1 :  \nEntrée : arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]  \nSortie : 2.00000\n\nExemple 2 :  \nEntrée : arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]  \nSortie : 4.00000\n\nExemple 3 :  \nEntrée : arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]  \nSortie : 4.77778\n\nExemple 4 :  \nEntrée : arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]  \nSortie : 5.27778\n\nExemple 5 :  \nEntrée : arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]  \nSortie : 5.29167",
      "de": "Schreiben Sie eine Java-Funktion `public double trimMean(int[] arr)`, um das folgende Problem zu lösen:\nGegeben ein ganzzahliges Array arr, berechnen Sie den Mittelwert der verbleibenden Elemente, nachdem die kleinsten 5% und die größten 5% der Elemente entfernt wurden.\nGeben Sie den Mittelwert mit einem Fehler innerhalb von 10^-5 zurück.\n\nBeispiel 1:\nEingabe: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nAusgabe: 2.00000\n\nBeispiel 2:\nEingabe: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nAusgabe: 4.00000\n\nBeispiel 3:\nEingabe: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nAusgabe: 4.77778\n\nBeispiel 4:\nEingabe: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nAusgabe: 5.27778\n\nBeispiel 5:\nEingabe: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nAusgabe: 5.29167",
      "ha": "Rubuta wani aikin Java `public double trimMean(int[] arr)` don warware matsalar mai zuwa:  \nAn ba da jerin lambobi na cikakken lamba arr, a lissafta matsakaicin sauran abubuwan bayan cire ƙananan kashi 5% da manyan kashi 5% na abubuwan.  \nMayar da matsakaicin tare da kuskure a cikin 10^-5.\n\nMisali na 1:  \nShigarwa: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]  \nFitarwa: 2.00000\n\nMisali na 2:  \nShigarwa: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]  \nFitarwa: 4.00000\n\nMisali na 3:  \nShigarwa: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]  \nFitarwa: 4.77778\n\nMisali na 4:  \nShigarwa: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]  \nFitarwa: 5.27778\n\nMisali na 5:  \nShigarwa: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]  \nFitarwa: 5.29167",
      "hi": "Java फ़ंक्शन `public double trimMean(int[] arr)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक array arr के लिए, सबसे छोटे 5% और सबसे बड़े 5% तत्वों को हटाने के बाद शेष तत्वों का औसत गणना करें।\n10^-5 की त्रुटि के भीतर औसत लौटाएं।\n\nउदाहरण 1:\nइनपुट: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nआउटपुट: 2.00000\n\nउदाहरण 2:\nइनपुट: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nआउटपुट: 4.00000\n\nउदाहरण 3:\nइनपुट: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nआउटपुट: 4.77778\n\nउदाहरण 4:\nइनपुट: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nआउटपुट: 5.27778\n\nउदाहरण 5:\nइनपुट: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nआउटपुट: 5.29167",
      "hu": "Írj egy Java függvényt `public double trimMean(int[] arr)` a következő probléma megoldására:\nAdott egy egész számokat tartalmazó tömb, `arr`, számítsd ki a megmaradt elemek átlagát, miután eltávolítottad a legkisebb 5% és a legnagyobb 5% elemeket.\nAdd vissza az átlagot 10^-5 hibahatáron belül.\n\n1. példa:\nBemenet: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nKimenet: 2.00000\n\n2. példa:\nBemenet: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nKimenet: 4.00000\n\n3. példa:\nBemenet: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nKimenet: 4.77778\n\n4. példa:\nBemenet: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nKimenet: 5.27778\n\n5. példa:\nBemenet: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nKimenet: 5.29167"
    },
    "instruction_bertscore": {
      "sq": "0.9555018288886592",
      "hy": "0.9742024820023318",
      "bn": "0.9896404324771254",
      "bg": "0.9576931192522361",
      "zh": "0.9873784296979001",
      "fr": "0.9568854881229482",
      "de": "0.9896404324771254",
      "ha": "0.975484442481531",
      "hi": "0.9674639463257232",
      "hu": "0.9385225066570348"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "trimMean",
    "signature": "public double trimMean(int[] arr)",
    "docstring": {
      "en": "Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "sq": "Dhënë një varg i plotë arr, llogarit mesataren e elementeve të mbetura pasi të keni hequr 5% më të vogla dhe 5% më të mëdha të elementeve. Kthe mesataren me një gabim brenda 10^-5.\n\nShembull 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nShembull 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nShembull 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nShembull 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nShembull 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "hy": "Տրված է ամբողջ թվերի զանգված `arr`, հաշվարկել մնացած տարրերի միջինը՝ հեռացնելով ամենափոքր 5% և ամենամեծ 5% տարրերը:\nՎերադարձնել միջինը՝ սխալը 10^-5-ի սահմաններում:\n\nՕրինակ 1:\nՄուտքագրում: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nԵլք: 2.00000\n\nՕրինակ 2:\nՄուտքագրում: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nԵլք: 4.00000\n\nՕրինակ 3:\nՄուտքագրում: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nԵլք: 4.77778\n\nՕրինակ 4:\nՄուտքագրում: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nԵլք: 5.27778\n\nՕրինակ 5:\nՄուտքագրում: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nԵլք: 5.29167",
      "bn": "প্রদত্ত একটি পূর্ণসংখ্যার অ্যারে arr, অ্যারের ক্ষুদ্রতম ৫% এবং বৃহত্তম ৫% উপাদানগুলি সরানোর পর অবশিষ্ট উপাদানগুলির গড় গণনা করুন। 10^-5 এর মধ্যে ত্রুটি সহ গড়টি ফেরত দিন।\n\nউদাহরণ ১:\nইনপুট: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nআউটপুট: 2.00000\n\nউদাহরণ ২:\nইনপুট: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nআউটপুট: 4.00000\n\nউদাহরণ ৩:\nইনপুট: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nআউটপুট: 4.77778\n\nউদাহরণ ৪:\nইনপুট: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nআউটপুট: 5.27778\n\nউদাহরণ ৫:\nইনপুট: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nআউটপুট: 5.29167",
      "bg": "Даден е масив от цели числа arr, изчислете средното аритметично на останалите елементи след премахване на най-малките 5% и най-големите 5% от елементите. Върнете средното аритметично с грешка в рамките на 10^-5.\n\nПример 1:\nВход: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nИзход: 2.00000\n\nПример 2:\nВход: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nИзход: 4.00000\n\nПример 3:\nВход: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nИзход: 4.77778\n\nПример 4:\nВход: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nИзход: 5.27778\n\nПример 5:\nВход: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nИзход: 5.29167",
      "zh": "给定一个整数数组 `arr`，计算在去掉最小的 5% 和最大的 5% 元素后的剩余元素的平均值。返回的平均值误差需在 10^-5 以内。\n\n示例 1:\n输入: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n输出: 2.00000\n\n示例 2:\n输入: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n输出: 4.00000\n\n示例 3:\n输入: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n输出: 4.77778\n\n示例 4:\n输入: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n输出: 5.27778\n\n示例 5:\n输入: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n输出: 5.29167",
      "fr": "Étant donné un tableau d'entiers `arr`, calculez la moyenne des éléments restants après avoir supprimé les 5% les plus petits et les 5% les plus grands des éléments.  \nRetournez la moyenne avec une erreur inférieure à 10^-5.\n\nExemple 1 :  \nEntrée : `arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]`  \nSortie : `2.00000`\n\nExemple 2 :  \nEntrée : `arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]`  \nSortie : `4.00000`\n\nExemple 3 :  \nEntrée : `arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]`  \nSortie : `4.77778`\n\nExemple 4 :  \nEntrée : `arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]`  \nSortie : `5.27778`\n\nExemple 5 :  \nEntrée : `arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]`  \nSortie : `5.29167`",
      "de": "Gegeben ein Integer-Array arr, berechne den Mittelwert der verbleibenden Elemente, nachdem die kleinsten 5% und die größten 5% der Elemente entfernt wurden.\nGib den Mittelwert mit einem Fehler innerhalb von 10^-5 zurück.\n\nBeispiel 1:\nEingabe: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nAusgabe: 2.00000\n\nBeispiel 2:\nEingabe: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nAusgabe: 4.00000\n\nBeispiel 3:\nEingabe: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nAusgabe: 4.77778\n\nBeispiel 4:\nEingabe: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nAusgabe: 5.27778\n\nBeispiel 5:\nEingabe: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nAusgabe: 5.29167",
      "ha": "An ba da jerin lambobi na cikakken lamba `arr`, a lissafta matsakaicin sauran abubuwan bayan cire ƙananan kashi 5% da manyan kashi 5% na abubuwan.\n\nA mayar da matsakaicin tare da kuskure cikin 10^-5.\n\nMisali 1:\nShigar: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nFitarwa: 2.00000\n\nMisali 2:\nShigar: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nFitarwa: 4.00000\n\nMisali 3:\nShigar: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nFitarwa: 4.77778\n\nMisali 4:\nShigar: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nFitarwa: 5.27778\n\nMisali 5:\nShigar: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nFitarwa: 5.29167",
      "hi": "दिए गए पूर्णांक array arr के लिए, सबसे छोटे 5% और सबसे बड़े 5% तत्वों को हटाने के बाद शेष तत्वों का औसत गणना करें। 10^-5 की त्रुटि के भीतर औसत लौटाएं।\n\nउदाहरण 1:\nइनपुट: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nआउटपुट: 2.00000\n\nउदाहरण 2:\nइनपुट: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nआउटपुट: 4.00000\n\nउदाहरण 3:\nइनपुट: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nआउटपुट: 4.77778\n\nउदाहरण 4:\nइनपुट: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nआउटपुट: 5.27778\n\nउदाहरण 5:\nइनपुट: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nआउटपुट: 5.29167",
      "hu": "Adott egy egész számokat tartalmazó tömb, `arr`, számítsd ki a maradék elemek átlagát, miután eltávolítottad a legkisebb 5%-ot és a legnagyobb 5%-ot az elemek közül. \nAdd vissza az átlagot 10^-5 hibahatáron belül.\n\nPélda 1:\nBemenet: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nKimenet: 2.00000\n\nPélda 2:\nBemenet: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nKimenet: 4.00000\n\nPélda 3:\nBemenet: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nKimenet: 4.77778\n\nPélda 4:\nBemenet: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nKimenet: 5.27778\n\nPélda 5:\nBemenet: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nKimenet: 5.29167"
    },
    "docstring_bertscore": {
      "sq": "0.9854952150553083",
      "hy": "0.953251743932296",
      "bn": "0.9554793836556023",
      "bg": "0.9418658532306141",
      "zh": "0.9388059522107717",
      "fr": "0.9121946455420036",
      "de": "0.9892991854825075",
      "ha": "0.9532678329931598",
      "hi": "0.9859216744833902",
      "hu": "0.9379659443293751"
    }
  },
  {
    "task_id": "Java/16",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "sq": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Kontrolloni nëse është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me k.\n     *\n     * @param arr vargu hyrës i numrave të plotë\n     * @param k pjestuesi\n     * @return true nëse është e mundur, false përndryshe\n     *\n     * Shembull:\n     * Hyrja: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Dalja: true\n     * Shpjegim: Çiftet janë (1,9), (2,8), (3,7), (4,6), (5,10), dhe shuma e secilit çift është e pjestueshme me 5.\n     *\n     * Hyrja: arr = [1,2,3,4,5,6], k = 7\n     * Dalja: true\n     * Shpjegim: Çiftet janë (1,6), (2,5), (3,4), dhe shuma e secilit çift është e pjestueshme me 7.\n     *\n     * Hyrja: arr = [1,2,3,4,5,6], k = 10\n     * Dalja: false\n     * Shpjegim: Nuk është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "hy": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Ստուգել, արդյոք հնարավոր է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի k-ի վրա:\n     *\n     * @param arr մուտքային ամբողջ թվերի զանգվածը\n     * @param k բաժանարարը\n     * @return true եթե հնարավոր է, false հակառակ դեպքում\n     *\n     * Օրինակ:\n     * Մուտք: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Ելք: true\n     * Բացատրություն: Զույգերն են (1,9), (2,8), (3,7), (4,6), (5,10), և յուրաքանչյուր զույգի գումարը բաժանվում է 5-ի վրա:\n     *\n     * Մուտք: arr = [1,2,3,4,5,6], k = 7\n     * Ելք: true\n     * Բացատրություն: Զույգերն են (1,6), (2,5), (3,4), և յուրաքանչյուր զույգի գումարը բաժանվում է 7-ի վրա:\n     *\n     * Մուտք: arr = [1,2,3,4,5,6], k = 10\n     * Ելք: false\n     * Բացատրություն: Անհնար է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի 10-ի վրա:\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "bn": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * এটি পরীক্ষা করুন যে n/2 জোড়ায় অ্যারে ভাগ করা সম্ভব কিনা যাতে প্রতিটি জোড়ার যোগফল k দ্বারা বিভাজ্য হয়।\n     *\n     * @param arr ইনপুট পূর্ণসংখ্যার অ্যারে\n     * @param k বিভাজক\n     * @return সত্য যদি এটি সম্ভব হয়, অন্যথায় মিথ্যা\n     *\n     * উদাহরণ:\n     * ইনপুট: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * আউটপুট: true\n     * ব্যাখ্যা: জোড়াগুলি হল (1,9), (2,8), (3,7), (4,6), (5,10), এবং প্রতিটি জোড়ার যোগফল 5 দ্বারা বিভাজ্য।\n     *\n     * ইনপুট: arr = [1,2,3,4,5,6], k = 7\n     * আউটপুট: true\n     * ব্যাখ্যা: জোড়াগুলি হল (1,6), (2,5), (3,4), এবং প্রতিটি জোড়ার যোগফল 7 দ্বারা বিভাজ্য।\n     *\n     * ইনপুট: arr = [1,2,3,4,5,6], k = 10\n     * আউটপুট: false\n     * ব্যাখ্যা: প্রতিটি জোড়ার যোগফল 10 দ্বারা বিভাজ্য হয় এমনভাবে n/2 জোড়ায় অ্যারে ভাগ করা সম্ভব নয়।\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "bg": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Проверете дали е възможно да се раздели масива на n/2 двойки, така че сумата на всяка двойка да е делима на k.\n     *\n     * @param arr входният масив от цели числа\n     * @param k делителят\n     * @return true ако е възможно, false в противен случай\n     *\n     * Пример:\n     * Вход: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Изход: true\n     * Обяснение: Двойките са (1,9), (2,8), (3,7), (4,6), (5,10), и сумата на всяка двойка е делима на 5.\n     *\n     * Вход: arr = [1,2,3,4,5,6], k = 7\n     * Изход: true\n     * Обяснение: Двойките са (1,6), (2,5), (3,4), и сумата на всяка двойка е делима на 7.\n     *\n     * Вход: arr = [1,2,3,4,5,6], k = 10\n     * Изход: false\n     * Обяснение: Не е възможно да се раздели масива на n/2 двойки, така че сумата на всяка двойка да е делима на 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "zh": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * 检查是否可以将数组分成 n/2 对，使得每对的和都能被 k 整除。\n     *\n     * @param arr 输入的整数数组\n     * @param k 除数\n     * @return 如果可以则返回 true，否则返回 false\n     *\n     * 示例:\n     * 输入: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * 输出: true\n     * 解释: 配对为 (1,9), (2,8), (3,7), (4,6), (5,10)，每对的和都能被 5 整除。\n     *\n     * 输入: arr = [1,2,3,4,5,6], k = 7\n     * 输出: true\n     * 解释: 配对为 (1,6), (2,5), (3,4)，每对的和都能被 7 整除。\n     *\n     * 输入: arr = [1,2,3,4,5,6], k = 10\n     * 输出: false\n     * 解释: 不可能将数组分成 n/2 对，使得每对的和都能被 10 整除。\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "fr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Vérifier s'il est possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par k.\n     *\n     * @param arr le tableau d'entiers en entrée\n     * @param k le diviseur\n     * @return true si c'est possible, false sinon\n     *\n     * Exemple :\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explication : Les paires sont (1,9), (2,8), (3,7), (4,6), (5,10), et la somme de chaque paire est divisible par 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explication : Les paires sont (1,6), (2,5), (3,4), et la somme de chaque paire est divisible par 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explication : Il n'est pas possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "de": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Überprüfen, ob es möglich ist, das Array in n/2 Paare zu unterteilen, sodass die Summe jedes Paares durch k teilbar ist.\n     *\n     * @param arr das Eingabe-Integer-Array\n     * @param k der Divisor\n     * @return true, wenn es möglich ist, false andernfalls\n     *\n     * Beispiel:\n     * Eingabe: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Ausgabe: true\n     * Erklärung: Die Paare sind (1,9), (2,8), (3,7), (4,6), (5,10), und die Summe jedes Paares ist durch 5 teilbar.\n     *\n     * Eingabe: arr = [1,2,3,4,5,6], k = 7\n     * Ausgabe: true\n     * Erklärung: Die Paare sind (1,6), (2,5), (3,4), und die Summe jedes Paares ist durch 7 teilbar.\n     *\n     * Eingabe: arr = [1,2,3,4,5,6], k = 10\n     * Ausgabe: false\n     * Erklärung: Es ist nicht möglich, das Array in n/2 Paare zu unterteilen, sodass die Summe jedes Paares durch 10 teilbar ist.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "ha": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Duba idan yana yiwuwa a raba jerin cikin n/2 ma'aurata ta yadda jumlar kowanne ma'aurata za ta rabu da k.\n     *\n     * @param arr jerin lambobin shigarwa\n     * @param k mai raba\n     * @return gaskiya idan yana yiwuwa, karya in ba haka ba\n     *\n     * Misali:\n     * Shigarwa: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Fitarwa: gaskiya\n     * Bayani: Ma'auratan sune (1,9), (2,8), (3,7), (4,6), (5,10), kuma jumlar kowanne ma'aurata za ta rabu da 5.\n     *\n     * Shigarwa: arr = [1,2,3,4,5,6], k = 7\n     * Fitarwa: gaskiya\n     * Bayani: Ma'auratan sune (1,6), (2,5), (3,4), kuma jumlar kowanne ma'aurata za ta rabu da 7.\n     *\n     * Shigarwa: arr = [1,2,3,4,5,6], k = 10\n     * Fitarwa: karya\n     * Bayani: Ba zai yiwu a raba jerin cikin n/2 ma'aurata ta yadda jumlar kowanne ma'aurata za ta rabu da 10 ba.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "hi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * जाँचें कि क्या यह संभव है कि सरणी को n/2 जोड़ों में विभाजित किया जाए ताकि प्रत्येक जोड़े का योग k से विभाज्य हो।\n     *\n     * @param arr इनपुट पूर्णांक सरणी\n     * @param k भाजक\n     * @return true यदि यह संभव है, अन्यथा false\n     *\n     * उदाहरण:\n     * इनपुट: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * आउटपुट: true\n     * व्याख्या: जोड़े हैं (1,9), (2,8), (3,7), (4,6), (5,10), और प्रत्येक जोड़े का योग 5 से विभाज्य है।\n     *\n     * इनपुट: arr = [1,2,3,4,5,6], k = 7\n     * आउटपुट: true\n     * व्याख्या: जोड़े हैं (1,6), (2,5), (3,4), और प्रत्येक जोड़े का योग 7 से विभाज्य है।\n     *\n     * इनपुट: arr = [1,2,3,4,5,6], k = 10\n     * आउटपुट: false\n     * व्याख्या: यह संभव नहीं है कि सरणी को n/2 जोड़ों में विभाजित किया जाए ताकि प्रत्येक जोड़े का योग 10 से विभाज्य हो।\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "hu": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Ellenőrizze, hogy lehetséges-e az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen k-val.\n     *\n     * @param arr a bemeneti egész szám tömb\n     * @param k az osztó\n     * @return igaz, ha lehetséges, hamis egyébként\n     *\n     * Példa:\n     * Bemenet: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Kimenet: true\n     * Magyarázat: A párok (1,9), (2,8), (3,7), (4,6), (5,10), és minden pár összege osztható 5-tel.\n     *\n     * Bemenet: arr = [1,2,3,4,5,6], k = 7\n     * Kimenet: true\n     * Magyarázat: A párok (1,6), (2,5), (3,4), és minden pár összege osztható 7-tel.\n     *\n     * Bemenet: arr = [1,2,3,4,5,6], k = 10\n     * Kimenet: false\n     * Magyarázat: Nem lehetséges az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen 10-zel.\n     */\n  public boolean canArrange(int[] arr, int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9507384737210616",
      "hy": "0.9245490579816115",
      "bn": "0.9860579349247801",
      "bg": "0.9617936448383203",
      "zh": "0.9397943369868013",
      "fr": "0.9962244337172889",
      "de": "0.999999801369619",
      "ha": "0.949397520018695",
      "hi": "0.9864408942994154",
      "hu": "0.9519640231720468"
    },
    "canonical_solution": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "instruction": {
      "en": "Write a Java function `public boolean canArrange(int[] arr, int k)` to solve the following problem:\nCheck if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.",
      "sq": "Shkruani një funksion Java `public boolean canArrange(int[] arr, int k)` për të zgjidhur problemin e mëposhtëm:\nKontrolloni nëse është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me k.\n\n@param arr vargu hyrës i numrave të plotë\n@param k pjestuesi\n@return true nëse është e mundur, false përndryshe\n\nShembull:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nShpjegim: Çiftet janë (1,9), (2,8), (3,7), (4,6), (5,10), dhe shuma e secilit çift është e pjestueshme me 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nShpjegim: Çiftet janë (1,6), (2,5), (3,4), dhe shuma e secilit çift është e pjestueshme me 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nShpjegim: Nuk është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me 10.",
      "hy": "Գրեք Java ֆունկցիա `public boolean canArrange(int[] arr, int k)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք հնարավոր է զանգվածը բաժանել n/2 զույգերի, այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի k-ի վրա:\n\n@param arr մուտքային ամբողջ թվերի զանգվածը\n@param k բաժանարարը\n@return true եթե հնարավոր է, false հակառակ դեպքում\n\nՕրինակ:\nՄուտք: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nԵլք: true\nԲացատրություն: Զույգերն են (1,9), (2,8), (3,7), (4,6), (5,10), և յուրաքանչյուր զույգի գումարը բաժանվում է 5-ի վրա:\n\nՄուտք: arr = [1,2,3,4,5,6], k = 7\nԵլք: true\nԲացատրություն: Զույգերն են (1,6), (2,5), (3,4), և յուրաքանչյուր զույգի գումարը բաժանվում է 7-ի վրա:\n\nՄուտք: arr = [1,2,3,4,5,6], k = 10\nԵլք: false\nԲացատրություն: Անհնար է զանգվածը բաժանել n/2 զույգերի, այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի 10-ի վրա:",
      "bn": "একটি জাভা ফাংশন `public boolean canArrange(int[] arr, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপরীক্ষা করুন যে অ্যারেটিকে n/2 জোড়ায় ভাগ করা সম্ভব কিনা যাতে প্রতিটি জোড়ার যোগফল k দ্বারা বিভাজ্য হয়।\n\n@param arr ইনপুট পূর্ণসংখ্যার অ্যারে\n@param k বিভাজক\n@return true যদি এটি সম্ভব হয়, অন্যথায় false\n\nউদাহরণ:\nইনপুট: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nআউটপুট: true\nব্যাখ্যা: জোড়াগুলি হল (1,9), (2,8), (3,7), (4,6), (5,10), এবং প্রতিটি জোড়ার যোগফল 5 দ্বারা বিভাজ্য।\n\nইনপুট: arr = [1,2,3,4,5,6], k = 7\nআউটপুট: true\nব্যাখ্যা: জোড়াগুলি হল (1,6), (2,5), (3,4), এবং প্রতিটি জোড়ার যোগফল 7 দ্বারা বিভাজ্য।\n\nইনপুট: arr = [1,2,3,4,5,6], k = 10\nআউটপুট: false\nব্যাখ্যা: অ্যারেটিকে n/2 জোড়ায় ভাগ করা সম্ভব নয় যাতে প্রতিটি জোড়ার যোগফল 10 দ্বারা বিভাজ্য হয়।",
      "bg": "Напишете Java функция `public boolean canArrange(int[] arr, int k)`, за да решите следния проблем:\nПроверете дали е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да се дели на k.\n\n@param arr входният масив от цели числа\n@param k делителят\n@return true ако е възможно, false в противен случай\n\nПример:\nВход: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nИзход: true\nОбяснение: Двойките са (1,9), (2,8), (3,7), (4,6), (5,10), и сумата на всяка двойка се дели на 5.\n\nВход: arr = [1,2,3,4,5,6], k = 7\nИзход: true\nОбяснение: Двойките са (1,6), (2,5), (3,4), и сумата на всяка двойка се дели на 7.\n\nВход: arr = [1,2,3,4,5,6], k = 10\nИзход: false\nОбяснение: Не е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да се дели на 10.",
      "zh": "编写一个 Java 函数 `public boolean canArrange(int[] arr, int k)` 来解决以下问题：\n检查是否可以将数组分成 n/2 对，使得每对的和都能被 k 整除。\n\n@param arr 输入的整数数组\n@param k 除数\n@return 如果可能则返回 true，否则返回 false\n\n示例：\n输入: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n输出: true\n解释: 这些对是 (1,9), (2,8), (3,7), (4,6), (5,10)，并且每对的和都能被 5 整除。\n\n输入: arr = [1,2,3,4,5,6], k = 7\n输出: true\n解释: 这些对是 (1,6), (2,5), (3,4)，并且每对的和都能被 7 整除。\n\n输入: arr = [1,2,3,4,5,6], k = 10\n输出: false\n解释: 不可能将数组分成 n/2 对，使得每对的和都能被 10 整除。",
      "fr": "Écrire une fonction Java `public boolean canArrange(int[] arr, int k)` pour résoudre le problème suivant :  \nVérifiez s'il est possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par k.\n\n@param arr le tableau d'entiers d'entrée  \n@param k le diviseur  \n@return true si c'est possible, false sinon\n\nExemple :  \nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5  \nOutput: true  \nExplication : Les paires sont (1,9), (2,8), (3,7), (4,6), (5,10), et la somme de chaque paire est divisible par 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7  \nOutput: true  \nExplication : Les paires sont (1,6), (2,5), (3,4), et la somme de chaque paire est divisible par 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10  \nOutput: false  \nExplication : Il n'est pas possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par 10.",
      "de": "Schreiben Sie eine Java-Funktion `public boolean canArrange(int[] arr, int k)`, um das folgende Problem zu lösen:\nÜberprüfen Sie, ob es möglich ist, das Array in n/2 Paare zu unterteilen, sodass die Summe jedes Paares durch k teilbar ist.\n\n@param arr das Eingabe-Integer-Array\n@param k der Divisor\n@return true, wenn es möglich ist, false andernfalls\n\nBeispiel:\nEingabe: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nAusgabe: true\nErläuterung: Die Paare sind (1,9), (2,8), (3,7), (4,6), (5,10), und die Summe jedes Paares ist durch 5 teilbar.\n\nEingabe: arr = [1,2,3,4,5,6], k = 7\nAusgabe: true\nErläuterung: Die Paare sind (1,6), (2,5), (3,4), und die Summe jedes Paares ist durch 7 teilbar.\n\nEingabe: arr = [1,2,3,4,5,6], k = 10\nAusgabe: false\nErläuterung: Es ist nicht möglich, das Array in n/2 Paare zu unterteilen, sodass die Summe jedes Paares durch 10 teilbar ist.",
      "ha": "Rubuta wani aikin Java `public boolean canArrange(int[] arr, int k)` don warware matsalar mai zuwa:\nDuba idan yana yiwuwa a raba jerin zuwa n/2 ma'aurata ta yadda jimillar kowanne ma'aurata za ta iya raba ta daidai da k.\n\n@param arr jerin lambobin shigarwa\n@param k mai raba\n@return gaskiya idan yana yiwuwa, ƙarya in ba haka ba\n\nMisali:\nShigarwa: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nFitarwa: gaskiya\nBayani: Ma'auratan sune (1,9), (2,8), (3,7), (4,6), (5,10), kuma jimillar kowanne ma'aurata za ta iya raba ta daidai da 5.\n\nShigarwa: arr = [1,2,3,4,5,6], k = 7\nFitarwa: gaskiya\nBayani: Ma'auratan sune (1,6), (2,5), (3,4), kuma jimillar kowanne ma'aurata za ta iya raba ta daidai da 7.\n\nShigarwa: arr = [1,2,3,4,5,6], k = 10\nFitarwa: ƙarya\nBayani: Ba zai yiwu a raba jerin zuwa n/2 ma'aurata ta yadda jimillar kowanne ma'aurata za ta iya raba ta daidai da 10 ba.",
      "hi": "Java फ़ंक्शन `public boolean canArrange(int[] arr, int k)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nजाँच करें कि क्या यह संभव है कि array को n/2 जोड़ों में विभाजित किया जा सके ताकि प्रत्येक जोड़े का योग k से विभाज्य हो।\n\n@param arr इनपुट पूर्णांक array\n@param k भाजक\n@return true अगर यह संभव है, अन्यथा false\n\nउदाहरण:\nइनपुट: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nआउटपुट: true\nव्याख्या: जोड़े हैं (1,9), (2,8), (3,7), (4,6), (5,10), और प्रत्येक जोड़े का योग 5 से विभाज्य है।\n\nइनपुट: arr = [1,2,3,4,5,6], k = 7\nआउटपुट: true\nव्याख्या: जोड़े हैं (1,6), (2,5), (3,4), और प्रत्येक जोड़े का योग 7 से विभाज्य है।\n\nइनपुट: arr = [1,2,3,4,5,6], k = 10\nआउटपुट: false\nव्याख्या: यह संभव नहीं है कि array को n/2 जोड़ों में विभाजित किया जा सके ताकि प्रत्येक जोड़े का योग 10 से विभाज्य हो।",
      "hu": "Írj egy Java függvényt `public boolean canArrange(int[] arr, int k)` a következő probléma megoldására:\nEllenőrizd, hogy lehetséges-e az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen k-val.\n\n@param arr a bemeneti egész szám tömb\n@param k az osztó\n@return igaz, ha lehetséges, hamis egyébként\n\nPélda:\nBemenet: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nKimenet: true\nMagyarázat: A párok (1,9), (2,8), (3,7), (4,6), (5,10), és minden pár összege osztható 5-tel.\n\nBemenet: arr = [1,2,3,4,5,6], k = 7\nKimenet: true\nMagyarázat: A párok (1,6), (2,5), (3,4), és minden pár összege osztható 7-tel.\n\nBemenet: arr = [1,2,3,4,5,6], k = 10\nKimenet: false\nMagyarázat: Nem lehetséges az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen 10-zel."
    },
    "instruction_bertscore": {
      "sq": "0.9930866695880807",
      "hy": "0.9855168657668412",
      "bn": "0.9851932968761353",
      "bg": "0.9924850181639261",
      "zh": "0.96807751557274",
      "fr": "1",
      "de": "0.9908004339023692",
      "ha": "0.979059789340159",
      "hi": "0.9851932968761353",
      "hu": "0.9913955305239497"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "canArrange",
    "signature": "public boolean canArrange(int[] arr, int k)",
    "docstring": {
      "en": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.",
      "sq": "Kontrolloni nëse është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me k.\n\n@param arr vargu hyrës i numrave të plotë\n@param k pjestuesi\n@return true nëse është e mundur, false përndryshe\n\nShembull:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nShpjegim: Çiftet janë (1,9), (2,8), (3,7), (4,6), (5,10), dhe shuma e secilit çift është e pjestueshme me 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nShpjegim: Çiftet janë (1,6), (2,5), (3,4), dhe shuma e secilit çift është e pjestueshme me 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nShpjegim: Nuk është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me 10.",
      "hy": "Ստուգել, արդյոք հնարավոր է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի k-ի վրա:\n\n@param arr մուտքային ամբողջ թվերի զանգվածը\n@param k բաժանարարը\n@return true եթե հնարավոր է, false հակառակ դեպքում\n\nՕրինակ:\nՄուտքագրում: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nԵլք: true\nԲացատրություն: Զույգերն են (1,9), (2,8), (3,7), (4,6), (5,10), և յուրաքանչյուր զույգի գումարը բաժանվում է 5-ի վրա:\n\nՄուտքագրում: arr = [1,2,3,4,5,6], k = 7\nԵլք: true\nԲացատրություն: Զույգերն են (1,6), (2,5), (3,4), և յուրաքանչյուր զույգի գումարը բաժանվում է 7-ի վրա:\n\nՄուտքագրում: arr = [1,2,3,4,5,6], k = 10\nԵլք: false\nԲացատրություն: Անհնար է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի 10-ի վրա:",
      "bn": "এটি পরীক্ষা করুন যে n/2 জোড়ায় অ্যারে ভাগ করা সম্ভব কিনা যাতে প্রতিটি জোড়ার যোগফল k দ্বারা বিভাজ্য হয়।\n\n@param arr ইনপুট পূর্ণসংখ্যার অ্যারে\n@param k বিভাজক\n@return সত্য যদি এটি সম্ভব হয়, মিথ্যা অন্যথায়\n\nউদাহরণ:\nইনপুট: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nআউটপুট: true\nব্যাখ্যা: জোড়াগুলি হল (1,9), (2,8), (3,7), (4,6), (5,10), এবং প্রতিটি জোড়ার যোগফল 5 দ্বারা বিভাজ্য।\n\nইনপুট: arr = [1,2,3,4,5,6], k = 7\nআউটপুট: true\nব্যাখ্যা: জোড়াগুলি হল (1,6), (2,5), (3,4), এবং প্রতিটি জোড়ার যোগফল 7 দ্বারা বিভাজ্য।\n\nইনপুট: arr = [1,2,3,4,5,6], k = 10\nআউটপুট: false\nব্যাখ্যা: এটি সম্ভব নয় যে অ্যারেটিকে n/2 জোড়ায় ভাগ করা যায় যাতে প্রতিটি জোড়ার যোগফল 10 দ্বারা বিভাজ্য হয়।",
      "bg": "Проверете дали е възможно масивът да бъде разделен на n/2 двойки, така че сумата на всяка двойка да е делима на k.\n\n@param arr входният масив от цели числа\n@param k делителят\n@return true ако е възможно, false в противен случай\n\nПример:\nВход: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nИзход: true\nОбяснение: Двойките са (1,9), (2,8), (3,7), (4,6), (5,10), и сумата на всяка двойка е делима на 5.\n\nВход: arr = [1,2,3,4,5,6], k = 7\nИзход: true\nОбяснение: Двойките са (1,6), (2,5), (3,4), и сумата на всяка двойка е делима на 7.\n\nВход: arr = [1,2,3,4,5,6], k = 10\nИзход: false\nОбяснение: Не е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да е делима на 10.",
      "zh": "检查是否可以将数组划分为 n/2 对，使得每对的和都能被 k 整除。\n\n@param arr 输入的整数数组\n@param k 除数\n@return 如果可能则返回 true，否则返回 false\n\n示例：\n输入: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n输出: true\n解释: 这些对是 (1,9), (2,8), (3,7), (4,6), (5,10)，并且每对的和都能被 5 整除。\n\n输入: arr = [1,2,3,4,5,6], k = 7\n输出: true\n解释: 这些对是 (1,6), (2,5), (3,4)，并且每对的和都能被 7 整除。\n\n输入: arr = [1,2,3,4,5,6], k = 10\n输出: false\n解释: 不可能将数组划分为 n/2 对，使得每对的和都能被 10 整除。",
      "fr": "Vérifiez s'il est possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par k.\n\n@param arr le tableau d'entiers en entrée\n@param k le diviseur\n@return true si c'est possible, false sinon\n\nExemple :\nEntrée : arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nSortie : true\nExplication : Les paires sont (1,9), (2,8), (3,7), (4,6), (5,10), et la somme de chaque paire est divisible par 5.\n\nEntrée : arr = [1,2,3,4,5,6], k = 7\nSortie : true\nExplication : Les paires sont (1,6), (2,5), (3,4), et la somme de chaque paire est divisible par 7.\n\nEntrée : arr = [1,2,3,4,5,6], k = 10\nSortie : false\nExplication : Il n'est pas possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par 10.",
      "de": "Überprüfen Sie, ob es möglich ist, das Array in n/2 Paare zu unterteilen, so dass die Summe jedes Paares durch k teilbar ist.\n\n@param arr das Eingabe-Integer-Array\n@param k der Divisor\n@return true, wenn es möglich ist, false andernfalls\n\nBeispiel:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nErläuterung: Die Paare sind (1,9), (2,8), (3,7), (4,6), (5,10), und die Summe jedes Paares ist durch 5 teilbar.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nErläuterung: Die Paare sind (1,6), (2,5), (3,4), und die Summe jedes Paares ist durch 7 teilbar.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nErläuterung: Es ist nicht möglich, das Array in n/2 Paare zu unterteilen, so dass die Summe jedes Paares durch 10 teilbar ist.",
      "ha": "Duba idan yana yiwuwa a raba jerin cikin n/2 ma'aurata ta yadda jumlar kowanne ma'aurata za ta rabu da k.\n\n@param arr jerin lambobin shigarwa\n@param k mai raba\n@return gaskiya idan zai yiwu, ƙarya in ba haka ba\n\nMisali:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nBayani: Ma'auratan sune (1,9), (2,8), (3,7), (4,6), (5,10), kuma jimillar kowace ma'aurata ana iya rabawa da 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nBayani: Ma'auratan sune (1,6), (2,5), (3,4), kuma jimillar kowace ma'aurata ana iya rabawa da 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nBayani: Ba zai yiwu a raba jerin cikin n/2 ma'aurata ba ta yadda jimillar kowace ma'aurata za a iya rabawa da 10.",
      "hi": "जाँचें कि क्या यह संभव है कि सरणी को n/2 जोड़ों में विभाजित किया जाए ताकि प्रत्येक जोड़े का योग k से विभाज्य हो।\n\n@param arr इनपुट पूर्णांक ऐरे\n@param k भाजक\n@return true यदि यह संभव है, अन्यथा false\n\nउदाहरण:\nइनपुट: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nआउटपुट: true\nव्याख्या: जोड़े हैं (1,9), (2,8), (3,7), (4,6), (5,10), और प्रत्येक जोड़े का योग 5 से विभाज्य है।\n\nइनपुट: arr = [1,2,3,4,5,6], k = 7\nआउटपुट: true\nव्याख्या: जोड़े हैं (1,6), (2,5), (3,4), और प्रत्येक जोड़े का योग 7 से विभाज्य है।\n\nइनपुट: arr = [1,2,3,4,5,6], k = 10\nआउटपुट: false\nव्याख्या: यह संभव नहीं है कि ऐरे को n/2 जोड़ों में विभाजित किया जाए ताकि प्रत्येक जोड़े का योग 10 से विभाज्य हो।",
      "hu": "Ellenőrizze, hogy lehetséges-e az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen k-val.\n\n@param arr a bemeneti egész szám tömb\n@param k az osztó\n@return true ha lehetséges, false különben\n\nPélda:\nBemenet: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nKimenet: true\nMagyarázat: A párok (1,9), (2,8), (3,7), (4,6), (5,10), és minden pár összege osztható 5-tel.\n\nBemenet: arr = [1,2,3,4,5,6], k = 7\nKimenet: true\nMagyarázat: A párok (1,6), (2,5), (3,4), és minden pár összege osztható 7-tel.\n\nBemenet: arr = [1,2,3,4,5,6], k = 10\nKimenet: false\nMagyarázat: Nem lehetséges a tömböt n/2 párokra osztani úgy, hogy minden pár összege osztható legyen 10-zel."
    },
    "docstring_bertscore": {
      "sq": "0.977790541205346",
      "hy": "0.9754194903469325",
      "bn": "0.9838449938496705",
      "bg": "0.9919163393830231",
      "zh": "0.9638464898263158",
      "fr": "0.9956009329512203",
      "de": "1",
      "ha": "0.9694947433414239",
      "hi": "0.9839891995063018",
      "hu": "0.9782132266561883"
    }
  },
  {
    "task_id": "Java/17",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Duke pasur një pemë me n nyje dhe lidhje, dhe një varg boolean hasApple që tregon nëse çdo nyje ka një mollë.\n   * Duke filluar nga nyja 0, kthe kohën minimale të nevojshme për të mbledhur të gjitha mollët dhe për t'u kthyer te nyja 0.\n   *\n   * Shembull:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Տրված է ծառ n գագաթներով և կողերով, և boolean զանգված hasApple, որը ցույց է տալիս՝ արդյոք յուրաքանչյուր գագաթում խնձոր կա։\n   * Սկսելով 0 գագաթից, վերադարձնել նվազագույն ժամանակը, որը պահանջվում է բոլոր խնձորները հավաքելու և 0 գագաթ վերադառնալու համար։\n   *\n   * Օրինակ:\n   * Մուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Ելք: 8\n   *\n   * Մուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Ելք: 6\n   *\n   * Մուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Ելք: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * একটি গাছ দেওয়া হয়েছে যেখানে nটি নোড এবং এজ রয়েছে, এবং একটি বুলিয়ান অ্যারে hasApple যা নির্দেশ করে প্রতিটি নোডে আপেল আছে কিনা।\n   * নোড 0 থেকে শুরু করে, সমস্ত আপেল সংগ্রহ করতে এবং নোড 0 তে ফিরে আসতে ন্যূনতম সময় ফেরত দিন।\n   *\n   * উদাহরণ:\n   * ইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * আউটপুট: 8\n   *\n   * ইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * আউটপুট: 6\n   *\n   * ইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * আউটপুট: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Дадено е дърво с n възли и ребра, и булев масив hasApple, указващ дали всеки възел има ябълка.\n   * Започвайки от възел 0, върнете минималното време, необходимо за събиране на всички ябълки и връщане до възел 0.\n   *\n   * Пример:\n   * Вход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Изход: 8\n   *\n   * Вход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Изход: 6\n   *\n   * Вход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Изход: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * 给定一个有 n 个节点和边的树，以及一个布尔数组 hasApple，表示每个节点是否有苹果。\n   * 从节点 0 开始，返回收集所有苹果并返回到节点 0 所需的最短时间。\n   *\n   * 示例：\n   * 输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * 输出: 8\n   *\n   * 输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * 输出: 6\n   *\n   * 输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * 输出: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "fr": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Étant donné un arbre avec n nœuds et arêtes, et un tableau booléen hasApple indiquant si chaque nœud a une pomme.\n   * En partant du nœud 0, retourner le temps minimum nécessaire pour collecter toutes les pommes et revenir au nœud 0.\n   *\n   * Exemple :\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Gegeben ist ein Baum mit n Knoten und Kanten sowie ein boolesches Array hasApple, das angibt, ob jeder Knoten einen Apfel hat.\n   * Beginnend bei Knoten 0, gib die minimale Zeit zurück, die benötigt wird, um alle Äpfel zu sammeln und zu Knoten 0 zurückzukehren.\n   *\n   * Beispiel:\n   * Eingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Ausgabe: 8\n   *\n   * Eingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Ausgabe: 6\n   *\n   * Eingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Ausgabe: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * An ba da itace tare da nodes n da gefuna, da kuma boolean array hasApple yana nuna idan kowanne node yana da apple.\n   * Fara daga node 0, dawo da lokacin mafi kankanta da ake bukata don tattara dukkan apples kuma a koma node 0.\n   *\n   * Misali:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * दिए गए n नोड्स और किनारों के साथ एक वृक्ष, और एक बूलियन ऐरे hasApple यह दर्शाता है कि प्रत्येक नोड पर सेब है या नहीं।\n   * नोड 0 से शुरू करते हुए, सभी सेब इकट्ठा करने और नोड 0 पर लौटने के लिए आवश्यक न्यूनतम समय लौटाएं।\n   *\n   * उदाहरण:\n   * इनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * आउटपुट: 8\n   *\n   * इनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * आउटपुट: 6\n   *\n   * इनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * आउटपुट: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Adott egy fa n csomóponttal és élekkel, valamint egy logikai tömb hasApple, amely jelzi, hogy az egyes csomópontoknak van-e almájuk.\n   * A 0. csomópontból kiindulva térj vissza a minimális idővel, amely szükséges az összes alma összegyűjtéséhez és a 0. csomóponthoz való visszatéréshez.\n   *\n   * Példa:\n   * Bemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Kimenet: 8\n   *\n   * Bemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Kimenet: 6\n   *\n   * Bemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Kimenet: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) "
    },
    "prompt_bertscore": {
      "sq": "0.9953532408660698",
      "hy": "0.9786551792539909",
      "bn": "0.9909287491285177",
      "bg": "0.9953532408660698",
      "zh": "0.9705010048517467",
      "fr": "0.9963158036925649",
      "de": "0.9765733342303643",
      "ha": "0.9963158036925649",
      "hi": "0.9906834406079396",
      "hu": "0.9953532408660698"
    },
    "canonical_solution": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n",
    "instruction": {
      "en": "Write a Java function `public int minTime(int n, int[][] edges, boolean[] hasApple)` to solve the following problem:\nGiven a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "sq": "Shkruani një funksion Java `public int minTime(int n, int[][] edges, boolean[] hasApple)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një pemë me n nyje dhe lidhje, dhe një varg boolean hasApple që tregon nëse çdo nyje ka një mollë.\nDuke filluar nga nyja 0, kthe kohën minimale të nevojshme për të mbledhur të gjitha mollët dhe për t'u kthyer në nyjën 0.\n\nShembull:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "hy": "Գրեք Java ֆունկցիա `public int minTime(int n, int[][] edges, boolean[] hasApple)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ծառ n գագաթներով և կողերով, և boolean զանգված hasApple, որը ցույց է տալիս, թե արդյոք յուրաքանչյուր գագաթում կա խնձոր:\nՍկսելով 0 գագաթից, վերադարձնել նվազագույն ժամանակը, որը պահանջվում է բոլոր խնձորները հավաքելու և 0 գագաթ վերադառնալու համար:\n\nՕրինակ:\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nԵլք: 8\n\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nԵլք: 6\n\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nԵլք: 0",
      "bn": "জাভা ফাংশন `public int minTime(int n, int[][] edges, boolean[] hasApple)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া একটি গাছের nটি নোড এবং এজেস, এবং একটি বুলিয়ান অ্যারে hasApple যা নির্দেশ করে প্রতিটি নোডে একটি আপেল আছে কিনা।\nনোড 0 থেকে শুরু করে, সমস্ত আপেল সংগ্রহ করতে এবং নোড 0-তে ফিরে আসতে প্রয়োজনীয় সর্বনিম্ন সময় ফেরত দিন।\n\nউদাহরণ:\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nআউটপুট: 8\n\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nআউটপুট: 6\n\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nআউটপুট: 0",
      "bg": "Напишете Java функция `public int minTime(int n, int[][] edges, boolean[] hasApple)`, за да решите следния проблем:\nДадено е дърво с n възли и ребра, и булев масив hasApple, който указва дали всеки възел има ябълка.\nЗапочвайки от възел 0, върнете минималното време, необходимо за събиране на всички ябълки и връщане до възел 0.\n\nПример:\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nИзход: 8\n\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nИзход: 6\n\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nИзход: 0",
      "zh": "编写一个 Java 函数 `public int minTime(int n, int[][] edges, boolean[] hasApple)` 来解决以下问题：\n给定一个有 n 个节点和边的树，以及一个布尔数组 hasApple，指示每个节点是否有苹果。\n从节点 0 开始，返回收集所有苹果并返回到节点 0 所需的最短时间。\n\n示例：\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n输出: 8\n\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n输出: 6\n\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n输出: 0",
      "fr": "Écrire une fonction Java `public int minTime(int n, int[][] edges, boolean[] hasApple)` pour résoudre le problème suivant :  \nÉtant donné un arbre avec n nœuds et des arêtes, et un tableau booléen hasApple indiquant si chaque nœud a une pomme.  \nEn partant du nœud 0, retourner le temps minimum requis pour collecter toutes les pommes et revenir au nœud 0.\n\nExemple :  \nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]  \nSortie : 8\n\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]  \nSortie : 6\n\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]  \nSortie : 0",
      "de": "Schreiben Sie eine Java-Funktion `public int minTime(int n, int[][] edges, boolean[] hasApple)`, um das folgende Problem zu lösen:\nGegeben ist ein Baum mit n Knoten und Kanten sowie ein boolesches Array hasApple, das angibt, ob jeder Knoten einen Apfel hat.\nAusgehend von Knoten 0, geben Sie die minimale Zeit zurück, die benötigt wird, um alle Äpfel zu sammeln und zu Knoten 0 zurückzukehren.\n\nBeispiel:\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nAusgabe: 8\n\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nAusgabe: 6\n\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nAusgabe: 0",
      "ha": "Rubuta aikin Java `public int minTime(int n, int[][] edges, boolean[] hasApple)` don warware matsalar mai zuwa:\nAn ba da itace tare da nodes n da edges, da kuma boolean array hasApple wanda ke nuna idan kowanne node yana da apple.\nFara daga node 0, dawo da mafi ƙarancin lokaci da ake buƙata don tattara dukkan apples kuma a koma node 0.\n\nMisali:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "hi": "Java फ़ंक्शन `public int minTime(int n, int[][] edges, boolean[] hasApple)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n नोड्स और edges के साथ एक वृक्ष, और एक boolean array hasApple जो इंगित करता है कि प्रत्येक नोड पर एक सेब है या नहीं।\nनोड 0 से शुरू करके, सभी सेब इकट्ठा करने और नोड 0 पर लौटने के लिए आवश्यक न्यूनतम समय लौटाएं।\n\nउदाहरण:\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nआउटपुट: 8\n\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nआउटपुट: 6\n\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nआउटपुट: 0",
      "hu": "Írj egy Java függvényt `public int minTime(int n, int[][] edges, boolean[] hasApple)` a következő probléma megoldására:\nAdott egy fa n csomóponttal és élekkel, valamint egy logikai tömb hasApple, amely jelzi, hogy az egyes csomópontokon van-e alma.\nA 0. csomópontból kiindulva térj vissza a minimális idővel, amely szükséges az összes alma összegyűjtéséhez és a 0. csomóponthoz való visszatéréshez.\n\nPélda:\nBemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nKimenet: 8\n\nBemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nKimenet: 6\n\nBemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nKimenet: 0"
    },
    "instruction_bertscore": {
      "sq": "0.9926490868586608",
      "hy": "0.9742920643041786",
      "bn": "0.9960790362783714",
      "bg": "0.9950910487631037",
      "zh": "0.9960790362783714",
      "fr": "0.9966201054363103",
      "de": "0.9965915026614414",
      "ha": "0.9938690746589771",
      "hi": "0.9883225198989589",
      "hu": "0.9960790362783714"
    },
    "level": "middle",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minTime",
    "signature": "public int minTime(int n, int[][] edges, boolean[] hasApple)",
    "docstring": {
      "en": "Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "sq": "Duke pasur një pemë me n nyje dhe lidhje, dhe një varg boolean hasApple që tregon nëse secila nyje ka një mollë.\nDuke filluar nga nyja 0, kthe kohën minimale të nevojshme për të mbledhur të gjitha mollët dhe për t'u kthyer në nyjen 0.\n\nShembull:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "hy": "Տրված է ծառ n գագաթներով և կողերով, և hasApple բուլյան զանգվածը, որը ցույց է տալիս, թե արդյոք յուրաքանչյուր գագաթում խնձոր կա:\nՍկսելով գագաթ 0-ից, վերադարձնել նվազագույն ժամանակը, որը պահանջվում է բոլոր խնձորները հավաքելու և վերադարձնելու համար գագաթ 0։\n\nՕրինակ:\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nԵլք: 8\n\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nԵլք: 6\n\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nԵլք: 0",
      "bn": "একটি গাছের nটি নোড এবং এজ দেওয়া আছে, এবং একটি বুলিয়ান অ্যারে hasApple নির্দেশ করে প্রতিটি নোডে একটি আপেল আছে কিনা। \nনোড 0 থেকে শুরু করে, সমস্ত আপেল সংগ্রহ করতে এবং নোড 0-তে ফিরে আসতে প্রয়োজনীয় সর্বনিম্ন সময় ফেরত দিন।\n\nউদাহরণ:\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nআউটপুট: 8\n\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nআউটপুট: 6\n\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nআউটপুট: 0",
      "bg": "Дадено е дърво с n възли и ребра, и булев масив hasApple, който указва дали всеки възел има ябълка.\nЗапочвайки от възел 0, върнете минималното време, необходимо за събиране на всички ябълки и връщане до възел 0.\n\nПример:\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nИзход: 8\n\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nИзход: 6\n\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nИзход: 0",
      "zh": "给定一个有 n 个节点和边的树，以及一个布尔数组 hasApple，表示每个节点是否有苹果。  \n从节点 0 开始，返回收集所有苹果并返回到节点 0 所需的最小时间。\n\n示例：  \n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]  \n输出: 8\n\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]  \n输出: 6\n\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]  \n输出: 0",
      "fr": "Étant donné un arbre avec n nœuds et arêtes, et un tableau booléen hasApple indiquant si chaque nœud a une pomme. En partant du nœud 0, retournez le temps minimum nécessaire pour collecter toutes les pommes et revenir au nœud 0.\n\nExemple :\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nSortie : 8\n\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nSortie : 6\n\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nSortie : 0",
      "de": "Gegeben ist ein Baum mit n Knoten und Kanten sowie ein boolesches Array hasApple, das angibt, ob jeder Knoten einen Apfel hat. Beginnend bei Knoten 0, gib die minimale Zeit zurück, die benötigt wird, um alle Äpfel zu sammeln und zu Knoten 0 zurückzukehren.\n\nBeispiel:\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nAusgabe: 8\n\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nAusgabe: 6\n\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nAusgabe: 0",
      "ha": "An ba da itace tare da nodes n da edges, da kuma boolean array hasApple yana nuna idan kowanne node yana da apple. Fara daga node 0, dawo da lokacin mafi ƙaranci da ake buƙata don tattara dukkan apples kuma a koma zuwa node 0.\n\nMisali:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "hi": "दिए गए n नोड्स और किनारों वाले पेड़ और एक boolean array hasApple, जो इंगित करता है कि प्रत्येक नोड में सेब है या नहीं। \n\nनोड 0 से शुरू करते हुए, सभी सेब इकट्ठा करने और नोड 0 पर लौटने के लिए आवश्यक न्यूनतम समय लौटाएं।\n\nउदाहरण:\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nआउटपुट: 8\n\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nआउटपुट: 6\n\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nआउटपुट: 0",
      "hu": "Adott egy fa n csomóponttal és élekkel, valamint egy logikai tömb hasApple, amely jelzi, hogy van-e alma az egyes csomópontokon. A 0. csomóponttól kezdve térj vissza a minimális idővel, amely szükséges az összes alma összegyűjtéséhez és a 0. csomóponthoz való visszatéréshez.\n\nPélda:\nBemenet: n = 7, élek = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nKimenet: 8\n\nBemenet: n = 7, élek = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nKimenet: 6\n\nBemenet: n = 7, élek = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nKimenet: 0"
    },
    "docstring_bertscore": {
      "sq": "0.9934412248182279",
      "hy": "0.9832425479039917",
      "bn": "0.9800880988227766",
      "bg": "0.9935151153199729",
      "zh": "0.9949510143444742",
      "fr": "1",
      "de": "0.9724773771430438",
      "ha": "0.9904371389354564",
      "hi": "0.9843024396171938",
      "hu": "0.9917236679134193"
    }
  },
  {
    "task_id": "Java/18",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg s. Ju duhet të riorganizoni vargun duke përdorur algoritmin e mëposhtëm:\n     * 1. Zgjidhni karakterin më të vogël nga s dhe bashkëngjitni atë në rezultatin.\n     * 2. Zgjidhni karakterin më të vogël nga s që është më i madh se karakteri i fundit i bashkëngjitur në rezultatin dhe bashkëngjitni atë.\n     * 3. Përsëritni hapin 2 derisa të mos mund të zgjidhni më shumë karaktere.\n     * 4. Zgjidhni karakterin më të madh nga s dhe bashkëngjitni atë në rezultatin.\n     * 5. Zgjidhni karakterin më të madh nga s që është më i vogël se karakteri i fundit i bashkëngjitur në rezultatin dhe bashkëngjitni atë.\n     * 6. Përsëritni hapin 5 derisa të mos mund të zgjidhni më shumë karaktere.\n     * 7. Përsëritni hapat nga 1 deri në 6 derisa të zgjidhni të gjithë karakteret nga s.\n     * Në secilin hap, Nëse karakteri më i vogël ose më i madh shfaqet më shumë se një herë, ju mund të zgjidhni çdo paraqitje dhe ta bashkëngjitni atë në rezultatin.\n     * Kthejeni vargun e rezultatit pasi të keni renditur s me këtë algoritëm.\n     */\n    public String sortString(String s)",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է s տողը։ Դուք պետք է վերադասավորեք տողը հետևյալ ալգորիթմի միջոցով.\n     * 1. Ընտրեք s-ի ամենափոքր նիշը և ավելացրեք այն արդյունքին։\n     * 2. Ընտրեք s-ի ամենափոքր նիշը, որը մեծ է արդյունքին վերջում ավելացված նիշից, և ավելացրեք այն։\n     * 3. Կրկնեք 2-րդ քայլը, մինչև չկարողանաք ավելի շատ նիշեր ընտրել։\n     * 4. Ընտրեք s-ի ամենամեծ նիշը և ավելացրեք այն արդյունքին։\n     * 5. Ընտրեք s-ի ամենամեծ նիշը, որը փոքր է արդյունքին վերջում ավելացված նիշից, և ավելացրեք այն։\n     * 6. Կրկնեք 5-րդ քայլը, մինչև չկարողանաք ավելի շատ նիշեր ընտրել։\n     * 7. Կրկնեք քայլերը 1-ից 6-ը, մինչև ընտրեք s-ի բոլոր նիշերը։\n     * Յուրաքանչյուր քայլում, եթե ամենափոքր կամ ամենամեծ նիշը հայտնվում է մեկից ավելի անգամ, կարող եք ընտրել ցանկացած հանդիպում և ավելացնել այն արդյունքին։\n     * Վերադարձնել արդյունքի տողը, երբ s-ը դասավորվի այս ալգորիթմով։\n     */\n    public String sortString(String s)",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি স্ট্রিং s দেওয়া আছে। আপনাকে নিম্নলিখিত অ্যালগরিদম ব্যবহার করে স্ট্রিংটি পুনরায় সাজাতে হবে:\n     * 1. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n     * 2. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে বড় এবং এটি যোগ করুন।\n     * 3. আরও অক্ষর বেছে নিতে না পারা পর্যন্ত ধাপ 2 পুনরাবৃত্তি করুন।\n     * 4. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n     * 5. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে ছোট এবং এটি যোগ করুন।\n     * 6. আরও অক্ষর বেছে নিতে না পারা পর্যন্ত ধাপ 5 পুনরাবৃত্তি করুন।\n     * 7. s থেকে সমস্ত অক্ষর বেছে না নেওয়া পর্যন্ত ধাপ 1 থেকে 6 পুনরাবৃত্তি করুন।\n     * প্রতিটি ধাপে, যদি সবচেয়ে ছোট বা সবচেয়ে বড় অক্ষর একাধিকবার উপস্থিত হয় তবে আপনি যেকোনো একটি বেছে নিয়ে ফলাফলে যোগ করতে পারেন।\n     * এই অ্যালগরিদম দিয়ে s সাজানোর পরে ফলাফল স্ট্রিংটি ফেরত দিন।\n     */\n    public String sortString(String s)",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е низ s. Трябва да пренаредите низа, използвайки следния алгоритъм:\n     * 1. Изберете най-малкия символ от s и го добавете към резултата.\n     * 2. Изберете най-малкия символ от s, който е по-голям от последния добавен символ към резултата, и го добавете.\n     * 3. Повторете стъпка 2, докато не можете да избирате повече символи.\n     * 4. Изберете най-големия символ от s и го добавете към резултата.\n     * 5. Изберете най-големия символ от s, който е по-малък от последния добавен символ към резултата, и го добавете.\n     * 6. Повторете стъпка 5, докато не можете да избирате повече символи.\n     * 7. Повторете стъпките от 1 до 6, докато не изберете всички символи от s.\n     * Във всяка стъпка, ако най-малкият или най-големият символ се появява повече от веднъж, можете да изберете всяко появяване и да го добавите към резултата.\n     * Върнете резултата като низ след сортиране на s с този алгоритъм.\n     */\n    public String sortString(String s)",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个字符串 s。你应该使用以下算法重新排序字符串：\n     * 1. 从 s 中选择最小的字符并将其附加到结果中。\n     * 2. 从 s 中选择比结果中最后附加字符大的最小字符并附加它。\n     * 3. 重复步骤 2，直到无法选择更多字符。\n     * 4. 从 s 中选择最大的字符并将其附加到结果中。\n     * 5. 从 s 中选择比结果中最后附加字符小的最大字符并附加它。\n     * 6. 重复步骤 5，直到无法选择更多字符。\n     * 7. 重复步骤 1 到 6，直到从 s 中选择所有字符。\n     * 在每一步中，如果最小或最大的字符出现多次，你可以选择任何一个出现并将其附加到结果中。\n     * 返回使用此算法排序后的结果字符串。\n     */\n    public String sortString(String s)",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné une chaîne de caractères s. Vous devez réorganiser la chaîne en utilisant l'algorithme suivant :\n     * 1. Choisissez le plus petit caractère de s et ajoutez-le au résultat.\n     * 2. Choisissez le plus petit caractère de s qui est plus grand que le dernier caractère ajouté au résultat et ajoutez-le.\n     * 3. Répétez l'étape 2 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n     * 4. Choisissez le plus grand caractère de s et ajoutez-le au résultat.\n     * 5. Choisissez le plus grand caractère de s qui est plus petit que le dernier caractère ajouté au résultat et ajoutez-le.\n     * 6. Répétez l'étape 5 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n     * 7. Répétez les étapes de 1 à 6 jusqu'à ce que vous ayez choisi tous les caractères de s.\n     * À chaque étape, si le plus petit ou le plus grand caractère apparaît plus d'une fois, vous pouvez choisir n'importe quelle occurrence et l'ajouter au résultat.\n     * Retournez la chaîne de résultat après avoir trié s avec cet algorithme.\n     */\n    public String sortString(String s)",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ist ein String s. Sie sollten den String mit dem folgenden Algorithmus neu ordnen:\n     * 1. Wählen Sie das kleinste Zeichen aus s und fügen Sie es dem Ergebnis hinzu.\n     * 2. Wählen Sie das kleinste Zeichen aus s, das größer ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und fügen Sie es hinzu.\n     * 3. Wiederholen Sie Schritt 2, bis Sie keine weiteren Zeichen auswählen können.\n     * 4. Wählen Sie das größte Zeichen aus s und fügen Sie es dem Ergebnis hinzu.\n     * 5. Wählen Sie das größte Zeichen aus s, das kleiner ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und fügen Sie es hinzu.\n     * 6. Wiederholen Sie Schritt 5, bis Sie keine weiteren Zeichen auswählen können.\n     * 7. Wiederholen Sie die Schritte von 1 bis 6, bis Sie alle Zeichen aus s ausgewählt haben.\n     * In jedem Schritt, wenn das kleinste oder größte Zeichen mehrmals vorkommt, können Sie eine beliebige Vorkommen auswählen und dem Ergebnis hinzufügen.\n     * Geben Sie den Ergebnisstring zurück, nachdem s mit diesem Algorithmus sortiert wurde.\n     */\n    public String sortString(String s)",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani kirtani s. Ya kamata ka sake tsara kirtani ta amfani da wannan dabarar:\n     * 1. Zaɓi ƙaramin harafi daga s ka haɗa shi zuwa sakamakon.\n     * 2. Zaɓi ƙaramin harafi daga s wanda ya fi ƙaramin harafin da aka haɗa zuwa sakamakon kuma haɗa shi.\n     * 3. Maimaita mataki na 2 har sai ba za ka iya zaɓar karin haruffa ba.\n     * 4. Zaɓi mafi girman harafi daga s ka haɗa shi zuwa sakamakon.\n     * 5. Zaɓi mafi girman harafi daga s wanda ya fi ƙaramin harafin da aka haɗa zuwa sakamakon kuma haɗa shi.\n     * 6. Maimaita mataki na 5 har sai ba za ka iya zaɓar karin haruffa ba.\n     * 7. Maimaita matakan daga 1 zuwa 6 har sai ka zaɓi duk haruffa daga s.\n     * A kowane mataki, Idan ƙaramin ko mafi girman harafi ya bayyana fiye da sau ɗaya za ka iya zaɓar kowanne bayyanar kuma haɗa shi zuwa sakamakon.\n     * Mayar da sakamakon kirtani bayan tsara s da wannan dabarar.\n     */\n    public String sortString(String s)",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए स्ट्रिंग s के लिए। आपको निम्नलिखित एल्गोरिदम का उपयोग करके स्ट्रिंग को पुनः क्रमबद्ध करना चाहिए:\n     * 1. s से सबसे छोटा वर्ण चुनें और उसे परिणाम में जोड़ें।\n     * 2. s से सबसे छोटा वर्ण चुनें जो परिणाम में जोड़े गए अंतिम वर्ण से बड़ा हो और उसे जोड़ें।\n     * 3. चरण 2 को तब तक दोहराएं जब तक आप अधिक वर्ण नहीं चुन सकते।\n     * 4. s से सबसे बड़ा वर्ण चुनें और उसे परिणाम में जोड़ें।\n     * 5. s से सबसे बड़ा वर्ण चुनें जो परिणाम में जोड़े गए अंतिम वर्ण से छोटा हो और उसे जोड़ें।\n     * 6. चरण 5 को तब तक दोहराएं जब तक आप अधिक वर्ण नहीं चुन सकते।\n     * 7. चरण 1 से 6 तक तब तक दोहराएं जब तक आप s से सभी वर्ण नहीं चुन लेते।\n     * प्रत्येक चरण में, यदि सबसे छोटा या सबसे बड़ा वर्ण एक से अधिक बार प्रकट होता है तो आप किसी भी प्रकट होने वाले को चुन सकते हैं और उसे परिणाम में जोड़ सकते हैं।\n     * इस एल्गोरिदम के साथ s को क्रमबद्ध करने के बाद परिणाम स्ट्रिंग लौटाएं।\n     */\n    public String sortString(String s)",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy s string. Újra kell rendezned a stringet a következő algoritmus szerint:\n     * 1. Válaszd ki a legkisebb karaktert s-ből és add hozzá az eredményhez.\n     * 2. Válaszd ki a legkisebb karaktert s-ből, amely nagyobb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n     * 3. Ismételd meg a 2. lépést, amíg nem tudsz több karaktert választani.\n     * 4. Válaszd ki a legnagyobb karaktert s-ből és add hozzá az eredményhez.\n     * 5. Válaszd ki a legnagyobb karaktert s-ből, amely kisebb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n     * 6. Ismételd meg az 5. lépést, amíg nem tudsz több karaktert választani.\n     * 7. Ismételd meg az 1-től 6-ig lépéseket, amíg ki nem választod az összes karaktert s-ből.\n     * Minden lépésben, ha a legkisebb vagy a legnagyobb karakter többször is előfordul, bármelyik előfordulást választhatod és hozzáadhatod az eredményhez.\n     * Add vissza az eredmény stringet, miután ezzel az algoritmussal rendezted s-t.\n     */\n    public String sortString(String s)"
    },
    "prompt_bertscore": {
      "sq": "0.9587861822390711",
      "hy": "0.9301891676510972",
      "bn": "0.9364797918184721",
      "bg": "0.9420881206269921",
      "zh": "0.9488802865064802",
      "fr": "0.9424541964192394",
      "de": "0.9488546631873266",
      "ha": "0.9586817026586467",
      "hi": "0.984588070105122",
      "hu": "0.9396600628492217"
    },
    "canonical_solution": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }",
    "instruction": {
      "en": "Write a Java function `public String sortString(String s)` to solve the following problem:\nGiven a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
      "sq": "Shkruani një funksion Java `public String sortString(String s)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg s. Ju duhet të riorganizoni vargun duke përdorur algoritmin e mëposhtëm:\n1. Zgjidhni karakterin më të vogël nga s dhe shtojeni atë në rezultatin.\n2. Zgjidhni karakterin më të vogël nga s i cili është më i madh se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n3. Përsëritni hapin 2 derisa të mos mund të zgjidhni më shumë karaktere.\n4. Zgjidhni karakterin më të madh nga s dhe shtojeni atë në rezultatin.\n5. Zgjidhni karakterin më të madh nga s i cili është më i vogël se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n6. Përsëritni hapin 5 derisa të mos mund të zgjidhni më shumë karaktere.\n7. Përsëritni hapat nga 1 deri në 6 derisa të zgjidhni të gjithë karakteret nga s.\nNë secilin hap, nëse karakteri më i vogël ose më i madh shfaqet më shumë se një herë, ju mund të zgjidhni çdo paraqitje dhe ta shtoni atë në rezultat.\nKthejeni vargun e rezultatit pasi të keni riorganizuar s me këtë algoritëm.",
      "hy": "Գրեք Java ֆունկցիա `public String sortString(String s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է s տողը։ Դուք պետք է վերադասավորեք տողը հետևյալ ալգորիթմի միջոցով:\n1. Ընտրեք s-ի ամենափոքր սիմվոլը և կցեք այն արդյունքին։\n2. Ընտրեք s-ի ամենափոքր սիմվոլը, որը մեծ է արդյունքին վերջին կցված սիմվոլից և կցեք այն։\n3. Կրկնեք 2-րդ քայլը, մինչև չկարողանաք ավելի շատ սիմվոլներ ընտրել։\n4. Ընտրեք s-ի ամենամեծ սիմվոլը և կցեք այն արդյունքին։\n5. Ընտրեք s-ի ամենամեծ սիմվոլը, որը փոքր է արդյունքին վերջին կցված սիմվոլից և կցեք այն։\n6. Կրկնեք 5-րդ քայլը, մինչև չկարողանաք ավելի շատ սիմվոլներ ընտրել։\n7. Կրկնեք քայլերը 1-ից 6-ը, մինչև չընտրեք s-ի բոլոր սիմվոլները։\nՅուրաքանչյուր քայլում, եթե ամենափոքր կամ ամենամեծ սիմվոլը հայտնվում է մեկից ավելի անգամ, կարող եք ընտրել ցանկացած հանդիպում և կցել այն արդյունքին։\nՎերադարձեք արդյունքի տողը, երբ s-ը դասավորված է այս ալգորիթմով։",
      "bn": "একটি জাভা ফাংশন `public String sortString(String s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক একটি স্ট্রিং s দেওয়া আছে। আপনাকে নিম্নলিখিত অ্যালগরিদম ব্যবহার করে স্ট্রিংটি পুনরায় সাজাতে হবে:\n1. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n2. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে বড় এবং এটি যোগ করুন।\n3. যতক্ষণ না আপনি আরও অক্ষর বেছে নিতে পারেন, ধাপ 2 পুনরাবৃত্তি করুন।\n4. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n5. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে ছোট এবং এটি যোগ করুন।\n6. যতক্ষণ না আপনি আরও অক্ষর বেছে নিতে পারেন, ধাপ 5 পুনরাবৃত্তি করুন।\n7. s থেকে সমস্ত অক্ষর বেছে না নেওয়া পর্যন্ত ধাপ 1 থেকে 6 পুনরাবৃত্তি করুন।\nপ্রতিটি ধাপে, যদি সবচেয়ে ছোট বা সবচেয়ে বড় অক্ষরটি একাধিকবার উপস্থিত হয়, আপনি যেকোনো একটি উপস্থিতি বেছে নিয়ে ফলাফলে যোগ করতে পারেন।\nএই অ্যালগরিদম দিয়ে s সাজানোর পরে ফলাফল স্ট্রিংটি ফেরত দিন।",
      "bg": "Напишете Java функция `public String sortString(String s)`, за да решите следния проблем:  \nДаден е низ s. Трябва да пренаредите низа, използвайки следния алгоритъм:  \n1. Изберете най-малкия символ от s и го добавете към резултата.  \n2. Изберете най-малкия символ от s, който е по-голям от последния добавен символ към резултата, и го добавете.  \n3. Повторете стъпка 2, докато не можете да изберете повече символи.  \n4. Изберете най-големия символ от s и го добавете към резултата.  \n5. Изберете най-големия символ от s, който е по-малък от последния добавен символ към резултата, и го добавете.  \n6. Повторете стъпка 5, докато не можете да изберете повече символи.  \n7. Повторете стъпките от 1 до 6, докато не изберете всички символи от s.  \nВъв всяка стъпка, ако най-малкият или най-големият символ се появява повече от веднъж, можете да изберете което и да е появяване и да го добавите към резултата.  \nВърнете резултата низ след сортиране на s с този алгоритъм.",
      "zh": "编写一个 Java 函数 `public String sortString(String s)` 来解决以下问题：  \n给定一个字符串 s。你应该使用以下算法重新排序字符串：  \n1. 从 s 中选择最小的字符并将其附加到结果中。  \n2. 从 s 中选择比结果中最后一个附加字符大的最小字符并附加它。  \n3. 重复步骤 2，直到无法选择更多字符。  \n4. 从 s 中选择最大的字符并将其附加到结果中。  \n5. 从 s 中选择比结果中最后一个附加字符小的最大字符并附加它。  \n6. 重复步骤 5，直到无法选择更多字符。  \n7. 重复步骤 1 到 6，直到从 s 中选择所有字符。  \n在每一步中，如果最小或最大的字符出现多次，你可以选择任何一个出现并将其附加到结果中。  \n在使用此算法对 s 进行排序后，返回结果字符串。",
      "fr": "Écrire une fonction Java `public String sortString(String s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne de caractères s. Vous devez réorganiser la chaîne en utilisant l'algorithme suivant :  \n1. Choisissez le plus petit caractère de s et ajoutez-le au résultat.  \n2. Choisissez le plus petit caractère de s qui est plus grand que le dernier caractère ajouté au résultat et ajoutez-le.  \n3. Répétez l'étape 2 jusqu'à ce que vous ne puissiez plus choisir de caractères.  \n4. Choisissez le plus grand caractère de s et ajoutez-le au résultat.  \n5. Choisissez le plus grand caractère de s qui est plus petit que le dernier caractère ajouté au résultat et ajoutez-le.  \n6. Répétez l'étape 5 jusqu'à ce que vous ne puissiez plus choisir de caractères.  \n7. Répétez les étapes de 1 à 6 jusqu'à ce que vous ayez choisi tous les caractères de s.  \nÀ chaque étape, si le plus petit ou le plus grand caractère apparaît plus d'une fois, vous pouvez choisir n'importe quelle occurrence et l'ajouter au résultat.  \nRetournez la chaîne de résultat après avoir trié s avec cet algorithme.",
      "de": "Schreiben Sie eine Java-Funktion `public String sortString(String s)`, um das folgende Problem zu lösen:\nGegeben ist ein String s. Sie sollten den String mit dem folgenden Algorithmus neu ordnen:\n1. Wählen Sie das kleinste Zeichen aus s und fügen Sie es dem Ergebnis hinzu.\n2. Wählen Sie das kleinste Zeichen aus s, das größer ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und fügen Sie es hinzu.\n3. Wiederholen Sie Schritt 2, bis Sie keine weiteren Zeichen mehr auswählen können.\n4. Wählen Sie das größte Zeichen aus s und fügen Sie es dem Ergebnis hinzu.\n5. Wählen Sie das größte Zeichen aus s, das kleiner ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und fügen Sie es hinzu.\n6. Wiederholen Sie Schritt 5, bis Sie keine weiteren Zeichen mehr auswählen können.\n7. Wiederholen Sie die Schritte 1 bis 6, bis Sie alle Zeichen aus s ausgewählt haben.\nIn jedem Schritt, wenn das kleinste oder das größte Zeichen mehr als einmal vorkommt, können Sie ein beliebiges Vorkommen auswählen und dem Ergebnis hinzufügen.\nGeben Sie den Ergebnisstring zurück, nachdem Sie s mit diesem Algorithmus sortiert haben.",
      "ha": "Rubuta aikin Java `public String sortString(String s)` don warware matsalar mai zuwa:\nAn ba da wani igiyar s. Ya kamata ka sake tsara igiyar ta amfani da wannan algorithm:\n1. Zaɓi mafi ƙarancin hali daga s kuma haɗa shi zuwa sakamakon.\n2. Zaɓi mafi ƙarancin hali daga s wanda ya fi wanda aka haɗa na ƙarshe girma zuwa sakamakon kuma haɗa shi.\n3. Maimaita mataki na 2 har sai ba za ka iya zaɓar karin haruffa ba.\n4. Zaɓi mafi girman hali daga s kuma haɗa shi zuwa sakamakon.\n5. Zaɓi mafi girman hali daga s wanda ya fi wanda aka haɗa na ƙarshe ƙanƙanta zuwa sakamakon kuma haɗa shi.\n6. Maimaita mataki na 5 har sai ba za ka iya zaɓar karin haruffa ba.\n7. Maimaita matakan daga 1 zuwa 6 har sai ka zaɓi duk haruffa daga s.\nA kowane mataki, Idan mafi ƙarancin ko mafi girman hali ya bayyana fiye da sau ɗaya za ka iya zaɓar kowanne daga ciki kuma haɗa shi zuwa sakamakon.\nMayar da igiyar sakamakon bayan tsara s da wannan algorithm.",
      "hi": "एक Java फ़ंक्शन `public String sortString(String s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया एक स्ट्रिंग s. आपको निम्नलिखित एल्गोरिदम का उपयोग करके स्ट्रिंग को पुनः क्रमबद्ध करना चाहिए:\n1. s से सबसे छोटा अक्षर चुनें और उसे परिणाम में जोड़ें।\n2. s से सबसे छोटा अक्षर चुनें जो परिणाम में अंतिम जोड़े गए अक्षर से बड़ा हो और उसे जोड़ें।\n3. चरण 2 को तब तक दोहराएं जब तक आप अधिक अक्षर नहीं चुन सकते।\n4. s से सबसे बड़ा अक्षर चुनें और उसे परिणाम में जोड़ें।\n5. s से सबसे बड़ा अक्षर चुनें जो परिणाम में अंतिम जोड़े गए अक्षर से छोटा हो और उसे जोड़ें।\n6. चरण 5 को तब तक दोहराएं जब तक आप अधिक अक्षर नहीं चुन सकते।\n7. चरण 1 से 6 तक दोहराएं जब तक आप s से सभी अक्षर नहीं चुन लेते।\nप्रत्येक चरण में, यदि सबसे छोटा या सबसे बड़ा अक्षर एक से अधिक बार आता है, तो आप किसी भी प्रकट होने वाले को चुन सकते हैं और उसे परिणाम में जोड़ सकते हैं।\nइस एल्गोरिदम के साथ s को क्रमबद्ध करने के बाद परिणाम स्ट्रिंग लौटाएं।",
      "hu": "Írj egy Java függvényt `public String sortString(String s)` a következő probléma megoldására:\nAdott egy s string. Újra kell rendezned a stringet a következő algoritmus használatával:\n1. Válaszd ki a legkisebb karaktert s-ből, és fűzd hozzá az eredményhez.\n2. Válaszd ki a legkisebb karaktert s-ből, amely nagyobb, mint az utoljára hozzáfűzött karakter az eredményhez, és fűzd hozzá.\n3. Ismételd meg a 2. lépést, amíg nem tudsz több karaktert választani.\n4. Válaszd ki a legnagyobb karaktert s-ből, és fűzd hozzá az eredményhez.\n5. Válaszd ki a legnagyobb karaktert s-ből, amely kisebb, mint az utoljára hozzáfűzött karakter az eredményhez, és fűzd hozzá.\n6. Ismételd meg az 5. lépést, amíg nem tudsz több karaktert választani.\n7. Ismételd meg az 1-6. lépéseket, amíg ki nem választod az összes karaktert s-ből.\nMinden lépésben, ha a legkisebb vagy a legnagyobb karakter többször is előfordul, bármelyik előfordulást választhatod, és hozzáfűzheted az eredményhez.\nAdd vissza az eredmény stringet, miután rendezted s-t ezzel az algoritmussal."
    },
    "instruction_bertscore": {
      "sq": "0.976600745222947",
      "hy": "0.9792713306959612",
      "bn": "0.9336584458862526",
      "bg": "0.9829626776971135",
      "zh": "0.9524729142082582",
      "fr": "0.9391424320762447",
      "de": "0.9416084282567929",
      "ha": "0.9539205324252404",
      "hi": "0.9863062229010737",
      "hu": "0.9535723333672863"
    },
    "level": "middle",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "sortString",
    "signature": "public String sortString(String s)",
    "docstring": {
      "en": "Given a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
      "sq": "Duke pasur një varg s. Duhet të riorganizoni vargun duke përdorur algoritmin e mëposhtëm:\n1. Zgjidhni karakterin më të vogël nga s dhe shtojeni atë në rezultat.\n2. Zgjidhni karakterin më të vogël nga s i cili është më i madh se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n3. Përsëritni hapin 2 derisa të mos mund të zgjidhni më shumë karaktere.\n4. Zgjidhni karakterin më të madh nga s dhe shtojeni atë në rezultat.\n5. Zgjidhni karakterin më të madh nga s i cili është më i vogël se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n6. Përsëritni hapin 5 derisa të mos mund të zgjidhni më shumë karaktere.\n7. Përsëritni hapat nga 1 deri në 6 derisa të zgjidhni të gjithë karakteret nga s.\nNë secilin hap, nëse karakteri më i vogël ose më i madh shfaqet më shumë se një herë, mund të zgjidhni çdo paraqitje dhe ta shtoni në rezultat.\nKtheni vargun rezultat pas renditjes së s me këtë algoritëm.",
      "hy": "Տրված է տող s: Դուք պետք է վերադասավորեք տողը հետևյալ ալգորիթմի միջոցով:\n1. Ընտրեք ամենափոքր սիմվոլը s-ից և կցեք այն արդյունքին:\n2. Ընտրեք s-ից ամենափոքր սիմվոլը, որը մեծ է արդյունքին վերջին կցված սիմվոլից, և կցեք այն:\n3. Կրկնեք 2-րդ քայլը, մինչև չկարողանաք ավել սիմվոլներ ընտրել:\n4. Ընտրեք ամենամեծ սիմվոլը s-ից և կցեք այն արդյունքին:\n5. Ընտրեք s-ից ամենամեծ սիմվոլը, որը փոքր է արդյունքին վերջին կցված սիմվոլից, և կցեք այն:\n6. Կրկնեք 5-րդ քայլը, մինչև չկարողանաք ավել սիմվոլներ ընտրել:\n7. Կրկնեք քայլերը 1-ից 6-ը, մինչև ընտրեք s-ի բոլոր սիմվոլները:\nՅուրաքանչյուր քայլում, եթե ամենափոքր կամ ամենամեծ սիմվոլը հայտնվում է մեկից ավելի անգամ, կարող եք ընտրել ցանկացած հանդիպում և կցել այն արդյունքին:\nՎերադարձեք արդյունքի տողը՝ s-ը այս ալգորիթմով դասավորելուց հետո:",
      "bn": "প্রদত্ত একটি স্ট্রিং s। আপনাকে নিম্নলিখিত অ্যালগরিদম ব্যবহার করে স্ট্রিংটি পুনরায় সাজাতে হবে:\n1. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n2. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে বড় এবং এটি যোগ করুন।\n3. ধাপ 2 পুনরাবৃত্তি করুন যতক্ষণ না আপনি আরও অক্ষর বেছে নিতে পারেন।\n4. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n5. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে ছোট এবং এটি যোগ করুন।\n6. ধাপ 5 পুনরাবৃত্তি করুন যতক্ষণ না আপনি আরও অক্ষর বেছে নিতে পারেন।\n7. s থেকে সমস্ত অক্ষর বেছে না নেওয়া পর্যন্ত ধাপ 1 থেকে 6 পুনরাবৃত্তি করুন।\nপ্রতিটি ধাপে, যদি সবচেয়ে ছোট বা সবচেয়ে বড় অক্ষর একাধিকবার উপস্থিত হয়, আপনি যেকোনো একটি উপস্থিতি বেছে নিয়ে ফলাফলে যোগ করতে পারেন।\nএই অ্যালগরিদম দিয়ে s সাজানোর পরে ফলাফল স্ট্রিংটি ফেরত দিন।",
      "bg": "Даден е низ s. Трябва да пренаредите низа, използвайки следния алгоритъм:\n1. Изберете най-малкия символ от s и го добавете към резултата.\n2. Изберете най-малкия символ от s, който е по-голям от последния добавен символ към резултата, и го добавете.\n3. Повторете стъпка 2, докато не можете да изберете повече символи.\n4. Изберете най-големия символ от s и го добавете към резултата.\n5. Изберете най-големия символ от s, който е по-малък от последния добавен символ към резултата, и го добавете.\n6. Повторете стъпка 5, докато не можете да изберете повече символи.\n7. Повторете стъпките от 1 до 6, докато не изберете всички символи от s.\nВъв всяка стъпка, ако най-малкият или най-големият символ се появява повече от веднъж, можете да изберете което и да е появяване и да го добавите към резултата.\nВърнете резултатния низ след сортиране на s с този алгоритъм.",
      "zh": "给定一个字符串 s。你应该使用以下算法重新排序字符串：\n1. 从 s 中选择最小的字符并将其附加到结果中。\n2. 从 s 中选择比结果中最后一个附加字符大的最小字符并附加它。\n3. 重复步骤 2，直到无法选择更多字符。\n4. 从 s 中选择最大的字符并将其附加到结果中。\n5. 从 s 中选择比结果中最后一个附加字符小的最大字符并附加它。\n6. 重复步骤 5，直到无法选择更多字符。\n7. 重复步骤 1 到 6，直到从 s 中选择所有字符。\n在每一步中，如果最小或最大的字符出现多次，你可以选择任何一个出现并将其附加到结果中。\n返回使用此算法排序后的结果字符串。",
      "fr": "Étant donné une chaîne de caractères s. Vous devez réorganiser la chaîne en utilisant l'algorithme suivant :\n1. Choisissez le plus petit caractère de s et ajoutez-le au résultat.\n2. Choisissez le plus petit caractère de s qui est plus grand que le dernier caractère ajouté au résultat et ajoutez-le.\n3. Répétez l'étape 2 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n4. Choisissez le plus grand caractère de s et ajoutez-le au résultat.\n5. Choisissez le plus grand caractère de s qui est plus petit que le dernier caractère ajouté au résultat et ajoutez-le.\n6. Répétez l'étape 5 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n7. Répétez les étapes de 1 à 6 jusqu'à ce que vous ayez choisi tous les caractères de s.\nÀ chaque étape, si le plus petit ou le plus grand caractère apparaît plus d'une fois, vous pouvez choisir n'importe quelle occurrence et l'ajouter au résultat.\nRetournez la chaîne de caractères résultante après avoir trié s avec cet algorithme.",
      "de": "Gegeben ist ein String s. Sie sollten den String mit dem folgenden Algorithmus neu ordnen:\n1. Wähle das kleinste Zeichen aus s und füge es dem Ergebnis hinzu.\n2. Wähle das kleinste Zeichen aus s, das größer ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und füge es hinzu.\n3. Wiederhole Schritt 2, bis du keine weiteren Zeichen mehr auswählen kannst.\n4. Wähle das größte Zeichen aus s und füge es dem Ergebnis hinzu.\n5. Wähle das größte Zeichen aus s, das kleiner ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und füge es hinzu.\n6. Wiederhole Schritt 5, bis du keine weiteren Zeichen mehr auswählen kannst.\n7. Wiederhole die Schritte 1 bis 6, bis du alle Zeichen aus s ausgewählt hast.\nIn jedem Schritt, wenn das kleinste oder das größte Zeichen mehrmals vorkommt, kannst du ein beliebiges Vorkommen auswählen und es dem Ergebnis hinzufügen.\nGib die Ergebniszeichenfolge zurück, nachdem du s mit diesem Algorithmus sortiert hast.",
      "ha": "An ba da wani kirtani s. Ya kamata ka sake tsara kirtanin ta amfani da wannan tsarin:\n1. Zaɓi ƙaramin harafi daga s kuma haɗa shi da sakamakon.\n2. Zaɓi ƙaramin harafi daga s wanda ya fi wanda aka haɗa na ƙarshe girma zuwa sakamakon kuma haɗa shi.\n3. Maimaita mataki na 2 har sai ba za ka iya zaɓar ƙarin haruffa ba.\n4. Zaɓi mafi girman harafi daga s kuma haɗa shi da sakamakon.\n5. Zaɓi mafi girman harafi daga s wanda ya fi wanda aka haɗa na ƙarshe ƙanƙanta zuwa sakamakon kuma haɗa shi.\n6. Maimaita mataki na 5 har sai ba za ka iya zaɓar ƙarin haruffa ba.\n7. Maimaita matakan daga 1 zuwa 6 har sai ka zaɓi duk haruffa daga s.\nA kowane mataki, Idan ƙaramin ko mafi girman harafi ya bayyana fiye da sau ɗaya za ka iya zaɓar kowanne daga ciki ka haɗa shi da sakamakon.\nMayar da kirtanin sakamakon bayan tsara s da wannan tsarin.",
      "hi": "दिया गया एक स्ट्रिंग s. आपको निम्नलिखित एल्गोरिदम का उपयोग करके स्ट्रिंग को पुनः क्रमबद्ध करना चाहिए:\n1. s से सबसे छोटा वर्ण चुनें और उसे परिणाम में जोड़ें।\n2. s से सबसे छोटा वर्ण चुनें जो परिणाम में जोड़े गए अंतिम वर्ण से बड़ा हो और उसे जोड़ें।\n3. चरण 2 को तब तक दोहराएं जब तक आप और वर्ण नहीं चुन सकते।\n4. s से सबसे बड़ा वर्ण चुनें और उसे परिणाम में जोड़ें।\n5. s से सबसे बड़ा वर्ण चुनें जो परिणाम में जोड़े गए अंतिम वर्ण से छोटा हो और उसे जोड़ें।\n6. चरण 5 को तब तक दोहराएं जब तक आप और वर्ण नहीं चुन सकते।\n7. चरण 1 से 6 तक तब तक दोहराएं जब तक आप s से सभी वर्ण नहीं चुन लेते।\nप्रत्येक चरण में, यदि सबसे छोटा या सबसे बड़ा वर्ण एक से अधिक बार आता है तो आप किसी भी आवृत्ति को चुन सकते हैं और उसे परिणाम में जोड़ सकते हैं।\nइस एल्गोरिदम के साथ s को सॉर्ट करने के बाद परिणाम स्ट्रिंग लौटाएं।",
      "hu": "Adott egy s string. Újra kell rendezned a stringet a következő algoritmus segítségével:\n1. Válaszd ki a legkisebb karaktert s-ből, és add hozzá az eredményhez.\n2. Válaszd ki a legkisebb karaktert s-ből, amely nagyobb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n3. Ismételd meg a 2. lépést, amíg nem tudsz több karaktert választani.\n4. Válaszd ki a legnagyobb karaktert s-ből, és add hozzá az eredményhez.\n5. Válaszd ki a legnagyobb karaktert s-ből, amely kisebb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n6. Ismételd meg az 5. lépést, amíg nem tudsz több karaktert választani.\n7. Ismételd meg az 1-től 6-ig terjedő lépéseket, amíg az összes karaktert ki nem választod s-ből.\nMinden lépésben, ha a legkisebb vagy a legnagyobb karakter többször is előfordul, bármelyik előfordulást választhatod, és hozzáadhatod az eredményhez.\nAdd vissza az eredmény stringet, miután ezzel az algoritmussal rendezted s-t."
    },
    "docstring_bertscore": {
      "sq": "0.9353263451958025",
      "hy": "0.9557727607283908",
      "bn": "0.9293765707622834",
      "bg": "0.935596879774772",
      "zh": "0.947194113201875",
      "fr": "0.9269278554248853",
      "de": "0.9323522525005671",
      "ha": "0.9473291818609787",
      "hi": "0.9365516960164068",
      "hu": "0.9380253348133045"
    }
  },
  {
    "task_id": "Java/19",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Kontrolloni nëse është e mundur të ndani vargun e dhënë të numrave të plotë në dy vargje jo bosh\n     * me të njëjtën mesatare.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ստուգել, արդյոք հնարավոր է տրված ամբողջ թվերի զանգվածը բաժանել երկու ոչ դատարկ զանգվածների,\n     * որոնք ունեն նույն միջինը։\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * প্রদত্ত পূর্ণসংখ্যার অ্যারেটি দুটি খালি নয় এমন অ্যারেতে ভাগ করা সম্ভব কিনা তা পরীক্ষা করুন\n     * যাদের গড় একই।\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Проверете дали е възможно да се раздели даденият масив от цели числа на два непразни масива\n     * със същата средна стойност.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 检查是否可以将给定的整数数组拆分为两个具有相同平均值的非空数组。\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Vérifiez s'il est possible de diviser le tableau d'entiers donné en deux tableaux non vides\n     * avec la même moyenne.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Überprüfen, ob es möglich ist, das gegebene Integer-Array in zwei nicht-leere Arrays\n     * mit dem gleichen Durchschnitt aufzuteilen.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duba idan yana yiwuwa a raba jerin lambobin cikakke da aka bayar zuwa jerin lambobi guda biyu\n     * da ke da matsakaici iri ɗaya kuma ba su da komai.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * जाँचें कि क्या दिए गए पूर्णांक array को दो गैर-खाली arrays में समान औसत के साथ विभाजित करना संभव है।\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ellenőrizze, hogy lehetséges-e a megadott egész szám tömböt két nem üres tömbre osztani\n     * ugyanazzal az átlaggal.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "0.9939010541503237",
      "hy": "0.9839937680050655",
      "bn": "0.9857162906694001",
      "bg": "0.984309590310911",
      "zh": "0.9773072734882882",
      "fr": "0.9939010541503237",
      "de": "1",
      "ha": "0.9673680078516834",
      "hi": "0.9942595819880917",
      "hu": "1"
    },
    "canonical_solution": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "en": "Write a Java function `public boolean splitArraySameAverage(int[] nums)` to solve the following problem:\nCheck if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "sq": "Shkruani një funksion Java `public boolean splitArraySameAverage(int[] nums)` për të zgjidhur problemin në vijim:  \nKontrolloni nëse është e mundur të ndahet vargu i dhënë i numrave të plotë në dy vargje jo-bosh  \nme të njëjtën mesatare.",
      "hy": "Գրեք Java ֆունկցիա `public boolean splitArraySameAverage(int[] nums)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք հնարավոր է տրված ամբողջ թվերի զանգվածը բաժանել երկու ոչ դատարկ զանգվածների, որոնք ունեն նույն միջին արժեքը:\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "bn": "একটি জাভা ফাংশন `public boolean splitArraySameAverage(int[] nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করুন যে প্রদত্ত পূর্ণসংখ্যার অ্যারেটিকে দুটি খালি নয় এমন অ্যারেতে ভাগ করা সম্ভব কিনা\nযাদের গড় একই।\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "bg": "Напишете Java функция `public boolean splitArraySameAverage(int[] nums)`, за да решите следния проблем:  \nПроверете дали е възможно да се раздели даденият масив от цели числа на два непразни масива със същата средна стойност.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})  \ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})  \nfalse",
      "zh": "编写一个Java函数 `public boolean splitArraySameAverage(int[] nums)` 来解决以下问题：  \n检查是否可以将给定的整数数组拆分为两个具有相同平均值的非空数组。\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})  \ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})  \nfalse",
      "fr": "Écrire une fonction Java `public boolean splitArraySameAverage(int[] nums)` pour résoudre le problème suivant :  \nVérifier s'il est possible de diviser le tableau d'entiers donné en deux tableaux non vides avec la même moyenne.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})  \ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})  \nfalse",
      "de": "Schreiben Sie eine Java-Funktion `public boolean splitArraySameAverage(int[] nums)`, um das folgende Problem zu lösen:\nÜberprüfen Sie, ob es möglich ist, das gegebene ganzzahlige Array in zwei nicht-leere Arrays mit demselben Durchschnitt aufzuteilen.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "ha": "Rubuta wani aikin Java `public boolean splitArraySameAverage(int[] nums)` don warware matsalar mai zuwa:  \nDuba idan yana yiwuwa a raba jerin lambobin cikakken lamba da aka bayar zuwa jerin lambobi guda biyu wadanda ba su da komai  \ntare da matsakaicin daraja iri daya.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})  \ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})  \nfalse",
      "hi": "Java फ़ंक्शन `public boolean splitArraySameAverage(int[] nums)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँचें कि क्या दिए गए पूर्णांक array को दो गैर-खाली arrays में विभाजित करना संभव है\nजिनका औसत समान हो।\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hu": "Írj egy Java függvényt `public boolean splitArraySameAverage(int[] nums)` a következő probléma megoldására:\nEllenőrizd, hogy lehetséges-e a megadott egész szám tömböt két nem üres tömbre osztani\nugyanazzal az átlaggal.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse"
    },
    "instruction_bertscore": {
      "sq": "0.8301926749267035",
      "hy": "0.9752319832672357",
      "bn": "0.9871575527141893",
      "bg": "0.9919467298313215",
      "zh": "0.9864909491554362",
      "fr": "0.994033540614474",
      "de": "0.834318227940798",
      "ha": "0.9674943367740216",
      "hi": "0.9802505784744632",
      "hu": "1"
    },
    "level": "hard",
    "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "splitArraySameAverage",
    "signature": "public boolean splitArraySameAverage(int[] nums)",
    "docstring": {
      "en": "Check if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "sq": "Kontrolloni nëse është e mundur të ndani vargun e dhënë të numrave të plotë në dy vargje jo bosh\nme mesatare të njëjtë.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hy": "Ստուգեք, արդյոք հնարավոր է տրված ամբողջ թվերի զանգվածը բաժանել երկու ոչ դատարկ զանգվածների՝\nնույն միջինով։\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "bn": "প্রদত্ত পূর্ণসংখ্যার অ্যারে দুটি খালি নয় এমন অ্যারেতে ভাগ করা সম্ভব কিনা তা পরীক্ষা করুন\nযাদের গড় একই।\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "bg": "Проверете дали е възможно да се раздели даденият масив от цели числа на два непразни масива със същата средна стойност.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "zh": "检查是否可以将给定的整数数组分割成两个具有相同平均值的非空数组。\n\nArgs:\n    new int[]{1,2,3,4,5,6,7,8}\n\nReturns:\n    true\n\nArgs:\n    new int[]{3,1}\n\nReturns:\n    false",
      "fr": "Vérifiez s'il est possible de diviser le tableau d'entiers donné en deux tableaux non vides avec la même moyenne.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "de": "Prüfen Sie, ob es möglich ist, das gegebene ganzzahlige Array in zwei nicht-leere Arrays mit demselben Durchschnitt aufzuteilen.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "ha": "Duba ko yana yiwuwa a raba jerin lambobin cikakkun lambobi da aka bayar zuwa cikin jerin lambobi guda biyu masu cike da lambobi ba tare da komai ba tare da matsakaici iri ɗaya.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hi": "जाँचें कि दिए गए पूर्णांक सरणी को दो गैर-खाली सरणियों में विभाजित करना संभव है या नहीं जिनका औसत समान हो।\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hu": "Ellenőrizze, hogy lehetséges-e a megadott egész szám tömböt két nem üres tömbre osztani\nugyanazzal az átlaggal.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse"
    },
    "docstring_bertscore": {
      "sq": "0.9919820860391457",
      "hy": "0.9919820860391457",
      "bn": "0.9765534711922608",
      "bg": "0.9809318806814128",
      "zh": "0.8546200405559929",
      "fr": "0.9919820860391457",
      "de": "1",
      "ha": "0.9583970653226237",
      "hi": "1",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/20",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg të plotë cost ku cost[i] është kostoja e hapit të i-të në një shkallë,\n     * kthe minimumin e kostos për të arritur në majë të katit.\n     * Mund të filloni ose nga hapi me indeks 0 ose nga hapi me indeks 1.\n     *\n     * Shembull:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Shpjegim: Do të filloni në indeksin 1.\n     * - Paguani 15 dhe ngjitni dy hapa për të arritur në majë.\n     * Kostoja totale është 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Shpjegim: Do të filloni në indeksin 0.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 2.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 4.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 6.\n     * - Paguani 1 dhe ngjitni një hap për të arritur në indeksin 7.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 9.\n     * - Paguani 1 dhe ngjitni një hap për të arritur në majë.\n     * Kostoja totale është 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "hy": "class Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված cost, որտեղ cost[i]-ն աստիճանավանդակի i-րդ աստիճանի արժեքն է,\n     * վերադարձնել նվազագույն արժեքը, որպեսզի հասնենք հարկի գագաթին։\n     * Դուք կարող եք սկսել կամ 0 ինդեքսով աստիճանից կամ 1 ինդեքսով աստիճանից։\n     *\n     * Օրինակ:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Բացատրություն: Դուք կսկսեք 1 ինդեքսից։\n     * - Վճարեք 15 և բարձրացեք երկու աստիճան՝ հասնելու գագաթին։\n     * Ընդհանուր արժեքը 15 է։\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Բացատրություն: Դուք կսկսեք 0 ինդեքսից։\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 2 ինդեքսին։\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 4 ինդեքսին։\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 6 ինդեքսին։\n     * - Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու 7 ինդեքսին։\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 9 ինդեքսին։\n     * - Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու գագաթին։\n     * Ընդհանուր արժեքը 6 է։\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "bn": "class Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যেখানে cost[i] হল সিঁড়ির ith ধাপের খরচ,\n     * মেঝের শীর্ষে পৌঁছানোর জন্য ন্যূনতম খরচ ফেরত দিন।\n     * আপনি হয় 0 সূচকের ধাপ থেকে বা 1 সূচকের ধাপ থেকে শুরু করতে পারেন।\n     *\n     * উদাহরণ:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * ব্যাখ্যা: আপনি সূচক 1 থেকে শুরু করবেন।\n     * - 15 পরিশোধ করুন এবং শীর্ষে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * মোট খরচ হল 15।\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * ব্যাখ্যা: আপনি সূচক 0 থেকে শুরু করবেন।\n     * - 1 পরিশোধ করুন এবং সূচক 2 তে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 পরিশোধ করুন এবং সূচক 4 তে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 পরিশোধ করুন এবং সূচক 6 তে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 পরিশোধ করুন এবং সূচক 7 তে পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n     * - 1 পরিশোধ করুন এবং সূচক 9 তে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 পরিশোধ করুন এবং শীর্ষে পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n     * মোট খরচ হল 6।\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "bg": "class Solution {\n    /**\n     * Като се даде масив от цели числа cost, където cost[i] е цената на i-тата стъпка на стълбище,\n     * върнете минималната цена за достигане до върха на етажа.\n     * Можете да започнете или от стъпката с индекс 0, или от стъпката с индекс 1.\n     *\n     * Пример:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Обяснение: Ще започнете от индекс 1.\n     * - Платете 15 и се изкачете две стъпки, за да достигнете върха.\n     * Общата цена е 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Обяснение: Ще започнете от индекс 0.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 2.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 4.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 6.\n     * - Платете 1 и се изкачете една стъпка, за да достигнете индекс 7.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 9.\n     * - Платете 1 и се изкачете една стъпка, за да достигнете върха.\n     * Общата цена е 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "zh": "class Solution {\n    /**\n     * 给定一个整数数组 cost，其中 cost[i] 是楼梯上第 i 阶的成本，\n     * 返回到达楼层顶部的最低成本。\n     * 你可以从索引为 0 的阶梯开始，或者从索引为 1 的阶梯开始。\n     *\n     * 示例：\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * 解释：你将从索引 1 开始。\n     * - 支付 15 并爬两阶到达顶部。\n     * 总成本是 15。\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * 解释：你将从索引 0 开始。\n     * - 支付 1 并爬两阶到达索引 2。\n     * - 支付 1 并爬两阶到达索引 4。\n     * - 支付 1 并爬两阶到达索引 6。\n     * - 支付 1 并爬一阶到达索引 7。\n     * - 支付 1 并爬两阶到达索引 9。\n     * - 支付 1 并爬一阶到达顶部。\n     * 总成本是 6。\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un tableau d'entiers cost où cost[i] est le coût de la ième marche d'un escalier,\n     * renvoie le coût minimum pour atteindre le sommet de l'étage.\n     * Vous pouvez commencer soit à partir de la marche avec l'indice 0, soit à partir de la marche avec l'indice 1.\n     *\n     * Exemple:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explication : Vous commencerez à l'indice 1.\n     * - Payez 15 et montez deux marches pour atteindre le sommet.\n     * Le coût total est de 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explication : Vous commencerez à l'indice 0.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 2.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 4.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 6.\n     * - Payez 1 et montez une marche pour atteindre l'indice 7.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 9.\n     * - Payez 1 et montez une marche pour atteindre le sommet.\n     * Le coût total est de 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein ganzzahliges Array cost, wobei cost[i] die Kosten der i-ten Stufe auf einer Treppe sind,\n     * gib die minimalen Kosten zurück, um die Spitze des Stockwerks zu erreichen.\n     * Du kannst entweder von der Stufe mit Index 0 oder der Stufe mit Index 1 starten.\n     *\n     * Beispiel:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Erklärung: Du wirst bei Index 1 starten.\n     * - Zahle 15 und klettere zwei Stufen, um die Spitze zu erreichen.\n     * Die Gesamtkosten sind 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Erklärung: Du wirst bei Index 0 starten.\n     * - Zahle 1 und klettere zwei Stufen, um Index 2 zu erreichen.\n     * - Zahle 1 und klettere zwei Stufen, um Index 4 zu erreichen.\n     * - Zahle 1 und klettere zwei Stufen, um Index 6 zu erreichen.\n     * - Zahle 1 und klettere eine Stufe, um Index 7 zu erreichen.\n     * - Zahle 1 und klettere zwei Stufen, um Index 9 zu erreichen.\n     * - Zahle 1 und klettere eine Stufe, um die Spitze zu erreichen.\n     * Die Gesamtkosten sind 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "ha": "class Solution {\n    /**\n     * An ba da wani tsararren lamba mai suna cost inda cost[i] shine kudin mataki na i akan matakala,\n     * dawo da mafi ƙarancin kuɗi don isa saman bene.\n     * Kuna iya farawa daga matakin da ke da alamar 0 ko matakin da ke da alamar 1.\n     *\n     * Misali:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Bayani: Za ku fara a alamar 1.\n     * - Biya 15 kuma hau matakai biyu don isa saman.\n     * Jimlar kudin shine 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Bayani: Za ku fara a alamar 0.\n     * - Biya 1 kuma hau matakai biyu don isa alamar 2.\n     * - Biya 1 kuma hau matakai biyu don isa alamar 4.\n     * - Biya 1 kuma hau matakai biyu don isa alamar 6.\n     * - Biya 1 kuma hau mataki daya don isa alamar 7.\n     * - Biya 1 kuma hau matakai biyu don isa alamar 9.\n     * - Biya 1 kuma hau mataki daya don isa saman.\n     * Jimlar kudin shine 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक पूर्णांक सरणी cost जहाँ cost[i] सीढ़ी पर ith चरण की लागत है,\n     * शीर्ष तक पहुँचने के लिए न्यूनतम लागत लौटाएँ।\n     * आप या तो सूचकांक 0 वाले चरण से या सूचकांक 1 वाले चरण से शुरू कर सकते हैं।\n     *\n     * उदाहरण:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * व्याख्या: आप सूचकांक 1 पर शुरू करेंगे।\n     * - 15 का भुगतान करें और शीर्ष पर पहुँचने के लिए दो चरण चढ़ें।\n     * कुल लागत 15 है।\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * व्याख्या: आप सूचकांक 0 पर शुरू करेंगे।\n     * - 1 का भुगतान करें और सूचकांक 2 तक पहुँचने के लिए दो चरण चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 4 तक पहुँचने के लिए दो चरण चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 6 तक पहुँचने के लिए दो चरण चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 7 तक पहुँचने के लिए एक चरण चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 9 तक पहुँचने के लिए दो चरण चढ़ें।\n     * - 1 का भुगतान करें और शीर्ष तक पहुँचने के लिए एक चरण चढ़ें।\n     * कुल लागत 6 है।\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "hu": "class Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb, cost, ahol cost[i] az i-edik lépcsőfok költsége egy lépcsőn,\n     * adja vissza a minimális költséget a lépcső tetejére való feljutáshoz.\n     * Kezdhet a 0. indexű vagy az 1. indexű lépcsőfokról.\n     *\n     * Példa:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Magyarázat: Az 1. indexnél fog kezdeni.\n     * - Fizet 15-öt és két lépést mászik, hogy elérje a tetejét.\n     * A teljes költség 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Magyarázat: A 0. indexnél fog kezdeni.\n     * - Fizet 1-et és két lépést mászik, hogy elérje a 2. indexet.\n     * - Fizet 1-et és két lépést mászik, hogy elérje a 4. indexet.\n     * - Fizet 1-et és két lépést mászik, hogy elérje a 6. indexet.\n     * - Fizet 1-et és egy lépést mászik, hogy elérje a 7. indexet.\n     * - Fizet 1-et és két lépést mászik, hogy elérje a 9. indexet.\n     * - Fizet 1-et és egy lépést mászik, hogy elérje a tetejét.\n     * A teljes költség 6.\n     */\n  public int minCostClimbingStairs(int[] cost) "
    },
    "prompt_bertscore": {
      "sq": "0.9863129763340289",
      "hy": "0.9854956123160704",
      "bn": "0.9937604238405511",
      "bg": "0.9691979895521579",
      "zh": "0.9779341509708342",
      "fr": "0.9719086983621409",
      "de": "0.9811952645666651",
      "ha": "0.9482174569249667",
      "hi": "0.9849571253530848",
      "hu": "0.939416939262835"
    },
    "canonical_solution": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }",
    "instruction": {
      "en": "Write a Java function `public int minCostClimbingStairs(int[] cost)` to solve the following problem:\nGiven an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.",
      "sq": "Shkruani një funksion Java `public int minCostClimbingStairs(int[] cost)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg të plotë cost ku cost[i] është kostoja e hapit të i-të në një shkallë,\nkthejeni koston minimale për të arritur majën e katit.\nJu mund të filloni ose nga hapi me indeks 0 ose nga hapi me indeks 1.\n\nShembull:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nShpjegim: Ju do të filloni në indeksin 1.\n- Paguani 15 dhe ngjitni dy hapa për të arritur majën.\nKostoja totale është 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nShpjegim: Ju do të filloni në indeksin 0.\n- Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 2.\n- Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 4.\n- Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 6.\n- Paguani 1 dhe ngjitni një hap për të arritur indeksin 7.\n- Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 9.\n- Paguani 1 dhe ngjitni një hap për të arritur majën.\nKostoja totale është 6.",
      "hy": "Գրեք Java ֆունկցիա `public int minCostClimbingStairs(int[] cost)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի զանգված cost, որտեղ cost[i]-ն աստիճանների i-րդ աստիճանի արժեքն է,\nվերադարձնել նվազագույն արժեքը՝ հասնելու համար հարկի գագաթին:\nԴուք կարող եք սկսել կամ 0 ինդեքսով աստիճանից, կամ 1 ինդեքսով աստիճանից:\n\nՕրինակ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nԲացատրություն: Դուք կսկսեք 1 ինդեքսից:\n- Վճարեք 15 և բարձրացեք երկու աստիճան՝ հասնելու համար գագաթին:\nԸնդհանուր արժեքը 15 է:\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nԲացատրություն: Դուք կսկսեք 0 ինդեքսից:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու համար 2 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու համար 4 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու համար 6 ինդեքսին:\n- Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու համար 7 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու համար 9 ինդեքսին:\n- Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու համար գագաթին:\nԸնդհանուր արժեքը 6 է:",
      "bn": "একটি জাভা ফাংশন `public int minCostClimbingStairs(int[] cost)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যেখানে cost[i] হল সিঁড়ির ith ধাপের খরচ,\nফ্লোরের উপরে পৌঁছানোর জন্য ন্যূনতম খরচ ফেরত দিন।\nআপনি হয়তো সূচক 0 সহ ধাপ থেকে অথবা সূচক 1 সহ ধাপ থেকে শুরু করতে পারেন।\n\nউদাহরণ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nব্যাখ্যা: আপনি সূচক 1 এ শুরু করবেন।\n- 15 প্রদান করুন এবং উপরে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\nমোট খরচ 15।\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nব্যাখ্যা: আপনি সূচক 0 এ শুরু করবেন।\n- 1 প্রদান করুন এবং সূচক 2 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 4 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 6 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 7 এ পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 9 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং উপরে পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\nমোট খরচ 6।",
      "bg": "Напишете Java функция `public int minCostClimbingStairs(int[] cost)`, за да решите следния проблем:\nДаден е масив от цели числа cost, където cost[i] е цената на i-тото стъпало на стълбище,\nвърнете минималната цена за достигане до върха на етажа.\nМожете да започнете или от стъпалото с индекс 0, или от стъпалото с индекс 1.\n\nПример:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nОбяснение: Ще започнете от индекс 1.\n- Платете 15 и се изкачете две стъпала, за да достигнете върха.\nОбщата цена е 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nОбяснение: Ще започнете от индекс 0.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 2.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 4.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 6.\n- Платете 1 и се изкачете едно стъпало, за да достигнете индекс 7.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 9.\n- Платете 1 и се изкачете едно стъпало, за да достигнете върха.\nОбщата цена е 6.",
      "zh": "编写一个 Java 函数 `public int minCostClimbingStairs(int[] cost)` 来解决以下问题：\n给定一个整数数组 cost，其中 cost[i] 是楼梯上第 i 阶的成本，\n返回到达楼层顶部的最低成本。\n您可以从索引为 0 的台阶或索引为 1 的台阶开始。\n\n示例：\n>>> minCostClimbingStairs([10, 15, 20])\n15\n解释：您将从索引 1 开始。\n- 支付 15 并爬两步到达顶部。\n总成本是 15。\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\n解释：您将从索引 0 开始。\n- 支付 1 并爬两步到达索引 2。\n- 支付 1 并爬两步到达索引 4。\n- 支付 1 并爬两步到达索引 6。\n- 支付 1 并爬一步到达索引 7。\n- 支付 1 并爬两步到达索引 9。\n- 支付 1 并爬一步到达顶部。\n总成本是 6。",
      "fr": "Écrire une fonction Java `public int minCostClimbingStairs(int[] cost)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers cost où cost[i] est le coût de la i-ème marche d'un escalier,  \nretourner le coût minimum pour atteindre le sommet de l'étage.  \nVous pouvez soit commencer à partir de la marche avec l'indice 0, soit à partir de la marche avec l'indice 1.\n\nExemple :\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplication : Vous commencerez à l'indice 1.\n- Payez 15 et montez deux marches pour atteindre le sommet.\nLe coût total est de 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplication : Vous commencerez à l'indice 0.\n- Payez 1 et montez deux marches pour atteindre l'indice 2.\n- Payez 1 et montez deux marches pour atteindre l'indice 4.\n- Payez 1 et montez deux marches pour atteindre l'indice 6.\n- Payez 1 et montez une marche pour atteindre l'indice 7.\n- Payez 1 et montez deux marches pour atteindre l'indice 9.\n- Payez 1 et montez une marche pour atteindre le sommet.\nLe coût total est de 6.",
      "de": "Schreiben Sie eine Java-Funktion `public int minCostClimbingStairs(int[] cost)`, um das folgende Problem zu lösen:\nGegeben ein ganzzahliges Array cost, wobei cost[i] die Kosten der i-ten Stufe auf einer Treppe sind,\ngeben Sie die minimalen Kosten zurück, um die Spitze des Stockwerks zu erreichen.\nSie können entweder von der Stufe mit Index 0 oder der Stufe mit Index 1 starten.\n\nBeispiel:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nErläuterung: Sie werden bei Index 1 starten.\n- Zahlen Sie 15 und steigen Sie zwei Stufen, um die Spitze zu erreichen.\nDie Gesamtkosten betragen 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nErläuterung: Sie werden bei Index 0 starten.\n- Zahlen Sie 1 und steigen Sie zwei Stufen, um Index 2 zu erreichen.\n- Zahlen Sie 1 und steigen Sie zwei Stufen, um Index 4 zu erreichen.\n- Zahlen Sie 1 und steigen Sie zwei Stufen, um Index 6 zu erreichen.\n- Zahlen Sie 1 und steigen Sie eine Stufe, um Index 7 zu erreichen.\n- Zahlen Sie 1 und steigen Sie zwei Stufen, um Index 9 zu erreichen.\n- Zahlen Sie 1 und steigen Sie eine Stufe, um die Spitze zu erreichen.\nDie Gesamtkosten betragen 6.",
      "ha": "Rubuta aikin Java `public int minCostClimbingStairs(int[] cost)` don warware matsalar mai zuwa:\nAn ba da jerin lambobi na tsada inda cost[i] shine kudin matakin na i akan matakala,\nmayar da mafi ƙarancin tsada don isa saman bene.\nZa ka iya fara daga matakin da ke da alamar 0 ko matakin da ke da alamar 1.\n\nMisali:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nBayani: Za ka fara a alamar 1.\n- Biya 15 kuma hau matakai biyu don isa saman.\nJimlar kudin shine 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nBayani: Za ka fara a alamar 0.\n- Biya 1 kuma hau matakai biyu don isa alamar 2.\n- Biya 1 kuma hau matakai biyu don isa alamar 4.\n- Biya 1 kuma hau matakai biyu don isa alamar 6.\n- Biya 1 kuma hau mataki daya don isa alamar 7.\n- Biya 1 kuma hau matakai biyu don isa alamar 9.\n- Biya 1 kuma hau mataki daya don isa saman.\nJimlar kudin shine 6.",
      "hi": "Java फ़ंक्शन `public int minCostClimbingStairs(int[] cost)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक ऐरे दिया गया है जहाँ cost[i] सीढ़ी पर ith कदम की लागत है,\nमंजिल के शीर्ष तक पहुँचने के लिए न्यूनतम लागत लौटाएं।\nआप या तो सूचकांक 0 वाले कदम से या सूचकांक 1 वाले कदम से शुरू कर सकते हैं।\n\nउदाहरण:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nव्याख्या: आप सूचकांक 1 पर शुरू करेंगे।\n- 15 का भुगतान करें और शीर्ष तक पहुँचने के लिए दो कदम चढ़ें।\nकुल लागत 15 है।\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nव्याख्या: आप सूचकांक 0 पर शुरू करेंगे।\n- 1 का भुगतान करें और सूचकांक 2 तक पहुँचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और सूचकांक 4 तक पहुँचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और सूचकांक 6 तक पहुँचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और सूचकांक 7 तक पहुँचने के लिए एक कदम चढ़ें।\n- 1 का भुगतान करें और सूचकांक 9 तक पहुँचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और शीर्ष तक पहुँचने के लिए एक कदम चढ़ें।\nकुल लागत 6 है।",
      "hu": "Írj egy Java függvényt `public int minCostClimbingStairs(int[] cost)` a következő probléma megoldására:\nAdott egy egész számokat tartalmazó tömb, `cost`, ahol `cost[i]` az i-edik lépcsőfok költsége egy lépcsőn,\nadd vissza a minimális költséget, hogy elérd a lépcső tetejét.\nElindulhatsz vagy a 0. indexű lépcsőfokról, vagy az 1. indexű lépcsőfokról.\n\nPélda:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nMagyarázat: Az 1. indexnél fogsz elindulni.\n- Fizess 15-öt és mássz fel két lépcsőfokot, hogy elérd a tetejét.\nA teljes költség 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nMagyarázat: A 0. indexnél fogsz elindulni.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 2. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 4. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 6. indexet.\n- Fizess 1-et és mássz fel egy lépcsőfokot, hogy elérd a 7. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 9. indexet.\n- Fizess 1-et és mássz fel egy lépcsőfokot, hogy elérd a tetejét.\nA teljes költség 6."
    },
    "instruction_bertscore": {
      "sq": "0.9875190600076728",
      "hy": "0.9700497166260355",
      "bn": "0.9906866186940362",
      "bg": "0.970554039163483",
      "zh": "0.9816256966023676",
      "fr": "0.9736330086999048",
      "de": "0.9821022108864703",
      "ha": "0.9844128781090492",
      "hi": "0.985954051235499",
      "hu": "0.9547241909469076"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "minCostClimbingStairs",
    "signature": "public int minCostClimbingStairs(int[] cost)",
    "docstring": {
      "en": "Given an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.",
      "sq": "Duke pasur një varg të plotë cost ku cost[i] është kostoja e hapit të i-të në një shkallë, kthe minimumin e kostos për të arritur në majë të katit. Ju mund të filloni ose nga hapi me indeks 0 ose hapi me indeks 1.\n\nShembull:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nShpjegim: Ju do të filloni në indeksin 1.\n- Paguani 15 dhe ngjitni dy hapa për të arritur në majë.\nKostoja totale është 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nShpjegim: Ju do të filloni në indeksin 0.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 2.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 4.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 6.\n- Paguani 1 dhe ngjitni një hap për të arritur në indeksin 7.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 9.\n- Paguani 1 dhe ngjitni një hap për të arritur në majë.\nKostoja totale është 6.",
      "hy": "Տրված է ամբողջ թվերի զանգված cost, որտեղ cost[i]-ն աստիճանավանդակի i-րդ աստիճանի արժեքն է, վերադարձնել նվազագույն արժեքը, որպեսզի հասնեք հարկի գագաթը: Դուք կարող եք սկսել կամ 0 ինդեքսով աստիճանից կամ 1 ինդեքսով աստիճանից:\n\nՕրինակ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nԲացատրություն: Դուք կսկսեք 1 ինդեքսից:\n- Վճարեք 15 և բարձրացեք երկու աստիճան՝ հասնելու գագաթին:\nԸնդհանուր արժեքը 15 է:\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nԲացատրություն: Դուք կսկսեք 0 ինդեքսից:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 2 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 4 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 6 ինդեքսին:\n- Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու 7 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 9 ինդեքսին:\n- Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու գագաթին:\nԸնդհանուր արժեքը 6 է:",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যেখানে cost[i] হল সিঁড়ির ith ধাপের খরচ, মেঝের শীর্ষে পৌঁছানোর জন্য সর্বনিম্ন খরচ ফেরত দিন। আপনি হয়তো সূচক 0 সহ ধাপ থেকে বা সূচক 1 সহ ধাপ থেকে শুরু করতে পারেন।\n\nউদাহরণ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nব্যাখ্যা: আপনি সূচক 1 এ শুরু করবেন।\n- 15 প্রদান করুন এবং শীর্ষে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\nমোট খরচ 15।\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nব্যাখ্যা: আপনি সূচক 0 এ শুরু করবেন।\n- 1 প্রদান করুন এবং সূচক 2 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 4 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 6 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 7 এ পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 9 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং শীর্ষে পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\nমোট খরচ 6।",
      "bg": "Даден е масив от цели числа cost, където cost[i] е цената на i-тото стъпало на стълбище, върнете минималната цена за достигане до върха на етажа. Можете да започнете или от стъпалото с индекс 0, или от стъпалото с индекс 1.\n\nПример:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nОбяснение: Ще започнете от индекс 1.\n- Платете 15 и се изкачете две стъпала, за да достигнете върха.\nОбщата цена е 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nОбяснение: Ще започнете от индекс 0.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 2.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 4.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 6.\n- Платете 1 и се изкачете едно стъпало, за да достигнете индекс 7.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 9.\n- Платете 1 и се изкачете едно стъпало, за да достигнете върха.\nОбщата цена е 6.",
      "zh": "给定一个整数数组 cost，其中 cost[i] 是楼梯上第 i 阶的成本，返回到达楼层顶部的最低成本。你可以从索引为 0 的台阶开始，或者从索引为 1 的台阶开始。\n\n示例：\n>>> minCostClimbingStairs([10, 15, 20])\n15\n解释：你将从索引 1 开始。\n- 支付 15 并爬两步到达顶部。\n总成本是 15。\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\n解释：你将从索引 0 开始。\n- 支付 1 并爬两步到达索引 2。\n- 支付 1 并爬两步到达索引 4。\n- 支付 1 并爬两步到达索引 6。\n- 支付 1 并爬一步到达索引 7。\n- 支付 1 并爬两步到达索引 9。\n- 支付 1 并爬一步到达顶部。\n总成本是 6。",
      "fr": "Étant donné un tableau d'entiers `cost` où `cost[i]` est le coût de la i-ème marche d'un escalier, renvoyez le coût minimum pour atteindre le sommet de l'étage. Vous pouvez commencer soit à partir de la marche avec l'indice 0, soit à partir de la marche avec l'indice 1.\n\nExemple :\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplication : Vous commencerez à l'indice 1.\n- Payez 15 et montez deux marches pour atteindre le sommet.\nLe coût total est de 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplication : Vous commencerez à l'indice 0.\n- Payez 1 et montez deux marches pour atteindre l'indice 2.\n- Payez 1 et montez deux marches pour atteindre l'indice 4.\n- Payez 1 et montez deux marches pour atteindre l'indice 6.\n- Payez 1 et montez une marche pour atteindre l'indice 7.\n- Payez 1 et montez deux marches pour atteindre l'indice 9.\n- Payez 1 et montez une marche pour atteindre le sommet.\nLe coût total est de 6.",
      "de": "Gegeben ein ganzzahliges Array cost, wobei cost[i] die Kosten der i-ten Stufe auf einer Treppe sind, gib die minimalen Kosten zurück, um die Spitze des Stockwerks zu erreichen. Du kannst entweder von der Stufe mit Index 0 oder der Stufe mit Index 1 starten.\n\nBeispiel:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nErläuterung: Du wirst bei Index 1 starten.\n- Zahle 15 und klettere zwei Stufen, um die Spitze zu erreichen.\nDie Gesamtkosten sind 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nErläuterung: Du wirst bei Index 0 starten.\n- Zahle 1 und klettere zwei Stufen, um Index 2 zu erreichen.\n- Zahle 1 und klettere zwei Stufen, um Index 4 zu erreichen.\n- Zahle 1 und klettere zwei Stufen, um Index 6 zu erreichen.\n- Zahle 1 und klettere eine Stufe, um Index 7 zu erreichen.\n- Zahle 1 und klettere zwei Stufen, um Index 9 zu erreichen.\n- Zahle 1 und klettere eine Stufe, um die Spitze zu erreichen.\nDie Gesamtkosten sind 6.",
      "ha": "An ba da jerin lambobi na tsada inda cost[i] shine kudin matakin na i akan matakala,\nmayar da mafi ƙarancin tsada don isa saman bene.\nZa ka iya fara daga matakin da ke da alamar 0 ko matakin da ke da alamar 1.\n\nMisali:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nBayani: Za ka fara a mataki na 1.\n- Biya 15 kuma hau matakai biyu don isa saman.\nJimillar kuɗin shine 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nBayani: Za ka fara a mataki na 0.\n- Biya 1 kuma hau matakai biyu don isa mataki na 2.\n- Biya 1 kuma hau matakai biyu don isa mataki na 4.\n- Biya 1 kuma hau matakai biyu don isa mataki na 6.\n- Biya 1 kuma hau mataki daya don isa mataki na 7.\n- Biya 1 kuma hau matakai biyu don isa mataki na 9.\n- Biya 1 kuma hau mataki daya don isa saman.\nJimillar kuɗin shine 6.",
      "hi": "एक पूर्णांक ऐरे दिया गया है जहाँ cost[i] सीढ़ी पर ith कदम की लागत है,\nमंजिल के शीर्ष तक पहुँचने के लिए न्यूनतम लागत लौटाएं।\nआप या तो सूचकांक 0 वाले कदम से या सूचकांक 1 वाले कदम से शुरू कर सकते हैं।\n\nउदाहरण:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nव्याख्या: आप इंडेक्स 1 से शुरू करेंगे।\n- 15 का भुगतान करें और शीर्ष पर पहुंचने के लिए दो कदम चढ़ें।\nकुल लागत 15 है।\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nव्याख्या: आप इंडेक्स 0 से शुरू करेंगे।\n- 1 का भुगतान करें और इंडेक्स 2 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 4 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 6 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 7 तक पहुंचने के लिए एक कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 9 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और शीर्ष पर पहुंचने के लिए एक कदम चढ़ें।\nकुल लागत 6 है।",
      "hu": "Adott egy egész számokat tartalmazó tömb, `cost`, ahol `cost[i]` az i-edik lépcsőfok költsége egy lépcsőházban. Térj vissza a legkisebb költséggel, amellyel elérheted az emelet tetejét. Kezdhetsz vagy a 0. indexű, vagy az 1. indexű lépcsőfokról.\n\nPélda:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nMagyarázat: Az 1. indexnél fogsz kezdeni.\n- Fizess 15-öt és mássz fel két lépcsőfokot, hogy elérd a tetejét.\nA teljes költség 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nMagyarázat: A 0. indexnél fogsz kezdeni.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 2. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 4. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 6. indexet.\n- Fizess 1-et és mássz fel egy lépcsőfokot, hogy elérd a 7. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 9. indexet.\n- Fizess 1-et és mássz fel egy lépcsőfokot, hogy elérd a tetejét.\nA teljes költség 6."
    },
    "docstring_bertscore": {
      "sq": "0.978229117086671",
      "hy": "0.9686100436242946",
      "bn": "0.9769048483363115",
      "bg": "0.9651745325539152",
      "zh": "0.9726340965136804",
      "fr": "0.9663305613715382",
      "de": "0.9778400001702238",
      "ha": "0.9820881081294169",
      "hi": "0.998582374970554",
      "hu": "0.946994489668935"
    }
  },
  {
    "task_id": "Java/21",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg të fjalëve strings ku secila fjalë mund të shkruhet si një bashkim i kodit Morse të secilës shkronjë,\n     * kthe numrin e transformimeve të ndryshme midis të gjitha fjalëve.\n     *\n     * Shembull:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է բառերի զանգված, որտեղ յուրաքանչյուր բառ կարող է գրվել որպես յուրաքանչյուր տառի Մորզեի կոդի միացում,\n     * վերադարձնել տարբեր փոխակերպումների քանակը բոլոր բառերի մեջ:\n     *\n     * Օրինակ:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি স্ট্রিং এর অ্যারে দেওয়া আছে words যেখানে প্রতিটি শব্দকে প্রতিটি অক্ষরের মোরস কোডের সংযোজন হিসেবে লেখা যেতে পারে,\n     * সমস্ত শব্দের মধ্যে বিভিন্ন রূপান্তরের সংখ্যা ফেরত দিন।\n     *\n     * উদাহরণ:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е масив от низове words, където всяка дума може да бъде написана като конкатенация на Морзовия код на всяка буква,\n     * върнете броя на различните трансформации сред всички думи.\n     *\n     * Пример:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个字符串数组 words，其中每个单词可以写成每个字母的摩尔斯密码的连接，\n     * 返回所有单词中不同转换的数量。\n     *\n     * 示例:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un tableau de chaînes de caractères words où chaque mot peut être écrit comme une concaténation du code Morse de chaque lettre,\n     * renvoyer le nombre de transformations différentes parmi tous les mots.\n     *\n     * Exemple :\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein Array von Zeichenketten words, wobei jedes Wort als Verkettung des Morsecodes jedes Buchstabens geschrieben werden kann,\n     * gib die Anzahl der unterschiedlichen Transformationen unter allen Wörtern zurück.\n     *\n     * Beispiel:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani jerin kalmomi na kirtani words inda kowace kalma za a iya rubuta ta a matsayin haɗin lambar Morse na kowace harafi,\n     * dawo da adadin canje-canje daban-daban tsakanin duk kalmomi.\n     *\n     * Misali:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए स्ट्रिंग्स के एक array words में जहाँ प्रत्येक शब्द को प्रत्येक अक्षर के मोर्स कोड के संयोजन के रूप में लिखा जा सकता है,\n     * सभी शब्दों के बीच विभिन्न रूपांतरणों की संख्या लौटाएं।\n     *\n     * उदाहरण:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy sztringekből álló tömb, ahol minden szó az egyes betűk Morse-kódjának összefűzéseként írható le,\n     * adja vissza a különböző átalakítások számát az összes szó között.\n     *\n     * Példa:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) "
    },
    "prompt_bertscore": {
      "sq": "0.993572320869711",
      "hy": "0.9828671364838357",
      "bn": "0.9791368579280005",
      "bg": "0.9952964325770939",
      "zh": "0.9952964325770939",
      "fr": "0.9962135090463319",
      "de": "0.9952088365790575",
      "ha": "1",
      "hi": "0.9742048655669042",
      "hu": "0.9706013131941693"
    },
    "canonical_solution": "    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }",
    "instruction": {
      "en": "Write a Java function `public int uniqueMorseRepresentations(String[] words)` to solve the following problem:\nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "sq": "Shkruani një funksion Java `public int uniqueMorseRepresentations(String[] words)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg të fjalëve strings words ku çdo fjalë mund të shkruhet si një bashkim i kodit Morse të secilës shkronjë,\nkthe numrin e transformimeve të ndryshme ndërmjet të gjitha fjalëve.\n\nShembull:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hy": "Գրեք Java ֆունկցիա `public int uniqueMorseRepresentations(String[] words)` հետևյալ խնդիրը լուծելու համար:\nՏրված է տողերի զանգված words, որտեղ յուրաքանչյուր բառ կարող է գրվել որպես յուրաքանչյուր տառի Մորզեի կոդի միացում,\nվերադարձնել տարբեր փոխակերպումների քանակը բոլոր բառերի մեջ:\n\nՕրինակ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "bn": "একটি জাভা ফাংশন `public int uniqueMorseRepresentations(String[] words)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং এর অ্যারে দেওয়া আছে যেখানে প্রতিটি শব্দ প্রতিটি অক্ষরের মর্স কোডের সংযোজন হিসাবে লেখা যেতে পারে, সমস্ত শব্দের মধ্যে বিভিন্ন রূপান্তরের সংখ্যা ফেরত দিন।\n\nউদাহরণ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "bg": "Напишете Java функция `public int uniqueMorseRepresentations(String[] words)`, за да решите следния проблем:  \nДаден е масив от низове words, където всяка дума може да бъде написана като конкатенация на Морзовия код на всяка буква, върнете броя на различните трансформации сред всички думи.\n\nПример:  \nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2  \nuniqueMorseRepresentations([\"a\"]) -> 1",
      "zh": "编写一个 Java 函数 `public int uniqueMorseRepresentations(String[] words)` 来解决以下问题：  \n给定一个字符串数组 words，其中每个单词可以写成每个字母的摩尔斯代码的连接，返回所有单词中不同转换的数量。  \n\n示例:  \nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2  \nuniqueMorseRepresentations([\"a\"]) -> 1",
      "fr": "Écrire une fonction Java `public int uniqueMorseRepresentations(String[] words)` pour résoudre le problème suivant :  \nÉtant donné un tableau de chaînes de caractères words où chaque mot peut être écrit comme une concaténation du code Morse de chaque lettre,  \nretourner le nombre de transformations différentes parmi tous les mots.  \n\nExemple :  \nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2  \nuniqueMorseRepresentations([\"a\"]) -> 1",
      "de": "Schreiben Sie eine Java-Funktion `public int uniqueMorseRepresentations(String[] words)`, um das folgende Problem zu lösen:\nGegeben ein Array von Strings words, wobei jedes Wort als eine Verkettung des Morse-Codes jedes Buchstabens geschrieben werden kann, geben Sie die Anzahl der verschiedenen Transformationen unter allen Wörtern zurück.\n\nBeispiel:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "ha": "Rubuta aikin Java `public int uniqueMorseRepresentations(String[] words)` don warware matsalar mai zuwa:\nAn ba da jerin kalmomi na igiyoyi inda kowace kalma za a iya rubuta ta a matsayin haɗin gwiwar lambar Morse na kowane harafi,\nmayar da adadin juyin daban-daban tsakanin duk kalmomi.\n\nMisali:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hi": "Java फ़ंक्शन `public int uniqueMorseRepresentations(String[] words)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग्स के एरे words में, जहाँ प्रत्येक शब्द को प्रत्येक अक्षर के मोर्स कोड के संयोजन के रूप में लिखा जा सकता है,\nसभी शब्दों में विभिन्न रूपांतरणों की संख्या लौटाएं।\n\nउदाहरण:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hu": "Írj egy Java függvényt `public int uniqueMorseRepresentations(String[] words)` a következő probléma megoldására:\nAdott egy sztringekből álló tömb, ahol minden szó az egyes betűk Morse-kódjának összefűzéseként írható le,\nadd vissza a különböző átalakítások számát az összes szó között.\n\nPélda:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1"
    },
    "instruction_bertscore": {
      "sq": "0.9966566534264207",
      "hy": "0.9956241727058014",
      "bn": "0.9933971288736383",
      "bg": "0.9935345810973144",
      "zh": "0.9835428770401164",
      "fr": "0.9966566534264207",
      "de": "0.9974899078748621",
      "ha": "0.9836850963929374",
      "hi": "0.9734637756152631",
      "hu": "0.9705212651506122"
    },
    "level": "middle",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "uniqueMorseRepresentations",
    "signature": "public int uniqueMorseRepresentations(String[] words)",
    "docstring": {
      "en": "Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "sq": "Duke pasur një varg fjalësh ku secila fjalë mund të shkruhet si një bashkim i kodit Morse të secilës shkronjë,\nkthe numrin e transformimeve të ndryshme midis të gjitha fjalëve.\n\nShembull:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hy": "Տրված է բառերի զանգված words, որտեղ յուրաքանչյուր բառ կարող է գրվել որպես յուրաքանչյուր տառի Մորզեի կոդի կոնկատենացիա, վերադարձնել տարբեր փոխակերպումների քանակը բոլոր բառերի մեջ։\n\nՕրինակ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "bn": "প্রদত্ত একটি স্ট্রিং এর অ্যারে words যেখানে প্রতিটি শব্দ প্রতিটি অক্ষরের মর্স কোডের সংযোজন হিসাবে লেখা যেতে পারে, সমস্ত শব্দের মধ্যে বিভিন্ন রূপান্তরের সংখ্যা ফেরত দিন।\n\nউদাহরণ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "bg": "Даден е масив от низове words, където всяка дума може да бъде написана като конкатенация на Морзовия код на всяка буква, върнете броя на различните трансформации сред всички думи.\n\nПример:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "zh": "给定一个字符串数组 words，其中每个单词可以写成每个字母的摩尔斯代码的连接，返回所有单词中不同转换的数量。\n\n例子：\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "fr": "Étant donné un tableau de chaînes de caractères words où chaque mot peut être écrit comme une concaténation du code Morse de chaque lettre,\nrenvoyer le nombre de transformations différentes parmi tous les mots.\n\nExemple :\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "de": "Gegeben ein Array von Zeichenketten words, bei dem jedes Wort als Verkettung des Morse-Codes jedes Buchstabens geschrieben werden kann, gib die Anzahl der unterschiedlichen Transformationen unter allen Wörtern zurück.\n\nBeispiel:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "ha": "An ba da wani jerin kirtani words inda kowanne kalma za a iya rubuta ta a matsayin haɗin gwiwar lambar Morse na kowanne harafi,\nmayar da adadin sauye-sauye daban-daban tsakanin duk kalmomin.\n\nMisali:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hi": "दिए गए स्ट्रिंग्स के एक एरे words में, जहाँ प्रत्येक शब्द को प्रत्येक अक्षर के मोर्स कोड के संयोजन के रूप में लिखा जा सकता है, सभी शब्दों के बीच विभिन्न रूपांतरणों की संख्या लौटाएँ।\n\nउदाहरण:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hu": "Adott egy words karakterlánc tömb, ahol minden szó az egyes betűk Morse-kódjának összefűzéseként írható le, adja vissza a különböző transzformációk számát az összes szó között.\n\nPélda:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1"
    },
    "docstring_bertscore": {
      "sq": "0.964120401121763",
      "hy": "0.9728547748670101",
      "bn": "0.9941314653923242",
      "bg": "0.9873520118572224",
      "zh": "0.9683262008097957",
      "fr": "0.9941314653923242",
      "de": "0.987184169185248",
      "ha": "0.9654768479938503",
      "hi": "0.9674123024266542",
      "hu": "0.9492421910607257"
    }
  },
  {
    "task_id": "Java/22",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg binar s dhe një numër të plotë k, kthe true nëse çdo varg binar me gjatësi k është një nënvarg i s, ose false përndryshe.\n     *\n     * Shembull 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Shpjegim: Të gjithë vargjet binare me gjatësi 2 (\"00\", \"01\", \"10\", dhe \"11\") janë nënvargje të s.\n     *\n     * Shembull 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Shpjegim: Të gjithë vargjet binare me gjatësi 1 (\"0\" dhe \"1\") janë nënvargje të s.\n     *\n     * Shembull 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Shpjegim: Vargu binar \"00\" nuk është një nënvarg i s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է երկայինական տող s և ամբողջ թիվ k, վերադարձնել true, եթե k երկարության բոլոր երկայինական տողերը ենթատող են s-ի, կամ false՝ հակառակ դեպքում:\n     *\n     * Օրինակ 1:\n     * Մուտք: s = \"00110110\", k = 2\n     * Ելք: true\n     * Բացատրություն: Երկայնության 2 բոլոր երկայինական տողերը (\"00\", \"01\", \"10\" և \"11\") ենթատողեր են s-ի:\n     *\n     * Օրինակ 2:\n     * Մուտք: s = \"0110\", k = 1\n     * Ելք: true\n     * Բացատրություն: Երկայնության 1 բոլոր երկայինական տողերը (\"0\" և \"1\") ենթատողեր են s-ի:\n     *\n     * Օրինակ 3:\n     * Մուտք: s = \"0110\", k = 2\n     * Ելք: false\n     * Բացատրություն: Երկայինական տողը \"00\" ենթատող չէ s-ի:\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি বাইনারি স্ট্রিং s এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, যদি দৈর্ঘ্য k এর প্রতিটি বাইনারি স্ট্রিং s এর একটি উপস্ট্রিং হয় তাহলে true ফেরত দিন, অন্যথায় false ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: s = \"00110110\", k = 2\n     * আউটপুট: true\n     * ব্যাখ্যা: দৈর্ঘ্য 2 এর সব বাইনারি স্ট্রিং (\"00\", \"01\", \"10\", এবং \"11\") s এর উপস্ট্রিং।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: s = \"0110\", k = 1\n     * আউটপুট: true\n     * ব্যাখ্যা: দৈর্ঘ্য 1 এর সব বাইনারি স্ট্রিং (\"0\" এবং \"1\") s এর উপস্ট্রিং।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: s = \"0110\", k = 2\n     * আউটপুট: false\n     * ব্যাখ্যা: বাইনারি স্ট্রিং \"00\" s এর একটি উপস্ট্রিং নয়।\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е двоичен низ s и цяло число k, върнете true, ако всеки двоичен низ с дължина k е подниз на s, или false в противен случай.\n     *\n     * Пример 1:\n     * Вход: s = \"00110110\", k = 2\n     * Изход: true\n     * Обяснение: Всички двоични низове с дължина 2 (\"00\", \"01\", \"10\" и \"11\") са поднизове на s.\n     *\n     * Пример 2:\n     * Вход: s = \"0110\", k = 1\n     * Изход: true\n     * Обяснение: Всички двоични низове с дължина 1 (\"0\" и \"1\") са поднизове на s.\n     *\n     * Пример 3:\n     * Вход: s = \"0110\", k = 2\n     * Изход: false\n     * Обяснение: Двоичният низ \"00\" не е подниз на s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个二进制字符串 s 和一个整数 k，如果长度为 k 的每个二进制字符串都是 s 的子字符串，则返回 true，否则返回 false。\n     *\n     * 示例 1:\n     * 输入: s = \"00110110\", k = 2\n     * 输出: true\n     * 解释: 长度为 2 的所有二进制字符串 (\"00\", \"01\", \"10\", 和 \"11\") 都是 s 的子字符串。\n     *\n     * 示例 2:\n     * 输入: s = \"0110\", k = 1\n     * 输出: true\n     * 解释: 长度为 1 的所有二进制字符串 (\"0\" 和 \"1\") 都是 s 的子字符串。\n     *\n     * 示例 3:\n     * 输入: s = \"0110\", k = 2\n     * 输出: false\n     * 解释: 二进制字符串 \"00\" 不是 s 的子字符串。\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné une chaîne binaire s et un entier k, renvoie true si chaque chaîne binaire de longueur k est une sous-chaîne de s, ou false sinon.\n     *\n     * Exemple 1 :\n     * Entrée : s = \"00110110\", k = 2\n     * Sortie : true\n     * Explication : Toutes les chaînes binaires de longueur 2 (\"00\", \"01\", \"10\", et \"11\") sont des sous-chaînes de s.\n     *\n     * Exemple 2 :\n     * Entrée : s = \"0110\", k = 1\n     * Sortie : true\n     * Explication : Toutes les chaînes binaires de longueur 1 (\"0\" et \"1\") sont des sous-chaînes de s.\n     *\n     * Exemple 3 :\n     * Entrée : s = \"0110\", k = 2\n     * Sortie : false\n     * Explication : La chaîne binaire \"00\" n'est pas une sous-chaîne de s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein binärer String s und ein ganzzahliger Wert k, gib true zurück, wenn jeder binäre String der Länge k ein Substring von s ist, oder false andernfalls.\n     *\n     * Beispiel 1:\n     * Eingabe: s = \"00110110\", k = 2\n     * Ausgabe: true\n     * Erklärung: Alle binären Strings der Länge 2 (\"00\", \"01\", \"10\" und \"11\") sind Substrings von s.\n     *\n     * Beispiel 2:\n     * Eingabe: s = \"0110\", k = 1\n     * Ausgabe: true\n     * Erklärung: Alle binären Strings der Länge 1 (\"0\" und \"1\") sind Substrings von s.\n     *\n     * Beispiel 3:\n     * Eingabe: s = \"0110\", k = 2\n     * Ausgabe: false\n     * Erklärung: Der binäre String \"00\" ist kein Substring von s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani igiyar binary s da kuma wani lamba k, dawo da true idan dukkan igiyoyin binary na tsawon k suna cikin s, ko kuma false idan ba haka ba.\n     *\n     * Misali 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Bayani: Dukkan igiyoyin binary na tsawon 2 (\"00\", \"01\", \"10\", da \"11\") suna cikin s.\n     *\n     * Misali 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Bayani: Dukkan igiyoyin binary na tsawon 1 (\"0\" da \"1\") suna cikin s.\n     *\n     * Misali 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Bayani: Igiyar binary \"00\" ba ta cikin s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए एक बाइनरी स्ट्रिंग s और एक पूर्णांक k के लिए, यदि लंबाई k का हर बाइनरी स्ट्रिंग s का उपस्ट्रिंग है तो true लौटाएं, अन्यथा false लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: s = \"00110110\", k = 2\n     * आउटपुट: true\n     * व्याख्या: लंबाई 2 के सभी बाइनरी स्ट्रिंग (\"00\", \"01\", \"10\", और \"11\") s के उपस्ट्रिंग हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: s = \"0110\", k = 1\n     * आउटपुट: true\n     * व्याख्या: लंबाई 1 के सभी बाइनरी स्ट्रिंग (\"0\" और \"1\") s के उपस्ट्रिंग हैं।\n     *\n     * उदाहरण 3:\n     * इनपुट: s = \"0110\", k = 2\n     * आउटपुट: false\n     * व्याख्या: बाइनरी स्ट्रिंग \"00\" s का उपस्ट्रिंग नहीं है।\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy bináris string s és egy egész szám k, adja vissza igaz értéket, ha minden k hosszúságú bináris string részstringje s-nek, vagy hamis értéket egyébként.\n     *\n     * 1. példa:\n     * Bemenet: s = \"00110110\", k = 2\n     * Kimenet: igaz\n     * Magyarázat: Minden 2 hosszúságú bináris string (\"00\", \"01\", \"10\" és \"11\") részstringje s-nek.\n     *\n     * 2. példa:\n     * Bemenet: s = \"0110\", k = 1\n     * Kimenet: igaz\n     * Magyarázat: Minden 1 hosszúságú bináris string (\"0\" és \"1\") részstringje s-nek.\n     *\n     * 3. példa:\n     * Bemenet: s = \"0110\", k = 2\n     * Kimenet: hamis\n     * Magyarázat: A \"00\" bináris string nem részstringje s-nek.\n     */\n  public boolean hasAllCodes(String s, int k) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9796167489285809",
      "bn": "0.9822192041808999",
      "bg": "1",
      "zh": "0.9954366656261044",
      "fr": "1",
      "de": "0.9963265297331407",
      "ha": "0.9398040698754719",
      "hi": "0.9917443254730469",
      "hu": "0.9859989417016128"
    },
    "canonical_solution": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "instruction": {
      "en": "Write a Java function `public boolean hasAllCodes(String s, int k)` to solve the following problem:\nGiven a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.",
      "sq": "Shkruani një funksion Java `public boolean hasAllCodes(String s, int k)` për të zgjidhur problemin në vijim:  \nDuke pasur një varg binar s dhe një numër të plotë k, ktheni true nëse çdo varg binar me gjatësi k është një nënvarg i s, ose false përndryshe.\n\nShembull 1:  \nInput: s = \"00110110\", k = 2  \nOutput: true  \nShpjegim: Të gjitha vargjet binare me gjatësi 2 (\"00\", \"01\", \"10\", dhe \"11\") janë nënvargje të s.\n\nShembull 2:  \nInput: s = \"0110\", k = 1  \nOutput: true  \nShpjegim: Të gjitha vargjet binare me gjatësi 1 (\"0\" dhe \"1\") janë nënvargje të s.\n\nShembull 3:  \nInput: s = \"0110\", k = 2  \nOutput: false  \nShpjegim: Vargu binar \"00\" nuk është një nënvarg i s.",
      "hy": "Գրեք Java ֆունկցիա `public boolean hasAllCodes(String s, int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված է երկբայական տող s և ամբողջ թիվ k, վերադարձնել true, եթե k երկարությամբ յուրաքանչյուր երկբայական տող ենթատող է s-ի, կամ false՝ հակառակ դեպքում:\n\nՕրինակ 1:\nՄուտք: s = \"00110110\", k = 2\nԵլք: true\nԲացատրություն: 2 երկարությամբ բոլոր երկբայական տողերը (\"00\", \"01\", \"10\" և \"11\") ենթատողեր են s-ի:\n\nՕրինակ 2:\nՄուտք: s = \"0110\", k = 1\nԵլք: true\nԲացատրություն: 1 երկարությամբ բոլոր երկբայական տողերը (\"0\" և \"1\") ենթատողեր են s-ի:\n\nՕրինակ 3:\nՄուտք: s = \"0110\", k = 2\nԵլք: false\nԲացատրություն: Երկբայական տողը \"00\" ենթատող չէ s-ի:",
      "bn": "একটি জাভা ফাংশন `public boolean hasAllCodes(String s, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি স্ট্রিং s এবং একটি পূর্ণসংখ্যা k দেওয়া হলে, যদি দৈর্ঘ্য k এর প্রতিটি বাইনারি স্ট্রিং s এর একটি সাবস্ট্রিং হয় তবে true ফেরত দিন, অন্যথায় false ফেরত দিন।\n\nউদাহরণ 1:\nইনপুট: s = \"00110110\", k = 2\nআউটপুট: true\nব্যাখ্যা: দৈর্ঘ্য 2 এর সমস্ত বাইনারি স্ট্রিং (\"00\", \"01\", \"10\", এবং \"11\") s এর সাবস্ট্রিং।\n\nউদাহরণ 2:\nইনপুট: s = \"0110\", k = 1\nআউটপুট: true\nব্যাখ্যা: দৈর্ঘ্য 1 এর সমস্ত বাইনারি স্ট্রিং (\"0\" এবং \"1\") s এর সাবস্ট্রিং।\n\nউদাহরণ 3:\nইনপুট: s = \"0110\", k = 2\nআউটপুট: false\nব্যাখ্যা: বাইনারি স্ট্রিং \"00\" s এর একটি সাবস্ট্রিং নয়।",
      "bg": "Напишете Java функция `public boolean hasAllCodes(String s, int k)`, за да решите следния проблем:  \nДаден е двоичен низ s и цяло число k, върнете true, ако всеки двоичен низ с дължина k е подниз на s, или false в противен случай.\n\nПример 1:  \nВход: s = \"00110110\", k = 2  \nИзход: true  \nОбяснение: Всички двоични низове с дължина 2 (\"00\", \"01\", \"10\" и \"11\") са поднизове на s.\n\nПример 2:  \nВход: s = \"0110\", k = 1  \nИзход: true  \nОбяснение: Всички двоични низове с дължина 1 (\"0\" и \"1\") са поднизове на s.\n\nПример 3:  \nВход: s = \"0110\", k = 2  \nИзход: false  \nОбяснение: Двоичният низ \"00\" не е подниз на s.",
      "zh": "编写一个 Java 函数 `public boolean hasAllCodes(String s, int k)` 来解决以下问题：\n给定一个二进制字符串 s 和一个整数 k，如果长度为 k 的每个二进制字符串都是 s 的子字符串，则返回 true，否则返回 false。\n\n示例 1:\n输入: s = \"00110110\", k = 2\n输出: true\n解释: 长度为 2 的所有二进制字符串 (\"00\", \"01\", \"10\", 和 \"11\") 都是 s 的子字符串。\n\n示例 2:\n输入: s = \"0110\", k = 1\n输出: true\n解释: 长度为 1 的所有二进制字符串 (\"0\" 和 \"1\") 都是 s 的子字符串。\n\n示例 3:\n输入: s = \"0110\", k = 2\n输出: false\n解释: 二进制字符串 \"00\" 不是 s 的子字符串。",
      "fr": "Écrire une fonction Java `public boolean hasAllCodes(String s, int k)` pour résoudre le problème suivant :  \nÉtant donné une chaîne binaire s et un entier k, retourner true si chaque chaîne binaire de longueur k est une sous-chaîne de s, ou false sinon.\n\nExemple 1 :  \nInput: s = \"00110110\", k = 2  \nOutput: true  \nExplication : Toutes les chaînes binaires de longueur 2 (\"00\", \"01\", \"10\", et \"11\") sont des sous-chaînes de s.\n\nExemple 2 :  \nInput: s = \"0110\", k = 1  \nOutput: true  \nExplication : Toutes les chaînes binaires de longueur 1 (\"0\" et \"1\") sont des sous-chaînes de s.\n\nExemple 3 :  \nInput: s = \"0110\", k = 2  \nOutput: false  \nExplication : La chaîne binaire \"00\" n'est pas une sous-chaîne de s.",
      "de": "Schreiben Sie eine Java-Funktion `public boolean hasAllCodes(String s, int k)`, um das folgende Problem zu lösen: Gegeben ein binärer String s und eine ganze Zahl k, geben Sie true zurück, wenn jeder binäre String der Länge k ein Substring von s ist, oder false andernfalls.\n\nBeispiel 1:\nEingabe: s = \"00110110\", k = 2\nAusgabe: true\nErklärung: Alle binären Strings der Länge 2 (\"00\", \"01\", \"10\" und \"11\") sind Substrings von s.\n\nBeispiel 2:\nEingabe: s = \"0110\", k = 1\nAusgabe: true\nErklärung: Alle binären Strings der Länge 1 (\"0\" und \"1\") sind Substrings von s.\n\nBeispiel 3:\nEingabe: s = \"0110\", k = 2\nAusgabe: false\nErklärung: Der binäre String \"00\" ist kein Substring von s.",
      "ha": "Rubuta aikin Java `public boolean hasAllCodes(String s, int k)` don warware matsalar mai zuwa:\nAn ba da igiyar binary s da kuma cikakken lamba k, dawo da gaskiya idan dukkan igiyoyin binary na tsawon k suna cikin s, ko kuma ƙarya in ba haka ba.\n\nMisali na 1:  \nShigar: s = \"00110110\", k = 2  \nFitarwa: gaskiya  \nBayani: Duk igiyoyin binary na tsawon 2 (\"00\", \"01\", \"10\", da \"11\") suna cikin s.\n\nMisali na 2:  \nShigar: s = \"0110\", k = 1  \nFitarwa: gaskiya  \nBayani: Duk igiyoyin binary na tsawon 1 (\"0\" da \"1\") suna cikin s.\n\nMisali na 3:  \nShigar: s = \"0110\", k = 2  \nFitarwa: ƙarya  \nBayani: Igiyar binary \"00\" ba ta cikin s.",
      "hi": "Java फ़ंक्शन `public boolean hasAllCodes(String s, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक बाइनरी स्ट्रिंग s और एक पूर्णांक k के लिए, true लौटाएं यदि लंबाई k का प्रत्येक बाइनरी स्ट्रिंग s का एक उपस्ट्रिंग है, अन्यथा false लौटाएं।\n\nउदाहरण 1:\nइनपुट: s = \"00110110\", k = 2\nआउटपुट: true\nव्याख्या: लंबाई 2 के सभी बाइनरी स्ट्रिंग (\"00\", \"01\", \"10\", और \"11\") s के उपस्ट्रिंग हैं।\n\nउदाहरण 2:\nइनपुट: s = \"0110\", k = 1\nआउटपुट: true\nव्याख्या: लंबाई 1 के सभी बाइनरी स्ट्रिंग (\"0\" और \"1\") s के उपस्ट्रिंग हैं।\n\nउदाहरण 3:\nइनपुट: s = \"0110\", k = 2\nआउटपुट: false\nव्याख्या: बाइनरी स्ट्रिंग \"00\" s का उपस्ट्रिंग नहीं है।",
      "hu": "Írj egy Java függvényt `public boolean hasAllCodes(String s, int k)` a következő probléma megoldására:\nAdott egy bináris string s és egy egész szám k, térj vissza true értékkel, ha minden k hosszúságú bináris string részstringje s-nek, vagy false értékkel, ha nem.\n\n1. példa:\nBemenet: s = \"00110110\", k = 2\nKimenet: true\nMagyarázat: Minden 2 hosszúságú bináris string (\"00\", \"01\", \"10\" és \"11\") részstringje s-nek.\n\n2. példa:\nBemenet: s = \"0110\", k = 1\nKimenet: true\nMagyarázat: Minden 1 hosszúságú bináris string (\"0\" és \"1\") részstringje s-nek.\n\n3. példa:\nBemenet: s = \"0110\", k = 2\nKimenet: false\nMagyarázat: A \"00\" bináris string nem részstringje s-nek."
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9655187590042486",
      "bn": "0.9824516017267108",
      "bg": "0.9865084286289673",
      "zh": "0.9957371933926102",
      "fr": "1",
      "de": "1",
      "ha": "0.9372469023500288",
      "hi": "0.9915025922993275",
      "hu": "0.9735219743169063"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "hasAllCodes",
    "signature": "public boolean hasAllCodes(String s, int k)",
    "docstring": {
      "en": "Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.",
      "sq": "Duke pasur një varg binar s dhe një numër të plotë k, kthe true nëse çdo varg binar me gjatësi k është një nënvarg i s, ose false përndryshe.\n\nShembull 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nShpjegim: Të gjitha vargjet binare me gjatësi 2 (\"00\", \"01\", \"10\", dhe \"11\") janë nënvargje të s.\n\nShembull 2:\nInput: s = \"0110\", k = 1\nOutput: true\nShpjegim: Të gjitha vargjet binare me gjatësi 1 (\"0\" dhe \"1\") janë nënvargje të s.\n\nShembull 3:\nInput: s = \"0110\", k = 2\nOutput: false\nShpjegim: Vargu binar \"00\" nuk është një nënvarg i s.",
      "hy": "Տրված է երկբայական տող s և ամբողջ թիվ k, վերադարձնել true, եթե երկբայական բոլոր տողերը k երկարությամբ ենթատողեր են s-ի, կամ false հակառակ դեպքում:\n\nՕրինակ 1:\nՄուտք: s = \"00110110\", k = 2\nԵլք: true\nԲացատրություն: Երկբայական բոլոր տողերը 2 երկարությամբ (\"00\", \"01\", \"10\" և \"11\") ենթատողեր են s-ի:\n\nՕրինակ 2:\nՄուտք: s = \"0110\", k = 1\nԵլք: true\nԲացատրություն: Երկբայական բոլոր տողերը 1 երկարությամբ (\"0\" և \"1\") ենթատողեր են s-ի:\n\nՕրինակ 3:\nՄուտք: s = \"0110\", k = 2\nԵլք: false\nԲացատրություն: Երկբայական տողը \"00\" ենթատող չէ s-ի:",
      "bn": "দেওয়া একটি বাইনারি স্ট্রিং s এবং একটি পূর্ণসংখ্যা k, যদি s এর প্রতিটি k দৈর্ঘ্যের বাইনারি স্ট্রিং একটি সাবস্ট্রিং হয় তবে true ফেরত দিন, অন্যথায় false।\n\nউদাহরণ 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: দৈর্ঘ্য 2 এর সমস্ত বাইনারি স্ট্রিং (\"00\", \"01\", \"10\", এবং \"11\") s এর সাবস্ট্রিং।\n\nউদাহরণ 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: দৈর্ঘ্য 1 এর সমস্ত বাইনারি স্ট্রিং (\"0\" এবং \"1\") s এর সাবস্ট্রিং।\n\nউদাহরণ 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: বাইনারি স্ট্রিং \"00\" s এর একটি সাবস্ট্রিং নয়।",
      "bg": "Даден е двоичен низ s и цяло число k, върнете true, ако всеки двоичен низ с дължина k е подниз на s, или false в противен случай.\n\nПример 1:\nВход: s = \"00110110\", k = 2\nИзход: true\nОбяснение: Всички двоични низове с дължина 2 (\"00\", \"01\", \"10\" и \"11\") са поднизове на s.\n\nПример 2:\nВход: s = \"0110\", k = 1\nИзход: true\nОбяснение: Всички двоични низове с дължина 1 (\"0\" и \"1\") са поднизове на s.\n\nПример 3:\nВход: s = \"0110\", k = 2\nИзход: false\nОбяснение: Двоичният низ \"00\" не е подниз на s.",
      "zh": "给定一个二进制字符串 s 和一个整数 k，如果长度为 k 的每个二进制字符串都是 s 的子字符串，则返回 true，否则返回 false。\n\n示例 1:\n输入: s = \"00110110\", k = 2\n输出: true\n解释: 所有长度为 2 的二进制字符串 (\"00\", \"01\", \"10\", 和 \"11\") 都是 s 的子字符串。\n\n示例 2:\n输入: s = \"0110\", k = 1\n输出: true\n解释: 所有长度为 1 的二进制字符串 (\"0\" 和 \"1\") 都是 s 的子字符串。\n\n示例 3:\n输入: s = \"0110\", k = 2\n输出: false\n解释: 二进制字符串 \"00\" 不是 s 的子字符串。",
      "fr": "Étant donné une chaîne binaire s et un entier k, renvoyez true si chaque chaîne binaire de longueur k est une sous-chaîne de s, ou false sinon.\n\nExemple 1 :\nInput: s = \"00110110\", k = 2\nOutput: true\nExplication : Toutes les chaînes binaires de longueur 2 (\"00\", \"01\", \"10\", et \"11\") sont des sous-chaînes de s.\n\nExemple 2 :\nInput: s = \"0110\", k = 1\nOutput: true\nExplication : Toutes les chaînes binaires de longueur 1 (\"0\" et \"1\") sont des sous-chaînes de s.\n\nExemple 3 :\nInput: s = \"0110\", k = 2\nOutput: false\nExplication : La chaîne binaire \"00\" n'est pas une sous-chaîne de s.",
      "de": "Gegeben ein binärer String s und ein ganzzahliger Wert k, gib true zurück, wenn jeder binäre String der Länge k ein Substring von s ist, oder false andernfalls.\n\nBeispiel 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nErklärung: Alle Binärstrings der Länge 2 (\"00\", \"01\", \"10\" und \"11\") sind Substrings von s.\n\nBeispiel 2:\nInput: s = \"0110\", k = 1\nOutput: true\nErklärung: Alle Binärstrings der Länge 1 (\"0\" und \"1\") sind Substrings von s.\n\nBeispiel 3:\nInput: s = \"0110\", k = 2\nOutput: false\nErklärung: Der Binärstring \"00\" ist kein Substring von s.",
      "ha": "An ba da igiyar binary s da kuma cikakken lamba k, dawo da gaskiya idan dukkan igiyoyin binary na tsawon k suna cikin s, ko kuma ƙarya in ba haka ba.\n\nMisali 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nBayani: Dukkan igiyoyin binary na tsawon 2 (\"00\", \"01\", \"10\", da \"11\") suna cikin s.\n\nMisali 2:\nInput: s = \"0110\", k = 1\nOutput: true\nBayani: Dukkan igiyoyin binary na tsawon 1 (\"0\" da \"1\") suna cikin s.\n\nMisali 3:\nInput: s = \"0110\", k = 2\nOutput: false\nBayani: Igiya binary \"00\" ba ta cikin s.",
      "hi": "दिए गए एक बाइनरी स्ट्रिंग s और एक पूर्णांक k के लिए, true लौटाएं यदि लंबाई k का प्रत्येक बाइनरी स्ट्रिंग s का एक उपस्ट्रिंग है, अन्यथा false लौटाएं।\n\nउदाहरण 1:\nइनपुट: s = \"00110110\", k = 2\nआउटपुट: true\nव्याख्या: लंबाई 2 के सभी बाइनरी स्ट्रिंग (\"00\", \"01\", \"10\", और \"11\") s के सबस्ट्रिंग हैं।\n\nउदाहरण 2:\nइनपुट: s = \"0110\", k = 1\nआउटपुट: true\nव्याख्या: लंबाई 1 के सभी बाइनरी स्ट्रिंग (\"0\" और \"1\") s के सबस्ट्रिंग हैं।\n\nउदाहरण 3:\nइनपुट: s = \"0110\", k = 2\nआउटपुट: false\nव्याख्या: बाइनरी स्ट्रिंग \"00\" s का सबस्ट्रिंग नहीं है।",
      "hu": "Adott egy bináris string s és egy egész szám k, adja vissza, hogy igaz-e, ha minden k hosszúságú bináris string az s egy részstringje, vagy hamis, ha nem.\n\nPélda 1:\nBemenet: s = \"00110110\", k = 2\nKimenet: true\nMagyarázat: Az összes 2 hosszúságú bináris string (\"00\", \"01\", \"10\" és \"11\") az s részstringjei.\n\nPélda 2:\nBemenet: s = \"0110\", k = 1\nKimenet: true\nMagyarázat: Az összes 1 hosszúságú bináris string (\"0\" és \"1\") az s részstringjei.\n\nPélda 3:\nBemenet: s = \"0110\", k = 2\nKimenet: false\nMagyarázat: A \"00\" bináris string nem részstringje az s-nek."
    },
    "docstring_bertscore": {
      "sq": "0.9998613559940377",
      "hy": "0.9890751304127001",
      "bn": "0.994283814894578",
      "bg": "1",
      "zh": "0.994283814894578",
      "fr": "1",
      "de": "1",
      "ha": "0.9654267931378294",
      "hi": "1",
      "hu": "0.9844859740892701"
    }
  },
  {
    "task_id": "Java/23",
    "prompt": {
      "en": "class Solution {\n    /**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "sq": "class Solution {\n    /**\n    * Kontrolloni nëse searchWord është një parashtesë e ndonjë fjale në fjali.\n    * Nëse searchWord është një parashtesë e disa fjalëve, kthe indeksin e fjalës së parë që përputhet.\n    * Nëse searchWord nuk është një parashtesë e asnjë fjale, kthe -1.\n    * \n    * Shembull:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "hy": "class Solution {\n    /**\n    * Ստուգել, արդյոք searchWord-ը նախածանց է նախադասության որևէ բառի համար:\n    * Եթե searchWord-ը նախածանց է մի քանի բառերի համար, վերադարձնել առաջին համընկնող բառի ինդեքսը:\n    * Եթե searchWord-ը ոչ մի բառի նախածանց չէ, վերադարձնել -1:\n    * \n    * Օրինակ:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "bn": "class Solution {\n    /**\n    * পরীক্ষা করুন যে searchWord কোনো শব্দের উপসর্গ কিনা sentence-এ।\n    * যদি searchWord একাধিক শব্দের উপসর্গ হয়, তাহলে প্রথম মিলে যাওয়া শব্দের সূচক ফেরত দিন।\n    * যদি searchWord কোনো শব্দের উপসর্গ না হয়, তাহলে -1 ফেরত দিন।\n    * \n    * উদাহরণ:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "bg": "class Solution {\n    /**\n    * Проверете дали searchWord е префикс на някоя дума в изречението.\n    * Ако searchWord е префикс на множество думи, върнете индекса на първата съвпадаща дума.\n    * Ако searchWord не е префикс на нито една дума, върнете -1.\n    * \n    * Пример:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "zh": "class Solution {\n    /**\n    * 检查 searchWord 是否是句子中任何单词的前缀。\n    * 如果 searchWord 是多个单词的前缀，返回第一个匹配单词的索引。\n    * 如果 searchWord 不是任何单词的前缀，返回 -1。\n    * \n    * 例子:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "fr": "class Solution {\n    /**\n    * Vérifiez si searchWord est un préfixe de n'importe quel mot dans la phrase.\n    * Si searchWord est un préfixe de plusieurs mots, renvoyez l'index du premier mot correspondant.\n    * Si searchWord n'est le préfixe d'aucun mot, renvoyez -1.\n    * \n    * Exemple:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "de": "class Solution {\n    /**\n    * Überprüfen, ob searchWord ein Präfix eines beliebigen Wortes im Satz ist.\n    * Wenn searchWord ein Präfix mehrerer Wörter ist, geben Sie den Index des ersten passenden Wortes zurück.\n    * Wenn searchWord kein Präfix eines Wortes ist, geben Sie -1 zurück.\n    * \n    * Beispiel:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "ha": "class Solution {\n    /**\n    * Duba idan searchWord kalma ce ta farko a cikin kowace kalma a cikin jumla.\n    * Idan searchWord kalma ce ta farko a cikin kalmomi da dama, dawo da lambar kalmar farko da ta dace.\n    * Idan searchWord ba kalma ce ta farko a cikin kowace kalma ba, dawo da -1.\n    * \n    * Misali:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "hi": "class Solution {\n    /**\n    * जाँचें कि searchWord वाक्य में किसी शब्द का उपसर्ग है या नहीं।\n    * यदि searchWord कई शब्दों का उपसर्ग है, तो पहले मिलान करने वाले शब्द का सूचकांक लौटाएं।\n    * यदि searchWord किसी भी शब्द का उपसर्ग नहीं है, तो -1 लौटाएं।\n    * \n    * उदाहरण:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "hu": "class Solution {\n    /**\n    * Ellenőrizze, hogy a searchWord előtagja-e bármelyik szónak a mondatban.\n    * Ha a searchWord több szó előtagja, adja vissza az első egyező szó indexét.\n    * Ha a searchWord nem előtagja egyetlen szónak sem, adja vissza a -1 értéket.\n    * \n    * Példa:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) "
    },
    "prompt_bertscore": {
      "sq": "0.9937910129192304",
      "hy": "0.9922113054988599",
      "bn": "0.9951998982119109",
      "bg": "0.9951998982119109",
      "zh": "0.9938041225243788",
      "fr": "0.9931063339958032",
      "de": "0.9951998982119109",
      "ha": "0.9856976194135829",
      "hi": "0.9951998982119109",
      "hu": "0.9951998982119109"
    },
    "canonical_solution": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }",
    "instruction": {
      "en": "Write a Java function `public int isPrefixOfWord(String sentence, String searchWord)` to solve the following problem:\nCheck if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "sq": "Shkruani një funksion Java `public int isPrefixOfWord(String sentence, String searchWord)` për të zgjidhur problemin në vijim:\nKontrolloni nëse searchWord është një parashtesë e ndonjë fjale në fjali.\nNëse searchWord është një parashtesë e disa fjalëve, kthe indeksin e fjalës së parë që përputhet.\nNëse searchWord nuk është një parashtesë e asnjë fjale, kthe -1.\n\nShembull:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "hy": "Գրեք Java ֆունկցիա `public int isPrefixOfWord(String sentence, String searchWord)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք searchWord-ը նախածանց է նախադասության որևէ բառի համար:\nԵթե searchWord-ը նախածանց է բազմաթիվ բառերի համար, վերադարձնել առաջին համընկնող բառի ինդեքսը:\nԵթե searchWord-ը նախածանց չէ որևէ բառի համար, վերադարձնել -1:\n\nՕրինակ:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "bn": "একটি জাভা ফাংশন `public int isPrefixOfWord(String sentence, String searchWord)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপরীক্ষা করুন যে searchWord কোনো শব্দের উপসর্গ কিনা sentence-এ।\nযদি searchWord একাধিক শব্দের উপসর্গ হয়, তাহলে প্রথম মিলে যাওয়া শব্দের সূচক ফেরত দিন।\nযদি searchWord কোনো শব্দের উপসর্গ না হয়, তাহলে -1 ফেরত দিন।\n\nউদাহরণ:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "bg": "Напишете Java функция `public int isPrefixOfWord(String sentence, String searchWord)`, за да решите следния проблем:\nПроверете дали searchWord е префикс на някоя дума в изречението.\nАко searchWord е префикс на множество думи, върнете индекса на първата съвпадаща дума.\nАко searchWord не е префикс на нито една дума, върнете -1.\n\nПример:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "zh": "编写一个 Java 函数 `public int isPrefixOfWord(String sentence, String searchWord)` 来解决以下问题：\n检查 searchWord 是否是句子中任何单词的前缀。\n如果 searchWord 是多个单词的前缀，返回第一个匹配单词的索引。\n如果 searchWord 不是任何单词的前缀，返回 -1。\n\n示例:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "fr": "Écrire une fonction Java `public int isPrefixOfWord(String sentence, String searchWord)` pour résoudre le problème suivant :  \nVérifiez si searchWord est un préfixe de n'importe quel mot dans la phrase.  \nSi searchWord est un préfixe de plusieurs mots, renvoyez l'indice du premier mot correspondant.  \nSi searchWord n'est le préfixe d'aucun mot, renvoyez -1.\n\nExemple :\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "de": "Schreiben Sie eine Java-Funktion `public int isPrefixOfWord(String sentence, String searchWord)`, um das folgende Problem zu lösen:\nÜberprüfen Sie, ob das Suchwort ein Präfix eines beliebigen Wortes im Satz ist.\nWenn das Suchwort ein Präfix mehrerer Wörter ist, geben Sie den Index des ersten übereinstimmenden Wortes zurück.\nWenn das Suchwort kein Präfix eines Wortes ist, geben Sie -1 zurück.\n\nBeispiel:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "ha": "Rubuta aikin Java `public int isPrefixOfWord(String sentence, String searchWord)` don warware matsalar mai zuwa:\nDuba idan searchWord kalma ce ta farko na kowace kalma a cikin jumla.\nIdan searchWord kalma ce ta farko na kalmomi da yawa, dawo da lambar kalmar da ta fara dacewa.\nIdan searchWord ba kalma ce ta farko na kowace kalma ba, dawo da -1.\n\nMisali:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "hi": "Java फ़ंक्शन `public int isPrefixOfWord(String sentence, String searchWord)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजांचें कि क्या searchWord वाक्य में किसी शब्द का उपसर्ग है।\nयदि searchWord कई शब्दों का उपसर्ग है, तो पहले मिलान करने वाले शब्द का सूचकांक लौटाएं।\nयदि searchWord किसी भी शब्द का उपसर्ग नहीं है, तो -1 लौटाएं।\n\nउदाहरण:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "hu": "Írj egy Java függvényt `public int isPrefixOfWord(String sentence, String searchWord)` a következő probléma megoldására:\nEllenőrizd, hogy a searchWord előtagja-e bármelyik szónak a mondatban.\nHa a searchWord több szó előtagja, add vissza az első egyező szó indexét.\nHa a searchWord nem előtagja egyetlen szónak sem, add vissza a -1 értéket.\n\nPélda:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1"
    },
    "instruction_bertscore": {
      "sq": "0.9900784124673073",
      "hy": "0.9910054204555971",
      "bn": "0.9955284328621425",
      "bg": "0.9955284328621425",
      "zh": "0.9955284328621425",
      "fr": "0.9955284328621425",
      "de": "0.9815414773208089",
      "ha": "0.9896557270164651",
      "hi": "0.9955284328621425",
      "hu": "0.9838005006443187"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isPrefixOfWord",
    "signature": "public int isPrefixOfWord(String sentence, String searchWord)",
    "docstring": {
      "en": "Check if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "sq": "Kontrolloni nëse searchWord është një parashtesë e ndonjë fjale në fjali.  \nNëse searchWord është një parashtesë e disa fjalëve, kthe indeksin e fjalës së parë që përputhet.  \nNëse searchWord nuk është një parashtesë e asnjë fjale, kthe -1.\n\nShembull:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1",
      "hy": "Ստուգեք, արդյոք searchWord-ը նախածանց է նախադասության որևէ բառի համար:  \nԵթե searchWord-ը մի քանի բառերի նախածանց է, վերադարձնել առաջին համընկնող բառի ինդեքսը:  \nԵթե searchWord-ը ոչ մի բառի նախածանց չէ, վերադարձնել -1:\n\nՕրինակ:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "bn": "যাচাই করুন যে searchWord বাক্যের কোনো শব্দের উপসর্গ কিনা।  \nযদি searchWord একাধিক শব্দের উপসর্গ হয়, তাহলে প্রথম মিলে যাওয়া শব্দের সূচক ফেরত দিন।  \nযদি searchWord কোনো শব্দের উপসর্গ না হয়, তাহলে -1 ফেরত দিন।\n\nউদাহরণ:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "bg": "Проверете дали searchWord е префикс на някоя дума в изречението.  \nАко searchWord е префикс на няколко думи, върнете индекса на първата съвпадаща дума.  \nАко searchWord не е префикс на нито една дума, върнете -1.\n\nПример:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  ",
      "zh": "检查 searchWord 是否是句子中任何单词的前缀。\n如果 searchWord 是多个单词的前缀，返回第一个匹配单词的索引。\n如果 searchWord 不是任何单词的前缀，返回 -1。\n\n示例：\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "fr": "Vérifiez si searchWord est un préfixe de n'importe quel mot dans la phrase.  \nSi searchWord est un préfixe de plusieurs mots, retournez l'indice du premier mot correspondant.  \nSi searchWord n'est le préfixe d'aucun mot, retournez -1.\n\nExemple :\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "de": "Überprüfen Sie, ob searchWord ein Präfix eines beliebigen Wortes im Satz ist. Wenn searchWord ein Präfix von mehreren Wörtern ist, geben Sie den Index des ersten übereinstimmenden Wortes zurück. Wenn searchWord kein Präfix eines Wortes ist, geben Sie -1 zurück.\n\nBeispiel:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "ha": "Duba idan searchWord kalma ce ta farko a cikin kowace kalma a cikin jumlar. Idan searchWord kalma ce ta farko a cikin kalmomi da dama, dawo da lambar kalmar farko da ta dace. Idan searchWord ba kalma ce ta farko a cikin kowace kalma ba, dawo da -1.\n\nMisali:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "hi": "किसी वाक्य में searchWord किसी शब्द का उपसर्ग है या नहीं, यह जांचें।  \nयदि searchWord कई शब्दों का उपसर्ग है, तो पहले मिलान करने वाले शब्द का सूचकांक लौटाएं।  \nयदि searchWord किसी भी शब्द का उपसर्ग नहीं है, तो -1 लौटाएं।  \n\nउदाहरण:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  ",
      "hu": "Ellenőrizze, hogy a searchWord bármely szó előtagja-e a mondatban.\nHa a searchWord több szó előtagja, adja vissza az első egyező szó indexét.\nHa a searchWord nem előtagja egyetlen szónak sem, adja vissza a -1 értéket.\n\nPélda:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.992546990842809",
      "hy": "0.9860094691118076",
      "bn": "0.9887656642790478",
      "bg": "0.994016458401705",
      "zh": "0.9887656642790478",
      "fr": "0.994016458401705",
      "de": "0.994016458401705",
      "ha": "0.9393271583306072",
      "hi": "0.9846121043812273",
      "hu": "0.9896001105097754"
    }
  },
  {
    "task_id": "Java/24",
    "prompt": {
      "en": "class Solution {\n    /**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    */\n public int minInsertions(String s) ",
      "sq": "class Solution {\n    /**\n    * Duke pasur një varg s të përbërë nga '(' dhe ')', kllapat e majta dhe të djathta në s mund të jenë të pabalancuara. Çdo operacion mund të fusë një '(' ose ')', dhe të llogarisë numrin minimal të operacioneve të futjes së kërkuara. Bëni që kllapat e majta dhe të djathta në s të jenë të balancuara.\n    *\n    * Shembull 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Shpjegim: Duhet të shtojmë një '(' në fillim të vargut për ta bërë atë të balancuar: \"((()))\".\n    * Shembull 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s përbëhet vetëm nga '(' dhe ')'.\n    */\n public int minInsertions(String s) ",
      "hy": "class Solution {\n    /**\n    * Տրված է s տողը, որը կազմված է '(' և ')' սիմվոլներից, s-ի ձախ և աջ փակագծերը կարող են լինել անհավասարակշիռ։ Յուրաքանչյուր գործողությամբ հնարավոր է ներդնել '(' կամ ')', և հաշվել անհրաժեշտ նվազագույն ներդրման գործողությունների քանակը։ s-ի ձախ և աջ փակագծերը հավասարակշռված դարձնելու համար։\n    *\n    * Օրինակ 1:\n    * Մուտք: s = \"(()))\"\n    * Ելք: 1\n    * Բացատրություն: Անհրաժեշտ է ավելացնել մեկ '(' տողի սկզբում, որպեսզի այն հավասարակշռված լինի: \"((()))\".\n    * Օրինակ 2:\n    * Մուտք: s = \"((()))\"\n    * Ելք: 0\n    *\n    * - s-ը բաղկացած է միայն '(' և ')' սիմվոլներից։\n    */\n public int minInsertions(String s) ",
      "bn": "class Solution {\n    /**\n    * একটি স্ট্রিং s দেওয়া হয়েছে যা '(' এবং ')' দ্বারা গঠিত, s-এ বাম এবং ডান বন্ধনীগুলি অসমতল হতে পারে। প্রতিটি অপারেশন একটি '(' বা ')' সন্নিবেশ করতে পারে এবং প্রয়োজনীয় সন্নিবেশ অপারেশনগুলির সর্বনিম্ন সংখ্যা গণনা করতে পারে। s-এ বাম এবং ডান বন্ধনীগুলি সমতল করুন।\n    *\n    * উদাহরণ 1:\n    * ইনপুট: s = \"(()))\"\n    * আউটপুট: 1\n    * ব্যাখ্যা: স্ট্রিংটিকে সমতল করতে আমাদের স্ট্রিংয়ের শুরুতে একটি '(' যোগ করতে হবে: \"((()))\"।\n    * উদাহরণ 2:\n    * ইনপুট: s = \"((()))\"\n    * আউটপুট: 0\n    *\n    * - s শুধুমাত্র '(' এবং ')' নিয়ে গঠিত।\n    */\n public int minInsertions(String s) ",
      "bg": "class Solution {\n    /**\n    * Даден е низ s, съставен от '(' и ')', лявите и десните скоби в s може да са небалансирани. Всяка операция може да вмъкне '(' или ')', и изчислява минималния брой операции за вмъкване, които са необходими. Направете така, че лявите и десните скоби в s да са балансирани.\n    *\n    * Пример 1:\n    * Вход: s = \"(()))\"\n    * Изход: 1\n    * Обяснение: Трябва да добавим една '(' в началото на низа, за да го направим балансиран: \"((()))\".\n    * Пример 2:\n    * Вход: s = \"((()))\"\n    * Изход: 0\n    *\n    * - s се състои само от '(' и ')'.\n    */\n public int minInsertions(String s) ",
      "zh": "class Solution {\n    /**\n    * 给定一个由 '(' 和 ')' 组成的字符串 s，s 中的左右括号可能不平衡。每次操作可以插入一个 '(' 或 ')'，计算所需的最小插入操作次数。使得 s 中的左右括号平衡。\n    *\n    * 示例 1:\n    * 输入: s = \"(()))\"\n    * 输出: 1\n    * 解释: 我们需要在字符串的开头添加一个 '(' 使其平衡: \"((()))\"。\n    * 示例 2:\n    * 输入: s = \"((()))\"\n    * 输出: 0\n    *\n    * - s 仅由 '(' 和 ')' 组成。\n    */\n public int minInsertions(String s) ",
      "fr": "class Solution {\n    /**\n    * Étant donné une chaîne s composée de '(' et ')', les parenthèses gauche et droite dans s peuvent être déséquilibrées. Chaque opération peut insérer un '(' ou ')', et calculer le nombre minimum d'opérations d'insertion requises. Rendre les parenthèses gauche et droite dans s équilibrées.\n    *\n    * Exemple 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explication: Nous devons ajouter un '(' au début de la chaîne pour la rendre équilibrée: \"((()))\".\n    * Exemple 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s se compose uniquement de '(' et ')'.\n    */\n public int minInsertions(String s) ",
      "de": "class Solution {\n    /**\n    * Gegeben ist ein String s, der aus '(' und ')' besteht. Die linken und rechten Klammern in s können unausgeglichen sein. Jede Operation kann ein '(' oder ')' einfügen und die minimale Anzahl der erforderlichen Einfügeoperationen berechnen. Bringen Sie die linken und rechten Klammern in s ins Gleichgewicht.\n    *\n    * Beispiel 1:\n    * Eingabe: s = \"(()))\"\n    * Ausgabe: 1\n    * Erklärung: Wir müssen ein '(' am Anfang des Strings hinzufügen, um ihn auszugleichen: \"((()))\".\n    * Beispiel 2:\n    * Eingabe: s = \"((()))\"\n    * Ausgabe: 0\n    *\n    * - s besteht nur aus '(' und ')'.\n    */\n public int minInsertions(String s) ",
      "ha": "class Solution {\n    /**\n    * An ba da wani kirtani s wanda aka hada da '(' da ')', za a iya samun rashin daidaito tsakanin kowane bangare na s. Kowace aiki na iya saka '(' ko ')', kuma a lissafta adadin mafi karancin ayyukan saka da ake bukata. Yi daidai tsakanin kowane bangare na s.\n    *\n    * Misali 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Bayani: Dole ne mu kara daya '(' a farkon kirtani don ya zama daidai: \"((()))\".\n    * Misali 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s ya kunshi '(' da ')' kawai.\n    */\n public int minInsertions(String s) ",
      "hi": "class Solution {\n    /**\n    * दिए गए स्ट्रिंग s में '(' और ')' होते हैं, s में बाएँ और दाएँ ब्रैकेट असंतुलित हो सकते हैं। प्रत्येक ऑपरेशन में '(' या ')' डाल सकते हैं, और आवश्यक न्यूनतम इनसर्शन ऑपरेशनों की संख्या की गणना करें। s में बाएँ और दाएँ ब्रैकेट को संतुलित बनाएं।\n    *\n    * उदाहरण 1:\n    * इनपुट: s = \"(()))\"\n    * आउटपुट: 1\n    * व्याख्या: हमें स्ट्रिंग के पहले एक '(' जोड़ने की आवश्यकता है ताकि यह संतुलित हो जाए: \"((()))\"।\n    * उदाहरण 2:\n    * इनपुट: s = \"((()))\"\n    * आउटपुट: 0\n    *\n    * - s केवल '(' और ')' से बना होता है।\n    */\n public int minInsertions(String s) ",
      "hu": "class Solution {\n    /**\n    * Adott egy s karakterlánc, amely '(' és ')' jelekből áll, az s-ben lévő bal és jobb zárójelek lehetnek kiegyensúlyozatlanok. Minden művelet során beilleszthetünk egy '(' vagy ')' jelet, és kiszámolhatjuk a szükséges beillesztési műveletek minimális számát. Tegyük kiegyensúlyozottá az s-ben lévő bal és jobb zárójeleket.\n    *\n    * Példa 1:\n    * Bemenet: s = \"(()))\"\n    * Kimenet: 1\n    * Magyarázat: Egy '(' jelet kell hozzáadnunk a karakterlánc elejére, hogy kiegyensúlyozott legyen: \"((()))\".\n    * Példa 2:\n    * Bemenet: s = \"((()))\"\n    * Kimenet: 0\n    *\n    * - s csak '(' és ')' jelekből áll.\n    */\n public int minInsertions(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9784478091361904",
      "hy": "0.9384198147500398",
      "bn": "0.9499689796249323",
      "bg": "0.980272626446758",
      "zh": "0.9427052652208675",
      "fr": "0.9801304070939371",
      "de": "0.9562729120278366",
      "ha": "0.9285721177190921",
      "hi": "0.9597844985341524",
      "hu": "0.9470262705299005"
    },
    "canonical_solution": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }",
    "instruction": {
      "en": "Write a Java function `public int minInsertions(String s)` to solve the following problem:\nGiven a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.",
      "sq": "Shkruani një funksion Java `public int minInsertions(String s)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg s të përbërë nga '(' dhe ')', kllapat e majta dhe të djathta në s mund të jenë të paekuilibruara. Çdo operacion mund të fusë një '(' ose ')', dhe llogaritni numrin minimal të operacioneve të futjes që kërkohen. Bëni që kllapat e majta dhe të djathta në s të jenë të ekuilibruara.\n\nShembulli 1:\nInput: s = \"(()))\"\nOutput: 1\nShpjegim: Duhet të shtojmë një '(' në fillim të vargut për ta bërë atë të ekuilibruar: \"((()))\".\nShembulli 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s përbëhet vetëm nga '(' dhe ')'.",
      "hy": "Java ֆունկցիա `public int minInsertions(String s)` գրեք հետևյալ խնդիրը լուծելու համար:\nՏրված է s տողը, որը կազմված է '(' և ')' սիմվոլներից, s-ի ձախ և աջ փակագծերը կարող են անհավասարակշռված լինել։ Յուրաքանչյուր գործողություն կարող է տեղադրել '(' կամ ')', և հաշվարկել անհրաժեշտ մինիմալ տեղադրման գործողությունների քանակը։ s-ի ձախ և աջ փակագծերը հավասարակշռված դարձնել։\n\nՕրինակ 1:\nՄուտք: s = \"(()))\"\nԵլք: 1\nԲացատրություն: Մենք պետք է ավելացնենք մեկ '(' տողի սկզբում, որպեսզի այն հավասարակշռված լինի: \"((()))\".\nՕրինակ 2:\nՄուտք: s = \"((()))\"\nԵլք: 0\n\n- s-ը բաղկացած է միայն '(' և ')' սիմվոլներից։",
      "bn": "একটি জাভা ফাংশন `public int minInsertions(String s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং s দেওয়া হয়েছে যা '(' এবং ')' নিয়ে গঠিত, s-এ বাম এবং ডান বন্ধনীগুলি ভারসাম্যহীন হতে পারে। প্রতিটি অপারেশন একটি '(' বা ')' সন্নিবেশ করতে পারে, এবং প্রয়োজনীয় সন্নিবেশ অপারেশনের সর্বনিম্ন সংখ্যা গণনা করুন। s-এ বাম এবং ডান বন্ধনীগুলি ভারসাম্যপূর্ণ করুন।\n\nউদাহরণ 1:\nইনপুট: s = \"(()))\"\nআউটপুট: 1\nব্যাখ্যা: স্ট্রিংটিকে ভারসাম্যপূর্ণ করতে আমাদের স্ট্রিংয়ের শুরুতে একটি '(' যোগ করতে হবে: \"((()))\"।\nউদাহরণ 2:\nইনপুট: s = \"((()))\"\nআউটপুট: 0\n\n- s শুধুমাত্র '(' এবং ')' নিয়ে গঠিত।",
      "bg": "Напишете Java функция `public int minInsertions(String s)`, за да решите следния проблем:  \nДаден е низ s, съставен от '(' и ')', лявите и десните скоби в s може да са небалансирани. Всяка операция може да вмъкне '(' или ')', и изчислете минималния брой операции на вмъкване, които са необходими. Направете така, че лявите и десните скоби в s да са балансирани.\n\nПример 1:  \nВход: s = \"(()))\"  \nИзход: 1  \nОбяснение: Трябва да добавим една '(' в началото на низа, за да го направим балансиран: \"((()))\".  \nПример 2:  \nВход: s = \"((()))\"  \nИзход: 0  \n\n- s се състои само от '(' и ')'.",
      "zh": "编写一个 Java 函数 `public int minInsertions(String s)` 来解决以下问题：  \n给定一个由 '(' 和 ')' 组成的字符串 s，s 中的左右括号可能不平衡。每次操作可以插入一个 '(' 或 ')'，计算所需的最小插入操作次数。使得 s 中的左右括号平衡。\n\n示例 1:  \n输入: s = \"(()))\"  \n输出: 1  \n解释: 我们需要在字符串的开头添加一个 '(' 使其平衡: \"((()))\"。  \n示例 2:  \n输入: s = \"((()))\"  \n输出: 0  \n\n- s 仅由 '(' 和 ')' 组成。",
      "fr": "Écrire une fonction Java `public int minInsertions(String s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne s composée de '(' et ')', les parenthèses gauche et droite dans s peuvent être déséquilibrées. Chaque opération peut insérer un '(' ou ')', et calculer le nombre minimum d'opérations d'insertion requises. Rendre les parenthèses gauche et droite dans s équilibrées.\n\nExemple 1 :  \nEntrée : s = \"(()))\"  \nSortie : 1  \nExplication : Nous devons ajouter un '(' au début de la chaîne pour la rendre équilibrée : \"((()))\".  \nExemple 2 :  \nEntrée : s = \"((()))\"  \nSortie : 0\n\n- s se compose uniquement de '(' et ')'.",
      "de": "Schreiben Sie eine Java-Funktion `public int minInsertions(String s)`, um das folgende Problem zu lösen:\nGegeben ist ein String s, der aus '(' und ')' besteht. Die linken und rechten Klammern in s können unausgeglichen sein. Jede Operation kann ein '(' oder ')' einfügen, und berechnen Sie die minimale Anzahl von Einfügeoperationen, die erforderlich sind. Machen Sie die linken und rechten Klammern in s ausgeglichen.\n\nBeispiel 1:\nEingabe: s = \"(()))\"\nAusgabe: 1\nErläuterung: Wir müssen ein '(' am Anfang des Strings hinzufügen, um ihn ausgeglichen zu machen: \"((()))\".\nBeispiel 2:\nEingabe: s = \"((()))\"\nAusgabe: 0\n\n- s besteht nur aus '(' und ')'.",
      "ha": "Rubuta aikin Java `public int minInsertions(String s)` don warware matsalar mai zuwa:\nAn ba da wani kirtani s wanda aka hada da '(' da ')', za a iya samun rashin daidaito tsakanin kowane bangare na s. Kowace aiki na iya saka '(' ko ')', kuma a lissafa adadin mafi karancin ayyukan saka da ake bukata. Yi daidai tsakanin kowane bangare na s.\n\nMisali na 1:\nInput: s = \"(()))\"\nOutput: 1\nBayani: Dole ne mu kara wani '(' a farkon kirtani don daidaita shi: \"((()))\".\nMisali na 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s ya ƙunshi '(' da ')' kawai.",
      "hi": "Java फ़ंक्शन `public int minInsertions(String s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग s में '(' और ')' से मिलकर बने होते हैं, s में बाएँ और दाएँ ब्रैकेट असंतुलित हो सकते हैं। प्रत्येक ऑपरेशन में '(' या ')' डाल सकते हैं, और आवश्यक न्यूनतम संख्या में डालने के ऑपरेशनों की गणना करें। s में बाएँ और दाएँ ब्रैकेट को संतुलित बनाएं।\n\nउदाहरण 1:\nइनपुट: s = \"(()))\"\nआउटपुट: 1\nव्याख्या: हमें स्ट्रिंग के पहले एक '(' जोड़ने की आवश्यकता है ताकि यह संतुलित हो जाए: \"((()))\"।\nउदाहरण 2:\nइनपुट: s = \"((()))\"\nआउटपुट: 0\n\n- s केवल '(' और ')' से बना होता है।",
      "hu": "Írj egy Java függvényt `public int minInsertions(String s)` a következő probléma megoldására:\nAdott egy s karakterlánc, amely '(' és ')' karakterekből áll, az s-ben lévő bal és jobb zárójelek lehetnek kiegyensúlyozatlanok. Minden művelet során beilleszthetünk egy '(' vagy ')' karaktert, és számoljuk ki a szükséges beillesztési műveletek minimális számát. Tegyük az s-ben lévő bal és jobb zárójeleket kiegyensúlyozottá.\n\n1. példa:\nBemenet: s = \"(()))\"\nKimenet: 1\nMagyarázat: Egy '(' karaktert kell hozzáadnunk a karakterlánc elejére, hogy kiegyensúlyozott legyen: \"((()))\".\n2. példa:\nBemenet: s = \"((()))\"\nKimenet: 0\n\n- s csak '(' és ')' karakterekből áll."
    },
    "instruction_bertscore": {
      "sq": "0.9798314683704795",
      "hy": "0.9492564924481602",
      "bn": "0.9640014215235231",
      "bg": "0.9775716505254456",
      "zh": "0.9415099075877996",
      "fr": "0.9798314683704795",
      "de": "0.964279702687353",
      "ha": "0.9186189479558149",
      "hi": "0.959389224075893",
      "hu": "0.9485684368082554"
    },
    "level": "hard",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "minInsertions",
    "signature": "public int minInsertions(String s)",
    "docstring": {
      "en": "Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.",
      "sq": "Duke pasur një varg s të përbërë nga '(' dhe ')', kllapat e majta dhe të djathta në s mund të jenë të pabalancuara. Çdo operacion mund të fusë një '(' ose ')', dhe llogarit numrin minimal të operacioneve të futjes së kërkuara. Bëni që kllapat e majta dhe të djathta në s të jenë të balancuara.\n\nShembull 1:\nInput: s = \"(()))\"\nOutput: 1\nShpjegim: Duhet të shtojmë një '(' në fillim të vargut për ta bërë atë të balancuar: \"((()))\".\nShembull 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s përbëhet vetëm nga '(' dhe ')'.",
      "hy": "Տրված է տող s, որը կազմված է '(' և ')' նշաններից, և s-ի մեջ ձախ և աջ փակագծերը կարող են անհավասարակշռված լինել: Յուրաքանչյուր գործողություն կարող է տեղադրել '(' կամ ')', և հաշվարկել անհրաժեշտ ներդրման գործողությունների նվազագույն քանակը: Դարձրեք այնպես, որ s-ի ձախ և աջ փակագծերը հավասարակշռված լինեն:\n\nՕրինակ 1:\nՄուտքագրում: s = \"(()))\"\nԵլք: 1\nԲացատրություն: Մենք պետք է ավելացնենք մեկ '(' տողի սկզբում, որպեսզի այն հավասարակշռված լինի: \"((()))\".\nՕրինակ 2:\nՄուտքագրում: s = \"((()))\"\nԵլք: 0\n\n- s-ը բաղկացած է միայն '(' և ')' նշաններից:",
      "bn": "একটি স্ট্রিং s দেওয়া হয়েছে যা '(' এবং ')' দিয়ে গঠিত, s-এ বাম এবং ডান বন্ধনী অসমতল হতে পারে। প্রতিটি অপারেশন একটি '(' বা ')' সন্নিবেশ করতে পারে এবং প্রয়োজনীয় সন্নিবেশ অপারেশনের সর্বনিম্ন সংখ্যা গণনা করতে পারে। s-এ বাম এবং ডান বন্ধনীকে ভারসাম্যপূর্ণ করুন।\n\nউদাহরণ ১:\nইনপুট: s = \"(()))\"\nআউটপুট: 1\nব্যাখ্যা: স্ট্রিংটিকে ভারসাম্যপূর্ণ করতে আমাদের স্ট্রিংয়ের শুরুতে একটি '(' যোগ করতে হবে: \"((()))\"।\n\nউদাহরণ ২:\nইনপুট: s = \"((()))\"\nআউটপুট: 0\n\n- s শুধুমাত্র '(' এবং ')' নিয়ে গঠিত।",
      "bg": "Даден е низ s, съставен от '(' и ')', като левите и десните скоби в s могат да бъдат небалансирани. Всяка операция може да вмъкне '(' или ')', и изчислява минималния брой операции за вмъкване, които са необходими. Направете така, че левите и десните скоби в s да бъдат балансирани.\n\nПример 1:\nВход: s = \"(()))\"\nИзход: 1\nОбяснение: Трябва да добавим една '(' в началото на низа, за да го направим балансиран: \"((()))\".\nПример 2:\nВход: s = \"((()))\"\nИзход: 0\n\n- s се състои само от '(' и ')'.",
      "zh": "给定一个由 '(' 和 ')' 组成的字符串 s，s 中的左右括号可能是不平衡的。每次操作可以插入一个 '(' 或 ')'，计算所需的最小插入操作次数。使得 s 中的左右括号平衡。\n\n示例 1:\n输入: s = \"(()))\"\n输出: 1\n解释: 我们需要在字符串的开头添加一个 '(' 使其平衡: \"((()))\"。\n示例 2:\n输入: s = \"((()))\"\n输出: 0\n\n- s 仅由 '(' 和 ')' 组成。",
      "fr": "Étant donné une chaîne s composée de '(' et ')', les parenthèses gauche et droite dans s peuvent être déséquilibrées. Chaque opération peut insérer un '(' ou ')', et calculer le nombre minimum d'opérations d'insertion requises. Rendre les parenthèses gauche et droite dans s équilibrées.\n\nExemple 1 :\nEntrée : s = \"(()))\"\nSortie : 1\nExplication : Nous devons ajouter un '(' au début de la chaîne pour la rendre équilibrée : \"((()))\".\nExemple 2 :\nEntrée : s = \"((()))\"\nSortie : 0\n\n- s se compose uniquement de '(' et ')'.",
      "de": "An ba da wani kirtani s wanda aka hada da '(' da ')', za a iya samun rashin daidaito tsakanin kowane bangare na s. Kowace aiki na iya saka '(' ko ')', kuma a lissafa adadin mafi karancin ayyukan saka da ake bukata. Yi daidai tsakanin kowane bangare na s.\n\nBeispiel 1:\nEingabe: s = \"(()))\"\nAusgabe: 1\nErläuterung: Wir müssen ein '(' am Anfang des Strings hinzufügen, um ihn ausbalanciert zu machen: \"((()))\".\nBeispiel 2:\nEingabe: s = \"((()))\"\nAusgabe: 0\n\n- s besteht nur aus '(' und ')'.",
      "ha": "An ba da wata ƙirtani s da aka haɗa da '(' da ')', za a iya samun rashin daidaito tsakanin manyan da ƙananan baka a cikin s. Kowace aiki na iya saka '(' ko ')', kuma a lissafa mafi ƙarancin adadin ayyukan saka da ake buƙata. Yi daidai da manyan da ƙananan baka a cikin s.\n\nMisali na 1:\nInput: s = \"(()))\"\nOutput: 1\nBayani: Muna buƙatar ƙara ɗaya '(' a farkon ƙirtanin don ya zama daidai: \"((()))\".\nMisali na 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s ya ƙunshi '(' da ')' kawai.",
      "hi": "एक स्ट्रिंग s दी गई है जो '(' और ')' से बनी है, s में बाएँ और दाएँ ब्रैकेट असंतुलित हो सकते हैं। प्रत्येक ऑपरेशन में '(' या ')' डाल सकते हैं, और आवश्यक न्यूनतम संख्या में डालने के ऑपरेशनों की गणना करें। s में बाएँ और दाएँ ब्रैकेट को संतुलित बनाएं।\n\nउदाहरण 1:\nइनपुट: s = \"(()))\"\nआउटपुट: 1\nव्याख्या: स्ट्रिंग को संतुलित बनाने के लिए हमें स्ट्रिंग की शुरुआत में एक '(' जोड़ने की आवश्यकता है: \"((()))\"।\n\nउदाहरण 2:\nइनपुट: s = \"((()))\"\nआउटपुट: 0\n\n- s केवल '(' और ')' से बना है।",
      "hu": "Adott egy s karakterlánc, amely '(' és ')' jelekből áll, az s-ben lévő bal és jobb zárójelek lehetnek kiegyensúlyozatlanok. Minden művelet során beilleszthetünk egy '(' vagy ')' jelet, és kiszámíthatjuk a szükséges beillesztési műveletek minimális számát. Tegyük kiegyensúlyozottá az s-ben lévő bal és jobb zárójeleket.\n\nPélda 1:\nBemenet: s = \"(()))\"\nKimenet: 1\nMagyarázat: Egy '(' jelet kell hozzáadnunk a karakterlánc elejére, hogy kiegyensúlyozott legyen: \"((()))\".\nPélda 2:\nBemenet: s = \"((()))\"\nKimenet: 0\n\n- s csak '(' és ')' jelekből áll."
    },
    "docstring_bertscore": {
      "sq": "0.9783884186522611",
      "hy": "0.9477562371802037",
      "bn": "0.9517673790948222",
      "bg": "0.9595453475553863",
      "zh": "0.947182394009394",
      "fr": "0.9781500621950192",
      "de": "0.985527790437798",
      "ha": "0.9329793286134942",
      "hi": "0.9331437945689911",
      "hu": "0.9397039601634304"
    }
  },
  {
    "task_id": "Java/25",
    "prompt": {
      "en": "class Solution {\n  /**\n  * Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\n  * The array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\n  * In one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\n  * The goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n  *\n  * Example 1:\n  * Input: n = 3\n  * Output: 2\n  * Explanation: arr = [1, 3, 5]\n  * First operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Second operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Example 2:\n  * Input: n = 6\n  * Output: 9\n  */\n  public int minOperations(int n) ",
      "sq": "class Solution {\n  /**\n  * Duke pasur një numër të plotë n, kthe numrin minimal të operacioneve të kërkuara për të bërë të gjitha elementet në vargun arr të barabarta.\n  * Vargu arr ka një gjatësi prej n, dhe arr[i] = (2 * i) + 1 për 0 <= i < n.\n  * Në një operacion, ju mund të zgjidhni dy indekse x dhe y (0 <= x, y < n) dhe të zbritni 1 nga arr[x] dhe të shtoni 1 në arr[y] (d.m.th., arr[x] -= 1 dhe arr[y] += 1).\n  * Qëllimi është që të gjitha elementet në arr të bëhen të barabarta. Rastet e testimit do të sigurojnë që pas kryerjes së disa operacioneve, të gjitha elementet në arr mund të bëhen të barabarta.\n  *\n  * Shembull 1:\n  * Hyrja: n = 3\n  * Dalja: 2\n  * Shpjegim: arr = [1, 3, 5]\n  * Operacioni i parë: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Operacioni i dytë: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Shembull 2:\n  * Hyrja: n = 6\n  * Dalja: 9\n  */\n  public int minOperations(int n) ",
      "hy": "class Solution {\n  /**\n  * Տրված է ամբողջ թիվ n, վերադարձնել գործողությունների նվազագույն քանակը, որը պահանջվում է, որպեսզի զանգվածի բոլոր տարրերը arr հավասարվեն:\n  * Զանգվածը arr ունի n երկարություն, և arr[i] = (2 * i) + 1 համար 0 <= i < n:\n  * Մեկ գործողության ընթացքում, դուք կարող եք ընտրել երկու ինդեքս x և y (0 <= x, y < n) և հանել 1 arr[x]-ից և ավելացնել 1 arr[y]-ին (այսինքն՝ arr[x] -= 1 և arr[y] += 1):\n  * Նպատակն է, որպեսզի arr-ի բոլոր տարրերը հավասարվեն: Թեստային դեպքերը կապահովեն, որ որոշ գործողություններ կատարելուց հետո arr-ի բոլոր տարրերը կարող են հավասարվել:\n  *\n  * Օրինակ 1:\n  * Մուտք: n = 3\n  * Ելք: 2\n  * Բացատրություն: arr = [1, 3, 5]\n  * Առաջին գործողություն: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Երկրորդ գործողություն: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Օրինակ 2:\n  * Մուտք: n = 6\n  * Ելք: 9\n  */\n  public int minOperations(int n) ",
      "bn": "class Solution {\n  /**\n  * একটি পূর্ণসংখ্যা n দেওয়া হলে, arr অ্যারেতে সমস্ত উপাদান সমান করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন ফেরত দিন।\n  * অ্যারে arr এর দৈর্ঘ্য n, এবং arr[i] = (2 * i) + 1 যেখানে 0 <= i < n।\n  * একটি অপারেশনে, আপনি দুটি সূচক x এবং y (0 <= x, y < n) নির্বাচন করতে পারেন এবং arr[x] থেকে 1 বিয়োগ করতে পারেন এবং arr[y] তে 1 যোগ করতে পারেন (অর্থাৎ, arr[x] -= 1 এবং arr[y] += 1)।\n  * লক্ষ্য হল arr এর সমস্ত উপাদান সমান করা। পরীক্ষার ক্ষেত্রে নিশ্চিত করা হবে যে কিছু অপারেশন করার পরে, arr এর সমস্ত উপাদান সমান করা যেতে পারে।\n  *\n  * উদাহরণ 1:\n  * ইনপুট: n = 3\n  * আউটপুট: 2\n  * ব্যাখ্যা: arr = [1, 3, 5]\n  * প্রথম অপারেশন: x = 2, y = 0 -> arr = [2, 3, 4]\n  * দ্বিতীয় অপারেশন: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * উদাহরণ 2:\n  * ইনপুট: n = 6\n  * আউটপুট: 9\n  */\n  public int minOperations(int n) ",
      "bg": "class Solution {\n  /**\n  * Дадено е цяло число n, върнете минималния брой операции, необходими за да направите всички елементи в масива arr равни.\n  * Масивът arr има дължина n, и arr[i] = (2 * i) + 1 за 0 <= i < n.\n  * В една операция можете да изберете два индекса x и y (0 <= x, y < n) и да извадите 1 от arr[x] и да добавите 1 към arr[y] (т.е., arr[x] -= 1 и arr[y] += 1).\n  * Целта е да направите всички елементи в arr равни. Тестовите случаи ще гарантират, че след извършване на някои операции, всички елементи в arr могат да бъдат направени равни.\n  *\n  * Пример 1:\n  * Вход: n = 3\n  * Изход: 2\n  * Обяснение: arr = [1, 3, 5]\n  * Първа операция: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Втора операция: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Пример 2:\n  * Вход: n = 6\n  * Изход: 9\n  */\n  public int minOperations(int n) ",
      "zh": "class Solution {\n  /**\n  * 给定一个整数 n，返回使数组 arr 中所有元素相等所需的最小操作次数。\n  * 数组 arr 的长度为 n，并且 arr[i] = (2 * i) + 1，其中 0 <= i < n。\n  * 在一次操作中，你可以选择两个索引 x 和 y (0 <= x, y < n)，然后从 arr[x] 减去 1 并加到 arr[y] 上（即，arr[x] -= 1 和 arr[y] += 1）。\n  * 目标是使 arr 中所有元素相等。测试用例将确保在执行某些操作后，arr 中的所有元素可以变得相等。\n  *\n  * 示例 1:\n  * 输入: n = 3\n  * 输出: 2\n  * 解释: arr = [1, 3, 5]\n  * 第一次操作: x = 2, y = 0 -> arr = [2, 3, 4]\n  * 第二次操作: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * 示例 2:\n  * 输入: n = 6\n  * 输出: 9\n  */\n  public int minOperations(int n) ",
      "fr": "class Solution {\n  /**\n  * Étant donné un entier n, retourne le nombre minimum d'opérations nécessaires pour rendre tous les éléments du tableau arr égaux.\n  * Le tableau arr a une longueur de n, et arr[i] = (2 * i) + 1 pour 0 <= i < n.\n  * En une opération, vous pouvez sélectionner deux indices x et y (0 <= x, y < n) et soustraire 1 de arr[x] et ajouter 1 à arr[y] (c'est-à-dire, arr[x] -= 1 et arr[y] += 1).\n  * L'objectif est de rendre tous les éléments de arr égaux. Les cas de test garantiront qu'après avoir effectué certaines opérations, tous les éléments de arr peuvent être rendus égaux.\n  *\n  * Exemple 1 :\n  * Entrée : n = 3\n  * Sortie : 2\n  * Explication : arr = [1, 3, 5]\n  * Première opération : x = 2, y = 0 -> arr = [2, 3, 4]\n  * Deuxième opération : x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Exemple 2 :\n  * Entrée : n = 6\n  * Sortie : 9\n  */\n  public int minOperations(int n) ",
      "de": "class Solution {\n  /**\n  * Gegeben eine ganze Zahl n, gib die minimale Anzahl von Operationen zurück, die erforderlich sind, um alle Elemente im Array arr gleich zu machen.\n  * Das Array arr hat eine Länge von n, und arr[i] = (2 * i) + 1 für 0 <= i < n.\n  * In einer Operation kannst du zwei Indizes x und y (0 <= x, y < n) auswählen und 1 von arr[x] subtrahieren und 1 zu arr[y] addieren (d.h., arr[x] -= 1 und arr[y] += 1).\n  * Das Ziel ist es, alle Elemente in arr gleich zu machen. Die Testfälle werden sicherstellen, dass nach einigen Operationen alle Elemente in arr gleich gemacht werden können.\n  *\n  * Beispiel 1:\n  * Eingabe: n = 3\n  * Ausgabe: 2\n  * Erklärung: arr = [1, 3, 5]\n  * Erste Operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Zweite Operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Beispiel 2:\n  * Eingabe: n = 6\n  * Ausgabe: 9\n  */\n  public int minOperations(int n) ",
      "ha": "class Solution {\n  /**\n  * An ba da cikakken lamba n, mayar da mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk abubuwan da ke cikin jerin arr su zama daidai.\n  * Jerin arr yana da tsawon n, kuma arr[i] = (2 * i) + 1 don 0 <= i < n.\n  * A cikin aiki guda, za ka iya zaɓar alamomi biyu x da y (0 <= x, y < n) kuma ka rage 1 daga arr[x] kuma ka ƙara 1 zuwa arr[y] (watau, arr[x] -= 1 da arr[y] += 1).\n  * Manufar ita ce a sanya duk abubuwan da ke cikin arr su zama daidai. Gwajin zai tabbatar da cewa bayan yin wasu ayyuka, duk abubuwan da ke cikin arr za a iya sanya su daidai.\n  *\n  * Misali 1:\n  * Shigarwa: n = 3\n  * Fitarwa: 2\n  * Bayani: arr = [1, 3, 5]\n  * Aiki na farko: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Aiki na biyu: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Misali 2:\n  * Shigarwa: n = 6\n  * Fitarwa: 9\n  */\n  public int minOperations(int n) ",
      "hi": "class Solution {\n  /**\n  * दिए गए एक पूर्णांक n के लिए, arr में सभी तत्वों को समान बनाने के लिए आवश्यक न्यूनतम संचालन की संख्या लौटाएं।\n  * सरणी arr की लंबाई n है, और arr[i] = (2 * i) + 1 जहाँ 0 <= i < n।\n  * एक ऑपरेशन में, आप दो सूचकांक x और y (0 <= x, y < n) का चयन कर सकते हैं और arr[x] से 1 घटा सकते हैं और arr[y] में 1 जोड़ सकते हैं (अर्थात, arr[x] -= 1 और arr[y] += 1)।\n  * लक्ष्य है कि arr में सभी तत्वों को समान बनाया जाए। परीक्षण मामले सुनिश्चित करेंगे कि कुछ संचालन करने के बाद, arr में सभी तत्व समान बनाए जा सकते हैं।\n  *\n  * उदाहरण 1:\n  * इनपुट: n = 3\n  * आउटपुट: 2\n  * व्याख्या: arr = [1, 3, 5]\n  * पहला ऑपरेशन: x = 2, y = 0 -> arr = [2, 3, 4]\n  * दूसरा ऑपरेशन: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * उदाहरण 2:\n  * इनपुट: n = 6\n  * आउटपुट: 9\n  */\n  public int minOperations(int n) ",
      "hu": "class Solution {\n  /**\n  * Adott egy egész szám n, adja vissza a minimális műveletek számát, amely szükséges ahhoz, hogy az arr tömb összes eleme egyenlő legyen.\n  * Az arr tömb hossza n, és arr[i] = (2 * i) + 1, ahol 0 <= i < n.\n  * Egy művelet során kiválaszthat két indexet, x és y (0 <= x, y < n), és kivonhat 1-et arr[x]-ből, valamint hozzáadhat 1-et arr[y]-hoz (azaz arr[x] -= 1 és arr[y] += 1).\n  * A cél az, hogy az arr összes eleme egyenlő legyen. A tesztesetek biztosítják, hogy néhány művelet végrehajtása után az arr összes eleme egyenlővé tehető.\n  *\n  * 1. példa:\n  * Bemenet: n = 3\n  * Kimenet: 2\n  * Magyarázat: arr = [1, 3, 5]\n  * Első művelet: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Második művelet: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * 2. példa:\n  * Bemenet: n = 6\n  * Kimenet: 9\n  */\n  public int minOperations(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9967186261053036",
      "hy": "0.9947774113914497",
      "bn": "0.9833845686264316",
      "bg": "0.9991818414605173",
      "zh": "0.9856503453828965",
      "fr": "0.9968713728683195",
      "de": "0.9968735578025109",
      "ha": "0.9859778868812231",
      "hi": "0.9847857073342517",
      "hu": "0.9841061928007313"
    },
    "canonical_solution": "  {\n\n      return n * n / 4;\n  }",
    "instruction": {
      "en": "Write a Java function `public int minOperations(int n)` to solve the following problem:\nGiven an integer n, return the minimum number of operations required to make all elements in the array arr equal.\nThe array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\nIn one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\nThe goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:\nInput: n = 6\nOutput: 9",
      "sq": "Shkruani një funksion Java `public int minOperations(int n)` për të zgjidhur problemin në vijim:\nDuke pasur një numër të plotë n, ktheni numrin minimal të operacioneve të nevojshme për të bërë të gjitha elementet në vargun arr të barabartë.\nVargu arr ka një gjatësi n, dhe arr[i] = (2 * i) + 1 për 0 <= i < n.\nNë një operacion, ju mund të zgjidhni dy indekse x dhe y (0 <= x, y < n) dhe të zbrisni 1 nga arr[x] dhe të shtoni 1 në arr[y] (d.m.th., arr[x] -= 1 dhe arr[y] += 1).\nQëllimi është të bëni të gjitha elementet në arr të barabartë. Rastet e testimit do të sigurojnë që pas kryerjes së disa operacioneve, të gjitha elementet në arr mund të bëhen të barabarta.\n\nShembull 1:\nInput: n = 3\nOutput: 2\nShpjegim: arr = [1, 3, 5]\nOperacioni i parë: x = 2, y = 0 -> arr = [2, 3, 4]\nOperacioni i dytë: x = 2, y = 0 -> arr = [3, 3, 3]\n\nShembull 2:\nInput: n = 6\nOutput: 9",
      "hy": "Գրեք Java ֆունկցիա `public int minOperations(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ n թիվը, վերադարձնել նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի զանգվածի բոլոր տարրերը հավասար դառնան:\nԶանգվածը ունի n երկարություն, և arr[i] = (2 * i) + 1 համար 0 <= i < n:\nՄեկ գործողության ժամանակ, դուք կարող եք ընտրել երկու ինդեքս x և y (0 <= x, y < n) և հանել 1 arr[x]-ից և գումարել 1 arr[y]-ին (այսինքն՝ arr[x] -= 1 և arr[y] += 1):\nՆպատակն է, որպեսզի arr-ի բոլոր տարրերը հավասար դառնան: Թեստային դեպքերը կապահովեն, որ որոշ գործողություններից հետո arr-ի բոլոր տարրերը կարող են հավասար դառնալ:\n\nՕրինակ 1:\nՄուտք: n = 3\nԵլք: 2\nԲացատրություն: arr = [1, 3, 5]\nԱռաջին գործողություն: x = 2, y = 0 -> arr = [2, 3, 4]\nԵրկրորդ գործողություն: x = 2, y = 0 -> arr = [3, 3, 3]\n\nՕրինակ 2:\nՄուտք: n = 6\nԵլք: 9",
      "bn": "একটি জাভা ফাংশন `public int minOperations(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হয়েছে, n দৈর্ঘ্যের অ্যারের সব উপাদানকে সমান করতে প্রয়োজনীয় সর্বনিম্ন অপারেশনের সংখ্যা ফেরত দিন।\nঅ্যারে arr এর দৈর্ঘ্য n, এবং arr[i] = (2 * i) + 1 যেখানে 0 <= i < n।\nএকটি অপারেশনে, আপনি দুটি ইনডেক্স x এবং y (0 <= x, y < n) নির্বাচন করতে পারেন এবং arr[x] থেকে 1 বিয়োগ করতে পারেন এবং arr[y] তে 1 যোগ করতে পারেন (অর্থাৎ, arr[x] -= 1 এবং arr[y] += 1)।\nলক্ষ্য হল arr এর সব উপাদানকে সমান করা। টেস্ট কেসগুলি নিশ্চিত করবে যে কিছু অপারেশন করার পরে, arr এর সব উপাদান সমান করা যেতে পারে।\n\nউদাহরণ 1:\nইনপুট: n = 3\nআউটপুট: 2\nব্যাখ্যা: arr = [1, 3, 5]\nপ্রথম অপারেশন: x = 2, y = 0 -> arr = [2, 3, 4]\nদ্বিতীয় অপারেশন: x = 2, y = 0 -> arr = [3, 3, 3]\n\nউদাহরণ 2:\nইনপুট: n = 6\nআউটপুট: 9",
      "bg": "Напишете Java функция `public int minOperations(int n)`, за да решите следния проблем:\nДадено е цяло число n, върнете минималния брой операции, необходими, за да направите всички елементи в масива arr равни.\nМасивът arr има дължина n, и arr[i] = (2 * i) + 1 за 0 <= i < n.\nПри една операция можете да изберете два индекса x и y (0 <= x, y < n) и да извадите 1 от arr[x] и да добавите 1 към arr[y] (т.е. arr[x] -= 1 и arr[y] += 1).\nЦелта е да направите всички елементи в arr равни. Тестовите случаи ще гарантират, че след извършване на някои операции всички елементи в arr могат да бъдат направени равни.\n\nПример 1:\nВход: n = 3\nИзход: 2\nОбяснение: arr = [1, 3, 5]\nПърва операция: x = 2, y = 0 -> arr = [2, 3, 4]\nВтора операция: x = 2, y = 0 -> arr = [3, 3, 3]\n\nПример 2:\nВход: n = 6\nИзход: 9",
      "zh": "编写一个 Java 函数 `public int minOperations(int n)` 来解决以下问题：\n给定一个整数 n，返回使数组 arr 中所有元素相等所需的最小操作次数。\n数组 arr 的长度为 n，且 arr[i] = (2 * i) + 1，其中 0 <= i < n。\n在一次操作中，你可以选择两个索引 x 和 y (0 <= x, y < n)，然后从 arr[x] 中减去 1 并将其加到 arr[y] 中（即，arr[x] -= 1 和 arr[y] += 1）。\n目标是使 arr 中的所有元素相等。测试用例将确保在执行一些操作后，arr 中的所有元素可以变得相等。\n\n示例 1:\n输入: n = 3\n输出: 2\n解释: arr = [1, 3, 5]\n第一次操作: x = 2, y = 0 -> arr = [2, 3, 4]\n第二次操作: x = 2, y = 0 -> arr = [3, 3, 3]\n\n示例 2:\n输入: n = 6\n输出: 9",
      "fr": "Écrire une fonction Java `public int minOperations(int n)` pour résoudre le problème suivant :\nÉtant donné un entier n, retourner le nombre minimum d'opérations nécessaires pour rendre tous les éléments du tableau arr égaux.\nLe tableau arr a une longueur de n, et arr[i] = (2 * i) + 1 pour 0 <= i < n.\nDans une opération, vous pouvez sélectionner deux indices x et y (0 <= x, y < n) et soustraire 1 de arr[x] et ajouter 1 à arr[y] (c'est-à-dire, arr[x] -= 1 et arr[y] += 1).\nL'objectif est de rendre tous les éléments de arr égaux. Les cas de test garantiront qu'après avoir effectué certaines opérations, tous les éléments de arr peuvent être rendus égaux.\n\nExemple 1 :\nEntrée : n = 3\nSortie : 2\nExplication : arr = [1, 3, 5]\nPremière opération : x = 2, y = 0 -> arr = [2, 3, 4]\nDeuxième opération : x = 2, y = 0 -> arr = [3, 3, 3]\n\nExemple 2 :\nEntrée : n = 6\nSortie : 9",
      "de": "Schreiben Sie eine Java-Funktion `public int minOperations(int n)`, um das folgende Problem zu lösen:\nGegeben ist eine ganze Zahl n, geben Sie die minimale Anzahl von Operationen zurück, die erforderlich sind, um alle Elemente im Array arr gleich zu machen.\nDas Array arr hat eine Länge von n, und arr[i] = (2 * i) + 1 für 0 <= i < n.\nIn einer Operation können Sie zwei Indizes x und y (0 <= x, y < n) auswählen und 1 von arr[x] subtrahieren und 1 zu arr[y] addieren (d.h. arr[x] -= 1 und arr[y] += 1).\nDas Ziel ist es, alle Elemente in arr gleich zu machen. Die Testfälle werden sicherstellen, dass nach einigen Operationen alle Elemente in arr gleich gemacht werden können.\n\nBeispiel 1:\nEingabe: n = 3\nAusgabe: 2\nErläuterung: arr = [1, 3, 5]\nErste Operation: x = 2, y = 0 -> arr = [2, 3, 4]\nZweite Operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nBeispiel 2:\nEingabe: n = 6\nAusgabe: 9",
      "ha": "Rubuta aikin Java `public int minOperations(int n)` don warware matsalar mai zuwa:\nAn ba da cikakken lamba n, dawo da mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk abubuwan cikin jerin arr su zama daidai.\nJerin arr yana da tsawon n, kuma arr[i] = (2 * i) + 1 don 0 <= i < n.\nA cikin aiki guda, za ka iya zaɓar abubuwa biyu x da y (0 <= x, y < n) kuma rage 1 daga arr[x] da ƙara 1 zuwa arr[y] (watau, arr[x] -= 1 da arr[y] += 1).\nManufar ita ce sanya duk abubuwan cikin arr su zama daidai. Gwaje-gwajen za su tabbatar da cewa bayan yin wasu ayyuka, duk abubuwan cikin arr za a iya sanya su daidai.\n\nMisali na 1:\nShigarwa: n = 3\nFitarwa: 2\nBayani: arr = [1, 3, 5]\nAikin farko: x = 2, y = 0 -> arr = [2, 3, 4]\nAikin na biyu: x = 2, y = 0 -> arr = [3, 3, 3]\n\nMisali na 2:\nShigarwa: n = 6\nFitarwa: 9",
      "hi": "Java फ़ंक्शन `public int minOperations(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के लिए, arr में सभी तत्वों को समान बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या लौटाएं।\narray arr की लंबाई n है, और arr[i] = (2 * i) + 1 जहाँ 0 <= i < n।\nएक ऑपरेशन में, आप दो इंडेक्स x और y (0 <= x, y < n) का चयन कर सकते हैं और arr[x] से 1 घटा सकते हैं और arr[y] में 1 जोड़ सकते हैं (अर्थात, arr[x] -= 1 और arr[y] += 1)।\nउद्देश्य यह है कि arr में सभी तत्व समान हो जाएं। परीक्षण मामले यह सुनिश्चित करेंगे कि कुछ ऑपरेशनों को करने के बाद, arr में सभी तत्व समान बनाए जा सकते हैं।\n\nउदाहरण 1:\nइनपुट: n = 3\nआउटपुट: 2\nव्याख्या: arr = [1, 3, 5]\nपहला ऑपरेशन: x = 2, y = 0 -> arr = [2, 3, 4]\nदूसरा ऑपरेशन: x = 2, y = 0 -> arr = [3, 3, 3]\n\nउदाहरण 2:\nइनपुट: n = 6\nआउटपुट: 9",
      "hu": "Írj egy Java függvényt `public int minOperations(int n)` a következő probléma megoldására:\nAdott egy egész szám n, add vissza a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az arr tömb összes eleme egyenlő legyen.\nAz arr tömb hossza n, és arr[i] = (2 * i) + 1, ahol 0 <= i < n.\nEgy művelet során kiválaszthatsz két indexet, x és y (0 <= x, y < n), és kivonhatsz 1-et arr[x]-ből, valamint hozzáadhatsz 1-et arr[y]-hoz (azaz, arr[x] -= 1 és arr[y] += 1).\nA cél az, hogy az arr összes eleme egyenlő legyen. A tesztesetek biztosítják, hogy néhány művelet végrehajtása után az arr összes eleme egyenlővé tehető.\n\n1. példa:\nBemenet: n = 3\nKimenet: 2\nMagyarázat: arr = [1, 3, 5]\nElső művelet: x = 2, y = 0 -> arr = [2, 3, 4]\nMásodik művelet: x = 2, y = 0 -> arr = [3, 3, 3]\n\n2. példa:\nBemenet: n = 6\nKimenet: 9"
    },
    "instruction_bertscore": {
      "sq": "0.9960397074629264",
      "hy": "0.9799544205763401",
      "bn": "0.9845356316845287",
      "bg": "0.9960397074629264",
      "zh": "0.9826160676822077",
      "fr": "0.9974485927556068",
      "de": "0.9937409580632096",
      "ha": "0.9868449084944404",
      "hi": "0.971192039947367",
      "hu": "0.9802340921528372"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.minOperations(4) == 4;\n      assert solution.minOperations(5) == 6;\n      assert solution.minOperations(7) == 12;\n      System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minOperations",
    "signature": "public int minOperations(int n)",
    "docstring": {
      "en": "Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\nThe array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\nIn one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\nThe goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:\nInput: n = 6\nOutput: 9",
      "sq": "Duke pasur një numër të plotë n, kthe numrin minimal të operacioneve të nevojshme për të bërë të gjitha elementet në vargun arr të barabarta. Vargu arr ka një gjatësi n, dhe arr[i] = (2 * i) + 1 për 0 <= i < n. Në një operacion, ju mund të zgjidhni dy indekse x dhe y (0 <= x, y < n) dhe të zbrisni 1 nga arr[x] dhe të shtoni 1 në arr[y] (d.m.th., arr[x] -= 1 dhe arr[y] += 1). Qëllimi është të bëni të gjitha elementet në arr të barabarta. Rastet e testimit do të sigurojnë që pas kryerjes së disa operacioneve, të gjitha elementet në arr mund të bëhen të barabarta.\n\nShembull 1:\nInput: n = 3\nOutput: 2\nShpjegim: arr = [1, 3, 5]\nOperacioni i parë: x = 2, y = 0 -> arr = [2, 3, 4]\nOperacioni i dytë: x = 2, y = 0 -> arr = [3, 3, 3]\n\nShembull 2:\nInput: n = 6\nOutput: 9",
      "hy": "Տրված է ամբողջ թիվ n, վերադարձնել նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են, որպեսզի զանգվածի բոլոր տարրերը arr հավասար լինեն:\nԶանգվածը arr ունի n երկարություն, և arr[i] = (2 * i) + 1 0 <= i < n համար:\nՄեկ գործողության ընթացքում դուք կարող եք ընտրել երկու ինդեքս x և y (0 <= x, y < n) և հանել 1 arr[x]-ից և ավելացնել 1 arr[y]-ին (այսինքն՝ arr[x] -= 1 և arr[y] += 1):\nՆպատակն է, որպեսզի arr-ի բոլոր տարրերը հավասար լինեն: Թեստային դեպքերը կապահովեն, որ որոշ գործողություններ կատարելուց հետո arr-ի բոլոր տարրերը կարող են հավասար լինել:\n\nՕրինակ 1:\nՄուտքագրում: n = 3\nԵլք: 2\nԲացատրություն: arr = [1, 3, 5]\nԱռաջին գործողություն: x = 2, y = 0 -> arr = [2, 3, 4]\nԵրկրորդ գործողություն: x = 2, y = 0 -> arr = [3, 3, 3]\n\nՕրինակ 2:\nՄուտքագրում: n = 6\nԵլք: 9",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, arr অ্যারেতে সমস্ত উপাদান সমান করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন ফেরত দিন। অ্যারে arr এর দৈর্ঘ্য n, এবং arr[i] = (2 * i) + 1 যেখানে 0 <= i < n। একটি অপারেশনে, আপনি দুটি সূচক x এবং y (0 <= x, y < n) নির্বাচন করতে পারেন এবং arr[x] থেকে 1 বিয়োগ এবং arr[y] তে 1 যোগ করতে পারেন (অর্থাৎ, arr[x] -= 1 এবং arr[y] += 1)। লক্ষ্য হল arr এর সমস্ত উপাদান সমান করা। পরীক্ষার ক্ষেত্রে নিশ্চিত করা হবে যে কিছু অপারেশন করার পরে, arr এর সমস্ত উপাদান সমান করা যেতে পারে।\n\nউদাহরণ 1:\nইনপুট: n = 3\nআউটপুট: 2\nব্যাখ্যা: arr = [1, 3, 5]\nপ্রথম অপারেশন: x = 2, y = 0 -> arr = [2, 3, 4]\nদ্বিতীয় অপারেশন: x = 2, y = 0 -> arr = [3, 3, 3]\n\nউদাহরণ 2:\nইনপুট: n = 6\nআউটপুট: 9",
      "bg": "Дадено е цяло число n, върнете минималния брой операции, необходими, за да направите всички елементи в масива arr равни.\nМасивът arr има дължина n, и arr[i] = (2 * i) + 1 за 0 <= i < n.\nВ една операция можете да изберете два индекса x и y (0 <= x, y < n) и да извадите 1 от arr[x] и да добавите 1 към arr[y] (т.е. arr[x] -= 1 и arr[y] += 1).\nЦелта е да направите всички елементи в arr равни. Тестовите случаи ще гарантират, че след извършване на някои операции, всички елементи в arr могат да бъдат направени равни.\n\nПример 1:\nВход: n = 3\nИзход: 2\nОбяснение: arr = [1, 3, 5]\nПърва операция: x = 2, y = 0 -> arr = [2, 3, 4]\nВтора операция: x = 2, y = 0 -> arr = [3, 3, 3]\n\nПример 2:\nВход: n = 6\nИзход: 9",
      "zh": "给定一个整数 n，返回使数组 arr 中所有元素相等所需的最小操作次数。  \n数组 arr 的长度为 n，并且 arr[i] = (2 * i) + 1，其中 0 <= i < n。  \n在一次操作中，你可以选择两个索引 x 和 y (0 <= x, y < n)，然后从 arr[x] 中减去 1 并加到 arr[y] 上（即，arr[x] -= 1 和 arr[y] += 1）。  \n目标是使 arr 中的所有元素相等。测试用例将确保在执行一些操作后，arr 中的所有元素可以变得相等。\n\n示例 1:  \n输入: n = 3  \n输出: 2  \n解释: arr = [1, 3, 5]  \n第一次操作: x = 2, y = 0 -> arr = [2, 3, 4]  \n第二次操作: x = 2, y = 0 -> arr = [3, 3, 3]  \n\n示例 2:  \n输入: n = 6  \n输出: 9",
      "fr": "Étant donné un entier n, retournez le nombre minimum d'opérations nécessaires pour rendre tous les éléments du tableau arr égaux.\nLe tableau arr a une longueur de n, et arr[i] = (2 * i) + 1 pour 0 <= i < n.\nDans une opération, vous pouvez sélectionner deux indices x et y (0 <= x, y < n) et soustraire 1 de arr[x] et ajouter 1 à arr[y] (c'est-à-dire, arr[x] -= 1 et arr[y] += 1).\nL'objectif est de rendre tous les éléments de arr égaux. Les cas de test garantiront qu'après avoir effectué certaines opérations, tous les éléments de arr peuvent être rendus égaux.\n\nExemple 1 :\nEntrée : n = 3\nSortie : 2\nExplication : arr = [1, 3, 5]\nPremière opération : x = 2, y = 0 -> arr = [2, 3, 4]\nDeuxième opération : x = 2, y = 0 -> arr = [3, 3, 3]\n\nExemple 2 :\nEntrée : n = 6\nSortie : 9",
      "de": "Gegeben eine ganze Zahl n, gib die minimale Anzahl von Operationen zurück, die erforderlich sind, um alle Elemente im Array arr gleich zu machen.\nDas Array arr hat eine Länge von n, und arr[i] = (2 * i) + 1 für 0 <= i < n.\nIn einer Operation kannst du zwei Indizes x und y (0 <= x, y < n) auswählen und 1 von arr[x] subtrahieren und 1 zu arr[y] addieren (d.h., arr[x] -= 1 und arr[y] += 1).\nDas Ziel ist es, alle Elemente in arr gleich zu machen. Die Testfälle werden sicherstellen, dass nach Durchführung einiger Operationen alle Elemente in arr gleich gemacht werden können.\n\nBeispiel 1:\nEingabe: n = 3\nAusgabe: 2\nErklärung: arr = [1, 3, 5]\nErste Operation: x = 2, y = 0 -> arr = [2, 3, 4]\nZweite Operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nBeispiel 2:\nEingabe: n = 6\nAusgabe: 9",
      "ha": "An ba da wani lamba n, mayar da mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk abubuwan da ke cikin jerin arr su zama daidai.\nJerin arr yana da tsawon n, kuma arr[i] = (2 * i) + 1 don 0 <= i < n.\nA cikin aiki guda, za ka iya zaɓar alamomi biyu x da y (0 <= x, y < n) kuma ka cire 1 daga arr[x] ka ƙara 1 zuwa arr[y] (watau, arr[x] -= 1 da arr[y] += 1).\nManufar ita ce a sanya duk abubuwan da ke cikin arr su zama daidai. Gwaje-gwajen za su tabbatar da cewa bayan yin wasu ayyuka, duk abubuwan da ke cikin arr za a iya sanya su daidai.\n\nExample 1:  \nMisali na 1:\n\nInput: n = 3  \nShigarwa: n = 3\n\nOutput: 2  \nFitarwa: 2\n\nExplanation: arr = [1, 3, 5]  \nBayani: arr = [1, 3, 5]\n\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]  \nAiki na farko: x = 2, y = 0 -> arr = [2, 3, 4]\n\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]  \nAiki na biyu: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:  \nMisali na 2:\n\nInput: n = 6  \nShigarwa: n = 6\n\nOutput: 9  \nFitarwa: 9",
      "hi": "दी गई एक पूर्णांक n के लिए, arr में सभी तत्वों को समान बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या लौटाएं।\nसरणी arr की लंबाई n है, और arr[i] = (2 * i) + 1 है जहाँ 0 <= i < n।\nएक ऑपरेशन में, आप दो इंडेक्स x और y (0 <= x, y < n) का चयन कर सकते हैं और arr[x] से 1 घटा सकते हैं और arr[y] में 1 जोड़ सकते हैं (अर्थात, arr[x] -= 1 और arr[y] += 1)।\nलक्ष्य यह है कि arr में सभी तत्वों को समान बनाया जाए। परीक्षण मामले यह सुनिश्चित करेंगे कि कुछ ऑपरेशनों को करने के बाद, arr में सभी तत्व समान बनाए जा सकते हैं।\n\nउदाहरण 1:\nइनपुट: n = 3\nआउटपुट: 2\nव्याख्या: arr = [1, 3, 5]\nपहला ऑपरेशन: x = 2, y = 0 -> arr = [2, 3, 4]\nदूसरा ऑपरेशन: x = 2, y = 0 -> arr = [3, 3, 3]\n\nउदाहरण 2:\nइनपुट: n = 6\nआउटपुट: 9",
      "hu": "Adott egy egész szám n, térj vissza a minimális műveletek számával, amely szükséges ahhoz, hogy az arr tömb összes elemét egyenlővé tegyük.\nAz arr tömb hossza n, és arr[i] = (2 * i) + 1, ahol 0 <= i < n.\nEgy művelet során kiválaszthatsz két indexet x és y (0 <= x, y < n), és kivonhatsz 1-et arr[x]-ből, valamint hozzáadhatsz 1-et arr[y]-hoz (azaz arr[x] -= 1 és arr[y] += 1).\nA cél az, hogy az arr összes eleme egyenlő legyen. A tesztesetek biztosítják, hogy néhány művelet elvégzése után az arr összes eleme egyenlővé tehető.\n\nPélda 1:\nBemenet: n = 3\nKimenet: 2\nMagyarázat: arr = [1, 3, 5]\nElső művelet: x = 2, y = 0 -> arr = [2, 3, 4]\nMásodik művelet: x = 2, y = 0 -> arr = [3, 3, 3]\n\nPélda 2:\nBemenet: n = 6\nKimenet: 9"
    },
    "docstring_bertscore": {
      "sq": "0.9913714962478445",
      "hy": "0.9942293901701744",
      "bn": "0.9809527368714215",
      "bg": "0.9923624632188275",
      "zh": "0.9826802252952819",
      "fr": "0.9963638722447753",
      "de": "0.9990855057257154",
      "ha": "1",
      "hi": "0.9858873114274712",
      "hu": "0.9828091364125735"
    }
  },
  {
    "task_id": "Java/26",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg të plotë `gain` që përfaqëson fitimin neto në lartësi midis pikave të njëpasnjëshme, kthe lartësinë më të lartë të arritur.\n     *\n     * Shembull:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Shpjegim: Lartësitë janë [0,-5,-4,1,1,-6]. Lartësia më e lartë e arritur është 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Shpjegim: Lartësitë janë [0,-4,-7,-9,-10,-6,-3,-1]. Lartësia më e lartë e arritur është 0.\n     *\n     * Kufizimet:\n     * - Gjatësia e vargut `gain` është midis 1 dhe 100, përfshirë.\n     * - Çdo element në vargun `gain` është midis -100 dhe 100, përfshirë.\n     */\n    public int highestAltitude(int[] gain) ",
      "hy": "class Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված `gain`, որը ներկայացնում է բարձրության զուտ աճը հաջորդական կետերի միջև, վերադարձնել հասած ամենաբարձր բարձրությունը:\n     *\n     * Օրինակ:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Բացատրություն: Բարձրությունները [0,-5,-4,1,1,-6] են։ Հասած ամենաբարձր բարձրությունը 1 է։\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Բացատրություն: Բարձրությունները [0,-4,-7,-9,-10,-6,-3,-1] են։ Հասած ամենաբարձր բարձրությունը 0 է։\n     *\n     * Պահանջներ:\n     * - `gain` զանգվածի երկարությունը 1-ից 100 է, ներառյալ:\n     * - `gain` զանգվածի յուրաքանչյուր տարր -100-ից 100 է, ներառյալ:\n     */\n    public int highestAltitude(int[] gain) ",
      "bn": "class Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে `gain` দেওয়া হয়েছে যা পরপর বিন্দুগুলির মধ্যে উচ্চতার নিট লাভ উপস্থাপন করে, সর্বোচ্চ উচ্চতা ফেরত দিন যা অর্জিত হয়েছে।\n     *\n     * উদাহরণ:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * ব্যাখ্যা: উচ্চতাগুলি হল [0,-5,-4,1,1,-6]। সর্বোচ্চ উচ্চতা অর্জিত হয়েছে 1।\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * ব্যাখ্যা: উচ্চতাগুলি হল [0,-4,-7,-9,-10,-6,-3,-1]। সর্বোচ্চ উচ্চতা অর্জিত হয়েছে 0।\n     *\n     * শর্তাবলী:\n     * - `gain` অ্যারের দৈর্ঘ্য 1 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n     * - `gain` অ্যারের প্রতিটি উপাদান -100 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n     */\n    public int highestAltitude(int[] gain) ",
      "bg": "class Solution {\n    /**\n     * Даден е масив от цели числа `gain`, представляващ нетната печалба в надморска височина между последователни точки, върнете най-високата достигната надморска височина.\n     *\n     * Пример:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Обяснение: Надморските височини са [0,-5,-4,1,1,-6]. Най-високата достигната надморска височина е 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Обяснение: Надморските височини са [0,-4,-7,-9,-10,-6,-3,-1]. Най-високата достигната надморска височина е 0.\n     *\n     * Ограничения:\n     * - Дължината на масива `gain` е между 1 и 100, включително.\n     * - Всеки елемент в масива `gain` е между -100 и 100, включително.\n     */\n    public int highestAltitude(int[] gain) ",
      "zh": "class Solution {\n    /**\n     * 给定一个整数数组 `gain`，表示连续点之间的海拔净增益，返回达到的最高海拔。\n     *\n     * 示例:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * 解释: 海拔为 [0,-5,-4,1,1,-6]。达到的最高海拔是 1。\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * 解释: 海拔为 [0,-4,-7,-9,-10,-6,-3,-1]。达到的最高海拔是 0。\n     *\n     * 约束条件:\n     * - `gain` 数组的长度在 1 到 100 之间（包括 1 和 100）。\n     * - `gain` 数组中的每个元素在 -100 到 100 之间（包括 -100 和 100）。\n     */\n    public int highestAltitude(int[] gain) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un tableau d'entiers `gain` représentant le gain net d'altitude entre des points consécutifs, renvoie l'altitude la plus élevée atteinte.\n     *\n     * Exemple:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explication: Les altitudes sont [0,-5,-4,1,1,-6]. L'altitude la plus élevée atteinte est 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explication: Les altitudes sont [0,-4,-7,-9,-10,-6,-3,-1]. L'altitude la plus élevée atteinte est 0.\n     *\n     * Contraintes:\n     * - La longueur du tableau `gain` est comprise entre 1 et 100, inclus.\n     * - Chaque élément du tableau `gain` est compris entre -100 et 100, inclus.\n     */\n    public int highestAltitude(int[] gain) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein Integer-Array `gain`, das den Nettogewinn in der Höhe zwischen aufeinanderfolgenden Punkten darstellt, gib die höchste erreichte Höhe zurück.\n     *\n     * Beispiel:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Erklärung: Die Höhen sind [0,-5,-4,1,1,-6]. Die höchste erreichte Höhe ist 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Erklärung: Die Höhen sind [0,-4,-7,-9,-10,-6,-3,-1]. Die höchste erreichte Höhe ist 0.\n     *\n     * Einschränkungen:\n     * - Die Länge des `gain`-Arrays liegt zwischen 1 und 100, einschließlich.\n     * - Jedes Element im `gain`-Array liegt zwischen -100 und 100, einschließlich.\n     */\n    public int highestAltitude(int[] gain) ",
      "ha": "class Solution {\n    /**\n     * An ba da wani tsari na lambobi `gain` wanda ke wakiltar karin tsawo tsakanin wurare masu jere, dawo da mafi girman tsawo da aka kai.\n     *\n     * Misali:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Bayani: Tsawon wuraren suna [0,-5,-4,1,1,-6]. Mafi girman tsawo da aka kai shine 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Bayani: Tsawon wuraren suna [0,-4,-7,-9,-10,-6,-3,-1]. Mafi girman tsawo da aka kai shine 0.\n     *\n     * Takurawa:\n     * - Tsawon jerin `gain` yana tsakanin 1 da 100, ciki har da.\n     * - Kowanne abu a cikin jerin `gain` yana tsakanin -100 da 100, ciki har da.\n     */\n    public int highestAltitude(int[] gain) ",
      "hi": "class Solution {\n    /**\n     * दिए गए पूर्णांक सरणी `gain` जो लगातार बिंदुओं के बीच ऊंचाई में शुद्ध लाभ का प्रतिनिधित्व करती है, सबसे अधिक ऊंचाई लौटाएं।\n     *\n     * उदाहरण:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * व्याख्या: ऊंचाइयाँ [0,-5,-4,1,1,-6] हैं। सबसे अधिक ऊंचाई 1 है।\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * व्याख्या: ऊंचाइयाँ [0,-4,-7,-9,-10,-6,-3,-1] हैं। सबसे अधिक ऊंचाई 0 है।\n     *\n     * बाधाएँ:\n     * - `gain` सरणी की लंबाई 1 और 100 के बीच है, समावेशी।\n     * - `gain` सरणी का प्रत्येक तत्व -100 और 100 के बीच है, समावेशी।\n     */\n    public int highestAltitude(int[] gain) ",
      "hu": "class Solution {\n    /**\n     * Adott egy `gain` egész szám tömb, amely a nettó magasságnövekedést jelenti az egymást követő pontok között, adja vissza az elért legmagasabb magasságot.\n     *\n     * Példa:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Magyarázat: A magasságok [0,-5,-4,1,1,-6]. Az elért legmagasabb magasság 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Magyarázat: A magasságok [0,-4,-7,-9,-10,-6,-3,-1]. Az elért legmagasabb magasság 0.\n     *\n     * Korlátozások:\n     * - A `gain` tömb hossza 1 és 100 között van, beleértve.\n     * - A `gain` tömb minden eleme -100 és 100 között van, beleértve.\n     */\n    public int highestAltitude(int[] gain) "
    },
    "prompt_bertscore": {
      "sq": "0.9927223814692627",
      "hy": "0.979168241528204",
      "bn": "0.9720411848262912",
      "bg": "0.9905618788147462",
      "zh": "0.9851946872888026",
      "fr": "0.990372385431239",
      "de": "0.9965009272076895",
      "ha": "0.9740997900953368",
      "hi": "0.9857113249098742",
      "hu": "0.9873194364747327"
    },
    "canonical_solution": "    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }",
    "instruction": {
      "en": "Write a Java function `public int highestAltitude(int[] gain)` to solve the following problem:\nGiven an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.",
      "sq": "Shkruani një funksion Java `public int highestAltitude(int[] gain)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg të numrave të plotë `gain` që përfaqëson fitimin neto në lartësi midis pikave të njëpasnjëshme, ktheni lartësinë më të lartë të arritur.\n\nShembull:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nShpjegim: Lartësitë janë [0,-5,-4,1,1,-6]. Lartësia më e lartë e arritur është 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nShpjegim: Lartësitë janë [0,-4,-7,-9,-10,-6,-3,-1]. Lartësia më e lartë e arritur është 0.\n\nKufizimet:\n- Gjatësia e vargut `gain` është midis 1 dhe 100, përfshirë.\n- Çdo element në vargun `gain` është midis -100 dhe 100, përfshirë.",
      "hy": "Գրեք Java ֆունկցիա `public int highestAltitude(int[] gain)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի զանգված `gain`, որը ներկայացնում է բարձրության զուտ աճը հաջորդական կետերի միջև, վերադարձնել հասած ամենաբարձր բարձրությունը:\n\nՕրինակ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nԲացատրություն: Բարձրությունները [0,-5,-4,1,1,-6] են: Հասած ամենաբարձր բարձրությունը 1 է:\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nԲացատրություն: Բարձրությունները [0,-4,-7,-9,-10,-6,-3,-1] են: Հասած ամենաբարձր բարձրությունը 0 է:\n\nՊահանջներ:\n- `gain` զանգվածի երկարությունը 1-ից 100 է, ներառյալ:\n- `gain` զանգվածի յուրաքանչյուր տարր -100-ից 100 է, ներառյալ:",
      "bn": "একটি জাভা ফাংশন `public int highestAltitude(int[] gain)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক একটি পূর্ণসংখ্যার অ্যারে `gain` দেওয়া হয়েছে যা পরপর বিন্দুগুলির মধ্যে উচ্চতার নিট বৃদ্ধি উপস্থাপন করে, সর্বোচ্চ উচ্চতা যা পৌঁছানো হয়েছে তা ফেরত দিন।\n\nউদাহরণ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nব্যাখ্যা: উচ্চতাগুলি হল [0,-5,-4,1,1,-6]। সর্বোচ্চ উচ্চতা যা পৌঁছানো হয়েছে তা হল 1।\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nব্যাখ্যা: উচ্চতাগুলি হল [0,-4,-7,-9,-10,-6,-3,-1]। সর্বোচ্চ উচ্চতা যা পৌঁছানো হয়েছে তা হল 0।\n\nসীমাবদ্ধতা:\n- `gain` অ্যারের দৈর্ঘ্য 1 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n- `gain` অ্যারের প্রতিটি উপাদান -100 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।",
      "bg": "Напишете функция на Java `public int highestAltitude(int[] gain)`, за да решите следния проблем:  \nДаден е цялочислен масив `gain`, представляващ нетната печалба в надморска височина между последователни точки, върнете най-високата достигната надморска височина.\n\nПример:  \n>>> highestAltitude([-5,1,5,0,-7])  \n1  \nОбяснение: Надморските височини са [0,-5,-4,1,1,-6]. Най-високата достигната надморска височина е 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])  \n0  \nОбяснение: Надморските височини са [0,-4,-7,-9,-10,-6,-3,-1]. Най-високата достигната надморска височина е 0.\n\nОграничения:  \n- Дължината на масива `gain` е между 1 и 100, включително.\n- Всеки елемент в масива `gain` е между -100 и 100, включително.",
      "zh": "编写一个 Java 函数 `public int highestAltitude(int[] gain)` 来解决以下问题：  \n给定一个整数数组 `gain`，表示连续点之间的净海拔增益，返回达到的最高海拔。\n\n示例：  \n>>> highestAltitude([-5,1,5,0,-7])  \n1  \n解释：海拔为 [0,-5,-4,1,1,-6]。达到的最高海拔是 1。\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])  \n0  \n解释：海拔为 [0,-4,-7,-9,-10,-6,-3,-1]。达到的最高海拔是 0。\n\n约束条件：\n- `gain` 数组的长度在 1 到 100 之间（包括 1 和 100）。\n- `gain` 数组中的每个元素在 -100 到 100 之间（包括 -100 和 100）。",
      "fr": "Écrire une fonction Java `public int highestAltitude(int[] gain)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers `gain` représentant le gain net d'altitude entre des points consécutifs, retourner l'altitude la plus élevée atteinte.\n\nExemple :  \n>>> highestAltitude([-5,1,5,0,-7])  \n1  \nExplication : Les altitudes sont [0,-5,-4,1,1,-6]. L'altitude la plus élevée atteinte est 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])  \n0  \nExplication : Les altitudes sont [0,-4,-7,-9,-10,-6,-3,-1]. L'altitude la plus élevée atteinte est 0.\n\nContraintes :  \n- La longueur du tableau `gain` est comprise entre 1 et 100, inclus.\n- Chaque élément du tableau `gain` est compris entre -100 et 100, inclus.",
      "de": "Schreiben Sie eine Java-Funktion `public int highestAltitude(int[] gain)`, um das folgende Problem zu lösen:\nGegeben ist ein ganzzahliges Array `gain`, das den Nettogewinn an Höhe zwischen aufeinanderfolgenden Punkten darstellt. Geben Sie die höchste erreichte Höhe zurück.\n\nBeispiel:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nErläuterung: Die Höhen sind [0,-5,-4,1,1,-6]. Die höchste erreichte Höhe ist 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nErläuterung: Die Höhen sind [0,-4,-7,-9,-10,-6,-3,-1]. Die höchste erreichte Höhe ist 0.\n\nEinschränkungen:\n- Die Länge des `gain`-Arrays liegt zwischen 1 und 100, einschließlich.\n- Jedes Element im `gain`-Array liegt zwischen -100 und 100, einschließlich.",
      "ha": "Rubuta aikin Java `public int highestAltitude(int[] gain)` don warware matsalar mai zuwa:  \nAn ba da jerin lambobi `gain` wanda ke wakiltar karin tsawo tsakanin maki masu jere, dawo da mafi girman tsawo da aka kai.\n\nMisali:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nBayani: Tsawon tsawo sun kasance [0,-5,-4,1,1,-6]. Mafi girman tsawo da aka kai shi ne 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nBayani: Tsawon tsawo sun kasance [0,-4,-7,-9,-10,-6,-3,-1]. Mafi girman tsawo da aka kai shi ne 0.\n\nTakaitawa:\n- Tsawon jerin `gain` yana tsakanin 1 da 100, har da.\n- Kowanne abu a cikin jerin `gain` yana tsakanin -100 da 100, har da.",
      "hi": "Java फ़ंक्शन `public int highestAltitude(int[] gain)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक array `gain` जो लगातार बिंदुओं के बीच ऊंचाई में शुद्ध लाभ को दर्शाता है, सबसे ऊंची ऊंचाई लौटाएं जो प्राप्त की गई है।\n\nउदाहरण:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nव्याख्या: ऊंचाइयाँ [0,-5,-4,1,1,-6] हैं। सबसे ऊंची ऊंचाई जो प्राप्त की गई है वह 1 है।\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nव्याख्या: ऊंचाइयाँ [0,-4,-7,-9,-10,-6,-3,-1] हैं। सबसे ऊंची ऊंचाई जो प्राप्त की गई है वह 0 है।\n\nबाधाएं:\n- `gain` array की लंबाई 1 और 100 के बीच है, समावेशी।\n- `gain` array में प्रत्येक तत्व -100 और 100 के बीच है, समावेशी।",
      "hu": "Írj egy Java függvényt `public int highestAltitude(int[] gain)` a következő probléma megoldására:  \nAdott egy egész számokat tartalmazó `gain` tömb, amely a nettó magasságnövekedést jelenti az egymást követő pontok között, add vissza a legmagasabb elért magasságot.\n\nPélda:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nMagyarázat: A magasságok [0,-5,-4,1,1,-6]. A legmagasabb elért magasság 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nMagyarázat: A magasságok [0,-4,-7,-9,-10,-6,-3,-1]. A legmagasabb elért magasság 0.\n\nKorlátozások:\n- A `gain` tömb hossza 1 és 100 között van, beleértve.\n- A `gain` tömb minden eleme -100 és 100 között van, beleértve."
    },
    "instruction_bertscore": {
      "sq": "0.9880605264263739",
      "hy": "0.9857349619252175",
      "bn": "0.9730319531668933",
      "bg": "0.9961640500814543",
      "zh": "0.9800495645288558",
      "fr": "0.9901497207740989",
      "de": "1",
      "ha": "0.9572982420547387",
      "hi": "0.9840954667601555",
      "hu": "0.983124760088038"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "highestAltitude",
    "signature": "public int highestAltitude(int[] gain)",
    "docstring": {
      "en": "Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.",
      "sq": "Duke pasur një varg të plotë `gain` që përfaqëson fitimin neto në lartësi midis pikave të njëpasnjëshme, kthe lartësinë më të lartë të arritur.\n\nShembull:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nShpjegim: Lartësitë janë [0,-5,-4,1,1,-6]. Lartësia më e lartë e arritur është 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nShpjegim: Lartësitë janë [0,-4,-7,-9,-10,-6,-3,-1]. Lartësia më e lartë e arritur është 0.\n\nKufizimet:\n- Gjatësia e vargut `gain` është midis 1 dhe 100, përfshirë.\n- Çdo element në vargun `gain` është midis -100 dhe 100, përfshirë.",
      "hy": "Տրված է ամբողջ թվերի զանգված `gain`, որը ներկայացնում է բարձրության զուտ աճը հաջորդական կետերի միջև, վերադարձնել ամենաբարձր հասած բարձրությունը:\n\nՕրինակ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nԲացատրություն: Բարձրությունները են [0,-5,-4,1,1,-6]: Ամենաբարձր հասած բարձրությունը 1 է:\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nԲացատրություն: Բարձրությունները են [0,-4,-7,-9,-10,-6,-3,-1]: Ամենաբարձր հասած բարձրությունը 0 է:\n\nՊահանջներ:\n- `gain` զանգվածի երկարությունը 1-ից 100-ի միջև է, ներառյալ:\n- `gain` զանգվածի յուրաքանչյուր տարր -100-ից 100-ի միջև է, ներառյալ:",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে `gain` দেওয়া হয়েছে যা পরপর বিন্দুগুলির মধ্যে উচ্চতার নিট বৃদ্ধি উপস্থাপন করে, সর্বোচ্চ উচ্চতা ফেরত দিন যা অর্জিত হয়েছে।\n\nউদাহরণ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nব্যাখ্যা: উচ্চতাগুলি হল [0,-5,-4,1,1,-6]। সর্বোচ্চ উচ্চতা যা অর্জিত হয়েছে তা হল 1।\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nব্যাখ্যা: উচ্চতাগুলি হল [0,-4,-7,-9,-10,-6,-3,-1]। সর্বোচ্চ উচ্চতা যা অর্জিত হয়েছে তা হল 0।\n\nসীমাবদ্ধতা:\n- `gain` অ্যারের দৈর্ঘ্য 1 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n- `gain` অ্যারের প্রতিটি উপাদান -100 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।",
      "bg": "Даден е масив от цели числа `gain`, представляващ нетната печалба в надморска височина между последователни точки, върнете най-високата достигната надморска височина.\n\nПример:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nОбяснение: Надморските височини са [0,-5,-4,1,1,-6]. Най-високата достигната надморска височина е 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nОбяснение: Надморските височини са [0,-4,-7,-9,-10,-6,-3,-1]. Най-високата достигната надморска височина е 0.\n\nОграничения:\n- Дължината на масива `gain` е между 1 и 100, включително.\n- Всеки елемент в масива `gain` е между -100 и 100, включително.",
      "zh": "给定一个整数数组 `gain`，表示连续点之间的海拔净增益，返回达到的最高海拔。\n\n示例：\n>>> highestAltitude([-5,1,5,0,-7])\n1\n解释：海拔为 [0,-5,-4,1,1,-6]。达到的最高海拔是 1。\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\n解释：海拔为 [0,-4,-7,-9,-10,-6,-3,-1]。达到的最高海拔是 0。\n\n约束条件：\n- `gain` 数组的长度在 1 到 100 之间（包括 1 和 100）。\n- `gain` 数组中的每个元素在 -100 到 100 之间（包括 -100 和 100）。",
      "fr": "Étant donné un tableau d'entiers `gain` représentant le gain net en altitude entre des points consécutifs, renvoyez l'altitude la plus élevée atteinte.\n\nExemple :\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplication : Les altitudes sont [0,-5,-4,1,1,-6]. L'altitude la plus élevée atteinte est 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplication : Les altitudes sont [0,-4,-7,-9,-10,-6,-3,-1]. L'altitude la plus élevée atteinte est 0.\n\nContraintes :\n- La longueur du tableau `gain` est comprise entre 1 et 100, inclus.\n- Chaque élément du tableau `gain` est compris entre -100 et 100, inclus.",
      "de": "Gegeben ein Integer-Array `gain`, das den Nettogewinn in der Höhe zwischen aufeinanderfolgenden Punkten darstellt, gib die höchste erreichte Höhe zurück.\n\nBeispiel:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nErläuterung: Die Höhen sind [0,-5,-4,1,1,-6]. Die höchste erreichte Höhe ist 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nErläuterung: Die Höhen sind [0,-4,-7,-9,-10,-6,-3,-1]. Die höchste erreichte Höhe ist 0.\n\nEinschränkungen:\n- Die Länge des `gain`-Arrays liegt zwischen 1 und 100, einschließlich.\n- Jedes Element im `gain`-Array liegt zwischen -100 und 100, einschließlich.",
      "ha": "An ba da jerin lambobi `gain` wanda ke wakiltar karin tsawo tsakanin maki masu jere, dawo da mafi girman tsawo da aka kai.\n\nMisali:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nBayani: Matsayin tsayin daka sun kasance [0,-5,-4,1,1,-6]. Mafi girman tsayin daka da aka kai shine 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nBayani: Matsayin tsayin daka sun kasance [0,-4,-7,-9,-10,-6,-3,-1]. Mafi girman tsayin daka da aka kai shine 0.\n\nTakaitaccen bayani:\n- Tsawon jerin `gain` yana tsakanin 1 da 100, har da.\n- Kowanne abu a cikin jerin `gain` yana tsakanin -100 da 100, har da.",
      "hi": "दिए गए पूर्णांक array `gain` जो लगातार बिंदुओं के बीच ऊँचाई में शुद्ध लाभ को दर्शाता है, के आधार पर सबसे अधिक ऊँचाई लौटाएँ।\n\nउदाहरण:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nव्याख्या: ऊँचाइयाँ [0,-5,-4,1,1,-6] हैं। सबसे अधिक ऊँचाई जो प्राप्त की गई है वह 1 है।\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nव्याख्या: ऊँचाइयाँ [0,-4,-7,-9,-10,-6,-3,-1] हैं। सबसे अधिक ऊँचाई जो प्राप्त की गई है वह 0 है।\n\nबाधाएँ:\n- `gain` array की लंबाई 1 और 100 के बीच है, दोनों सम्मिलित।\n- `gain` array का प्रत्येक तत्व -100 और 100 के बीच है, दोनों सम्मिलित।",
      "hu": "Adott egy egész számokból álló tömb `gain`, amely a nettó magasságnövekedést jelenti az egymást követő pontok között, adja vissza az elért legmagasabb magasságot.\n\nPélda:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nMagyarázat: A magasságok [0,-5,-4,1,1,-6]. Az elért legmagasabb magasság 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nMagyarázat: A magasságok [0,-4,-7,-9,-10,-6,-3,-1]. Az elért legmagasabb magasság 0.\n\nKorlátozások:\n- A `gain` tömb hossza 1 és 100 között van, beleértve.\n- A `gain` tömb minden eleme -100 és 100 között van, beleértve."
    },
    "docstring_bertscore": {
      "sq": "0.9888131369401151",
      "hy": "0.9816602582886678",
      "bn": "0.9667687399921011",
      "bg": "0.9866295931613985",
      "zh": "0.9733549261664559",
      "fr": "0.9873553885737001",
      "de": "1",
      "ha": "0.9726787883494132",
      "hi": "0.9900015425098468",
      "hu": "0.9743556260261097"
    }
  },
  {
    "task_id": "Java/27",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg të plotë nums, kthe maksimumin e shumës absolute të çdo nënvargu.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "hy": "class Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված nums, վերադարձնել ցանկացած ենթազանգվածի առավելագույն բացարձակ գումարը։\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "bn": "class Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে nums দেওয়া হলে, যেকোনো উপঅ্যারের সর্বাধিক পরম যোগফল ফেরত দিন।\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "bg": "class Solution {\n    /**\n     * Даден е масив от цели числа nums, върнете максималната абсолютна сума на който и да е подмасив.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "zh": "class Solution {\n    /**\n     * 给定一个整数数组 nums，返回任何子数组的最大绝对和。\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un tableau d'entiers nums, renvoie la somme absolue maximale de n'importe quel sous-tableau.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein Integer-Array nums, gib die maximale absolute Summe eines beliebigen Teilarrays zurück.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "ha": "class Solution {\n    /**\n     * An ba da wani jerin lambobi na integers nums, dawo da mafi girman jimillar cikakken adadi na kowane subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "hi": "class Solution {\n    /**\n     * दिए गए पूर्णांक array nums के लिए, किसी भी उपarray का अधिकतम परिमाणात्मक योग लौटाएं।\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "hu": "class Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb, nums, adja vissza bármely részhalmaz maximális abszolút összegét.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9900144534846141",
      "bn": "1",
      "bg": "0.9900144534846141",
      "zh": "1",
      "fr": "0.9900144534846141",
      "de": "1",
      "ha": "0.9900144534846141",
      "hi": "0.9892753498367833",
      "hu": "0.97837093917873"
    },
    "canonical_solution": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }",
    "instruction": {
      "en": "Write a Java function `public int maxAbsoluteSum(int[] nums)` to solve the following problem:\nGiven an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "sq": "Shkruani një funksion Java `public int maxAbsoluteSum(int[] nums)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg të plotë nums, ktheni shumën absolute maksimale të çdo nënvargu.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hy": "Գրեք Java ֆունկցիա `public int maxAbsoluteSum(int[] nums)` լուծելու հետևյալ խնդիրը:\nՏրված է ամբողջ թվերի զանգված nums, վերադարձնել ցանկացած ենթազանգվածի առավելագույն բացարձակ գումարը.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "bn": "একটি জাভা ফাংশন `public int maxAbsoluteSum(int[] nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে nums দেওয়া হয়েছে, যেকোনো সাবঅ্যারের সর্বাধিক পরম যোগফল ফেরত দিন।\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "bg": "Напишете Java функция `public int maxAbsoluteSum(int[] nums)`, за да решите следния проблем:\nДаден е масив от цели числа nums, върнете максималната абсолютна сума на който и да е подмасив.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "zh": "编写一个 Java 函数 `public int maxAbsoluteSum(int[] nums)` 来解决以下问题：\n给定一个整数数组 nums，返回任何子数组的最大绝对和。\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "fr": "Écrire une fonction Java `public int maxAbsoluteSum(int[] nums)` pour résoudre le problème suivant:\nÉtant donné un tableau d'entiers nums, retourner la somme absolue maximale de n'importe quel sous-tableau.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "de": "Schreiben Sie eine Java-Funktion `public int maxAbsoluteSum(int[] nums)`, um das folgende Problem zu lösen:  \nGegeben ein Integer-Array nums, geben Sie die maximale absolute Summe eines beliebigen Teilarrays zurück.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "ha": "Rubuta aikin Java `public int maxAbsoluteSum(int[] nums)` don warware matsalar mai zuwa:\nAn ba da jerin lambobi na cikakken lamba nums, dawo da mafi girman jimillar kowane ƙaramin jeri.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hi": "Java फ़ंक्शन `public int maxAbsoluteSum(int[] nums)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक ऐरे nums के लिए, किसी भी उप-ऐरे का अधिकतम परिमाण योग लौटाएं।\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hu": "Írj egy Java függvényt `public int maxAbsoluteSum(int[] nums)` a következő probléma megoldására:\nAdott egy egész számokat tartalmazó tömb, nums, térj vissza bármely részhalmaz maximális abszolút összegével.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8"
    },
    "instruction_bertscore": {
      "sq": "0.8364826101365323",
      "hy": "0.8373424345228309",
      "bn": "0.8364826101365323",
      "bg": "0.8373424345228309",
      "zh": "0.8364826101365323",
      "fr": "0.8373424345228309",
      "de": "0.8364826101365323",
      "ha": "0.8364826101365323",
      "hi": "0.8346444380572341",
      "hu": "0.8300254905266744"
    },
    "level": "easy",
    "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "maxAbsoluteSum",
    "signature": "public int maxAbsoluteSum(int[] nums)",
    "docstring": {
      "en": "Given an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "sq": "Duke pasur një varg të plotë nums, kthe maksimumin e shumës absolute të çdo nënvargu.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hy": "Տրված է ամբողջ թվերի զանգված `nums`, վերադարձնել ցանկացած ենթազանգվածի առավելագույն բացարձակ գումարը։\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "bn": "প্রদত্ত একটি পূর্ণসংখ্যার অ্যারে nums, যেকোনো উপঅ্যারের সর্বাধিক পরম যোগফল ফেরত দিন।\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "bg": "Даден е масив от цели числа nums, върнете максималната абсолютна сума на произволен подмасив.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "zh": "给定一个整数数组 `nums`，返回任何子数组的最大绝对和。\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "fr": "Étant donné un tableau d'entiers nums, renvoyez la somme absolue maximale de n'importe quel sous-tableau.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "de": "Gegeben ein Integer-Array nums, gib die maximale absolute Summe eines beliebigen Teilarrays zurück.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "ha": "An ba da jerin lambobi na integers nums, mayar da mafi girman jimlar da ba ta da alamar kowace subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hi": "दिए गए पूर्णांक array nums के लिए, किसी भी उपarray का अधिकतम परिमाणात्मक योग लौटाएं।\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hu": "Adott egy egész számokat tartalmazó tömb, nums, térj vissza bármely részhalmaz maximális abszolút összegével.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8"
    },
    "docstring_bertscore": {
      "sq": "0.9714446977920435",
      "hy": "0.9560355487225",
      "bn": "0.999999801369619",
      "bg": "0.9859518663013075",
      "zh": "0.971846527052877",
      "fr": "0.9859518663013075",
      "de": "0.999999801369619",
      "ha": "0.9796312489463963",
      "hi": "0.9840827544157692",
      "hu": "0.9685200640616858"
    }
  },
  {
    "task_id": "Java/28",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një numër të plotë k, kthe numrin minimal të numrave Fibonacci, shuma e të cilëve është e barabartë me k.\n     * Numrat Fibonacci janë të përcaktuar si më poshtë:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, për n > 2.\n     * Është e garantuar që ka të paktën një zgjidhje të vlefshme për k e dhënë.\n     *\n     * Shembull 1:\n     * Input: k = 7\n     * Output: 2\n     * Shpjegim: Numrat Fibonacci janë: 1, 1, 2, 3, 5, 8, 13, ...\n     * Për k = 7, mund të marrim 2 + 5 = 7.\n     *\n     * Shembull 2:\n     * Input: k = 10\n     * Output: 2\n     * Shpjegim: Për k = 10, mund të marrim 2 + 8 = 10.\n     *\n     * Shembull 3:\n     * Input: k = 19\n     * Output: 3\n     * Shpjegim: Për k = 19, mund të marrim 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է ամբողջ թիվ k, վերադարձնել Ֆիբոնաչիի թվերի նվազագույն քանակը, որոնց գումարը հավասար է k-ի:\n     * Ֆիբոնաչիի թվերը սահմանվում են հետևյալ կերպ.\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, n > 2-ի համար:\n     * Երաշխավորված է, որ տրված k-ի համար առնվազն մեկ վավեր լուծում կա:\n     *\n     * Օրինակ 1:\n     * Մուտքագրում: k = 7\n     * Ելք: 2\n     * Բացատրություն: Ֆիբոնաչիի թվերն են՝ 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7-ի համար, մենք կարող ենք ստանալ 2 + 5 = 7:\n     *\n     * Օրինակ 2:\n     * Մուտքագրում: k = 10\n     * Ելք: 2\n     * Բացատրություն: k = 10-ի համար, մենք կարող ենք ստանալ 2 + 8 = 10:\n     *\n     * Օրինակ 3:\n     * Մուտքագրում: k = 19\n     * Ելք: 3\n     * Բացատրություն: k = 19-ի համար, մենք կարող ենք ստանալ 1 + 5 + 13 = 19:\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি পূর্ণসংখ্যা k দেওয়া হলে, সেই k এর সমান যোগফল যেসব ফিবোনাচ্চি সংখ্যার, তাদের মধ্যে সর্বনিম্ন সংখ্যা ফেরত দিন।\n     * ফিবোনাচ্চি সংখ্যা নিম্নরূপে সংজ্ঞায়িত করা হয়:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, n > 2 এর জন্য।\n     * প্রদত্ত k এর জন্য অন্তত একটি বৈধ সমাধান আছে তা নিশ্চিত করা হয়েছে।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: k = 7\n     * আউটপুট: 2\n     * ব্যাখ্যা: ফিবোনাচ্চি সংখ্যা হল: 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7 এর জন্য, আমরা পেতে পারি 2 + 5 = 7।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: k = 10\n     * আউটপুট: 2\n     * ব্যাখ্যা: k = 10 এর জন্য, আমরা পেতে পারি 2 + 8 = 10।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: k = 19\n     * আউটপুট: 3\n     * ব্যাখ্যা: k = 19 এর জন্য, আমরা পেতে পারি 1 + 5 + 13 = 19।\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Дадено е цяло число k, върнете минималния брой числа на Фибоначи, чиято сума е равна на k.\n     * Числата на Фибоначи са дефинирани по следния начин:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, за n > 2.\n     * Гарантирано е, че съществува поне едно валидно решение за даденото k.\n     *\n     * Пример 1:\n     * Вход: k = 7\n     * Изход: 2\n     * Обяснение: Числата на Фибоначи са: 1, 1, 2, 3, 5, 8, 13, ...\n     * За k = 7, можем да получим 2 + 5 = 7.\n     *\n     * Пример 2:\n     * Вход: k = 10\n     * Изход: 2\n     * Обяснение: За k = 10, можем да получим 2 + 8 = 10.\n     *\n     * Пример 3:\n     * Вход: k = 19\n     * Изход: 3\n     * Обяснение: За k = 19, можем да получим 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个整数 k，返回其和等于 k 的最小斐波那契数字数量。\n     * 斐波那契数定义如下：\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, 对于 n > 2。\n     * 可以保证对于给定的 k，至少有一个有效的解决方案。\n     *\n     * 示例 1:\n     * 输入: k = 7\n     * 输出: 2\n     * 解释: 斐波那契数为: 1, 1, 2, 3, 5, 8, 13, ...\n     * 对于 k = 7，我们可以得到 2 + 5 = 7。\n     *\n     * 示例 2:\n     * 输入: k = 10\n     * 输出: 2\n     * 解释: 对于 k = 10，我们可以得到 2 + 8 = 10。\n     *\n     * 示例 3:\n     * 输入: k = 19\n     * 输出: 3\n     * 解释: 对于 k = 19，我们可以得到 1 + 5 + 13 = 19。\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un entier k, renvoie le nombre minimum de nombres de Fibonacci dont la somme est égale à k.\n     * Les nombres de Fibonacci sont définis comme suit :\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, pour n > 2.\n     * Il est garanti qu'il existe au moins une solution valide pour le k donné.\n     *\n     * Exemple 1 :\n     * Entrée : k = 7\n     * Sortie : 2\n     * Explication : Les nombres de Fibonacci sont : 1, 1, 2, 3, 5, 8, 13, ...\n     * Pour k = 7, nous pouvons obtenir 2 + 5 = 7.\n     *\n     * Exemple 2 :\n     * Entrée : k = 10\n     * Sortie : 2\n     * Explication : Pour k = 10, nous pouvons obtenir 2 + 8 = 10.\n     *\n     * Exemple 3 :\n     * Entrée : k = 19\n     * Sortie : 3\n     * Explication : Pour k = 19, nous pouvons obtenir 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben eine ganze Zahl k, gib die minimale Anzahl von Fibonacci-Zahlen zurück, deren Summe gleich k ist.\n     * Fibonacci-Zahlen sind wie folgt definiert:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, für n > 2.\n     * Es ist garantiert, dass es mindestens eine gültige Lösung für das gegebene k gibt.\n     *\n     * Beispiel 1:\n     * Eingabe: k = 7\n     * Ausgabe: 2\n     * Erklärung: Fibonacci-Zahlen sind: 1, 1, 2, 3, 5, 8, 13, ...\n     * Für k = 7 können wir 2 + 5 = 7 erhalten.\n     *\n     * Beispiel 2:\n     * Eingabe: k = 10\n     * Ausgabe: 2\n     * Erklärung: Für k = 10 können wir 2 + 8 = 10 erhalten.\n     *\n     * Beispiel 3:\n     * Eingabe: k = 19\n     * Ausgabe: 3\n     * Erklärung: Für k = 19 können wir 1 + 5 + 13 = 19 erhalten.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani cikakken lamba k, dawo da mafi ƙarancin adadin lambobin Fibonacci waɗanda jimlarsu ta yi daidai da k.\n     * Ana ayyana lambobin Fibonacci kamar haka:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, don n > 2.\n     * An tabbatar da cewa akwai aƙalla mafita guda ɗaya mai inganci don k da aka bayar.\n     *\n     * Misali 1:\n     * Shigarwa: k = 7\n     * Fitarwa: 2\n     * Bayani: Lambobin Fibonacci sune: 1, 1, 2, 3, 5, 8, 13, ...\n     * Don k = 7, za mu iya samun 2 + 5 = 7.\n     *\n     * Misali 2:\n     * Shigarwa: k = 10\n     * Fitarwa: 2\n     * Bayani: Don k = 10, za mu iya samun 2 + 8 = 10.\n     *\n     * Misali 3:\n     * Shigarwa: k = 19\n     * Fitarwa: 3\n     * Bayani: Don k = 19, za mu iya samun 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए एक पूर्णांक k के लिए, न्यूनतम संख्या में फिबोनाची संख्याएँ लौटाएँ जिनका योग k के बराबर है।\n     * फिबोनाची संख्याएँ निम्नलिखित रूप से परिभाषित की जाती हैं:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, n > 2 के लिए।\n     * यह गारंटी दी जाती है कि दिए गए k के लिए कम से कम एक मान्य समाधान है।\n     *\n     * उदाहरण 1:\n     * इनपुट: k = 7\n     * आउटपुट: 2\n     * व्याख्या: फिबोनाची संख्याएँ हैं: 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7 के लिए, हम 2 + 5 = 7 प्राप्त कर सकते हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: k = 10\n     * आउटपुट: 2\n     * व्याख्या: k = 10 के लिए, हम 2 + 8 = 10 प्राप्त कर सकते हैं।\n     *\n     * उदाहरण 3:\n     * इनपुट: k = 19\n     * आउटपुट: 3\n     * व्याख्या: k = 19 के लिए, हम 1 + 5 + 13 = 19 प्राप्त कर सकते हैं।\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy egész szám k, adja vissza a minimális számú Fibonacci számot, amelyek összege egyenlő k-val.\n     * A Fibonacci számok a következőképpen vannak definiálva:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, ha n > 2.\n     * Garantált, hogy legalább egy érvényes megoldás létezik a megadott k-ra.\n     *\n     * 1. példa:\n     * Bemenet: k = 7\n     * Kimenet: 2\n     * Magyarázat: A Fibonacci számok: 1, 1, 2, 3, 5, 8, 13, ...\n     * K esetén 7, kaphatjuk 2 + 5 = 7.\n     *\n     * 2. példa:\n     * Bemenet: k = 10\n     * Kimenet: 2\n     * Magyarázat: K esetén 10, kaphatjuk 2 + 8 = 10.\n     *\n     * 3. példa:\n     * Bemenet: k = 19\n     * Kimenet: 3\n     * Magyarázat: K esetén 19, kaphatjuk 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9930374092535841",
      "hy": "0.9874362311387812",
      "bn": "0.9971009895887958",
      "bg": "0.9905598925109359",
      "zh": "0.9900559672342504",
      "fr": "0.9905598925109359",
      "de": "1",
      "ha": "0.9930374092535841",
      "hi": "0.9919306407704577",
      "hu": "0.9907871256668398"
    },
    "canonical_solution": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }",
    "instruction": {
      "en": "Write a Java function `public int findMinFibonacciNumbers(int k)` to solve the following problem:\nGiven an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.",
      "sq": "Shkruani një funksion Java `public int findMinFibonacciNumbers(int k)` për të zgjidhur problemin në vijim:\nDuke pasur një numër të plotë k, ktheni numrin minimal të numrave të Fibonaccit, shuma e të cilëve është e barabartë me k.\nNumrat e Fibonaccit janë të përcaktuar si më poshtë:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, për n > 2.\nËshtë e garantuar që ekziston të paktën një zgjidhje e vlefshme për k e dhënë.\n\nShembulli 1:\nInput: k = 7\nOutput: 2\nShpjegim: Numrat e Fibonaccit janë: 1, 1, 2, 3, 5, 8, 13, ...\nPër k = 7, mund të marrim 2 + 5 = 7.\n\nShembulli 2:\nInput: k = 10\nOutput: 2\nShpjegim: Për k = 10, mund të marrim 2 + 8 = 10.\n\nShembulli 3:\nInput: k = 19\nOutput: 3\nShpjegim: Për k = 19, mund të marrim 1 + 5 + 13 = 19.",
      "hy": "Գրեք Java ֆունկցիա `public int findMinFibonacciNumbers(int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ k, վերադարձնել Ֆիբոնաչիի թվերի նվազագույն քանակը, որոնց գումարը հավասար է k-ին:\nՖիբոնաչիի թվերը սահմանվում են հետևյալ կերպ.\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, n > 2-ի համար:\nԵրաշխավորված է, որ տրված k-ի համար առնվազն մեկ վավեր լուծում կա:\n\nՕրինակ 1:\nՄուտքագրում: k = 7\nԵլք: 2\nԲացատրություն: Ֆիբոնաչիի թվերն են՝ 1, 1, 2, 3, 5, 8, 13, ...\nk = 7-ի համար կարող ենք ստանալ 2 + 5 = 7:\n\nՕրինակ 2:\nՄուտքագրում: k = 10\nԵլք: 2\nԲացատրություն: k = 10-ի համար կարող ենք ստանալ 2 + 8 = 10:\n\nՕրինակ 3:\nՄուտքագրում: k = 19\nԵլք: 3\nԲացատրություն: k = 19-ի համար կարող ենք ստանալ 1 + 5 + 13 = 19:",
      "bn": "একটি জাভা ফাংশন `public int findMinFibonacciNumbers(int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা k দেওয়া হলে, সেই k এর সমান যোগফল পাওয়ার জন্য ন্যূনতম কতগুলি ফিবোনাচ্চি সংখ্যা প্রয়োজন তা ফেরত দিন।\nফিবোনাচ্চি সংখ্যা নিম্নরূপ সংজ্ঞায়িত করা হয়:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, n > 2 এর জন্য।\nপ্রদত্ত k এর জন্য অন্তত একটি বৈধ সমাধান থাকা নিশ্চিত।\n\nউদাহরণ 1:\nইনপুট: k = 7\nআউটপুট: 2\nব্যাখ্যা: ফিবোনাচ্চি সংখ্যা হল: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 এর জন্য, আমরা 2 + 5 = 7 পেতে পারি।\n\nউদাহরণ 2:\nইনপুট: k = 10\nআউটপুট: 2\nব্যাখ্যা: k = 10 এর জন্য, আমরা 2 + 8 = 10 পেতে পারি।\n\nউদাহরণ 3:\nইনপুট: k = 19\nআউটপুট: 3\nব্যাখ্যা: k = 19 এর জন্য, আমরা 1 + 5 + 13 = 19 পেতে পারি।",
      "bg": "Напишете Java функция `public int findMinFibonacciNumbers(int k)`, за да решите следния проблем:  \nДадено е цяло число k, върнете минималния брой числа на Фибоначи, чиято сума е равна на k.  \nЧислата на Фибоначи са дефинирани по следния начин:  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2, за n > 2.  \nГарантирано е, че съществува поне едно валидно решение за даденото k.\n\nПример 1:  \nВход: k = 7  \nИзход: 2  \nОбяснение: Числата на Фибоначи са: 1, 1, 2, 3, 5, 8, 13, ...  \nЗа k = 7, можем да получим 2 + 5 = 7.\n\nПример 2:  \nВход: k = 10  \nИзход: 2  \nОбяснение: За k = 10, можем да получим 2 + 8 = 10.\n\nПример 3:  \nВход: k = 19  \nИзход: 3  \nОбяснение: За k = 19, можем да получим 1 + 5 + 13 = 19.",
      "zh": "编写一个 Java 函数 `public int findMinFibonacciNumbers(int k)` 来解决以下问题：  \n给定一个整数 k，返回其总和等于 k 的最少斐波那契数字数量。  \n斐波那契数定义如下：  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2，对于 n > 2。  \n保证对于给定的 k 至少有一个有效解决方案。  \n\n示例 1：  \n输入：k = 7  \n输出：2  \n解释：斐波那契数为：1, 1, 2, 3, 5, 8, 13, ...  \n对于 k = 7，我们可以得到 2 + 5 = 7。  \n\n示例 2：  \n输入：k = 10  \n输出：2  \n解释：对于 k = 10，我们可以得到 2 + 8 = 10。  \n\n示例 3：  \n输入：k = 19  \n输出：3  \n解释：对于 k = 19，我们可以得到 1 + 5 + 13 = 19。",
      "fr": "Écrire une fonction Java `public int findMinFibonacciNumbers(int k)` pour résoudre le problème suivant :  \nÉtant donné un entier k, retourner le nombre minimum de nombres de Fibonacci dont la somme est égale à k.  \nLes nombres de Fibonacci sont définis comme suit :  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2, pour n > 2.  \nIl est garanti qu'il existe au moins une solution valide pour le k donné.  \n\nExemple 1 :  \nEntrée : k = 7  \nSortie : 2  \nExplication : Les nombres de Fibonacci sont : 1, 1, 2, 3, 5, 8, 13, ...  \nPour k = 7, nous pouvons obtenir 2 + 5 = 7.  \n\nExemple 2 :  \nEntrée : k = 10  \nSortie : 2  \nExplication : Pour k = 10, nous pouvons obtenir 2 + 8 = 10.  \n\nExemple 3 :  \nEntrée : k = 19  \nSortie : 3  \nExplication : Pour k = 19, nous pouvons obtenir 1 + 5 + 13 = 19.",
      "de": "Schreiben Sie eine Java-Funktion `public int findMinFibonacciNumbers(int k)`, um das folgende Problem zu lösen:\nGegeben ist eine ganze Zahl k, geben Sie die minimale Anzahl von Fibonacci-Zahlen zurück, deren Summe gleich k ist.\nFibonacci-Zahlen sind wie folgt definiert:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, für n > 2.\nEs ist garantiert, dass es mindestens eine gültige Lösung für das gegebene k gibt.\n\nBeispiel 1:\nEingabe: k = 7\nAusgabe: 2\nErläuterung: Fibonacci-Zahlen sind: 1, 1, 2, 3, 5, 8, 13, ...\nFür k = 7 können wir 2 + 5 = 7 erhalten.\n\nBeispiel 2:\nEingabe: k = 10\nAusgabe: 2\nErläuterung: Für k = 10 können wir 2 + 8 = 10 erhalten.\n\nBeispiel 3:\nEingabe: k = 19\nAusgabe: 3\nErläuterung: Für k = 19 können wir 1 + 5 + 13 = 19 erhalten.",
      "ha": "Rubuta aikin Java `public int findMinFibonacciNumbers(int k)` don warware matsalar mai zuwa:\nAn ba da wani lamba k, dawo da mafi ƙarancin adadin lambobin Fibonacci waɗanda jimlarsu ta yi daidai da k.\nLambobin Fibonacci an ayyana su kamar haka:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, don n > 2.\nAna tabbatar da cewa akwai aƙalla mafita guda ɗaya mai inganci don k da aka bayar.\n\nMisali 1:\nShigarwa: k = 7\nFitarwa: 2\nBayani: Lambobin Fibonacci sune: 1, 1, 2, 3, 5, 8, 13, ...\nDon k = 7, za mu iya samun 2 + 5 = 7.\n\nMisali 2:\nShigarwa: k = 10\nFitarwa: 2\nBayani: Don k = 10, za mu iya samun 2 + 8 = 10.\n\nMisali 3:\nShigarwa: k = 19\nFitarwa: 3\nBayani: Don k = 19, za mu iya samun 1 + 5 + 13 = 19.",
      "hi": "Java फ़ंक्शन `public int findMinFibonacciNumbers(int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक k के लिए, उन न्यूनतम फ़िबोनाची संख्याओं की संख्या लौटाएं जिनका योग k के बराबर है।\nफ़िबोनाची संख्याएँ निम्नलिखित रूप से परिभाषित की जाती हैं:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, जहाँ n > 2 है।\nयह सुनिश्चित है कि दिए गए k के लिए कम से कम एक मान्य समाधान है।\n\nउदाहरण 1:\nइनपुट: k = 7\nआउटपुट: 2\nव्याख्या: फ़िबोनाची संख्याएँ हैं: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 के लिए, हम 2 + 5 = 7 प्राप्त कर सकते हैं।\n\nउदाहरण 2:\nइनपुट: k = 10\nआउटपुट: 2\nव्याख्या: k = 10 के लिए, हम 2 + 8 = 10 प्राप्त कर सकते हैं।\n\nउदाहरण 3:\nइनपुट: k = 19\nआउटपुट: 3\nव्याख्या: k = 19 के लिए, हम 1 + 5 + 13 = 19 प्राप्त कर सकते हैं।",
      "hu": "Írj egy Java függvényt `public int findMinFibonacciNumbers(int k)` a következő probléma megoldására:\nAdott egy egész szám k, térj vissza a minimális számú Fibonacci számmal, amelyek összege egyenlő k-val.\nA Fibonacci számok a következőképpen vannak definiálva:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, ha n > 2.\nGarantált, hogy legalább egy érvényes megoldás létezik a megadott k-ra.\n\n1. példa:\nBemenet: k = 7\nKimenet: 2\nMagyarázat: A Fibonacci számok: 1, 1, 2, 3, 5, 8, 13, ...\nHa k = 7, akkor 2 + 5 = 7-et kaphatunk.\n\n2. példa:\nBemenet: k = 10\nKimenet: 2\nMagyarázat: Ha k = 10, akkor 2 + 8 = 10-et kaphatunk.\n\n3. példa:\nBemenet: k = 19\nKimenet: 3\nMagyarázat: Ha k = 19, akkor 1 + 5 + 13 = 19-et kaphatunk."
    },
    "instruction_bertscore": {
      "sq": "0.9925273264350865",
      "hy": "0.9908790915332589",
      "bn": "0.9919288530970284",
      "bg": "0.9889893220880931",
      "zh": "0.990099070026935",
      "fr": "0.9900233918517607",
      "de": "0.9974916955482914",
      "ha": "0.9864424833424638",
      "hi": "0.9851265570681076",
      "hu": "0.978883604192181"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "findMinFibonacciNumbers",
    "signature": "public int findMinFibonacciNumbers(int k)",
    "docstring": {
      "en": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.",
      "sq": "Duke pasur një numër të plotë k, kthe numrin minimal të numrave të Fibonaccit, shuma e të cilëve është e barabartë me k. Numrat e Fibonaccit përcaktohen si më poshtë: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, për n > 2. Garantohet që ekziston të paktën një zgjidhje e vlefshme për k e dhënë.\n\nShembull 1: Input: k = 7 Output: 2 Shpjegim: Numrat e Fibonaccit janë: 1, 1, 2, 3, 5, 8, 13, ... Për k = 7, mund të marrim 2 + 5 = 7.\n\nShembull 2: Input: k = 10 Output: 2 Shpjegim: Për k = 10, mund të marrim 2 + 8 = 10.\n\nShembull 3: Input: k = 19 Output: 3 Shpjegim: Për k = 19, mund të marrim 1 + 5 + 13 = 19.",
      "hy": "Տրված է ամբողջ թիվ k, վերադարձնել Ֆիբոնաչիի թվերի նվազագույն քանակը, որոնց գումարը հավասար է k-ին։ Ֆիբոնաչիի թվերը սահմանվում են հետևյալ կերպ՝\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, n > 2-ի համար։\nԵրաշխավորված է, որ տրված k-ի համար առնվազն մեկ վավեր լուծում կա։\n\nՕրինակ 1:\nՄուտք: k = 7\nԵլք: 2\nԲացատրություն: Ֆիբոնաչիի թվերն են՝ 1, 1, 2, 3, 5, 8, 13, ...\nk = 7-ի համար, մենք կարող ենք ստանալ 2 + 5 = 7։\n\nՕրինակ 2:\nՄուտք: k = 10\nԵլք: 2\nԲացատրություն: k = 10-ի համար, մենք կարող ենք ստանալ 2 + 8 = 10։\n\nՕրինակ 3:\nՄուտք: k = 19\nԵլք: 3\nԲացատրություն: k = 19-ի համար, մենք կարող ենք ստանալ 1 + 5 + 13 = 19։",
      "bn": "একটি পূর্ণসংখ্যা k দেওয়া হলে, সেই k এর সমান যোগফল যেসব ফিবোনাচ্চি সংখ্যার মাধ্যমে পাওয়া যায়, সেগুলোর মধ্যে সর্বনিম্ন সংখ্যক ফিবোনাচ্চি সংখ্যা ফেরত দিন। ফিবোনাচ্চি সংখ্যা নিম্নরূপে সংজ্ঞায়িত করা হয়:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, যেখানে n > 2।\nপ্রদত্ত k এর জন্য অন্তত একটি বৈধ সমাধান থাকা নিশ্চিত।\n\nউদাহরণ 1:\nইনপুট: k = 7\nআউটপুট: 2\nব্যাখ্যা: ফিবোনাচ্চি সংখ্যা হল: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 এর জন্য, আমরা 2 + 5 = 7 পেতে পারি।\n\nউদাহরণ 2:\nইনপুট: k = 10\nআউটপুট: 2\nব্যাখ্যা: k = 10 এর জন্য, আমরা 2 + 8 = 10 পেতে পারি।\n\nউদাহরণ 3:\nইনপুট: k = 19\nআউটপুট: 3\nব্যাখ্যা: k = 19 এর জন্য, আমরা 1 + 5 + 13 = 19 পেতে পারি।",
      "bg": "Дадено е цяло число k, върнете минималния брой числа на Фибоначи, чиято сума е равна на k. Числата на Фибоначи са дефинирани както следва: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, за n > 2. Гарантирано е, че има поне едно валидно решение за даденото k.\n\nПример 1: Вход: k = 7 Изход: 2 Обяснение: Числата на Фибоначи са: 1, 1, 2, 3, 5, 8, 13, ... За k = 7, можем да получим 2 + 5 = 7.\n\nПример 2: Вход: k = 10 Изход: 2 Обяснение: За k = 10, можем да получим 2 + 8 = 10.\n\nПример 3: Вход: k = 19 Изход: 3 Обяснение: За k = 19, можем да получим 1 + 5 + 13 = 19.",
      "zh": "给定一个整数 k，返回其和等于 k 的最少斐波那契数字的数量。  \n斐波那契数定义如下：  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2，对于 n > 2。  \n保证对于给定的 k 至少存在一个有效解。\n\n示例 1:  \n输入: k = 7  \n输出: 2  \n解释: 斐波那契数为: 1, 1, 2, 3, 5, 8, 13, ...  \n对于 k = 7，我们可以得到 2 + 5 = 7。\n\n示例 2:  \n输入: k = 10  \n输出: 2  \n解释: 对于 k = 10，我们可以得到 2 + 8 = 10。\n\n示例 3:  \n输入: k = 19  \n输出: 3  \n解释: 对于 k = 19，我们可以得到 1 + 5 + 13 = 19。",
      "fr": "Étant donné un entier k, renvoyer le nombre minimum de nombres de Fibonacci dont la somme est égale à k.\nLes nombres de Fibonacci sont définis comme suit :\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, pour n > 2.\nIl est garanti qu'il existe au moins une solution valide pour le k donné.\n\nExemple 1 :\nEntrée : k = 7\nSortie : 2\nExplication : Les nombres de Fibonacci sont : 1, 1, 2, 3, 5, 8, 13, ...\nPour k = 7, nous pouvons obtenir 2 + 5 = 7.\n\nExemple 2 :\nEntrée : k = 10\nSortie : 2\nExplication : Pour k = 10, nous pouvons obtenir 2 + 8 = 10.\n\nExemple 3 :\nEntrée : k = 19\nSortie : 3\nExplication : Pour k = 19, nous pouvons obtenir 1 + 5 + 13 = 19.",
      "de": "Gegeben eine ganze Zahl k, geben Sie die minimale Anzahl von Fibonacci-Zahlen zurück, deren Summe gleich k ist. Fibonacci-Zahlen sind wie folgt definiert: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, für n > 2. Es ist garantiert, dass es mindestens eine gültige Lösung für das gegebene k gibt.\n\nBeispiel 1: Eingabe: k = 7 Ausgabe: 2 Erklärung: Fibonacci-Zahlen sind: 1, 1, 2, 3, 5, 8, 13, ... Für k = 7 können wir 2 + 5 = 7 erhalten.\n\nBeispiel 2: Eingabe: k = 10 Ausgabe: 2 Erklärung: Für k = 10 können wir 2 + 8 = 10 erhalten.\n\nBeispiel 3: Eingabe: k = 19 Ausgabe: 3 Erklärung: Für k = 19 können wir 1 + 5 + 13 = 19 erhalten.",
      "ha": "An ba da wani cikakken lamba k, dawo da mafi ƙarancin adadin lambobin Fibonacci waɗanda jimlarsu ta yi daidai da k. Ana ayyana lambobin Fibonacci kamar haka:  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2, don n > 2.  \nAna tabbatar da cewa akwai aƙalla mafita guda ɗaya mai inganci don k da aka bayar.  \n\nMisali na 1:  \nShigarwa: k = 7  \nFitarwa: 2  \nBayani: Lambobin Fibonacci sune: 1, 1, 2, 3, 5, 8, 13, ...  \nDon k = 7, zamu iya samun 2 + 5 = 7.  \n\nMisali na 2:  \nShigarwa: k = 10  \nFitarwa: 2  \nBayani: Don k = 10, zamu iya samun 2 + 8 = 10.  \n\nMisali na 3:  \nShigarwa: k = 19  \nFitarwa: 3  \nBayani: Don k = 19, zamu iya samun 1 + 5 + 13 = 19.",
      "hi": "दी गई संख्या k के लिए, उन न्यूनतम फिबोनाची संख्याओं की संख्या लौटाएं जिनका योग k के बराबर है। फिबोनाची संख्याएं निम्नलिखित रूप में परिभाषित की जाती हैं:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, जहाँ n > 2.\nयह सुनिश्चित है कि दिए गए k के लिए कम से कम एक वैध समाधान है।\n\nउदाहरण 1:\nइनपुट: k = 7\nआउटपुट: 2\nव्याख्या: फिबोनाची संख्याएं हैं: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 के लिए, हम 2 + 5 = 7 प्राप्त कर सकते हैं।\n\nउदाहरण 2:\nइनपुट: k = 10\nआउटपुट: 2\nव्याख्या: k = 10 के लिए, हम 2 + 8 = 10 प्राप्त कर सकते हैं।\n\nउदाहरण 3:\nइनपुट: k = 19\nआउटपुट: 3\nव्याख्या: k = 19 के लिए, हम 1 + 5 + 13 = 19 प्राप्त कर सकते हैं।",
      "hu": "Adott egy egész szám k, térj vissza a legkisebb számú Fibonacci-számmal, amelyek összege egyenlő k-val. A Fibonacci-számok a következőképpen vannak definiálva: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, ahol n > 2. Garantált, hogy legalább egy érvényes megoldás létezik a megadott k-ra.\n\nPélda 1: Bemenet: k = 7 Kimenet: 2 Magyarázat: A Fibonacci-számok: 1, 1, 2, 3, 5, 8, 13, ... K esetén k = 7, kaphatjuk a 2 + 5 = 7 összeget.\n\nPélda 2: Bemenet: k = 10 Kimenet: 2 Magyarázat: K esetén k = 10, kaphatjuk a 2 + 8 = 10 összeget.\n\nPélda 3: Bemenet: k = 19 Kimenet: 3 Magyarázat: K esetén k = 19, kaphatjuk az 1 + 5 + 13 = 19 összeget."
    },
    "docstring_bertscore": {
      "sq": "0.9812520728556411",
      "hy": "0.9970312703250526",
      "bn": "0.9921233122400616",
      "bg": "0.9875665326687402",
      "zh": "0.9935991359711507",
      "fr": "0.9875665326687402",
      "de": "0.9972132157540805",
      "ha": "0.9875665326687402",
      "hi": "0.985960208777311",
      "hu": "0.9736087757934185"
    }
  },
  {
    "task_id": "Java/29",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     */\n    public int kthFactor(int n, int k) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni faktorin e k-të të n.\n     * Një faktor i n është një numër i plotë pozitiv që e ndan n në mënyrë të barabartë.\n     * Ktheni faktorin e k-të në rend rritës. Nëse n ka më pak se k faktorë, ktheni -1.\n     *\n     * Shembull 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Shpjegim: Faktorët e 12 janë [1, 2, 3, 4, 6, 12]. Faktori i 3-të është 3.\n     *\n     * Shembull 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Shpjegim: Faktorët e 7 janë [1, 7]. Faktori i 2-të është 7.\n     *\n     * Shembull 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Shpjegim: Faktorët e 4 janë [1, 2, 4]. Nuk ka faktor të 4-të, kështu që kthejmë -1.\n     */\n    public int kthFactor(int n, int k) ",
      "hy": "class Solution {\n    /**\n     * Տրված են n և k դրական ամբողջ թվերը, գտնել n-ի k-րդ գործոնը:\n     * n-ի գործոնը դրական ամբողջ թիվ է, որը n-ին բաժանում է առանց մնացորդի:\n     * Վերադարձնել k-րդ գործոնը աճման կարգով: Եթե n-ն ունի k-ից պակաս գործոններ, վերադարձնել -1:\n     *\n     * Օրինակ 1:\n     * Մուտքագրում: n = 12, k = 3\n     * Ելք: 3\n     * Բացատրություն: 12-ի գործոններն են [1, 2, 3, 4, 6, 12]: 3-րդ գործոնը 3-ն է:\n     *\n     * Օրինակ 2:\n     * Մուտքագրում: n = 7, k = 2\n     * Ելք: 7\n     * Բացատրություն: 7-ի գործոններն են [1, 7]: 2-րդ գործոնը 7-ն է:\n     *\n     * Օրինակ 3:\n     * Մուտքագրում: n = 4, k = 4\n     * Ելք: -1\n     * Բացատրություն: 4-ի գործոններն են [1, 2, 4]: Չկա 4-րդ գործոն, ուստի վերադարձնում ենք -1:\n     */\n    public int kthFactor(int n, int k) ",
      "bn": "class Solution {\n    /**\n     * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া হলে, n এর k তম গুণনীয়ক খুঁজে বের করুন।\n     * n এর একটি গুণনীয়ক হল একটি ধনাত্মক পূর্ণসংখ্যা যা n কে সমানভাবে ভাগ করে।\n     * ক্রমবর্ধমান ক্রমে k তম গুণনীয়কটি ফেরত দিন। যদি n এর k টির কম গুণনীয়ক থাকে, তাহলে -1 ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: n = 12, k = 3\n     * আউটপুট: 3\n     * ব্যাখ্যা: 12 এর গুণনীয়কগুলি হল [1, 2, 3, 4, 6, 12]। 3য় গুণনীয়কটি হল 3।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: n = 7, k = 2\n     * আউটপুট: 7\n     * ব্যাখ্যা: 7 এর গুণনীয়কগুলি হল [1, 7]। 2য় গুণনীয়কটি হল 7।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: n = 4, k = 4\n     * আউটপুট: -1\n     * ব্যাখ্যা: 4 এর গুণনীয়কগুলি হল [1, 2, 4]। এখানে 4র্থ গুণনীয়ক নেই, তাই আমরা -1 ফেরত দিই।\n     */\n    public int kthFactor(int n, int k) ",
      "bg": "class Solution {\n    /**\n     * Дадени са две положителни цели числа n и k, намерете k-тия делител на n.\n     * Делител на n е положително цяло число, което дели n без остатък.\n     * Върнете k-тия делител в нарастващ ред. Ако n има по-малко от k делители, върнете -1.\n     *\n     * Пример 1:\n     * Вход: n = 12, k = 3\n     * Изход: 3\n     * Обяснение: Делителите на 12 са [1, 2, 3, 4, 6, 12]. Третият делител е 3.\n     *\n     * Пример 2:\n     * Вход: n = 7, k = 2\n     * Изход: 7\n     * Обяснение: Делителите на 7 са [1, 7]. Вторият делител е 7.\n     *\n     * Пример 3:\n     * Вход: n = 4, k = 4\n     * Изход: -1\n     * Обяснение: Делителите на 4 са [1, 2, 4]. Няма четвърти делител, затова връщаме -1.\n     */\n    public int kthFactor(int n, int k) ",
      "zh": "class Solution {\n    /**\n     * 给定两个正整数 n 和 k，找到 n 的第 k 个因子。\n     * n 的因子是可以整除 n 的正整数。\n     * 按升序返回第 k 个因子。如果 n 的因子少于 k 个，则返回 -1。\n     *\n     * 示例 1:\n     * 输入: n = 12, k = 3\n     * 输出: 3\n     * 解释: 12 的因子是 [1, 2, 3, 4, 6, 12]。第 3 个因子是 3。\n     *\n     * 示例 2:\n     * 输入: n = 7, k = 2\n     * 输出: 7\n     * 解释: 7 的因子是 [1, 7]。第 2 个因子是 7。\n     *\n     * 示例 3:\n     * 输入: n = 4, k = 4\n     * 输出: -1\n     * 解释: 4 的因子是 [1, 2, 4]。没有第 4 个因子，所以返回 -1。\n     */\n    public int kthFactor(int n, int k) ",
      "fr": "class Solution {\n    /**\n     * Étant donné deux entiers positifs n et k, trouver le k-ième facteur de n.\n     * Un facteur de n est un entier positif qui divise n sans reste.\n     * Retourner le k-ième facteur dans l'ordre croissant. Si n a moins de k facteurs, retourner -1.\n     *\n     * Exemple 1 :\n     * Entrée : n = 12, k = 3\n     * Sortie : 3\n     * Explication : Les facteurs de 12 sont [1, 2, 3, 4, 6, 12]. Le 3ème facteur est 3.\n     *\n     * Exemple 2 :\n     * Entrée : n = 7, k = 2\n     * Sortie : 7\n     * Explication : Les facteurs de 7 sont [1, 7]. Le 2ème facteur est 7.\n     *\n     * Exemple 3 :\n     * Entrée : n = 4, k = 4\n     * Sortie : -1\n     * Explication : Les facteurs de 4 sont [1, 2, 4]. Il n'y a pas de 4ème facteur, donc nous retournons -1.\n     */\n    public int kthFactor(int n, int k) ",
      "de": "class Solution {\n    /**\n     * Gegeben zwei positive ganze Zahlen n und k, finde den k-ten Faktor von n.\n     * Ein Faktor von n ist eine positive ganze Zahl, die n ohne Rest teilt.\n     * Gib den k-ten Faktor in aufsteigender Reihenfolge zurück. Wenn n weniger als k Faktoren hat, gib -1 zurück.\n     *\n     * Beispiel 1:\n     * Eingabe: n = 12, k = 3\n     * Ausgabe: 3\n     * Erklärung: Die Faktoren von 12 sind [1, 2, 3, 4, 6, 12]. Der 3. Faktor ist 3.\n     *\n     * Beispiel 2:\n     * Eingabe: n = 7, k = 2\n     * Ausgabe: 7\n     * Erklärung: Die Faktoren von 7 sind [1, 7]. Der 2. Faktor ist 7.\n     *\n     * Beispiel 3:\n     * Eingabe: n = 4, k = 4\n     * Ausgabe: -1\n     * Erklärung: Die Faktoren von 4 sind [1, 2, 4]. Es gibt keinen 4. Faktor, daher geben wir -1 zurück.\n     */\n    public int kthFactor(int n, int k) ",
      "ha": "class Solution {\n    /**\n     * An ba da lambobi guda biyu masu kyau n da k, nemo k na dalilin n.\n     * Dalilin n shi ne lamba mai kyau da ke raba n ba tare da saura ba.\n     * Mayar da k na dalilin a tsari mai tashi. Idan n yana da ƙasa da k dalilai, mayar da -1.\n     *\n     * Misali 1:\n     * Shigarwa: n = 12, k = 3\n     * Fitarwa: 3\n     * Bayani: Dalilan 12 sune [1, 2, 3, 4, 6, 12]. Na 3 na dalilin shine 3.\n     *\n     * Misali 2:\n     * Shigarwa: n = 7, k = 2\n     * Fitarwa: 7\n     * Bayani: Dalilan 7 sune [1, 7]. Na 2 na dalilin shine 7.\n     *\n     * Misali 3:\n     * Shigarwa: n = 4, k = 4\n     * Fitarwa: -1\n     * Bayani: Dalilan 4 sune [1, 2, 4]. Babu na 4 na dalilin, don haka muna mayar da -1.\n     */\n    public int kthFactor(int n, int k) ",
      "hi": "class Solution {\n    /**\n     * दिए गए दो धनात्मक पूर्णांक n और k के लिए, n का kth गुणक खोजें।\n     * n का एक गुणक वह धनात्मक पूर्णांक है जो n को पूरी तरह से विभाजित करता है।\n     * आरोही क्रम में kth गुणक लौटाएं। यदि n के k से कम गुणक हैं, तो -1 लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: n = 12, k = 3\n     * आउटपुट: 3\n     * व्याख्या: 12 के गुणक [1, 2, 3, 4, 6, 12] हैं। तीसरा गुणक 3 है।\n     *\n     * उदाहरण 2:\n     * इनपुट: n = 7, k = 2\n     * आउटपुट: 7\n     * व्याख्या: 7 के गुणक [1, 7] हैं। दूसरा गुणक 7 है।\n     *\n     * उदाहरण 3:\n     * इनपुट: n = 4, k = 4\n     * आउटपुट: -1\n     * व्याख्या: 4 के गुणक [1, 2, 4] हैं। कोई चौथा गुणक नहीं है, इसलिए हम -1 लौटाते हैं।\n     */\n    public int kthFactor(int n, int k) ",
      "hu": "class Solution {\n    /**\n     * Két pozitív egész szám, n és k esetén, találja meg n k-adik osztóját.\n     * Egy n osztója olyan pozitív egész szám, amely n-t maradék nélkül osztja.\n     * Adja vissza a k-adik osztót növekvő sorrendben. Ha n-nek kevesebb mint k osztója van, adja vissza -1-et.\n     *\n     * 1. példa:\n     * Bemenet: n = 12, k = 3\n     * Kimenet: 3\n     * Magyarázat: A 12 osztói [1, 2, 3, 4, 6, 12]. A 3. osztó 3.\n     *\n     * 2. példa:\n     * Bemenet: n = 7, k = 2\n     * Kimenet: 7\n     * Magyarázat: A 7 osztói [1, 7]. A 2. osztó 7.\n     *\n     * 3. példa:\n     * Bemenet: n = 4, k = 4\n     * Kimenet: -1\n     * Magyarázat: A 4 osztói [1, 2, 4]. Nincs 4. osztó, ezért -1-et adunk vissza.\n     */\n    public int kthFactor(int n, int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9826959170953836",
      "hy": "0.969779579307828",
      "bn": "0.9864071271346395",
      "bg": "0.9083765723577509",
      "zh": "0.9800726056530559",
      "fr": "0.9753181888526048",
      "de": "0.9726344937744424",
      "ha": "0.9692875718540046",
      "hi": "0.9758443607319662",
      "hu": "0.9077598250246376"
    },
    "canonical_solution": "    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "instruction": {
      "en": "Write a Java function `public int kthFactor(int n, int k)` to solve the following problem:\nGiven two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.",
      "sq": "Shkruani një funksion Java `public int kthFactor(int n, int k)` për të zgjidhur problemin në vijim:\nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni faktorin e k-të të n.\nNjë faktor i n është një numër i plotë pozitiv që e ndan n në mënyrë të barabartë.\nKtheni faktorin e k-të në rend rritës. Nëse n ka më pak se k faktorë, ktheni -1.\n\nShembull 1:\nInput: n = 12, k = 3\nOutput: 3\nShpjegim: Faktorët e 12 janë [1, 2, 3, 4, 6, 12]. Faktori i 3-të është 3.\n\nShembull 2:\nInput: n = 7, k = 2\nOutput: 7\nShpjegim: Faktorët e 7 janë [1, 7]. Faktori i 2-të është 7.\n\nShembull 3:\nInput: n = 4, k = 4\nOutput: -1\nShpjegim: Faktorët e 4 janë [1, 2, 4]. Nuk ka faktor të 4-të, kështu që kthejmë -1.",
      "hy": "Գրեք Java ֆունկցիա `public int kthFactor(int n, int k)` հետևյալ խնդիրը լուծելու համար:\nՏրված են երկու դրական ամբողջ թիվ n և k, գտնել n-ի k-րդ գործակիցը։\nn-ի գործակիցը դրական ամբողջ թիվ է, որը n-ը հավասարապես բաժանում է։\nՎերադարձնել k-րդ գործակիցը աճման կարգով։ Եթե n-ն ունի k-ից պակաս գործակիցներ, վերադարձնել -1։\n\nՕրինակ 1:\nՄուտք: n = 12, k = 3\nԵլք: 3\nԲացատրություն: 12-ի գործակիցներն են [1, 2, 3, 4, 6, 12]։ 3-րդ գործակիցը 3 է։\n\nՕրինակ 2:\nՄուտք: n = 7, k = 2\nԵլք: 7\nԲացատրություն: 7-ի գործակիցներն են [1, 7]։ 2-րդ գործակիցը 7 է։\n\nՕրինակ 3:\nՄուտք: n = 4, k = 4\nԵլք: -1\nԲացատրություն: 4-ի գործակիցներն են [1, 2, 4]։ 4-րդ գործակից չկա, ուստի վերադարձնում ենք -1։",
      "bn": "একটি জাভা ফাংশন `public int kthFactor(int n, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, n এর k তম গুণনীয়ক খুঁজে বের করুন।\nn এর একটি গুণনীয়ক হল একটি ধনাত্মক পূর্ণসংখ্যা যা n কে সমানভাবে ভাগ করে।\nক্রমবর্ধমান ক্রমে k তম গুণনীয়কটি ফেরত দিন। যদি n এর k টির কম গুণনীয়ক থাকে, তাহলে -1 ফেরত দিন।\n\nউদাহরণ 1:\nইনপুট: n = 12, k = 3\nআউটপুট: 3\nব্যাখ্যা: 12 এর গুণনীয়কগুলি হল [1, 2, 3, 4, 6, 12]। 3য় গুণনীয়ক হল 3।\n\nউদাহরণ 2:\nইনপুট: n = 7, k = 2\nআউটপুট: 7\nব্যাখ্যা: 7 এর গুণনীয়কগুলি হল [1, 7]। 2য় গুণনীয়ক হল 7।\n\nউদাহরণ 3:\nইনপুট: n = 4, k = 4\nআউটপুট: -1\nব্যাখ্যা: 4 এর গুণনীয়কগুলি হল [1, 2, 4]। কোন 4র্থ গুণনীয়ক নেই, তাই আমরা -1 ফেরত দিই।",
      "bg": "Напишете Java функция `public int kthFactor(int n, int k)`, за да решите следния проблем:  \nДадени са две положителни цели числа n и k, намерете k-тия делител на n.  \nДелител на n е положително цяло число, което дели n без остатък.  \nВърнете k-тия делител в нарастващ ред. Ако n има по-малко от k делители, върнете -1.\n\nПример 1:  \nВход: n = 12, k = 3  \nИзход: 3  \nОбяснение: Делителите на 12 са [1, 2, 3, 4, 6, 12]. Третият делител е 3.\n\nПример 2:  \nВход: n = 7, k = 2  \nИзход: 7  \nОбяснение: Делителите на 7 са [1, 7]. Вторият делител е 7.\n\nПример 3:  \nВход: n = 4, k = 4  \nИзход: -1  \nОбяснение: Делителите на 4 са [1, 2, 4]. Няма четвърти делител, затова връщаме -1.",
      "zh": "编写一个 Java 函数 `public int kthFactor(int n, int k)` 来解决以下问题：\n给定两个正整数 n 和 k，找到 n 的第 k 个因子。\nn 的因子是能整除 n 的正整数。\n按升序返回第 k 个因子。如果 n 的因子少于 k 个，则返回 -1。\n\n示例 1：\n输入：n = 12, k = 3\n输出：3\n解释：12 的因子是 [1, 2, 3, 4, 6, 12]。第 3 个因子是 3。\n\n示例 2：\n输入：n = 7, k = 2\n输出：7\n解释：7 的因子是 [1, 7]。第 2 个因子是 7。\n\n示例 3：\n输入：n = 4, k = 4\n输出：-1\n解释：4 的因子是 [1, 2, 4]。没有第 4 个因子，所以返回 -1。",
      "fr": "Écrire une fonction Java `public int kthFactor(int n, int k)` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le k-ième facteur de n.  \nUn facteur de n est un entier positif qui divise n sans reste.  \nRetourner le k-ième facteur dans l'ordre croissant. Si n a moins de k facteurs, retourner -1.\n\nExemple 1 :  \nEntrée : n = 12, k = 3  \nSortie : 3  \nExplication : Les facteurs de 12 sont [1, 2, 3, 4, 6, 12]. Le 3ème facteur est 3.\n\nExemple 2 :  \nEntrée : n = 7, k = 2  \nSortie : 7  \nExplication : Les facteurs de 7 sont [1, 7]. Le 2ème facteur est 7.\n\nExemple 3 :  \nEntrée : n = 4, k = 4  \nSortie : -1  \nExplication : Les facteurs de 4 sont [1, 2, 4]. Il n'y a pas de 4ème facteur, donc nous retournons -1.",
      "de": "Schreiben Sie eine Java-Funktion `public int kthFactor(int n, int k)`, um das folgende Problem zu lösen:\nGegeben zwei positive ganze Zahlen n und k, finde den k-ten Faktor von n.\nEin Faktor von n ist eine positive ganze Zahl, die n ohne Rest teilt.\nGeben Sie den k-ten Faktor in aufsteigender Reihenfolge zurück. Wenn n weniger als k Faktoren hat, geben Sie -1 zurück.\n\nBeispiel 1:\nEingabe: n = 12, k = 3\nAusgabe: 3\nErläuterung: Die Faktoren von 12 sind [1, 2, 3, 4, 6, 12]. Der 3. Faktor ist 3.\n\nBeispiel 2:\nEingabe: n = 7, k = 2\nAusgabe: 7\nErläuterung: Die Faktoren von 7 sind [1, 7]. Der 2. Faktor ist 7.\n\nBeispiel 3:\nEingabe: n = 4, k = 4\nAusgabe: -1\nErläuterung: Die Faktoren von 4 sind [1, 2, 4]. Es gibt keinen 4. Faktor, daher geben wir -1 zurück.",
      "ha": "Rubuta aikin Java `public int kthFactor(int n, int k)` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau guda biyu n da k, nemo k na n.\nWani abu na n shine lamba mai kyau wanda ke raba n daidai.\nMayar da k na cikin tsari mai tashi. Idan n yana da ƙasa da abubuwan k, mayar da -1.\n\nMisali 1:\nShigar: n = 12, k = 3\nFitarwa: 3\nBayani: Abubuwan 12 sune [1, 2, 3, 4, 6, 12]. Na 3 na shine 3.\n\nMisali 2:\nShigar: n = 7, k = 2\nFitarwa: 7\nBayani: Abubuwan 7 sune [1, 7]. Na 2 na shine 7.\n\nMisali 3:\nShigar: n = 4, k = 4\nFitarwa: -1\nBayani: Abubuwan 4 sune [1, 2, 4]. Babu na 4, don haka muna mayar da -1.",
      "hi": "Java फ़ंक्शन `public int kthFactor(int n, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए दो धनात्मक पूर्णांक n और k के लिए, n का kवाँ गुणांक खोजें।\nn का एक गुणांक वह धनात्मक पूर्णांक है जो n को पूरी तरह से विभाजित करता है।\nआरोही क्रम में kवाँ गुणांक लौटाएं। यदि n के k से कम गुणांक हैं, तो -1 लौटाएं।\n\nउदाहरण 1:\nइनपुट: n = 12, k = 3\nआउटपुट: 3\nव्याख्या: 12 के गुणांक [1, 2, 3, 4, 6, 12] हैं। तीसरा गुणांक 3 है।\n\nउदाहरण 2:\nइनपुट: n = 7, k = 2\nआउटपुट: 7\nव्याख्या: 7 के गुणांक [1, 7] हैं। दूसरा गुणांक 7 है।\n\nउदाहरण 3:\nइनपुट: n = 4, k = 4\nआउटपुट: -1\nव्याख्या: 4 के गुणांक [1, 2, 4] हैं। कोई चौथा गुणांक नहीं है, इसलिए हम -1 लौटाते हैं।",
      "hu": "Írj egy Java függvényt `public int kthFactor(int n, int k)` a következő probléma megoldására:\nKét pozitív egész szám, n és k adott, találd meg n k-adik osztóját.\nEgy n osztója olyan pozitív egész szám, amely n-t maradék nélkül osztja.\nAdd vissza az n k-adik osztóját növekvő sorrendben. Ha n-nek kevesebb mint k osztója van, térj vissza -1-gyel.\n\n1. példa:\nBemenet: n = 12, k = 3\nKimenet: 3\nMagyarázat: A 12 osztói [1, 2, 3, 4, 6, 12]. A 3. osztó 3.\n\n2. példa:\nBemenet: n = 7, k = 2\nKimenet: 7\nMagyarázat: A 7 osztói [1, 7]. A 2. osztó 7.\n\n3. példa:\nBemenet: n = 4, k = 4\nKimenet: -1\nMagyarázat: A 4 osztói [1, 2, 4]. Nincs 4. osztó, ezért -1-et adunk vissza."
    },
    "instruction_bertscore": {
      "sq": "0.9836636443117857",
      "hy": "0.9880452318870342",
      "bn": "0.9880452318870342",
      "bg": "0.9733833303109439",
      "zh": "0.9871988678334446",
      "fr": "0.977329321460583",
      "de": "0.9764911012526158",
      "ha": "0.9856682221171897",
      "hi": "0.9676095423950218",
      "hu": "0.9616126925611975"
    },
    "level": "easy",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "kthFactor",
    "signature": "public int kthFactor(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni faktorin e k-të të n.\nNjë faktor i n është një numër i plotë pozitiv që e ndan n në mënyrë të barabartë.\nKtheni faktorin e k-të në rend rritës. Nëse n ka më pak se k faktorë, ktheni -1.\n\nShembull 1:\nInput: n = 12, k = 3\nOutput: 3\nShpjegim: Faktorët e 12 janë [1, 2, 3, 4, 6, 12]. Faktori i 3-të është 3.\n\nShembull 2:\nInput: n = 7, k = 2\nOutput: 7\nShpjegim: Faktorët e 7 janë [1, 7]. Faktori i 2-të është 7.\n\nShembull 3:\nInput: n = 4, k = 4\nOutput: -1\nShpjegim: Faktorët e 4 janë [1, 2, 4]. Nuk ka faktor të 4-të, kështu që ne kthejmë -1.",
      "hy": "Տրված են երկու դրական ամբողջ թվեր՝ n և k, գտնել n-ի k-րդ գործակիցը։ \nn-ի գործակիցը դրական ամբողջ թիվ է, որը n-ը հավասարապես բաժանում է։ \nՎերադարձնել k-րդ գործակիցը աճման կարգով։ Եթե n-ն ունի k-ից պակաս գործակիցներ, վերադարձնել -1։\n\nՕրինակ 1:\nՄուտքագրում: n = 12, k = 3\nԵլք: 3\nԲացատրություն: 12-ի գործակիցներն են [1, 2, 3, 4, 6, 12]։ 3-րդ գործակիցը 3 է։\n\nՕրինակ 2:\nՄուտքագրում: n = 7, k = 2\nԵլք: 7\nԲացատրություն: 7-ի գործակիցներն են [1, 7]։ 2-րդ գործակիցը 7 է։\n\nՕրինակ 3:\nՄուտքագրում: n = 4, k = 4\nԵլք: -1\nԲացատրություն: 4-ի գործակիցներն են [1, 2, 4]։ Չկա 4-րդ գործակից, ուստի վերադարձնում ենք -1։",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, n-এর kth গুণনীয়ক খুঁজে বের করুন। n-এর একটি গুণনীয়ক হল একটি ধনাত্মক পূর্ণসংখ্যা যা n কে সমানভাবে ভাগ করে। ক্রমবর্ধমান ক্রমে kth গুণনীয়কটি ফেরত দিন। যদি n-এর k-এর চেয়ে কম গুণনীয়ক থাকে, তাহলে -1 ফেরত দিন।\n\nউদাহরণ 1:\nইনপুট: n = 12, k = 3\nআউটপুট: 3\nব্যাখ্যা: 12-এর গুণনীয়কগুলি হল [1, 2, 3, 4, 6, 12]। তৃতীয় গুণনীয়ক হল 3।\n\nউদাহরণ 2:\nইনপুট: n = 7, k = 2\nআউটপুট: 7\nব্যাখ্যা: 7-এর গুণনীয়কগুলি হল [1, 7]। দ্বিতীয় গুণনীয়ক হল 7।\n\nউদাহরণ 3:\nইনপুট: n = 4, k = 4\nআউটপুট: -1\nব্যাখ্যা: 4-এর গুণনীয়কগুলি হল [1, 2, 4]। চতুর্থ গুণনীয়ক নেই, তাই আমরা -1 ফেরত দিই।",
      "bg": "Дадени са две положителни цели числа n и k, намерете k-тия делител на n. Делител на n е положително цяло число, което дели n без остатък. Върнете k-тия делител във възходящ ред. Ако n има по-малко от k делители, върнете -1.\n\nПример 1:\nВход: n = 12, k = 3\nИзход: 3\nОбяснение: Делителите на 12 са [1, 2, 3, 4, 6, 12]. Третият делител е 3.\n\nПример 2:\nВход: n = 7, k = 2\nИзход: 7\nОбяснение: Делителите на 7 са [1, 7]. Вторият делител е 7.\n\nПример 3:\nВход: n = 4, k = 4\nИзход: -1\nОбяснение: Делителите на 4 са [1, 2, 4]. Няма четвърти делител, затова връщаме -1.",
      "zh": "给定两个正整数 n 和 k，找出 n 的第 k 个因子。\nn 的因子是能整除 n 的正整数。\n按升序返回第 k 个因子。如果 n 的因子少于 k 个，则返回 -1。\n\n示例 1:\n输入: n = 12, k = 3\n输出: 3\n解释: 12 的因子是 [1, 2, 3, 4, 6, 12]。第 3 个因子是 3。\n\n示例 2:\n输入: n = 7, k = 2\n输出: 7\n解释: 7 的因子是 [1, 7]。第 2 个因子是 7。\n\n示例 3:\n输入: n = 4, k = 4\n输出: -1\n解释: 4 的因子是 [1, 2, 4]。没有第 4 个因子，因此返回 -1。",
      "fr": "Étant donné deux entiers positifs n et k, trouvez le k-ième facteur de n.  \nUn facteur de n est un entier positif qui divise n sans reste.  \nRetournez le k-ième facteur dans l'ordre croissant. Si n a moins de k facteurs, retournez -1.\n\nExemple 1:  \nEntrée: n = 12, k = 3  \nSortie: 3  \nExplication: Les facteurs de 12 sont [1, 2, 3, 4, 6, 12]. Le 3ème facteur est 3.\n\nExemple 2:  \nEntrée: n = 7, k = 2  \nSortie: 7  \nExplication: Les facteurs de 7 sont [1, 7]. Le 2ème facteur est 7.\n\nExemple 3:  \nEntrée: n = 4, k = 4  \nSortie: -1  \nExplication: Les facteurs de 4 sont [1, 2, 4]. Il n'y a pas de 4ème facteur, donc nous retournons -1.",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde den k-ten Faktor von n.\nEin Faktor von n ist eine positive ganze Zahl, die n ohne Rest teilt.\nGib den k-ten Faktor in aufsteigender Reihenfolge zurück. Wenn n weniger als k Faktoren hat, gib -1 zurück.\n\nBeispiel 1:\nEingabe: n = 12, k = 3\nAusgabe: 3\nErläuterung: Die Faktoren von 12 sind [1, 2, 3, 4, 6, 12]. Der 3. Faktor ist 3.\n\nBeispiel 2:\nEingabe: n = 7, k = 2\nAusgabe: 7\nErläuterung: Die Faktoren von 7 sind [1, 7]. Der 2. Faktor ist 7.\n\nBeispiel 3:\nEingabe: n = 4, k = 4\nAusgabe: -1\nErläuterung: Die Faktoren von 4 sind [1, 2, 4]. Es gibt keinen 4. Faktor, daher geben wir -1 zurück.",
      "ha": "An ba da lambobi guda biyu masu kyau n da k, nemo k na dalilin n.\nWani abin nadi na n shine lamba mai kyau wadda take raba n ba tare da saura ba.  \nReturn the kth factor in ascending order. Idan n yana da ƙasa da k abubuwan nadi, dawo da -1.\n\nMisali 1:  \nInput: n = 12, k = 3  \nOutput: 3  \nBayani: Abubuwan nadi na 12 sune [1, 2, 3, 4, 6, 12]. Abin nadi na 3 shine 3.\n\nMisali 2:  \nInput: n = 7, k = 2  \nOutput: 7  \nBayani: Abubuwan nadi na 7 sune [1, 7]. Abin nadi na 2 shine 7.\n\nMisali 3:  \nInput: n = 4, k = 4  \nOutput: -1  \nBayani: Abubuwan nadi na 4 sune [1, 2, 4]. Babu abin nadi na 4, don haka muna dawowa da -1.",
      "hi": "दिए गए दो धनात्मक पूर्णांक n और k के लिए, n का kth गुणक खोजें।\nn का एक गुणक एक धनात्मक पूर्णांक है जो n को समान रूप से विभाजित करता है।  \nAscending क्रम में kth गुणक लौटाएं। यदि n के पास k से कम गुणक हैं, तो -1 लौटाएं।\n\nउदाहरण 1:  \nइनपुट: n = 12, k = 3  \nआउटपुट: 3  \nव्याख्या: 12 के गुणक [1, 2, 3, 4, 6, 12] हैं। तीसरा गुणक 3 है।\n\nउदाहरण 2:  \nइनपुट: n = 7, k = 2  \nआउटपुट: 7  \nव्याख्या: 7 के गुणक [1, 7] हैं। दूसरा गुणक 7 है।\n\nउदाहरण 3:  \nइनपुट: n = 4, k = 4  \nआउटपुट: -1  \nव्याख्या: 4 के गुणक [1, 2, 4] हैं। कोई चौथा गुणक नहीं है, इसलिए हम -1 लौटाते हैं।",
      "hu": "Adott két pozitív egész szám, n és k, keressük meg n k-adik osztóját. Egy n osztója olyan pozitív egész szám, amely n-t maradék nélkül osztja. Adjuk vissza az osztókat növekvő sorrendben. Ha n-nek kevesebb mint k osztója van, térjünk vissza -1-gyel.\n\nPélda 1:\nBemenet: n = 12, k = 3\nKimenet: 3\nMagyarázat: A 12 osztói [1, 2, 3, 4, 6, 12]. A 3. osztó 3.\n\nPélda 2:\nBemenet: n = 7, k = 2\nKimenet: 7\nMagyarázat: A 7 osztói [1, 7]. A 2. osztó 7.\n\nPélda 3:\nBemenet: n = 4, k = 4\nKimenet: -1\nMagyarázat: A 4 osztói [1, 2, 4]. Nincs 4. osztó, így visszatérünk -1-gyel."
    },
    "docstring_bertscore": {
      "sq": "0.985441982113191",
      "hy": "0.9813227852712895",
      "bn": "0.9060152543880081",
      "bg": "0.8996445821770762",
      "zh": "0.9849235568186899",
      "fr": "0.9743252355778114",
      "de": "0.9743252355778114",
      "ha": "0.9809720040183818",
      "hi": "0.9919520928516095",
      "hu": "0.901174632002188"
    }
  },
  {
    "task_id": "Java/30",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     */\n  public String makeGood(String s) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg s që përbëhet nga shkronja të vogla dhe të mëdha të anglishtes,\n     * ju duhet ta bëni vargun \"të mirë\".\n     * Një varg konsiderohet \"i mirë\" nëse nuk ka karaktere ngjitur të tilla që\n     * njëra është një shkronjë e vogël dhe tjetra është shkronja përkatëse e madhe.\n     * Ju mund të zgjidhni çdo karakter ngjitur në varg dhe t'i hiqni derisa vargu të jetë \"i mirë\".\n     * Kthejeni vargun përfundimtar \"të mirë\".\n     *\n     * Shembulli 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Shpjegim: Ju mund të hiqni \"Ee\" për të bërë \"leetcode\".\n     *\n     * Shembulli 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Shpjegim: Ka zgjidhje të shumta të mundshme, të tilla si:\n     * - Hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\", pastaj hiqni \"aA\" për të bërë \"\".\n     * - Hiqni \"aA\" për të bërë \"abBAcC\", pastaj hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\",\n     *   pastaj hiqni \"aA\" për të bërë \"\".\n     * Pavarësisht zgjedhjeve, rezultati është një varg bosh.\n     *\n     * Shembulli 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Shpjegim: Vargu është tashmë \"i mirë\".\n     */\n  public String makeGood(String s) ",
      "hy": "class Solution {\n    /**\n     * Տրված է s տողը, որը բաղկացած է փոքրատառ և մեծատառ անգլերեն տառերից,\n     * անհրաժեշտ է դարձնել տողը \"լավ\":\n     * Տողը համարվում է \"լավ\", եթե չկան հարակից նիշեր, որոնցից\n     * մեկը փոքրատառ է, իսկ մյուսը՝ համապատասխան մեծատառ:\n     * Կարող եք ընտրել տողի ցանկացած հարակից նիշեր և հեռացնել դրանք, մինչև տողը դառնա \"լավ\":\n     * Վերադարձնել վերջնական \"լավ\" տողը:\n     *\n     * Օրինակ 1:\n     * Մուտք: s = \"leEeetcode\"\n     * Ելք: \"leetcode\"\n     * Բացատրություն: Կարող եք հեռացնել \"Ee\"՝ ստանալու համար \"leetcode\":\n     *\n     * Օրինակ 2.\n     * Մուտք: s = \"abBAcC\"\n     * Ելք: \"\"\n     * Բացատրություն: Կան մի քանի հնարավոր լուծումներ, օրինակ՝\n     * - Հեռացնել \"bB\"՝ ստանալու համար \"aAcC\", ապա հեռացնել \"cC\"՝ ստանալու համար \"aA\", ապա հեռացնել \"aA\"՝ ստանալու համար \"\":\n     * - Հեռացնել \"aA\"՝ ստանալու համար \"abBAcC\", ապա հեռացնել \"bB\"՝ ստանալու համար \"aAcC\", ապա հեռացնել \"cC\"՝ ստանալու համար \"aA\",\n     *   ապա հեռացնել \"aA\"՝ ստանալու համար \"\":\n     * Անկախ ընտրություններից, արդյունքը դատարկ տող է:\n     *\n     * Օրինակ 3.\n     * Մուտք: s = \"s\"\n     * Ելք: \"s\"\n     * Բացատրություն: Տողն արդեն \"լավ\" է:\n     */\n  public String makeGood(String s) ",
      "bn": "class Solution {\n    /**\n     * একটি স্ট্রিং s দেওয়া হয়েছে যা ছোট হাতের এবং বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত,\n     * আপনাকে স্ট্রিংটিকে \"ভালো\" করতে হবে।\n     * একটি স্ট্রিংকে \"ভালো\" বিবেচনা করা হয় যদি কোনো সংলগ্ন অক্ষর না থাকে এমনভাবে যে\n     * একটি ছোট হাতের অক্ষর এবং অন্যটি সংশ্লিষ্ট বড় হাতের অক্ষর।\n     * আপনি স্ট্রিংয়ের যেকোনো সংলগ্ন অক্ষর বেছে নিতে পারেন এবং সেগুলি মুছে ফেলতে পারেন যতক্ষণ না স্ট্রিংটি \"ভালো\" হয়।\n     * চূড়ান্ত \"ভালো\" স্ট্রিংটি ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: s = \"leEeetcode\"\n     * আউটপুট: \"leetcode\"\n     * ব্যাখ্যা: আপনি \"Ee\" মুছে \"leetcode\" করতে পারেন।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: s = \"abBAcC\"\n     * আউটপুট: \"\"\n     * ব্যাখ্যা: একাধিক সম্ভাব্য সমাধান রয়েছে, যেমন:\n     * - \"bB\" মুছে \"aAcC\" করতে পারেন, তারপর \"cC\" মুছে \"aA\" করতে পারেন, তারপর \"aA\" মুছে \"\" করতে পারেন।\n     * - \"aA\" মুছে \"abBAcC\" করতে পারেন, তারপর \"bB\" মুছে \"aAcC\" করতে পারেন, তারপর \"cC\" মুছে \"aA\" করতে পারেন,\n     *   তারপর \"aA\" মুছে \"\" করতে পারেন।\n     * কোনো ব্যাপার না পছন্দগুলি, ফলাফল একটি খালি স্ট্রিং।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: s = \"s\"\n     * আউটপুট: \"s\"\n     * ব্যাখ্যা: স্ট্রিংটি ইতিমধ্যেই \"ভালো\"।\n     */\n  public String makeGood(String s) ",
      "bg": "class Solution {\n    /**\n     * Даден е низ s, състоящ се от малки и главни английски букви,\n     * трябва да направите низа \"добър\".\n     * Един низ се счита за \"добър\", ако няма съседни символи, такива че\n     * единият е малка буква, а другият е съответната главна буква.\n     * Можете да изберете произволни съседни символи в низа и да ги премахнете, докато низът стане \"добър\".\n     * Върнете крайния \"добър\" низ.\n     *\n     * Пример 1:\n     * Вход: s = \"leEeetcode\"\n     * Изход: \"leetcode\"\n     * Обяснение: Можете да премахнете \"Ee\", за да направите \"leetcode\".\n     *\n     * Пример 2:\n     * Вход: s = \"abBAcC\"\n     * Изход: \"\"\n     * Обяснение: Има множество възможни решения, като например:\n     * - Премахнете \"bB\", за да направите \"aAcC\", след това премахнете \"cC\", за да направите \"aA\", след това премахнете \"aA\", за да направите \"\".\n     * - Премахнете \"aA\", за да направите \"abBAcC\", след това премахнете \"bB\", за да направите \"aAcC\", след това премахнете \"cC\", за да направите \"aA\",\n     *   след това премахнете \"aA\", за да направите \"\".\n     * Независимо от избора, резултатът е празен низ.\n     *\n     * Пример 3:\n     * Вход: s = \"s\"\n     * Изход: \"s\"\n     * Обяснение: Низът вече е \"добър\".\n     */\n  public String makeGood(String s) ",
      "zh": "class Solution {\n    /**\n     * 给定一个由小写和大写英文字母组成的字符串s，\n     * 你需要使字符串变得“好”。\n     * 如果没有相邻字符满足一个是小写字母，另一个是对应的大写字母，\n     * 则认为字符串是“好”的。\n     * 你可以选择字符串中的任意相邻字符并将其移除，直到字符串变得“好”为止。\n     * 返回最终的“好”字符串。\n     *\n     * 示例1:\n     * 输入: s = \"leEeetcode\"\n     * 输出: \"leetcode\"\n     * 解释: 你可以移除 \"Ee\" 使其变为 \"leetcode\"。\n     *\n     * 示例2:\n     * 输入: s = \"abBAcC\"\n     * 输出: \"\"\n     * 解释: 有多种可能的解决方案，例如：\n     * - 移除 \"bB\" 使其变为 \"aAcC\"，然后移除 \"cC\" 使其变为 \"aA\"，然后移除 \"aA\" 使其变为 \"\"。\n     * - 移除 \"aA\" 使其变为 \"abBAcC\"，然后移除 \"bB\" 使其变为 \"aAcC\"，然后移除 \"cC\" 使其变为 \"aA\"，\n     *   然后移除 \"aA\" 使其变为 \"\"。\n     * 无论选择如何，结果都是一个空字符串。\n     *\n     * 示例3:\n     * 输入: s = \"s\"\n     * 输出: \"s\"\n     * 解释: 字符串已经是“好”的。\n     */\n  public String makeGood(String s) ",
      "fr": "class Solution {\n    /**\n     * Étant donné une chaîne s composée de lettres anglaises minuscules et majuscules,\n     * vous devez rendre la chaîne \"bonne\".\n     * Une chaîne est considérée comme \"bonne\" s'il n'y a pas de caractères adjacents tels que\n     * l'un est une lettre minuscule et l'autre est la lettre majuscule correspondante.\n     * Vous pouvez choisir n'importe quels caractères adjacents dans la chaîne et les supprimer jusqu'à ce que la chaîne soit \"bonne\".\n     * Retournez la chaîne \"bonne\" finale.\n     *\n     * Exemple 1 :\n     * Entrée : s = \"leEeetcode\"\n     * Sortie : \"leetcode\"\n     * Explication : Vous pouvez supprimer \"Ee\" pour obtenir \"leetcode\".\n     *\n     * Exemple 2 :\n     * Entrée : s = \"abBAcC\"\n     * Sortie : \"\"\n     * Explication : Il y a plusieurs solutions possibles, telles que :\n     * - Supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\", puis supprimer \"aA\" pour obtenir \"\".\n     * - Supprimer \"aA\" pour obtenir \"abBAcC\", puis supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\",\n     *   puis supprimer \"aA\" pour obtenir \"\".\n     * Peu importe les choix, le résultat est une chaîne vide.\n     *\n     * Exemple 3 :\n     * Entrée : s = \"s\"\n     * Sortie : \"s\"\n     * Explication : La chaîne est déjà \"bonne\".\n     */\n  public String makeGood(String s) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein String s, bestehend aus Klein- und Großbuchstaben des englischen Alphabets,\n     * müssen Sie den String \"gut\" machen.\n     * Ein String wird als \"gut\" betrachtet, wenn es keine benachbarten Zeichen gibt, bei denen\n     * eines ein Kleinbuchstabe und das andere der entsprechende Großbuchstabe ist.\n     * Sie können beliebige benachbarte Zeichen im String auswählen und entfernen, bis der String \"gut\" ist.\n     * Geben Sie den endgültigen \"guten\" String zurück.\n     *\n     * Beispiel 1:\n     * Eingabe: s = \"leEeetcode\"\n     * Ausgabe: \"leetcode\"\n     * Erklärung: Sie können \"Ee\" entfernen, um \"leetcode\" zu machen.\n     *\n     * Beispiel 2:\n     * Eingabe: s = \"abBAcC\"\n     * Ausgabe: \"\"\n     * Erklärung: Es gibt mehrere mögliche Lösungen, wie zum Beispiel:\n     * - Entfernen Sie \"bB\", um \"aAcC\" zu machen, dann entfernen Sie \"cC\", um \"aA\" zu machen, dann entfernen Sie \"aA\", um \"\" zu machen.\n     * - Entfernen Sie \"aA\", um \"abBAcC\" zu machen, dann entfernen Sie \"bB\", um \"aAcC\" zu machen, dann entfernen Sie \"cC\", um \"aA\" zu machen,\n     *   dann entfernen Sie \"aA\", um \"\" zu machen.\n     * Unabhängig von den Entscheidungen ist das Ergebnis ein leerer String.\n     *\n     * Beispiel 3:\n     * Eingabe: s = \"s\"\n     * Ausgabe: \"s\"\n     * Erklärung: Der String ist bereits \"gut\".\n     */\n  public String makeGood(String s) ",
      "ha": "class Solution {\n    /**\n     * An ba da wata igiyar haruffa s da ta ƙunshi ƙananan da manyan haruffan Ingilishi,\n     * kana buƙatar ka sa igiyar ta zama \"mai kyau\".\n     * Ana ɗaukar igiya a matsayin \"mai kyau\" idan babu haruffa masu makwabtaka da\n     * ɗaya yana da ƙananan harafi kuma ɗayan yana da babban harafi daidai.\n     * Za ka iya zaɓar kowane haruffa masu makwabtaka a cikin igiyar kuma ka cire su har sai igiyar ta zama \"mai kyau\".\n     * Mayar da igiyar ƙarshe \"mai kyau\".\n     *\n     * Misali 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Bayani: Za ka iya cire \"Ee\" don sa \"leetcode\".\n     *\n     * Misali 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Bayani: Akwai hanyoyi da dama masu yiwuwa, kamar:\n     * - Cire \"bB\" don sa \"aAcC\", sannan cire \"cC\" don sa \"aA\", sannan cire \"aA\" don sa \"\".\n     * - Cire \"aA\" don sa \"abBAcC\", sannan cire \"bB\" don sa \"aAcC\", sannan cire \"cC\" don sa \"aA\",\n     *   sannan cire \"aA\" don sa \"\".\n     * Duk da zaɓin, sakamakon shi ne igiya babu komai.\n     *\n     * Misali 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Bayani: Igiya ta riga ta zama \"mai kyau\".\n     */\n  public String makeGood(String s) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक स्ट्रिंग s जिसमें छोटे और बड़े अंग्रेजी अक्षर होते हैं,\n     * आपको स्ट्रिंग को \"अच्छा\" बनाना है।\n     * एक स्ट्रिंग को \"अच्छा\" माना जाता है यदि कोई ऐसे आसन्न अक्षर नहीं हैं\n     * जिनमें से एक छोटा अक्षर है और दूसरा उसके अनुरूप बड़ा अक्षर है।\n     * आप स्ट्रिंग में कोई भी आसन्न अक्षर चुन सकते हैं और उन्हें हटा सकते हैं जब तक कि स्ट्रिंग \"अच्छा\" न हो जाए।\n     * अंतिम \"अच्छा\" स्ट्रिंग लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: s = \"leEeetcode\"\n     * आउटपुट: \"leetcode\"\n     * व्याख्या: आप \"Ee\" को हटा सकते हैं ताकि \"leetcode\" बन सके।\n     *\n     * उदाहरण 2:\n     * इनपुट: s = \"abBAcC\"\n     * आउटपुट: \"\"\n     * व्याख्या: कई संभावित समाधान हैं, जैसे:\n     * - \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं, फिर \"aA\" को हटाकर \"\" बनाएं।\n     * - \"aA\" को हटाकर \"abBAcC\" बनाएं, फिर \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं,\n     *   फिर \"aA\" को हटाकर \"\" बनाएं।\n     * चाहे जो भी विकल्प चुने जाएं, परिणाम एक खाली स्ट्रिंग है।\n     *\n     * उदाहरण 3:\n     * इनपुट: s = \"s\"\n     * आउटपुट: \"s\"\n     * व्याख्या: स्ट्रिंग पहले से ही \"अच्छा\" है।\n     */\n  public String makeGood(String s) ",
      "hu": "class Solution {\n    /**\n     * Adott egy s karakterlánc, amely kis- és nagybetűs angol betűkből áll,\n     * a karakterláncot \"jóvá\" kell tenni.\n     * Egy karakterlánc akkor tekinthető \"jónak\", ha nincsenek szomszédos karakterek,\n     * amelyek közül az egyik kisbetű, a másik pedig a megfelelő nagybetű.\n     * Kiválaszthat bármely szomszédos karaktert a karakterláncban, és eltávolíthatja őket,\n     * amíg a karakterlánc \"jó\" nem lesz.\n     * Adja vissza a végső \"jó\" karakterláncot.\n     *\n     * 1. példa:\n     * Bemenet: s = \"leEeetcode\"\n     * Kimenet: \"leetcode\"\n     * Magyarázat: Eltávolíthatja az \"Ee\"-t, hogy \"leetcode\"-t kapjon.\n     *\n     * 2. példa:\n     * Bemenet: s = \"abBAcC\"\n     * Kimenet: \"\"\n     * Magyarázat: Több lehetséges megoldás is van, például:\n     * - Távolítsa el a \"bB\"-t, hogy \"aAcC\"-t kapjon, majd távolítsa el a \"cC\"-t, hogy \"aA\"-t kapjon,\n     *   majd távolítsa el az \"aA\"-t, hogy \"\"-t kapjon.\n     * - Távolítsa el az \"aA\"-t, hogy \"abBAcC\"-t kapjon, majd távolítsa el a \"bB\"-t, hogy \"aAcC\"-t kapjon,\n     *   majd távolítsa el a \"cC\"-t, hogy \"aA\"-t kapjon, majd távolítsa el az \"aA\"-t, hogy \"\"-t kapjon.\n     * Nem számít, milyen választásokat tesz, az eredmény egy üres karakterlánc lesz.\n     *\n     * 3. példa:\n     * Bemenet: s = \"s\"\n     * Kimenet: \"s\"\n     * Magyarázat: A karakterlánc már \"jó\".\n     */\n  public String makeGood(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9948656032806292",
      "hy": "0.9731372272688418",
      "bn": "0.9763468955959845",
      "bg": "0.9956366864198066",
      "zh": "0.9748680924091797",
      "fr": "0.9885920613260233",
      "de": "0.9849668582417556",
      "ha": "0.9867130179214332",
      "hi": "0.990828043525333",
      "hu": "0.97233078792184"
    },
    "canonical_solution": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }",
    "instruction": {
      "en": "Write a Java function `public String makeGood(String s)` to solve the following problem:\nGiven a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".",
      "sq": "Shkruani një funksion Java `public String makeGood(String s)` për të zgjidhur problemin në vijim:  \nDuke pasur një varg s që përbëhet nga shkronja të vogla dhe të mëdha të alfabetit anglez,  \nju duhet ta bëni vargun \"të mirë\".  \nNjë varg konsiderohet \"i mirë\" nëse nuk ka karaktere ngjitur të tilla që  \nnjëri është një shkronjë e vogël dhe tjetri është shkronja përkatëse e madhe.  \nJu mund të zgjidhni çdo karakter ngjitur në varg dhe t'i hiqni ato derisa vargu të jetë \"i mirë\".  \nKtheni vargun final \"të mirë\".\n\nShembulli 1:  \nInput: s = \"leEeetcode\"  \nOutput: \"leetcode\"  \nShpjegim: Ju mund të hiqni \"Ee\" për të bërë \"leetcode\".\n\nShembulli 2:  \nInput: s = \"abBAcC\"  \nOutput: \"\"  \nShpjegim: Ka zgjidhje të shumta të mundshme, të tilla si:  \n- Hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\", pastaj hiqni \"aA\" për të bërë \"\".  \n- Hiqni \"aA\" për të bërë \"abBAcC\", pastaj hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\",  \npastaj hiqni \"aA\" për të bërë \"\".  \nPavarësisht zgjedhjeve, rezultati është një varg bosh.\n\nShembulli 3:  \nInput: s = \"s\"  \nOutput: \"s\"  \nShpjegim: Vargu është tashmë \"i mirë\".",
      "hy": "Գրեք Java ֆունկցիա `public String makeGood(String s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է s տողը, որը բաղկացած է փոքրատառ և մեծատառ անգլերեն տառերից,\nՁեզ անհրաժեշտ է տողը դարձնել \"լավ\"։\nՏողը համարվում է \"լավ\", եթե չկան հարակից նիշեր, որոնցից մեկը փոքրատառ է, իսկ մյուսը՝ համապատասխան մեծատառ։\nԴուք կարող եք ընտրել ցանկացած հարակից նիշեր տողում և հեռացնել դրանք, մինչև տողը դառնա \"լավ\"։\nՎերադարձնել վերջնական \"լավ\" տողը։\n\nՕրինակ 1:\nՄուտք: s = \"leEeetcode\"\nԵլք: \"leetcode\"\nԲացատրություն: Կարող եք հեռացնել \"Ee\"՝ \"leetcode\" ստանալու համար։\n\nՕրինակ 2:\nՄուտք: s = \"abBAcC\"\nԵլք: \"\"\nԲացատրություն: Կան բազմաթիվ հնարավոր լուծումներ, օրինակ՝\n- Հեռացնել \"bB\"՝ \"aAcC\" ստանալու համար, ապա հեռացնել \"cC\"՝ \"aA\" ստանալու համար, ապա հեռացնել \"aA\"՝ \"\" ստանալու համար։\n- Հեռացնել \"aA\"՝ \"abBAcC\" ստանալու համար, ապա հեռացնել \"bB\"՝ \"aAcC\" ստանալու համար, ապա հեռացնել \"cC\"՝ \"aA\" ստանալու համար,\nապա հեռացնել \"aA\"՝ \"\" ստանալու համար։\nԱնկախ ընտրություններից, արդյունքը դատարկ տող է։\n\nՕրինակ 3:\nՄուտք: s = \"s\"\nԵլք: \"s\"\nԲացատրություն: Տողն արդեն \"լավ\" է։",
      "bn": "একটি জাভা ফাংশন `public String makeGood(String s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং s দেওয়া হয়েছে যা ছোট হাতের এবং বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত,\nআপনাকে স্ট্রিংটিকে \"ভাল\" করতে হবে।\nএকটি স্ট্রিংকে \"ভাল\" বলে বিবেচনা করা হয় যদি সেখানে কোনো সংলগ্ন অক্ষর না থাকে যেমন\nএকটি ছোট হাতের অক্ষর এবং অন্যটি সংশ্লিষ্ট বড় হাতের অক্ষর।\nআপনি স্ট্রিংয়ের যেকোনো সংলগ্ন অক্ষর বেছে নিতে পারেন এবং সেগুলি সরিয়ে দিতে পারেন যতক্ষণ না স্ট্রিংটি \"ভাল\" হয়।\nফাইনাল \"ভাল\" স্ট্রিংটি রিটার্ন করুন।\n\nউদাহরণ 1:\nইনপুট: s = \"leEeetcode\"\nআউটপুট: \"leetcode\"\nব্যাখ্যা: আপনি \"Ee\" সরিয়ে \"leetcode\" করতে পারেন।\n\nউদাহরণ 2:\nইনপুট: s = \"abBAcC\"\nআউটপুট: \"\"\nব্যাখ্যা: একাধিক সম্ভাব্য সমাধান রয়েছে, যেমন:\n- \"bB\" সরিয়ে \"aAcC\" করুন, তারপর \"cC\" সরিয়ে \"aA\" করুন, তারপর \"aA\" সরিয়ে \"\" করুন।\n- \"aA\" সরিয়ে \"abBAcC\" করুন, তারপর \"bB\" সরিয়ে \"aAcC\" করুন, তারপর \"cC\" সরিয়ে \"aA\" করুন,\nতারপর \"aA\" সরিয়ে \"\" করুন।\nযে কোনো পছন্দ হোক না কেন, ফলাফল একটি খালি স্ট্রিং।\n\nউদাহরণ 3:\nইনপুট: s = \"s\"\nআউটপুট: \"s\"\nব্যাখ্যা: স্ট্রিংটি ইতিমধ্যেই \"ভাল\"।",
      "bg": "Напишете Java функция `public String makeGood(String s)`, за да решите следния проблем:  \nДаден е низ s, състоящ се от малки и главни английски букви,  \nтрябва да направите низа \"добър\".  \nЕдин низ се счита за \"добър\", ако няма съседни символи, такива че  \nедин е малка буква, а другият е съответната главна буква.  \nМожете да изберете произволни съседни символи в низа и да ги премахнете, докато низът стане \"добър\".  \nВърнете крайния \"добър\" низ.\n\nПример 1:  \nВход: s = \"leEeetcode\"  \nИзход: \"leetcode\"  \nОбяснение: Можете да премахнете \"Ee\", за да получите \"leetcode\".\n\nПример 2:  \nВход: s = \"abBAcC\"  \nИзход: \"\"  \nОбяснение: Има няколко възможни решения, като например:  \n- Премахнете \"bB\", за да получите \"aAcC\", след това премахнете \"cC\", за да получите \"aA\", след това премахнете \"aA\", за да получите \"\".  \n- Премахнете \"aA\", за да получите \"abBAcC\", след това премахнете \"bB\", за да получите \"aAcC\", след това премахнете \"cC\", за да получите \"aA\",  \nслед това премахнете \"aA\", за да получите \"\".  \nНезависимо от избора, резултатът е празен низ.\n\nПример 3:  \nВход: s = \"s\"  \nИзход: \"s\"  \nОбяснение: Низът вече е \"добър\".",
      "zh": "编写一个 Java 函数 `public String makeGood(String s)` 来解决以下问题：  \n给定一个由小写和大写英文字母组成的字符串 s，  \n你需要使字符串变得“良好”。  \n如果字符串中没有相邻字符，一个是小写字母，另一个是对应的大写字母，则该字符串被认为是“良好”的。  \n你可以选择字符串中的任何相邻字符并将其删除，直到字符串变得“良好”。  \n返回最终的“良好”字符串。\n\n示例 1：  \n输入：s = \"leEeetcode\"  \n输出：\"leetcode\"  \n解释：你可以删除 \"Ee\" 使其变为 \"leetcode\"。\n\n示例 2：  \n输入：s = \"abBAcC\"  \n输出：\"\"  \n解释：有多种可能的解决方案，例如：  \n- 删除 \"bB\" 使其变为 \"aAcC\"，然后删除 \"cC\" 使其变为 \"aA\"，然后删除 \"aA\" 使其变为 \"\"。  \n- 删除 \"aA\" 使其变为 \"abBAcC\"，然后删除 \"bB\" 使其变为 \"aAcC\"，然后删除 \"cC\" 使其变为 \"aA\"，  \n然后删除 \"aA\" 使其变为 \"\"。  \n无论选择如何，结果都是一个空字符串。\n\n示例 3：  \n输入：s = \"s\"  \n输出：\"s\"  \n解释：字符串已经是“良好”的。",
      "fr": "Écrire une fonction Java `public String makeGood(String s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne s composée de lettres anglaises minuscules et majuscules,  \nvous devez rendre la chaîne \"bonne\".  \nUne chaîne est considérée comme \"bonne\" s'il n'y a pas de caractères adjacents tels que  \nl'un soit une lettre minuscule et l'autre la lettre majuscule correspondante.  \nVous pouvez choisir n'importe quels caractères adjacents dans la chaîne et les supprimer jusqu'à ce que la chaîne soit \"bonne\".  \nRetournez la chaîne \"bonne\" finale.  \n\nExemple 1 :  \nEntrée : s = \"leEeetcode\"  \nSortie : \"leetcode\"  \nExplication : Vous pouvez supprimer \"Ee\" pour obtenir \"leetcode\".  \n\nExemple 2 :  \nEntrée : s = \"abBAcC\"  \nSortie : \"\"  \nExplication : Il y a plusieurs solutions possibles, telles que :  \n- Supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\", puis supprimer \"aA\" pour obtenir \"\".  \n- Supprimer \"aA\" pour obtenir \"abBAcC\", puis supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\",  \npuis supprimer \"aA\" pour obtenir \"\".  \nPeu importe les choix, le résultat est une chaîne vide.  \n\nExemple 3 :  \nEntrée : s = \"s\"  \nSortie : \"s\"  \nExplication : La chaîne est déjà \"bonne\".  ",
      "de": "Schreiben Sie eine Java-Funktion `public String makeGood(String s)`, um das folgende Problem zu lösen:\nGegeben ist ein String s, bestehend aus Klein- und Großbuchstaben des englischen Alphabets,\nSie müssen den String \"good\" machen.\nEin String wird als \"good\" betrachtet, wenn es keine benachbarten Zeichen gibt, bei denen\neines ein Kleinbuchstabe und das andere der entsprechende Großbuchstabe ist.\nSie können beliebige benachbarte Zeichen im String auswählen und entfernen, bis der String \"good\" ist.\nGeben Sie den endgültigen \"good\"-String zurück.\n\nBeispiel 1:\nEingabe: s = \"leEeetcode\"\nAusgabe: \"leetcode\"\nErklärung: Sie können \"Ee\" entfernen, um \"leetcode\" zu erhalten.\n\nBeispiel 2:\nEingabe: s = \"abBAcC\"\nAusgabe: \"\"\nErklärung: Es gibt mehrere mögliche Lösungen, wie zum Beispiel:\n- Entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten, dann entfernen Sie \"aA\", um \"\" zu erhalten.\n- Entfernen Sie \"aA\", um \"abBAcC\" zu erhalten, dann entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten,\ndann entfernen Sie \"aA\", um \"\" zu erhalten.\nUnabhängig von den Entscheidungen ist das Ergebnis ein leerer String.\n\nBeispiel 3:\nEingabe: s = \"s\"\nAusgabe: \"s\"\nErklärung: Der String ist bereits \"good\".",
      "ha": "Rubuta wani aikin Java `public String makeGood(String s)` don warware matsalar mai zuwa:\nAn ba da wani igiyar s da ke ƙunshe da ƙananan haruffa da manyan haruffan Ingilishi,\nkana buƙatar sanya igiyar ta zama \"mai kyau\".\nAna ɗaukar igiyar \"mai kyau\" idan babu haruffa masu makwabtaka da\ndaya yana da ƙaramar harafi kuma ɗayan yana da babbar harafin da ya dace.\nZa ka iya zaɓar duk wani haruffa masu makwabtaka a cikin igiyar kuma ka cire su har sai igiyar ta zama \"mai kyau\".\nMayar da igiyar \"mai kyau\" ta ƙarshe.\n\nMisali 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nBayani: Za ka iya cire \"Ee\" don sanya \"leetcode\".\n\nMisali 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nBayani: Akwai hanyoyi da dama masu yuwuwa, kamar:\n- Cire \"bB\" don sanya \"aAcC\", sannan cire \"cC\" don sanya \"aA\", sannan cire \"aA\" don sanya \"\".\n- Cire \"aA\" don sanya \"abBAcC\", sannan cire \"bB\" don sanya \"aAcC\", sannan cire \"cC\" don sanya \"aA\",\nsannan cire \"aA\" don sanya \"\".\nDuk da zaɓin da aka yi, sakamakon shi ne igiyar mai komai.\n\nMisali 3:\nInput: s = \"s\"\nOutput: \"s\"\nBayani: Igiyar tuni tana da \"mai kyau\".",
      "hi": "Java फ़ंक्शन `public String makeGood(String s)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए एक स्ट्रिंग s जिसमें छोटे और बड़े अंग्रेजी अक्षर शामिल हैं,\nआपको स्ट्रिंग को \"अच्छा\" बनाना है।\nएक स्ट्रिंग को \"अच्छा\" तब माना जाता है जब उसमें कोई भी आसन्न अक्षर नहीं होते हैं\nजिसमें एक छोटा अक्षर और दूसरा संबंधित बड़ा अक्षर होता है।\nआप स्ट्रिंग में किसी भी आसन्न अक्षरों को चुन सकते हैं और उन्हें हटा सकते हैं जब तक कि स्ट्रिंग \"अच्छा\" न हो जाए।\nअंतिम \"अच्छा\" स्ट्रिंग वापस करें।\n\nउदाहरण 1:\nइनपुट: s = \"leEeetcode\"\nआउटपुट: \"leetcode\"\nव्याख्या: आप \"Ee\" को हटाकर \"leetcode\" बना सकते हैं।\n\nउदाहरण 2:\nइनपुट: s = \"abBAcC\"\nआउटपुट: \"\"\nव्याख्या: कई संभावित समाधान हैं, जैसे:\n- \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं, फिर \"aA\" को हटाकर \"\" बनाएं।\n- \"aA\" को हटाकर \"abBAcC\" बनाएं, फिर \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं,\nफिर \"aA\" को हटाकर \"\" बनाएं।\nचाहे जो भी विकल्प चुने जाएं, परिणाम एक खाली स्ट्रिंग होता है।\n\nउदाहरण 3:\nइनपुट: s = \"s\"\nआउटपुट: \"s\"\nव्याख्या: स्ट्रिंग पहले से ही \"अच्छा\" है।",
      "hu": "Írj egy Java függvényt `public String makeGood(String s)` a következő probléma megoldására:\nAdott egy s karakterlánc, amely kis- és nagybetűs angol betűkből áll,\nés a karakterláncot \"jóvá\" kell tenni.\nEgy karakterlánc akkor tekinthető \"jónak\", ha nincsenek egymás melletti karakterek, ahol\naz egyik kisbetű, a másik pedig a megfelelő nagybetű.\nKiválaszthatsz bármilyen egymás melletti karaktert a karakterláncban, és eltávolíthatod őket, amíg a karakterlánc \"jó\" nem lesz.\nAdd vissza a végső \"jó\" karakterláncot.\n\n1. példa:\nBemenet: s = \"leEeetcode\"\nKimenet: \"leetcode\"\nMagyarázat: Eltávolíthatod az \"Ee\"-t, hogy \"leetcode\"-t kapj.\n\n2. példa:\nBemenet: s = \"abBAcC\"\nKimenet: \"\"\nMagyarázat: Több lehetséges megoldás is van, például:\n- Eltávolítod a \"bB\"-t, hogy \"aAcC\"-t kapj, majd eltávolítod a \"cC\"-t, hogy \"aA\"-t kapj, majd eltávolítod az \"aA\"-t, hogy \"\"-t kapj.\n- Eltávolítod az \"aA\"-t, hogy \"abBAcC\"-t kapj, majd eltávolítod a \"bB\"-t, hogy \"aAcC\"-t kapj, majd eltávolítod a \"cC\"-t, hogy \"aA\"-t kapj,\nmajd eltávolítod az \"aA\"-t, hogy \"\"-t kapj.\nBármilyen választás esetén az eredmény egy üres karakterlánc.\n\n3. példa:\nBemenet: s = \"s\"\nKimenet: \"s\"\nMagyarázat: A karakterlánc már \"jó\"."
    },
    "instruction_bertscore": {
      "sq": "0.9886844244532045",
      "hy": "0.9817647378690921",
      "bn": "0.9880019304639686",
      "bg": "0.9843215081337732",
      "zh": "0.9692984965249615",
      "fr": "0.9813116619699516",
      "de": "0.972968192814581",
      "ha": "0.9893293773004248",
      "hi": "0.9919316339223628",
      "hu": "0.9701976962599064"
    },
    "level": "easy",
    "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "makeGood",
    "signature": "public String makeGood(String s)",
    "docstring": {
      "en": "Given a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".",
      "sq": "Duke pasur një varg s që përbëhet nga shkronja angleze të vogla dhe të mëdha,\nju duhet ta bëni vargun \"të mirë\".\nNjë varg konsiderohet \"i mirë\" nëse nuk ka karaktere ngjitur të tilla që\nnjëri është një shkronjë e vogël dhe tjetri është shkronja përkatëse e madhe.\nJu mund të zgjidhni çdo karakter ngjitur në varg dhe t'i hiqni derisa vargu të jetë \"i mirë\".\nKtheni vargun përfundimtar \"të mirë\".\n\nShembulli 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nShpjegim: Ju mund të hiqni \"Ee\" për ta bërë \"leetcode\".\n\nShembulli 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nShpjegim: Ka zgjidhje të shumta të mundshme, të tilla si:\n- Hiqni \"bB\" për ta bërë \"aAcC\", pastaj hiqni \"cC\" për ta bërë \"aA\", pastaj hiqni \"aA\" për ta bërë \"\".\n- Hiqni \"aA\" për ta bërë \"abBAcC\", pastaj hiqni \"bB\" për ta bërë \"aAcC\", pastaj hiqni \"cC\" për ta bërë \"aA\",\npastaj hiqni \"aA\" për ta bërë \"\".\nPavarësisht zgjedhjeve, rezultati është një varg bosh.\n\nShembulli 3:\nInput: s = \"s\"\nOutput: \"s\"\nShpjegim: Vargu është tashmë \"i mirë\".",
      "hy": "Տրված է s տողը, որը բաղկացած է փոքրատառ և մեծատառ անգլերեն տառերից, \nդուք պետք է տողը դարձնեք \"լավ\"։ \nՏողը համարվում է \"լավ\", եթե չկան հարակից նիշեր, որոնցից մեկը փոքրատառ է, իսկ մյուսը՝ համապատասխան մեծատառ։ \nԴուք կարող եք ընտրել ցանկացած հարակից նիշեր տողում և հեռացնել դրանք, մինչև տողը դառնա \"լավ\"։ \nՎերադարձնել վերջնական \"լավ\" տողը։\n\nՕրինակ 1:\nՄուտք: s = \"leEeetcode\"\nԵլք: \"leetcode\"\nԲացատրություն: Դուք կարող եք հեռացնել \"Ee\"-ն, որպեսզի ստացվի \"leetcode\"։\n\nՕրինակ 2:\nՄուտք: s = \"abBAcC\"\nԵլք: \"\"\nԲացատրություն: Կան մի քանի հնարավոր լուծումներ, օրինակ՝\n- Հեռացնել \"bB\"-ն, որպեսզի ստացվի \"aAcC\", ապա հեռացնել \"cC\"-ն, որպեսզի ստացվի \"aA\", ապա հեռացնել \"aA\"-ն, որպեսզի ստացվի \"\"։\n- Հեռացնել \"aA\"-ն, որպեսզի ստացվի \"abBAcC\", ապա հեռացնել \"bB\"-ն, որպեսզի ստացվի \"aAcC\", ապա հեռացնել \"cC\"-ն, որպեսզի ստացվի \"aA\",\nապա հեռացնել \"aA\"-ն, որպեսզի ստացվի \"\"։\nՈրոշումների տարբերություն չկա, արդյունքը դատարկ տող է։\n\nՕրինակ 3:\nՄուտք: s = \"s\"\nԵլք: \"s\"\nԲացատրություն: Տողն արդեն \"լավ\" է։",
      "bn": "একটি স্ট্রিং s দেওয়া হয়েছে যা ছোট এবং বড় ইংরেজি অক্ষর নিয়ে গঠিত, \nআপনাকে স্ট্রিংটিকে \"ভালো\" করতে হবে। \nএকটি স্ট্রিংকে \"ভালো\" বিবেচনা করা হয় যদি সেখানে কোনো সংলগ্ন অক্ষর না থাকে \nযেমন একটি ছোট হাতের অক্ষর এবং অন্যটি সংশ্লিষ্ট বড় হাতের অক্ষর। \nআপনি স্ট্রিংয়ের যেকোনো সংলগ্ন অক্ষর বেছে নিতে পারেন এবং সেগুলি মুছে ফেলতে পারেন যতক্ষণ না স্ট্রিংটি \"ভালো\" হয়। \nচূড়ান্ত \"ভালো\" স্ট্রিংটি ফেরত দিন।\n\nউদাহরণ ১:\nইনপুট: s = \"leEeetcode\"\nআউটপুট: \"leetcode\"\nব্যাখ্যা: আপনি \"Ee\" মুছে \"leetcode\" করতে পারেন।\n\nউদাহরণ ২:\nইনপুট: s = \"abBAcC\"\nআউটপুট: \"\"\nব্যাখ্যা: একাধিক সম্ভাব্য সমাধান রয়েছে, যেমন:\n- \"bB\" মুছে \"aAcC\" করতে পারেন, তারপর \"cC\" মুছে \"aA\" করতে পারেন, তারপর \"aA\" মুছে \"\" করতে পারেন।\n- \"aA\" মুছে \"abBAcC\" করতে পারেন, তারপর \"bB\" মুছে \"aAcC\" করতে পারেন, তারপর \"cC\" মুছে \"aA\" করতে পারেন,\nতারপর \"aA\" মুছে \"\" করতে পারেন।\nযে কোনো পছন্দেই, ফলাফল একটি খালি স্ট্রিং হয়।\n\nউদাহরণ ৩:\nইনপুট: s = \"s\"\nআউটপুট: \"s\"\nব্যাখ্যা: স্ট্রিংটি ইতিমধ্যেই \"ভালো\"।",
      "bg": "Даден е низ `s`, състоящ се от малки и главни английски букви, трябва да направите низа \"добър\". Низ се счита за \"добър\", ако няма съседни символи, така че единият да е малка буква, а другият да е съответната главна буква. Можете да изберете произволни съседни символи в низа и да ги премахнете, докато низът стане \"добър\". Върнете крайния \"добър\" низ.\n\nПример 1:\nВход: s = \"leEeetcode\"\nИзход: \"leetcode\"\nОбяснение: Можете да премахнете \"Ee\", за да направите \"leetcode\".\n\nПример 2:\nВход: s = \"abBAcC\"\nИзход: \"\"\nОбяснение: Има множество възможни решения, като например:\n- Премахнете \"bB\", за да направите \"aAcC\", след това премахнете \"cC\", за да направите \"aA\", след това премахнете \"aA\", за да направите \"\".\n- Премахнете \"aA\", за да направите \"abBAcC\", след това премахнете \"bB\", за да направите \"aAcC\", след това премахнете \"cC\", за да направите \"aA\",\nслед това премахнете \"aA\", за да направите \"\".\nНезависимо от избора, резултатът е празен низ.\n\nПример 3:\nВход: s = \"s\"\nИзход: \"s\"\nОбяснение: Низът вече е \"добър\".",
      "zh": "给定一个由小写和大写英文字母组成的字符串 s，你需要使字符串变得“良好”。 如果不存在相邻字符使得一个是小写字母而另一个是对应的大写字母，则认为字符串是“良好”的。 你可以选择字符串中的任何相邻字符并将其删除，直到字符串变得“良好”。 返回最终的“良好”字符串。\n\n示例 1:\n输入: s = \"leEeetcode\"\n输出: \"leetcode\"\n解释: 你可以移除 \"Ee\" 使其变为 \"leetcode\"。\n\n示例 2:\n输入: s = \"abBAcC\"\n输出: \"\"\n解释: 有多种可能的解决方案，例如：\n- 移除 \"bB\" 使其变为 \"aAcC\"，然后移除 \"cC\" 使其变为 \"aA\"，然后移除 \"aA\" 使其变为 \"\"。\n- 移除 \"aA\" 使其变为 \"abBAcC\"，然后移除 \"bB\" 使其变为 \"aAcC\"，然后移除 \"cC\" 使其变为 \"aA\"，然后移除 \"aA\" 使其变为 \"\"。\n无论选择如何，结果都是一个空字符串。\n\n示例 3:\n输入: s = \"s\"\n输出: \"s\"\n解释: 字符串已经是“良好”的。",
      "fr": "Étant donné une chaîne de caractères s composée de lettres anglaises majuscules et minuscules, vous devez rendre la chaîne \"bonne\". Une chaîne est considérée comme \"bonne\" s'il n'y a pas de caractères adjacents tels que l'un soit une lettre minuscule et l'autre la lettre majuscule correspondante. Vous pouvez choisir n'importe quels caractères adjacents dans la chaîne et les supprimer jusqu'à ce que la chaîne soit \"bonne\". Retournez la chaîne \"bonne\" finale.\n\nExemple 1 :\nEntrée : s = \"leEeetcode\"\nSortie : \"leetcode\"\nExplication : Vous pouvez supprimer \"Ee\" pour obtenir \"leetcode\".\n\nExemple 2 :\nEntrée : s = \"abBAcC\"\nSortie : \"\"\nExplication : Il existe plusieurs solutions possibles, telles que :\n- Supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\", puis supprimer \"aA\" pour obtenir \"\".\n- Supprimer \"aA\" pour obtenir \"abBAcC\", puis supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\", puis supprimer \"aA\" pour obtenir \"\".\nPeu importe les choix, le résultat est une chaîne vide.\n\nExemple 3 :\nEntrée : s = \"s\"\nSortie : \"s\"\nExplication : La chaîne est déjà \"bonne\".",
      "de": "Gegeben ist ein String s, der aus kleinen und großen englischen Buchstaben besteht. Sie müssen den String \"gut\" machen. Ein String wird als \"gut\" betrachtet, wenn es keine benachbarten Zeichen gibt, bei denen eines ein Kleinbuchstabe und das andere der entsprechende Großbuchstabe ist. Sie können beliebige benachbarte Zeichen im String auswählen und entfernen, bis der String \"gut\" ist. Geben Sie den endgültigen \"guten\" String zurück.\n\nBeispiel 1:\nEingabe: s = \"leEeetcode\"\nAusgabe: \"leetcode\"\nErklärung: Sie können \"Ee\" entfernen, um \"leetcode\" zu erhalten.\n\nBeispiel 2:\nEingabe: s = \"abBAcC\"\nAusgabe: \"\"\nErklärung: Es gibt mehrere mögliche Lösungen, wie zum Beispiel:\n- Entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten, dann entfernen Sie \"aA\", um \"\" zu erhalten.\n- Entfernen Sie \"aA\", um \"abBAcC\" zu erhalten, dann entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten, dann entfernen Sie \"aA\", um \"\" zu erhalten.\nUnabhängig von den Entscheidungen ist das Ergebnis ein leerer String.\n\nBeispiel 3:\nEingabe: s = \"s\"\nAusgabe: \"s\"\nErklärung: Der String ist bereits \"gut\".",
      "ha": "An ba da wata igiyar rubutu `s` da ta ƙunshi ƙananan da manyan haruffan Ingilishi,\nkana buƙatar ka sa igiyar rubutun ta zama \"mai kyau\".\nAna ɗaukar igiyar rubutu a matsayin \"mai kyau\" idan babu haruffa masu makwabtaka da suke da\nɗaya ƙaramin harafi ne ɗayan kuma babban harafi ne na wannan harafin.\nZa ka iya zaɓar kowane haruffa masu makwabtaka a cikin igiyar rubutun ka cire su har sai igiyar rubutun ta zama \"mai kyau\".\nMayar da igiyar rubutun \"mai kyau\" ta ƙarshe.\n\nMisali 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nBayani: Za ka iya cire \"Ee\" don ka sa \"leetcode\".\n\nMisali 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nBayani: Akwai hanyoyi da dama masu yiwuwa, kamar:\n- Cire \"bB\" don ka sa \"aAcC\", sannan cire \"cC\" don ka sa \"aA\", sannan cire \"aA\" don ka sa \"\".\n- Cire \"aA\" don ka sa \"abBAcC\", sannan cire \"bB\" don ka sa \"aAcC\", sannan cire \"cC\" don ka sa \"aA\",\nsannan cire \"aA\" don ka sa \"\".\nDuk da zaɓin, sakamakon zai kasance igiyar rubutu mai komai.\n\nMisali 3:\nInput: s = \"s\"\nOutput: \"s\"\nBayani: Igiyar rubutun ta riga ta zama \"mai kyau\".",
      "hi": "दी गई एक स्ट्रिंग s जिसमें छोटे और बड़े अंग्रेजी अक्षर शामिल हैं, आपको स्ट्रिंग को \"अच्छा\" बनाना है। एक स्ट्रिंग को \"अच्छा\" माना जाता है यदि उसमें कोई भी ऐसे आसन्न अक्षर नहीं हैं जिनमें से एक छोटा अक्षर है और दूसरा संबंधित बड़ा अक्षर है। आप स्ट्रिंग में किसी भी आसन्न अक्षरों को चुन सकते हैं और उन्हें हटा सकते हैं जब तक कि स्ट्रिंग \"अच्छा\" न हो जाए। अंतिम \"अच्छा\" स्ट्रिंग लौटाएं।\n\nउदाहरण 1:\nइनपुट: s = \"leEeetcode\"\nआउटपुट: \"leetcode\"\nव्याख्या: आप \"Ee\" को हटा सकते हैं ताकि \"leetcode\" बन जाए।\n\nउदाहरण 2:\nइनपुट: s = \"abBAcC\"\nआउटपुट: \"\"\nव्याख्या: कई संभावित समाधान हैं, जैसे:\n- \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं, फिर \"aA\" को हटाकर \"\" बनाएं।\n- \"aA\" को हटाकर \"abBAcC\" बनाएं, फिर \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं,\nफिर \"aA\" को हटाकर \"\" बनाएं।\nचाहे जो भी विकल्प चुने जाएं, परिणाम एक खाली स्ट्रिंग है।\n\nउदाहरण 3:\nइनपुट: s = \"s\"\nआउटपुट: \"s\"\nव्याख्या: स्ट्रिंग पहले से ही \"अच्छा\" है।",
      "hu": "Adott egy s string, amely kis- és nagybetűs angol betűkből áll, meg kell tenni a stringet \"jóvá\". Egy string akkor tekinthető \"jónak\", ha nincsenek szomszédos karakterek, amelyek közül az egyik kisbetű, a másik pedig a megfelelő nagybetű. Kiválaszthat bármilyen szomszédos karaktert a stringben, és eltávolíthatja őket, amíg a string \"jó\" nem lesz. Adja vissza a végső \"jó\" stringet.\n\nPélda 1:\nBemenet: s = \"leEeetcode\"\nKimenet: \"leetcode\"\nMagyarázat: Eltávolíthatja az \"Ee\"-t, hogy \"leetcode\"-t kapjon.\n\nPélda 2:\nBemenet: s = \"abBAcC\"\nKimenet: \"\"\nMagyarázat: Több lehetséges megoldás is van, például:\n- Eltávolítja a \"bB\"-t, hogy \"aAcC\"-t kapjon, majd eltávolítja a \"cC\"-t, hogy \"aA\"-t kapjon, majd eltávolítja az \"aA\"-t, hogy \"\"-t kapjon.\n- Eltávolítja az \"aA\"-t, hogy \"abBAcC\"-t kapjon, majd eltávolítja a \"bB\"-t, hogy \"aAcC\"-t kapjon, majd eltávolítja a \"cC\"-t, hogy \"aA\"-t kapjon, majd eltávolítja az \"aA\"-t, hogy \"\"-t kapjon.\nBármilyen választás esetén az eredmény egy üres string.\n\nPélda 3:\nBemenet: s = \"s\"\nKimenet: \"s\"\nMagyarázat: A string már \"jó\"."
    },
    "docstring_bertscore": {
      "sq": "0.9962162898716664",
      "hy": "0.9632730439162681",
      "bn": "0.9695110310326688",
      "bg": "0.9879647865827151",
      "zh": "0.9742058587188094",
      "fr": "0.9734262344732475",
      "de": "0.972689117129227",
      "ha": "0.957072597941883",
      "hi": "0.9849628856341348",
      "hu": "0.9644423809694205"
    }
  },
  {
    "task_id": "Java/31",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   */\n  public int maxUniqueSplit(String s) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Duke pasur një varg s, ndani vargun dhe ktheni numrin maksimal të nënvargjeve unike.\n   * Nënvargjet e ndara duhet të jenë në gjendje të rindërtojnë vargun origjinal, dhe çdo nënvargje duhet të jetë unik.\n   *\n   * Shembull:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Shpjegim: Një mënyrë e mundshme për të ndarë vargun është ['a', 'b', 'ab', 'c', 'cc'].\n   *            Ndarja e vargut si ['a', 'b', 'a', 'b', 'c', 'cc'] nuk është e vlefshme, sepse si 'a' ashtu edhe 'b' shfaqen më shumë se një herë.\n   *\n   * Shënim:\n   * - Gjatësia e s është midis 1 dhe 16.\n   * - s përmban vetëm shkronja të vogla angleze.\n   */\n  public int maxUniqueSplit(String s) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Տրված է s տողը, բաժանեք տողը և վերադարձեք առավելագույն քանակությամբ եզակի ենթատողեր:\n   * Բաժանված ենթատողերը պետք է կարողանան վերակառուցել սկզբնական տողը, և յուրաքանչյուր ենթատող պետք է լինի եզակի:\n   *\n   * Օրինակ:\n   * Մուտք: s = \"ababccc\"\n   * Ելք: 5\n   * Բացատրություն: Տողը բաժանելու հնարավոր տարբերակներից մեկն է ['a', 'b', 'ab', 'c', 'cc']:\n   *              Տողը ['a', 'b', 'a', 'b', 'c', 'cc'] ձևով բաժանելը անվավեր է, քանի որ 'a' և 'b' երկուսն էլ հայտնվում են մեկից ավելի անգամ:\n   *\n   * Նշում:\n   * - s-ի երկարությունը 1-ից 16 է:\n   * - s-ը պարունակում է միայն փոքրատառ անգլերեն տառեր:\n   */\n  public int maxUniqueSplit(String s) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * একটি স্ট্রিং s দেওয়া আছে, স্ট্রিংটি ভাগ করুন এবং সর্বাধিক সংখ্যক অনন্য সাবস্ট্রিং ফেরত দিন।\n   * বিভক্ত সাবস্ট্রিংগুলি মূল স্ট্রিংটি পুনর্গঠন করতে সক্ষম হওয়া উচিত, এবং প্রতিটি সাবস্ট্রিং অনন্য হতে হবে।\n   *\n   * উদাহরণ:\n   * ইনপুট: s = \"ababccc\"\n   * আউটপুট: 5\n   * ব্যাখ্যা: স্ট্রিংটি ভাগ করার একটি সম্ভাব্য উপায় হল ['a', 'b', 'ab', 'c', 'cc']।\n   *              স্ট্রিংটি ['a', 'b', 'a', 'b', 'c', 'cc'] হিসাবে ভাগ করা বৈধ নয়, কারণ 'a' এবং 'b' উভয়ই একাধিকবার উপস্থিত হয়।\n   *\n   * নোট:\n   * - s এর দৈর্ঘ্য 1 এবং 16 এর মধ্যে।\n   * - s শুধুমাত্র ছোট হাতের ইংরেজি অক্ষর ধারণ করে।\n   */\n  public int maxUniqueSplit(String s) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Даден е низ s, разделете низа и върнете максималния брой уникални поднизове.\n   * Разделените поднизове трябва да могат да възстановят оригиналния низ, и всеки подниз трябва да е уникален.\n   *\n   * Пример:\n   * Вход: s = \"ababccc\"\n   * Изход: 5\n   * Обяснение: Един възможен начин за разделяне на низа е ['a', 'b', 'ab', 'c', 'cc'].\n   *             Разделянето на низа като ['a', 'b', 'a', 'b', 'c', 'cc'] не е валидно, защото както 'a', така и 'b' се появяват повече от веднъж.\n   *\n   * Забележка:\n   * - Дължината на s е между 1 и 16.\n   * - s съдържа само малки английски букви.\n   */\n  public int maxUniqueSplit(String s) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * 给定一个字符串 s，拆分字符串并返回最大数量的唯一子字符串。\n   * 拆分的子字符串应能够重构原始字符串，并且每个子字符串必须是唯一的。\n   *\n   * 示例：\n   * 输入: s = \"ababccc\"\n   * 输出: 5\n   * 解释: 一种可能的拆分方式是 ['a', 'b', 'ab', 'c', 'cc']。\n   *              将字符串拆分为 ['a', 'b', 'a', 'b', 'c', 'cc'] 是无效的，因为 'a' 和 'b' 都出现了多次。\n   *\n   * 注意：\n   * - s 的长度在 1 到 16 之间。\n   * - s 只包含小写英文字母。\n   */\n  public int maxUniqueSplit(String s) ",
      "fr": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Étant donné une chaîne s, divisez la chaîne et retournez le nombre maximum de sous-chaînes uniques.\n   * Les sous-chaînes divisées doivent pouvoir reconstruire la chaîne originale, et chaque sous-chaîne doit être unique.\n   *\n   * Exemple:\n   * Entrée: s = \"ababccc\"\n   * Sortie: 5\n   * Explication: Une façon possible de diviser la chaîne est ['a', 'b', 'ab', 'c', 'cc'].\n   *              Diviser la chaîne comme ['a', 'b', 'a', 'b', 'c', 'cc'] n'est pas valide, car 'a' et 'b' apparaissent plus d'une fois.\n   *\n   * Remarque:\n   * - La longueur de s est comprise entre 1 et 16.\n   * - s ne contient que des lettres minuscules anglaises.\n   */\n  public int maxUniqueSplit(String s) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Gegeben ein String s, teile den String und gib die maximale Anzahl einzigartiger Substrings zurück.\n   * Die geteilten Substrings sollten in der Lage sein, den ursprünglichen String zu rekonstruieren, und jedes Substring muss einzigartig sein.\n   *\n   * Beispiel:\n   * Eingabe: s = \"ababccc\"\n   * Ausgabe: 5\n   * Erklärung: Eine mögliche Möglichkeit, den String zu teilen, ist ['a', 'b', 'ab', 'c', 'cc'].\n   *             Das Teilen des Strings als ['a', 'b', 'a', 'b', 'c', 'cc'] ist nicht gültig, da sowohl 'a' als auch 'b' mehr als einmal vorkommen.\n   *\n   * Hinweis:\n   * - Die Länge von s liegt zwischen 1 und 16.\n   * - s enthält nur kleine englische Buchstaben.\n   */\n  public int maxUniqueSplit(String s) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * An ba da wata igiya s, a raba igiyar kuma a dawo da yawan mafi girman igiyoyi na musamman.\n   * Ya kamata a iya sake gina igiyar asali daga igiyoyin da aka raba, kuma kowace igiya dole ne ta kasance ta musamman.\n   *\n   * Misali:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Bayani: Wata hanya mai yiwuwa don raba igiyar ita ce ['a', 'b', 'ab', 'c', 'cc'].\n   *              Raba igiyar kamar ['a', 'b', 'a', 'b', 'c', 'cc'] ba ta dace ba, domin duka 'a' da 'b' sun bayyana fiye da sau daya.\n   *\n   * Lura:\n   * - Tsawon s yana tsakanin 1 da 16.\n   * - s yana dauke da ƙananan haruffan Ingilishi kawai.\n   */\n  public int maxUniqueSplit(String s) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * दिए गए स्ट्रिंग s को विभाजित करें और अद्वितीय उपस्ट्रिंग्स की अधिकतम संख्या लौटाएं।\n   * विभाजित उपस्ट्रिंग्स को मूल स्ट्रिंग को पुनर्निर्मित करने में सक्षम होना चाहिए, और प्रत्येक उपस्ट्रिंग अद्वितीय होनी चाहिए।\n   *\n   * उदाहरण:\n   * इनपुट: s = \"ababccc\"\n   * आउटपुट: 5\n   * व्याख्या: स्ट्रिंग को विभाजित करने का एक संभावित तरीका ['a', 'b', 'ab', 'c', 'cc'] है।\n   *              स्ट्रिंग को ['a', 'b', 'a', 'b', 'c', 'cc'] के रूप में विभाजित करना मान्य नहीं है, क्योंकि 'a' और 'b' दोनों एक से अधिक बार प्रकट होते हैं।\n   *\n   * नोट:\n   * - s की लंबाई 1 और 16 के बीच है।\n   * - s में केवल छोटे अंग्रेजी अक्षर होते हैं।\n   */\n  public int maxUniqueSplit(String s) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Adott egy s karakterlánc, ossza fel a karakterláncot, és adja vissza az egyedi részkarakterláncok maximális számát.\n   * A felosztott részkarakterláncoknak képesnek kell lenniük az eredeti karakterlánc rekonstruálására, és minden részkarakterláncnak egyedinek kell lennie.\n   *\n   * Példa:\n   * Bemenet: s = \"ababccc\"\n   * Kimenet: 5\n   * Magyarázat: Az egyik lehetséges módja a karakterlánc felosztásának: ['a', 'b', 'ab', 'c', 'cc'].\n   *              A karakterlánc ['a', 'b', 'a', 'b', 'c', 'cc'] formában történő felosztása nem érvényes, mert mind az 'a', mind a 'b' többször is megjelenik.\n   *\n   * Megjegyzés:\n   * - Az s hossza 1 és 16 között van.\n   * - s csak kisbetűs angol betűket tartalmaz.\n   */\n  public int maxUniqueSplit(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9994088759860402",
      "hy": "0.9917085720044606",
      "bn": "0.9963126256064684",
      "bg": "0.993600526383818",
      "zh": "0.9834459454141714",
      "fr": "0.9951454734875074",
      "de": "0.9986383887380058",
      "ha": "0.9843731520328423",
      "hi": "0.984195775102578",
      "hu": "0.9924236413761862"
    },
    "canonical_solution": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n",
    "instruction": {
      "en": "Write a Java function `public int maxUniqueSplit(String s)` to solve the following problem:\nGiven a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.",
      "sq": "Shkruani një funksion Java `public int maxUniqueSplit(String s)` për të zgjidhur problemin në vijim:\nDuke pasur një varg s, ndani vargun dhe ktheni numrin maksimal të nënvargjeve unike.\nNënvargjet e ndara duhet të jenë në gjendje të rindërtojnë vargun origjinal, dhe secili nënvarg duhet të jetë unik.\n\nShembull:\nInput: s = \"ababccc\"\nOutput: 5\nShpjegim: Një mënyrë e mundshme për të ndarë vargun është ['a', 'b', 'ab', 'c', 'cc'].\nNdarja e vargut si ['a', 'b', 'a', 'b', 'c', 'cc'] nuk është e vlefshme, sepse si 'a' ashtu edhe 'b' shfaqen më shumë se një herë.\n\nShënim:\n- Gjatësia e s është midis 1 dhe 16.\n- s përmban vetëm shkronja të vogla të anglishtes.",
      "hy": "Գրեք Java ֆունկցիա `public int maxUniqueSplit(String s)` հետևյալ խնդիրը լուծելու համար:\nՏրված է s տողը, բաժանեք տողը և վերադարձեք առավելագույն քանակով եզակի ենթատողեր:\nԲաժանված ենթատողերը պետք է կարողանան վերականգնել սկզբնական տողը, և յուրաքանչյուր ենթատող պետք է լինի եզակի:\n\nՕրինակ:\nՄուտք: s = \"ababccc\"\nԵլք: 5\nԲացատրություն: Տողը բաժանելու հնարավոր եղանակներից մեկն է ['a', 'b', 'ab', 'c', 'cc']:\nՏողը ['a', 'b', 'a', 'b', 'c', 'cc'] ձևով բաժանելը վավեր չէ, քանի որ 'a' և 'b' երկուսն էլ հայտնվում են մեկից ավելի անգամ:\n\nՆշում:\n- s-ի երկարությունը 1-ից 16 է:\n- s-ն պարունակում է միայն փոքրատառ անգլերեն տառեր:",
      "bn": "একটি জাভা ফাংশন `public int maxUniqueSplit(String s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিং s দেওয়া আছে, স্ট্রিংটি বিভক্ত করুন এবং সর্বাধিক সংখ্যক অনন্য উপ-স্ট্রিং ফেরত দিন।\nবিভক্ত উপ-স্ট্রিংগুলি মূল স্ট্রিংটি পুনর্গঠন করতে সক্ষম হওয়া উচিত, এবং প্রতিটি উপ-স্ট্রিং অনন্য হতে হবে।\n\nউদাহরণ:\nইনপুট: s = \"ababccc\"\nআউটপুট: 5\nব্যাখ্যা: স্ট্রিংটি বিভক্ত করার একটি সম্ভাব্য উপায় হল ['a', 'b', 'ab', 'c', 'cc']।\nস্ট্রিংটি ['a', 'b', 'a', 'b', 'c', 'cc'] হিসাবে বিভক্ত করা বৈধ নয়, কারণ 'a' এবং 'b' উভয়ই একাধিকবার উপস্থিত হয়েছে।\n\nনোট:\n- s এর দৈর্ঘ্য 1 এবং 16 এর মধ্যে।\n- s শুধুমাত্র ছোট হাতের ইংরেজি অক্ষর ধারণ করে।",
      "bg": "Напишете Java функция `public int maxUniqueSplit(String s)`, за да решите следния проблем:  \nДаден е низ s, разделете низа и върнете максималния брой уникални поднизове.  \nРазделените поднизове трябва да могат да възстановят оригиналния низ, и всеки подниз трябва да бъде уникален.\n\nПример:  \nВход: s = \"ababccc\"  \nИзход: 5  \nОбяснение: Един възможен начин за разделяне на низа е ['a', 'b', 'ab', 'c', 'cc'].  \nРазделянето на низа като ['a', 'b', 'a', 'b', 'c', 'cc'] не е валидно, защото както 'a', така и 'b' се появяват повече от веднъж.\n\nЗабележка:  \n- Дължината на s е между 1 и 16.  \n- s съдържа само малки английски букви.",
      "zh": "编写一个 Java 函数 `public int maxUniqueSplit(String s)` 来解决以下问题：\n给定一个字符串 s，拆分字符串并返回最大数量的唯一子字符串。\n拆分后的子字符串应能够重构原始字符串，并且每个子字符串必须是唯一的。\n\n示例：\n输入: s = \"ababccc\"\n输出: 5\n解释: 一种可能的拆分方式是 ['a', 'b', 'ab', 'c', 'cc']。\n将字符串拆分为 ['a', 'b', 'a', 'b', 'c', 'cc'] 是无效的，因为 'a' 和 'b' 都出现了多次。\n\n注意：\n- s 的长度在 1 到 16 之间。\n- s 只包含小写英文字母。",
      "fr": "Écrivez une fonction Java `public int maxUniqueSplit(String s)` pour résoudre le problème suivant :  \nÉtant donné une chaîne s, divisez la chaîne et retournez le nombre maximum de sous-chaînes uniques.  \nLes sous-chaînes divisées doivent pouvoir reconstruire la chaîne originale, et chaque sous-chaîne doit être unique.\n\nExemple :  \nEntrée : s = \"ababccc\"  \nSortie : 5  \nExplication : Une façon possible de diviser la chaîne est ['a', 'b', 'ab', 'c', 'cc'].  \nDiviser la chaîne comme ['a', 'b', 'a', 'b', 'c', 'cc'] n'est pas valide, car 'a' et 'b' apparaissent plus d'une fois.\n\nRemarque :  \n- La longueur de s est comprise entre 1 et 16.  \n- s ne contient que des lettres minuscules anglaises.",
      "de": "Schreiben Sie eine Java-Funktion `public int maxUniqueSplit(String s)`, um das folgende Problem zu lösen:\nGegeben ist ein String s, teilen Sie den String und geben Sie die maximale Anzahl eindeutiger Substrings zurück.\nDie geteilten Substrings sollten in der Lage sein, den ursprünglichen String zu rekonstruieren, und jeder Substring muss einzigartig sein.\n\nBeispiel:\nEingabe: s = \"ababccc\"\nAusgabe: 5\nErläuterung: Eine mögliche Möglichkeit, den String zu teilen, ist ['a', 'b', 'ab', 'c', 'cc'].\nDas Teilen des Strings als ['a', 'b', 'a', 'b', 'c', 'cc'] ist nicht gültig, da sowohl 'a' als auch 'b' mehr als einmal vorkommen.\n\nHinweis:\n- Die Länge von s liegt zwischen 1 und 16.\n- s enthält nur kleine englische Buchstaben.",
      "ha": "Rubuta aikin Java `public int maxUniqueSplit(String s)` don warware matsalar mai zuwa:  \nAn ba da igiyar s, raba igiyar kuma dawo da yawan adadin kwayoyin igiyoyi na musamman.  \nYa kamata a iya sake gina igiyar asali daga kwayoyin igiyoyin da aka raba, kuma kowanne kwayar igiya dole ne ya zama na musamman.\n\nMisali:  \nShigar: s = \"ababccc\"  \nFitarwa: 5  \nBayani: Wani yuwuwar hanya don raba igiyar shine ['a', 'b', 'ab', 'c', 'cc'].  \nRaba igiyar kamar ['a', 'b', 'a', 'b', 'c', 'cc'] ba daidai bane, domin 'a' da 'b' sun bayyana fiye da sau daya.\n\nLura:  \n- Tsawon s yana tsakanin 1 da 16.  \n- s yana dauke da kananan haruffan Ingilishi kawai.",
      "hi": "Java फ़ंक्शन `public int maxUniqueSplit(String s)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए स्ट्रिंग s को विभाजित करें और अद्वितीय उपस्ट्रिंग्स की अधिकतम संख्या लौटाएं।\nविभाजित उपस्ट्रिंग्स को मूल स्ट्रिंग को पुनर्निर्मित करने में सक्षम होना चाहिए, और प्रत्येक उपस्ट्रिंग अद्वितीय होनी चाहिए।\n\nउदाहरण:\nइनपुट: s = \"ababccc\"\nआउटपुट: 5\nव्याख्या: स्ट्रिंग को विभाजित करने का एक संभव तरीका है ['a', 'b', 'ab', 'c', 'cc']।\nस्ट्रिंग को ['a', 'b', 'a', 'b', 'c', 'cc'] के रूप में विभाजित करना मान्य नहीं है, क्योंकि 'a' और 'b' दोनों एक से अधिक बार प्रकट होते हैं।\n\nनोट:\n- s की लंबाई 1 और 16 के बीच है।\n- s केवल छोटे अक्षरों वाले अंग्रेजी अक्षरों को शामिल करता है।",
      "hu": "Írj egy Java függvényt `public int maxUniqueSplit(String s)` a következő probléma megoldására:\nAdott egy s string, oszd fel a stringet, és add vissza az egyedi részstringek maximális számát.\nA felosztott részstringeknek képesnek kell lenniük az eredeti string rekonstruálására, és minden részstringnek egyedinek kell lennie.\n\nPélda:\nBemenet: s = \"ababccc\"\nKimenet: 5\nMagyarázat: Az egyik lehetséges módja a string felosztásának ['a', 'b', 'ab', 'c', 'cc'].\nA string felosztása ['a', 'b', 'a', 'b', 'c', 'cc'] nem érvényes, mert mind az 'a', mind a 'b' többször jelenik meg.\n\nMegjegyzés:\n- Az s hossza 1 és 16 között van.\n- s csak kisbetűs angol betűket tartalmaz."
    },
    "instruction_bertscore": {
      "sq": "0.9988334437721821",
      "hy": "0.9890383837922087",
      "bn": "0.9968368111820194",
      "bg": "0.996555153301712",
      "zh": "0.984513980972996",
      "fr": "0.9945591166026924",
      "de": "0.9977487232613506",
      "ha": "0.9731578848284693",
      "hi": "0.9835327468906836",
      "hu": "0.9839671515340069"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "maxUniqueSplit",
    "signature": "public int maxUniqueSplit(String s)",
    "docstring": {
      "en": "Given a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.",
      "sq": "Duke pasur një varg s, ndajeni vargun dhe ktheni numrin maksimal të nënvargjeve unike. Nënvargjet e ndara duhet të jenë në gjendje të rindërtojnë vargun origjinal, dhe secili nënvarg duhet të jetë unik.\n\nShembull:\nInput: s = \"ababccc\"\nOutput: 5\nShpjegim: Një mënyrë e mundshme për të ndarë vargun është ['a', 'b', 'ab', 'c', 'cc'].\nNdarja e vargut si ['a', 'b', 'a', 'b', 'c', 'cc'] nuk është e vlefshme, sepse si 'a' ashtu edhe 'b' shfaqen më shumë se një herë.\n\nShënim:\n- Gjatësia e s është midis 1 dhe 16.\n- s përmban vetëm shkronja të vogla të anglishtes.",
      "hy": "Տրված է տող s, բաժանեք տողը և վերադարձեք եզակի ենթատողերի առավելագույն քանակը։ Բաժանված ենթատողերը պետք է կարողանան վերականգնել սկզբնական տողը, և յուրաքանչյուր ենթատող պետք է լինի եզակի։\n\nՕրինակ:\nՄուտք: s = \"ababccc\"\nԵլք: 5\nԲացատրություն: Տողը բաժանելու հնարավոր տարբերակներից մեկը ['a', 'b', 'ab', 'c', 'cc'] է։\nՏողը ['a', 'b', 'a', 'b', 'c', 'cc'] ձևով բաժանելը վավեր չէ, քանի որ 'a' և 'b' երկուսն էլ հայտնվում են մեկից ավելի անգամ։\n\nՆշում:\n- s-ի երկարությունը 1-ից 16 է։\n- s-ն պարունակում է միայն փոքրատառ անգլերեն տառեր։",
      "bn": "একটি স্ট্রিং s দেওয়া হয়েছে, স্ট্রিংটি ভাগ করুন এবং সর্বাধিক সংখ্যক অনন্য সাবস্ট্রিং ফেরত দিন। \n\nভাগ করা সাবস্ট্রিংগুলি মূল স্ট্রিংটি পুনর্গঠন করতে সক্ষম হওয়া উচিত, এবং প্রতিটি সাবস্ট্রিং অনন্য হতে হবে।\n\nউদাহরণ:\nইনপুট: s = \"ababccc\"\nআউটপুট: 5\nব্যাখ্যা: স্ট্রিংটি ভাগ করার একটি সম্ভাব্য উপায় হল ['a', 'b', 'ab', 'c', 'cc']।\nস্ট্রিংটি ['a', 'b', 'a', 'b', 'c', 'cc'] হিসাবে ভাগ করা বৈধ নয়, কারণ 'a' এবং 'b' উভয়ই একাধিকবার উপস্থিত হয়েছে।\n\nনোট:\n- s এর দৈর্ঘ্য 1 এবং 16 এর মধ্যে।\n- s শুধুমাত্র ছোট হাতের ইংরেজি অক্ষর ধারণ করে।",
      "bg": "Даден е низ s, разделете низа и върнете максималния брой уникални поднизове. Разделените поднизове трябва да могат да реконструират оригиналния низ, и всеки подниз трябва да е уникален.\n\nПример:\nВход: s = \"ababccc\"\nИзход: 5\nОбяснение: Един възможен начин за разделяне на низа е ['a', 'b', 'ab', 'c', 'cc'].\nРазделянето на низа като ['a', 'b', 'a', 'b', 'c', 'cc'] не е валидно, защото както 'a', така и 'b' се появяват повече от веднъж.\n\nЗабележка:\n- Дължината на s е между 1 и 16.\n- s съдържа само малки букви от английската азбука.",
      "zh": "给定一个字符串 s，拆分字符串并返回最大数量的唯一子字符串。\n拆分后的子字符串应该能够重构原始字符串，并且每个子字符串必须是唯一的。\n\n示例:\n输入: s = \"ababccc\"\n输出: 5\n解释: 一种可能的拆分方式是 ['a', 'b', 'ab', 'c', 'cc']。\n将字符串拆分为 ['a', 'b', 'a', 'b', 'c', 'cc'] 是无效的，因为 'a' 和 'b' 都出现了多次。\n\n注意:\n- s 的长度在 1 到 16 之间。\n- s 只包含小写英文字母。",
      "fr": "Étant donné une chaîne de caractères s, divisez la chaîne et renvoyez le nombre maximum de sous-chaînes uniques. Les sous-chaînes divisées doivent pouvoir reconstruire la chaîne originale, et chaque sous-chaîne doit être unique.\n\nExemple :\nEntrée : s = \"ababccc\"\nSortie : 5\nExplication : Une façon possible de diviser la chaîne est ['a', 'b', 'ab', 'c', 'cc'].\nDiviser la chaîne comme ['a', 'b', 'a', 'b', 'c', 'cc'] n'est pas valide, car 'a' et 'b' apparaissent tous deux plus d'une fois.\n\nRemarque :\n- La longueur de s est comprise entre 1 et 16.\n- s ne contient que des lettres minuscules anglaises.",
      "de": "Gegeben ein String s, teile den String und gib die maximale Anzahl einzigartiger Substrings zurück.\nDie geteilten Substrings sollten in der Lage sein, den ursprünglichen String zu rekonstruieren, und jedes Substring muss einzigartig sein.\n\nBeispiel:\nEingabe: s = \"ababccc\"\nAusgabe: 5\nErklärung: Eine mögliche Möglichkeit, den String zu teilen, ist ['a', 'b', 'ab', 'c', 'cc'].\nDas Teilen des Strings als ['a', 'b', 'a', 'b', 'c', 'cc'] ist nicht gültig, da sowohl 'a' als auch 'b' mehr als einmal vorkommen.\n\nHinweis:\n- Die Länge von s liegt zwischen 1 und 16.\n- s enthält nur kleine englische Buchstaben.",
      "ha": "An ba da wani kirtani s, a raba kirtanin kuma a mayar da mafi yawan adadin kirtan-kirtan na musamman.\nKirtan-kirtan da aka raba ya kamata su iya sake gina kirtani na asali, kuma kowanne kirtani dole ne ya zama na musamman.\n\nMisali:\nShigar: s = \"ababccc\"\nFitarwa: 5\nBayani: Wata hanya mai yiwuwa don raba kirtanin ita ce ['a', 'b', 'ab', 'c', 'cc'].\nRaba kirtanin kamar ['a', 'b', 'a', 'b', 'c', 'cc'] ba daidai ba ne, domin duka 'a' da 'b' sun bayyana fiye da sau daya.\n\nLura:\n- Tsawon s yana tsakanin 1 da 16.\n- s yana dauke da kananan haruffan Ingilishi kawai.",
      "hi": "दिए गए स्ट्रिंग s के लिए, स्ट्रिंग को विभाजित करें और अद्वितीय उपस्ट्रिंग्स की अधिकतम संख्या लौटाएं। विभाजित उपस्ट्रिंग्स को मूल स्ट्रिंग को पुनर्निर्माण करने में सक्षम होना चाहिए, और प्रत्येक उपस्ट्रिंग अद्वितीय होनी चाहिए।\n\nउदाहरण:\nइनपुट: s = \"ababccc\"\nआउटपुट: 5\nव्याख्या: स्ट्रिंग को विभाजित करने का एक संभावित तरीका ['a', 'b', 'ab', 'c', 'cc'] है।\nस्ट्रिंग को ['a', 'b', 'a', 'b', 'c', 'cc'] के रूप में विभाजित करना मान्य नहीं है, क्योंकि 'a' और 'b' दोनों एक से अधिक बार प्रकट होते हैं।\n\nनोट:\n- s की लंबाई 1 और 16 के बीच है।\n- s में केवल छोटे अक्षरों वाले अंग्रेजी अक्षर होते हैं।",
      "hu": "Adott egy s string, oszd fel a stringet, és add vissza az egyedi részstringek maximális számát.  \nA felosztott részstringeknek képesnek kell lenniük az eredeti string rekonstruálására, és minden részstringnek egyedinek kell lennie.\n\nPélda:  \nBemenet: s = \"ababccc\"  \nKimenet: 5  \nMagyarázat: A string egyik lehetséges felosztása ['a', 'b', 'ab', 'c', 'cc'].  \nA string ['a', 'b', 'a', 'b', 'c', 'cc'] felosztása nem érvényes, mert az 'a' és 'b' is többször szerepel.\n\nMegjegyzés:  \n- Az s hossza 1 és 16 között van.  \n- s csak kisbetűs angol betűket tartalmaz."
    },
    "docstring_bertscore": {
      "sq": "0.9977743465805041",
      "hy": "0.9924002029912241",
      "bn": "0.9863296612860359",
      "bg": "0.9904925568117651",
      "zh": "0.9792979471670198",
      "fr": "0.9943267190568815",
      "de": "0.9973155104003135",
      "ha": "0.9923463741579637",
      "hi": "0.9950078226334501",
      "hu": "0.9733231453054904"
    }
  },
  {
    "task_id": "Java/32",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explanation: Perform the \"../\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një listë të regjistrave që përfaqësojnë operacionet e dosjeve,\n     * kthe numrin minimal të hapave të nevojshëm për t'u kthyer në dosjen kryesore.\n     *\n     * Shembull:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Shpjegim: Kryeni operacionin \"../\" dy herë për t'u kthyer në dosjen kryesore.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "hy": "class Solution {\n    /**\n     * Տրված է թղթապանակի գործողությունները ներկայացնող գրանցամատյանների ցուցակ,\n     * վերադարձնել հիմնական թղթապանակ վերադառնալու համար պահանջվող նվազագույն քայլերի թիվը:\n     *\n     * Օրինակ:\n     * Մուտք: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Ելք: 2\n     * Բացատրություն: Կատարեք \"../\" գործողությունը երկու անգամ՝ հիմնական թղթապանակ վերադառնալու համար:\n     *\n     * Մուտք: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Ելք: 3\n     *\n     * Մուտք: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Ելք: 0\n     */\n  public int minOperations(String[] logs) ",
      "bn": "class Solution {\n    /**\n     * ফোল্ডার অপারেশনগুলি উপস্থাপনকারী লগগুলির একটি তালিকা দেওয়া আছে,\n     * মূল ফোল্ডারে ফিরে আসতে প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা ফেরত দিন।\n     *\n     * উদাহরণ:\n     * ইনপুট: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * আউটপুট: 2\n     * ব্যাখ্যা: মূল ফোল্ডারে ফিরে আসতে \"../\" অপারেশনটি দুবার সম্পাদন করুন।\n     *\n     * ইনপুট: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * আউটপুট: 3\n     *\n     * ইনপুট: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * আউটপুট: 0\n     */\n  public int minOperations(String[] logs) ",
      "bg": "class Solution {\n    /**\n     * Даден е списък от дневници, представляващи операции с папки,\n     * върнете минималния брой стъпки, необходими за връщане в главната папка.\n     *\n     * Пример:\n     * Вход: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Изход: 2\n     * Обяснение: Изпълнете операцията \"../\" два пъти, за да се върнете в главната папка.\n     *\n     * Вход: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Изход: 3\n     *\n     * Вход: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Изход: 0\n     */\n  public int minOperations(String[] logs) ",
      "zh": "class Solution {\n    /**\n     * 给定一个表示文件夹操作的日志列表，\n     * 返回返回主文件夹所需的最小步骤数。\n     *\n     * 示例：\n     * 输入: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * 输出: 2\n     * 解释: 执行两次\"../\"操作以返回到主文件夹。\n     *\n     * 输入: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * 输出: 3\n     *\n     * 输入: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * 输出: 0\n     */\n  public int minOperations(String[] logs) ",
      "fr": "class Solution {\n    /**\n     * Étant donné une liste de logs représentant des opérations de dossier,\n     * renvoie le nombre minimum d'étapes nécessaires pour revenir au dossier principal.\n     *\n     * Exemple:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explication: Effectuez l'opération \"../\" deux fois pour revenir au dossier principal.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "de": "class Solution {\n    /**\n     * Gegeben eine Liste von Logs, die Ordneroperationen darstellen,\n     * gib die minimale Anzahl von Schritten zurück, die erforderlich sind, um zum Hauptordner zurückzukehren.\n     *\n     * Beispiel:\n     * Eingabe: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Ausgabe: 2\n     * Erklärung: Führe die \"../\"-Operation zweimal aus, um zum Hauptordner zurückzukehren.\n     *\n     * Eingabe: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Ausgabe: 3\n     *\n     * Eingabe: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Ausgabe: 0\n     */\n  public int minOperations(String[] logs) ",
      "ha": "class Solution {\n    /**\n     * An ba da jerin bayanan aiki na manyan fayiloli,\n     * mayar da adadin matakai mafi karanci da ake bukata don komawa babban babban fayil.\n     *\n     * Misali:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Bayani: Yi aikin \"../\" sau biyu don komawa babban babban fayil.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "hi": "class Solution {\n    /**\n     * दिए गए लॉग्स की सूची जो फ़ोल्डर संचालन का प्रतिनिधित्व करती है,\n     * मुख्य फ़ोल्डर पर वापस लौटने के लिए आवश्यक न्यूनतम चरणों की संख्या लौटाएं।\n     *\n     * उदाहरण:\n     * इनपुट: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * आउटपुट: 2\n     * व्याख्या: मुख्य फ़ोल्डर पर लौटने के लिए \"../\" संचालन को दो बार करें।\n     *\n     * इनपुट: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * आउटपुट: 3\n     *\n     * इनपुट: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * आउटपुट: 0\n     */\n  public int minOperations(String[] logs) ",
      "hu": "class Solution {\n    /**\n     * Adott egy naplólista, amely mappaműveleteket reprezentál,\n     * adja vissza a minimális lépések számát, amelyek szükségesek a fő mappához való visszatéréshez.\n     *\n     * Példa:\n     * Bemenet: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Kimenet: 2\n     * Magyarázat: Hajtsa végre a \"../\" műveletet kétszer a fő mappához való visszatéréshez.\n     *\n     * Bemenet: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Kimenet: 3\n     *\n     * Bemenet: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Kimenet: 0\n     */\n  public int minOperations(String[] logs) "
    },
    "prompt_bertscore": {
      "sq": "0.9963892969335478",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.999999801369619",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9745012220954083",
      "hi": "0.999999801369619",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }",
    "instruction": {
      "en": "Write a Java function `public int minOperations(String[] logs)` to solve the following problem:\nGiven a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "sq": "Shkruani një funksion Java `public int minOperations(String[] logs)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një listë të log-eve që përfaqësojnë operacionet e dosjeve,  \nktheni numrin minimal të hapave të nevojshëm për t'u kthyer në dosjen kryesore.\n\nShembull:  \nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]  \nOutput: 2  \nShpjegim: Kryeni operacionin \"../\" dy herë për t'u kthyer në dosjen kryesore.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]  \nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]  \nOutput: 0",
      "hy": "Գրեք Java ֆունկցիա `public int minOperations(String[] logs)` հետևյալ խնդիրը լուծելու համար:\nՏրված է թղթապանակների գործողությունները ներկայացնող լոգերի ցուցակը,\nվերադարձնել հիմնական թղթապանակ վերադառնալու համար անհրաժեշտ նվազագույն քայլերի քանակը:\n\nՕրինակ:\nՄուտք: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nԵլք: 2\nԲացատրություն: Կատարեք \"../\" գործողությունը երկու անգամ՝ հիմնական թղթապանակ վերադառնալու համար:\n\nՄուտք: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nԵլք: 3\n\nՄուտք: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nԵլք: 0",
      "bn": "একটি জাভা ফাংশন `public int minOperations(String[] logs)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nফোল্ডার অপারেশনগুলি উপস্থাপনকারী লগগুলির একটি তালিকা দেওয়া আছে,\nপ্রধান ফোল্ডারে ফিরে আসার জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপের সংখ্যা ফেরত দিন।\n\nউদাহরণ:\nইনপুট: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nআউটপুট: 2\nব্যাখ্যা: প্রধান ফোল্ডারে ফিরে আসতে \"../\" অপারেশনটি দুবার সম্পাদন করুন।\n\nইনপুট: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nআউটপুট: 3\n\nইনপুট: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nআউটপুট: 0",
      "bg": "Напишете Java функция `public int minOperations(String[] logs)`, за да решите следния проблем:  \nДаден е списък от логове, представляващи операции с папки,  \nвърнете минималния брой стъпки, необходими за връщане към главната папка.\n\nПример:  \nВход: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]  \nИзход: 2  \nОбяснение: Извършете операцията \"../\" два пъти, за да се върнете към главната папка.\n\nВход: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]  \nИзход: 3\n\nВход: logs = [\"d1/\",\"../\",\"../\",\"../\"]  \nИзход: 0",
      "zh": "编写一个 Java 函数 `public int minOperations(String[] logs)` 来解决以下问题：\n给定一个表示文件夹操作的日志列表，\n返回返回主文件夹所需的最小步骤数。\n\n示例：\n输入: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n输出: 2\n解释: 执行两次 \"../\" 操作以返回主文件夹。\n\n输入: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n输出: 3\n\n输入: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n输出: 0",
      "fr": "Écrire une fonction Java `public int minOperations(String[] logs)` pour résoudre le problème suivant :  \nÉtant donné une liste de journaux représentant des opérations de dossier,  \nretourner le nombre minimum d'étapes nécessaires pour revenir au dossier principal.\n\nExemple :  \nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]  \nOutput: 2  \nExplication : Effectuer l'opération \"../\" deux fois pour revenir au dossier principal.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]  \nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]  \nOutput: 0",
      "de": "Schreiben Sie eine Java-Funktion `public int minOperations(String[] logs)`, um das folgende Problem zu lösen:\nGegeben ist eine Liste von Logs, die Ordneroperationen darstellen,\ngeben Sie die minimale Anzahl von Schritten zurück, die erforderlich sind, um zum Hauptordner zurückzukehren.\n\nBeispiel:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nErläuterung: Führen Sie die \"../\"-Operation zweimal aus, um zum Hauptordner zurückzukehren.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "ha": "Rubuta aikin Java `public int minOperations(String[] logs)` don warware matsalar mai zuwa:\nAn ba da jerin bayanan aiki na manyan fayiloli,\nmayar da adadin matakan da ake bukata don komawa babban fayil.\n\nMisali:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nBayani: Yi aikin \"../\" sau biyu don komawa babban fayil.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "hi": "Java फ़ंक्शन `public int minOperations(String[] logs)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए लॉग्स की एक सूची जो फ़ोल्डर ऑपरेशन्स का प्रतिनिधित्व करती है,\nमुख्य फ़ोल्डर पर वापस लौटने के लिए आवश्यक न्यूनतम चरणों की संख्या लौटाएं।\n\nउदाहरण:\nइनपुट: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nआउटपुट: 2\nव्याख्या: मुख्य फ़ोल्डर पर वापस लौटने के लिए \"../\" ऑपरेशन दो बार करें।\n\nइनपुट: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nआउटपुट: 3\n\nइनपुट: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nआउटपुट: 0",
      "hu": "Írj egy Java függvényt `public int minOperations(String[] logs)` a következő probléma megoldására:\nAdott egy naplókat tartalmazó lista, amely mappaműveleteket reprezentál,\nadd vissza a minimális lépések számát, amelyek szükségesek a fő mappába való visszatéréshez.\n\nPélda:\nBemenet: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nKimenet: 2\nMagyarázat: Hajtsd végre a \"../\" műveletet kétszer a fő mappába való visszatéréshez.\n\nBemenet: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nKimenet: 3\n\nBemenet: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nKimenet: 0"
    },
    "instruction_bertscore": {
      "sq": "0.9963755914372564",
      "hy": "1",
      "bn": "1",
      "bg": "0.9979211344320889",
      "zh": "0.9940013624927464",
      "fr": "1",
      "de": "0.9986967860700301",
      "ha": "0.9674647408472474",
      "hi": "0.9846526249789583",
      "hu": "0.994488801447806"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"../\", \"d21/\", \"./\", \"../\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\", \"../\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"../\", \"../\", \"../\", \"d2/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minOperations",
    "signature": "public int minOperations(String[] logs)",
    "docstring": {
      "en": "Given a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "sq": "Duke pasur një listë të regjistrimeve që përfaqësojnë operacionet e dosjeve,\nkthe numrin minimal të hapave të nevojshëm për t'u kthyer në dosjen kryesore.\n\nShembull:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nShpjegim: Kryeni operacionin \"../\" dy herë për t'u kthyer në dosjen kryesore.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "hy": "Տրված է թղթապանակի գործողությունները ներկայացնող գրառումների ցուցակը, վերադարձնել հիմնական թղթապանակ վերադառնալու համար անհրաժեշտ նվազագույն քայլերի քանակը։\n\nՕրինակ:\nՄուտքագրում: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nԵլք: 2\nԲացատրություն: Կատարել \"../\" գործողությունը երկու անգամ՝ հիմնական թղթապանակ վերադառնալու համար։\n\nՄուտքագրում: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nԵլք: 3\n\nՄուտքագրում: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nԵլք: 0",
      "bn": "নির্দিষ্ট ফোল্ডার অপারেশনগুলির একটি তালিকা দেওয়া হলে, মূল ফোল্ডারে ফিরে আসার জন্য প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দিন।\n\nউদাহরণ:\nইনপুট: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nআউটপুট: 2\nব্যাখ্যা: মূল ফোল্ডারে ফিরে আসার জন্য \"../\" অপারেশনটি দুবার সম্পাদন করুন।\n\nইনপুট: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nআউটপুট: 3\n\nইনপুট: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nআউটপুট: 0",
      "bg": "Даден е списък от логове, представляващи операции с папки, върнете минималния брой стъпки, необходими за връщане към главната папка.\n\nПример:\nВход: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nИзход: 2\nОбяснение: Изпълнете операцията \"../\" два пъти, за да се върнете към главната папка.\n\nВход: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nИзход: 3\n\nВход: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nИзход: 0",
      "zh": "给定一个表示文件夹操作的日志列表，返回返回主文件夹所需的最小步骤数。\n\n示例：\n输入: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n输出: 2\n解释: 执行两次\"../\"操作以返回到主文件夹。\n\n输入: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n输出: 3\n\n输入: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n输出: 0",
      "fr": "Étant donné une liste de journaux représentant des opérations de dossier, renvoyez le nombre minimum d'étapes nécessaires pour revenir au dossier principal.\n\nExemple :\nEntrée : logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nSortie : 2\nExplication : Effectuez l'opération \"../\" deux fois pour revenir au dossier principal.\n\nEntrée : logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nSortie : 3\n\nEntrée : logs = [\"d1/\",\"../\",\"../\",\"../\"]\nSortie : 0",
      "de": "Angenommen, eine Liste von Protokollen, die Ordneroperationen darstellen,\ngibt die minimale Anzahl von Schritten zurück, die erforderlich sind, um zum Hauptordner zurückzukehren.\n\nBeispiel:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nErläuterung: Führen Sie die \"../\" Operation zweimal aus, um zum Hauptordner zurückzukehren.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "ha": "An ba da jerin rajistan ayyukan da ke wakiltar ayyukan manyan fayiloli,\nmayar da adadin matakan da ake bukata don komawa babban fayil.\n\nMisali:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nBayani: Yi aikin \"../\" sau biyu don komawa babban fayil.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "hi": "दी गई फ़ोल्डर संचालन को दर्शाने वाली लॉग्स की सूची के आधार पर, मुख्य फ़ोल्डर पर वापस लौटने के लिए आवश्यक न्यूनतम चरणों की संख्या लौटाएं।\n\nउदाहरण:\nइनपुट: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nआउटपुट: 2\nव्याख्या: मुख्य फ़ोल्डर पर वापस लौटने के लिए \"../\" संचालन को दो बार निष्पादित करें।\n\nइनपुट: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nआउटपुट: 3\n\nइनपुट: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nआउटपुट: 0",
      "hu": "Adott egy mappaműveleteket reprezentáló naplók listája, térj vissza a főmappához való visszatéréshez szükséges minimális lépések számával.\n\nPélda:\nBemenet: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nKimenet: 2\nMagyarázat: Hajtsd végre a \"../\" műveletet kétszer, hogy visszatérj a főmappához.\n\nBemenet: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nKimenet: 3\n\nBemenet: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nKimenet: 0"
    },
    "docstring_bertscore": {
      "sq": "0.9895297953548889",
      "hy": "1",
      "bn": "0.9873508200749362",
      "bg": "1",
      "zh": "1",
      "fr": "0.9970759621607854",
      "de": "0.9934863139147229",
      "ha": "0.9585363052197292",
      "hi": "0.9922649357017393",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/33",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Kthen vargun leksikografikisht më të vogël me gjatësi n dhe vlerë k.\n     * Vlera e një vargu është shuma e pozicioneve të karaktereve të tij në alfabet (duke filluar nga 1).\n     * Shembull:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Վերադարձնել լեքսիկոգրաֆիկորեն ամենափոքր տողը n երկարությամբ և k արժեքով:\n     * Տողի արժեքը նրա նիշերի դիրքերի գումարն է այբուբենում (սկսած 1-ից):\n     * Օրինակ:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * দৈর্ঘ্য n এবং মান k এর লেক্সিকোগ্রাফিক্যালি ক্ষুদ্রতম স্ট্রিং ফেরত দিন।\n     * একটি স্ট্রিং এর মান হল বর্ণমালায় এর অক্ষরগুলির অবস্থানের যোগফল (১ থেকে শুরু করে)।\n     * উদাহরণ:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Връща лексикографски най-малкия низ с дължина n и стойност k.\n     * Стойността на един низ е сумата от позициите на неговите символи в азбуката (започвайки от 1).\n     * Пример:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 返回长度为 n 且值为 k 的字典序最小字符串。\n     * 字符串的值是其字符在字母表中的位置之和（从 1 开始）。\n     * 例子:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Retourne la plus petite chaîne lexicographiquement de longueur n et de valeur k.\n     * La valeur d'une chaîne est la somme des positions de ses caractères dans l'alphabet (en commençant par 1).\n     * Exemple:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gibt den lexikographisch kleinsten String der Länge n und Wert k zurück.\n     * Der Wert eines Strings ist die Summe der Positionen seiner Zeichen im Alphabet (beginnend bei 1).\n     * Beispiel:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Mayar da ƙaramar ƙirar haruffa ta tsawo n da ƙima k.\n     * Ƙimar kirtani shine jimillar matsayi na haruffansa a cikin haruffa (fara daga 1).\n     * Misali:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * लंबाई n और मान k वाली शब्दकोशानुसार सबसे छोटी स्ट्रिंग लौटाएं।\n     * एक स्ट्रिंग का मान उसके वर्णों की वर्णमाला में स्थितियों के योग के बराबर होता है (1 से शुरू होकर)।\n     * उदाहरण:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adja vissza az abc sorrendben legkisebb n hosszúságú és k értékű karakterláncot.\n     * Egy karakterlánc értéke a karaktereinek az ábécében elfoglalt helyeinek összege (1-től kezdve).\n     * Példa:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9966701602923311",
      "hy": "0.9962983242190339",
      "bn": "0.999999801369619",
      "bg": "0.9966701602923311",
      "zh": "0.9898178094073896",
      "fr": "0.9949814047927725",
      "de": "0.9964800710176808",
      "ha": "0.9735271387068132",
      "hi": "0.9896189803959736",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }",
    "instruction": {
      "en": "Write a Java function `public String getSmallestString(int n, int k)` to solve the following problem:\nReturn the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "sq": "Shkruani një funksion Java `public String getSmallestString(int n, int k)` për të zgjidhur problemin e mëposhtëm:  \nKthe string-un më të vogël leksikografik me gjatësi n dhe vlerë k.  \nVlera e një string-u është shuma e pozicioneve të karaktereve të tij në alfabet (duke filluar nga 1).  \nShembull:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "hy": "Գրեք Java ֆունկցիա `public String getSmallestString(int n, int k)` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնել լեքսիկոգրաֆիկորեն ամենափոքր տողը, որի երկարությունը n է և արժեքը k:\nՏողի արժեքը նրա նիշերի դիրքերի գումարն է այբուբենում (սկսած 1-ից):\nՕրինակ:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "bn": "একটি জাভা ফাংশন `public String getSmallestString(int n, int k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nদৈর্ঘ্য n এবং মান k এর লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম স্ট্রিংটি ফেরত দিন।  \nএকটি স্ট্রিংয়ের মান হল বর্ণমালায় তার অক্ষরগুলির অবস্থানের যোগফল (১ থেকে শুরু করে)।  \nউদাহরণ:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "bg": "Напишете Java функция `public String getSmallestString(int n, int k)`, за да решите следния проблем:  \nВърнете лексикографски най-малкия низ с дължина n и стойност k.  \nСтойността на низа е сумата от позициите на неговите символи в азбуката (започвайки от 1).  \nПример:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "zh": "编写一个 Java 函数 `public String getSmallestString(int n, int k)` 来解决以下问题：\n返回长度为 n 且值为 k 的字典序最小的字符串。\n字符串的值是其字符在字母表中的位置之和（从 1 开始）。\n示例:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "fr": "Écrire une fonction Java `public String getSmallestString(int n, int k)` pour résoudre le problème suivant :\nRetourner la plus petite chaîne lexicographique de longueur n et de valeur k.\nLa valeur d'une chaîne est la somme des positions de ses caractères dans l'alphabet (en commençant par 1).\nExemple :\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "de": "Schreiben Sie eine Java-Funktion `public String getSmallestString(int n, int k)`, um das folgende Problem zu lösen:\nGeben Sie die lexikographisch kleinste Zeichenkette der Länge n und des Wertes k zurück.\nDer Wert einer Zeichenkette ist die Summe der Positionen ihrer Zeichen im Alphabet (beginnend bei 1).\nBeispiel:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "ha": "Rubuta aikin Java `public String getSmallestString(int n, int k)` don warware matsalar mai zuwa:\nMayar da ƙaramar kalma ta lexicographically mai tsawon n da ƙimar k.\nƘimar kalma ita ce jumlar matsayin haruffanta a cikin haruffa (fara daga 1).\nMisali:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "hi": "एक Java फ़ंक्शन `public String getSmallestString(int n, int k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n और मान k का शब्दकोशानुसार सबसे छोटा स्ट्रिंग लौटाएं।\nएक स्ट्रिंग का मान उसके वर्णों की वर्णमाला में स्थितियों के योग के बराबर होता है (1 से शुरू करके)।\nउदाहरण:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "hu": "Írj egy Java függvényt `public String getSmallestString(int n, int k)` a következő probléma megoldására:\nAdd vissza a lexicoográfiailag legkisebb n hosszúságú és k értékű karakterláncot.\nEgy karakterlánc értéke a karaktereinek ábécében elfoglalt pozícióinak összege (1-től kezdve).\nPélda:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\""
    },
    "instruction_bertscore": {
      "sq": "0.9918128529545039",
      "hy": "0.9818620667557992",
      "bn": "1",
      "bg": "0.9955173095608046",
      "zh": "0.9885410133180973",
      "fr": "0.9949508157140932",
      "de": "0.9973327912434635",
      "ha": "0.9692621471652321",
      "hi": "0.991852777661092",
      "hu": "1"
    },
    "level": "easy",
    "test": "\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "getSmallestString",
    "signature": "public String getSmallestString(int n, int k)",
    "docstring": {
      "en": "Return the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "sq": "Kthe string-un leksikografikisht më të vogël me gjatësi n dhe vlerë k. Vlera e një string-u është shuma e pozicioneve të karaktereve të tij në alfabet (duke filluar nga 1). Shembull: >>> getSmallestString(3, 27) \"aay\" >>> getSmallestString(5, 73) \"aaszz\"",
      "hy": "Վերադարձնել լեքսիկոգրաֆիկորեն ամենափոքր տողը, որի երկարությունը n է և արժեքը՝ k: Տողի արժեքը նրա նիշերի դիրքերի գումարն է այբուբենում (սկսած 1-ից): Օրինակ:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "bn": "লেক্সিকোগ্রাফিক্যালি সবচেয়ে ছোট স্ট্রিং ফেরত দিন যার দৈর্ঘ্য n এবং মান k।\nএকটি স্ট্রিংয়ের মান হল বর্ণমালায় তার অক্ষরগুলির অবস্থানের যোগফল (১ থেকে শুরু করে)।\nউদাহরণ:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "bg": "Върнете лексикографски най-малкия низ с дължина n и стойност k. Стойността на низа е сумата от позициите на неговите символи в азбуката (започвайки от 1).\nПример:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "zh": "返回字典序最小的长度为 n 且值为 k 的字符串。  \n字符串的值是其字符在字母表中的位置之和（从 1 开始）。  \n示例：  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"  ",
      "fr": "Retourne la plus petite chaîne lexicographiquement de longueur n et de valeur k.  \nLa valeur d'une chaîne est la somme des positions de ses caractères dans l'alphabet (en commençant par 1).  \nExemple :  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "de": "Geben Sie die lexikografisch kleinste Zeichenkette der Länge n und des Wertes k zurück. Der Wert einer Zeichenkette ist die Summe der Positionen ihrer Zeichen im Alphabet (beginnend bei 1). Beispiel:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "ha": "Mayar da kirtani mafi ƙanƙanta a cikin tsari na haruffa wanda yake da tsawon n da darajar k. \nDarajar kirtani ita ce jimillar matsayin haruffansa a cikin haruffa (farawa daga 1).\n\nMisali:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "hi": "लंबाई n और मान k की शब्दकोशानुसार सबसे छोटी स्ट्रिंग लौटाएं।  \nएक स्ट्रिंग का मान उसके वर्णमाला में उसके अक्षरों की स्थितियों के योग के बराबर होता है (1 से शुरू होकर)।  \nउदाहरण:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "hu": "Adja vissza az n hosszúságú és k értékű lexicoográfiailag legkisebb karakterláncot.  \nEgy karakterlánc értéke a karaktereinek az ábécében elfoglalt helyeinek összege (1-től kezdve).  \nPélda:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\""
    },
    "docstring_bertscore": {
      "sq": "0.9963030913481786",
      "hy": "0.9733414193005456",
      "bn": "0.9999996027392379",
      "bg": "0.9903755635173356",
      "zh": "0.993964814502636",
      "fr": "0.9927535664390852",
      "de": "0.9966701602923311",
      "ha": "0.9500251920227653",
      "hi": "0.9480627238581405",
      "hu": "0.9999996027392379"
    }
  },
  {
    "task_id": "Java/34",
    "prompt": {
      "en": "public class Solution {\n\n  // Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  // @param n The number of passengers.\n  // @return The probability that the last passenger will sit in their own seat.\n\n  // Example 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Example 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Example 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Example 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Example 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Example 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Function to calculate the probability that the last passenger will sit in their own seat\n  public static double calculateProbability(int n) ",
      "sq": "public class Solution {\n\n  // Duke pasur parasysh numrin e pasagjerëve n, llogarit probabilitetin që pasagjeri i fundit të ulet në vendin e tij.\n  // @param n Numri i pasagjerëve.\n  // @return Probabiliteti që pasagjeri i fundit të ulet në vendin e tij.\n\n  // Shembulli 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Shembulli 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Shembulli 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Shembulli 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Shembulli 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Shembulli 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Funksioni për të llogaritur probabilitetin që pasagjeri i fundit të ulet në vendin e tij\n  public static double calculateProbability(int n) ",
      "hy": "public class Solution {\n\n  // Տրված է ուղևորների թիվը n, հաշվարկել հավանականությունը, որ վերջին ուղևորը կնստի իր տեղում:\n  // @param n Ուղևորների թիվը:\n  // @return Հավանականությունը, որ վերջին ուղևորը կնստի իր տեղում:\n\n  // Օրինակ 1:\n  // Մուտքագրում: n = 1\n  // Ելք: 1.00000\n\n  // Օրինակ 2:\n  // Մուտքագրում: n = 2\n  // Ելք: 0.50000\n\n  // Օրինակ 3:\n  // Մուտքագրում: n = 3\n  // Ելք: 0.50000\n\n  // Օրինակ 4:\n  // Մուտքագրում: n = 4\n  // Ելք: 0.50000\n\n  // Օրինակ 5:\n  // Մուտքագրում: n = 5\n  // Ելք: 0.50000\n\n  // Օրինակ 6:\n  // Մուտքագրում: n = 100000\n  // Ելք: 0.50000\n\n  // Ֆունկցիա, որը հաշվարկում է հավանականությունը, որ վերջին ուղևորը կնստի իր տեղում\n  public static double calculateProbability(int n) ",
      "bn": "public class Solution {\n\n  // যাত্রীদের সংখ্যা n দেওয়া হলে, শেষ যাত্রী তাদের নিজ আসনে বসার সম্ভাবনা গণনা করুন।\n  // @param n যাত্রীদের সংখ্যা।\n  // @return শেষ যাত্রী তাদের নিজ আসনে বসার সম্ভাবনা।\n\n  // উদাহরণ 1:\n  // ইনপুট: n = 1\n  // আউটপুট: 1.00000\n\n  // উদাহরণ 2:\n  // ইনপুট: n = 2\n  // আউটপুট: 0.50000\n\n  // উদাহরণ 3:\n  // ইনপুট: n = 3\n  // আউটপুট: 0.50000\n\n  // উদাহরণ 4:\n  // ইনপুট: n = 4\n  // আউটপুট: 0.50000\n\n  // উদাহরণ 5:\n  // ইনপুট: n = 5\n  // আউটপুট: 0.50000\n\n  // উদাহরণ 6:\n  // ইনপুট: n = 100000\n  // আউটপুট: 0.50000\n\n  // শেষ যাত্রী তাদের নিজ আসনে বসার সম্ভাবনা গণনা করার ফাংশন\n  public static double calculateProbability(int n) ",
      "bg": "public class Solution {\n\n  // Даден е броят на пътниците n, изчислете вероятността последният пътник да седне на своето място.\n  // @param n Броят на пътниците.\n  // @return Вероятността последният пътник да седне на своето място.\n\n  // Пример 1:\n  // Вход: n = 1\n  // Изход: 1.00000\n\n  // Пример 2:\n  // Вход: n = 2\n  // Изход: 0.50000\n\n  // Пример 3:\n  // Вход: n = 3\n  // Изход: 0.50000\n\n  // Пример 4:\n  // Вход: n = 4\n  // Изход: 0.50000\n\n  // Пример 5:\n  // Вход: n = 5\n  // Изход: 0.50000\n\n  // Пример 6:\n  // Вход: n = 100000\n  // Изход: 0.50000\n\n  // Функция за изчисляване на вероятността последният пътник да седне на своето място\n  public static double calculateProbability(int n) ",
      "zh": "public class Solution {\n\n  // 给定乘客数量 n，计算最后一个乘客坐在自己座位上的概率。\n  // @param n 乘客数量。\n  // @return 最后一个乘客坐在自己座位上的概率。\n\n  // 示例 1:\n  // 输入: n = 1\n  // 输出: 1.00000\n\n  // 示例 2:\n  // 输入: n = 2\n  // 输出: 0.50000\n\n  // 示例 3:\n  // 输入: n = 3\n  // 输出: 0.50000\n\n  // 示例 4:\n  // 输入: n = 4\n  // 输出: 0.50000\n\n  // 示例 5:\n  // 输入: n = 5\n  // 输出: 0.50000\n\n  // 示例 6:\n  // 输入: n = 100000\n  // 输出: 0.50000\n\n  // 计算最后一个乘客坐在自己座位上的概率的函数\n  public static double calculateProbability(int n) ",
      "fr": "public class Solution {\n\n  // Étant donné le nombre de passagers n, calculez la probabilité que le dernier passager s'assoit à sa propre place.\n  // @param n Le nombre de passagers.\n  // @return La probabilité que le dernier passager s'assoit à sa propre place.\n\n  // Exemple 1 :\n  // Entrée : n = 1\n  // Sortie : 1.00000\n\n  // Exemple 2 :\n  // Entrée : n = 2\n  // Sortie : 0.50000\n\n  // Exemple 3 :\n  // Entrée : n = 3\n  // Sortie : 0.50000\n\n  // Exemple 4 :\n  // Entrée : n = 4\n  // Sortie : 0.50000\n\n  // Exemple 5 :\n  // Entrée : n = 5\n  // Sortie : 0.50000\n\n  // Exemple 6 :\n  // Entrée : n = 100000\n  // Sortie : 0.50000\n\n  // Fonction pour calculer la probabilité que le dernier passager s'assoit à sa propre place\n  public static double calculateProbability(int n) ",
      "de": "public class Solution {\n\n  // Gegeben die Anzahl der Passagiere n, berechne die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n  // @param n Die Anzahl der Passagiere.\n  // @return Die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n\n  // Beispiel 1:\n  // Eingabe: n = 1\n  // Ausgabe: 1.00000\n\n  // Beispiel 2:\n  // Eingabe: n = 2\n  // Ausgabe: 0.50000\n\n  // Beispiel 3:\n  // Eingabe: n = 3\n  // Ausgabe: 0.50000\n\n  // Beispiel 4:\n  // Eingabe: n = 4\n  // Ausgabe: 0.50000\n\n  // Beispiel 5:\n  // Eingabe: n = 5\n  // Ausgabe: 0.50000\n\n  // Beispiel 6:\n  // Eingabe: n = 100000\n  // Ausgabe: 0.50000\n\n  // Funktion zur Berechnung der Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt\n  public static double calculateProbability(int n) ",
      "ha": "public class Solution {\n\n  // An ba da yawan fasinjoji n, ƙididdige yuwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n  // @param n Yawan fasinjoji.\n  // @return Yuwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n\n  // Misali 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Misali 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Misali 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Misali 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Misali 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Misali 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Aiki don ƙididdige yuwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa\n  public static double calculateProbability(int n) ",
      "hi": "public class Solution {\n\n  // दिए गए यात्रियों की संख्या n के लिए, यह गणना करें कि अंतिम यात्री के अपनी सीट पर बैठने की संभावना क्या है।\n  // @param n यात्रियों की संख्या।\n  // @return संभावना कि अंतिम यात्री अपनी सीट पर बैठेगा।\n\n  // उदाहरण 1:\n  // इनपुट: n = 1\n  // आउटपुट: 1.00000\n\n  // उदाहरण 2:\n  // इनपुट: n = 2\n  // आउटपुट: 0.50000\n\n  // उदाहरण 3:\n  // इनपुट: n = 3\n  // आउटपुट: 0.50000\n\n  // उदाहरण 4:\n  // इनपुट: n = 4\n  // आउटपुट: 0.50000\n\n  // उदाहरण 5:\n  // इनपुट: n = 5\n  // आउटपुट: 0.50000\n\n  // उदाहरण 6:\n  // इनपुट: n = 100000\n  // आउटपुट: 0.50000\n\n  // यह संभावना गणना करने के लिए फ़ंक्शन कि अंतिम यात्री अपनी सीट पर बैठेगा\n  public static double calculateProbability(int n) ",
      "hu": "public class Solution {\n\n  // Adott az utasok száma n, számítsa ki annak valószínűségét, hogy az utolsó utas a saját ülésére fog ülni.\n  // @param n Az utasok száma.\n  // @return Annak valószínűsége, hogy az utolsó utas a saját ülésére fog ülni.\n\n  // 1. példa:\n  // Bemenet: n = 1\n  // Kimenet: 1.00000\n\n  // 2. példa:\n  // Bemenet: n = 2\n  // Kimenet: 0.50000\n\n  // 3. példa:\n  // Bemenet: n = 3\n  // Kimenet: 0.50000\n\n  // 4. példa:\n  // Bemenet: n = 4\n  // Kimenet: 0.50000\n\n  // 5. példa:\n  // Bemenet: n = 5\n  // Kimenet: 0.50000\n\n  // 6. példa:\n  // Bemenet: n = 100000\n  // Kimenet: 0.50000\n\n  // Függvény annak valószínűségének kiszámítására, hogy az utolsó utas a saját ülésére fog ülni\n  public static double calculateProbability(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9769030606628821",
      "hy": "0.9764624984777468",
      "bn": "0.9740227215074952",
      "bg": "1",
      "zh": "0.9769030606628821",
      "fr": "0.9885426023611456",
      "de": "0.9885426023611456",
      "ha": "0.9868580180995887",
      "hi": "0.974629934582319",
      "hu": "1"
    },
    "canonical_solution": "  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }",
    "instruction": {
      "en": "Write a Java function `public static double calculateProbability(int n)` to solve the following problem:\nGiven the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  @param n The number of passengers.\n  @return The probability that the last passenger will sit in their own seat.\n\n  Example 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Example 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Example 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Example 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Example 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Example 6:\n  Input: n = 100000\n  Output: 0.50000",
      "sq": "Shkruani një funksion në Java `public static double calculateProbability(int n)` për të zgjidhur problemin në vijim: Duke pasur parasysh numrin e pasagjerëve n, llogaritni probabilitetin që pasagjeri i fundit të ulet në vendin e tij.\n  @param n Numri i pasagjerëve.\n  @return Probabiliteti që pasagjeri i fundit të ulet në vendin e tij.\n\n  Shembulli 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Shembulli 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Shembulli 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Shembulli 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Shembulli 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Shembulli 6:\n  Input: n = 100000\n  Output: 0.50000",
      "hy": "Գրեք Java ֆունկցիա `public static double calculateProbability(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ուղևորների թիվը n, հաշվեք հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստատեղում:\n  @param n Ուղևորների թիվը:\n  @return Հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստատեղում:\n\n  Օրինակ 1:\n  Մուտք: n = 1\n  Ելք: 1.00000\n\n  Օրինակ 2:\n  Մուտք: n = 2\n  Ելք: 0.50000\n\n  Օրինակ 3:\n  Մուտք: n = 3\n  Ելք: 0.50000\n\n  Օրինակ 4:\n  Մուտք: n = 4\n  Ելք: 0.50000\n\n  Օրինակ 5:\n  Մուտք: n = 5\n  Ելք: 0.50000\n\n  Օրինակ 6:\n  Մուտք: n = 100000\n  Ելք: 0.50000",
      "bn": "একটি জাভা ফাংশন `public static double calculateProbability(int n)` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করার জন্য:\nযাত্রীদের সংখ্যা n দেওয়া হলে, শেষ যাত্রী তার নিজের আসনে বসার সম্ভাবনা গণনা করুন।\n  @param n যাত্রীদের সংখ্যা।\n  @return শেষ যাত্রী তার নিজের আসনে বসার সম্ভাবনা।\n\n  উদাহরণ 1:\n  ইনপুট: n = 1\n  আউটপুট: 1.00000\n\n  উদাহরণ 2:\n  ইনপুট: n = 2\n  আউটপুট: 0.50000\n\n  উদাহরণ 3:\n  ইনপুট: n = 3\n  আউটপুট: 0.50000\n\n  উদাহরণ 4:\n  ইনপুট: n = 4\n  আউটপুট: 0.50000\n\n  উদাহরণ 5:\n  ইনপুট: n = 5\n  আউটপুট: 0.50000\n\n  উদাহরণ 6:\n  ইনপুট: n = 100000\n  আউটপুট: 0.50000",
      "bg": "Напишете Java функция `public static double calculateProbability(int n)`, за да решите следния проблем:  \nКато се даде броят на пътниците n, изчислете вероятността последният пътник да седне на своето място.  \n  @param n Броят на пътниците.  \n  @return Вероятността последният пътник да седне на своето място.\n\n  Пример 1:  \n  Вход: n = 1  \n  Изход: 1.00000\n\n  Пример 2:  \n  Вход: n = 2  \n  Изход: 0.50000\n\n  Пример 3:  \n  Вход: n = 3  \n  Изход: 0.50000\n\n  Пример 4:  \n  Вход: n = 4  \n  Изход: 0.50000\n\n  Пример 5:  \n  Вход: n = 5  \n  Изход: 0.50000\n\n  Пример 6:  \n  Вход: n = 100000  \n  Изход: 0.50000",
      "zh": "编写一个 Java 函数 `public static double calculateProbability(int n)` 来解决以下问题：\n给定乘客数量 n，计算最后一个乘客坐在自己座位上的概率。\n  @param n 乘客的数量。\n  @return 最后一个乘客坐在自己座位上的概率。\n\n  示例 1:\n  输入: n = 1\n  输出: 1.00000\n\n  示例 2:\n  输入: n = 2\n  输出: 0.50000\n\n  示例 3:\n  输入: n = 3\n  输出: 0.50000\n\n  示例 4:\n  输入: n = 4\n  输出: 0.50000\n\n  示例 5:\n  输入: n = 5\n  输出: 0.50000\n\n  示例 6:\n  输入: n = 100000\n  输出: 0.50000",
      "fr": "Écrire une fonction Java `public static double calculateProbability(int n)` pour résoudre le problème suivant :  \nÉtant donné le nombre de passagers n, calculer la probabilité que le dernier passager s'assoit à sa propre place.  \n  @param n Le nombre de passagers.  \n  @return La probabilité que le dernier passager s'assoit à sa propre place.  \n\n  Exemple 1 :  \n  Entrée : n = 1  \n  Sortie : 1.00000  \n\n  Exemple 2 :  \n  Entrée : n = 2  \n  Sortie : 0.50000  \n\n  Exemple 3 :  \n  Entrée : n = 3  \n  Sortie : 0.50000  \n\n  Exemple 4 :  \n  Entrée : n = 4  \n  Sortie : 0.50000  \n\n  Exemple 5 :  \n  Entrée : n = 5  \n  Sortie : 0.50000  \n\n  Exemple 6 :  \n  Entrée : n = 100000  \n  Sortie : 0.50000  ",
      "de": "Schreiben Sie eine Java-Funktion `public static double calculateProbability(int n)`, um das folgende Problem zu lösen:\nGegeben ist die Anzahl der Passagiere n, berechnen Sie die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n  @param n Die Anzahl der Passagiere.\n  @return Die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n\n  Beispiel 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Beispiel 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Beispiel 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Beispiel 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Beispiel 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Beispiel 6:\n  Input: n = 100000\n  Output: 0.50000",
      "ha": "Rubuta aikin Java `public static double calculateProbability(int n)` don warware matsalar mai zuwa:  \nAn ba da adadin fasinjoji n, a lissafta yiwuwar cewa fasinja na ƙarshe zai zauna a wurin zama na kansu.  \n  @param n Adadin fasinjoji.  \n  @return Yiwuwar cewa fasinja na ƙarshe zai zauna a wurin zama na kansu.  \n\n  Misali 1:  \n  Input: n = 1  \n  Output: 1.00000  \n\n  Misali 2:  \n  Input: n = 2  \n  Output: 0.50000  \n\n  Misali 3:  \n  Input: n = 3  \n  Output: 0.50000  \n\n  Misali 4:  \n  Input: n = 4  \n  Output: 0.50000  \n\n  Misali 5:  \n  Input: n = 5  \n  Output: 0.50000  \n\n  Misali 6:  \n  Input: n = 100000  \n  Output: 0.50000",
      "hi": "Java फ़ंक्शन `public static double calculateProbability(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए यात्रियों की संख्या n के आधार पर, यह संभावना गणना करें कि अंतिम यात्री अपनी सीट पर बैठेगा।\n  @param n यात्रियों की संख्या।\n  @return यह संभावना कि अंतिम यात्री अपनी सीट पर बैठेगा।\n\n  उदाहरण 1:\n  इनपुट: n = 1\n  आउटपुट: 1.00000\n\n  उदाहरण 2:\n  इनपुट: n = 2\n  आउटपुट: 0.50000\n\n  उदाहरण 3:\n  इनपुट: n = 3\n  आउटपुट: 0.50000\n\n  उदाहरण 4:\n  इनपुट: n = 4\n  आउटपुट: 0.50000\n\n  उदाहरण 5:\n  इनपुट: n = 5\n  आउटपुट: 0.50000\n\n  उदाहरण 6:\n  इनपुट: n = 100000\n  आउटपुट: 0.50000",
      "hu": "Írj egy Java függvényt `public static double calculateProbability(int n)` a következő probléma megoldására:\nAdott az utasok száma n, számítsd ki annak valószínűségét, hogy az utolsó utas a saját helyére fog ülni.\n  @param n Az utasok száma.\n  @return Annak a valószínűsége, hogy az utolsó utas a saját helyére fog ülni.\n\n  1. példa:\n  Bemenet: n = 1\n  Kimenet: 1.00000\n\n  2. példa:\n  Bemenet: n = 2\n  Kimenet: 0.50000\n\n  3. példa:\n  Bemenet: n = 3\n  Kimenet: 0.50000\n\n  4. példa:\n  Bemenet: n = 4\n  Kimenet: 0.50000\n\n  5. példa:\n  Bemenet: n = 5\n  Kimenet: 0.50000\n\n  6. példa:\n  Bemenet: n = 100000\n  Kimenet: 0.50000"
    },
    "instruction_bertscore": {
      "sq": "0.9919566613503732",
      "hy": "0.9818426009784578",
      "bn": "0.9735809675400736",
      "bg": "0.9852159407395733",
      "zh": "0.9908973655283142",
      "fr": "0.9908973655283142",
      "de": "0.9887803629272444",
      "ha": "0.9948028360802221",
      "hi": "0.9670261649659223",
      "hu": "0.9602792868133103"
    },
    "level": "easy",
    "test": "public static void main(String[] args) {\n    assert Math.abs(calculateProbability(6) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(10) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(50) - 0.50000) < 0.00001;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateProbability",
    "signature": "public static double calculateProbability(int n)",
    "docstring": {
      "en": "Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  @param n The number of passengers.\n  @return The probability that the last passenger will sit in their own seat.\n\n  Example 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Example 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Example 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Example 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Example 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Example 6:\n  Input: n = 100000\n  Output: 0.50000",
      "sq": "Duke pasur parasysh numrin e pasagjerëve n, llogaritni probabilitetin që pasagjeri i fundit të ulet në vendin e tij.\n\n@param n Numri i pasagjerëve.\n@return Probabiliteti që pasagjeri i fundit të ulet në vendin e tij.\n\nShembulli 1:\nInput: n = 1\nOutput: 1.00000\n\nShembulli 2:\nInput: n = 2\nOutput: 0.50000\n\nShembulli 3:\nInput: n = 3\nOutput: 0.50000\n\nShembulli 4:\nInput: n = 4\nOutput: 0.50000\n\nShembulli 5:\nInput: n = 5\nOutput: 0.50000\n\nShembulli 6:\nInput: n = 100000\nOutput: 0.50000",
      "hy": "Տրված է ուղևորների քանակը n, հաշվարկել հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստատեղում:\n  @param n Ուղևորների քանակը:\n  @return Հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստատեղում:\n\n  Օրինակ 1:\n  Մուտք: n = 1\n  Ելք: 1.00000\n\n  Օրինակ 2:\n  Մուտք: n = 2\n  Ելք: 0.50000\n\n  Օրինակ 3:\n  Մուտք: n = 3\n  Ելք: 0.50000\n\n  Օրինակ 4:\n  Մուտք: n = 4\n  Ելք: 0.50000\n\n  Օրինակ 5:\n  Մուտք: n = 5\n  Ելք: 0.50000\n\n  Օրինակ 6:\n  Մուտք: n = 100000\n  Ելք: 0.50000",
      "bn": "যদি যাত্রীদের সংখ্যা n দেওয়া হয়, তাহলে শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা গণনা করুন।\n  @param n যাত্রীদের সংখ্যা।\n  @return শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা।\n\n  উদাহরণ 1:\n  Input: n = 1\n  Output: 1.00000\n\n  উদাহরণ 2:\n  Input: n = 2\n  Output: 0.50000\n\n  উদাহরণ 3:\n  Input: n = 3\n  Output: 0.50000\n\n  উদাহরণ 4:\n  Input: n = 4\n  Output: 0.50000\n\n  উদাহরণ 5:\n  Input: n = 5\n  Output: 0.50000\n\n  উদাহরণ 6:\n  Input: n = 100000\n  Output: 0.50000",
      "bg": "Даден е броят на пътниците n, изчислете вероятността последният пътник да седне на своето място.\n  @param n Броят на пътниците.\n  @return Вероятността последният пътник да седне на своето място.\n\n  Пример 1:\n  Вход: n = 1\n  Изход: 1.00000\n\n  Пример 2:\n  Вход: n = 2\n  Изход: 0.50000\n\n  Пример 3:\n  Вход: n = 3\n  Изход: 0.50000\n\n  Пример 4:\n  Вход: n = 4\n  Изход: 0.50000\n\n  Пример 5:\n  Вход: n = 5\n  Изход: 0.50000\n\n  Пример 6:\n  Вход: n = 100000\n  Изход: 0.50000",
      "zh": "给定乘客数量 n，计算最后一位乘客坐在自己座位上的概率。\n  @param n 乘客的数量。\n  @return 最后一位乘客坐在自己座位上的概率。\n\n  示例 1:\n  输入: n = 1\n  输出: 1.00000\n\n  示例 2:\n  输入: n = 2\n  输出: 0.50000\n\n  示例 3:\n  输入: n = 3\n  输出: 0.50000\n\n  示例 4:\n  输入: n = 4\n  输出: 0.50000\n\n  示例 5:\n  输入: n = 5\n  输出: 0.50000\n\n  示例 6:\n  输入: n = 100000\n  输出: 0.50000",
      "fr": "Étant donné le nombre de passagers n, calculez la probabilité que le dernier passager s'assoie à sa propre place.\n  @param n Le nombre de passagers.\n  @return La probabilité que le dernier passager s'assoie à sa propre place.\n\n  Exemple 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Exemple 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Exemple 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Exemple 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Exemple 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Exemple 6:\n  Input: n = 100000\n  Output: 0.50000",
      "de": "Gegeben die Anzahl der Passagiere n, berechne die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n@param n Die Anzahl der Passagiere.  \n@return Die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n\nExample 1:  \nInput: n = 1  \nOutput: 1.00000\n\nExample 2:  \nInput: n = 2  \nOutput: 0.50000\n\nExample 3:  \nInput: n = 3  \nOutput: 0.50000\n\nExample 4:  \nInput: n = 4  \nOutput: 0.50000\n\nExample 5:  \nInput: n = 5  \nOutput: 0.50000\n\nExample 6:  \nInput: n = 100000  \nOutput: 0.50000",
      "ha": "An ba da yawan fasinjoji n, ƙididdige yuwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n@param n Yawan fasinjoji.  \n@return Yiwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n\nExample 1:  \nInput: n = 1  \nOutput: 1.00000\n\nExample 2:  \nInput: n = 2  \nOutput: 0.50000\n\nExample 3:  \nInput: n = 3  \nOutput: 0.50000\n\nExample 4:  \nInput: n = 4  \nOutput: 0.50000\n\nExample 5:  \nInput: n = 5  \nOutput: 0.50000\n\nExample 6:  \nInput: n = 100000  \nOutput: 0.50000",
      "hi": "दी गई संख्या n यात्रियों की, यह गणना करें कि अंतिम यात्री अपने स्वयं के सीट पर बैठेगा, इसकी संभावना कितनी है।\n  @param n यात्रियों की संख्या।\n  @return यह संभावना कि अंतिम यात्री अपने स्वयं के सीट पर बैठेगा।\n\n  उदाहरण 1:\n  इनपुट: n = 1\n  आउटपुट: 1.00000\n\n  उदाहरण 2:\n  इनपुट: n = 2\n  आउटपुट: 0.50000\n\n  उदाहरण 3:\n  इनपुट: n = 3\n  आउटपुट: 0.50000\n\n  उदाहरण 4:\n  इनपुट: n = 4\n  आउटपुट: 0.50000\n\n  उदाहरण 5:\n  इनपुट: n = 5\n  आउटपुट: 0.50000\n\n  उदाहरण 6:\n  इनपुट: n = 100000\n  आउटपुट: 0.50000",
      "hu": "Adott az utasok száma n, számítsa ki annak valószínűségét, hogy az utolsó utas a saját ülésére fog ülni.\n  @param n Az utasok száma.\n  @return Annak valószínűsége, hogy az utolsó utas a saját ülésére fog ülni.\n\n  Példa 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Példa 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Példa 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Példa 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Példa 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Példa 6:\n  Input: n = 100000\n  Output: 0.50000"
    },
    "docstring_bertscore": {
      "sq": "0.9536209978106398",
      "hy": "0.9795430570572169",
      "bn": "0.9714804512606298",
      "bg": "1",
      "zh": "0.9862013460598874",
      "fr": "0.9862013460598874",
      "de": "1",
      "ha": "0.9866178739689175",
      "hi": "0.9884973146342696",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/35",
    "prompt": {
      "en": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "sq": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Duke pasur një varg numrash të plotë nums ku çdo element shfaqet tre herë përveç njërit, i cili shfaqet vetëm një herë. Gjeni dhe ktheni elementin që shfaqet vetëm një herë.\n   *\n   * @param nums Një varg numrash të plotë ku çdo element shfaqet tre herë përveç njërit.\n   * @return Elementi që shfaqet vetëm një herë.\n   *\n   * Shembull:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Shembull:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "hy": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Տրված է ամբողջ թվերի զանգված nums, որտեղ յուրաքանչյուր տարր հայտնվում է երեք անգամ, բացի մեկից, որը հայտնվում է միայն մեկ անգամ։ Գտեք և վերադարձեք տարրը, որը հայտնվում է միայն մեկ անգամ։\n   *\n   * @param nums Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր տարր հայտնվում է երեք անգամ, բացի մեկից։\n   * @return Տարրը, որը հայտնվում է միայն մեկ անգամ։\n   *\n   * Օրինակ:\n   * singleNumber(new int[]{2,2,3,2})\n   * Արդյունք: 3\n   *\n   * Օրինակ:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Արդյունք: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "bn": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যার অ্যারে nums দেওয়া হয়েছে যেখানে প্রতিটি উপাদান তিনবার প্রদর্শিত হয় শুধুমাত্র একটি ছাড়া, যা শুধুমাত্র একবার প্রদর্শিত হয়। যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয় তা খুঁজে বের করুন এবং ফেরত দিন।\n   *\n   * @param nums একটি পূর্ণসংখ্যার অ্যারে যেখানে প্রতিটি উপাদান তিনবার প্রদর্শিত হয় শুধুমাত্র একটি ছাড়া।\n   * @return যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয়।\n   *\n   * উদাহরণ:\n   * singleNumber(new int[]{2,2,3,2})\n   * আউটপুট: 3\n   *\n   * উদাহরণ:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * আউটপুট: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "bg": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Даден е масив от цели числа nums, където всеки елемент се появява три пъти, с изключение на един, който се появява само веднъж. Намерете и върнете елемента, който се появява само веднъж.\n   *\n   * @param nums Масив от цели числа, където всеки елемент се появява три пъти, с изключение на един.\n   * @return Елементът, който се появява само веднъж.\n   *\n   * Пример:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Пример:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "zh": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * 给定一个整数数组 nums，其中每个元素出现三次，只有一个元素出现一次。找到并返回只出现一次的元素。\n   *\n   * @param nums 一个整数数组，其中每个元素出现三次，只有一个元素出现一次。\n   * @return 只出现一次的元素。\n   *\n   * 示例:\n   * singleNumber(new int[]{2,2,3,2})\n   * 输出: 3\n   *\n   * 示例:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * 输出: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "fr": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Étant donné un tableau d'entiers nums où chaque élément apparaît trois fois sauf un, qui apparaît une seule fois. Trouvez et renvoyez l'élément qui apparaît une seule fois.\n   *\n   * @param nums Un tableau d'entiers où chaque élément apparaît trois fois sauf un.\n   * @return L'élément qui apparaît une seule fois.\n   *\n   * Exemple:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Exemple:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "de": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Gegeben ein ganzzahliges Array nums, in dem jedes Element dreimal vorkommt, außer einem, das nur einmal vorkommt. Finde und gib das Element zurück, das nur einmal vorkommt.\n   *\n   * @param nums Ein ganzzahliges Array, in dem jedes Element dreimal vorkommt, außer einem.\n   * @return Das Element, das nur einmal vorkommt.\n   *\n   * Beispiel:\n   * singleNumber(new int[]{2,2,3,2})\n   * Ausgabe: 3\n   *\n   * Beispiel:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Ausgabe: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "ha": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * An ba da wani jerin lambobi na integer nums inda kowace ƙungiya ta bayyana sau uku sai ɗaya, wanda ya bayyana sau ɗaya kawai. Nemo kuma dawo da abin da ya bayyana sau ɗaya kawai.\n   *\n   * @param nums Wani jerin lambobi na integer inda kowace ƙungiya ta bayyana sau uku sai ɗaya.\n   * @return Abin da ya bayyana sau ɗaya kawai.\n   *\n   * Misali:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Misali:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "hi": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * एक पूर्णांक सरणी nums दी गई है जहाँ हर तत्व तीन बार दिखाई देता है सिवाय एक के, जो केवल एक बार दिखाई देता है। उस तत्व को खोजें और लौटाएं जो केवल एक बार दिखाई देता है।\n   *\n   * @param nums एक पूर्णांक सरणी जहाँ हर तत्व तीन बार दिखाई देता है सिवाय एक के।\n   * @return वह तत्व जो केवल एक बार दिखाई देता है।\n   *\n   * उदाहरण:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * उदाहरण:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "hu": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Adott egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet, amely csak egyszer. Találja meg és adja vissza azt az elemet, amely csak egyszer jelenik meg.\n   *\n   * @param nums Egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet.\n   * @return Az az elem, amely csak egyszer jelenik meg.\n   *\n   * Példa:\n   * singleNumber(new int[]{2,2,3,2})\n   * Kimenet: 3\n   *\n   * Példa:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Kimenet: 99\n   */\n  public static int singleNumber(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "0.9847882895292052",
      "hy": "0.9747816881934296",
      "bn": "0.996282036527789",
      "bg": "0.9791420223179075",
      "zh": "0.9800648590681955",
      "fr": "0.9882744513467485",
      "de": "0.996282036527789",
      "ha": "0.9722493494656158",
      "hi": "0.996282036527789",
      "hu": "0.9881099853912516"
    },
    "canonical_solution": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }",
    "instruction": {
      "en": "Write a Java function `public static int singleNumber(int[] nums)` to solve the following problem:\nGiven an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99",
      "sq": "Shkruani një funksion Java `public static int singleNumber(int[] nums)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg të plotë nums ku çdo element shfaqet tre herë përveç njërit, i cili shfaqet vetëm një herë. Gjeni dhe ktheni elementin që shfaqet vetëm një herë.\n\n@param nums Një varg i plotë ku çdo element shfaqet tre herë përveç njërit.\n@return Elementi që shfaqet vetëm një herë.\n\nShembull:\nsingleNumber(new int[]{2,2,3,2})\nDalja: 3\n\nShembull:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nDalja: 99",
      "hy": "Գրեք Java ֆունկցիա `public static int singleNumber(int[] nums)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թվերի զանգված nums, որտեղ յուրաքանչյուր տարր հայտնվում է երեք անգամ, բացառությամբ մեկի, որը հայտնվում է միայն մեկ անգամ։ Գտեք և վերադարձեք տարրը, որը հայտնվում է միայն մեկ անգամ։\n\n@param nums Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր տարր հայտնվում է երեք անգամ, բացառությամբ մեկի։\n@return Տարրը, որը հայտնվում է միայն մեկ անգամ։\n\nՕրինակ:\nsingleNumber(new int[]{2,2,3,2})\nԵլք: 3\n\nՕրինակ:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nԵլք: 99",
      "bn": "একটি জাভা ফাংশন `public static int singleNumber(int[] nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত একটি পূর্ণসংখ্যার অ্যারে nums যেখানে প্রতিটি উপাদান তিনবার করে উপস্থিত হয়, শুধুমাত্র একটি উপাদান একবার উপস্থিত হয়। সেই উপাদানটি খুঁজে বের করুন এবং ফেরত দিন যা শুধুমাত্র একবার উপস্থিত হয়।\n\n@param nums একটি পূর্ণসংখ্যার অ্যারে যেখানে প্রতিটি উপাদান তিনবার করে উপস্থিত হয়, শুধুমাত্র একটি উপাদান একবার উপস্থিত হয়।\n@return যে উপাদানটি শুধুমাত্র একবার উপস্থিত হয়।\n\nউদাহরণ:\nsingleNumber(new int[]{2,2,3,2})\nআউটপুট: 3\n\nউদাহরণ:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nআউটপুট: 99",
      "bg": "Напишете Java функция `public static int singleNumber(int[] nums)`, за да решите следния проблем:  \nДаден е цялочислен масив nums, в който всеки елемент се появява три пъти, с изключение на един, който се появява само веднъж. Намерете и върнете елемента, който се появява само веднъж.\n\n@param nums Цялочислен масив, в който всеки елемент се появява три пъти, с изключение на един.\n@return Елементът, който се появява само веднъж.\n\nПример:\nsingleNumber(new int[]{2,2,3,2})\nИзход: 3\n\nПример:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nИзход: 99",
      "zh": "编写一个 Java 函数 `public static int singleNumber(int[] nums)` 来解决以下问题：\n给定一个整数数组 nums，其中每个元素出现三次，只有一个元素只出现一次。找出并返回只出现一次的元素。\n\n @param nums 一个整数数组，其中每个元素出现三次，只有一个元素只出现一次。\n @return 只出现一次的元素。\n\n 示例：\n singleNumber(new int[]{2,2,3,2})\n 输出: 3\n\n 示例：\n singleNumber(new int[]{0,1,0,1,0,1,99})\n 输出: 99",
      "fr": "Écrire une fonction Java `public static int singleNumber(int[] nums)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers nums où chaque élément apparaît trois fois sauf un, qui apparaît une seule fois. Trouver et retourner l'élément qui apparaît une seule fois.\n\n @param nums Un tableau d'entiers où chaque élément apparaît trois fois sauf un.\n @return L'élément qui apparaît une seule fois.\n\n Exemple :\n singleNumber(new int[]{2,2,3,2})\n Sortie : 3\n\n Exemple :\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Sortie : 99",
      "de": "Schreiben Sie eine Java-Funktion `public static int singleNumber(int[] nums)`, um das folgende Problem zu lösen:\nGegeben ist ein ganzzahliges Array nums, bei dem jedes Element dreimal vorkommt, außer einem, das nur einmal vorkommt. Finden und geben Sie das Element zurück, das nur einmal vorkommt.\n\n @param nums Ein ganzzahliges Array, bei dem jedes Element dreimal vorkommt, außer einem.\n @return Das Element, das nur einmal vorkommt.\n\n Beispiel:\n singleNumber(new int[]{2,2,3,2})\n Ausgabe: 3\n\n Beispiel:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Ausgabe: 99",
      "ha": "Rubuta aikin Java `public static int singleNumber(int[] nums)` don warware matsalar mai zuwa:\nAn ba da jerin lambobi na integer nums inda kowace alama ta bayyana sau uku sai ɗaya, wanda ya bayyana sau ɗaya kawai. Nemo kuma dawo da alamar da ta bayyana sau ɗaya kawai.\n\n@param nums Jerin lambobi na integer inda kowace alama ta bayyana sau uku sai ɗaya.\n@return Alamar da ta bayyana sau ɗaya kawai.\n\nMisali:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nMisali:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "hi": "Java फ़ंक्शन `public static int singleNumber(int[] nums)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक पूर्णांक array nums में हर तत्व तीन बार आता है सिवाय एक के, जो केवल एक बार आता है। उस तत्व को खोजें और लौटाएं जो केवल एक बार आता है।\n\n @param nums एक पूर्णांक array जहां हर तत्व तीन बार आता है सिवाय एक के।\n @return वह तत्व जो केवल एक बार आता है।\n\n उदाहरण:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n उदाहरण:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99",
      "hu": "Írj egy Java függvényt `public static int singleNumber(int[] nums)` a következő probléma megoldására:\nAdott egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet, amely csak egyszer. Találd meg és add vissza azt az elemet, amely csak egyszer jelenik meg.\n\n @param nums Egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet.\n @return Az az elem, amely csak egyszer jelenik meg.\n\n Példa:\n singleNumber(new int[]{2,2,3,2})\n Kimenet: 3\n\n Példa:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Kimenet: 99"
    },
    "instruction_bertscore": {
      "sq": "0.9957056111620257",
      "hy": "0.978820439731012",
      "bn": "0.978297247307366",
      "bg": "0.9877804575891147",
      "zh": "0.9754153191089309",
      "fr": "0.9758703813118818",
      "de": "0.9957056111620257",
      "ha": "0.9678977550779034",
      "hi": "0.9886677395011976",
      "hu": "0.9832963767372521"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "singleNumber",
    "signature": "public static int singleNumber(int[] nums)",
    "docstring": {
      "en": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99",
      "sq": "Duke pasur një varg të plotë nums ku çdo element shfaqet tre herë përveç njërit, i cili shfaqet vetëm një herë. Gjeni dhe ktheni elementin që shfaqet vetëm një herë.\n\n@param nums Një varg të plotë ku çdo element shfaqet tre herë përveç njërit.\n@return Elementi që shfaqet vetëm një herë.\n\nShembull:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nShembull:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "hy": "Տրված է ամբողջ թվերի զանգված nums, որտեղ յուրաքանչյուր տարր հանդիպում է երեք անգամ, բացի մեկից, որը հանդիպում է միայն մեկ անգամ։ Գտեք և վերադարձեք տարրը, որը հանդիպում է միայն մեկ անգամ։\n\n @param nums Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր տարր հանդիպում է երեք անգամ, բացի մեկից։\n @return Տարրը, որը հանդիպում է միայն մեկ անգամ։\n\n Օրինակ:\n singleNumber(new int[]{2,2,3,2})\n Արդյունք: 3\n\n Օրինակ:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Արդյունք: 99",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে `nums` দেওয়া আছে যেখানে প্রতিটি উপাদান তিনবার করে প্রদর্শিত হয়, শুধুমাত্র একটি উপাদান যা একবারই প্রদর্শিত হয়। যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয় তা খুঁজে বের করুন এবং ফেরত দিন।\n\n@param nums একটি পূর্ণসংখ্যার অ্যারে যেখানে প্রতিটি উপাদান তিনবার করে প্রদর্শিত হয়, শুধুমাত্র একটি উপাদান যা একবারই প্রদর্শিত হয়।\n@return যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয়।\n\nউদাহরণ:\nsingleNumber(new int[]{2,2,3,2})\nআউটপুট: 3\n\nউদাহরণ:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nআউটপুট: 99",
      "bg": "Даден е масив от цели числа nums, където всеки елемент се появява три пъти, с изключение на един, който се появява само веднъж. Намерете и върнете елемента, който се появява само веднъж.\n\n @param nums Масив от цели числа, където всеки елемент се появява три пъти, с изключение на един.\n @return Елементът, който се появява само веднъж.\n\n Пример:\n singleNumber(new int[]{2,2,3,2})\n Изход: 3\n\n Пример:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Изход: 99",
      "zh": "给定一个整数数组 nums，其中每个元素出现三次，只有一个元素出现一次。找到并返回只出现一次的元素。\n\n@param nums 一个整数数组，其中每个元素出现三次，只有一个元素出现一次。\n@return 只出现一次的元素。\n\n例子：\nsingleNumber(new int[]{2,2,3,2})\n输出: 3\n\n例子：\nsingleNumber(new int[]{0,1,0,1,0,1,99})\n输出: 99",
      "fr": "Étant donné un tableau d'entiers nums où chaque élément apparaît trois fois sauf un, qui apparaît une seule fois. Trouver et retourner l'élément qui apparaît une seule fois.\n\n @param nums Un tableau d'entiers où chaque élément apparaît trois fois sauf un.\n @return L'élément qui apparaît une seule fois.\n\n Exemple:\n singleNumber(new int[]{2,2,3,2})\n Sortie: 3\n\n Exemple:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Sortie: 99",
      "de": "Gegeben ein ganzzahliges Array nums, in dem jedes Element dreimal vorkommt, außer einem, das nur einmal vorkommt. Finde und gib das Element zurück, das nur einmal vorkommt.\n\n@param nums Ein ganzzahliges Array, in dem jedes Element dreimal vorkommt, außer einem.\n@return Das Element, das nur einmal vorkommt.\n\nBeispiel:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nBeispiel:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "ha": "An ba da wani jerin lambobi na integer nums inda kowace ƙungiya ta bayyana sau uku sai ɗaya, wanda ya bayyana sau ɗaya kawai. Nemo kuma dawo da abin da ya bayyana sau ɗaya kawai.\n\n@param nums Wani tsararren lambobi inda kowanne abu ya bayyana sau uku sai dai ɗaya.\n@return Abin da ya bayyana sau ɗaya kawai.\n\nExample:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nExample:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "hi": "दिए गए पूर्णांक array nums में हर तत्व तीन बार आता है सिवाय एक के, जो केवल एक बार आता है। उस तत्व को खोजें और लौटाएं जो केवल एक बार आता है।\n\n@param nums एक पूर्णांक array जिसमें हर तत्व तीन बार आता है सिवाय एक के।\n@return वह तत्व जो केवल एक बार आता है।\n\nउदाहरण:\nsingleNumber(new int[]{2,2,3,2})\nआउटपुट: 3\n\nउदाहरण:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nआउटपुट: 99",
      "hu": "Adott egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet, amely csak egyszer jelenik meg. Találd meg és add vissza azt az elemet, amely csak egyszer jelenik meg.\n\n @param nums Egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet.\n @return Az az elem, amely csak egyszer jelenik meg.\n\n Példa:\n singleNumber(new int[]{2,2,3,2})\n Kimenet: 3\n\n Példa:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Kimenet: 99"
    },
    "docstring_bertscore": {
      "sq": "0.9845243097528098",
      "hy": "0.9657420195525318",
      "bn": "0.9586237025873845",
      "bg": "0.9614831855527628",
      "zh": "0.9706195871892245",
      "fr": "0.9792828512580611",
      "de": "1",
      "ha": "0.9926179018888384",
      "hi": "0.9945398494557319",
      "hu": "0.9812737235671738"
    }
  },
  {
    "task_id": "Java/36",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "sq": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Gjej të gjitha numrat hapës në intervalin [low, high] ku një numër hapës përcaktohet si një numër ku çdo shifër është ose një më shumë ose një më pak se shifra ngjitur.\n   *\n   * @param low Kufiri i poshtëm i intervalit.\n   * @param high Kufiri i sipërm i intervalit.\n   * @return Një listë e numrave hapës brenda intervalit [low, high] të renditur në rritje.\n   *\n   * Shembull:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "hy": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Գտնել բոլոր քայլող թվերը [low, high] միջակայքում, որտեղ քայլող թիվը սահմանվում է որպես թիվ, որտեղ յուրաքանչյուր թվանշանը կամ մեկով ավել է, կամ մեկով պակաս հարևան թվանշանից։\n   *\n   * @param low Միջակայքի ստորին սահմանը։\n   * @param high Միջակայքի վերին սահմանը։\n   * @return Քայլող թվերի ցուցակ [low, high] միջակայքում, դասավորված աճման կարգով։\n   *\n   * Օրինակ:\n   * findSteppingNumbers(0, 21)\n   * Արդյունք: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "bn": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * [low, high] সীমার মধ্যে সমস্ত স্টেপিং সংখ্যা খুঁজুন যেখানে একটি স্টেপিং সংখ্যা সংজ্ঞায়িত করা হয় এমন একটি সংখ্যা হিসাবে যেখানে প্রতিটি অঙ্ক সংলগ্ন অঙ্কের চেয়ে এক বেশি বা এক কম।\n   *\n   * @param low সীমার নিম্ন সীমা।\n   * @param high সীমার উপরের সীমা।\n   * @return [low, high] সীমার মধ্যে ক্রমবর্ধমান ক্রমে সাজানো স্টেপিং সংখ্যার একটি তালিকা।\n   *\n   * উদাহরণ:\n   * findSteppingNumbers(0, 21)\n   * আউটপুট: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "bg": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Намерете всички стъпкови числа в диапазона [low, high], където стъпково число е дефинирано като число, при което всяка цифра е или с едно повече, или с едно по-малко от съседната цифра.\n   *\n   * @param low Долна граница на диапазона.\n   * @param high Горна граница на диапазона.\n   * @return Списък със стъпкови числа в диапазона [low, high], сортирани във възходящ ред.\n   *\n   * Пример:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "zh": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * 找到范围 [low, high] 内的所有阶梯数，其中阶梯数被定义为每个数字与相邻数字相差一的数字。\n   *\n   * @param low 范围的下限。\n   * @param high 范围的上限。\n   * @return 范围 [low, high] 内按升序排列的阶梯数列表。\n   *\n   * 示例:\n   * findSteppingNumbers(0, 21)\n   * 输出: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "fr": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Trouver tous les nombres à pas dans la plage [low, high] où un nombre à pas est défini comme un nombre où chaque chiffre est soit un de plus, soit un de moins que le chiffre adjacent.\n   *\n   * @param low La borne inférieure de la plage.\n   * @param high La borne supérieure de la plage.\n   * @return Une liste de nombres à pas dans la plage [low, high] triés par ordre croissant.\n   *\n   * Exemple:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "de": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Finde alle Stepping-Nummern im Bereich [low, high], wobei eine Stepping-Nummer als eine Zahl definiert ist, bei der jede Ziffer entweder eins mehr oder eins weniger als die benachbarte Ziffer ist.\n   *\n   * @param low Die untere Grenze des Bereichs.\n   * @param high Die obere Grenze des Bereichs.\n   * @return Eine Liste von Stepping-Nummern innerhalb des Bereichs [low, high], sortiert in aufsteigender Reihenfolge.\n   *\n   * Beispiel:\n   * findSteppingNumbers(0, 21)\n   * Ausgabe: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "ha": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Nemo duk lambobin mataki a cikin kewayon [low, high] inda ake ayyana lambar mataki a matsayin lamba inda kowace lamba tana da ɗaya fiye ko ɗaya ƙasa da lambobin da ke kusa da ita.\n   *\n   * @param low Ƙananan iyaka na kewayon.\n   * @param high Babban iyaka na kewayon.\n   * @return Jerin lambobin mataki a cikin kewayon [low, high] da aka jera a tsari mai tashi.\n   *\n   * Misali:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "hi": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * उन सभी स्टेपिंग नंबरों को खोजें जो [low, high] रेंज में हैं, जहाँ एक स्टेपिंग नंबर को एक संख्या के रूप में परिभाषित किया जाता है जहाँ प्रत्येक अंक या तो अगले अंक से एक अधिक या एक कम होता है।\n   *\n   * @param low रेंज की निचली सीमा।\n   * @param high रेंज की ऊपरी सीमा।\n   * @return [low, high] रेंज के भीतर स्टेपिंग नंबरों की एक सूची जो आरोही क्रम में सॉर्ट की गई है।\n   *\n   * उदाहरण:\n   * findSteppingNumbers(0, 21)\n   * आउटपुट: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "hu": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Keresse meg az összes lépő számot a [low, high] tartományban, ahol a lépő szám olyan szám, amelyben minden számjegy vagy eggyel több, vagy eggyel kevesebb, mint a szomszédos számjegy.\n   *\n   * @param low A tartomány alsó határa.\n   * @param high A tartomány felső határa.\n   * @return A [low, high] tartományon belüli lépő számok listája növekvő sorrendben rendezve.\n   *\n   * Példa:\n   * findSteppingNumbers(0, 21)\n   * Kimenet: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) "
    },
    "prompt_bertscore": {
      "sq": "0.9782748020743091",
      "hy": "0.9702946278858514",
      "bn": "0.988749773848565",
      "bg": "0.9728388844365273",
      "zh": "0.9671779185770331",
      "fr": "0.9974005242033964",
      "de": "0.9929889434406115",
      "ha": "0.9767932180621699",
      "hi": "0.9838457883711946",
      "hu": "0.983529370174206"
    },
    "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "instruction": {
      "en": "Write a Java function `public static List<Integer> findSteppingNumbers(int low, int high)` to solve the following problem:\nFind all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "sq": "Shkruani një funksion Java `public static List<Integer> findSteppingNumbers(int low, int high)` për të zgjidhur problemin në vijim:\nGjeni të gjitha numrat stepping në intervalin [low, high] ku një numër stepping është i përcaktuar si një numër ku secila shifër është ose një më shumë ose një më pak se shifra ngjitur.\n\n@param low Kufiri i poshtëm i intervalit.\n@param high Kufiri i sipërm i intervalit.\n@return Një listë e numrave stepping brenda intervalit [low, high] e renditur në rritje.\n\nShembull:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hy": "Գրեք Java ֆունկցիա `public static List<Integer> findSteppingNumbers(int low, int high)` հետևյալ խնդիրը լուծելու համար:\nԳտեք բոլոր քայլող թվերը [low, high] միջակայքում, որտեղ քայլող թիվը սահմանվում է որպես թիվ, որի յուրաքանչյուր թվանշանը կամ մեկով ավելի է, կամ մեկով պակաս հարակից թվանշանից։\n\n@param low Միջակայքի ստորին սահմանը։\n@param high Միջակայքի վերին սահմանը։\n@return Քայլող թվերի ցուցակ [low, high] միջակայքում, դասավորված աճման կարգով։\n\nՕրինակ:\nfindSteppingNumbers(0, 21)\nԵլք: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "bn": "একটি জাভা ফাংশন `public static List<Integer> findSteppingNumbers(int low, int high)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n[low, high] সীমার মধ্যে সমস্ত স্টেপিং সংখ্যা খুঁজুন যেখানে একটি স্টেপিং সংখ্যা সংজ্ঞায়িত করা হয় এমন একটি সংখ্যা হিসাবে যেখানে প্রতিটি অঙ্ক হয় পাশের অঙ্কের চেয়ে এক বেশি বা এক কম।\n\n@param low সীমার নিম্ন সীমা।\n@param high সীমার উচ্চ সীমা।\n@return [low, high] সীমার মধ্যে স্টেপিং সংখ্যার একটি তালিকা যা ঊর্ধ্বক্রমে সাজানো।\n\nউদাহরণ:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "bg": "Напишете Java функция `public static List<Integer> findSteppingNumbers(int low, int high)` за решаване на следния проблем:\nНамерете всички стъпкови числа в диапазона [low, high], където стъпково число се определя като число, при което всяка цифра е или с едно повече, или с едно по-малко от съседната цифра.\n\n@param low Долна граница на диапазона.\n@param high Горна граница на диапазона.\n@return Списък от стъпкови числа в диапазона [low, high], сортирани във възходящ ред.\n\nПример:\nfindSteppingNumbers(0, 21)\nИзход: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "zh": "编写一个 Java 函数 `public static List<Integer> findSteppingNumbers(int low, int high)` 来解决以下问题：\n在范围 [low, high] 中查找所有的阶梯数，其中阶梯数被定义为每个数字与相邻数字相差 1 的数字。\n\n@param low 范围的下限。\n@param high 范围的上限。\n@return 范围 [low, high] 内按升序排序的阶梯数列表。\n\n示例：\nfindSteppingNumbers(0, 21)\n输出: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "fr": "Écrire une fonction Java `public static List<Integer> findSteppingNumbers(int low, int high)` pour résoudre le problème suivant :\nTrouver tous les nombres à pas dans la plage [low, high] où un nombre à pas est défini comme un nombre où chaque chiffre est soit un de plus, soit un de moins que le chiffre adjacent.\n\n@param low La borne inférieure de la plage.\n@param high La borne supérieure de la plage.\n@return Une liste de nombres à pas dans la plage [low, high] triée par ordre croissant.\n\nExemple :\nfindSteppingNumbers(0, 21)\nSortie : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "de": "Schreiben Sie eine Java-Funktion `public static List<Integer> findSteppingNumbers(int low, int high)`, um das folgende Problem zu lösen:\nFinden Sie alle Stepping-Nummern im Bereich [low, high], wobei eine Stepping-Nummer als eine Zahl definiert ist, bei der jede Ziffer entweder eins mehr oder eins weniger als die benachbarte Ziffer ist.\n\n@param low Die untere Grenze des Bereichs.\n@param high Die obere Grenze des Bereichs.\n@return Eine Liste von Stepping-Nummern innerhalb des Bereichs [low, high], sortiert in aufsteigender Reihenfolge.\n\nBeispiel:\nfindSteppingNumbers(0, 21)\nAusgabe: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "ha": "Rubuta aikin Java `public static List<Integer> findSteppingNumbers(int low, int high)` don warware matsalar mai zuwa:\nNemo duk lambobin mataki a cikin zangon [low, high] inda aka ayyana lambar mataki a matsayin lamba inda kowace lamba tana da ɗaya fiye ko ɗaya ƙasa da lambobi masu makwabtaka.\n\n@param low Ƙananan iyaka na zangon.\n@param high Babban iyaka na zangon.\n@return Jerin lambobin mataki a cikin zangon [low, high] an jera su a cikin tsari mai tashi.\n\nMisali:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hi": "Java फ़ंक्शन `public static List<Integer> findSteppingNumbers(int low, int high)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन सभी स्टेपिंग संख्याओं को खोजें जो [low, high] सीमा में हैं, जहाँ एक स्टेपिंग संख्या को इस प्रकार परिभाषित किया गया है कि प्रत्येक अंक अपने आसन्न अंक से या तो एक अधिक या एक कम होता है।\n\n@param low सीमा की निचली सीमा।\n@param high सीमा की ऊपरी सीमा।\n@return [low, high] सीमा के भीतर स्टेपिंग संख्याओं की एक सूची जो आरोही क्रम में सॉर्ट की गई है।\n\nउदाहरण:\nfindSteppingNumbers(0, 21)\nआउटपुट: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hu": "Írj egy Java függvényt `public static List<Integer> findSteppingNumbers(int low, int high)` a következő probléma megoldására:\nTaláld meg az összes stepping számot a [low, high] tartományban, ahol a stepping szám olyan szám, amelyben minden számjegy vagy eggyel nagyobb, vagy eggyel kisebb, mint a szomszédos számjegy.\n\n@param low A tartomány alsó határa.\n@param high A tartomány felső határa.\n@return A stepping számok listája a [low, high] tartományban növekvő sorrendben rendezve.\n\nPélda:\nfindSteppingNumbers(0, 21)\nKimenet: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]"
    },
    "instruction_bertscore": {
      "sq": "0.9977364081777265",
      "hy": "0.9894284938605612",
      "bn": "0.9930181421066236",
      "bg": "0.9696639764260657",
      "zh": "0.9589844153593439",
      "fr": "0.9982230526112619",
      "de": "0.9907642831730208",
      "ha": "0.9690990716224025",
      "hi": "0.9651143475484616",
      "hu": "0.9794498994085115"
    },
    "level": "middle",
    "test": "  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "findSteppingNumbers",
    "signature": "public static List<Integer> findSteppingNumbers(int low, int high)",
    "docstring": {
      "en": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "sq": "Gjeni të gjitha numrat hapës në intervalin [low, high] ku një numër hapës është i përcaktuar si një numër ku çdo shifër është ose një më shumë ose një më pak se shifra ngjitur.\n\n@param low Kufiri i poshtëm i intervalit.\n@param high Kufiri i sipërm i intervalit.\n@return Një listë e numrave hapës brenda intervalit [low, high] të renditur në rritje.\n\nShembull:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hy": "Գտնել բոլոր քայլող թվերը [low, high] միջակայքում, որտեղ քայլող թիվը սահմանվում է որպես թիվ, որի յուրաքանչյուր թվանշանը կամ մեկով ավել կամ մեկով պակաս է հարակից թվանշանից։\n\n@param low Միջակայքի ստորին սահմանը։\n@param high Միջակայքի վերին սահմանը։\n@return Քայլող թվերի ցուցակ [low, high] միջակայքում, դասավորված աճման կարգով։\n\nՕրինակ:\nfindSteppingNumbers(0, 21)\nԵլք: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "bn": "Find all stepping numbers in the range [low, high] যেখানে একটি stepping number সংজ্ঞায়িত হয় এমন একটি সংখ্যা হিসেবে যেখানে প্রতিটি অঙ্ক সংলগ্ন অঙ্কের চেয়ে এক বেশি বা এক কম হয়।\n\n@param low পরিসরের নিম্ন সীমা।\n@param high পরিসরের উপরের সীমা।\n@return পরিসর [low, high] এর মধ্যে থাকা stepping numbers এর একটি তালিকা যা ঊর্ধ্বক্রমে সাজানো।\n\nউদাহরণ:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "bg": "Намерете всички стъпкови числа в диапазона [low, high], където стъпково число е число, при което всяка цифра е или с едно повече, или с едно по-малко от съседната цифра.\n\n@param low Долна граница на диапазона.\n@param high Горна граница на диапазона.\n@return Списък със стъпкови числа в диапазона [low, high], сортирани във възходящ ред.\n\nПример:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "zh": "在范围 [low, high] 中查找所有的阶梯数，其中阶梯数被定义为每个数字与相邻数字相差1的数字。\n\n@param low 范围的下界。\n@param high 范围的上界。\n@return 范围 [low, high] 内按升序排序的阶梯数列表。\n\n示例：\nfindSteppingNumbers(0, 21)\n输出: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "fr": "Trouver tous les nombres à pas dans la plage [low, high] où un nombre à pas est défini comme un nombre où chaque chiffre est soit un de plus, soit un de moins que le chiffre adjacent.\n\n@param low La borne inférieure de la plage.\n@param high La borne supérieure de la plage.\n@return Une liste de nombres à pas dans la plage [low, high] triée par ordre croissant.\n\nExemple:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "de": "Finde alle Stepping-Nummern im Bereich [low, high], wobei eine Stepping-Nummer als eine Zahl definiert ist, bei der jede Ziffer entweder eins mehr oder eins weniger als die benachbarte Ziffer ist.\n\n@param low Die untere Grenze des Bereichs.\n@param high Die obere Grenze des Bereichs.\n@return Eine Liste von Stepping-Nummern innerhalb des Bereichs [low, high], sortiert in aufsteigender Reihenfolge.\n\nBeispiel:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "ha": "Nemo duk lambobin mataki a cikin kewayon [low, high] inda ake ayyana lambar mataki a matsayin lamba inda kowace lamba tana da ɗaya fiye ko ɗaya ƙasa da lambobin da ke kusa da ita.\n\n@param low Ƙananan iyaka na kewayon.\n@param high Babban iyaka na kewayon.\n@return Jerin lambobin stepping a cikin kewayon [low, high] da aka tsara a cikin tsari mai hawa.\n\nMisali:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hi": "उन सभी स्टेपिंग नंबरों को खोजें जो [low, high] रेंज में हैं, जहाँ एक स्टेपिंग नंबर को एक संख्या के रूप में परिभाषित किया जाता है जहाँ प्रत्येक अंक या तो अगले अंक से एक अधिक या एक कम होता है।\n\n@param low सीमा का निचला बाउंड।\n@param high सीमा का ऊपरी बाउंड।\n@return सीमा [low, high] के भीतर सभी स्टेपिंग नंबरों की एक सूची जो आरोही क्रम में सॉर्ट की गई है।\n\nउदाहरण:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hu": "Találja meg az összes lépőszámot a [low, high] tartományban, ahol a lépőszám olyan szám, amelyben minden számjegy vagy eggyel több, vagy eggyel kevesebb, mint a szomszédos számjegy.\n\n@param low A tartomány alsó határa.\n@param high A tartomány felső határa.\n@return A [low, high] tartományon belüli lépőszámok listája növekvő sorrendben rendezve.\n\nPélda:\nfindSteppingNumbers(0, 21)\nKimenet: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]"
    },
    "docstring_bertscore": {
      "sq": "0.9709095875455355",
      "hy": "0.9649766966944043",
      "bn": "0.9715120334912143",
      "bg": "0.9547184306658576",
      "zh": "0.9505316994944042",
      "fr": "0.9981372442866548",
      "de": "0.9876924643303162",
      "ha": "0.9701452578393132",
      "hi": "0.9838169869659446",
      "hu": "0.977784979554677"
    }
  },
  {
    "task_id": "Java/37",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Llogarit numrin e herëve që shfaqet shifra 1 në të gjitha numrat të plotë jo-negativë më të vegjël ose të barabartë me n.\n   *\n   * @param n Një numër i plotë që përfaqëson kufirin e sipërm.\n   * @return Numri i herëve që shfaqet shifra 1.\n   *\n   * Shembull:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Shembull:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Հաշվեք, թե քանի անգամ է թվանշան 1-ը հայտնվում բոլոր ոչ բացասական ամբողջ թվերում, որոնք փոքր կամ հավասար են n-ին:\n   *\n   * @param n Ամբողջ թիվ, որը ներկայացնում է վերին սահմանը:\n   * @return Թվանշան 1-ի հայտնվելու քանակը:\n   *\n   * Օրինակ:\n   * countDigitOne(13)\n   * Արդյունք: 6\n   *\n   * Օրինակ:\n   * countDigitOne(0)\n   * Արդյունք: 0\n   */\n  public static int countDigitOne(int n)",
      "bn": "public class Solution {\n\n  /**\n   * সমস্ত অ-ঋণাত্মক পূর্ণসংখ্যায় সংখ্যা 1 কতবার উপস্থিত হয় তা গণনা করুন যা n এর চেয়ে কম বা সমান।\n   *\n   * @param n একটি পূর্ণসংখ্যা যা উপরের সীমা নির্দেশ করে।\n   * @return সংখ্যা 1 কতবার উপস্থিত হয়।\n   *\n   * উদাহরণ:\n   * countDigitOne(13)\n   * আউটপুট: 6\n   *\n   * উদাহরণ:\n   * countDigitOne(0)\n   * আউটপুট: 0\n   */\n  public static int countDigitOne(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Изчислете колко пъти цифрата 1 се появява във всички неотрицателни цели числа, по-малки или равни на n.\n   *\n   * @param n Цяло число, представляващо горната граница.\n   * @return Броят на пъти, когато цифрата 1 се появява.\n   *\n   * Пример:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Пример:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 计算数字1在所有小于或等于n的非负整数中出现的次数。\n   *\n   * @param n 表示上限的整数。\n   * @return 数字1出现的次数。\n   *\n   * 示例:\n   * countDigitOne(13)\n   * 输出: 6\n   *\n   * 示例:\n   * countDigitOne(0)\n   * 输出: 0\n   */\n  public static int countDigitOne(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Calculer le nombre de fois que le chiffre 1 apparaît dans tous les entiers non négatifs inférieurs ou égaux à n.\n   *\n   * @param n Un entier représentant la limite supérieure.\n   * @return Le nombre de fois que le chiffre 1 apparaît.\n   *\n   * Exemple :\n   * countDigitOne(13)\n   * Sortie : 6\n   *\n   * Exemple :\n   * countDigitOne(0)\n   * Sortie : 0\n   */\n  public static int countDigitOne(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Berechne, wie oft die Ziffer 1 in allen nicht-negativen ganzen Zahlen kleiner oder gleich n erscheint.\n   *\n   * @param n Eine ganze Zahl, die die obere Grenze darstellt.\n   * @return Die Anzahl der Vorkommen der Ziffer 1.\n   *\n   * Beispiel:\n   * countDigitOne(13)\n   * Ausgabe: 6\n   *\n   * Beispiel:\n   * countDigitOne(0)\n   * Ausgabe: 0\n   */\n  public static int countDigitOne(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * Lissafi adadin lokutan da lamba 1 ta bayyana a cikin duk lambobin da ba su da kyau ƙasa da ko daidai da n.\n   *\n   * @param n Lamba mai nuni da iyaka ta sama.\n   * @return Adadin lokutan da lamba 1 ta bayyana.\n   *\n   * Misali:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Misali:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * सभी गैर-ऋणात्मक पूर्णांकों में अंक 1 कितनी बार प्रकट होता है, इसकी गणना करें जो n से कम या उसके बराबर हैं।\n   *\n   * @param n एक पूर्णांक जो ऊपरी सीमा का प्रतिनिधित्व करता है।\n   * @return अंक 1 कितनी बार प्रकट होता है।\n   *\n   * उदाहरण:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * उदाहरण:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Számolja meg, hogy hányszor jelenik meg az 1-es számjegy az összes nem negatív egész szám között, amelyek kisebbek vagy egyenlőek n-nel.\n   *\n   * @param n Egy egész szám, amely a felső határt jelenti.\n   * @return Az 1-es számjegy megjelenésének száma.\n   *\n   * Példa:\n   * countDigitOne(13)\n   * Kimenet: 6\n   *\n   * Példa:\n   * countDigitOne(0)\n   * Kimenet: 0\n   */\n  public static int countDigitOne(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9983638815514156",
      "hy": "0.9636452772503276",
      "bn": "0.9581853253364405",
      "bg": "0.9917951748505919",
      "zh": "1",
      "fr": "1",
      "de": "0.9774773010944541",
      "ha": "0.9814318333504776",
      "hi": "0.9731294806839813",
      "hu": "0.9750101131316197"
    },
    "canonical_solution": "  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }",
    "instruction": {
      "en": "Write a Java function `public static int countDigitOne(int n)` to solve the following problem:\nCalculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0",
      "sq": "Shkruani një funksion Java `public static int countDigitOne(int n)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni sa herë shfaqet shifra 1 në të gjitha numrat e plotë jo-negativë më të vegjël ose të barabartë me n.\n\n    @param n Një numër i plotë që përfaqëson kufirin e sipërm.\n    @return Numri i herëve që shifra 1 shfaqet.\n\n    Shembull:\n    countDigitOne(13)\n    Output: 6\n\n    Shembull:\n    countDigitOne(0)\n    Output: 0",
      "hy": "Գրեք Java ֆունկցիա `public static int countDigitOne(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք, թե քանի անգամ է թվանշան 1-ը հայտնվում բոլոր ոչ բացասական ամբողջ թվերում, որոնք փոքր կամ հավասար են n-ին:\n\n    @param n Թիվ, որը ներկայացնում է վերին սահմանը։\n    @return Թվանշան 1-ի հայտնվելու քանակը։\n   \n    Օրինակ:\n    countDigitOne(13)\n    Արդյունք: 6\n   \n    Օրինակ:\n    countDigitOne(0)\n    Արդյունք: 0",
      "bn": "একটি জাভা ফাংশন `public static int countDigitOne(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn এর চেয়ে ছোট বা সমান সমস্ত অ-ঋণাত্মক পূর্ণসংখ্যায় সংখ্যা 1 কতবার প্রদর্শিত হয় তা গণনা করুন।\n\n    @param n উপরের সীমা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n    @return সংখ্যা 1 কতবার প্রদর্শিত হয়।\n\n    উদাহরণ:\n    countDigitOne(13)\n    আউটপুট: 6\n\n    উদাহরণ:\n    countDigitOne(0)\n    আউটপুট: 0",
      "bg": "Напишете Java функция `public static int countDigitOne(int n)`, за да решите следния проблем:  \nИзчислете колко пъти цифрата 1 се появява във всички неотрицателни цели числа, по-малки или равни на n.\n   \n    @param n Цяло число, представляващо горната граница.\n    @return Броят пъти, в които се появява цифрата 1.\n   \n    Пример:\n    countDigitOne(13)\n    Изход: 6\n   \n    Пример:\n    countDigitOne(0)\n    Изход: 0",
      "zh": "编写一个 Java 函数 `public static int countDigitOne(int n)` 来解决以下问题：\n计算在所有小于或等于 n 的非负整数中，数字 1 出现的次数。\n   \n    @param n 表示上限的整数。\n    @return 数字 1 出现的次数。\n   \n    示例：\n    countDigitOne(13)\n    输出: 6\n   \n    示例：\n    countDigitOne(0)\n    输出: 0",
      "fr": "Écrire une fonction Java `public static int countDigitOne(int n)` pour résoudre le problème suivant :  \nCalculer le nombre de fois que le chiffre 1 apparaît dans tous les entiers non négatifs inférieurs ou égaux à n.\n   \n    @param n Un entier représentant la limite supérieure.\n    @return Le nombre de fois que le chiffre 1 apparaît.\n   \n    Exemple:\n    countDigitOne(13)\n    Output: 6\n   \n    Exemple:\n    countDigitOne(0)\n    Output: 0",
      "de": "Schreiben Sie eine Java-Funktion `public static int countDigitOne(int n)`, um das folgende Problem zu lösen:\nBerechnen Sie, wie oft die Ziffer 1 in allen nicht-negativen ganzen Zahlen kleiner oder gleich n erscheint.\n   \n    @param n Ein ganzzahliger Wert, der die Obergrenze darstellt.\n    @return Die Anzahl der Vorkommen der Ziffer 1.\n   \n    Beispiel:\n    countDigitOne(13)\n    Ausgabe: 6\n   \n    Beispiel:\n    countDigitOne(0)\n    Ausgabe: 0",
      "ha": "Rubuta aikin Java `public static int countDigitOne(int n)` don magance matsalar mai zuwa:\nƘididdige sau nawa lamba 1 ta bayyana a cikin duk lambobi marasa kyau waɗanda suka yi ƙasa ko daidai da n.\n   \n    @param n Wani cikakken lamba da ke wakiltar iyaka ta sama.\n    @return Adadin sau nawa lamba 1 ta bayyana.\n   \n    Misali:\n    countDigitOne(13)\n    Fitarwa: 6\n   \n    Misali:\n    countDigitOne(0)\n    Fitarwa: 0",
      "hi": "Java फ़ंक्शन `public static int countDigitOne(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगणना करें कि अंक 1 कितनी बार सभी गैर-ऋणात्मक पूर्णांकों में n से कम या उसके बराबर दिखाई देता है।\n\n    @param n एक पूर्णांक जो ऊपरी सीमा का प्रतिनिधित्व करता है।\n    @return वह संख्या जो दर्शाती है कि अंक 1 कितनी बार दिखाई देता है।\n   \n    उदाहरण:\n    countDigitOne(13)\n    Output: 6\n   \n    उदाहरण:\n    countDigitOne(0)\n    Output: 0",
      "hu": "Írj egy Java függvényt `public static int countDigitOne(int n)` a következő probléma megoldására:\nSzámold ki, hogy az 1-es számjegy hányszor jelenik meg az összes nem negatív egész szám között, amelyek kisebbek vagy egyenlőek n-nél.\n   \n    @param n Egy egész szám, amely a felső határt jelenti.\n    @return Az 1-es számjegy megjelenésének száma.\n   \n    Példa:\n    countDigitOne(13)\n    Kimenet: 6\n   \n    Példa:\n    countDigitOne(0)\n    Kimenet: 0"
    },
    "instruction_bertscore": {
      "sq": "0.9946091714587131",
      "hy": "0.9510572754826225",
      "bn": "0.9600711221739857",
      "bg": "0.9918758187852921",
      "zh": "0.9897582202930791",
      "fr": "0.999999801369619",
      "de": "0.9778558906007065",
      "ha": "0.9713638552269622",
      "hi": "0.9590402304964146",
      "hu": "0.9837963294063169"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "countDigitOne",
    "signature": "public static int countDigitOne(int n)",
    "docstring": {
      "en": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0",
      "sq": "Llogarit numrin e herëve që shfaqet shifra 1 në të gjitha numrat e plotë jo-negativë më të vegjël ose të barabartë me n.\n\n    @param n Një numër i plotë që përfaqëson kufirin e sipërm.\n    @return Numri i herëve që shfaqet shifra 1.\n\n    Shembull:\n    countDigitOne(13)\n    Output: 6\n\n    Shembull:\n    countDigitOne(0)\n    Output: 0",
      "hy": "Հաշվել, թե քանի անգամ է թիվ 1-ը հայտնվում բոլոր ոչ բացասական ամբողջ թվերում, որոնք փոքր կամ հավասար են n-ին:\n\n    @param n Ամբողջ թիվ, որը ներկայացնում է վերին սահմանը:\n    @return Թիվ 1-ի հայտնվելու քանակը:\n   \n    Օրինակ:\n    countDigitOne(13)\n    Արդյունք: 6\n   \n    Օրինակ:\n    countDigitOne(0)\n    Արդյունք: 0",
      "bn": "সমস্ত অ-ঋণাত্মক পূর্ণসংখ্যায় সংখ্যা 1 কতবার উপস্থিত হয় তা গণনা করুন যা n এর চেয়ে কম বা সমান।\n   \n    @param n একটি পূর্ণসংখ্যা যা উপরের সীমা নির্দেশ করে।\n    @return সংখ্যা 1 কতবার প্রদর্শিত হয়।\n\n    উদাহরণ:\n    countDigitOne(13)\n    Output: 6\n\n    উদাহরণ:\n    countDigitOne(0)\n    Output: 0",
      "bg": "Изчислете колко пъти цифрата 1 се появява във всички неотрицателни цели числа, по-малки или равни на n.\n   \n    @param n Цяло число, представляващо горната граница.\n    @return Броят пъти, когато цифрата 1 се появява.\n   \n    Пример:\n    countDigitOne(13)\n    Output: 6\n   \n    Пример:\n    countDigitOne(0)\n    Output: 0",
      "zh": "计算在所有小于或等于 n 的非负整数中，数字 1 出现的次数。\n\n    @param n 一个整数，表示上限。\n    @return 数字 1 出现的次数。\n   \n    示例:\n    countDigitOne(13)\n    输出: 6\n   \n    示例:\n    countDigitOne(0)\n    输出: 0",
      "fr": "Calculer le nombre de fois que le chiffre 1 apparaît dans tous les entiers non négatifs inférieurs ou égaux à n.\n   \n    @param n Un entier représentant la limite supérieure.\n    @return Le nombre de fois que le chiffre 1 apparaît.\n   \n    Exemple:\n    countDigitOne(13)\n    Output: 6\n   \n    Exemple:\n    countDigitOne(0)\n    Output: 0",
      "de": "Berechne, wie oft die Ziffer 1 in allen nicht-negativen ganzen Zahlen kleiner oder gleich n vorkommt.\n   \n    @param n Eine ganze Zahl, die die obere Grenze darstellt.\n    @return Die Anzahl der Vorkommen der Ziffer 1.\n   \n    Beispiel:\n    countDigitOne(13)\n    Ausgabe: 6\n   \n    Beispiel:\n    countDigitOne(0)\n    Ausgabe: 0",
      "ha": "Ƙididdige adadin lokutan da lamba 1 ta bayyana a cikin dukkan lambobin da ba su da korafi ƙasa da ko daidai da n.\n\n    @param n Wani lamba da ke wakiltar iyaka mafi girma.\n    @return Adadin lokutan da lamba 1 ta bayyana.\n\n    Misali:\n    countDigitOne(13)\n    Output: 6\n\n    Misali:\n    countDigitOne(0)\n    Output: 0",
      "hi": "सभी गैर-ऋणात्मक पूर्णांकों में अंक 1 कितनी बार प्रकट होता है, इसकी गणना करें जो n से कम या उसके बराबर हैं।\n\n    @param n ऊपरी सीमा का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    @return अंक 1 जितनी बार प्रकट होता है, उसकी संख्या।\n\n    उदाहरण:\n    countDigitOne(13)\n    Output: 6\n\n    उदाहरण:\n    countDigitOne(0)\n    Output: 0",
      "hu": "Számítsa ki, hogy az 1-es számjegy hányszor jelenik meg az összes nem negatív egész számokban, amelyek kisebbek vagy egyenlőek n-nél.\n   \n    @param n Egy egész szám, amely a felső határt jelenti.\n    @return Az 1-es számjegy megjelenésének száma.\n   \n    Példa:\n    countDigitOne(13)\n    Kimenet: 6\n   \n    Példa:\n    countDigitOne(0)\n    Kimenet: 0"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9481040389773958",
      "bn": "0.9806039419223243",
      "bg": "0.9911456535046078",
      "zh": "1",
      "fr": "1",
      "de": "0.9725212744572526",
      "ha": "0.9723725003018574",
      "hi": "0.9733902823742802",
      "hu": "0.9719371025066289"
    }
  },
  {
    "task_id": "Java/38",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke dhënë një numër të plotë n, përcaktoni nëse është fuqi e dy.\n   * Nëse është, kthe true; përndryshe, kthe false.\n   * Një numër n është fuqi e dy nëse ekziston një numër i plotë x i tillë që n == 2^x.\n   *\n   * @param n Numri i plotë që do të kontrollohet.\n   * @return True nëse n është fuqi e dy, false përndryshe.\n   *\n   * Shembull:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Shembull:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Shembull:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Shembull:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Shembull:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, որոշել՝ արդյոք այն երկուսի աստիճան է:\n   * Եթե այո, վերադարձնել true; հակառակ դեպքում՝ false:\n   * Թիվ n-ը երկուսի աստիճան է, եթե գոյություն ունի ամբողջ թիվ x, այնպես որ n == 2^x:\n   *\n   * @param n Ստուգվող ամբողջ թիվը:\n   * @return True, եթե n-ը երկուսի աստիճան է, false՝ հակառակ դեպքում:\n   *\n   * Օրինակ:\n   * isPowerOfTwo(1)\n   * Արդյունք: true\n   *\n   * Օրինակ:\n   * isPowerOfTwo(16)\n   * Արդյունք: true\n   *\n   * Օրինակ:\n   * isPowerOfTwo(3)\n   * Արդյունք: false\n   *\n   * Օրինակ:\n   * isPowerOfTwo(4)\n   * Արդյունք: true\n   *\n   * Օրինակ:\n   * isPowerOfTwo(5)\n   * Արդյունք: false\n   */\n  public static boolean isPowerOfTwo(int n)",
      "bn": "public class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, এটি দুইয়ের ঘাত কিনা তা নির্ধারণ করুন।\n   * যদি হয়, তাহলে true ফেরত দিন; অন্যথায়, false ফেরত দিন।\n   * একটি সংখ্যা n দুইয়ের ঘাত যদি কোনো পূর্ণসংখ্যা x বিদ্যমান থাকে যাতে n == 2^x হয়।\n   *\n   * @param n যে পূর্ণসংখ্যাটি পরীক্ষা করা হবে।\n   * @return যদি n দুইয়ের ঘাত হয় তবে True, অন্যথায় false।\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(1)\n   * আউটপুট: true\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(16)\n   * আউটপুট: true\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(3)\n   * আউটপুট: false\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(4)\n   * আউটপুট: true\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(5)\n   * আউটপুট: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е цяло число n, определете дали е степен на две.\n   * Ако е, върнете true; в противен случай върнете false.\n   * Число n е степен на две, ако съществува цяло число x, такова че n == 2^x.\n   *\n   * @param n Цялото число, което ще бъде проверено.\n   * @return True ако n е степен на две, false в противен случай.\n   *\n   * Пример:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Пример:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Пример:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Пример:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Пример:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个整数 n，确定它是否是二的幂。\n   * 如果是，返回 true；否则，返回 false。\n   * 如果存在一个整数 x 使得 n == 2^x，则数字 n 是二的幂。\n   *\n   * @param n 要检查的整数。\n   * @return 如果 n 是二的幂则返回 true，否则返回 false。\n   *\n   * 示例:\n   * isPowerOfTwo(1)\n   * 输出: true\n   *\n   * 示例:\n   * isPowerOfTwo(16)\n   * 输出: true\n   *\n   * 示例:\n   * isPowerOfTwo(3)\n   * 输出: false\n   *\n   * 示例:\n   * isPowerOfTwo(4)\n   * 输出: true\n   *\n   * 示例:\n   * isPowerOfTwo(5)\n   * 输出: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier n, déterminez s'il est une puissance de deux.\n   * Si c'est le cas, retournez true ; sinon, retournez false.\n   * Un nombre n est une puissance de deux s'il existe un entier x tel que n == 2^x.\n   *\n   * @param n L'entier à vérifier.\n   * @return True si n est une puissance de deux, false sinon.\n   *\n   * Exemple :\n   * isPowerOfTwo(1)\n   * Sortie : true\n   *\n   * Exemple :\n   * isPowerOfTwo(16)\n   * Sortie : true\n   *\n   * Exemple :\n   * isPowerOfTwo(3)\n   * Sortie : false\n   *\n   * Exemple :\n   * isPowerOfTwo(4)\n   * Sortie : true\n   *\n   * Exemple :\n   * isPowerOfTwo(5)\n   * Sortie : false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, bestimmen, ob sie eine Potenz von zwei ist.\n   * Wenn ja, gib true zurück; andernfalls gib false zurück.\n   * Eine Zahl n ist eine Potenz von zwei, wenn es eine ganze Zahl x gibt, so dass n == 2^x.\n   *\n   * @param n Die zu überprüfende ganze Zahl.\n   * @return True, wenn n eine Potenz von zwei ist, andernfalls false.\n   *\n   * Beispiel:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Beispiel:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Beispiel:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Beispiel:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Beispiel:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba n, tantance ko yana da ikon biyu.\n   * Idan haka ne, dawo da gaskiya; in ba haka ba, dawo da ƙarya.\n   * Wani lamba n yana da ikon biyu idan akwai wani lamba x wanda n == 2^x.\n   *\n   * @param n Lambar da za a duba.\n   * @return Gaskiya idan n yana da ikon biyu, ƙarya in ba haka ba.\n   *\n   * Misali:\n   * isPowerOfTwo(1)\n   * Fitarwa: true\n   *\n   * Misali:\n   * isPowerOfTwo(16)\n   * Fitarwa: true\n   *\n   * Misali:\n   * isPowerOfTwo(3)\n   * Fitarwa: false\n   *\n   * Misali:\n   * isPowerOfTwo(4)\n   * Fitarwa: true\n   *\n   * Misali:\n   * isPowerOfTwo(5)\n   * Fitarwa: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए एक पूर्णांक n के लिए, यह निर्धारित करें कि क्या यह दो का घात है।\n   * यदि हाँ, तो true लौटाएँ; अन्यथा, false लौटाएँ।\n   * एक संख्या n दो का घात तब होती है जब कोई पूर्णांक x मौजूद हो ताकि n == 2^x हो।\n   *\n   * @param n वह पूर्णांक जिसे जाँचना है।\n   * @return true यदि n दो का घात है, अन्यथा false।\n   *\n   * उदाहरण:\n   * isPowerOfTwo(1)\n   * आउटपुट: true\n   *\n   * उदाहरण:\n   * isPowerOfTwo(16)\n   * आउटपुट: true\n   *\n   * उदाहरण:\n   * isPowerOfTwo(3)\n   * आउटपुट: false\n   *\n   * उदाहरण:\n   * isPowerOfTwo(4)\n   * आउटपुट: true\n   *\n   * उदाहरण:\n   * isPowerOfTwo(5)\n   * आउटपुट: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy egész szám n, határozza meg, hogy kettő hatványa-e.\n   * Ha igen, adjon vissza true-t; ellenkező esetben adjon vissza false-t.\n   * Egy szám n akkor kettő hatványa, ha létezik egy x egész szám, amelyre n == 2^x.\n   *\n   * @param n Az ellenőrizendő egész szám.\n   * @return True, ha n kettő hatványa, különben false.\n   *\n   * Példa:\n   * isPowerOfTwo(1)\n   * Kimenet: true\n   *\n   * Példa:\n   * isPowerOfTwo(16)\n   * Kimenet: true\n   *\n   * Példa:\n   * isPowerOfTwo(3)\n   * Kimenet: false\n   *\n   * Példa:\n   * isPowerOfTwo(4)\n   * Kimenet: true\n   *\n   * Példa:\n   * isPowerOfTwo(5)\n   * Kimenet: false\n   */\n  public static boolean isPowerOfTwo(int n) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9671465349768295",
      "bn": "0.9945829522484165",
      "bg": "1",
      "zh": "0.9899421520259174",
      "fr": "0.9964679545644376",
      "de": "0.9904025772491563",
      "ha": "0.9834022467303437",
      "hi": "0.9879343961344168",
      "hu": "0.9917248596957056"
    },
    "canonical_solution": "  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }",
    "instruction": {
      "en": "Write a Java function `public static boolean isPowerOfTwo(int n)` to solve the following problem:\nGiven an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false",
      "sq": "Shkruani një funksion Java `public static boolean isPowerOfTwo(int n)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë n, përcaktoni nëse është fuqi e dyshit.  \n    Nëse është, kthe true; përndryshe, kthe false.  \n    Një numër n është fuqi e dyshit nëse ekziston një numër i plotë x i tillë që n == 2^x.\n   \n    @param n Numri i plotë që do të kontrollohet.\n    @return True nëse n është fuqi e dyshit, false përndryshe.\n   \n    Shembull:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Shembull:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Shembull:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Shembull:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Shembull:\n    isPowerOfTwo(5)\n    Output: false",
      "hy": "Գրեք Java ֆունկցիա `public static boolean isPowerOfTwo(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, որոշեք, արդյոք այն երկուի աստիճան է:\n    Եթե այո, վերադարձնել true, հակառակ դեպքում՝ false:\n    Թիվ n-ը երկուի աստիճան է, եթե գոյություն ունի ամբողջ թիվ x, այնպես որ n == 2^x:\n\n    @param n Ստուգվող ամբողջ թիվը:\n    @return True, եթե n-ը երկուի աստիճան է, false՝ հակառակ դեպքում:\n\n    Օրինակ:\n    isPowerOfTwo(1)\n    Արդյունք: true\n\n    Օրինակ:\n    isPowerOfTwo(16)\n    Արդյունք: true\n\n    Օրինակ:\n    isPowerOfTwo(3)\n    Արդյունք: false\n\n    Օրինակ:\n    isPowerOfTwo(4)\n    Արդյունք: true\n\n    Օրինակ:\n    isPowerOfTwo(5)\n    Արդյունք: false",
      "bn": "একটি জাভা ফাংশন `public static boolean isPowerOfTwo(int n)` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করতে:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, নির্ধারণ করুন এটি দুইয়ের ঘাত কিনা।\n    যদি হয়, true ফেরত দিন; অন্যথায়, false ফেরত দিন।\n    একটি সংখ্যা n দুইয়ের ঘাত যদি একটি পূর্ণসংখ্যা x বিদ্যমান থাকে যাতে n == 2^x হয়।\n   \n    @param n যাচাই করার জন্য পূর্ণসংখ্যা।\n    @return যদি n দুইয়ের ঘাত হয় তবে True, অন্যথায় false।\n   \n    উদাহরণ:\n    isPowerOfTwo(1)\n    আউটপুট: true\n   \n    উদাহরণ:\n    isPowerOfTwo(16)\n    আউটপুট: true\n   \n    উদাহরণ:\n    isPowerOfTwo(3)\n    আউটপুট: false\n   \n    উদাহরণ:\n    isPowerOfTwo(4)\n    আউটপুট: true\n   \n    উদাহরণ:\n    isPowerOfTwo(5)\n    আউটপুট: false",
      "bg": "Напишете Java функция `public static boolean isPowerOfTwo(int n)`, за да решите следния проблем:\nДадено е цяло число n, определете дали е степен на двойката.\n    Ако е, върнете true; в противен случай върнете false.\n    Число n е степен на двойката, ако съществува цяло число x, такова че n == 2^x.\n   \n    @param n Цялото число, което трябва да бъде проверено.\n    @return True ако n е степен на двойката, false в противен случай.\n   \n    Пример:\n    isPowerOfTwo(1)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(16)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(3)\n    Изход: false\n   \n    Пример:\n    isPowerOfTwo(4)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(5)\n    Изход: false",
      "zh": "编写一个 Java 函数 `public static boolean isPowerOfTwo(int n)` 来解决以下问题：\n给定一个整数 n，确定它是否是二的幂。\n    如果是，返回 true；否则，返回 false。\n    如果存在一个整数 x 使得 n == 2^x，则数字 n 是二的幂。\n   \n    @param n 要检查的整数。\n    @return 如果 n 是二的幂则返回 true，否则返回 false。\n   \n    示例：\n    isPowerOfTwo(1)\n    输出: true\n   \n    示例：\n    isPowerOfTwo(16)\n    输出: true\n   \n    示例：\n    isPowerOfTwo(3)\n    输出: false\n   \n    示例：\n    isPowerOfTwo(4)\n    输出: true\n   \n    示例：\n    isPowerOfTwo(5)\n    输出: false",
      "fr": "Écrire une fonction Java `public static boolean isPowerOfTwo(int n)` pour résoudre le problème suivant :\nÉtant donné un entier n, déterminez s'il est une puissance de deux.\n    Si c'est le cas, retournez true ; sinon, retournez false.\n    Un nombre n est une puissance de deux s'il existe un entier x tel que n == 2^x.\n   \n    @param n L'entier à vérifier.\n    @return True si n est une puissance de deux, false sinon.\n   \n    Exemple:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Exemple:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Exemple:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Exemple:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Exemple:\n    isPowerOfTwo(5)\n    Output: false",
      "de": "Schreiben Sie eine Java-Funktion `public static boolean isPowerOfTwo(int n)`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, bestimmen Sie, ob sie eine Potenz von zwei ist.\n    Wenn ja, geben Sie true zurück; andernfalls false.\n    Eine Zahl n ist eine Potenz von zwei, wenn es eine ganze Zahl x gibt, so dass n == 2^x.\n   \n    @param n Die zu überprüfende ganze Zahl.\n    @return True, wenn n eine Potenz von zwei ist, andernfalls false.\n   \n    Beispiel:\n    isPowerOfTwo(1)\n    Ausgabe: true\n   \n    Beispiel:\n    isPowerOfTwo(16)\n    Ausgabe: true\n   \n    Beispiel:\n    isPowerOfTwo(3)\n    Ausgabe: false\n   \n    Beispiel:\n    isPowerOfTwo(4)\n    Ausgabe: true\n   \n    Beispiel:\n    isPowerOfTwo(5)\n    Ausgabe: false",
      "ha": "Rubuta aikin Java `public static boolean isPowerOfTwo(int n)` don warware matsalar mai zuwa:\nAn ba da cikakken lamba n, tantance idan yana da iko na biyu.\n    Idan haka ne, dawo da gaskiya; in ba haka ba, dawo da ƙarya.\n    Lamba n tana da iko na biyu idan akwai cikakken lamba x wanda n == 2^x.\n   \n    @param n Lambar da za a duba.\n    @return Gaskiya idan n yana da iko na biyu, ƙarya in ba haka ba.\n   \n    Misali:\n    isPowerOfTwo(1)\n    Fitarwa: true\n   \n    Misali:\n    isPowerOfTwo(16)\n    Fitarwa: true\n   \n    Misali:\n    isPowerOfTwo(3)\n    Fitarwa: false\n   \n    Misali:\n    isPowerOfTwo(4)\n    Fitarwa: true\n   \n    Misali:\n    isPowerOfTwo(5)\n    Fitarwa: false",
      "hi": "एक जावा फ़ंक्शन `public static boolean isPowerOfTwo(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया एक पूर्णांक n, यह निर्धारित करें कि क्या यह दो का घात है।\n    यदि यह है, तो true लौटाएं; अन्यथा, false लौटाएं।\n    एक संख्या n दो का घात है यदि कोई पूर्णांक x मौजूद है जिससे n == 2^x हो।\n\n    @param n वह पूर्णांक जिसे जांचा जाना है।\n    @return True यदि n दो का घात है, अन्यथा false।\n\n    उदाहरण:\n    isPowerOfTwo(1)\n    आउटपुट: true\n\n    उदाहरण:\n    isPowerOfTwo(16)\n    आउटपुट: true\n\n    उदाहरण:\n    isPowerOfTwo(3)\n    आउटपुट: false\n\n    उदाहरण:\n    isPowerOfTwo(4)\n    आउटपुट: true\n\n    उदाहरण:\n    isPowerOfTwo(5)\n    आउटपुट: false",
      "hu": "Írjon egy Java függvényt `public static boolean isPowerOfTwo(int n)` a következő probléma megoldására:\nAdott egy egész szám n, határozza meg, hogy hatványa-e kettőnek.\n    Ha igen, adja vissza true; ellenkező esetben adja vissza false.\n    Egy szám n akkor hatványa kettőnek, ha létezik egy x egész szám, amelyre n == 2^x.\n   \n    @param n Az ellenőrizendő egész szám.\n    @return True, ha n hatványa kettőnek, különben false.\n   \n    Példa:\n    isPowerOfTwo(1)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(16)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(3)\n    Kimenet: false\n   \n    Példa:\n    isPowerOfTwo(4)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(5)\n    Kimenet: false"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9559016718456824",
      "bn": "0.9868667578363542",
      "bg": "0.9986761285104024",
      "zh": "0.9717130474368215",
      "fr": "0.9965843519677241",
      "de": "0.9812496892910686",
      "ha": "0.9829857188213136",
      "hi": "0.9982288128923119",
      "hu": "0.9929744434227961"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert isPowerOfTwo(1024) == true; // 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; // 65536 is 2^16\n    assert isPowerOfTwo(14) == false; // 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isPowerOfTwo",
    "signature": "public static boolean isPowerOfTwo(int n)",
    "docstring": {
      "en": "Given an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false",
      "sq": "Duke pasur një numër të plotë n, përcaktoni nëse është fuqi e dyshit. Nëse është, kthe true; përndryshe, kthe false. Një numër n është fuqi e dyshit nëse ekziston një numër i plotë x i tillë që n == 2^x.\n\n@param n Numri i plotë që do të kontrollohet.\n@return True nëse n është fuqi e dyshit, false përndryshe.\n\nShembull:\nisPowerOfTwo(1)\nOutput: true\n\nShembull:\nisPowerOfTwo(16)\nOutput: true\n\nShembull:\nisPowerOfTwo(3)\nOutput: false\n\nShembull:\nisPowerOfTwo(4)\nOutput: true\n\nShembull:\nisPowerOfTwo(5)\nOutput: false",
      "hy": "Տրված է ամբողջ թիվ n, որոշել՝ արդյոք այն երկուի աստիճան է:\n    Եթե այո, վերադարձնել true, հակառակ դեպքում՝ false:\n    Թիվ n-ը երկուի աստիճան է, եթե գոյություն ունի ամբողջ թիվ x, այնպես, որ n == 2^x:\n   \n    @param n Ստուգվող ամբողջ թիվը:\n    @return True, եթե n-ը երկուի աստիճան է, false՝ հակառակ դեպքում:\n   \n    Օրինակ:\n    isPowerOfTwo(1)\n    Արդյունք: true\n   \n    Օրինակ:\n    isPowerOfTwo(16)\n    Արդյունք: true\n   \n    Օրինակ:\n    isPowerOfTwo(3)\n    Արդյունք: false\n   \n    Օրինակ:\n    isPowerOfTwo(4)\n    Արդյունք: true\n   \n    Օրինակ:\n    isPowerOfTwo(5)\n    Արդյունք: false",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, নির্ধারণ করুন এটি দুইয়ের ঘাত কিনা। \n    যদি হয়, তাহলে true ফেরত দিন; অন্যথায়, false ফেরত দিন। \n    একটি সংখ্যা n দুইয়ের ঘাত যদি হয়, তাহলে একটি পূর্ণসংখ্যা x বিদ্যমান এমন যে n == 2^x।\n\n    @param n যাচাই করার জন্য পূর্ণসংখ্যা।\n    @return যদি n দুইয়ের ঘাত হয় তাহলে True, অন্যথায় false।\n\n    উদাহরণ:\n    isPowerOfTwo(1)\n    আউটপুট: true\n\n    উদাহরণ:\n    isPowerOfTwo(16)\n    আউটপুট: true\n\n    উদাহরণ:\n    isPowerOfTwo(3)\n    আউটপুট: false\n\n    উদাহরণ:\n    isPowerOfTwo(4)\n    আউটপুট: true\n\n    উদাহরণ:\n    isPowerOfTwo(5)\n    আউটপুট: false",
      "bg": "Дадено е цяло число n, определете дали е степен на две.\n    Ако е, върнете true; в противен случай върнете false.\n    Число n е степен на две, ако съществува цяло число x, такова че n == 2^x.\n   \n    @param n Цялото число, което трябва да се провери.\n    @return True ако n е степен на две, false в противен случай.\n   \n    Пример:\n    isPowerOfTwo(1)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(16)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(3)\n    Изход: false\n   \n    Пример:\n    isPowerOfTwo(4)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(5)\n    Изход: false",
      "zh": "给定一个整数 n，确定它是否是二的幂。\n    如果是，返回 true；否则，返回 false。\n    如果存在一个整数 x 使得 n == 2^x，则数字 n 是二的幂。\n   \n    @param n 要检查的整数。\n    @return 如果 n 是二的幂则为 True，否则为 false。\n   \n    示例:\n    isPowerOfTwo(1)\n    输出: true\n   \n    示例:\n    isPowerOfTwo(16)\n    输出: true\n   \n    示例:\n    isPowerOfTwo(3)\n    输出: false\n   \n    示例:\n    isPowerOfTwo(4)\n    输出: true\n   \n    示例:\n    isPowerOfTwo(5)\n    输出: false",
      "fr": "Étant donné un entier n, déterminez s'il est une puissance de deux.\n    Si c'est le cas, retournez vrai ; sinon, retournez faux.  \n    Un nombre n est une puissance de deux s'il existe un entier x tel que n == 2^x.\n   \n    @param n L'entier à vérifier.\n    @return Vrai si n est une puissance de deux, faux sinon.\n   \n    Exemple:\n    isPowerOfTwo(1)\n    Sortie: true\n   \n    Exemple:\n    isPowerOfTwo(16)\n    Sortie: true\n   \n    Exemple:\n    isPowerOfTwo(3)\n    Sortie: false\n   \n    Exemple:\n    isPowerOfTwo(4)\n    Sortie: true\n   \n    Exemple:\n    isPowerOfTwo(5)\n    Sortie: false",
      "de": "Gegeben eine ganze Zahl n, bestimmen, ob sie eine Potenz von zwei ist.\n    Wenn es so ist, geben Sie true zurück; andernfalls false.  \nEine Zahl n ist eine Potenz von zwei, wenn es eine ganze Zahl x gibt, so dass n == 2^x.\n\n@param n Die zu prüfende ganze Zahl.  \n@return True, wenn n eine Potenz von zwei ist, andernfalls false.\n\nBeispiel:  \nisPowerOfTwo(1)  \nAusgabe: true\n\nBeispiel:  \nisPowerOfTwo(16)  \nAusgabe: true\n\nBeispiel:  \nisPowerOfTwo(3)  \nAusgabe: false\n\nBeispiel:  \nisPowerOfTwo(4)  \nAusgabe: true\n\nBeispiel:  \nisPowerOfTwo(5)  \nAusgabe: false",
      "ha": "An ba da wani lamba n, tantance ko yana da ikon biyu.\n    Idan haka ne, dawo da gaskiya; in ba haka ba, dawo da ƙarya.  \n    Wani lamba n yana da ikon biyu idan akwai wani cikakken lamba x wanda n == 2^x.  \n   \n    @param n Lambar cikakke da za a duba.  \n    @return Gaskiya idan n yana da ikon biyu, ƙarya in ba haka ba.  \n   \n    Misali:  \n    isPowerOfTwo(1)  \n    Output: true  \n   \n    Misali:  \n    isPowerOfTwo(16)  \n    Output: true  \n   \n    Misali:  \n    isPowerOfTwo(3)  \n    Output: false  \n   \n    Misali:  \n    isPowerOfTwo(4)  \n    Output: true  \n   \n    Misali:  \n    isPowerOfTwo(5)  \n    Output: false",
      "hi": "दिए गए एक पूर्णांक n के लिए, यह निर्धारित करें कि क्या यह दो का घात है।\n    यदि यह है, तो true लौटाएं; अन्यथा, false लौटाएं।  \n    एक संख्या n दो की शक्ति है यदि कोई पूर्णांक x मौजूद है ऐसा कि n == 2^x।  \n   \n    @param n जाँच की जाने वाली पूर्णांक।  \n    @return True यदि n दो की शक्ति है, अन्यथा false।  \n   \n    उदाहरण:  \n    isPowerOfTwo(1)  \n    Output: true  \n   \n    उदाहरण:  \n    isPowerOfTwo(16)  \n    Output: true  \n   \n    उदाहरण:  \n    isPowerOfTwo(3)  \n    Output: false  \n   \n    उदाहरण:  \n    isPowerOfTwo(4)  \n    Output: true  \n   \n    उदाहरण:  \n    isPowerOfTwo(5)  \n    Output: false",
      "hu": "Adott egy egész szám n, határozza meg, hogy kettő hatványa-e.\n    Ha igen, adjon vissza igazat; ellenkező esetben hamisat.\n    Egy szám n akkor kettő hatványa, ha létezik egy x egész szám, amelyre n == 2^x.\n   \n    @param n Az ellenőrizendő egész szám.\n    @return Igaz, ha n kettő hatványa, hamis egyébként.\n   \n    Példa:\n    isPowerOfTwo(1)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(16)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(3)\n    Kimenet: false\n   \n    Példa:\n    isPowerOfTwo(4)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(5)\n    Kimenet: false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9559306718813135",
      "bn": "0.9827970199593304",
      "bg": "1",
      "zh": "0.9728877475102619",
      "fr": "0.9959245018419262",
      "de": "0.9901145631966557",
      "ha": "0.9875230326152935",
      "hi": "0.9895796515805287",
      "hu": "0.9824263756683193"
    }
  },
  {
    "task_id": "Java/39",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë jo-negativ num, shtoni vazhdimisht të gjitha shifrat e tij derisa rezultati të jetë një shifër e vetme. Kthe rezultatin.\n   *\n   * @param num Numri i plotë jo-negativ mbi të cilin do të kryhet operacioni.\n   * @return Rezultati me një shifër pas shtimit të vazhdueshëm të të gjitha shifrave.\n   *\n   * Shembull:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարել դրա բոլոր թվանշանները, մինչև արդյունքը լինի միանիշ։ Վերադարձնել արդյունքը։\n   *\n   * @param num Ոչ բացասական ամբողջ թիվ, որի վրա պետք է կատարել գործողությունը։\n   * @return Միանիշ արդյունքը, որը ստացվում է բոլոր թվանշանները բազմիցս գումարելուց հետո։\n   *\n   * Օրինակ:\n   * addDigits(38)\n   * Արդյունք: 2\n   */\n  public static int addDigits(int num) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, ফলাফল একক অঙ্ক না হওয়া পর্যন্ত এর সমস্ত অঙ্ক বারবার যোগ করুন। ফলাফল ফেরত দিন।\n   *\n   * @param num যে অ-ঋণাত্মক পূর্ণসংখ্যার উপর অপারেশনটি সম্পাদন করতে হবে।\n   * @return সমস্ত অঙ্ক বারবার যোগ করার পরে একক অঙ্কের ফলাফল।\n   *\n   * উদাহরণ:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е неотрицателно цяло число num, събирайте многократно всичките му цифри, докато резултатът стане едноцифрено число. Върнете резултата.\n   *\n   * @param num Неотрицателното цяло число, върху което да се извърши операцията.\n   * @return Едноцифреният резултат след многократно събиране на всички цифри.\n   *\n   * Пример:\n   * addDigits(38)\n   * Изход: 2\n   */\n  public static int addDigits(int num) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个非负整数 num，反复将其所有位数相加，直到结果为一位数。返回结果。\n   *\n   * @param num 要进行操作的非负整数。\n   * @return 反复相加所有位数后的一位数结果。\n   *\n   * 示例:\n   * addDigits(38)\n   * 输出: 2\n   */\n  public static int addDigits(int num) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat soit un seul chiffre. Retournez le résultat.\n   *\n   * @param num L'entier non négatif sur lequel effectuer l'opération.\n   * @return Le résultat à un chiffre après avoir ajouté de manière répétée tous les chiffres.\n   *\n   * Exemple :\n   * addDigits(38)\n   * Sortie : 2\n   */\n  public static int addDigits(int num) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis eine einzelne Ziffer ist. Gib das Ergebnis zurück.\n   *\n   * @param num Die nicht-negative ganze Zahl, auf der die Operation ausgeführt werden soll.\n   * @return Das einstellige Ergebnis nach wiederholtem Addieren aller Ziffern.\n   *\n   * Beispiel:\n   * addDigits(38)\n   * Ausgabe: 2\n   */\n  public static int addDigits(int num) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon ya zama lamba guda. Mayar da sakamakon.\n   *\n   * @param num Lamba mara kyau da za a yi aikin a kai.\n   * @return Sakamakon lamba guda bayan ci gaba da ƙara duk lambobi.\n   *\n   * Misali:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए एक गैर-ऋणात्मक पूर्णांक num पर, इसके सभी अंकों को तब तक बार-बार जोड़ें जब तक परिणाम एकल अंक न हो जाए। परिणाम लौटाएं।\n   *\n   * @param num वह गैर-ऋणात्मक पूर्णांक जिस पर ऑपरेशन करना है।\n   * @return सभी अंकों को बार-बार जोड़ने के बाद एकल अंक का परिणाम।\n   *\n   * उदाहरण:\n   * addDigits(38)\n   * आउटपुट: 2\n   */\n  public static int addDigits(int num) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény egy egyjegyű szám lesz. Add vissza az eredményt.\n   *\n   * @param num A nem negatív egész szám, amelyen a műveletet végrehajtjuk.\n   * @return Az egyjegyű eredmény az összes számjegy ismételt összeadása után.\n   *\n   * Példa:\n   * addDigits(38)\n   * Kimenet: 2\n   */\n  public static int addDigits(int num) "
    },
    "prompt_bertscore": {
      "sq": "0.9747808936719055",
      "hy": "0.9778890618743393",
      "bn": "0.9771509513784137",
      "bg": "0.9753201751564151",
      "zh": "0.9676411246256064",
      "fr": "0.9835146715260095",
      "de": "0.9771509513784137",
      "ha": "0.9785806928611028",
      "hi": "0.9786821929858116",
      "hu": "0.9650307241580459"
    },
    "canonical_solution": "  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }",
    "instruction": {
      "en": "Write a Java function `public static int addDigits(int num)` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2",
      "sq": "Shkruani një funksion Java `public static int addDigits(int num)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë jo-negativ num, shtoni në mënyrë të përsëritur të gjitha shifrat e tij derisa rezultati të jetë një shifër e vetme. Ktheni rezultatin.\n\n@param num Numri i plotë jo-negativ mbi të cilin do të kryhet operacioni.\n@return Rezultati me një shifër pas shtimit të përsëritur të të gjitha shifrave.\n\nShembull:\naddDigits(38)\nOutput: 2",
      "hy": "Գրեք Java ֆունկցիա `public static int addDigits(int num)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը դառնա միանիշ թիվ: Վերադարձնել արդյունքը:\n\n@param num Ոչ բացասական ամբողջ թիվը, որի վրա պետք է կատարել գործողությունը:\n@return Միանիշ արդյունքը, որը ստացվում է բոլոր թվանշանները բազմիցս գումարելուց հետո:\n\nՕրինակ:\naddDigits(38)\nԵլք: 2",
      "bn": "একটি জাভা ফাংশন `public static int addDigits(int num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফল একটি একক অঙ্ক হয়। ফলাফল ফেরত দিন।\n\n@param num যে অ-ঋণাত্মক পূর্ণসংখ্যার উপর অপারেশনটি সম্পাদন করতে হবে।\n@return একক অঙ্কের ফলাফল যা সমস্ত অঙ্ক বারবার যোগ করার পরে পাওয়া যায়।\n\nউদাহরণ:\naddDigits(38)\nআউটপুট: 2",
      "bg": "Напишете Java функция `public static int addDigits(int num)`, за да решите следния проблем:  \nДадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът стане едноцифрено число. Върнете резултата.\n\n@param num Неотрицателното цяло число, върху което да се извърши операцията.\n@return Едноцифреният резултат след многократно събиране на всички цифри.\n\nПример:  \naddDigits(38)  \nИзход: 2",
      "zh": "编写一个 Java 函数 `public static int addDigits(int num)` 来解决以下问题：  \n给定一个非负整数 num，重复将其所有位数相加，直到结果为一位数。返回结果。\n\n@param num 要执行操作的非负整数。\n@return 重复相加所有位数后的单一数字结果。\n\n示例：  \naddDigits(38)  \n输出：2",
      "fr": "Écrire une fonction Java `public static int addDigits(int num)` pour résoudre le problème suivant :  \nÉtant donné un entier non négatif num, additionner à plusieurs reprises tous ses chiffres jusqu'à ce que le résultat soit un seul chiffre. Retourner le résultat.\n\n@param num L'entier non négatif sur lequel effectuer l'opération.\n@return Le résultat à un seul chiffre après avoir additionné à plusieurs reprises tous les chiffres.\n\nExemple :  \naddDigits(38)  \nSortie : 2",
      "de": "Schreiben Sie eine Java-Funktion `public static int addDigits(int num)`, um das folgende Problem zu lösen:\nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis eine einzelne Ziffer ist. Geben Sie das Ergebnis zurück.\n\n@param num Die nicht-negative ganze Zahl, auf der die Operation ausgeführt werden soll.\n@return Das einstellige Ergebnis nach wiederholtem Addieren aller Ziffern.\n\nBeispiel:\naddDigits(38)\nAusgabe: 2",
      "ha": "Rubuta aikin Java `public static int addDigits(int num)` don warware matsalar mai zuwa:  \nAn ba da lamba mai kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon ya zama lamba guda ɗaya. Mayar da sakamakon.\n\n@param num Lamba mai kyau da za a aiwatar da aikin a kai.  \n@return Sakamakon lamba guda ɗaya bayan ci gaba da ƙara duk lambobi.\n\nMisali:  \naddDigits(38)  \nSakamako: 2",
      "hi": "एक जावा फ़ंक्शन `public static int addDigits(int num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए गैर-ऋणात्मक पूर्णांक num के सभी अंकों को तब तक जोड़ें जब तक परिणाम एकल अंक न हो जाए। परिणाम लौटाएं।\n\n@param num वह गैर-ऋणात्मक पूर्णांक जिस पर ऑपरेशन करना है।\n@return सभी अंकों को बार-बार जोड़ने के बाद एकल अंक परिणाम।\n\nउदाहरण:\naddDigits(38)\nआउटपुट: 2",
      "hu": "Írj egy Java függvényt `public static int addDigits(int num)` a következő probléma megoldására:\nAdott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény egyetlen számjegy nem lesz. Add vissza az eredményt.\n\n@param num A nem negatív egész szám, amelyen a műveletet végre kell hajtani.\n@return Az egyetlen számjegyű eredmény, miután ismételten összeadtad az összes számjegyet.\n\nPélda:\naddDigits(38)\nKimenet: 2"
    },
    "instruction_bertscore": {
      "sq": "0.9720123834210411",
      "hy": "0.9712863893783586",
      "bn": "0.968020707283764",
      "bg": "0.9802527634086545",
      "zh": "1",
      "fr": "0.982276409730638",
      "de": "0.9734796660457459",
      "ha": "0.9244783455659631",
      "hi": "0.9457832416053842",
      "hu": "0.9694703118045567"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "addDigits",
    "signature": "public static int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni në mënyrë të përsëritur të gjitha shifrat e tij derisa rezultati të jetë një shifër e vetme. Kthe rezultatin.\n\n@param num Numri i plotë jo-negativ mbi të cilin do të kryhet operacioni.\n@return Rezultati me një shifër pas shtimit të përsëritur të të gjitha shifrave.\n\nShembull:\naddDigits(38)\nOutput: 2",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը լինի միանիշ։ Վերադարձնել արդյունքը։\n\n@param num Ոչ բացասական ամբողջ թիվ, որի վրա պետք է կատարել գործողությունը։\n@return Միանիշ արդյունքը, որը ստացվում է բոլոր թվանշանները բազմիցս գումարելուց հետո։\n\nՕրինակ:\naddDigits(38)\nԱրդյունք: 2",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফল একটি একক অঙ্ক হয়। ফলাফল ফেরত দিন।\n\n@param num যে অ-ঋণাত্মক পূর্ণসংখ্যার উপর অপারেশনটি সম্পাদন করতে হবে।\n@return সমস্ত অঙ্ক বারবার যোগ করার পরে একক অঙ্কের ফলাফল।\n\nউদাহরণ:\naddDigits(38)\nOutput: 2",
      "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът стане едноцифрено число. Върнете резултата.\n\n@param num Неотрицателното цяло число, върху което да се извърши операцията.\n@return Едноцифреният резултат след многократно събиране на всички цифри.\n\nПример:\naddDigits(38)\nИзход: 2",
      "zh": "给定一个非负整数 num，重复将其所有位数相加，直到结果为一位数。返回结果。\n\n@param num 要执行操作的非负整数。\n@return 反复相加所有位数后的单一数字结果。\n\n示例：\naddDigits(38)\n输出: 2",
      "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat soit un seul chiffre. Retournez le résultat.\n\n@param num L'entier non négatif sur lequel effectuer l'opération.\n@return Le résultat à un chiffre après avoir additionné de manière répétée tous les chiffres.\n\nExemple :\naddDigits(38)\nOutput: 2",
      "de": "Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis eine einzelne Ziffer ist. Gib das Ergebnis zurück.\n\n@param num Die nicht-negative ganze Zahl, auf der die Operation durchgeführt werden soll.\n@return Das einstellige Ergebnis nach wiederholtem Addieren aller Ziffern.\n\nBeispiel:\naddDigits(38)\nAusgabe: 2",
      "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon ya zama lamba guda ɗaya. Mayar da sakamakon.\n\n@param num Lamba mara kyau da za a yi aikin a kai.\n@return Sakamakon lamba guda ɗaya bayan ci gaba da ƙara duk lambobi.\n\nMisali:\naddDigits(38)\nOutput: 2",
      "hi": "गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम एकल अंक न हो जाए। परिणाम लौटाएं।\n\n@param num वह गैर-ऋणात्मक पूर्णांक जिस पर ऑपरेशन करना है।\n@return सभी अंकों को बार-बार जोड़ने के बाद एकल अंक का परिणाम।\n\nउदाहरण:\naddDigits(38)\nOutput: 2",
      "hu": "Adott egy nem negatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény egyjegyű nem lesz. Add vissza az eredményt.\n\n@param num A nem negatív egész szám, amelyen a műveletet végre kell hajtani.\n@return Az egyjegyű eredmény, miután ismételten összeadtuk az összes számjegyet.\n\nPélda:\naddDigits(38)\nKimenet: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9735932826236978",
      "hy": "0.9629224612937416",
      "bn": "0.9703905663598913",
      "bg": "0.9687228656807224",
      "zh": "1",
      "fr": "0.9811452097106442",
      "de": "0.9745834550731567",
      "ha": "0.8748608736442101",
      "hi": "0.9335694594755489",
      "hu": "0.9621817686028624"
    }
  },
  {
    "task_id": "Java/40",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një matricë binare mat me madhësi m x n, kthe gjatësinë e vijës më të gjatë të pandërprerë të 1-shave në matricë.\n   * Vija mund të jetë horizontale, vertikale, diagonale, ose anti-diagonale.\n   *\n   * @param mat Matrica binare.\n   * @return Gjatësia e vijës më të gjatë të pandërprerë të 1-shave.\n   *\n   * Shembull:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է m x n չափսի երկբայական մատրիցա mat, վերադարձնել մատրիցայում 1-երի ամենաերկար շարունակական գծի երկարությունը:\n   * Գիծը կարող է լինել հորիզոնական, ուղղահայաց, անկյունագծային կամ հակաանկյունագծային:\n   *\n   * @param mat Երկբայական մատրիցան:\n   * @return 1-երի ամենաերկար շարունակական գծի երկարությունը:\n   *\n   * Օրինակ:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Արդյունք: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি বাইনারি ম্যাট্রিক্স mat দেওয়া হয়েছে যার আকার m x n, ম্যাট্রিক্সে 1s এর দীর্ঘতম ক্রমাগত লাইনের দৈর্ঘ্য ফেরত দিন।\n   * লাইনটি অনুভূমিক, উল্লম্ব, তির্যক, বা বিপরীত তির্যক হতে পারে।\n   *\n   * @param mat বাইনারি ম্যাট্রিক্স।\n   * @return 1s এর দীর্ঘতম ক্রমাগত লাইনের দৈর্ঘ্য।\n   *\n   * উদাহরণ:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * আউটপুট: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадена е бинарна матрица mat с размер m x n, върнете дължината на най-дългата непрекъсната линия от 1-ци в матрицата.\n   * Линията може да бъде хоризонтална, вертикална, диагонална или анти-диагонална.\n   *\n   * @param mat Бинарната матрица.\n   * @return Дължината на най-дългата непрекъсната линия от 1-ци.\n   *\n   * Пример:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Изход: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个大小为 m x n 的二进制矩阵 mat，返回矩阵中连续 1 的最长线的长度。\n   * 该线可以是水平、垂直、对角线或反对角线。\n   *\n   * @param mat 二进制矩阵。\n   * @return 连续 1 的最长线的长度。\n   *\n   * 示例:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * 输出: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné une matrice binaire mat de taille m x n, renvoie la longueur de la plus longue ligne continue de 1s dans la matrice.\n   * La ligne peut être horizontale, verticale, diagonale ou anti-diagonale.\n   *\n   * @param mat La matrice binaire.\n   * @return La longueur de la plus longue ligne continue de 1s.\n   *\n   * Exemple :\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Sortie : 3\n   */\n  public static int longestLine(int[][] mat) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine binäre Matrix mat der Größe m x n, gib die Länge der längsten zusammenhängenden Linie von 1en in der Matrix zurück.\n   * Die Linie kann horizontal, vertikal, diagonal oder anti-diagonal sein.\n   *\n   * @param mat Die binäre Matrix.\n   * @return Die Länge der längsten zusammenhängenden Linie von 1en.\n   *\n   * Beispiel:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Ausgabe: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da matrix na binary mat mai girman m x n, dawo da tsawon layin da ya fi tsayi na 1s a cikin matrix.\n   * Layin na iya zama a kwance, a tsaye, a diagonal, ko kuma a anti-diagonal.\n   *\n   * @param mat Matrix na binary.\n   * @return Tsawon layin da ya fi tsayi na 1s.\n   *\n   * Misali:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए एक बाइनरी मैट्रिक्स mat के आकार m x n में, मैट्रिक्स में 1s की सबसे लंबी निरंतर रेखा की लंबाई लौटाएं।\n   * रेखा क्षैतिज, लंबवत, विकर्ण, या विपरीत-विकर्ण हो सकती है।\n   *\n   * @param mat बाइनरी मैट्रिक्स।\n   * @return 1s की सबसे लंबी निरंतर रेखा की लंबाई।\n   *\n   * उदाहरण:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * आउटपुट: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy m x n méretű bináris mátrix, mat, adja vissza a leghosszabb folyamatos 1-esekből álló sor hosszát a mátrixban.\n   * A sor lehet vízszintes, függőleges, átlós vagy ellenátlós.\n   *\n   * @param mat A bináris mátrix.\n   * @return A leghosszabb folyamatos 1-esekből álló sor hossza.\n   *\n   * Példa:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Kimenet: 3\n   */\n  public static int longestLine(int[][] mat) "
    },
    "prompt_bertscore": {
      "sq": "0.9990551152774171",
      "hy": "0.996202187114613",
      "bn": "0.9851704543823163",
      "bg": "0.9990551152774171",
      "zh": "0.9818576968874164",
      "fr": "0.9990551152774171",
      "de": "0.9922603672029756",
      "ha": "0.9720540958010585",
      "hi": "0.9836727813093132",
      "hu": "0.9839725145542949"
    },
    "canonical_solution": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }",
    "instruction": {
      "en": "Write a Java function `public static int longestLine(int[][] mat)` to solve the following problem:\nGiven a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "sq": "Shkruani një funksion Java `public static int longestLine(int[][] mat)` për të zgjidhur problemin në vijim:  \nDuke pasur një matricë binare mat me madhësi m x n, ktheni gjatësinë e vijës më të gjatë të pandërprerë të 1-shave në matricë.  \n    Vija mund të jetë horizontale, vertikale, diagonale, ose anti-diagonale.\n   \n    @param mat Matrica binare.\n    @return Gjatësia e vijës më të gjatë të pandërprerë të 1-shave.\n   \n    Shembull:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "hy": "Գրեք Java ֆունկցիա `public static int longestLine(int[][] mat)` հետևյալ խնդիրը լուծելու համար:\nՈւնենալով m x n չափսի բինար մատրիցա mat, վերադարձնել մատրիցայում ամենաերկար շարունակական 1-երի գծի երկարությունը:\n    Գիծը կարող է լինել հորիզոնական, ուղղահայաց, անկյունագծային կամ հակաանկյունագծային:\n   \n    @param mat Բինար մատրիցան։\n    @return Ամենաերկար շարունակական 1-երի գծի երկարությունը։\n   \n    Օրինակ:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Արդյունք: 3",
      "bn": "একটি জাভা ফাংশন `public static int longestLine(int[][] mat)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাইনারি ম্যাট্রিক্স mat দেওয়া আছে যার আকার m x n, ম্যাট্রিক্সে 1s এর দীর্ঘতম ক্রমাগত লাইনের দৈর্ঘ্য ফেরত দিন।\n    লাইনটি অনুভূমিক, উল্লম্ব, তির্যক, বা বিপরীত তির্যক হতে পারে।\n\n    @param mat বাইনারি ম্যাট্রিক্স।\n    @return 1s এর দীর্ঘতম ক্রমাগত লাইনের দৈর্ঘ্য।\n\n    উদাহরণ:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    আউটপুট: 3",
      "bg": "Напишете Java функция `public static int longestLine(int[][] mat)`, за да решите следния проблем:  \nДадена е бинарна матрица mat с размер m x n, върнете дължината на най-дългата непрекъсната линия от 1ци в матрицата.  \nЛинията може да бъде хоризонтална, вертикална, диагонална или анти-диагонална.\n\n@param mat Бинарната матрица.  \n@return Дължината на най-дългата непрекъсната линия от 1ци.\n\nПример:  \nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})  \nИзход: 3",
      "zh": "编写一个Java函数 `public static int longestLine(int[][] mat)` 来解决以下问题：  \n给定一个大小为 m x n 的二进制矩阵 mat，返回矩阵中最长连续的1的长度。  \n该线可以是水平的、垂直的、对角线的或反对角线的。\n\n@param mat 二进制矩阵。  \n@return 最长连续1的长度。\n\n示例：  \nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})  \n输出: 3",
      "fr": "Écrire une fonction Java `public static int longestLine(int[][] mat)` pour résoudre le problème suivant :  \nÉtant donné une matrice binaire mat de taille m x n, retourner la longueur de la plus longue ligne continue de 1 dans la matrice.  \n    La ligne peut être horizontale, verticale, diagonale ou anti-diagonale.\n   \n    @param mat La matrice binaire.\n    @return La longueur de la plus longue ligne continue de 1.\n   \n    Exemple :\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Sortie : 3",
      "de": "Schreiben Sie eine Java-Funktion `public static int longestLine(int[][] mat)`, um das folgende Problem zu lösen:\nGegeben eine binäre Matrix mat der Größe m x n, geben Sie die Länge der längsten kontinuierlichen Linie von 1en in der Matrix zurück.\n    Die Linie könnte horizontal, vertikal, diagonal oder anti-diagonal sein.\n   \n    @param mat Die binäre Matrix.\n    @return Die Länge der längsten kontinuierlichen Linie von 1en.\n   \n    Beispiel:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Ausgabe: 3",
      "ha": "Rubuta aikin Java `public static int longestLine(int[][] mat)` don warware matsalar mai zuwa:  \nAn ba da matrix na binary mat mai girman m x n, dawo da tsawon layin 1s mafi tsawo a cikin matrix.  \nLayin na iya zama a kwance, a tsaye, a diagonally, ko kuma anti-diagonally.\n\n@param mat Matrix na binary.  \n@return Tsawon layin 1s mafi tsawo.\n\nMisali:  \nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})  \nOutput: 3",
      "hi": "Java फ़ंक्शन `public static int longestLine(int[][] mat)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए बाइनरी मैट्रिक्स mat के आकार m x n के लिए, मैट्रिक्स में 1s की सबसे लंबी निरंतर रेखा की लंबाई लौटाएं।\n    रेखा क्षैतिज, लंबवत, विकर्ण, या प्रतिविकर्ण हो सकती है।\n   \n    @param mat बाइनरी मैट्रिक्स।\n    @return 1s की सबसे लंबी निरंतर रेखा की लंबाई।\n   \n    उदाहरण:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "hu": "Írj egy Java függvényt `public static int longestLine(int[][] mat)` a következő probléma megoldására:\nAdott egy m x n méretű bináris mátrix, térj vissza a leghosszabb folyamatos 1-esekből álló sor hosszával a mátrixban.\n    A sor lehet vízszintes, függőleges, átlós vagy anti-átlós.\n   \n    @param mat A bináris mátrix.\n    @return A leghosszabb folyamatos 1-esekből álló sor hossza.\n   \n    Példa:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Kimenet: 3"
    },
    "instruction_bertscore": {
      "sq": "0.9990165809834962",
      "hy": "0.9819452928854528",
      "bn": "0.9918098734987885",
      "bg": "0.9974515722113224",
      "zh": "0.9452765355033642",
      "fr": "0.9990165809834962",
      "de": "1",
      "ha": "0.9649073746914232",
      "hi": "0.9649173062104749",
      "hu": "0.9778630412944238"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "longestLine",
    "signature": "public static int longestLine(int[][] mat)",
    "docstring": {
      "en": "Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "sq": "Duke pasur një matricë binare mat me madhësi m x n, kthe gjatësinë e vijës më të gjatë të pandërprerë të 1-shave në matricë.\n    Vija mund të jetë horizontale, vertikale, diagonale, ose anti-diagonale.\n   \n    @param mat Matrica binare.\n    @return Gjatësia e vijës më të gjatë të pandërprerë të 1-shave.\n   \n    Shembull:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "hy": "Տրված է երկբային մատրիցա `mat` չափսի m x n, վերադարձնել մատրիցայում ամենաերկար շարունակական 1-երի գծի երկարությունը։ Գիծը կարող է լինել հորիզոնական, ուղղահայաց, անկյունագիծ կամ հակաանկյունագիծ։\n\n@param mat Երկբային մատրիցան։\n@return Ամենաերկար շարունակական 1-երի գծի երկարությունը։\n\nՕրինակ:\nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\nԵլք: 3",
      "bn": "একটি m x n আকারের বাইনারি ম্যাট্রিক্স mat দেওয়া হয়েছে, ম্যাট্রিক্সে 1s এর সবচেয়ে দীর্ঘতর ধারাবাহিক রেখার দৈর্ঘ্য ফেরত দিন।\n    রেখাটি অনুভূমিক, উল্লম্ব, তির্যক, বা বিপরীত তির্যক হতে পারে।\n\n    @param mat বাইনারি ম্যাট্রিক্স।\n    @return 1s এর সবচেয়ে দীর্ঘতর ধারাবাহিক রেখার দৈর্ঘ্য।\n\n    উদাহরণ:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    আউটপুট: 3",
      "bg": "Дадена е двоична матрица mat с размер m x n, върнете дължината на най-дългата непрекъсната линия от 1-ци в матрицата.\n    Линията може да бъде хоризонтална, вертикална, диагонална или анти-диагонална.\n\n@param mat Двоичната матрица.  \n@return Дължината на най-дългата непрекъсната линия от 1-ци.\n\nПример:  \nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})  \nOutput: 3",
      "zh": "给定一个大小为 m x n 的二进制矩阵 mat，返回矩阵中连续 1 的最长线的长度。\n    该线可以是水平的、垂直的、对角线的或反对角线的。\n   \n    @param mat 二进制矩阵。\n    @return 连续 1 的最长线的长度。\n   \n    示例:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    输出: 3",
      "fr": "Étant donné une matrice binaire mat de taille m x n, renvoyer la longueur de la plus longue ligne continue de 1s dans la matrice.  \n    La ligne peut être horizontale, verticale, diagonale ou anti-diagonale.\n   \n    @param mat La matrice binaire.\n    @return La longueur de la plus longue ligne continue de 1s.\n   \n    Exemple:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Sortie: 3",
      "de": "Gegeben eine binäre Matrix mat der Größe m x n, gib die Länge der längsten zusammenhängenden Linie von 1en in der Matrix zurück.\n    Die Linie könnte horizontal, vertikal, diagonal oder anti-diagonal verlaufen.\n   \n    @param mat Die binäre Matrix.\n    @return Die Länge der längsten kontinuierlichen Linie von 1en.\n   \n    Beispiel:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Ausgabe: 3",
      "ha": "An ba da matrix ɗin binary mat mai girman m x n, dawo da tsawon layin ci gaba mafi tsawo na 1s a cikin matrix ɗin.  \nLayin na iya zama a kwance, tsaye, diagonal, ko anti-diagonal.\n\n@param mat Matrix ɗin binary.\n@return Tsawon layin ci gaba mafi tsawo na 1s.\n\nMisali:\nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\nOutput: 3",
      "hi": "दिए गए बाइनरी मैट्रिक्स mat के आकार m x n के लिए, मैट्रिक्स में 1s की सबसे लंबी निरंतर रेखा की लंबाई लौटाएं।\n    रेखा क्षैतिज, लंबवत, विकर्ण, या प्रतिविकर्ण हो सकती है।\n\n    @param mat बाइनरी मैट्रिक्स।\n    @return 1s की सबसे लंबी निरंतर रेखा की लंबाई।\n\n    उदाहरण:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "hu": "Adott egy m x n méretű bináris mátrix, mat, térje vissza a leghosszabb folytonos 1-esekből álló vonal hosszát a mátrixban.\n    A vonal lehet vízszintes, függőleges, átlós vagy antidiagonális.\n   \n    @param mat A bináris mátrix.\n    @return Az 1-esekből álló leghosszabb folytonos vonal hossza.\n   \n    Példa:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Kimenet: 3"
    },
    "docstring_bertscore": {
      "sq": "0.981314244164905",
      "hy": "0.9822388685886224",
      "bn": "0.9664030614606159",
      "bg": "0.998844169812758",
      "zh": "0.9699835727091508",
      "fr": "0.998844169812758",
      "de": "1",
      "ha": "0.9743256328385734",
      "hi": "0.9707274434861265",
      "hu": "0.9781327813518692"
    }
  },
  {
    "task_id": "Java/41",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, shtoni një pikë ('.') si ndarës mijërash çdo tre shifra dhe kthejeni rezultatin si një varg.\n   *\n   * @param n Numri i plotë për të cilin do të shtohen ndarësit e mijërave.\n   * @return Vargu me ndarësit e mijërave të shtuar.\n   *\n   * Shembull:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Shembull:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Shembull:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Shembull:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, ավելացրեք կետ ('.') որպես հազարավորների բաժանարար յուրաքանչյուր երեք թվանշանից հետո և վերադարձնել արդյունքը որպես տող:\n   *\n   * @param n Թիվը, որին պետք է ավելացնել հազարավորների բաժանարարներ:\n   * @return Տողը՝ ավելացված հազարավորների բաժանարարներով:\n   *\n   * Օրինակ:\n   * addThousandSeparator(987)\n   * Արդյունք: \"987\"\n   *\n   * Օրինակ:\n   * addThousandSeparator(1234)\n   * Արդյունք: \"1.234\"\n   *\n   * Օրինակ:\n   * addThousandSeparator(123456789)\n   * Արդյունք: \"123.456.789\"\n   *\n   * Օրինակ:\n   * addThousandSeparator(0)\n   * Արդյունք: \"0\"\n   */\n  public static String addThousandSeparator(int n)",
      "bn": "public class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, প্রতি তিনটি অঙ্কের পর একটি ডট ('.') যোগ করুন এবং ফলাফলটি একটি স্ট্রিং হিসেবে ফেরত দিন।\n   *\n   * @param n পূর্ণসংখ্যা যাতে হাজার বিভাজক যোগ করতে হবে।\n   * @return স্ট্রিং যার মধ্যে হাজার বিভাজক যোগ করা হয়েছে।\n   *\n   * উদাহরণ:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * উদাহরণ:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * উদাহরণ:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * উদাহরণ:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е цяло число n, добавете точка ('.') като разделител на хиляди на всеки три цифри и върнете резултата като низ.\n   *\n   * @param n Цялото число, към което да се добавят разделители на хиляди.\n   * @return Низът с добавени разделители на хиляди.\n   *\n   * Пример:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Пример:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Пример:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Пример:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个整数 n，每三位数字添加一个点（'.'）作为千位分隔符，并将结果作为字符串返回。\n   *\n   * @param n 要添加千位分隔符的整数。\n   * @return 添加了千位分隔符的字符串。\n   *\n   * 示例:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * 示例:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * 示例:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * 示例:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier n, ajoutez un point ('.') comme séparateur de milliers tous les trois chiffres et renvoyez le résultat sous forme de chaîne.\n   *\n   * @param n L'entier auquel ajouter des séparateurs de milliers.\n   * @return La chaîne avec les séparateurs de milliers ajoutés.\n   *\n   * Exemple:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Exemple:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Exemple:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Exemple:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, füge einen Punkt ('.') als Tausendertrennzeichen alle drei Ziffern hinzu und gib das Ergebnis als Zeichenkette zurück.\n   *\n   * @param n Die ganze Zahl, der Tausendertrennzeichen hinzugefügt werden sollen.\n   * @return Die Zeichenkette mit hinzugefügten Tausendertrennzeichen.\n   *\n   * Beispiel:\n   * addThousandSeparator(987)\n   * Ausgabe: \"987\"\n   *\n   * Beispiel:\n   * addThousandSeparator(1234)\n   * Ausgabe: \"1.234\"\n   *\n   * Beispiel:\n   * addThousandSeparator(123456789)\n   * Ausgabe: \"123.456.789\"\n   *\n   * Beispiel:\n   * addThousandSeparator(0)\n   * Ausgabe: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba n, ƙara wata doka ('.') a matsayin mai raba dubu kowane lambobi uku kuma dawo da sakamakon a matsayin kirtani.\n   *\n   * @param n Lambar da za a ƙara masu raba dubu a kai.\n   * @return Kirtani tare da masu raba dubu da aka ƙara.\n   *\n   * Misali:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Misali:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Misali:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Misali:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n)",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए पूर्णांक n के लिए, हर तीन अंकों के बाद एक डॉट ('.') जोड़ें और परिणाम को एक स्ट्रिंग के रूप में लौटाएं।\n   *\n   * @param n वह पूर्णांक जिसमें हजारों विभाजक जोड़ने हैं।\n   * @return वह स्ट्रिंग जिसमें हजारों विभाजक जोड़े गए हैं।\n   *\n   * उदाहरण:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * उदाहरण:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * उदाहरण:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * उदाहरण:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy egész szám n, adjunk hozzá egy pontot ('.') ezres elválasztóként minden három számjegy után, és adjuk vissza az eredményt sztringként.\n   *\n   * @param n Az egész szám, amelyhez ezres elválasztókat kell hozzáadni.\n   * @return A sztring, amelyhez ezres elválasztók lettek hozzáadva.\n   *\n   * Példa:\n   * addThousandSeparator(987)\n   * Kimenet: \"987\"\n   *\n   * Példa:\n   * addThousandSeparator(1234)\n   * Kimenet: \"1.234\"\n   *\n   * Példa:\n   * addThousandSeparator(123456789)\n   * Kimenet: \"123.456.789\"\n   *\n   * Példa:\n   * addThousandSeparator(0)\n   * Kimenet: \"0\"\n   */\n  public static String addThousandSeparator(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9826947253130974",
      "hy": "0.969973045298956",
      "bn": "0.9657118277346145",
      "bg": "0.9832906164562021",
      "zh": "0.9653286697295982",
      "fr": "0.9927225800996438",
      "de": "0.9832906164562021",
      "ha": "0.9849094540616364",
      "hi": "0.9769032592932632",
      "hu": "0.9759009703905611"
    },
    "canonical_solution": "  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }",
    "instruction": {
      "en": "Write a Java function `public static String addThousandSeparator(int n)` to solve the following problem:\nGiven an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "sq": "Shkruani një funksion Java `public static String addThousandSeparator(int n)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë n, shtoni një pikë ('.') si ndarës mijësh çdo tre shifra dhe ktheni rezultatin si një varg.  \n\n    @param n Numri i plotë për të cilin do të shtohen ndarësit e mijëve.\n    @return Vargu me ndarësit e mijëve të shtuar.\n\n    Shembull:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    Shembull:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    Shembull:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    Shembull:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hy": "Գրեք Java ֆունկցիա `public static String addThousandSeparator(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n ամբողջ թիվը, ավելացնել կետ ('.') որպես հազարավորների բաժանարար յուրաքանչյուր երեք թվանշանից հետո և վերադարձնել արդյունքը որպես տող:\n\n    @param n Ամբողջ թիվը, որին պետք է ավելացնել հազարավորների բաժանարարներ:\n    @return Տող, որում ավելացված են հազարավորների բաժանարարներ:\n\n    Օրինակ:\n    addThousandSeparator(987)\n    Արդյունք: \"987\"\n   \n    Օրինակ:\n    addThousandSeparator(1234)\n    Արդյունք: \"1.234\"\n   \n    Օրինակ:\n    addThousandSeparator(123456789)\n    Արդյունք: \"123.456.789\"\n   \n    Օրինակ:\n    addThousandSeparator(0)\n    Արդյունք: \"0\"",
      "bn": "একটি জাভা ফাংশন `public static String addThousandSeparator(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া আছে, প্রতিটি তিনটি অঙ্কের পরে একটি ডট ('.') যোগ করুন এবং ফলাফলটি একটি স্ট্রিং হিসেবে ফেরত দিন।\n\n    @param n যে পূর্ণসংখ্যাটিতে হাজারের বিভাজক যোগ করতে হবে।\n    @return স্ট্রিং যা হাজারের বিভাজক যোগ করা হয়েছে।\n\n    উদাহরণ:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    উদাহরণ:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    উদাহরণ:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    উদাহরণ:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "bg": "Напишете Java функция `public static String addThousandSeparator(int n)`, за да решите следния проблем:  \nДадено е цяло число n, добавете точка ('.') като разделител за хиляди на всеки три цифри и върнете резултата като низ.\n\n    @param n Цялото число, към което да се добавят разделители за хиляди.\n    @return Низът с добавени разделители за хиляди.\n   \n    Пример:\n    addThousandSeparator(987)\n    Изход: \"987\"\n   \n    Пример:\n    addThousandSeparator(1234)\n    Изход: \"1.234\"\n   \n    Пример:\n    addThousandSeparator(123456789)\n    Изход: \"123.456.789\"\n   \n    Пример:\n    addThousandSeparator(0)\n    Изход: \"0\"",
      "zh": "编写一个 Java 函数 `public static String addThousandSeparator(int n)` 来解决以下问题：  \n给定一个整数 n，每三位数字添加一个点（'.'）作为千位分隔符，并将结果作为字符串返回。\n\n    @param n 添加千位分隔符的整数。\n    @return 添加了千位分隔符的字符串。\n   \n    示例：\n    addThousandSeparator(987)\n    输出: \"987\"\n   \n    示例：\n    addThousandSeparator(1234)\n    输出: \"1.234\"\n   \n    示例：\n    addThousandSeparator(123456789)\n    输出: \"123.456.789\"\n   \n    示例：\n    addThousandSeparator(0)\n    输出: \"0\"",
      "fr": "Écrire une fonction Java `public static String addThousandSeparator(int n)` pour résoudre le problème suivant :  \nÉtant donné un entier n, ajoutez un point ('.') comme séparateur de milliers tous les trois chiffres et retournez le résultat sous forme de chaîne.\n\n    @param n L'entier auquel ajouter des séparateurs de milliers.\n    @return La chaîne avec les séparateurs de milliers ajoutés.\n   \n    Exemple :\n    addThousandSeparator(987)\n    Sortie : \"987\"\n   \n    Exemple :\n    addThousandSeparator(1234)\n    Sortie : \"1.234\"\n   \n    Exemple :\n    addThousandSeparator(123456789)\n    Sortie : \"123.456.789\"\n   \n    Exemple :\n    addThousandSeparator(0)\n    Sortie : \"0\"",
      "de": "Schreiben Sie eine Java-Funktion `public static String addThousandSeparator(int n)`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, fügen Sie alle drei Ziffern einen Punkt ('.') als Tausendertrennzeichen hinzu und geben Sie das Ergebnis als Zeichenkette zurück.\n   \n    @param n Die ganze Zahl, der Tausendertrennzeichen hinzugefügt werden sollen.\n    @return Die Zeichenkette mit hinzugefügten Tausendertrennzeichen.\n   \n    Beispiel:\n    addThousandSeparator(987)\n    Ausgabe: \"987\"\n   \n    Beispiel:\n    addThousandSeparator(1234)\n    Ausgabe: \"1.234\"\n   \n    Beispiel:\n    addThousandSeparator(123456789)\n    Ausgabe: \"123.456.789\"\n   \n    Beispiel:\n    addThousandSeparator(0)\n    Ausgabe: \"0\"",
      "ha": "Rubuta aikin Java `public static String addThousandSeparator(int n)` don warware matsalar mai zuwa:  \nAn ba da wani cikakken lamba n, ƙara dige ('.') a matsayin mai raba dubu a kowane lambobi uku kuma mayar da sakamakon a matsayin kirtani.\n\n    @param n Lambar cikakke don ƙara masu raba dubu zuwa.\n    @return Kirtani tare da masu raba dubu da aka ƙara.\n\n    Misali:\n    addThousandSeparator(987)\n    Fitarwa: \"987\"\n\n    Misali:\n    addThousandSeparator(1234)\n    Fitarwa: \"1.234\"\n\n    Misali:\n    addThousandSeparator(123456789)\n    Fitarwa: \"123.456.789\"\n\n    Misali:\n    addThousandSeparator(0)\n    Fitarwa: \"0\"",
      "hi": "Java फ़ंक्शन `public static String addThousandSeparator(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के हर तीन अंकों के बाद एक बिंदु ('.') जोड़ें और परिणाम को एक स्ट्रिंग के रूप में लौटाएं।\n\n    @param n वह पूर्णांक जिसमें हजार विभाजक जोड़ने हैं।\n    @return स्ट्रिंग जिसमें हजार विभाजक जोड़े गए हैं।\n\n    उदाहरण:\n    addThousandSeparator(987)\n    आउटपुट: \"987\"\n\n    उदाहरण:\n    addThousandSeparator(1234)\n    आउटपुट: \"1.234\"\n\n    उदाहरण:\n    addThousandSeparator(123456789)\n    आउटपुट: \"123.456.789\"\n\n    उदाहरण:\n    addThousandSeparator(0)\n    आउटपुट: \"0\"",
      "hu": "Írj egy Java függvényt `public static String addThousandSeparator(int n)` a következő probléma megoldására:\nAdott egy egész szám n, adj hozzá egy pontot ('.') ezres elválasztóként minden három számjegy után, és az eredményt adja vissza sztringként.\n   \n    @param n Az egész szám, amelyhez ezres elválasztókat kell hozzáadni.\n    @return A sztring, amelyhez hozzá lettek adva az ezres elválasztók.\n   \n    Példa:\n    addThousandSeparator(987)\n    Kimenet: \"987\"\n   \n    Példa:\n    addThousandSeparator(1234)\n    Kimenet: \"1.234\"\n   \n    Példa:\n    addThousandSeparator(123456789)\n    Kimenet: \"123.456.789\"\n   \n    Példa:\n    addThousandSeparator(0)\n    Kimenet: \"0\""
    },
    "instruction_bertscore": {
      "sq": "0.9830457051963861",
      "hy": "0.9690943044932576",
      "bn": "0.9702415935741151",
      "bg": "0.9859208799618661",
      "zh": "0.9971671335056804",
      "fr": "0.9905587007286497",
      "de": "0.9859208799618661",
      "ha": "0.9926675594840971",
      "hi": "0.9499302467006305",
      "hu": "0.9811281274978753"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "addThousandSeparator",
    "signature": "public static String addThousandSeparator(int n)",
    "docstring": {
      "en": "Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "sq": "Duke pasur një numër të plotë n, shtoni një pikë ('.') si një ndarës mijërash çdo tre shifra dhe ktheni rezultatin si një varg.\n   \n    @param n Numri i plotë për të cilin do të shtohen ndarës mijërash.\n    @return Vargu me ndarës mijërash të shtuar.\n\n    Shembull:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    Shembull:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    Shembull:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    Shembull:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hy": "Տրված է n ամբողջ թիվը, ավելացնել կետ ('.') որպես հազարավոր բաժանարար յուրաքանչյուր երեք թվանշանից հետո և վերադարձնել արդյունքը որպես տող։\n   \n    @param n Ամբողջ թիվը, որին պետք է ավելացնել հազարավոր բաժանարարներ։\n    @return Տողը, որում ավելացված են հազարավոր բաժանարարներ։\n\n    Օրինակ:\n    addThousandSeparator(987)\n    Արդյունք: \"987\"\n\n    Օրինակ:\n    addThousandSeparator(1234)\n    Արդյունք: \"1.234\"\n\n    Օրինակ:\n    addThousandSeparator(123456789)\n    Արդյունք: \"123.456.789\"\n\n    Օրինակ:\n    addThousandSeparator(0)\n    Արդյունք: \"0\"",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, প্রতি তিনটি অঙ্কের পর একটি ডট ('.') যোগ করুন এবং ফলাফলটি একটি স্ট্রিং হিসাবে ফেরত দিন।\n   \n    @param n যে পূর্ণসংখ্যায় হাজার বিভাজক যোগ করতে হবে।\n    @return স্ট্রিং যা হাজার বিভাজক যোগ করার পর ফেরত দেওয়া হবে।\n\n    উদাহরণ:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    উদাহরণ:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    উদাহরণ:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    উদাহরণ:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "bg": "Дадено е цяло число n, добавете точка ('.') като разделител за хиляди на всеки три цифри и върнете резултата като низ.\n   \n    @param n Цялото число, към което да се добавят разделители за хиляди.\n    @return Низът с добавени разделители за хиляди.\n   \n    Пример:\n    addThousandSeparator(987)\n    Изход: \"987\"\n   \n    Пример:\n    addThousandSeparator(1234)\n    Изход: \"1.234\"\n   \n    Пример:\n    addThousandSeparator(123456789)\n    Изход: \"123.456.789\"\n   \n    Пример:\n    addThousandSeparator(0)\n    Изход: \"0\"",
      "zh": "给定一个整数 n，每三位数字添加一个点（'.'）作为千位分隔符，并将结果作为字符串返回。\n   \n    @param n 要添加千位分隔符的整数。\n    @return 添加了千位分隔符的字符串。\n   \n    示例:\n    addThousandSeparator(987)\n    输出: \"987\"\n   \n    示例:\n    addThousandSeparator(1234)\n    输出: \"1.234\"\n   \n    示例:\n    addThousandSeparator(123456789)\n    输出: \"123.456.789\"\n   \n    示例:\n    addThousandSeparator(0)\n    输出: \"0\"",
      "fr": "Étant donné un entier n, ajoutez un point ('.') comme séparateur de milliers tous les trois chiffres et renvoyez le résultat sous forme de chaîne de caractères.\n   \n    @param n L'entier auquel ajouter des séparateurs de milliers.\n    @return La chaîne de caractères avec les séparateurs de milliers ajoutés.\n   \n    Exemple:\n    addThousandSeparator(987)\n    Sortie: \"987\"\n   \n    Exemple:\n    addThousandSeparator(1234)\n    Sortie: \"1.234\"\n   \n    Exemple:\n    addThousandSeparator(123456789)\n    Sortie: \"123.456.789\"\n   \n    Exemple:\n    addThousandSeparator(0)\n    Sortie: \"0\"",
      "de": "Gegeben eine ganze Zahl n, füge einen Punkt ('.') als Tausendertrennzeichen alle drei Ziffern hinzu und gib das Ergebnis als Zeichenkette zurück.\n   \n    @param n Die ganze Zahl, der Tausendertrennzeichen hinzugefügt werden sollen.\n    @return Der String mit hinzugefügten Tausendertrennzeichen.\n\n    Beispiel:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    Beispiel:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    Beispiel:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    Beispiel:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "ha": "An ba da wani lamba n, ƙara wata doka ('.') a matsayin mai raba dubu kowane lambobi uku kuma dawo da sakamakon a matsayin kirtani.\n   \n    @param n Lambar cikakke da za a kara masu raba dubu.\n    @return Kirtani tare da masu raba dubu da aka kara.\n\n    Misali:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Misali:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Misali:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Misali:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hi": "दिए गए पूर्णांक n के लिए, हर तीन अंकों के बाद एक डॉट ('.') को हजारों विभाजक के रूप में जोड़ें और परिणाम को एक स्ट्रिंग के रूप में लौटाएं।\n   \n    @param n वह पूर्णांक जिसमें हजारों विभाजक जोड़ना है।\n    @return वह स्ट्रिंग जिसमें हजारों विभाजक जोड़े गए हैं।\n\n    उदाहरण:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    उदाहरण:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    उदाहरण:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    उदाहरण:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hu": "Adott egy egész szám n, adjunk hozzá egy pontot ('.') ezres elválasztóként minden három számjegy után, és az eredményt adjuk vissza sztringként.\n   \n    @param n Az egész szám, amelyhez ezres elválasztókat kell hozzáadni.\n    @return A sztring, amelyhez hozzá lettek adva az ezres elválasztók.\n   \n    Példa:\n    addThousandSeparator(987)\n    Kimenet: \"987\"\n   \n    Példa:\n    addThousandSeparator(1234)\n    Kimenet: \"1.234\"\n   \n    Példa:\n    addThousandSeparator(123456789)\n    Kimenet: \"123.456.789\"\n   \n    Példa:\n    addThousandSeparator(0)\n    Kimenet: \"0\""
    },
    "docstring_bertscore": {
      "sq": "0.9803935923488083",
      "hy": "0.9670881376448053",
      "bn": "0.9497870341959044",
      "bg": "0.9815676965311054",
      "zh": "0.959514957107088",
      "fr": "0.9804795993037964",
      "de": "0.9762497653396585",
      "ha": "0.9666775686472061",
      "hi": "0.9556202125957559",
      "hu": "0.9622203028967833"
    }
  },
  {
    "task_id": "Java/42",
    "prompt": {
      "en": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "sq": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Duke pasur një varg të numrave të plotë jo-negativ A, nëse shuma e çdo çifti të elementeve ngjitur në varg është një katror perfekt, atëherë vargu konsiderohet si një varg katror.\n   * Kthe numrin e permutacioneve katrore të A. Dy permutacione A1 dhe A2 konsiderohen të ndryshme nëse ekziston një indeks i tillë që A1[i] != A2[i].\n   *\n   * @param A Vargu hyrës i numrave të plotë jo-negativ.\n   * @return Numri i permutacioneve katrore të A.\n   *\n   * Shembull:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Shembull:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "hy": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Տրված է ոչ բացասական ամբողջ թվերի զանգված A, եթե զանգվածի հարակից տարրերի զույգերի գումարը կատարյալ քառակուսի է, ապա զանգվածը համարվում է քառակուսի զանգված:\n   * Վերադարձնում է A-ի քառակուսի փոխատեղումների քանակը։ Երկու փոխատեղումներ A1 և A2 համարվում են տարբեր, եթե գոյություն ունի i ինդեքս, որ A1[i] != A2[i]:\n   *\n   * @param A Մուտքային ոչ բացասական ամբողջ թվերի զանգվածը։\n   * @return A-ի քառակուսի փոխատեղումների քանակը։\n   *\n   * Օրինակ:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Արդյունք: 2\n   *\n   * Օրինակ:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Արդյունք: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "bn": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * একটি অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে A দেওয়া হলে, যদি অ্যারের প্রতিটি সন্নিহিত উপাদানের জোড়ার যোগফল একটি পূর্ণবর্গ হয়, তাহলে অ্যারেটিকে একটি বর্গাকার অ্যারে হিসেবে বিবেচনা করা হয়।\n   * A এর বর্গাকার বিন্যাসের সংখ্যা ফেরত দিন। দুটি বিন্যাস A1 এবং A2 কে ভিন্ন বলে বিবেচনা করা হয় যদি এমন একটি সূচক i থাকে যাতে A1[i] != A2[i]।\n   *\n   * @param A ইনপুট অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে।\n   * @return A এর বর্গাকার বিন্যাসের সংখ্যা।\n   *\n   * উদাহরণ:\n   * squarePermutations(new int[]{1, 17, 8})\n   * আউটপুট: 2\n   *\n   * উদাহরণ:\n   * squarePermutations(new int[]{2, 2, 2})\n   * আউটপুট: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "bg": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Даден е масив A от неотрицателни цели числа, ако сумата на всяка двойка съседни елементи в масива е точен квадрат, тогава масивът се счита за квадратен масив.\n   * Връща броя на квадратните пермутации на A. Две пермутации A1 и A2 се считат за различни, ако съществува индекс i, такъв че A1[i] != A2[i].\n   *\n   * @param A Входният масив от неотрицателни цели числа.\n   * @return Броят на квадратните пермутации на A.\n   *\n   * Пример:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Пример:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "zh": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * 给定一个非负整数数组A，如果数组中每对相邻元素的和是一个完全平方数，则该数组被视为一个平方数组。\n   * 返回A的平方排列的数量。如果存在一个索引i使得A1[i] != A2[i]，则两个排列A1和A2被视为不同。\n   *\n   * @param A 输入的非负整数数组。\n   * @return A的平方排列的数量。\n   *\n   * 示例:\n   * squarePermutations(new int[]{1, 17, 8})\n   * 输出: 2\n   *\n   * 示例:\n   * squarePermutations(new int[]{2, 2, 2})\n   * 输出: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "fr": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Étant donné un tableau d'entiers non négatifs A, si la somme de chaque paire d'éléments adjacents dans le tableau est un carré parfait, alors le tableau est considéré comme un tableau carré.\n   * Retourne le nombre de permutations carrées de A. Deux permutations A1 et A2 sont considérées différentes s'il existe un indice i tel que A1[i] != A2[i].\n   *\n   * @param A Le tableau d'entiers non négatifs en entrée.\n   * @return Le nombre de permutations carrées de A.\n   *\n   * Exemple:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Exemple:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "de": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Gegeben ein nicht-negatives Integer-Array A, wenn die Summe jedes Paares benachbarter Elemente im Array ein perfektes Quadrat ist, dann wird das Array als Quadrat-Array betrachtet.\n   * Gib die Anzahl der quadratischen Permutationen von A zurück. Zwei Permutationen A1 und A2 werden als unterschiedlich betrachtet, wenn es einen Index i gibt, so dass A1[i] != A2[i].\n   *\n   * @param A Das Eingabe-Array aus nicht-negativen ganzen Zahlen.\n   * @return Die Anzahl der quadratischen Permutationen von A.\n   *\n   * Beispiel:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Ausgabe: 2\n   *\n   * Beispiel:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Ausgabe: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "ha": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * An ba da wani jerin lambobi marasa kyau A, idan jumlar kowace ma'aurata na abubuwan da ke makwabtaka a cikin jerin cikakke ne murabba'i, to ana ɗaukar jerin a matsayin jerin murabba'i.\n   * Mayar da adadin murabba'in permutations na A. Ana ɗaukar permutations biyu A1 da A2 daban-daban idan akwai wani index i wanda A1[i] != A2[i].\n   *\n   * @param A Shigar da jerin lambobi marasa kyau.\n   * @return Adadin murabba'in permutations na A.\n   *\n   * Misali:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Misali:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "hi": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * दिए गए एक गैर-ऋणात्मक पूर्णांक सरणी A में, यदि सरणी के प्रत्येक संलग्न तत्वों की जोड़ी का योग एक पूर्ण वर्ग है, तो सरणी को एक वर्ग सरणी माना जाता है।\n   * A के वर्ग क्रमचयों की संख्या लौटाएं। दो क्रमचय A1 और A2 को अलग माना जाता है यदि कोई ऐसा सूचकांक i मौजूद है जिससे A1[i] != A2[i] हो।\n   *\n   * @param A इनपुट गैर-ऋणात्मक पूर्णांक सरणी।\n   * @return A के वर्ग क्रमचयों की संख्या।\n   *\n   * उदाहरण:\n   * squarePermutations(new int[]{1, 17, 8})\n   * आउटपुट: 2\n   *\n   * उदाहरण:\n   * squarePermutations(new int[]{2, 2, 2})\n   * आउटपुट: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "hu": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Adott egy nemnegatív egész számokat tartalmazó tömb, A, ha a tömb szomszédos elemeinek összege tökéletes négyzet, akkor a tömb négyzet tömbnek tekinthető.\n   * Adja vissza A négyzet permutációinak számát. Két permutáció, A1 és A2 különbözőnek tekintendő, ha létezik egy i index, amelyre A1[i] != A2[i].\n   *\n   * @param A A bemeneti nemnegatív egész számokat tartalmazó tömb.\n   * @return A négyzet permutációinak száma A esetén.\n   *\n   * Példa:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Kimenet: 2\n   *\n   * Példa:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Kimenet: 1\n   */\n  public static int squarePermutations(int[] A) "
    },
    "prompt_bertscore": {
      "sq": "0.980791051741259",
      "hy": "0.9846329605712358",
      "bn": "0.9708702587300906",
      "bg": "0.9871805938383893",
      "zh": "0.9719084997317599",
      "fr": "0.9888417397149841",
      "de": "0.9942923560009624",
      "ha": "0.9689556604872952",
      "hi": "0.9790299947830038",
      "hu": "0.9620165081258414"
    },
    "canonical_solution": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }",
    "instruction": {
      "en": "Write a Java function `public static int squarePermutations(int[] A)` to solve the following problem:\nGiven a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "sq": "Shkruani një funksion Java `public static int squarePermutations(int[] A)` për të zgjidhur problemin në vijim:  \nDuke pasur një varg të numrave të plotë jo-negativ A, nëse shuma e çdo çifti të elementeve ngjitur në varg është një katror i përsosur, atëherë vargu konsiderohet si një varg katror.  \nKtheni numrin e permutacioneve katrore të A. Dy permutacione A1 dhe A2 konsiderohen të ndryshme nëse ekziston një indeks i tillë që A1[i] != A2[i].\n\n@param A Vargu hyrës i numrave të plotë jo-negativ.  \n@return Numri i permutacioneve katrore të A.\n\nShembull:  \nsquarePermutations(new int[]{1, 17, 8})  \nDalja: 2\n\nShembull:  \nsquarePermutations(new int[]{2, 2, 2})  \nDalja: 1",
      "hy": "Գրեք Java ֆունկցիա `public static int squarePermutations(int[] A)` հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թվերի զանգված A, եթե զանգվածի հարևան տարրերի զույգերի գումարը կատարյալ քառակուսի է, ապա զանգվածը համարվում է քառակուսի զանգված:\n    Վերադարձնել A-ի քառակուսի փոխարկումների քանակը։ Երկու փոխարկումներ A1 և A2 համարվում են տարբեր, եթե գոյություն ունի ինդեքս i, այնպես որ A1[i] != A2[i]:\n\n    @param A Մուտքային ոչ բացասական ամբողջ թվերի զանգվածը։\n    @return A-ի քառակուսի փոխարկումների քանակը։\n\n    Օրինակ:\n    squarePermutations(new int[]{1, 17, 8})\n    Արդյունք: 2\n\n    Օրինակ:\n    squarePermutations(new int[]{2, 2, 2})\n    Արդյունք: 1",
      "bn": "একটি জাভা ফাংশন `public static int squarePermutations(int[] A)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযদি একটি অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে A এর প্রতিটি সংলগ্ন উপাদান জোড়ার যোগফল একটি পূর্ণ বর্গ হয়, তাহলে অ্যারেটি একটি বর্গাকার অ্যারে হিসাবে বিবেচিত হয়।\n    A এর বর্গাকার পরিবর্তনগুলির সংখ্যা ফেরত দিন। দুটি পরিবর্তন A1 এবং A2 ভিন্ন হিসাবে বিবেচিত হয় যদি এমন একটি সূচক i থাকে যাতে A1[i] != A2[i] হয়।\n\n    @param A ইনপুট অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে।\n    @return A এর বর্গাকার পরিবর্তনগুলির সংখ্যা।\n\n    উদাহরণ:\n    squarePermutations(new int[]{1, 17, 8})\n    আউটপুট: 2\n\n    উদাহরণ:\n    squarePermutations(new int[]{2, 2, 2})\n    আউটপুট: 1",
      "bg": "Напишете Java функция `public static int squarePermutations(int[] A)`, за да решите следния проблем:  \nДаден е масив от неотрицателни цели числа A, ако сумата на всяка двойка съседни елементи в масива е точен квадрат, тогава масивът се счита за квадратен масив.  \nВърнете броя на квадратните пермутации на A. Две пермутации A1 и A2 се считат за различни, ако съществува индекс i, такъв че A1[i] != A2[i].\n\n@param A Входният масив от неотрицателни цели числа.  \n@return Броят на квадратните пермутации на A.\n\nПример:  \nsquarePermutations(new int[]{1, 17, 8})  \nИзход: 2\n\nПример:  \nsquarePermutations(new int[]{2, 2, 2})  \nИзход: 1",
      "zh": "编写一个 Java 函数 `public static int squarePermutations(int[] A)` 来解决以下问题：  \n给定一个非负整数数组 A，如果数组中每对相邻元素的和是一个完全平方数，则该数组被认为是一个平方数组。  \n返回 A 的平方排列数。如果存在一个索引 i 使得 A1[i] != A2[i]，则两个排列 A1 和 A2 被认为是不同的。\n\n@param A 输入的非负整数数组。  \n@return A 的平方排列数。\n\n示例：  \nsquarePermutations(new int[]{1, 17, 8})  \n输出: 2\n\n示例：  \nsquarePermutations(new int[]{2, 2, 2})  \n输出: 1",
      "fr": "Écrire une fonction Java `public static int squarePermutations(int[] A)` pour résoudre le problème suivant :  \nÉtant donné un tableau d'entiers non négatifs A, si la somme de chaque paire d'éléments adjacents dans le tableau est un carré parfait, alors le tableau est considéré comme un tableau carré.  \nRetourner le nombre de permutations carrées de A. Deux permutations A1 et A2 sont considérées différentes s'il existe un indice i tel que A1[i] != A2[i].\n\n@param A Le tableau d'entiers non négatifs en entrée.  \n@return Le nombre de permutations carrées de A.\n\nExemple :  \nsquarePermutations(new int[]{1, 17, 8})  \nSortie : 2\n\nExemple :  \nsquarePermutations(new int[]{2, 2, 2})  \nSortie : 1",
      "de": "Schreiben Sie eine Java-Funktion `public static int squarePermutations(int[] A)`, um das folgende Problem zu lösen:\nGegeben ein nicht-negatives Ganzzahl-Array A, wenn die Summe jedes Paares benachbarter Elemente im Array ein perfektes Quadrat ist, dann wird das Array als Quadrat-Array betrachtet.\n    Geben Sie die Anzahl der Quadrat-Permutationen von A zurück. Zwei Permutationen A1 und A2 werden als unterschiedlich betrachtet, wenn es einen Index i gibt, sodass A1[i] != A2[i] ist.\n   \n    @param A Das Eingabe-Array nicht-negativer Ganzzahlen.\n    @return Die Anzahl der Quadrat-Permutationen von A.\n   \n    Beispiel:\n    squarePermutations(new int[]{1, 17, 8})\n    Ausgabe: 2\n   \n    Beispiel:\n    squarePermutations(new int[]{2, 2, 2})\n    Ausgabe: 1",
      "ha": "Rubuta aikin Java `public static int squarePermutations(int[] A)` don warware matsalar mai zuwa:\nAn ba da jerin lambobi marasa kyau A, idan jumlar kowanne ma'aurata na abubuwan kusa a cikin jerin lambobin ya zama cikakken murabba'i, to ana ɗaukar jerin lambobin a matsayin jerin murabba'i.\n    Mayar da adadin murabba'in permutations na A. Ana ɗaukar permutations biyu A1 da A2 daban-daban idan akwai wani index i inda A1[i] != A2[i].\n   \n    @param A Shigar jerin lambobi marasa kyau.\n    @return Adadin murabba'in permutations na A.\n   \n    Misali:\n    squarePermutations(new int[]{1, 17, 8})\n    Fitarwa: 2\n   \n    Misali:\n    squarePermutations(new int[]{2, 2, 2})\n    Fitarwa: 1",
      "hi": "Java फ़ंक्शन `public static int squarePermutations(int[] A)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयदि किसी गैर-ऋणात्मक पूर्णांक array A में प्रत्येक जोड़ी के आसन्न तत्वों का योग एक पूर्ण वर्ग है, तो array को एक वर्ग array माना जाता है। \n    A के वर्ग क्रमपरिवर्तनों की संख्या लौटाएं। दो क्रमपरिवर्तन A1 और A2 को अलग माना जाता है यदि कोई ऐसा सूचकांक i मौजूद है जिससे A1[i] != A2[i] हो।\n\n    @param A इनपुट गैर-ऋणात्मक पूर्णांक array।\n    @return A के वर्ग क्रमपरिवर्तनों की संख्या।\n\n    उदाहरण:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n\n    उदाहरण:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "hu": "Írj egy Java függvényt `public static int squarePermutations(int[] A)` a következő probléma megoldására:\nAdott egy nem-negatív egész számokat tartalmazó tömb A, ha a tömb minden szomszédos elempárjának összege tökéletes négyzet, akkor a tömb négyzet tömbnek minősül.\n    Add vissza A négyzet permutációinak számát. Két permutáció A1 és A2 különbözőnek tekintendő, ha létezik egy i index, amelyre A1[i] != A2[i].\n   \n    @param A A bemeneti nem-negatív egész számokat tartalmazó tömb.\n    @return A négyzet permutációinak száma A esetén.\n   \n    Példa:\n    squarePermutations(new int[]{1, 17, 8})\n    Kimenet: 2\n   \n    Példa:\n    squarePermutations(new int[]{2, 2, 2})\n    Kimenet: 1"
    },
    "instruction_bertscore": {
      "sq": "0.9845556933530133",
      "hy": "0.9716367733705041",
      "bn": "0.9654454643936468",
      "bg": "0.9857220509504502",
      "zh": "0.969494941971805",
      "fr": "0.9869291277759992",
      "de": "0.9928008404697715",
      "ha": "0.9638468870870779",
      "hi": "0.9655006836395744",
      "hu": "0.9760646418245339"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "squarePermutations",
    "signature": "public static int squarePermutations(int[] A)",
    "docstring": {
      "en": "Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "sq": "Given një varg të numrave të plotë jo-negativ A, nëse shuma e secilit çift elementësh ngjitur në varg është një katror perfekt, atëherë vargu konsiderohet si një varg katror.\n    Kthe numrin e permutacioneve katrore të A. Dy permutacione A1 dhe A2 konsiderohen të ndryshme nëse ekziston një indeks i tillë që A1[i] != A2[i].\n   \n    @param A Vargu hyrës i numrave të plotë jo-negativ.\n    @return Numri i permutacioneve katrore të A.\n   \n    Shembull:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Shembull:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "hy": "Տրված է ոչ բացասական ամբողջ թվերի զանգված A, եթե զանգվածի հարակից տարրերի զույգերի գումարը կատարյալ քառակուսի է, ապա զանգվածը համարվում է քառակուսի զանգված։ \n    Վերադարձնել A-ի քառակուսի փոխատեղումների քանակը։ Երկու փոխատեղումներ A1 և A2 համարվում են տարբեր, եթե գոյություն ունի i ինդեքս, որի դեպքում A1[i] != A2[i]։\n\n    @param A Մուտքային ոչ բացասական ամբողջ թվերի զանգվածը։\n    @return A-ի քառակուսի փոխատեղումների քանակը։\n\n    Օրինակ:\n    squarePermutations(new int[]{1, 17, 8})\n    Արդյունք: 2\n\n    Օրինակ:\n    squarePermutations(new int[]{2, 2, 2})\n    Արդյունք: 1",
      "bn": "প্রদত্ত একটি অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে A, যদি অ্যারেতে প্রতিটি সন্নিহিত উপাদানের জোড়ার যোগফল একটি পূর্ণবর্গ হয়, তবে অ্যারেটিকে একটি বর্গাকার অ্যারে হিসেবে বিবেচনা করা হয়। \n    A এর বর্গাকার বিন্যাসের সংখ্যা ফেরত দিন। দুটি বিন্যাস A1 এবং A2 কে ভিন্ন বিবেচনা করা হয় যদি এমন একটি সূচক i থাকে যাতে A1[i] != A2[i] হয়।\n\n    @param A ইনপুট অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে।\n    @return A এর বর্গাকার বিন্যাসের সংখ্যা।\n\n    উদাহরণ:\n    squarePermutations(new int[]{1, 17, 8})\n    আউটপুট: 2\n\n    উদাহরণ:\n    squarePermutations(new int[]{2, 2, 2})\n    আউটপুট: 1",
      "bg": "Даден е масив от неотрицателни цели числа A, ако сумата на всяка двойка съседни елементи в масива е точен квадрат, тогава масивът се счита за квадратен масив.\n    Върнете броя на квадратните пермутации на A. Две пермутации A1 и A2 се считат за различни, ако съществува индекс i такъв, че A1[i] != A2[i].\n   \n    @param A Входният масив от неотрицателни цели числа.\n    @return Броят на квадратните пермутации на A.\n   \n    Пример:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Пример:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "zh": "给定一个非负整数数组A，如果数组中每对相邻元素的和是一个完全平方数，则该数组被认为是一个平方数组。\n    返回A的平方排列的数量。如果存在一个索引i使得A1[i] != A2[i]，则两个排列A1和A2被认为是不同的。\n   \n    @param A 输入的非负整数数组。\n    @return A的平方排列的数量。\n   \n    示例:\n    squarePermutations(new int[]{1, 17, 8})\n    输出: 2\n   \n    示例:\n    squarePermutations(new int[]{2, 2, 2})\n    输出: 1",
      "fr": "Étant donné un tableau d'entiers non négatifs A, si la somme de chaque paire d'éléments adjacents dans le tableau est un carré parfait, alors le tableau est considéré comme un tableau carré.\n    Retourne le nombre de permutations carrées de A. Deux permutations A1 et A2 sont considérées différentes s'il existe un indice i tel que A1[i] != A2[i].\n   \n    @param A Le tableau d'entiers non négatifs d'entrée.\n    @return Le nombre de permutations carrées de A.\n   \n    Exemple:\n    squarePermutations(new int[]{1, 17, 8})\n    Sortie: 2\n   \n    Exemple:\n    squarePermutations(new int[]{2, 2, 2})\n    Sortie: 1",
      "de": "Gegeben ein nicht-negatives Integer-Array A, wenn die Summe jedes Paares benachbarter Elemente im Array ein perfektes Quadrat ist, dann wird das Array als Quadrat-Array betrachtet.\n    Geben Sie die Anzahl der quadratischen Permutationen von A zurück. Zwei Permutationen A1 und A2 werden als unterschiedlich betrachtet, wenn es einen Index i gibt, sodass A1[i] != A2[i].\n\n    @param A Das Eingabe-Array nicht-negativer Ganzzahlen.\n    @return Die Anzahl der quadratischen Permutationen von A.\n\n    Beispiel:\n    squarePermutations(new int[]{1, 17, 8})\n    Ausgabe: 2\n\n    Beispiel:\n    squarePermutations(new int[]{2, 2, 2})\n    Ausgabe: 1",
      "ha": "An ba da jerin lambobi marasa kyau A, idan jumlar kowanne ma'aurata na abubuwan da ke makwabtaka a cikin jerin lambobin ta kasance cikakken murabba'i, to ana ɗaukar jerin lambobin a matsayin jerin murabba'i.\n    Mayar da adadin permutations na murabba'i na A. Ana ɗaukar permutations A1 da A2 daban idan akwai wani index i wanda A1[i] != A2[i].\n   \n    @param A Jerin lambobi marasa kyau na shigarwa.\n    @return Adadin permutations na murabba'i na A.\n   \n    Misali:\n    squarePermutations(new int[]{1, 17, 8})\n    Fitarwa: 2\n   \n    Misali:\n    squarePermutations(new int[]{2, 2, 2})\n    Fitarwa: 1",
      "hi": "दी गई एक गैर-ऋणात्मक पूर्णांक सरणी A के लिए, यदि सरणी में प्रत्येक समीपवर्ती तत्वों की जोड़ी का योग एक पूर्ण वर्ग है, तो सरणी को एक वर्ग सरणी माना जाता है। \n    A के वर्ग क्रमचयों की संख्या लौटाएं। दो क्रमचय A1 और A2 को अलग माना जाता है यदि कोई ऐसा सूचकांक i मौजूद हो जिसके लिए A1[i] != A2[i] हो।\n\n    @param A इनपुट गैर-ऋणात्मक पूर्णांक सरणी।\n    @return A के वर्ग क्रमचयों की संख्या।\n\n    उदाहरण:\n    squarePermutations(new int[]{1, 17, 8})\n    आउटपुट: 2\n\n    उदाहरण:\n    squarePermutations(new int[]{2, 2, 2})\n    आउटपुट: 1",
      "hu": "Adott egy nemnegatív egész számokat tartalmazó tömb, A, ha a tömb szomszédos elemeinek összege tökéletes négyzet, akkor a tömb négyzet tömbnek tekinthető.\n    Visszaadja A négyzet permutációinak számát. Két permutáció, A1 és A2 különbözőnek tekinthető, ha létezik egy i index, amelyre A1[i] != A2[i].\n   \n    @param A A bemeneti nemnegatív egész számokat tartalmazó tömb.\n    @return A négyzet permutációinak száma A-ból.\n   \n    Példa:\n    squarePermutations(new int[]{1, 17, 8})\n    Kimenet: 2\n   \n    Példa:\n    squarePermutations(new int[]{2, 2, 2})\n    Kimenet: 1"
    },
    "docstring_bertscore": {
      "sq": "0.9768371153763786",
      "hy": "0.9577564823437862",
      "bn": "0.9438475885421992",
      "bg": "0.9854858794273997",
      "zh": "0.9659984513744478",
      "fr": "0.983079273730781",
      "de": "0.9916922843132158",
      "ha": "0.9491460539563048",
      "hi": "0.9686275230978256",
      "hu": "0.9558313566907961"
    }
  },
  {
    "task_id": "Java/43",
    "prompt": {
      "en": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "sq": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Duke pasur parasysh n numra të plotë jo-negativë që përfaqësojnë lartësitë e shiritave në një grafik me shiritë.\n   * Çdo shirit ka një gjerësi prej 1 njësie. Llogaritni sipërfaqen më të madhe të drejtkëndëshit që mund të formohet në grafik me shiritë.\n   *\n   * @param heights Një varg numrash të plotë që përfaqësojnë lartësitë e shiritave.\n   * @return Sipërfaqja maksimale e drejtkëndëshit që mund të formohet.\n   *\n   * Shembull:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Shembull:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "hy": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Տրված են n ոչ բացասական ամբողջ թվեր, որոնք ներկայացնում են սյուների բարձրությունները սյունակային գծապատկերում։\n   * Յուրաքանչյուր սյուն ունի 1 միավոր լայնություն։ Հաշվեք ամենամեծ ուղղանկյուն տարածքը, որը կարող է ձևավորվել սյունակային գծապատկերում։\n   *\n   * @param heights Ամբողջ թվերի զանգված, որը ներկայացնում է սյուների բարձրությունները։\n   * @return Ուղղանկյան առավելագույն տարածքը, որը կարող է ձևավորվել։\n   *\n   * Օրինակ:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Արդյունք: 10\n   *\n   * Օրինակ:\n   * largestRectangleArea(new int[]{2,4})\n   * Արդյունք: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "bn": "import java.util.*;\npublic class Solution {\n\n  /**\n   * n টি অ-ঋণাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে যা একটি বার চার্টের বারগুলির উচ্চতা উপস্থাপন করে।\n   * প্রতিটি বারের প্রস্থ 1 ইউনিট। বার চার্টে যে বৃহত্তম আয়তক্ষেত্র এলাকা গঠন করা যেতে পারে তা গণনা করুন।\n   *\n   * @param heights একটি পূর্ণসংখ্যার অ্যারে যা বারগুলির উচ্চতা উপস্থাপন করে।\n   * @return আয়তক্ষেত্রের সর্বাধিক এলাকা যা গঠন করা যেতে পারে।\n   *\n   * উদাহরণ:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * আউটপুট: 10\n   *\n   * উদাহরণ:\n   * largestRectangleArea(new int[]{2,4})\n   * আউটপুট: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "bg": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Дадени са n неотрицателни цели числа, представляващи височините на колони в диаграма.\n   * Всяка колона има ширина от 1 единица. Изчислете най-голямата площ на правоъгълник, която може да бъде образувана в диаграмата.\n   *\n   * @param heights Масив от цели числа, представляващи височините на колоните.\n   * @return Максималната площ на правоъгълника, която може да бъде образувана.\n   *\n   * Пример:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Пример:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "zh": "import java.util.*;\npublic class Solution {\n\n  /**\n   * 给定 n 个非负整数，表示柱状图中每个柱子的高度。\n   * 每个柱子的宽度为 1 单位。计算在柱状图中可以形成的最大矩形面积。\n   *\n   * @param heights 一个整数数组，表示柱子的高度。\n   * @return 可以形成的矩形的最大面积。\n   *\n   * 示例:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * 输出: 10\n   *\n   * 示例:\n   * largestRectangleArea(new int[]{2,4})\n   * 输出: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "fr": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Étant donné n entiers non négatifs représentant les hauteurs des barres dans un histogramme.\n   * Chaque barre a une largeur de 1 unité. Calculer la plus grande aire de rectangle qui peut être formée dans l'histogramme.\n   *\n   * @param heights Un tableau d'entiers représentant les hauteurs des barres.\n   * @return L'aire maximale du rectangle qui peut être formée.\n   *\n   * Exemple:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Exemple:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "de": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Gegeben sind n nicht-negative ganze Zahlen, die die Höhen von Balken in einem Balkendiagramm darstellen.\n   * Jeder Balken hat eine Breite von 1 Einheit. Berechne die größte Rechteckfläche, die im Balkendiagramm gebildet werden kann.\n   *\n   * @param heights Ein Array von ganzen Zahlen, das die Höhen der Balken darstellt.\n   * @return Die maximale Fläche des Rechtecks, das gebildet werden kann.\n   *\n   * Beispiel:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Ausgabe: 10\n   *\n   * Beispiel:\n   * largestRectangleArea(new int[]{2,4})\n   * Ausgabe: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "ha": "import java.util.*;\npublic class Solution {\n\n  /**\n   * An ba n lambobi marasa kyau da ke wakiltar tsayin sanduna a cikin ginshiƙi.\n   * Kowane sanda yana da faɗin naúrar 1. Lissafa mafi girman yankin murabba'i da za a iya samarwa a cikin ginshiƙi.\n   *\n   * @param heights Wani tsari na lambobi da ke wakiltar tsayin sanduna.\n   * @return Mafi girman yankin murabba'i da za a iya samarwa.\n   *\n   * Misali:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Misali:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "hi": "import java.util.*;\npublic class Solution {\n\n  /**\n   * n गैर-ऋणात्मक पूर्णांकों को दिया गया है जो बार चार्ट में बार की ऊंचाई का प्रतिनिधित्व करते हैं।\n   * प्रत्येक बार की चौड़ाई 1 यूनिट होती है। बार चार्ट में बनने वाले सबसे बड़े आयत क्षेत्र की गणना करें।\n   *\n   * @param heights बार की ऊंचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n   * @return आयत का अधिकतम क्षेत्रफल जो बनाया जा सकता है।\n   *\n   * उदाहरण:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * उदाहरण:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "hu": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Adott n nemnegatív egész szám, amelyek egy oszlopdiagram oszlopainak magasságát képviselik.\n   * Minden oszlop szélessége 1 egység. Számítsa ki a legnagyobb téglalap területét, amely az oszlopdiagramon kialakítható.\n   *\n   * @param heights Egész számok tömbje, amely az oszlopok magasságát képviseli.\n   * @return A téglalap maximális területe, amely kialakítható.\n   *\n   * Példa:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Kimenet: 10\n   *\n   * Példa:\n   * largestRectangleArea(new int[]{2,4})\n   * Kimenet: 4\n   */\n  public static int largestRectangleArea(int[] heights) "
    },
    "prompt_bertscore": {
      "sq": "0.984269466973942",
      "hy": "0.9538394912297782",
      "bn": "0.9970952293077457",
      "bg": "0.9554992466937057",
      "zh": "0.9723713085195712",
      "fr": "0.9836193497368149",
      "de": "0.9970952293077457",
      "ha": "0.9547424649419628",
      "hi": "0.9868701345528318",
      "hu": "0.961250788006952"
    },
    "canonical_solution": "  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }",
    "instruction": {
      "en": "Write a Java function `public static int largestRectangleArea(int[] heights)` to solve the following problem:\nGiven n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "sq": "Shkruani një funksion Java `public static int largestRectangleArea(int[] heights)` për të zgjidhur problemin në vijim:\nDuke pasur n numra të plotë jo-negativë që përfaqësojnë lartësitë e shufrave në një diagram shufrash.\n    Çdo shufër ka një gjerësi prej 1 njësie. Llogaritni sipërfaqen më të madhe të drejtkëndëshit që mund të formohet në diagramin e shufrave.\n   \n    @param heights Një varg numrash të plotë që përfaqësojnë lartësitë e shufrave.\n    @return Sipërfaqja maksimale e drejtkëndëshit që mund të formohet.\n   \n    Shembull:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Shembull:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hy": "Գրեք Java ֆունկցիա `public static int largestRectangleArea(int[] heights)` հետևյալ խնդիրը լուծելու համար:\nՏրված են n ոչ բացասական ամբողջ թվեր, որոնք ներկայացնում են սյուների բարձրությունները սյունակազմ գծապատկերում:\n    Յուրաքանչյուր սյուն ունի 1 միավոր լայնություն։ Հաշվեք ամենամեծ ուղղանկյուն տարածքը, որը կարող է ձևավորվել սյունակազմ գծապատկերում։\n   \n    @param heights Մասիվ, որը ներկայացնում է սյուների բարձրությունները։\n    @return Ուղղանկյան առավելագույն տարածքը, որը կարող է ձևավորվել։\n   \n    Օրինակ:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Արդյունք: 10\n   \n    Օրինակ:\n    largestRectangleArea(new int[]{2,4})\n    Արդյունք: 4",
      "bn": "একটি জাভা ফাংশন `public static int largestRectangleArea(int[] heights)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn টি অ-ঋণাত্মক পূর্ণসংখ্যা দেওয়া আছে যা একটি বার চার্টের বারের উচ্চতা উপস্থাপন করে।\n    প্রতিটি বারের প্রস্থ 1 ইউনিট। বার চার্টে গঠিত হতে পারে এমন বৃহত্তম আয়তক্ষেত্রের ক্ষেত্রফল গণনা করুন।\n   \n    @param heights একটি পূর্ণসংখ্যার অ্যারে যা বারের উচ্চতা উপস্থাপন করে।\n    @return আয়তক্ষেত্রের সর্বাধিক ক্ষেত্রফল যা গঠিত হতে পারে।\n   \n    উদাহরণ:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    আউটপুট: 10\n   \n    উদাহরণ:\n    largestRectangleArea(new int[]{2,4})\n    আউটপুট: 4",
      "bg": "Напишете Java функция `public static int largestRectangleArea(int[] heights)`, за да решите следния проблем:  \nДадени са n неотрицателни цели числа, представляващи височините на пръчките в диаграма с пръчки.  \nВсяка пръчка има ширина от 1 единица. Изчислете най-голямата площ на правоъгълник, която може да се образува в диаграмата с пръчки.\n\n@param heights Масив от цели числа, представляващ височините на пръчките.  \n@return Максималната площ на правоъгълника, която може да се образува.\n\nПример:  \nlargestRectangleArea(new int[]{2,1,5,6,2,3})  \nИзход: 10\n\nПример:  \nlargestRectangleArea(new int[]{2,4})  \nИзход: 4",
      "zh": "编写一个 Java 函数 `public static int largestRectangleArea(int[] heights)` 来解决以下问题：\n给定 n 个非负整数，表示柱状图中柱子的高度。\n每个柱子的宽度为 1 个单位。计算在柱状图中可以形成的最大矩形面积。\n\n@param heights 一个整数数组，表示柱子的高度。\n@return 可以形成的矩形的最大面积。\n\n示例：\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\n输出: 10\n\n示例：\nlargestRectangleArea(new int[]{2,4})\n输出: 4",
      "fr": "Écrire une fonction Java `public static int largestRectangleArea(int[] heights)` pour résoudre le problème suivant :  \nÉtant donné n entiers non négatifs représentant les hauteurs des barres dans un histogramme.  \nChaque barre a une largeur de 1 unité. Calculer la plus grande aire de rectangle qui peut être formée dans l'histogramme.\n\n@param heights Un tableau d'entiers représentant les hauteurs des barres.  \n@return La surface maximale du rectangle qui peut être formée.\n\nExemple :  \nlargestRectangleArea(new int[]{2,1,5,6,2,3})  \nSortie : 10\n\nExemple :  \nlargestRectangleArea(new int[]{2,4})  \nSortie : 4",
      "de": "Schreiben Sie eine Java-Funktion `public static int largestRectangleArea(int[] heights)`, um das folgende Problem zu lösen:\nGegeben sind n nicht-negative ganze Zahlen, die die Höhen der Balken in einem Balkendiagramm darstellen.\n    Jeder Balken hat eine Breite von 1 Einheit. Berechnen Sie die größte Rechteckfläche, die im Balkendiagramm gebildet werden kann.\n   \n    @param heights Ein Array von ganzen Zahlen, das die Höhen der Balken darstellt.\n    @return Die maximale Fläche des Rechtecks, das gebildet werden kann.\n   \n    Beispiel:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Beispiel:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "ha": "Rubuta aikin Java `public static int largestRectangleArea(int[] heights)` don warware matsalar mai zuwa:\nAn ba da lambobi n marasa kyau waɗanda ke wakiltar tsayin sanduna a cikin ginshiƙi na sanduna.\n    Kowace sanda tana da faɗin naúrar 1. Lissafa mafi girman yankin murabba'i wanda za a iya samarwa a cikin ginshiƙi na sanduna.\n   \n    @param heights Wani tsari na lambobi waɗanda ke wakiltar tsayin sanduna.\n    @return Mafi girman yankin murabba'i wanda za a iya samarwa.\n   \n    Misali:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Misali:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hi": "एक जावा फ़ंक्शन `public static int largestRectangleArea(int[] heights)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n गैर-ऋणात्मक पूर्णांक जो बार चार्ट में बार की ऊँचाई का प्रतिनिधित्व करते हैं।\n    प्रत्येक बार की चौड़ाई 1 इकाई है। बार चार्ट में बनने वाले सबसे बड़े आयत क्षेत्रफल की गणना करें।\n\n    @param heights पूर्णांकों की एक सरणी जो बार की ऊँचाई का प्रतिनिधित्व करती है।\n    @return आयत का अधिकतम क्षेत्रफल जो बनाया जा सकता है।\n\n    उदाहरण:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n\n    उदाहरण:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hu": "Írj egy Java függvényt `public static int largestRectangleArea(int[] heights)` a következő probléma megoldására:\nAdott n nem-negatív egész szám, amelyek egy oszlopdiagram oszlopainak magasságát képviselik.\n    Minden oszlop szélessége 1 egység. Számítsd ki a legnagyobb téglalap területét, amely az oszlopdiagramon kialakítható.\n   \n    @param heights Egy egész számokat tartalmazó tömb, amely az oszlopok magasságát képviseli.\n    @return A téglalap maximális területe, amely kialakítható.\n   \n    Példa:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Kimenet: 10\n   \n    Példa:\n    largestRectangleArea(new int[]{2,4})\n    Kimenet: 4"
    },
    "instruction_bertscore": {
      "sq": "0.9928258678977819",
      "hy": "0.948856649491137",
      "bn": "0.9685254270819736",
      "bg": "0.9835299660653491",
      "zh": "0.9739822009097642",
      "fr": "0.9782128293954262",
      "de": "0.993566759219042",
      "ha": "0.9841318161198849",
      "hi": "0.9874850942125158",
      "hu": "0.961205500280076"
    },
    "level": "middle",
    "test": "  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "largestRectangleArea",
    "signature": "public static int largestRectangleArea(int[] heights)",
    "docstring": {
      "en": "Given n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "sq": "Duke pasur parasysh n numra të plotë jo-negativë që përfaqësojnë lartësitë e shiritave në një diagramë shiritash. \n    Secili shirit ka një gjerësi prej 1 njësie. Llogaritni sipërfaqen më të madhe të drejtkëndëshit që mund të formohet në diagramën e shiritave.\n   \n    @param heights Një varg numrash të plotë që përfaqësojnë lartësitë e shiritave.\n    @return Sipërfaqja maksimale e drejtkëndëshit që mund të formohet.\n   \n    Shembull:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Shembull:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hy": "Տրված են n ոչ բացասական ամբողջ թվեր, որոնք ներկայացնում են սյունակների բարձրությունները սյունակային գծապատկերում։  \n    Յուրաքանչյուր սյունակ ունի 1 միավոր լայնություն։ Հաշվեք ամենամեծ ուղղանկյուն տարածքը, որը կարող է ձևավորվել սյունակային գծապատկերում։\n   \n    @param heights Թվերի զանգված, որը ներկայացնում է սյունակների բարձրությունները։\n    @return Առավելագույն ուղղանկյուն տարածքը, որը կարող է ձևավորվել։\n   \n    Օրինակ:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Արդյունք: 10\n   \n    Օրինակ:\n    largestRectangleArea(new int[]{2,4})\n    Արդյունք: 4",
      "bn": "n টি অ-ঋণাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে যা একটি বার চার্টের বারগুলির উচ্চতা উপস্থাপন করে। \n    প্রতিটি বারের প্রস্থ 1 ইউনিট। বার চার্টে গঠিত হতে পারে এমন বৃহত্তম আয়তক্ষেত্রের ক্ষেত্রফল গণনা করুন।\n   \n    @param heights বারগুলির উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n    @return আয়তক্ষেত্রের সর্বাধিক ক্ষেত্রফল যা গঠিত হতে পারে।\n   \n    উদাহরণ:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    উদাহরণ:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "bg": "Дадени са n неотрицателни цели числа, представляващи височините на колоните в диаграма с колони. \n    Всяка колона има ширина от 1 единица. Изчислете най-голямата площ на правоъгълник, която може да бъде образувана в диаграмата с колони.\n   \n    @param heights Масив от цели числа, представляващи височините на колоните.\n    @return Максималната площ на правоъгълника, която може да бъде образувана.\n   \n    Пример:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Изход: 10\n   \n    Пример:\n    largestRectangleArea(new int[]{2,4})\n    Изход: 4",
      "zh": "给定 n 个非负整数，表示柱状图中柱子的高度。  \n每个柱子的宽度为 1 个单位。计算在柱状图中可以形成的最大矩形面积。\n\n@param heights 一个整数数组，表示柱子的高度。\n@return 可以形成的矩形的最大面积。\n\n示例：\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\n输出: 10\n\n示例：\nlargestRectangleArea(new int[]{2,4})\n输出: 4",
      "fr": "Étant donné n entiers non négatifs représentant les hauteurs des barres dans un histogramme.\n    Chaque barre a une largeur de 1 unité. Calculez la plus grande aire de rectangle qui peut être formée dans l'histogramme.\n   \n    @param heights Un tableau d'entiers représentant les hauteurs des barres.\n    @return La surface maximale du rectangle qui peut être formée.\n   \n    Exemple:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Sortie: 10\n   \n    Exemple:\n    largestRectangleArea(new int[]{2,4})\n    Sortie: 4",
      "de": "Gegeben sind n nicht-negative ganze Zahlen, die die Höhen der Balken in einem Balkendiagramm darstellen. Jeder Balken hat eine Breite von 1 Einheit. Berechne die größte Rechteckfläche, die im Balkendiagramm gebildet werden kann.\n\n@param heights Ein Array von ganzen Zahlen, das die Höhen der Balken darstellt.\n@return Die maximale Fläche des Rechtecks, das gebildet werden kann.\n\nBeispiel:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\nAusgabe: 10\n\nBeispiel:\nlargestRectangleArea(new int[]{2,4})\nAusgabe: 4",
      "ha": "An ba n lambobi marasa kyau da ke wakiltar tsayin sanduna a cikin ginshiƙi.\n    Kowanne sandar yana da faɗin naúrar 1. Lissafa mafi girman yankin rectangle da za a iya samarwa a cikin ginshiƙi.\n   \n    @param heights Wani tsararren lambobi da ke wakiltar tsayin sanduna.\n    @return Mafi girman yankin rectangle da za a iya samarwa.\n   \n    Misali:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Misali:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hi": "n गैर-ऋणात्मक पूर्णांकों को दिया गया है जो बार चार्ट में बार की ऊँचाई का प्रतिनिधित्व करते हैं। \n    प्रत्येक बार की चौड़ाई 1 इकाई है। बार चार्ट में बनने वाले सबसे बड़े आयत क्षेत्रफल की गणना करें।\n   \n    @param heights बार की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक श्रृंखला।\n    @return आयत का अधिकतम क्षेत्रफल जो बनाया जा सकता है।\n   \n    उदाहरण:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    उदाहरण:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hu": "Adott n nem negatív egész szám, amelyek egy oszlopdiagram oszlopainak magasságát képviselik. \n    Minden oszlop szélessége 1 egység. Számítsa ki a legnagyobb téglalap területét, amely az oszlopdiagramon kialakítható.\n   \n    @param heights Egész számok tömbje, amely az oszlopok magasságát képviseli.\n    @return A téglalap maximális területe, amely kialakítható.\n   \n    Példa:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Kimenet: 10\n   \n    Példa:\n    largestRectangleArea(new int[]{2,4})\n    Kimenet: 4"
    },
    "docstring_bertscore": {
      "sq": "0.9912034549454889",
      "hy": "0.9260395803608973",
      "bn": "0.9584689695205584",
      "bg": "0.9774947805679851",
      "zh": "0.9647649567082212",
      "fr": "0.9778761508995721",
      "de": "0.9897621929006998",
      "ha": "0.9689179207148986",
      "hi": "0.9709364026469751",
      "hu": "0.9478738263657763"
    }
  },
  {
    "task_id": "Java/44",
    "prompt": {
      "en": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "sq": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Kthen të gjitha elementet në matricë në rend diagonal.\n   *\n   * @param mat Matrica hyrëse.\n   * @return Një varg që përmban të gjitha elementet në rend diagonal.\n   *\n   * Shembull:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "hy": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Վերադարձնել մատրիցի բոլոր տարրերը անկյունագծային հերթականությամբ:\n   *\n   * @param mat Մուտքային մատրից:\n   * @return Զանգված, որը պարունակում է բոլոր տարրերը անկյունագծային հերթականությամբ:\n   *\n   * Օրինակ:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Արդյունք: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "bn": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * ম্যাট্রিক্সের সব উপাদান তির্যক ক্রমে ফেরত দিন।\n   *\n   * @param mat ইনপুট ম্যাট্রিক্স।\n   * @return একটি অ্যারে যা তির্যক ক্রমে সব উপাদান ধারণ করে।\n   *\n   * উদাহরণ:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * আউটপুট: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "bg": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Връща всички елементи в матрицата в диагонален ред.\n   *\n   * @param mat Входната матрица.\n   * @return Масив, съдържащ всички елементи в диагонален ред.\n   *\n   * Пример:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "zh": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * 返回矩阵中所有元素的对角线顺序。\n   *\n   * @param mat 输入矩阵。\n   * @return 包含所有元素的对角线顺序的数组。\n   *\n   * 示例:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * 输出: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "fr": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Retourne tous les éléments de la matrice dans l'ordre diagonal.\n   *\n   * @param mat La matrice d'entrée.\n   * @return Un tableau contenant tous les éléments dans l'ordre diagonal.\n   *\n   * Exemple:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "de": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Gibt alle Elemente in der Matrix in diagonaler Reihenfolge zurück.\n   *\n   * @param mat Die Eingabematrix.\n   * @return Ein Array, das alle Elemente in diagonaler Reihenfolge enthält.\n   *\n   * Beispiel:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Ausgabe: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "ha": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Mayar da dukkan abubuwa a cikin matrix a cikin tsari na diagonal.\n   *\n   * @param mat Matrix na shigarwa.\n   * @return Jeri mai dauke da dukkan abubuwa a cikin tsari na diagonal.\n   *\n   * Misali:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "hi": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * मैट्रिक्स में सभी तत्वों को विकर्ण क्रम में लौटाएं।\n   *\n   * @param mat इनपुट मैट्रिक्स।\n   * @return एक सरणी जो विकर्ण क्रम में सभी तत्वों को शामिल करती है।\n   *\n   * उदाहरण:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * आउटपुट: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "hu": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Adja vissza az összes elemet a mátrixban átlós sorrendben.\n   *\n   * @param mat A bemeneti mátrix.\n   * @return Egy tömb, amely az összes elemet átlós sorrendben tartalmazza.\n   *\n   * Példa:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Kimenet: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) "
    },
    "prompt_bertscore": {
      "sq": "0.9922444767724928",
      "hy": "0.9759216279501888",
      "bn": "0.9899361931144863",
      "bg": "0.9810895932039545",
      "zh": "0.9793827623397217",
      "fr": "0.9956541658933377",
      "de": "0.9986604367103007",
      "ha": "0.9771110266718257",
      "hi": "0.9886137120375561",
      "hu": "0.9986604367103007"
    },
    "canonical_solution": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }",
    "instruction": {
      "en": "Write a Java function `public static int[] diagonalOrder(int[][] mat)` to solve the following problem:\nReturn all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "sq": "Shkruani një funksion Java `public static int[] diagonalOrder(int[][] mat)` për të zgjidhur problemin në vijim: Ktheni të gjitha elementet në matricë në rend diagonale.\n\n@param mat Matrica hyrëse.\n@return Një varg që përmban të gjitha elementet në rend diagonale.\n\nShembull:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "hy": "Գրեք Java ֆունկցիա `public static int[] diagonalOrder(int[][] mat)` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնել մատրիցի բոլոր տարրերը անկյունագծային կարգով:\n\n@param mat Մուտքային մատրիցը։\n@return Զանգված, որը պարունակում է բոլոր տարրերը անկյունագծային կարգով։\n\nՕրինակ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nԵլք: [1,2,4,7,5,3,6,8,9]",
      "bn": "একটি জাভা ফাংশন `public static int[] diagonalOrder(int[][] mat)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nম্যাট্রিক্সের সমস্ত উপাদান তির্যক ক্রমে ফেরত দিন।\n\n@param mat ইনপুট ম্যাট্রিক্স।\n@return একটি অ্যারে যা তির্যক ক্রমে সমস্ত উপাদান ধারণ করে।\n\nউদাহরণ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nআউটপুট: [1,2,4,7,5,3,6,8,9]",
      "bg": "Напишете Java функция `public static int[] diagonalOrder(int[][] mat)`, за да решите следния проблем:  \nВърнете всички елементи в матрицата в диагонален ред.\n\n@param mat Входната матрица.\n@return Масив, съдържащ всички елементи в диагонален ред.\n\nПример:  \ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})  \nИзход: [1,2,4,7,5,3,6,8,9]",
      "zh": "编写一个 Java 函数 `public static int[] diagonalOrder(int[][] mat)` 来解决以下问题：  \n返回矩阵中所有元素的对角线顺序。\n\n@param mat 输入矩阵。\n@return 一个包含所有元素按对角线顺序排列的数组。\n\n示例：  \ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})  \n输出: [1,2,4,7,5,3,6,8,9]",
      "fr": "Écrire une fonction Java `public static int[] diagonalOrder(int[][] mat)` pour résoudre le problème suivant :  \nRetourner tous les éléments de la matrice en ordre diagonal.\n\n@param mat La matrice d'entrée.  \n@return Un tableau contenant tous les éléments en ordre diagonal.\n\nExemple :  \ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})  \nSortie : [1,2,4,7,5,3,6,8,9]",
      "de": "Schreiben Sie eine Java-Funktion `public static int[] diagonalOrder(int[][] mat)`, um das folgende Problem zu lösen:\nGeben Sie alle Elemente in der Matrix in diagonaler Reihenfolge zurück.\n\n@param mat Die Eingabematrix.\n@return Ein Array, das alle Elemente in diagonaler Reihenfolge enthält.\n\nBeispiel:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nAusgabe: [1,2,4,7,5,3,6,8,9]",
      "ha": "Rubuta aikin Java `public static int[] diagonalOrder(int[][] mat)` don warware matsalar mai zuwa: \nMayar da dukkan abubuwa a cikin matrix a tsari na diagonal.\n\n@param mat Matrix ɗin shigarwa.\n@return Wani tsari mai ɗauke da dukkan abubuwa a tsari na diagonal.\n\nMisali:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nFitarwa: [1,2,4,7,5,3,6,8,9]",
      "hi": "एक जावा फ़ंक्शन `public static int[] diagonalOrder(int[][] mat)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nमैट्रिक्स के सभी तत्वों को विकर्ण क्रम में लौटाएं।\n\n@param mat इनपुट मैट्रिक्स।\n@return एक array जो सभी तत्वों को विकर्ण क्रम में समाहित करता है।\n\nउदाहरण:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nआउटपुट: [1,2,4,7,5,3,6,8,9]",
      "hu": "Írj egy Java függvényt `public static int[] diagonalOrder(int[][] mat)` a következő probléma megoldására:\nAdja vissza az összes elemet a mátrixban átlós sorrendben.\n\n@param mat A bemeneti mátrix.\n@return Egy tömb, amely az összes elemet átlós sorrendben tartalmazza.\n\nPélda:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nKimenet: [1,2,4,7,5,3,6,8,9]"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9983865254148536",
      "bn": "0.9904262142644994",
      "bg": "0.9985164296840504",
      "zh": "0.9705033884163191",
      "fr": "0.9983865254148536",
      "de": "1",
      "ha": "0.9865608670495605",
      "hi": "0.9904262142644994",
      "hu": "1"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "diagonalOrder",
    "signature": "public static int[] diagonalOrder(int[][] mat)",
    "docstring": {
      "en": "Return all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "sq": "Kthe të gjitha elementet në matricë në rend diagonal.\n\n@param mat Matrica hyrëse.\n@return Një varg që përmban të gjitha elementet në rend diagonal.\n\nShembull:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "hy": "Վերադարձնել մատրիցայի բոլոր տարրերը անկյունագծային կարգով:\n\n@param mat Մուտքային մատրիցա:\n@return Զանգված, որը պարունակում է բոլոր տարրերը անկյունագծային կարգով:\n\nՕրինակ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nԵլք: [1,2,4,7,5,3,6,8,9]",
      "bn": "ডায়াগোনাল ক্রমে ম্যাট্রিক্সের সমস্ত উপাদান ফেরত দিন।\n\n@param mat ইনপুট ম্যাট্রিক্স।\n@return একটি অ্যারে যা ডায়াগোনাল ক্রমে সমস্ত উপাদান ধারণ করে।\n\nউদাহরণ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nআউটপুট: [1,2,4,7,5,3,6,8,9]",
      "bg": "Върнете всички елементи в матрицата в диагонален ред.\n\n@param mat Входната матрица.\n@return Масив, съдържащ всички елементи в диагонален ред.\n\nПример:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nИзход: [1,2,4,7,5,3,6,8,9]",
      "zh": "以对角线顺序返回矩阵中的所有元素。\n\n@param mat 输入矩阵。\n@return 一个包含所有元素按对角线顺序排列的数组。\n\n示例：\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n输出: [1,2,4,7,5,3,6,8,9]",
      "fr": "Retourner tous les éléments de la matrice dans l'ordre diagonal.\n\n@param mat La matrice d'entrée.\n@return Un tableau contenant tous les éléments dans l'ordre diagonal.\n\nExemple :\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nSortie : [1,2,4,7,5,3,6,8,9]",
      "de": "Gibt alle Elemente in der Matrix in diagonaler Reihenfolge zurück.\n\n@param mat Die Eingabematrix.\n@return Ein Array, das alle Elemente in diagonaler Reihenfolge enthält.\n\nBeispiel:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nAusgabe: [1,2,4,7,5,3,6,8,9]",
      "ha": "Mayar da dukkan abubuwa a cikin matrix a cikin tsari na diagonal.\n\n@param mat Matrix ɗin shigarwa.\n@return Wani tsari mai ɗauke da dukkan abubuwa a cikin tsari na diagonal.\n\nMisali:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nFitarwa: [1,2,4,7,5,3,6,8,9]",
      "hi": "मैट्रिक्स में सभी तत्वों को विकर्ण क्रम में लौटाएं।\n\n@param mat इनपुट मैट्रिक्स।\n@return एक सरणी जो विकर्ण क्रम में सभी तत्वों को शामिल करती है।\n\nउदाहरण:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nआउटपुट: [1,2,4,7,5,3,6,8,9]",
      "hu": "Adja vissza az összes elemet a mátrixban átlós sorrendben.\n\n@param mat A bemeneti mátrix.\n@return Egy tömb, amely az összes elemet átlós sorrendben tartalmazza.\n\nPélda:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nKimenet: [1,2,4,7,5,3,6,8,9]"
    },
    "docstring_bertscore": {
      "sq": "0.9799953384348333",
      "hy": "0.9631308245634471",
      "bn": "0.9878881152556356",
      "bg": "0.9755052986715397",
      "zh": "0.9879214851596495",
      "fr": "0.997369736494336",
      "de": "0.9993796773200281",
      "ha": "0.9903604676083769",
      "hi": "0.9848466868612294",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/45",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Gjeni numrin më të vogël të plotë që mund të formohet duke riorganizuar shifrat e numrit të dhënë pozitiv n, i cili është më i madh se n.\n   *\n   * @param n Numri i plotë pozitiv i dhënë.\n   * @return Numri më i vogël i riorganizuar më i madh se n, ose -1 nëse nuk është e mundur.\n   *\n   * Shembull:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Գտնել ամենափոքր ամբողջ թիվը, որը կարող է կազմվել տրված դրական ամբողջ n թվի թվանշանները վերադասավորելով, որը մեծ է n-ից:\n   *\n   * @param n Մուտքային դրական ամբողջ թիվը։\n   * @return Ամենափոքր վերադասավորված թիվը, որը մեծ է n-ից, կամ -1, եթե դա հնարավոր չէ։\n   *\n   * Օրինակ:\n   * findSmallestInteger(12)\n   * Արդյունք: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * প্রদত্ত ধনাত্মক পূর্ণসংখ্যা n এর অঙ্কগুলো পুনর্বিন্যাস করে যে ক্ষুদ্রতম পূর্ণসংখ্যা গঠন করা যায়, যা n এর চেয়ে বড়।\n   *\n   * @param n ইনপুট ধনাত্মক পূর্ণসংখ্যা।\n   * @return n এর চেয়ে বড় ক্ষুদ্রতম পুনর্বিন্যস্ত পূর্ণসংখ্যা, অথবা সম্ভব না হলে -1।\n   *\n   * উদাহরণ:\n   * findSmallestInteger(12)\n   * আউটপুট: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Намерете най-малкото цяло число, което може да се образува чрез пренареждане на цифрите на даденото положително цяло число n, което е по-голямо от n.\n   *\n   * @param n Входното положително цяло число.\n   * @return Най-малкото пренаредено цяло число, по-голямо от n, или -1, ако не е възможно.\n   *\n   * Пример:\n   * findSmallestInteger(12)\n   * Изход: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 查找通过重新排列给定正整数 n 的数字可以形成的比 n 大的最小整数。\n   *\n   * @param n 输入的正整数。\n   * @return 比 n 大的最小重新排列整数，如果不可能则返回 -1。\n   *\n   * 示例:\n   * findSmallestInteger(12)\n   * 输出: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Trouver le plus petit entier qui peut être formé en réarrangeant les chiffres de l'entier positif donné n, qui est supérieur à n.\n   *\n   * @param n L'entier positif d'entrée.\n   * @return Le plus petit entier réarrangé supérieur à n, ou -1 si ce n'est pas possible.\n   *\n   * Exemple:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Finde die kleinste ganze Zahl, die gebildet werden kann, indem die Ziffern der gegebenen positiven ganzen Zahl n umgeordnet werden, die größer als n ist.\n   *\n   * @param n Die Eingabe positive ganze Zahl.\n   * @return Die kleinste umgeordnete ganze Zahl, die größer als n ist, oder -1, falls nicht möglich.\n   *\n   * Beispiel:\n   * findSmallestInteger(12)\n   * Ausgabe: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * Nemo ƙaramin cikakken lamba wanda za a iya samarwa ta hanyar sake tsara lambobin lamba mai kyau da aka bayar n, wanda ya fi n girma.\n   *\n   * @param n Lamba mai kyau da aka shigar.\n   * @return Ƙaramin lamba da aka sake tsara wanda ya fi n girma, ko -1 idan ba zai yiwu ba.\n   *\n   * Misali:\n   * findSmallestInteger(12)\n   * Fitarwa: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए धनात्मक पूर्णांक n के अंकों को पुनर्व्यवस्थित करके बनने वाली सबसे छोटी पूर्णांक खोजें, जो n से बड़ा हो।\n   *\n   * @param n इनपुट धनात्मक पूर्णांक।\n   * @return सबसे छोटा पुनर्व्यवस्थित पूर्णांक जो n से बड़ा है, या -1 यदि संभव नहीं है।\n   *\n   * उदाहरण:\n   * findSmallestInteger(12)\n   * आउटपुट: 21\n   */\n  public static int findSmallestInteger(int n)",
      "hu": "public class Solution {\n\n  /**\n   * Keresse meg a legkisebb egész számot, amely a megadott pozitív egész szám n számjegyeinek átrendezésével képezhető, és amely nagyobb, mint n.\n   *\n   * @param n A bemeneti pozitív egész szám.\n   * @return A legkisebb átrendezett egész szám, amely nagyobb, mint n, vagy -1, ha nem lehetséges.\n   *\n   * Példa:\n   * findSmallestInteger(12)\n   * Kimenet: 21\n   */\n  public static int findSmallestInteger(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9808043599767884",
      "hy": "0.9732133027047781",
      "bn": "0.9371442104430338",
      "bg": "1",
      "zh": "0.9684745777044288",
      "fr": "0.9943155957555436",
      "de": "0.992410333140657",
      "ha": "0.9914384346862533",
      "hi": "0.9859802704457955",
      "hu": "0.9801520578054699"
    },
    "canonical_solution": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n",
    "instruction": {
      "en": "Write a Java function `public static int findSmallestInteger(int n)` to solve the following problem:\nFind the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21",
      "sq": "Shkruani një funksion Java `public static int findSmallestInteger(int n)` për të zgjidhur problemin e mëposhtëm: Gjeni numrin më të vogël të plotë që mund të formohet duke riorganizuar shifrat e numrit të dhënë pozitiv n, i cili është më i madh se n.\n\n@param n Numri i plotë pozitiv i dhënë si input.\n@return Numri më i vogël i riorganizuar më i madh se n, ose -1 nëse nuk është e mundur.\n\nShembull:\nfindSmallestInteger(12)\nOutput: 21",
      "hy": "Գրեք Java ֆունկցիա `public static int findSmallestInteger(int n)` հետևյալ խնդիրը լուծելու համար:\nԳտեք ամենափոքր ամբողջ թիվը, որը կարող է ձևավորվել տրված դրական ամբողջ թիվ n-ի թվանշանները վերադասավորելով, որը մեծ է n-ից:\n\n@param n Մուտքային դրական ամբողջ թիվը։\n@return Ամենափոքր վերադասավորված թիվը, որը մեծ է n-ից, կամ -1, եթե դա հնարավոր չէ։\n\nՕրինակ:\nfindSmallestInteger(12)\nԵլք: 21",
      "bn": "একটি জাভা ফাংশন `public static int findSmallestInteger(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত ধনাত্মক পূর্ণসংখ্যা n এর অঙ্কগুলো পুনর্বিন্যাস করে n এর চেয়ে বড় যে ক্ষুদ্রতম পূর্ণসংখ্যা গঠন করা যায় তা খুঁজুন।\n\n@param n ইনপুট ধনাত্মক পূর্ণসংখ্যা।\n@return n এর চেয়ে বড় ক্ষুদ্রতম পুনর্বিন্যস্ত পূর্ণসংখ্যা, অথবা যদি সম্ভব না হয় তবে -1।\n\nউদাহরণ:\nfindSmallestInteger(12)\nআউটপুট: 21",
      "bg": "Напишете Java функция `public static int findSmallestInteger(int n)`, за да решите следния проблем:  \nНамерете най-малкото цяло число, което може да се образува чрез пренареждане на цифрите на даденото положително цяло число n, което е по-голямо от n.\n\n@param n Входното положително цяло число.\n@return Най-малкото пренаредено цяло число, по-голямо от n, или -1, ако не е възможно.\n\nПример:\nfindSmallestInteger(12)\nИзход: 21",
      "zh": "编写一个 Java 函数 `public static int findSmallestInteger(int n)` 来解决以下问题：\n找到通过重新排列给定正整数 n 的数字而形成的最小整数，该整数大于 n。\n\n@param n 输入的正整数。\n@return 大于 n 的最小重新排列整数，如果不可能，则返回 -1。\n\n示例：\nfindSmallestInteger(12)\n输出: 21",
      "fr": "Écrire une fonction Java `public static int findSmallestInteger(int n)` pour résoudre le problème suivant :  \nTrouver le plus petit entier qui peut être formé en réarrangeant les chiffres de l'entier positif donné n, qui est supérieur à n.\n\n@param n L'entier positif d'entrée.\n@return Le plus petit entier réarrangé supérieur à n, ou -1 si ce n'est pas possible.\n\nExemple :  \nfindSmallestInteger(12)  \nSortie : 21",
      "de": "Schreiben Sie eine Java-Funktion `public static int findSmallestInteger(int n)`, um das folgende Problem zu lösen:\nFinden Sie die kleinste ganze Zahl, die durch Umordnen der Ziffern der gegebenen positiven ganzen Zahl n gebildet werden kann und größer als n ist.\n\n@param n Die Eingabe positive ganze Zahl.\n@return Die kleinste umgeordnete ganze Zahl, die größer als n ist, oder -1, wenn dies nicht möglich ist.\n\nBeispiel:\nfindSmallestInteger(12)\nAusgabe: 21",
      "ha": "Rubuta aikin Java `public static int findSmallestInteger(int n)` don warware matsalar mai zuwa:  \nNemo ƙaramin cikakken lamba wanda za a iya samarwa ta hanyar sake tsara lambobin lambar da aka bayar ta n, wanda ya fi n girma.\n\n@param n Lambar cikakken lamba mai kyau da aka shigar.  \n@return Ƙaramin lambar da aka sake tsara wanda ya fi n girma, ko -1 idan ba zai yiwu ba.\n\nMisali:  \nfindSmallestInteger(12)  \nFitarwa: 21",
      "hi": "Java फ़ंक्शन `public static int findSmallestInteger(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए धनात्मक पूर्णांक n के अंकों को पुनर्व्यवस्थित करके सबसे छोटा पूर्णांक खोजें, जो n से बड़ा हो।\n\n@param n इनपुट धनात्मक पूर्णांक।\n@return सबसे छोटा पुनर्व्यवस्थित पूर्णांक जो n से बड़ा है, या -1 यदि संभव नहीं है।\n\nउदाहरण:\nfindSmallestInteger(12)\nआउटपुट: 21",
      "hu": "Írj egy Java függvényt `public static int findSmallestInteger(int n)` a következő probléma megoldására:\nTaláld meg a legkisebb egész számot, amely a megadott pozitív egész szám n számjegyeinek átrendezésével képezhető, és nagyobb, mint n.\n\n@param n A bemeneti pozitív egész szám.\n@return A legkisebb átrendezett egész szám, amely nagyobb, mint n, vagy -1, ha nem lehetséges.\n\nPélda:\nfindSmallestInteger(12)\nKimenet: 21"
    },
    "instruction_bertscore": {
      "sq": "0.9832423492736106",
      "hy": "0.9761250254603685",
      "bn": "0.9913528249920271",
      "bg": "1",
      "zh": "1",
      "fr": "0.9938144513041925",
      "de": "0.9741091257232455",
      "ha": "0.973104651886352",
      "hi": "0.9469617156560641",
      "hu": "0.981331723638436"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "findSmallestInteger",
    "signature": "public static int findSmallestInteger(int n)",
    "docstring": {
      "en": "Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21",
      "sq": "Gjeni numrin më të vogël të plotë që mund të formohet duke riorganizuar shifrat e numrit të dhënë pozitiv n, i cili është më i madh se n.\n\n@param n Numri i plotë pozitiv i dhënë si hyrje.\n@return Numri më i vogël i riorganizuar që është më i madh se n, ose -1 nëse nuk është e mundur.\n\nShembull:\nfindSmallestInteger(12)\nDalja: 21",
      "hy": "Գտնել ամենափոքր ամբողջ թիվը, որը կարող է ձևավորվել տրված դրական ամբողջ թիվ n-ի թվանշանները վերադասավորելով, որը մեծ է n-ից:\n\n@param n Մուտքային դրական ամբողջ թիվը:\n@return Ամենափոքր վերադասավորված թիվը, որը մեծ է n-ից, կամ -1, եթե դա հնարավոր չէ:\n\nՕրինակ:\nfindSmallestInteger(12)\nOutput: 21",
      "bn": "প্রদত্ত ধনাত্মক পূর্ণসংখ্যা n এর অঙ্কগুলো পুনর্বিন্যাস করে যে ক্ষুদ্রতম পূর্ণসংখ্যা গঠন করা যায়, যা n এর চেয়ে বড়।\n\n@param n ইনপুট ধনাত্মক পূর্ণসংখ্যা।\n@return n এর চেয়ে বড় ক্ষুদ্রতম পুনর্বিন্যাসিত পূর্ণসংখ্যা, অথবা সম্ভব না হলে -1।\n\nউদাহরণ:\nfindSmallestInteger(12)\nOutput: 21",
      "bg": "Намерете най-малкото цяло число, което може да бъде образувано чрез пренареждане на цифрите на даденото положително цяло число n, което е по-голямо от n.\n\n@param n Входното положително цяло число.\n@return Най-малкото пренаредено цяло число, по-голямо от n, или -1, ако не е възможно.\n\nПример:\nfindSmallestInteger(12)\nИзход: 21",
      "zh": "找到通过重新排列给定正整数 n 的数字而形成的比 n 大的最小整数。\n\n@param n 输入的正整数。\n@return 比 n 大的最小重新排列整数，如果不可能则返回 -1。\n\n示例：\nfindSmallestInteger(12)\n输出: 21",
      "fr": "Trouver le plus petit entier qui peut être formé en réarrangeant les chiffres de l'entier positif donné n, qui est supérieur à n.\n\n@param n L'entier positif d'entrée.\n@return Le plus petit entier réarrangé supérieur à n, ou -1 si ce n'est pas possible.\n\nExemple :\nfindSmallestInteger(12)\nSortie : 21",
      "de": "Finde die kleinste ganze Zahl, die durch Umordnen der Ziffern der gegebenen positiven ganzen Zahl n gebildet werden kann und die größer als n ist.\n\n@param n Die Eingabe positive ganze Zahl.\n@return Die kleinste umgeordnete ganze Zahl, die größer als n ist, oder -1, falls nicht möglich.\n\nBeispiel:\nfindSmallestInteger(12)\nAusgabe: 21",
      "ha": "Nemo ƙaramin cikakken lamba wanda za a iya samarwa ta hanyar sake tsara lambobin lamba mai kyau da aka bayar n, wanda ya fi n girma.\n\n@param n Lambar shigar da lamba mai kyau.\n@return Mafi ƙarancin lambar da aka sake tsara fiye da n, ko -1 idan ba zai yiwu ba.\n\nMisali:\nfindSmallestInteger(12)\nOutput: 21",
      "hi": "दिए गए धनात्मक पूर्णांक n के अंकों को पुनर्व्यवस्थित करके वह सबसे छोटा पूर्णांक खोजें, जो n से बड़ा हो।\n\n@param n इनपुट धनात्मक पूर्णांक।\n@return सबसे छोटा पुनर्व्यवस्थित पूर्णांक जो n से बड़ा हो, या -1 यदि संभव नहीं है।\n\nउदाहरण:\nfindSmallestInteger(12)\nOutput: 21",
      "hu": "Keresse meg a legkisebb egész számot, amely a megadott pozitív egész szám n számjegyeinek átrendezésével képezhető, és amely nagyobb, mint n.\n\n@param n A bemeneti pozitív egész szám.\n@return A legkisebb átrendezett egész szám, amely nagyobb, mint n, vagy -1, ha nem lehetséges.\n\nPélda:\nfindSmallestInteger(12)\nKimenet: 21"
    },
    "docstring_bertscore": {
      "sq": "0.9634446605654823",
      "hy": "0.9679253647008673",
      "bn": "0.9873228131912103",
      "bg": "1",
      "zh": "0.9260932105637767",
      "fr": "0.9923282987932895",
      "de": "0.9753950588100653",
      "ha": "1",
      "hi": "0.9250080927921831",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/46",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "sq": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, kthe të gjithë numrat simetrikë qendrorë me gjatësi n.\n   *\n   * @param n Gjatësia e numrave simetrikë qendrorë.\n   * @return Një listë e numrave simetrikë qendrorë.\n   *\n   * Shembull:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "hy": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, վերադարձնել բոլոր կենտրոնական սիմետրիկ թվերը, որոնց երկարությունը n է։\n   *\n   * @param n Կենտրոնական սիմետրիկ թվերի երկարությունը։\n   * @return Կենտրոնական սիմետրիկ թվերի ցուցակ։\n   *\n   * Օրինակ:\n   * centerSymmetricNumbers(2)\n   * Արդյունք: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Արդյունք: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n)",
      "bn": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, n দৈর্ঘ্যের সমস্ত কেন্দ্র সমমিত সংখ্যা ফেরত দিন।\n   *\n   * @param n কেন্দ্র সমমিত সংখ্যার দৈর্ঘ্য।\n   * @return কেন্দ্র সমমিত সংখ্যার একটি তালিকা।\n   *\n   * উদাহরণ:\n   * centerSymmetricNumbers(2)\n   * আউটপুট: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * আউটপুট: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "bg": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Като се даде цяло число n, върнете всички централно симетрични числа с дължина n.\n   *\n   * @param n Дължината на централно симетричните числа.\n   * @return Списък с централно симетрични числа.\n   *\n   * Пример:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "zh": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * 给定一个整数 n，返回长度为 n 的所有中心对称数。\n   *\n   * @param n 中心对称数的长度。\n   * @return 中心对称数的列表。\n   *\n   * 示例:\n   * centerSymmetricNumbers(2)\n   * 输出: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * 输出: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "fr": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Étant donné un entier n, retourne tous les nombres symétriques centraux de longueur n.\n   *\n   * @param n La longueur des nombres symétriques centraux.\n   * @return Une liste de nombres symétriques centraux.\n   *\n   * Exemple :\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "de": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, gebe alle zentriersymmetrischen Zahlen der Länge n zurück.\n   *\n   * @param n Die Länge der zentriersymmetrischen Zahlen.\n   * @return Eine Liste von zentriersymmetrischen Zahlen.\n   *\n   * Beispiel:\n   * centerSymmetricNumbers(2)\n   * Ausgabe: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Ausgabe: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "ha": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * An ba wani lamba n, mayar da duk lambobin da suke daidai daga tsakiya na tsawon n.\n   *\n   * @param n Tsawon lambobin da suke daidai daga tsakiya.\n   * @return Jerin lambobin da suke daidai daga tsakiya.\n   *\n   * Misali:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "hi": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * दिए गए एक पूर्णांक n के लिए, n लंबाई की सभी केंद्र सममित संख्याएँ लौटाएँ।\n   *\n   * @param n केंद्र सममित संख्याओं की लंबाई।\n   * @return केंद्र सममित संख्याओं की एक सूची।\n   *\n   * उदाहरण:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "hu": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Adott egy egész szám n, adja vissza az összes középen szimmetrikus számot, amelyek hossza n.\n   *\n   * @param n A középen szimmetrikus számok hossza.\n   * @return A középen szimmetrikus számok listája.\n   *\n   * Példa:\n   * centerSymmetricNumbers(2)\n   * Kimenet: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Kimenet: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9740852900775212",
      "hy": "0.9775889313685956",
      "bn": "0.9904730910344236",
      "bg": "0.9972966405141152",
      "zh": "0.9954303094539113",
      "fr": "0.9740852900775212",
      "de": "0.9740852900775212",
      "ha": "0.9359436884200589",
      "hi": "0.9855454685417101",
      "hu": "0.9954303094539113"
    },
    "canonical_solution": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }",
    "instruction": {
      "en": "Write a Java function `public static List<String> centerSymmetricNumbers(int n)` to solve the following problem:\nGiven an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "sq": "Shkruani një funksion Java `public static List<String> centerSymmetricNumbers(int n)` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë n, kthe të gjithë numrat simetrikë qendrorë të gjatësisë n.\n\n@param n Gjatësia e numrave simetrikë qendrorë.\n@return Një listë e numrave simetrikë qendrorë.\n\nShembull:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "hy": "Գրեք Java ֆունկցիա `public static List<String> centerSymmetricNumbers(int n)` հետևյալ խնդիրը լուծելու համար:\nՏրված է n ամբողջ թիվը, վերադարձնել բոլոր կենտրոնական սիմետրիկ թվերը, որոնք ունեն n երկարություն։\n\n@param n Կենտրոնական սիմետրիկ թվերի երկարությունը։\n@return Կենտրոնական սիմետրիկ թվերի ցանկ։\n\nՕրինակ:\ncenterSymmetricNumbers(2)\nԵլք: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nԵլք: [\"0\",\"1\",\"8\"]",
      "bn": "একটি জাভা ফাংশন `public static List<String> centerSymmetricNumbers(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, n দৈর্ঘ্যের সমস্ত কেন্দ্র সমমিত সংখ্যা ফেরত দিন।\n\n@param n কেন্দ্র সমমিত সংখ্যার দৈর্ঘ্য।\n@return কেন্দ্র সমমিত সংখ্যার একটি তালিকা।\n\nউদাহরণ:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "bg": "Напишете Java функция `public static List<String> centerSymmetricNumbers(int n)`, за да решите следния проблем:\nДадено е цяло число n, върнете всички централно симетрични числа с дължина n.\n\n@param n Дължината на централно симетричните числа.\n@return Списък с централно симетрични числа.\n\nПример:\ncenterSymmetricNumbers(2)\nИзход: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nИзход: [\"0\",\"1\",\"8\"]",
      "zh": "编写一个 Java 函数 `public static List<String> centerSymmetricNumbers(int n)` 来解决以下问题：\n给定一个整数 n，返回所有长度为 n 的中心对称数。\n\n@param n 中心对称数的长度。\n@return 中心对称数的列表。\n\n示例：\ncenterSymmetricNumbers(2)\n输出: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\n输出: [\"0\",\"1\",\"8\"]",
      "fr": "Écrire une fonction Java `public static List<String> centerSymmetricNumbers(int n)` pour résoudre le problème suivant :  \nÉtant donné un entier n, retourner tous les nombres symétriques centraux de longueur n.\n\n@param n La longueur des nombres symétriques centraux.  \n@return Une liste de nombres symétriques centraux.\n\nExemple :  \ncenterSymmetricNumbers(2)  \nSortie : [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)  \nSortie : [\"0\",\"1\",\"8\"]",
      "de": "Schreiben Sie eine Java-Funktion `public static List<String> centerSymmetricNumbers(int n)`, um das folgende Problem zu lösen:\nGegeben ist eine ganze Zahl n, geben Sie alle zentralsymmetrischen Zahlen der Länge n zurück.\n\n@param n Die Länge der zentralsymmetrischen Zahlen.\n@return Eine Liste von zentralsymmetrischen Zahlen.\n\nBeispiel:\ncenterSymmetricNumbers(2)\nAusgabe: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nAusgabe: [\"0\",\"1\",\"8\"]",
      "ha": "Rubuta wani aikin Java `public static List<String> centerSymmetricNumbers(int n)` don warware matsalar mai zuwa:\nAn ba da wani lamba n, dawo da duk lambobin da ke da daidaiton tsakiya na tsawon n.\n\n@param n Tsawon lambobin da ke da daidaiton tsakiya.\n@return Jerin lambobin da ke da daidaiton tsakiya.\n\nMisali:\ncenterSymmetricNumbers(2)\nFitarwa: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nFitarwa: [\"0\",\"1\",\"8\"]",
      "hi": "Java फ़ंक्शन `public static List<String> centerSymmetricNumbers(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए पूर्णांक n के लिए, n लंबाई के सभी केंद्र सममित संख्याओं को लौटाएं।\n\n@param n केंद्र सममित संख्याओं की लंबाई।\n@return केंद्र सममित संख्याओं की एक सूची।\n\nउदाहरण:\ncenterSymmetricNumbers(2)\nआउटपुट: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nआउटपुट: [\"0\",\"1\",\"8\"]",
      "hu": "Írj egy Java függvényt `public static List<String> centerSymmetricNumbers(int n)` a következő probléma megoldására:\nAdott egy egész szám n, add vissza az összes középen szimmetrikus számot, amelynek hossza n.\n\n@param n A középen szimmetrikus számok hossza.\n@return A középen szimmetrikus számok listája.\n\nPélda:\ncenterSymmetricNumbers(2)\nKimenet: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nKimenet: [\"0\",\"1\",\"8\"]"
    },
    "instruction_bertscore": {
      "sq": "0.9888459109529859",
      "hy": "0.9883030541216175",
      "bn": "0.9888459109529859",
      "bg": "0.9945626919495509",
      "zh": "0.9805566678916379",
      "fr": "0.9968000645615279",
      "de": "0.9710480329211167",
      "ha": "0.9499528905640685",
      "hi": "0.9679621113213588",
      "hu": "0.9942246230410295"
    },
    "level": "middle",
    "test": "  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "centerSymmetricNumbers",
    "signature": "public static List<String> centerSymmetricNumbers(int n)",
    "docstring": {
      "en": "Given an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "sq": "Duke pasur një numër të plotë n, kthe të gjitha numrat simetrikë qendrorë me gjatësi n.\n\n@param n Gjatësia e numrave simetrikë qendrorë.\n@return Një listë e numrave simetrikë qendrorë.\n\nShembull:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "hy": "Տրված է ամբողջ թիվ `n`, վերադարձնել բոլոր կենտրոնական սիմետրիկ թվերը, որոնք ունեն `n` երկարություն։\n\n@param n Կենտրոնական սիմետրիկ թվերի երկարությունը։\n@return Կենտրոնական սիմետրիկ թվերի ցուցակ։\n\nՕրինակ:\ncenterSymmetricNumbers(2)\nԵլք: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nԵլք: [\"0\",\"1\",\"8\"]",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, n দৈর্ঘ্যের সমস্ত কেন্দ্র সমমিত সংখ্যা ফেরত দিন।\n\n@param n কেন্দ্র সমমিত সংখ্যার দৈর্ঘ্য।\n@return কেন্দ্র সমমিত সংখ্যার একটি তালিকা।\n\nউদাহরণ:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "bg": "Дадено е цяло число n, върнете всички централно симетрични числа с дължина n.\n\n@param n Дължината на централно симетричните числа.\n@return Списък с централно симетрични числа.\n\nПример:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "zh": "给定一个整数 n，返回所有长度为 n 的中心对称数。\n\n@param n 中心对称数的长度。\n@return 一个中心对称数的列表。\n\n示例：\ncenterSymmetricNumbers(2)\n输出: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\n输出: [\"0\",\"1\",\"8\"]",
      "fr": "Étant donné un entier n, renvoie tous les nombres symétriques centraux de longueur n.\n\n@param n La longueur des nombres symétriques centraux.\n@return Une liste de nombres symétriques centraux.\n\nExemple :\ncenterSymmetricNumbers(2)\nSortie : [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nSortie : [\"0\",\"1\",\"8\"]",
      "de": "Gegeben eine ganze Zahl n, gebe alle zentriersymmetrischen Zahlen der Länge n zurück.\n\n@param n Die Länge der zentrumsymmetrischen Zahlen.\n@return Eine Liste von zentrumsymmetrischen Zahlen.\n\nBeispiel:\ncenterSymmetricNumbers(2)\nAusgabe: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nAusgabe: [\"0\",\"1\",\"8\"]",
      "ha": "@param n Tsawon lambobin da suke da daidaiton tsakiya.  \n@return Jerin lambobin da suke da daidaiton tsakiya.\n\nMisali:  \ncenterSymmetricNumbers(2)  \nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)  \nOutput: [\"0\",\"1\",\"8\"]",
      "hi": "दिए गए पूर्णांक n के लिए, लंबाई n के सभी केंद्र सममित संख्याएँ लौटाएँ।\n\n@param n केंद्र सममित संख्याओं की लंबाई।\n@return केंद्र सममित संख्याओं की एक सूची।\n\nउदाहरण:\ncenterSymmetricNumbers(2)\nआउटपुट: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nआउटपुट: [\"0\",\"1\",\"8\"]",
      "hu": "Adott egy egész szám n, adja vissza az összes középen szimmetrikus számot, amelynek hossza n.\n\n@param n A középen szimmetrikus számok hossza.\n@return Egy lista a középen szimmetrikus számokról.\n\nPélda:\ncenterSymmetricNumbers(2)\nKimenet: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nKimenet: [\"0\",\"1\",\"8\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9775068970212282",
      "hy": "0.953588025167388",
      "bn": "0.9859951677243731",
      "bg": "0.9621156246859779",
      "zh": "0.9621156246859779",
      "fr": "0.9621156246859779",
      "de": "1",
      "ha": "0.882324410211596",
      "hi": "0.9859951677243731",
      "hu": "0.9621156246859779"
    }
  },
  {
    "task_id": "Java/47",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "sq": "public class Solution {\n\n  /**\n   * Përcaktoni nëse pikat e dhëna formojnë një bumerang në planin X-Y.\n   *\n   * @param points Një varg pikash ku points[i] = [xi, yi].\n   * @return True nëse pikat formojnë një bumerang, false përndryshe.\n   *\n   * Shembull:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "hy": "public class Solution {\n\n  /**\n   * Որոշել՝ արդյոք տրված կետերը X-Y հարթությունում բումերանգ են կազմում։\n   *\n   * @param points Կետերի զանգված, որտեղ points[i] = [xi, yi]։\n   * @return Ճիշտ է, եթե կետերը բումերանգ են կազմում, սխալ՝ հակառակ դեպքում։\n   *\n   * Օրինակ:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Արդյունք: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "bn": "public class Solution {\n\n  /**\n   * প্রদত্ত পয়েন্টগুলি X-Y প্লেনে একটি বুমেরাং তৈরি করে কিনা তা নির্ধারণ করুন।\n   *\n   * @param points পয়েন্টের একটি অ্যারে যেখানে points[i] = [xi, yi]।\n   * @return পয়েন্টগুলি একটি বুমেরাং তৈরি করলে True, অন্যথায় false।\n   *\n   * উদাহরণ:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * আউটপুট: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "bg": "public class Solution {\n\n  /**\n   * Определете дали дадените точки образуват бумеранг в X-Y равнината.\n   *\n   * @param points Масив от точки, където points[i] = [xi, yi].\n   * @return Връща true, ако точките образуват бумеранг, false в противен случай.\n   *\n   * Пример:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "zh": "public class Solution {\n\n  /**\n   * 确定给定的点是否在 X-Y 平面上形成回旋镖。\n   *\n   * @param points 一个点的数组，其中 points[i] = [xi, yi]。\n   * @return 如果这些点形成回旋镖则返回 true，否则返回 false。\n   *\n   * 示例:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * 输出: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "fr": "public class Solution {\n\n  /**\n   * Déterminer si les points donnés forment un boomerang sur le plan X-Y.\n   *\n   * @param points Un tableau de points où points[i] = [xi, yi].\n   * @return True si les points forment un boomerang, false sinon.\n   *\n   * Exemple:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "de": "public class Solution {\n\n  /**\n   * Bestimmen, ob die gegebenen Punkte auf der X-Y-Ebene einen Bumerang bilden.\n   *\n   * @param points Ein Array von Punkten, wobei points[i] = [xi, yi] ist.\n   * @return True, wenn die Punkte einen Bumerang bilden, andernfalls false.\n   *\n   * Beispiel:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Ausgabe: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "ha": "public class Solution {\n\n  /**\n   * Tantance idan maki da aka bayar suna samar da boomerang a kan filin X-Y.\n   *\n   * @param points Wani tsararren maki inda points[i] = [xi, yi].\n   * @return Gaskiya idan maki sun samar da boomerang, karya in ba haka ba.\n   *\n   * Misali:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "hi": "public class Solution {\n\n  /**\n   * निर्धारित करें कि दिए गए बिंदु X-Y तल पर एक बूमरैंग बनाते हैं या नहीं।\n   *\n   * @param points बिंदुओं की एक श्रृंखला जहाँ points[i] = [xi, yi]।\n   * @return True अगर बिंदु एक बूमरैंग बनाते हैं, अन्यथा false।\n   *\n   * उदाहरण:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "hu": "public class Solution {\n\n  /**\n   * Határozza meg, hogy a megadott pontok bumerángot alkotnak-e az X-Y síkon.\n   *\n   * @param points Egy pontokat tartalmazó tömb, ahol points[i] = [xi, yi].\n   * @return Igaz, ha a pontok bumerángot alkotnak, hamis egyébként.\n   *\n   * Példa:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Kimenet: true\n   */\n  public static boolean isBoomerang(int[][] points) "
    },
    "prompt_bertscore": {
      "sq": "0.9986512997127731",
      "hy": "0.9876036765499937",
      "bn": "0.9956704535845825",
      "bg": "0.9877168958671836",
      "zh": "0.9840908982613916",
      "fr": "1",
      "de": "0.9910646123091456",
      "ha": "1",
      "hi": "0.9969720784715042",
      "hu": "0.992496141465264"
    },
    "canonical_solution": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }",
    "instruction": {
      "en": "Write a Java function `public static boolean isBoomerang(int[][] points)` to solve the following problem:\nDetermine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "sq": "Shkruani një funksion Java `public static boolean isBoomerang(int[][] points)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse pikat e dhëna formojnë një bumerang në planin X-Y.\n\n@param points Një varg pikash ku points[i] = [xi, yi].\n@return True nëse pikat formojnë një bumerang, false përndryshe.\n\nShembull:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hy": "Գրեք Java ֆունկցիա `public static boolean isBoomerang(int[][] points)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք՝ արդյոք տրված կետերը ձևավորում են բումերանգ X-Y հարթության վրա։\n\n@param points Կետերի զանգված, որտեղ points[i] = [xi, yi]։\n@return Ճիշտ, եթե կետերը ձևավորում են բումերանգ, սխալ՝ հակառակ դեպքում։\n\nՕրինակ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nԱրդյունք: true",
      "bn": "একটি জাভা ফাংশন `public static boolean isBoomerang(int[][] points)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন যে প্রদত্ত বিন্দুগুলি X-Y সমতলে একটি বুমেরাং গঠন করে কিনা।\n\n@param points একটি বিন্দুর অ্যারে যেখানে points[i] = [xi, yi]।\n@return সত্য যদি বিন্দুগুলি একটি বুমেরাং গঠন করে, অন্যথায় মিথ্যা।\n\nউদাহরণ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nআউটপুট: true",
      "bg": "Напишете Java функция `public static boolean isBoomerang(int[][] points)` за решаване на следния проблем:  \nОпределете дали дадените точки образуват бумеранг в X-Y равнината.\n\n@param points Масив от точки, където points[i] = [xi, yi].  \n@return Връща true, ако точките образуват бумеранг, false в противен случай.\n\nПример:  \nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})  \nИзход: true",
      "zh": "编写一个 Java 函数 `public static boolean isBoomerang(int[][] points)` 来解决以下问题：  \n确定给定的点在 X-Y 平面上是否形成回旋镖。\n\n@param points 一个点的数组，其中 points[i] = [xi, yi]。  \n@return 如果点形成回旋镖，则返回 true，否则返回 false。\n\n示例：  \nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})  \n输出: true",
      "fr": "Écrire une fonction Java `public static boolean isBoomerang(int[][] points)` pour résoudre le problème suivant :  \nDéterminer si les points donnés forment un boomerang sur le plan X-Y.\n\n@param points Un tableau de points où points[i] = [xi, yi].  \n@return True si les points forment un boomerang, false sinon.\n\nExemple :  \nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})  \nSortie : true",
      "de": "Schreiben Sie eine Java-Funktion `public static boolean isBoomerang(int[][] points)`, um das folgende Problem zu lösen:\nBestimmen Sie, ob die gegebenen Punkte auf der X-Y-Ebene einen Bumerang bilden.\n\n@param points Ein Array von Punkten, wobei points[i] = [xi, yi].\n@return True, wenn die Punkte einen Bumerang bilden, andernfalls false.\n\nBeispiel:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nAusgabe: true",
      "ha": "Rubuta aikin Java `public static boolean isBoomerang(int[][] points)` don warware matsalar mai zuwa:\nKayyade idan maki da aka bayar suna samar da boomerang a kan X-Y fili.\n\n@param points Wani tsararren maki inda points[i] = [xi, yi].\n@return Gaskiya idan maki suna samar da boomerang, karya in ba haka ba.\n\nMisali:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nSakamako: true",
      "hi": "Java फ़ंक्शन `public static boolean isBoomerang(int[][] points)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि दिए गए बिंदु X-Y तल पर एक बूमरैंग बनाते हैं या नहीं।\n\n@param points बिंदुओं का एक सरणी जहाँ points[i] = [xi, yi] है।\n@return True यदि बिंदु एक बूमरैंग बनाते हैं, अन्यथा false।\n\nउदाहरण:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nआउटपुट: true",
      "hu": "Írj egy Java függvényt `public static boolean isBoomerang(int[][] points)` a következő probléma megoldására:\nHatározd meg, hogy a megadott pontok bumerángot alkotnak-e az X-Y síkon.\n\n@param points Egy pontokat tartalmazó tömb, ahol points[i] = [xi, yi].\n@return Igaz, ha a pontok bumerángot alkotnak, hamis egyébként.\n\nPélda:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nKimenet: true"
    },
    "instruction_bertscore": {
      "sq": "0.9987377039285232",
      "hy": "0.9878150192754148",
      "bn": "0.9958402825603674",
      "bg": "0.9849505705505106",
      "zh": "0.9832024245670226",
      "fr": "1",
      "de": "0.9897721244197515",
      "ha": "0.9904246252214511",
      "hi": "0.9805773254512655",
      "hu": "0.9940023556446516"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isBoomerang",
    "signature": "public static boolean isBoomerang(int[][] points)",
    "docstring": {
      "en": "Determine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "sq": "Përcaktoni nëse pikat e dhëna formojnë një bumerang në planin X-Y.\n\n@param points Një varg pikash ku points[i] = [xi, yi].\n@return True nëse pikat formojnë një bumerang, false përndryshe.\n\nShembull:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hy": "Սահմանել, արդյոք տրված կետերը ձևավորում են բումերանգ X-Y հարթության վրա։\n\n@param points Կետերի զանգված, որտեղ points[i] = [xi, yi]։\n@return Ճիշտ, եթե կետերը ձևավորում են բումերանգ, սխալ՝ հակառակ դեպքում։\n\nՕրինակ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nԵլք: true",
      "bn": "প্রদত্ত পয়েন্টগুলি X-Y প্লেনে একটি বুমেরাং তৈরি করে কিনা তা নির্ধারণ করুন।\n\n@param points পয়েন্টগুলির একটি অ্যারে যেখানে points[i] = [xi, yi]।\n@return পয়েন্টগুলি যদি একটি বুমেরাং গঠন করে তবে সত্য, অন্যথায় মিথ্যা।\n\nউদাহরণ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "bg": "Определете дали дадените точки образуват бумеранг в X-Y равнината.\n\n@param points Масив от точки, където points[i] = [xi, yi].\n@return True, ако точките образуват бумеранг, false в противен случай.\n\nПример:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "zh": "确定给定的点是否在 X-Y 平面上形成回旋镖。\n\n@param points 一个点的数组，其中 points[i] = [xi, yi]。\n@return 如果这些点形成回旋镖，则返回 True，否则返回 false。\n\n示例：\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n输出: true",
      "fr": "Déterminer si les points donnés forment un boomerang sur le plan X-Y.\n\n@param points Un tableau de points où points[i] = [xi, yi].\n@return True si les points forment un boomerang, false sinon.\n\nExemple :\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "de": "Bestimmen Sie, ob die gegebenen Punkte auf der X-Y-Ebene einen Bumerang bilden.\n\n@param points Ein Array von Punkten, wobei points[i] = [xi, yi].\n@return True, wenn die Punkte einen Bumerang bilden, andernfalls false.\n\nBeispiel:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nAusgabe: true",
      "ha": "Tantance idan maki da aka bayar suna samar da boomerang a kan filin X-Y.\n\n@param points Wani tsararraki na maki inda points[i] = [xi, yi].\n@return Gaskiya idan maki sun samar da boomerang, ƙarya in ba haka ba.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hi": "निर्धारित करें कि दिए गए बिंदु X-Y तल पर एक बूमरैंग बनाते हैं या नहीं।\n\n@param points बिंदुओं की एक array जहां points[i] = [xi, yi] है।\n@return True यदि बिंदु एक बूमरैंग बनाते हैं, अन्यथा false।\n\nउदाहरण:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hu": "Határozza meg, hogy az adott pontok bumerángot alkotnak-e az X-Y síkon.\n\n@param points Egy pontokat tartalmazó tömb, ahol points[i] = [xi, yi].\n@return Igaz, ha a pontok bumerángot alkotnak, hamis különben.\n\nPélda:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nKimenet: true"
    },
    "docstring_bertscore": {
      "sq": "0.9980647441975771",
      "hy": "0.9849082622793502",
      "bn": "0.9967472288801726",
      "bg": "0.9826685061028009",
      "zh": "0.9835595619921234",
      "fr": "1",
      "de": "0.9883898555981298",
      "ha": "1",
      "hi": "0.9941761572280571",
      "hu": "0.992035120350882"
    }
  },
  {
    "task_id": "Java/48",
    "prompt": {
      "en": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "sq": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Gjeni dhe ktheni numrin e n-të të shëmtuar.\n   *\n   * @param n Indeksi i numrit të shëmtuar për të gjetur.\n   * @return Numri i n-të i shëmtuar.\n   *\n   * Shembull:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "hy": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Գտնել և վերադարձնել n-րդ տգեղ թիվը։\n   *\n   * @param n Տգեղ թվի ինդեքսը, որը պետք է գտնել։\n   * @return n-րդ տգեղ թիվը։\n   *\n   * Օրինակ:\n   * findNthUglyNumber(10)\n   * Արդյունք: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "bn": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * nth কদর্য সংখ্যা খুঁজে বের করুন এবং ফেরত দিন।\n   *\n   * @param n খুঁজে বের করার জন্য কদর্য সংখ্যার সূচক।\n   * @return nth কদর্য সংখ্যা।\n   *\n   * উদাহরণ:\n   * findNthUglyNumber(10)\n   * আউটপুট: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "bg": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Намерете и върнете n-тото грозно число.\n   *\n   * @param n Индексът на грозното число, което трябва да се намери.\n   * @return n-тото грозно число.\n   *\n   * Пример:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "zh": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * 查找并返回第 n 个丑数。\n   *\n   * @param n 要查找的丑数的索引。\n   * @return 第 n 个丑数。\n   *\n   * 示例:\n   * findNthUglyNumber(10)\n   * 输出: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "fr": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Trouver et retourner le nième nombre laid.\n   *\n   * @param n L'indice du nombre laid à trouver.\n   * @return Le nième nombre laid.\n   *\n   * Exemple:\n   * findNthUglyNumber(10)\n   * Sortie: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "de": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Finde und gib die n-te hässliche Zahl zurück.\n   *\n   * @param n Der Index der zu findenden hässlichen Zahl.\n   * @return Die n-te hässliche Zahl.\n   *\n   * Beispiel:\n   * findNthUglyNumber(10)\n   * Ausgabe: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "ha": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Nemo kuma dawo da lamba mai muni ta n.\n   *\n   * @param n Lambar mai nuna inda lamba mai muni take nema.\n   * @return Lamba mai muni ta n.\n   *\n   * Misali:\n   * findNthUglyNumber(10)\n   * Fitarwa: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "hi": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * nth बदसूरत संख्या खोजें और लौटाएं।\n   *\n   * @param n बदसूरत संख्या का सूचकांक जिसे खोजना है।\n   * @return nth बदसूरत संख्या।\n   *\n   * उदाहरण:\n   * findNthUglyNumber(10)\n   * आउटपुट: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "hu": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Keresse meg és adja vissza az n-edik csúnya számot.\n   *\n   * @param n A keresendő csúnya szám indexe.\n   * @return Az n-edik csúnya szám.\n   *\n   * Példa:\n   * findNthUglyNumber(10)\n   * Kimenet: 12\n   */\n  public static int findNthUglyNumber(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9835142742652474",
      "hy": "0.9953494668888302",
      "bn": "0.9782885075706005",
      "bg": "0.974733222380457",
      "zh": "1",
      "fr": "1",
      "de": "0.9835142742652474",
      "ha": "0.9688698521626882",
      "hi": "0.99273529244403",
      "hu": "0.9835142742652474"
    },
    "canonical_solution": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n",
    "instruction": {
      "en": "Write a Java function `public static int findNthUglyNumber(int n)` to solve the following problem:\nFind and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12",
      "sq": "Shkruani një funksion Java `public static int findNthUglyNumber(int n)` për të zgjidhur problemin e mëposhtëm:  \nGjeni dhe ktheni numrin e n-të të shëmtuar.\n\n    @param n Indeksi i numrit të shëmtuar për të gjetur.\n    @return Numri i n-të i shëmtuar.\n   \n    Shembull:\n    findNthUglyNumber(10)\n    Output: 12",
      "hy": "Գրեք Java ֆունկցիա `public static int findNthUglyNumber(int n)` հետևյալ խնդիրը լուծելու համար:\nԳտնել և վերադարձնել n-րդ տգեղ թիվը.\n   \n    @param n Գտնվող տգեղ թվի ինդեքսը:\n    @return n-րդ տգեղ թիվը.\n   \n    Օրինակ:\n    findNthUglyNumber(10)\n    Output: 12",
      "bn": "একটি জাভা ফাংশন `public static int findNthUglyNumber(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn তম কুৎসিত সংখ্যা খুঁজে বের করুন এবং ফেরত দিন।\n   \n    @param n খুঁজে বের করার জন্য কুৎসিত সংখ্যার সূচক।\n    @return n তম কুৎসিত সংখ্যা।\n   \n    উদাহরণ:\n    findNthUglyNumber(10)\n    আউটপুট: 12",
      "bg": "Напишете Java функция `public static int findNthUglyNumber(int n)`, за да решите следния проблем:  \nНамерете и върнете n-тото грозно число.\n   \n    @param n Индексът на грозното число, което трябва да се намери.\n    @return n-тото грозно число.\n   \n    Пример:\n    findNthUglyNumber(10)\n    Изход: 12",
      "zh": "编写一个 Java 函数 `public static int findNthUglyNumber(int n)` 来解决以下问题：  \n查找并返回第 n 个丑数。\n\n    @param n 要查找的丑数的索引。\n    @return 第 n 个丑数。\n    \n    示例：\n    findNthUglyNumber(10)\n    输出: 12",
      "fr": "Écrivez une fonction Java `public static int findNthUglyNumber(int n)` pour résoudre le problème suivant :  \nTrouver et retourner le nième nombre laid.\n\n    @param n L'indice du nombre laid à trouver.\n    @return Le nième nombre laid.\n   \n    Exemple :\n    findNthUglyNumber(10)\n    Sortie : 12",
      "de": "Schreiben Sie eine Java-Funktion `public static int findNthUglyNumber(int n)`, um das folgende Problem zu lösen:\nFinden und geben Sie die n-te hässliche Zahl zurück.\n   \n    @param n Der Index der zu findenden hässlichen Zahl.\n    @return Die n-te hässliche Zahl.\n   \n    Beispiel:\n    findNthUglyNumber(10)\n    Ausgabe: 12",
      "ha": "Rubuta aikin Java `public static int findNthUglyNumber(int n)` don warware matsalar mai zuwa:  \nNemo kuma dawo da lamba mai muni ta n.\n\n    @param n Alamar lamba mai muni da za a nema.\n    @return Lamba mai muni ta n.\n\n    Misali:\n    findNthUglyNumber(10)\n    Output: 12",
      "hi": "Java फ़ंक्शन `public static int findNthUglyNumber(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nnth बदसूरत संख्या खोजें और लौटाएं।\n\n    @param n वह सूचकांक है जिस बदसूरत संख्या को खोजना है।\n    @return nth बदसूरत संख्या।\n\n    उदाहरण:\n    findNthUglyNumber(10)\n    आउटपुट: 12",
      "hu": "Írj egy Java függvényt `public static int findNthUglyNumber(int n)` a következő probléma megoldására:\nTaláld meg és add vissza az n-edik csúnya számot.\n   \n    @param n A megtalálandó csúnya szám indexe.\n    @return Az n-edik csúnya szám.\n   \n    Példa:\n    findNthUglyNumber(10)\n    Kimenet: 12"
    },
    "instruction_bertscore": {
      "sq": "0.9734939674331804",
      "hy": "1",
      "bn": "1",
      "bg": "0.991836291339466",
      "zh": "1",
      "fr": "1",
      "de": "0.9971393252523355",
      "ha": "0.971704506330437",
      "hi": "0.9722497467263779",
      "hu": "0.9829493694615842"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "findNthUglyNumber",
    "signature": "public static int findNthUglyNumber(int n)",
    "docstring": {
      "en": "Find and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12",
      "sq": "Gjeni dhe ktheni numrin e n-të të shëmtuar.\n\n    @param n Indeksi i numrit të shëmtuar për të gjetur.\n    @return Numri i n-të i shëmtuar.\n   \n    Shembull:\n    findNthUglyNumber(10)\n    Output: 12",
      "hy": "Գտնել և վերադարձնել n-րդ տգեղ թիվը։\n\n    @param n Տգեղ թվի ինդեքսը, որը պետք է գտնել։\n    @return n-րդ տգեղ թիվը։\n\n    Օրինակ:\n    findNthUglyNumber(10)\n    Արդյունք: 12",
      "bn": "nth কদর্য সংখ্যা খুঁজে বের করুন এবং ফেরত দিন।\n   \n    @param n খুঁজে বের করার জন্য কুৎসিত সংখ্যার সূচক।\n    @return nth কুৎসিত সংখ্যা।\n   \n    উদাহরণ:\n    findNthUglyNumber(10)\n    Output: 12",
      "bg": "Намерете и върнете n-тото грозно число.\n   \n    @param n Индексът на грозното число, което трябва да се намери.\n    @return n-тото грозно число.\n   \n    Пример:\n    findNthUglyNumber(10)\n    Изход: 12",
      "zh": "找到并返回第 n 个丑数。\n\n    @param n 要查找的丑数的索引。\n    @return 第 n 个丑数。\n   \n    示例:\n    findNthUglyNumber(10)\n    Output: 12",
      "fr": "Trouver et retourner le nième nombre laid.\n   \n    @param n L'indice du nombre laid à trouver.\n    @return Le nième nombre laid.\n   \n    Exemple:\n    findNthUglyNumber(10)\n    Output: 12",
      "de": "Finde und gib die n-te hässliche Zahl zurück.\n   \n    @param n Der Index der zu findenden hässlichen Zahl.\n    @return Die n-te hässliche Zahl.\n   \n    Beispiel:\n    findNthUglyNumber(10)\n    Ausgabe: 12",
      "ha": "Nemo kuma dawo da lamba mai muni ta n.\n   \n    @param n Lambar da ke nuna matsayin lambar mummuna da za a nema.\n    @return Lambar mummuna ta n.\n   \n    Misali:\n    findNthUglyNumber(10)\n    Output: 12",
      "hi": "nth बदसूरत संख्या खोजें और लौटाएं।\n   \n    @param n बदसूरत संख्या का वह सूचकांक जिसे खोजना है।\n    @return nth बदसूरत संख्या।\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12",
      "hu": "Keresse meg és adja vissza az n-edik csúnya számot.\n   \n    @param n A csúnya szám indexe, amelyet meg kell találni.\n    @return Az nth csúnya szám.\n\n    Példa:\n    findNthUglyNumber(10)\n    Kimenet: 12"
    },
    "docstring_bertscore": {
      "sq": "0.9726857404127495",
      "hy": "0.9618643572539687",
      "bn": "0.9623718578775129",
      "bg": "0.9908715435787796",
      "zh": "1",
      "fr": "1",
      "de": "0.9726857404127495",
      "ha": "0.9628239406247483",
      "hi": "0.9861888323458822",
      "hu": "0.9908715435787796"
    }
  },
  {
    "task_id": "Java/49",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "sq": "public class Solution {\n\n  /**\n   * Llogarit energjinë e vargut, e cila përcaktohet si gjatësia e nënvargut më të gjatë jo-bosh që përmban vetëm një karakter.\n   *\n   * @param s Vargu hyrës.\n   * @return Energjia e vargut.\n   *\n   * Shembull:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "hy": "public class Solution {\n\n  /**\n   * Հաշվել տողի էներգիան, որը սահմանվում է որպես ամենաերկար ոչ դատարկ ենթատողի երկարությունը, որը պարունակում է միայն մեկ սիմվոլ:\n   *\n   * @param s Մուտքային տողը:\n   * @return Տողի էներգիան:\n   *\n   * Օրինակ:\n   * calculateEnergy(\"aabbccdd\")\n   * Արդյունք: 2\n   */\n  public static int calculateEnergy(String s) ",
      "bn": "public class Solution {\n\n  /**\n   * স্ট্রিংয়ের শক্তি গণনা করুন, যা শুধুমাত্র একটি অক্ষর ধারণকারী দীর্ঘতম অ-খালি উপস্ট্রিংয়ের দৈর্ঘ্য হিসাবে সংজ্ঞায়িত করা হয়।\n   *\n   * @param s ইনপুট স্ট্রিং।\n   * @return স্ট্রিংয়ের শক্তি।\n   *\n   * উদাহরণ:\n   * calculateEnergy(\"aabbccdd\")\n   * আউটপুট: 2\n   */\n  public static int calculateEnergy(String s) ",
      "bg": "public class Solution {\n\n  /**\n   * Изчислете енергията на низа, която се определя като дължината на най-дългия непразен подниз, съдържащ само един символ.\n   *\n   * @param s Входният низ.\n   * @return Енергията на низа.\n   *\n   * Пример:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "zh": "public class Solution {\n\n  /**\n   * 计算字符串的能量，定义为仅包含一个字符的最长非空子串的长度。\n   *\n   * @param s 输入字符串。\n   * @return 字符串的能量。\n   *\n   * 示例:\n   * calculateEnergy(\"aabbccdd\")\n   * 输出: 2\n   */\n  public static int calculateEnergy(String s) ",
      "fr": "public class Solution {\n\n  /**\n   * Calculer l'énergie de la chaîne, qui est définie comme la longueur de la plus longue sous-chaîne non vide contenant un seul caractère.\n   *\n   * @param s La chaîne d'entrée.\n   * @return L'énergie de la chaîne.\n   *\n   * Exemple:\n   * calculateEnergy(\"aabbccdd\")\n   * Sortie: 2\n   */\n  public static int calculateEnergy(String s) ",
      "de": "public class Solution {\n\n  /**\n   * Berechne die Energie des Strings, die als die Länge des längsten nicht-leeren Substrings definiert ist, der nur ein Zeichen enthält.\n   *\n   * @param s Der Eingabestring.\n   * @return Die Energie des Strings.\n   *\n   * Beispiel:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "ha": "public class Solution {\n\n  /**\n   * Lissafa makamashin igiyar, wanda aka ayyana shi azaman tsawon mafi tsawo da ba komai ba substring da ke dauke da harafi daya kawai.\n   *\n   * @param s Igiyar shigarwa.\n   * @return Makamashin igiyar.\n   *\n   * Misali:\n   * calculateEnergy(\"aabbccdd\")\n   * Fitarwa: 2\n   */\n  public static int calculateEnergy(String s) ",
      "hi": "public class Solution {\n\n  /**\n   * स्ट्रिंग की ऊर्जा की गणना करें, जिसे केवल एक वर्ण वाली सबसे लंबी गैर-खाली उपस्ट्रिंग की लंबाई के रूप में परिभाषित किया गया है।\n   *\n   * @param s इनपुट स्ट्रिंग।\n   * @return स्ट्रिंग की ऊर्जा।\n   *\n   * उदाहरण:\n   * calculateEnergy(\"aabbccdd\")\n   * आउटपुट: 2\n   */\n  public static int calculateEnergy(String s) ",
      "hu": "public class Solution {\n\n  /**\n   * Számítsa ki a karakterlánc energiáját, amelyet az egyetlen karaktert tartalmazó leghosszabb nem üres részkarakterlánc hosszaként határozunk meg.\n   *\n   * @param s A bemeneti karakterlánc.\n   * @return A karakterlánc energiája.\n   *\n   * Példa:\n   * calculateEnergy(\"aabbccdd\")\n   * Kimenet: 2\n   */\n  public static int calculateEnergy(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9832469177723744",
      "hy": "0.9781025895339519",
      "bn": "0.9711135809468583",
      "bg": "0.9798610642972537",
      "zh": "0.9742686259192165",
      "fr": "0.9919882435809578",
      "de": "0.9955246588849029",
      "ha": "0.9642022368387494",
      "hi": "0.9764035052545794",
      "hu": "0.9946560482286374"
    },
    "canonical_solution": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }",
    "instruction": {
      "en": "Write a Java function `public static int calculateEnergy(String s)` to solve the following problem:\nCalculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "sq": "Shkruani një funksion Java `public static int calculateEnergy(String s)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni energjinë e vargut, e cila përcaktohet si gjatësia e nënvargut më të gjatë jo-bosh që përmban vetëm një karakter.\n\n    @param s Vargu hyrës.\n    @return Energjia e vargut.\n\n    Shembull:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hy": "Գրեք Java ֆունկցիա `public static int calculateEnergy(String s)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տողի էներգիան, որը սահմանվում է որպես ամենաերկար ոչ դատարկ ենթատողի երկարություն, որը պարունակում է միայն մեկ սիմվոլ։\n\n    @param s Մուտքային տողը։\n    @return Տողի էներգիան։\n\n    Օրինակ:\n    calculateEnergy(\"aabbccdd\")\n    Արդյունք: 2",
      "bn": "একটি জাভা ফাংশন `public static int calculateEnergy(String s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nস্ট্রিংয়ের শক্তি গণনা করুন, যা শুধুমাত্র একটি অক্ষর ধারণকারী দীর্ঘতম নন-এম্পটি সাবস্ট্রিংয়ের দৈর্ঘ্য হিসাবে সংজ্ঞায়িত করা হয়েছে।\n\n    @param s ইনপুট স্ট্রিং।\n    @return স্ট্রিংয়ের শক্তি।\n\n    উদাহরণ:\n    calculateEnergy(\"aabbccdd\")\n    আউটপুট: 2",
      "bg": "Напишете Java функция `public static int calculateEnergy(String s)` за решаване на следния проблем:  \nИзчислете енергията на низа, която се дефинира като дължината на най-дългия непразен подниз, съдържащ само един символ.\n   \n    @param s Входният низ.\n    @return Енергията на низа.\n   \n    Пример:\n    calculateEnergy(\"aabbccdd\")\n    Изход: 2",
      "zh": "编写一个 Java 函数 `public static int calculateEnergy(String s)` 来解决以下问题：  \n计算字符串的能量，定义为仅包含一个字符的最长非空子字符串的长度。\n\n    @param s 输入字符串。\n    @return 字符串的能量。\n   \n    例子:\n    calculateEnergy(\"aabbccdd\")\n    输出: 2",
      "fr": "Écrire une fonction Java `public static int calculateEnergy(String s)` pour résoudre le problème suivant :\nCalculer l'énergie de la chaîne, qui est définie comme la longueur de la plus longue sous-chaîne non vide contenant un seul caractère.\n\n    @param s La chaîne d'entrée.\n    @return L'énergie de la chaîne.\n   \n    Exemple :\n    calculateEnergy(\"aabbccdd\")\n    Sortie : 2",
      "de": "Schreiben Sie eine Java-Funktion `public static int calculateEnergy(String s)`, um das folgende Problem zu lösen:\nBerechnen Sie die Energie des Strings, die als die Länge des längsten nicht-leeren Substrings definiert ist, der nur ein Zeichen enthält.\n   \n    @param s Der Eingabestring.\n    @return Die Energie des Strings.\n   \n    Beispiel:\n    calculateEnergy(\"aabbccdd\")\n    Ausgabe: 2",
      "ha": "Rubuta aikin Java `public static int calculateEnergy(String s)` don magance matsalar mai zuwa:\nƘididdige kuzarin igiyar, wanda aka ayyana azaman tsawon mafi tsawo ba komai ba substring mai ɗauke da harafi ɗaya kawai.\n\n    @param s Igiyar shigarwa.\n    @return Kuzarin igiyar.\n\n    Misali:\n    calculateEnergy(\"aabbccdd\")\n    Fitarwa: 2",
      "hi": "Java फ़ंक्शन `public static int calculateEnergy(String s)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nस्ट्रिंग की ऊर्जा की गणना करें, जिसे केवल एक वर्ण वाली सबसे लंबी गैर-खाली उपस्ट्रिंग की लंबाई के रूप में परिभाषित किया गया है।\n\n    @param s इनपुट स्ट्रिंग।\n    @return स्ट्रिंग की ऊर्जा।\n\n    उदाहरण:\n    calculateEnergy(\"aabbccdd\")\n    आउटपुट: 2",
      "hu": "Írj egy Java függvényt `public static int calculateEnergy(String s)` a következő probléma megoldására:\nSzámítsd ki a string energiáját, amelyet a leghosszabb nem üres, csak egy karaktert tartalmazó részstring hosszaként definiálunk.\n   \n    @param s A bemeneti string.\n    @return A string energiája.\n   \n    Példa:\n    calculateEnergy(\"aabbccdd\")\n    Kimenet: 2"
    },
    "instruction_bertscore": {
      "sq": "0.980756291424578",
      "hy": "0.9913830168099445",
      "bn": "0.9770859992438153",
      "bg": "1",
      "zh": "0.9692895581578149",
      "fr": "1",
      "de": "0.993190751907743",
      "ha": "0.9650476077404339",
      "hi": "0.9504363569115074",
      "hu": "1"
    },
    "level": "hard",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; // Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; // All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; // Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateEnergy",
    "signature": "public static int calculateEnergy(String s)",
    "docstring": {
      "en": "Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "sq": "Llogarit energjinë e vargut, e cila përcaktohet si gjatësia e nënvargut më të gjatë jo-bosh që përmban vetëm një karakter.\n   \n    @param s Vargu hyrës.\n    @return Energjia e vargut.\n   \n    Shembull:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hy": "Հաշվեք տողի էներգիան, որը սահմանվում է որպես ամենաերկար ոչ դատարկ ենթատողի երկարությունը, որը պարունակում է միայն մեկ սիմվոլ։\n   \n    @param s Մուտքային տողը։\n    @return Տողի էներգիան։\n   \n    Օրինակ:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "bn": "স্ট্রিংয়ের শক্তি গণনা করুন, যা শুধুমাত্র একটি অক্ষর ধারণকারী দীর্ঘতম নন-এম্পটি সাবস্ট্রিংয়ের দৈর্ঘ্য হিসাবে সংজ্ঞায়িত করা হয়।\n   \n    @param s ইনপুট স্ট্রিং।\n    @return স্ট্রিংয়ের শক্তি।\n\n    উদাহরণ:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "bg": "Изчислете енергията на низа, която се определя като дължината на най-дългия непразен подниз, съдържащ само един символ.\n   \n    @param s Входният низ.\n    @return Енергията на низа.\n   \n    Пример:\n    calculateEnergy(\"aabbccdd\")\n    Изход: 2",
      "zh": "计算字符串的能量，其定义为仅包含一个字符的最长非空子字符串的长度。\n   \n    @param s 输入字符串。\n    @return 字符串的能量。\n   \n    示例：\n    calculateEnergy(\"aabbccdd\")\n    输出: 2",
      "fr": "Calculer l'énergie de la chaîne, qui est définie comme la longueur de la plus longue sous-chaîne non vide contenant un seul caractère.\n   \n    @param s La chaîne d'entrée.\n    @return L'énergie de la chaîne.\n   \n    Exemple :\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "de": "Berechnen Sie die Energie der Zeichenkette, die als die Länge der längsten nicht-leeren Teilzeichenkette definiert ist, die nur ein Zeichen enthält.\n   \n    @param s Die Eingabezeichenkette.\n    @return Die Energie der Zeichenkette.\n   \n    Beispiel:\n    calculateEnergy(\"aabbccdd\")\n    Ausgabe: 2",
      "ha": "Ƙididdige kuzarin igiyar, wanda aka ayyana azaman tsawon mafi tsawo ba komai ba substring mai ɗauke da harafi ɗaya kawai.\n   \n    @param s Jeren shigarwa.\n    @return Makaman jeren.\n   \n    Misali:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hi": "स्ट्रिंग की ऊर्जा की गणना करें, जिसे केवल एक वर्ण वाली सबसे लंबी गैर-खाली उपस्ट्रिंग की लंबाई के रूप में परिभाषित किया गया है।\n   \n    @param s इनपुट स्ट्रिंग।\n    @return स्ट्रिंग की ऊर्जा।\n\n    उदाहरण:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hu": "Számítsa ki a karakterlánc energiáját, amelyet a leghosszabb nem üres, csak egy karaktert tartalmazó részkarakterlánc hossza határoz meg.\n   \n    @param s A bemeneti karakterlánc.\n    @return A karakterlánc energiája.\n\n    Példa:\n    calculateEnergy(\"aabbccdd\")\n    Kimenet: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9679768099695554",
      "hy": "0.9851559543645008",
      "bn": "0.9656955400433697",
      "bg": "0.999999801369619",
      "zh": "0.9793499883268509",
      "fr": "0.9856606741627104",
      "de": "0.9911047356461146",
      "ha": "0.9602997457425569",
      "hi": "0.9374926081313689",
      "hu": "0.9835297674349681"
    }
  },
  {
    "task_id": "Java/50",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "sq": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Kthen të gjitha numrat e plotë në intervalin [1, n] në rend leksikografik.\n   *\n   * @param n Kufiri i sipërm i intervalit.\n   * @return Lista e numrave të plotë në rend leksikografik.\n   *\n   * Shembull:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "hy": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Վերադարձնել բոլոր ամբողջ թվերը [1, n] միջակայքում բառարանային կարգով:\n   *\n   * @param n Միջակայքի վերին սահմանը:\n   * @return Բառարանային կարգով ամբողջ թվերի ցուցակ:\n   *\n   * Օրինակ:\n   * lexicalOrder(13)\n   * Արդյունք: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "bn": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * লেক্সিকোগ্রাফিক ক্রমে [1, n] পরিসরের সমস্ত পূর্ণসংখ্যা ফেরত দিন।\n   *\n   * @param n পরিসরের উপরের সীমা।\n   * @return লেক্সিকোগ্রাফিক ক্রমে পূর্ণসংখ্যার তালিকা।\n   *\n   * উদাহরণ:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "bg": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Връща всички цели числа в диапазона [1, n] в лексикографски ред.\n   *\n   * @param n Горната граница на диапазона.\n   * @return Списък с цели числа в лексикографски ред.\n   *\n   * Пример:\n   * lexicalOrder(13)\n   * Изход: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "zh": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * 返回范围 [1, n] 内的所有整数，按字典顺序排列。\n   *\n   * @param n 范围的上限。\n   * @return 按字典顺序排列的整数列表。\n   *\n   * 示例:\n   * lexicalOrder(13)\n   * 输出: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "fr": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Retourne tous les entiers dans la plage [1, n] dans l'ordre lexicographique.\n   *\n   * @param n La limite supérieure de la plage.\n   * @return Liste d'entiers dans l'ordre lexicographique.\n   *\n   * Exemple:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "de": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Gibt alle ganzen Zahlen im Bereich [1, n] in lexikographischer Reihenfolge zurück.\n   *\n   * @param n Die obere Grenze des Bereichs.\n   * @return Liste von ganzen Zahlen in lexikographischer Reihenfolge.\n   *\n   * Beispiel:\n   * lexicalOrder(13)\n   * Ausgabe: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "ha": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Mayar da duk lambobi a cikin kewayon [1, n] a cikin tsari na haruffa.\n   *\n   * @param n Iyakar sama na kewayon.\n   * @return Jerin lambobi a cikin tsari na haruffa.\n   *\n   * Misali:\n   * lexicalOrder(13)\n   * Fitarwa: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "hi": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * श्रेणी [1, n] में सभी पूर्णांकों को शब्दकोशीय क्रम में लौटाएं।\n   *\n   * @param n श्रेणी की उच्च सीमा।\n   * @return शब्दकोशीय क्रम में पूर्णांकों की सूची।\n   *\n   * उदाहरण:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "hu": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Az összes egész szám visszaadása a [1, n] tartományban lexikografikus sorrendben.\n   *\n   * @param n A tartomány felső határa.\n   * @return Egész számok listája lexikografikus sorrendben.\n   *\n   * Példa:\n   * lexicalOrder(13)\n   * Kimenet: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9772671501513192",
      "hy": "0.996498543643117",
      "bn": "0.9936922936198561",
      "bg": "0.9888254520237393",
      "zh": "0.9936922936198561",
      "fr": "0.998866615045815",
      "de": "0.998866615045815",
      "ha": "0.9829322872488152",
      "hi": "1",
      "hu": "0.9944427191994059"
    },
    "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }",
    "instruction": {
      "en": "Write a Java function `public static List<Integer> lexicalOrder(int n)` to solve the following problem:\nReturn all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "sq": "Shkruani një funksion Java `public static List<Integer> lexicalOrder(int n)` për të zgjidhur problemin e mëposhtëm: \nKtheni të gjitha numrat e plotë në intervalin [1, n] në rend leksikografik.\n   \n    @param n Kufiri i sipërm i intervalit.\n    @return Lista e numrave të plotë në rend leksikografik.\n   \n    Shembull:\n    lexicalOrder(13)\n    Dalja: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hy": "Java ֆունկցիա գրեք `public static List<Integer> lexicalOrder(int n)` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնել բոլոր ամբողջ թվերը [1, n] միջակայքում բառարանային կարգով:\n\n    @param n Միջակայքի վերին սահմանը:\n    @return Բառարանային կարգով ամբողջ թվերի ցուցակ:\n   \n    Օրինակ:\n    lexicalOrder(13)\n    Արդյունք: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "bn": "একটি জাভা ফাংশন `public static List<Integer> lexicalOrder(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nরেঞ্জ [1, n] এর সকল পূর্ণসংখ্যা বর্ণানুক্রমিক ক্রমে ফেরত দিন।\n\n    @param n পরিসরের উপরের সীমা।\n    @return বর্ণানুক্রমিক ক্রমে পূর্ণসংখ্যার তালিকা।\n\n    উদাহরণ:\n    lexicalOrder(13)\n    আউটপুট: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "bg": "Напишете Java функция `public static List<Integer> lexicalOrder(int n)`, за да решите следния проблем:  \nВърнете всички цели числа в диапазона [1, n] в лексикографски ред.\n   \n    @param n Горната граница на диапазона.\n    @return Списък от цели числа в лексикографски ред.\n   \n    Пример:\n    lexicalOrder(13)\n    Изход: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "zh": "编写一个 Java 函数 `public static List<Integer> lexicalOrder(int n)` 来解决以下问题：\n返回范围 [1, n] 内所有整数的字典顺序。\n\n    @param n 范围的上限。\n    @return 按字典顺序排列的整数列表。\n   \n    示例：\n    lexicalOrder(13)\n    输出: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "fr": "Écrire une fonction Java `public static List<Integer> lexicalOrder(int n)` pour résoudre le problème suivant :  \nRetourner tous les entiers dans la plage [1, n] dans l'ordre lexicographique.\n   \n    @param n La limite supérieure de la plage.\n    @return Liste des entiers dans l'ordre lexicographique.\n   \n    Exemple :\n    lexicalOrder(13)\n    Sortie : [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "de": "Schreiben Sie eine Java-Funktion `public static List<Integer> lexicalOrder(int n)`, um das folgende Problem zu lösen:\nGeben Sie alle Ganzzahlen im Bereich [1, n] in lexikographischer Reihenfolge zurück.\n   \n    @param n Die obere Grenze des Bereichs.\n    @return Liste von Ganzzahlen in lexikographischer Reihenfolge.\n   \n    Beispiel:\n    lexicalOrder(13)\n    Ausgabe: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "ha": "Rubuta wani aikin Java `public static List<Integer> lexicalOrder(int n)` don warware matsalar mai zuwa:\nMayar da duk lambobin cikinsu a cikin kewayon [1, n] a cikin tsarin haruffa.\n\n    @param n Iyakar sama na kewayon.\n    @return Jerin lambobi a cikin tsarin haruffa.\n\n    Misali:\n    lexicalOrder(13)\n    Fitarwa: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hi": "Java फ़ंक्शन `public static List<Integer> lexicalOrder(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलेक्सिकोग्राफिकल क्रम में [1, n] सीमा के भीतर सभी पूर्णांक लौटाएं।\n\n    @param n सीमा की ऊपरी सीमा।\n    @return लेक्सिकोग्राफिकल क्रम में पूर्णांकों की सूची।\n\n    उदाहरण:\n    lexicalOrder(13)\n    आउटपुट: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hu": "Írj egy Java függvényt `public static List<Integer> lexicalOrder(int n)` a következő probléma megoldására:\nAdja vissza az összes egész számot a [1, n] tartományban lexikografikus sorrendben.\n   \n    @param n A tartomány felső határa.\n    @return Egész számok listája lexikografikus sorrendben.\n   \n    Példa:\n    lexicalOrder(13)\n    Kimenet: [1,10,11,12,13,2,3,4,5,6,7,8,9]"
    },
    "instruction_bertscore": {
      "sq": "0.9888459109529859",
      "hy": "0.9798827150087865",
      "bn": "0.9921680040757943",
      "bg": "0.9889658837031309",
      "zh": "0.9921680040757943",
      "fr": "0.999999801369619",
      "de": "0.9959280771887848",
      "ha": "0.9713531291863864",
      "hi": "0.9689632084417745",
      "hu": "0.9959280771887848"
    },
    "level": "middle",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "lexicalOrder",
    "signature": "public static List<Integer> lexicalOrder(int n)",
    "docstring": {
      "en": "Return all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "sq": "Kthe të gjitha numrat e plotë në intervalin [1, n] në rend leksikografik.\n\n    @param n Kufiri i sipërm i intervalit.\n    @return Listë e numrave të plotë në rend leksikografik.\n\n    Shembull:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hy": "Բոլոր ամբողջ թվերը վերադարձնել [1, n] միջակայքում բառարանային կարգով։\n\n    @param n Միջակայքի վերին սահմանը։\n    @return Բառարանային կարգով ամբողջ թվերի ցուցակ։\n\n    Օրինակ:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "bn": "লেক্সিকোগ্রাফিক ক্রমে [1, n] পরিসরের সমস্ত পূর্ণসংখ্যা ফেরত দিন।\n\n    @param n পরিসরের উপরের সীমা।\n    @return বর্ণানুক্রমিক ক্রমে পূর্ণসংখ্যার তালিকা।\n\n    উদাহরণ:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "bg": "Върнете всички цели числа в диапазона [1, n] в лексикографски ред.\n   \n    @param n Горната граница на диапазона.\n    @return Списък от цели числа в лексикографски ред.\n   \n    Пример:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "zh": "返回范围 [1, n] 内的所有整数，按字典顺序排列。\n\n    @param n 范围的上限。\n    @return 按字典顺序排列的整数列表。\n\n    示例：\n    lexicalOrder(13)\n    输出: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "fr": "Retourne tous les entiers dans la plage [1, n] dans l'ordre lexicographique.\n\n    @param n La limite supérieure de la plage.\n    @return Liste des entiers dans l'ordre lexicographique.\n   \n    Exemple:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "de": "Gibt alle ganzen Zahlen im Bereich [1, n] in lexikographischer Reihenfolge zurück.\n   \n    @param n Die obere Grenze des Bereichs.\n    @return Liste von ganzen Zahlen in lexikographischer Reihenfolge.\n   \n    Beispiel:\n    lexicalOrder(13)\n    Ausgabe: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "ha": "Mayar da duk lambobi a cikin kewayon [1, n] a cikin tsari na haruffa.\n\n    @param n Iyakar sama na kewayon.\n    @return Jerin lambobin cikakkun adadi a cikin tsari na haruffa.\n\n    Misali:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hi": "श्रेणी [1, n] में सभी पूर्णांकों को शब्दकोशीय क्रम में लौटाएं।\n\n    @param n श्रेणी की ऊपरी सीमा।\n    @return शब्दकोशीय क्रम में पूर्णांकों की सूची।\n\n    उदाहरण:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hu": "Adja vissza az összes egész számot a [1, n] tartományban lexikografikus sorrendben.\n   \n    @param n A tartomány felső határa.\n    @return Egész számok listája lexikografikus sorrendben.\n   \n    Példa:\n    lexicalOrder(13)\n    Kimenet: [1,10,11,12,13,2,3,4,5,6,7,8,9]"
    },
    "docstring_bertscore": {
      "sq": "0.9822861426193087",
      "hy": "0.9890316303592535",
      "bn": "0.9890316303592535",
      "bg": "0.9865997986042433",
      "zh": "0.9898932889521829",
      "fr": "0.9920089011405854",
      "de": "0.9920089011405854",
      "ha": "0.9538343268398712",
      "hi": "0.9498446370064045",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/51",
    "prompt": {
      "en": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "sq": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Llogarit shumën e elementeve unike në vargun e dhënë të numrave të plotë.\n   *\n   * @param nums Një varg i numrave të plotë.\n   * @return Shuma e elementeve unike.\n   *\n   * Shembull:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "hy": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Հաշվարկել տրված ամբողջ թվերի զանգվածի եզակի տարրերի գումարը։\n   *\n   * @param nums Ամբողջ թվերի զանգված։\n   * @return Եզակի տարրերի գումարը։\n   *\n   * Օրինակ:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Արդյունք: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "bn": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * প্রদত্ত পূর্ণসংখ্যার অ্যারের অনন্য উপাদানগুলির যোগফল গণনা করুন।\n   *\n   * @param nums পূর্ণসংখ্যার একটি অ্যারে।\n   * @return অনন্য উপাদানগুলির যোগফল।\n   *\n   * উদাহরণ:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * আউটপুট: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "bg": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Изчисляване на сумата от уникалните елементи в дадения масив от цели числа.\n   *\n   * @param nums Масив от цели числа.\n   * @return Сумата от уникалните елементи.\n   *\n   * Пример:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "zh": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * 计算给定整数数组中唯一元素的和。\n   *\n   * @param nums 整数数组。\n   * @return 唯一元素的和。\n   *\n   * 示例:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * 输出: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "fr": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculer la somme des éléments uniques dans le tableau d'entiers donné.\n   *\n   * @param nums Un tableau d'entiers.\n   * @return La somme des éléments uniques.\n   *\n   * Exemple:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Sortie: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "de": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Berechnet die Summe der einzigartigen Elemente im gegebenen Integer-Array.\n   *\n   * @param nums Ein Array von ganzen Zahlen.\n   * @return Die Summe der einzigartigen Elemente.\n   *\n   * Beispiel:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Ausgabe: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "ha": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Lissafa jumillar abubuwan da ba su maimaita kansu ba a cikin jerin lambobin da aka bayar.\n   *\n   * @param nums Jerin lambobi.\n   * @return Jumillar abubuwan da ba su maimaita kansu ba.\n   *\n   * Misali:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "hi": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * दिए गए पूर्णांक array में अद्वितीय तत्वों का योग गणना करें।\n   *\n   * @param nums पूर्णांकों का एक array।\n   * @return अद्वितीय तत्वों का योग।\n   *\n   * उदाहरण:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * आउटपुट: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "hu": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Számítsa ki az egyedi elemek összegét a megadott egész szám tömbben.\n   *\n   * @param nums Egész számok tömbje.\n   * @return Az egyedi elemek összege.\n   *\n   * Példa:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Kimenet: 4\n   */\n  public static int calculateUniqueSum(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "0.9921084149614839",
      "hy": "0.9759730732188768",
      "bn": "0.9957367961318482",
      "bg": "0.9797093106861431",
      "zh": "0.9714441019009004",
      "fr": "1",
      "de": "0.9941519243215708",
      "ha": "0.9234855909215507",
      "hi": "1",
      "hu": "0.9915296060311483"
    },
    "canonical_solution": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }",
    "instruction": {
      "en": "Write a Java function `public static int calculateUniqueSum(int[] nums)` to solve the following problem:\nCalculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "sq": "Shkruani një funksion Java `public static int calculateUniqueSum(int[] nums)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni shumën e elementeve unike në vargun e dhënë të numrave të plotë.\n\n   @param nums Një varg me numra të plotë.\n   @return Shuma e elementeve unike.\n\n   Shembull:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "hy": "Գրեք Java ֆունկցիա `public static int calculateUniqueSum(int[] nums)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրված ամբողջ թվերի զանգվածի եզակի տարրերի գումարը։\n\n   @param nums Ամբողջ թվերի զանգված։\n   @return Եզակի տարրերի գումարը։\n\n   Օրինակ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Արդյունք: 4",
      "bn": "একটি জাভা ফাংশন `public static int calculateUniqueSum(int[] nums)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যার অ্যারেতে অনন্য উপাদানগুলির যোগফল গণনা করুন।\n\n   @param nums পূর্ণসংখ্যার একটি অ্যারে।\n   @return অনন্য উপাদানগুলির যোগফল।\n\n   উদাহরণ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   আউটপুট: 4",
      "bg": "Напишете Java функция `public static int calculateUniqueSum(int[] nums)`, за да решите следния проблем:  \nИзчислете сумата на уникалните елементи в дадения масив от цели числа.\n\n   @param nums Масив от цели числа.\n   @return Сумата на уникалните елементи.\n\n   Пример:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Изход: 4",
      "zh": "编写一个 Java 函数 `public static int calculateUniqueSum(int[] nums)` 来解决以下问题：\n计算给定整数数组中唯一元素的和。\n\n   @param nums 一个整数数组。\n   @return 唯一元素的和。\n\n   示例：\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   输出: 4",
      "fr": "Écrire une fonction Java `public static int calculateUniqueSum(int[] nums)` pour résoudre le problème suivant :  \nCalculer la somme des éléments uniques dans le tableau d'entiers donné.\n\n   @param nums Un tableau d'entiers.\n   @return La somme des éléments uniques.\n\n   Exemple :  \n   calculateUniqueSum(new int[]{1, 2, 3, 2})  \n   Sortie : 4",
      "de": "Schreiben Sie eine Java-Funktion `public static int calculateUniqueSum(int[] nums)`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der eindeutigen Elemente im gegebenen Integer-Array.\n\n   @param nums Ein Array von Ganzzahlen.\n   @return Die Summe der eindeutigen Elemente.\n\n   Beispiel:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "ha": "Rubuta aikin Java `public static int calculateUniqueSum(int[] nums)` don warware matsalar mai zuwa:\nƘididdige jimillar abubuwan musamman a cikin jerin lambobin da aka bayar.\n\n   @param nums Wani tsararren lambobi.\n   @return Jimillar abubuwan musamman.\n\n   Misali:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Fitarwa: 4",
      "hi": "Java फ़ंक्शन `public static int calculateUniqueSum(int[] nums)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक एरे में अद्वितीय तत्वों का योग गणना करें।\n\n   @param nums पूर्णांकों का एक एरे।\n   @return अद्वितीय तत्वों का योग।\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "hu": "Írj egy Java függvényt `public static int calculateUniqueSum(int[] nums)` a következő probléma megoldására:\nSzámítsd ki az egyedi elemek összegét a megadott egész számokat tartalmazó tömbben.\n\n   @param nums Egy egész számokat tartalmazó tömb.\n   @return Az egyedi elemek összege.\n\n   Példa:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Kimenet: 4"
    },
    "instruction_bertscore": {
      "sq": "0.990844927107721",
      "hy": "0.965845704611432",
      "bn": "0.9944365616575939",
      "bg": "0.9745639892958153",
      "zh": "0.9870848539947306",
      "fr": "0.990844927107721",
      "de": "0.9861943939965512",
      "ha": "0.96467835386209",
      "hi": "0.9751008872157526",
      "hu": "0.9878362727261856"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; // Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; // Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; // Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateUniqueSum",
    "signature": "public static int calculateUniqueSum(int[] nums)",
    "docstring": {
      "en": "Calculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "sq": "Llogarit shumën e elementeve unike në vargun e dhënë të numrave të plotë.\n\n   @param nums Një varg me numra të plotë.\n   @return Shuma e elementeve unike.\n\n   Shembull:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "hy": "Հաշվարկել տրված ամբողջ թվերի զանգվածում եզակի տարրերի գումարը։\n\n   @param nums Ամբողջ թվերի զանգված։\n   @return Եզակի տարրերի գումարը։\n\n   Օրինակ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Արդյունք: 4",
      "bn": "অনন্য উপাদানগুলির যোগফল গণনা করুন প্রদত্ত পূর্ণসংখ্যার অ্যারেতে।\n\n   @param nums পূর্ণসংখ্যার একটি অ্যারে।\n   @return অনন্য উপাদানগুলির যোগফল।\n\n   উদাহরণ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   আউটপুট: 4",
      "bg": "Изчислете сумата на уникалните елементи в дадения масив от цели числа.\n\n   @param nums Масив от цели числа.\n   @return Сумата на уникалните елементи.\n\n   Пример:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Изход: 4",
      "zh": "计算给定整数数组中唯一元素的和。\n\n   @param nums 一个整数数组。\n   @return 唯一元素的和。\n\n   示例：\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   输出: 4",
      "fr": "Calculer la somme des éléments uniques dans le tableau d'entiers donné.\n\n   @param nums Un tableau d'entiers.\n   @return La somme des éléments uniques.\n\n   Exemple :\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Sortie : 4",
      "de": "Berechne die Summe der einzigartigen Elemente im gegebenen Integer-Array.\n\n   @param nums Ein Array von Ganzzahlen.\n   @return Die Summe der einzigartigen Elemente.\n\n   Beispiel:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Ausgabe: 4",
      "ha": "Lissafa jumillar abubuwan da ba su maimaita kansu ba a cikin jerin lambobin da aka bayar.\n\n   @param nums Wani tsararren lambobi.\n   @return Jimillar abubuwan da ba su maimaita kansu ba.\n\n   Misali:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "hi": "अद्वितीय तत्वों का योग दिए गए पूर्णांक सरणी में गणना करें।\n\n   @param nums पूर्णांकों की एक सरणी।\n   @return अद्वितीय तत्वों का योग।\n\n   उदाहरण:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   आउटपुट: 4",
      "hu": "Számítsa ki az egyedi elemek összegét a megadott egész szám tömbben.\n\n   @param nums Egy egész számokat tartalmazó tömb.\n   @return Az egyedi elemek összege.\n\n   Példa:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Kimenet: 4"
    },
    "docstring_bertscore": {
      "sq": "0.9908139407682796",
      "hy": "0.95959401199874",
      "bn": "0.9952626654123179",
      "bg": "0.9653336354891241",
      "zh": "0.9846266043990427",
      "fr": "0.9908139407682796",
      "de": "0.9899481109373485",
      "ha": "0.9579380305120521",
      "hi": "1",
      "hu": "0.9862712639540117"
    }
  },
  {
    "task_id": "Java/52",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, kthe numrin minimal të numrave katrorë perfektë që shuma e tyre është n.\n   *\n   * @param n Numri i plotë i synuar.\n   * @return Numri minimal i numrave katrorë perfektë.\n   *\n   * Shembull:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Shembull:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, վերադարձնել նվազագույն քանակը կատարյալ քառակուսի թվերի, որոնք գումարվում են n-ի։\n   *\n   * @param n Նպատակային ամբողջ թիվը։\n   * @return Կատարյալ քառակուսի թվերի նվազագույն քանակը։\n   *\n   * Օրինակ:\n   * minPerfectSquareSum(12)\n   * Արդյունք: 3\n   *\n   * Օրինակ:\n   * minPerfectSquareSum(13)\n   * Արդյունք: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, n এর সমষ্টি হিসাবে প্রাপ্ত সর্বনিম্ন সংখ্যা নিখুঁত বর্গসংখ্যা ফেরত দিন।\n   *\n   * @param n লক্ষ্য পূর্ণসংখ্যা।\n   * @return নিখুঁত বর্গসংখ্যার সর্বনিম্ন সংখ্যা।\n   *\n   * উদাহরণ:\n   * minPerfectSquareSum(12)\n   * আউটপুট: 3\n   *\n   * উদাহরণ:\n   * minPerfectSquareSum(13)\n   * আউটপুট: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е цяло число n, върнете минималния брой перфектни квадратни числа, които сумират до n.\n   *\n   * @param n Целевото цяло число.\n   * @return Минималният брой перфектни квадратни числа.\n   *\n   * Пример:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Пример:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个整数 n，返回其和为 n 的最少完全平方数的数量。\n   *\n   * @param n 目标整数。\n   * @return 最少完全平方数的数量。\n   *\n   * 示例:\n   * minPerfectSquareSum(12)\n   * 输出: 3\n   *\n   * 示例:\n   * minPerfectSquareSum(13)\n   * 输出: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier n, retourne le nombre minimum de nombres carrés parfaits qui s'additionnent pour donner n.\n   *\n   * @param n L'entier cible.\n   * @return Le nombre minimum de nombres carrés parfaits.\n   *\n   * Exemple :\n   * minPerfectSquareSum(12)\n   * Sortie : 3\n   *\n   * Exemple :\n   * minPerfectSquareSum(13)\n   * Sortie : 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, gib die minimale Anzahl von perfekten Quadratzahlen zurück, die sich zu n summieren.\n   *\n   * @param n Die Zielzahl.\n   * @return Die minimale Anzahl von perfekten Quadratzahlen.\n   *\n   * Beispiel:\n   * minPerfectSquareSum(12)\n   * Ausgabe: 3\n   *\n   * Beispiel:\n   * minPerfectSquareSum(13)\n   * Ausgabe: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba n, dawo da mafi ƙarancin adadin lambobin murabba'i cikakke waɗanda suka tara zuwa n.\n   *\n   * @param n Manufar lamba.\n   * @return Mafi ƙarancin adadin lambobin murabba'i cikakke.\n   *\n   * Misali:\n   * minPerfectSquareSum(12)\n   * Fitarwa: 3\n   *\n   * Misali:\n   * minPerfectSquareSum(13)\n   * Fitarwa: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए पूर्णांक n के लिए, उन पूर्ण वर्ग संख्याओं की न्यूनतम संख्या लौटाएं जिनका योग n होता है।\n   *\n   * @param n लक्षित पूर्णांक।\n   * @return पूर्ण वर्ग संख्याओं की न्यूनतम संख्या।\n   *\n   * उदाहरण:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * उदाहरण:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy egész szám n, térjen vissza a tökéletes négyzetekből álló számok minimális számára, amelyek összege n.\n   *\n   * @param n A cél egész szám.\n   * @return A tökéletes négyzetekből álló számok minimális száma.\n   *\n   * Példa:\n   * minPerfectSquareSum(12)\n   * Kimenet: 3\n   *\n   * Példa:\n   * minPerfectSquareSum(13)\n   * Kimenet: 2\n   */\n  public static int minPerfectSquareSum(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9961497486940197",
      "hy": "0.9868125317423317",
      "bn": "0.9605645200404764",
      "bg": "0.9961497486940197",
      "zh": "0.9567287687523117",
      "fr": "0.9961497486940197",
      "de": "0.9738667966583828",
      "ha": "0.9677499740744134",
      "hi": "0.9621551521318038",
      "hu": "0.9961497486940197"
    },
    "canonical_solution": "  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }",
    "instruction": {
      "en": "Write a Java function `public static int minPerfectSquareSum(int n)` to solve the following problem:\nGiven an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2",
      "sq": "Shkruani një funksion Java `public static int minPerfectSquareSum(int n)` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një numër të plotë n, kthe numrin minimal të numrave katrorë perfektë që shuma e tyre është e barabartë me n.\n\n    @param n Numri i plotë i synuar.\n    @return Numri minimal i numrave katrorë perfektë.\n\n    Shembull:\n    minPerfectSquareSum(12)\n    Output: 3\n\n    Shembull:\n    minPerfectSquareSum(13)\n    Output: 2",
      "hy": "Գրեք Java ֆունկցիա `public static int minPerfectSquareSum(int n)` հետևյալ խնդիրը լուծելու համար:  \nՏրված է ամբողջ թիվ n, վերադարձնել նվազագույն քանակի կատարյալ քառակուսի թվերը, որոնք գումարվում են n-ի:\n\n    @param n Նպատակային ամբողջ թիվը։\n    @return Նվազագույն քանակի կատարյալ քառակուսի թվերը։\n\n    Օրինակ:\n    minPerfectSquareSum(12)\n    Արդյունք: 3\n\n    Օրինակ:\n    minPerfectSquareSum(13)\n    Արդյունք: 2",
      "bn": "একটি জাভা ফাংশন `public static int minPerfectSquareSum(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া আছে, n এর সমষ্টি হিসাবে ন্যূনতম সংখ্যক পূর্ণ বর্গ সংখ্যা ফেরত দিন।\n\n    @param n লক্ষ্য পূর্ণসংখ্যা।\n    @return ন্যূনতম সংখ্যক পূর্ণ বর্গ সংখ্যা।\n   \n    উদাহরণ:\n    minPerfectSquareSum(12)\n    আউটপুট: 3\n   \n    উদাহরণ:\n    minPerfectSquareSum(13)\n    আউটপুট: 2",
      "bg": "Напишете Java функция `public static int minPerfectSquareSum(int n)`, за да решите следния проблем:  \nДадено е цяло число n, върнете минималния брой перфектни квадратни числа, които се сумират до n.\n   \n    @param n Целевото цяло число.\n    @return Минималният брой перфектни квадратни числа.\n   \n    Пример:\n    minPerfectSquareSum(12)\n    Изход: 3\n   \n    Пример:\n    minPerfectSquareSum(13)\n    Изход: 2",
      "zh": "编写一个 Java 函数 `public static int minPerfectSquareSum(int n)` 来解决以下问题：  \n给定一个整数 n，返回其和为 n 的最小完全平方数的数量。\n\n    @param n 目标整数。\n    @return 最小完全平方数的数量。\n\n    示例：\n    minPerfectSquareSum(12)\n    输出: 3\n\n    示例：\n    minPerfectSquareSum(13)\n    输出: 2",
      "fr": "Écrire une fonction Java `public static int minPerfectSquareSum(int n)` pour résoudre le problème suivant :  \nÉtant donné un entier n, retourner le nombre minimum de nombres carrés parfaits qui s'additionnent pour donner n.\n\n    @param n L'entier cible.\n    @return Le nombre minimum de nombres carrés parfaits.\n   \n    Exemple :\n    minPerfectSquareSum(12)\n    Sortie : 3\n   \n    Exemple :\n    minPerfectSquareSum(13)\n    Sortie : 2",
      "de": "Schreiben Sie eine Java-Funktion `public static int minPerfectSquareSum(int n)`, um das folgende Problem zu lösen:\nGegeben ist eine ganze Zahl n, geben Sie die minimale Anzahl von perfekten Quadratzahlen zurück, die sich zu n summieren.\n\n    @param n Die Ziel-Ganzzahl.\n    @return Die minimale Anzahl von perfekten Quadratzahlen.\n\n    Beispiel:\n    minPerfectSquareSum(12)\n    Ausgabe: 3\n\n    Beispiel:\n    minPerfectSquareSum(13)\n    Ausgabe: 2",
      "ha": "Rubuta aikin Java `public static int minPerfectSquareSum(int n)` don warware matsalar mai zuwa:\nAn ba da cikakken lamba n, dawo da mafi ƙarancin adadin lambobin murabba'i cikakke waɗanda suka haɗa zuwa n.\n   \n    @param n Manufar cikakken lamba.\n    @return Mafi ƙarancin adadin lambobin murabba'i cikakke.\n   \n    Misali:\n    minPerfectSquareSum(12)\n    Fitarwa: 3\n   \n    Misali:\n    minPerfectSquareSum(13)\n    Fitarwa: 2",
      "hi": "Java फ़ंक्शन `public static int minPerfectSquareSum(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के लिए, उन पूर्ण वर्ग संख्याओं की न्यूनतम संख्या लौटाएं जिनका योग n के बराबर हो।\n\n    @param n लक्ष्य पूर्णांक।\n    @return पूर्ण वर्ग संख्याओं की न्यूनतम संख्या।\n\n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n\n    Example:\n    minPerfectSquareSum(13)\n    Output: 2",
      "hu": "Írj egy Java függvényt `public static int minPerfectSquareSum(int n)` a következő probléma megoldására:\nAdott egy egész szám n, add vissza a legkisebb számú tökéletes négyzet számot, amelyek összege n.\n\n    @param n A cél egész szám.\n    @return A legkisebb számú tökéletes négyzet szám.\n\n    Példa:\n    minPerfectSquareSum(12)\n    Kimenet: 3\n\n    Példa:\n    minPerfectSquareSum(13)\n    Kimenet: 2"
    },
    "instruction_bertscore": {
      "sq": "0.9798098176589467",
      "hy": "0.9856207494561223",
      "bn": "0.9780932539060432",
      "bg": "1",
      "zh": "0.9582556404913268",
      "fr": "1",
      "de": "0.9793932897499166",
      "ha": "0.9878680535871511",
      "hi": "0.9452548847918314",
      "hu": "0.9736594265405825"
    },
    "level": "easy",
    "test": "  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minPerfectSquareSum",
    "signature": "public static int minPerfectSquareSum(int n)",
    "docstring": {
      "en": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2",
      "sq": "Duke pasur një numër të plotë n, kthe numrin minimal të numrave të katrorëve të përsosur që shuma e tyre është n.\n   \n    @param n Numri i plotë i synuar.\n    @return Numri minimal i numrave të katrorëve të përsosur.\n   \n    Shembull:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Shembull:\n    minPerfectSquareSum(13)\n    Output: 2",
      "hy": "Տրված է ամբողջ թիվ n, վերադարձնել նվազագույն քանակությամբ կատարյալ քառակուսի թվեր, որոնք գումարվում են n-ի:\n\n    @param n Նպատակային ամբողջ թիվը։\n    @return Կատարյալ քառակուսի թվերի նվազագույն քանակը։\n\n    Օրինակ:\n    minPerfectSquareSum(12)\n    Արդյունք: 3\n\n    Օրինակ:\n    minPerfectSquareSum(13)\n    Արդյունք: 2",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, n এর সমষ্টি হিসেবে ন্যূনতম সংখ্যক নিখুঁত বর্গ সংখ্যা ফেরত দিন।\n\n    @param n লক্ষ্য পূর্ণসংখ্যা।\n    @return ন্যূনতম সংখ্যক নিখুঁত বর্গ সংখ্যা।\n\n    উদাহরণ:\n    minPerfectSquareSum(12)\n    আউটপুট: 3\n\n    উদাহরণ:\n    minPerfectSquareSum(13)\n    আউটপুট: 2",
      "bg": "Като се даде цяло число n, върнете минималния брой перфектни квадратни числа, които се сумират до n.\n   \n    @param n Целевото цяло число.\n    @return Минималният брой перфектни квадратни числа.\n   \n    Пример:\n    minPerfectSquareSum(12)\n    Изход: 3\n   \n    Пример:\n    minPerfectSquareSum(13)\n    Изход: 2",
      "zh": "给定一个整数 n，返回其和为 n 的最少完全平方数的数量。\n\n    @param n 目标整数。\n    @return 完全平方数的最少数量。\n   \n    示例:\n    minPerfectSquareSum(12)\n    输出: 3\n   \n    示例:\n    minPerfectSquareSum(13)\n    输出: 2",
      "fr": "Étant donné un entier n, renvoyer le nombre minimum de nombres carrés parfaits qui s'additionnent pour donner n.\n   \n    @param n L'entier cible.\n    @return Le nombre minimum de nombres carrés parfaits.\n   \n    Exemple:\n    minPerfectSquareSum(12)\n    Sortie: 3\n   \n    Exemple:\n    minPerfectSquareSum(13)\n    Sortie: 2",
      "de": "Gegeben eine ganze Zahl n, gib die minimale Anzahl von perfekten Quadratzahlen zurück, die sich zu n summieren.\n\n    @param n Die Zielzahl.\n    @return Die minimale Anzahl von perfekten Quadratzahlen.\n   \n    Beispiel:\n    minPerfectSquareSum(12)\n    Ausgabe: 3\n   \n    Beispiel:\n    minPerfectSquareSum(13)\n    Ausgabe: 2",
      "ha": "An ba da wani lamba n, dawo da mafi ƙarancin adadin lambobin murabba'in cikakke waɗanda ke haɗuwa zuwa n.\n   \n    @param n Lambar manufa.\n    @return Mafi ƙarancin adadin lambobin murabba'in cikakke.\n   \n    Misali:\n    minPerfectSquareSum(12)\n    Fitarwa: 3\n   \n    Misali:\n    minPerfectSquareSum(13)\n    Fitarwa: 2",
      "hi": "दिए गए पूर्णांक n के लिए, उन संपूर्ण वर्ग संख्याओं की न्यूनतम संख्या लौटाएं जिनका योग n के बराबर होता है।\n\n    @param n लक्ष्य पूर्णांक।\n    @return संपूर्ण वर्ग संख्याओं की न्यूनतम संख्या।\n\n    उदाहरण:\n    minPerfectSquareSum(12)\n    आउटपुट: 3\n\n    उदाहरण:\n    minPerfectSquareSum(13)\n    आउटपुट: 2",
      "hu": "Adott egy egész szám n, add vissza a legkisebb számú tökéletes négyzet számot, amelyek összege n.\n\n    @param n A cél egész szám.\n    @return A legkisebb számú tökéletes négyzet szám.\n\n    Példa:\n    minPerfectSquareSum(12)\n    Kimenet: 3\n\n    Példa:\n    minPerfectSquareSum(13)\n    Kimenet: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9752742915383961",
      "hy": "0.9762446009497515",
      "bn": "0.9687681534075984",
      "bg": "0.9948600416299602",
      "zh": "0.9470731472998247",
      "fr": "0.999999801369619",
      "de": "0.9924460866092432",
      "ha": "0.962423899037344",
      "hi": "0.9366962989338001",
      "hu": "0.9628354611868483"
    }
  },
  {
    "task_id": "Java/53",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "sq": "public class Solution {\n\n  /**\n   * Kthen karakteret e secilës fjalë në vargun e dhënë duke ruajtur rendin origjinal të fjalëve.\n   *\n   * @param s Vargu hyrës që përmban fjalë të ndara me hapësira.\n   * @return Vargu me karakteret e secilës fjalë të kthyera.\n   *\n   * Shembull:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "hy": "public class Solution {\n\n  /**\n   * Շրջել տրված տողի յուրաքանչյուր բառի նիշերը՝ պահպանելով սկզբնական բառերի հերթականությունը։\n   *\n   * @param s Մուտքային տող, որը պարունակում է բառեր, որոնք բաժանված են բացատներով։\n   * @return Տող, որտեղ յուրաքանչյուր բառի նիշերը շրջված են։\n   *\n   * Օրինակ:\n   * reverseWords(\"Mr Ding\")\n   * Արդյունք: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "bn": "public class Solution {\n\n  /**\n   * প্রদত্ত স্ট্রিংয়ের প্রতিটি শব্দের অক্ষর উল্টে দিন, মূল শব্দের ক্রম বজায় রেখে।\n   *\n   * @param s ইনপুট স্ট্রিং যা স্পেস দ্বারা পৃথক শব্দগুলি ধারণ করে।\n   * @return স্ট্রিং যেখানে প্রতিটি শব্দের অক্ষর উল্টানো হয়েছে।\n   *\n   * উদাহরণ:\n   * reverseWords(\"Mr Ding\")\n   * আউটপুট: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "bg": "public class Solution {\n\n  /**\n   * Обърнете символите на всяка дума в дадения низ, като запазите оригиналния ред на думите.\n   *\n   * @param s Входният низ, съдържащ думи, разделени с интервали.\n   * @return Низът с обърнати символи на всяка дума.\n   *\n   * Пример:\n   * reverseWords(\"Mr Ding\")\n   * Изход: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "zh": "public class Solution {\n\n  /**\n   * 反转给定字符串中每个单词的字符，同时保持原有的单词顺序。\n   *\n   * @param s 输入字符串，包含由空格分隔的单词。\n   * @return 每个单词的字符反转后的字符串。\n   *\n   * 示例:\n   * reverseWords(\"Mr Ding\")\n   * 输出: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "fr": "public class Solution {\n\n  /**\n   * Inverser les caractères de chaque mot dans la chaîne donnée tout en conservant l'ordre original des mots.\n   *\n   * @param s La chaîne d'entrée contenant des mots séparés par des espaces.\n   * @return La chaîne avec les caractères de chaque mot inversés.\n   *\n   * Exemple :\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "de": "public class Solution {\n\n  /**\n   * Kehrt die Zeichen jedes Wortes in der gegebenen Zeichenkette um, während die ursprüngliche Wortreihenfolge beibehalten wird.\n   *\n   * @param s Die Eingabezeichenkette, die Wörter enthält, die durch Leerzeichen getrennt sind.\n   * @return Die Zeichenkette mit umgekehrten Zeichen jedes Wortes.\n   *\n   * Beispiel:\n   * reverseWords(\"Mr Ding\")\n   * Ausgabe: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "ha": "public class Solution {\n\n  /**\n   * Juya haruffan kowace kalma a cikin igiyar da aka bayar yayin da ake kiyaye tsarin kalmomi na asali.\n   *\n   * @param s Igiyar shigarwa mai dauke da kalmomi da aka raba ta wurin sarari.\n   * @return Igiyar da ke dauke da haruffan kowace kalma da aka juyar.\n   *\n   * Misali:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए स्ट्रिंग में प्रत्येक शब्द के अक्षरों को उल्टा करें जबकि मूल शब्द क्रम को बनाए रखें।\n   *\n   * @param s इनपुट स्ट्रिंग जिसमें शब्द स्पेस द्वारा अलग किए गए हैं।\n   * @return स्ट्रिंग जिसमें प्रत्येक शब्द के अक्षर उल्टे हैं।\n   *\n   * उदाहरण:\n   * reverseWords(\"Mr Ding\")\n   * आउटपुट: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "hu": "public class Solution {\n\n  /**\n   * Fordítsa meg az egyes szavak karaktereit a megadott sztringben, miközben megőrzi az eredeti szórendet.\n   *\n   * @param s A bemeneti sztring, amely szóközökkel elválasztott szavakat tartalmaz.\n   * @return A sztring, amelyben az egyes szavak karakterei meg vannak fordítva.\n   *\n   * Példa:\n   * reverseWords(\"Mr Ding\")\n   * Kimenet: \"rM gniD\"\n   */\n  public static String reverseWords(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9713926566322123",
      "hy": "0.9596311558799935",
      "bn": "0.969216462177594",
      "bg": "0.9800424138351386",
      "zh": "0.9725882128956613",
      "fr": "0.9848135155875966",
      "de": "0.9826716841888974",
      "ha": "0.9735849401476944",
      "hi": "0.9538716693515058",
      "hu": "0.9935888071913369"
    },
    "canonical_solution": "  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }",
    "instruction": {
      "en": "Write a Java function `public static String reverseWords(String s)` to solve the following problem:\nReverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "sq": "Shkruani një funksion Java `public static String reverseWords(String s)` për të zgjidhur problemin e mëposhtëm:\nPërmbysni karakteret e secilës fjalë në vargun e dhënë duke ruajtur rendin origjinal të fjalëve.\n   \n    @param s Vargu hyrës që përmban fjalë të ndara me hapësira.\n    @return Vargu me karakteret e secilës fjalë të përmbysura.\n   \n    Shembull:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "hy": "Գրեք Java ֆունկցիա `public static String reverseWords(String s)` հետևյալ խնդիրը լուծելու համար:\nՇրջել տրված տողի յուրաքանչյուր բառի նիշերը՝ պահպանելով սկզբնական բառերի հերթականությունը։\n   \n    @param s Մուտքային տողը, որը պարունակում է բառեր, որոնք բաժանված են բացատներով։\n    @return Տողը, որտեղ յուրաքանչյուր բառի նիշերը շրջված են։\n   \n    Օրինակ:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "bn": "একটি জাভা ফাংশন `public static String reverseWords(String s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত স্ট্রিং-এর প্রতিটি শব্দের অক্ষরগুলি উল্টান কিন্তু মূল শব্দের ক্রম বজায় রাখুন।\n\n    @param s শব্দগুলি স্পেস দ্বারা পৃথক করা ইনপুট স্ট্রিং।\n    @return প্রতিটি শব্দের অক্ষর উল্টানো স্ট্রিং।\n\n    উদাহরণ:\n    reverseWords(\"Mr Ding\")\n    আউটপুট: \"rM gniD\"",
      "bg": "Напишете Java функция `public static String reverseWords(String s)`, за да решите следния проблем:  \nОбърнете знаците на всяка дума в дадения низ, като запазите оригиналния ред на думите.\n   \n    @param s Входният низ, съдържащ думи, разделени с интервали.\n    @return Низът с обърнати знаци на всяка дума.\n   \n    Пример:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "zh": "编写一个 Java 函数 `public static String reverseWords(String s)` 来解决以下问题：\n反转给定字符串中每个单词的字符，同时保持原有的单词顺序。\n\n    @param s 输入字符串，包含由空格分隔的单词。\n    @return 每个单词的字符被反转后的字符串。\n\n    示例：\n    reverseWords(\"Mr Ding\")\n    输出: \"rM gniD\"",
      "fr": "Écrire une fonction Java `public static String reverseWords(String s)` pour résoudre le problème suivant :\nInverser les caractères de chaque mot dans la chaîne donnée tout en maintenant l'ordre original des mots.\n   \n    @param s La chaîne d'entrée contenant des mots séparés par des espaces.\n    @return La chaîne avec les caractères de chaque mot inversés.\n   \n    Exemple :\n    reverseWords(\"Mr Ding\")\n    Sortie : \"rM gniD\"",
      "de": "Schreiben Sie eine Java-Funktion `public static String reverseWords(String s)`, um das folgende Problem zu lösen:\nDrehen Sie die Zeichen jedes Wortes in der gegebenen Zeichenkette um, während die ursprüngliche Wortreihenfolge beibehalten wird.\n   \n    @param s Die Eingabezeichenkette, die Wörter enthält, die durch Leerzeichen getrennt sind.\n    @return Die Zeichenkette mit umgekehrten Zeichen jedes Wortes.\n   \n    Beispiel:\n    reverseWords(\"Mr Ding\")\n    Ausgabe: \"rM gniD\"",
      "ha": "Rubuta aikin Java `public static String reverseWords(String s)` don warware matsalar mai zuwa: \n\nJuya haruffan kowace kalma a cikin igiyar da aka bayar yayin da ake kiyaye tsarin kalmomin asali.\n\n    @param s Igiyar shigarwa da ke dauke da kalmomi da aka raba ta wurin sarari.\n    @return Igiyar da ke dauke da haruffan kowace kalma da aka juyar.\n\n    Misali:\n    reverseWords(\"Mr Ding\")\n    Fitarwa: \"rM gniD\"",
      "hi": "Java फ़ंक्शन `public static String reverseWords(String s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में प्रत्येक शब्द के अक्षरों को उल्टा करें जबकि मूल शब्द क्रम को बनाए रखें।\n\n    @param s इनपुट स्ट्रिंग जिसमें शब्द स्पेस द्वारा अलग किए गए हैं।\n    @return स्ट्रिंग जिसमें प्रत्येक शब्द के अक्षर उल्टे हैं।\n\n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "hu": "Írj egy Java függvényt `public static String reverseWords(String s)` a következő probléma megoldására:\nFordítsd meg az egyes szavak karaktereit a megadott szövegben, miközben megőrzöd az eredeti szórendet.\n   \n    @param s A bemeneti szöveg, amely szavakat tartalmaz szóközökkel elválasztva.\n    @return A szöveg, amelyben az egyes szavak karakterei meg vannak fordítva.\n   \n    Példa:\n    reverseWords(\"Mr Ding\")\n    Kimenet: \"rM gniD\""
    },
    "instruction_bertscore": {
      "sq": "0.9830059791201791",
      "hy": "0.9762785667449084",
      "bn": "0.9619281176062809",
      "bg": "0.9775349039049541",
      "zh": "0.9802976538747684",
      "fr": "0.9830059791201791",
      "de": "0.993891321261653",
      "ha": "0.9688472082992502",
      "hi": "0.9549575816446236",
      "hu": "0.9667228563740821"
    },
    "level": "middle",
    "test": "  public static void main(String[] args) {\n    testReverseWords(\"The quick brown fox\", \"ehT kciuq nworb xof\");\n    testReverseWords(\"Hello World\", \"olleH dlroW\");\n    testReverseWords(\"a b c d e f\", \"a b c d e f\");\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "reverseWords",
    "signature": "public static String reverseWords(String s)",
    "docstring": {
      "en": "Reverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "sq": "Kthe karakteret e secilës fjalë në vargun e dhënë duke ruajtur rendin origjinal të fjalëve.\n\n    @param s Vargu hyrës që përmban fjalë të ndara me hapësira.\n    @return Vargu me karakteret e secilës fjalë të kthyera.\n\n    Shembull:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "hy": "Շրջել տրված տողի յուրաքանչյուր բառի նիշերը՝ պահպանելով սկզբնական բառերի հերթականությունը։\n\n    @param s Մուտքային տողը, որը պարունակում է բառեր, բաժանված բացատներով։\n    @return Տողը, որտեղ յուրաքանչյուր բառի նիշերը շրջված են։\n\n    Օրինակ:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "bn": "প্রতিটি শব্দের অক্ষরগুলি উল্টে দিন প্রদত্ত স্ট্রিং-এ, মূল শব্দের ক্রম বজায় রেখে।\n\n    @param s শব্দগুলি স্পেস দ্বারা পৃথক করা ইনপুট স্ট্রিং।\n    @return প্রতিটি শব্দের অক্ষর উল্টানো স্ট্রিং।\n\n    উদাহরণ:\n    reverseWords(\"Mr Ding\")\n    আউটপুট: \"rM gniD\"",
      "bg": "Обърнете символите на всяка дума в дадения низ, като запазите оригиналния ред на думите.\n\n    @param s Входният низ, съдържащ думи, разделени с интервали.\n    @return Низът с обърнати символи на всяка дума.\n\n    Пример:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "zh": "将给定字符串中每个单词的字符反转，同时保持原始单词顺序。\n\n    @param s 输入字符串，其中包含以空格分隔的单词。\n    @return 字符反转后的字符串。\n   \n    示例:\n    reverseWords(\"Mr Ding\")\n    输出: \"rM gniD\"",
      "fr": "Inversez les caractères de chaque mot dans la chaîne donnée tout en conservant l'ordre original des mots.\n\n    @param s La chaîne d'entrée contenant des mots séparés par des espaces.\n    @return La chaîne avec les caractères de chaque mot inversés.\n   \n    Exemple:\n    reverseWords(\"Mr Ding\")\n    Sortie: \"rM gniD\"",
      "de": "Kehrt die Zeichen jedes Wortes in der gegebenen Zeichenkette um, während die ursprüngliche Wortreihenfolge beibehalten wird.\n\n    @param s Der Eingabestring, der Wörter enthält, die durch Leerzeichen getrennt sind.\n    @return Der String mit umgekehrten Zeichen jedes Wortes.\n   \n    Beispiel:\n    reverseWords(\"Mr Ding\")\n    Ausgabe: \"rM gniD\"",
      "ha": "Juya haruffan kowace kalma a cikin igiyar da aka bayar yayin da ake kiyaye tsarin kalmomi na asali.\n\n    @param s Kalmomin da aka shigar a cikin igiyar rubutu da aka raba su da sarari.\n    @return Igiyar rubutu tare da haruffan kowace kalma an juyasu baya.\n\n    Misali:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "hi": "प्रत्येक शब्द के वर्णों को उलटें लेकिन मूल शब्द क्रम को बनाए रखें।\n\n    @param s इनपुट स्ट्रिंग जिसमें शब्द स्पेस द्वारा अलग किए गए हैं।\n    @return स्ट्रिंग जिसमें प्रत्येक शब्द के वर्ण उलटे हुए हैं।\n\n    उदाहरण:\n    reverseWords(\"Mr Ding\")\n    आउटपुट: \"rM gniD\"",
      "hu": "Fordítsa meg az egyes szavak karaktereit a megadott szövegben, miközben megőrzi az eredeti szórendet.\n   \n    @param s A bemeneti szöveg, amely szóközökkel elválasztott szavakat tartalmaz.\n    @return A szöveg, amelyben az egyes szavak karakterei meg vannak fordítva.\n   \n    Példa:\n    reverseWords(\"Mr Ding\")\n    Kimenet: \"rM gniD\""
    },
    "docstring_bertscore": {
      "sq": "0.980323873085065",
      "hy": "0.9860392636689629",
      "bn": "0.9557129729836993",
      "bg": "0.9804698664151257",
      "zh": "0.971049423333784",
      "fr": "0.980323873085065",
      "de": "0.9920754423182321",
      "ha": "0.9273670271973534",
      "hi": "0.927199581786141",
      "hu": "0.9487851425539644"
    }
  }
]