{"task_id": "Python/1", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n```"}
{"task_id": "Python/1", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) <= threshold:\n                return True\n    return False\n```"}
{"task_id": "Python/1", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False\n```"}
{"task_id": "Python/1", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/1", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    numbers_sorted = sorted(numbers)\n    for i in range(len(numbers_sorted) - 1):\n        if abs(numbers_sorted[i] - numbers_sorted[i + 1]) < threshold:\n            return True\n    return False\n```"}
{"task_id": "Python/2", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current = []\n    balance = 0\n    \n    for char in paren_string:\n        current.append(char)\n        if char == '(':\n            balance += 1\n        else:\n            balance -= 1\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = []\n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            if not stack:\n                current_group = []\n            stack.append(char)\n            current_group.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                current_group.append(char)\n                if not stack:\n                    result.append(''.join(current_group))\n    return result\n```"}
{"task_id": "Python/2", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == '(':\n            balance += 1\n            current.append(char)\n        elif char == ')':\n            balance -= 1\n            current.append(char)\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current.append(char)\n        elif char == ')':\n            balance -= 1\n            current.append(char)\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current.append(char)\n        elif char == ')':\n            balance -= 1\n            current.append(char)\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current.append(char)\n        elif char == ')':\n            balance -= 1\n            current.append(char)\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current_group = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current_group.append(char)\n        elif char == ')':\n            balance -= 1\n            current_group.append(char)\n            if balance == 0:\n                result.append(''.join(current_group))\n                current_group = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    current = []\n    balance = 0\n    \n    for char in paren_string:\n        if char == ' ':\n            continue\n        if char == '(':\n            balance += 1\n            current.append(char)\n        elif char == ')':\n            balance -= 1\n            current.append(char)\n            if balance == 0:\n                result.append(''.join(current))\n                current = []\n    \n    return result\n```"}
{"task_id": "Python/2", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    result = []\n    stack = []\n    current_group = []\n    for char in paren_string.replace(\" \", \"\"):\n        if char == '(':\n            stack.append(char)\n            current_group.append(char)\n        elif char == ')':\n            stack.pop()\n            current_group.append(char)\n            if not stack:\n                result.append(''.join(current_group))\n                current_group = []\n    return result\n```"}
{"task_id": "Python/3", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\nimport math\n\ndef truncate_number(number: float) -> float:\n    return number - math.floor(number)\n```"}
{"task_id": "Python/3", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\nimport math\n\ndef truncate_number(number: float) -> float:\n    return number - math.floor(number)\n```"}
{"task_id": "Python/3", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\nimport math\n\ndef truncate_number(number: float) -> float:\n    return number - math.floor(number)\n```"}
{"task_id": "Python/3", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\nimport math\n\ndef truncate_number(number: float) -> float:\n    return number - math.floor(number)\n```"}
{"task_id": "Python/3", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/3", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\ndef truncate_number(number: float) -> float:\n    return number - int(number)\n```"}
{"task_id": "Python/4", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/4", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False\n```"}
{"task_id": "Python/5", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    return sum(absolute_differences) / len(absolute_differences)\n```"}
{"task_id": "Python/5", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n```"}
{"task_id": "Python/5", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n```"}
{"task_id": "Python/5", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)\n```"}
{"task_id": "Python/5", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(numbers)\n```"}
{"task_id": "Python/5", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(x - mean) for x in numbers]\n    return sum(absolute_deviations) / len(numbers)\n```"}
{"task_id": "Python/6", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/6", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```"}
{"task_id": "Python/7", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # carpets are numbered from 1 to n\n    return topmost\n```"}
{"task_id": "Python/7", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point):\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # since carpets are 1-indexed in the output\n    return topmost\n```"}
{"task_id": "Python/7", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point):\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x < a + g and b <= y < b + k:\n            topmost = i + 1\n    return topmost\n```"}
{"task_id": "Python/7", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # assuming carpets are numbered from 1 to n\n    return topmost\n```"}
{"task_id": "Python/7", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # carpets are 1-indexed in the return value\n    return topmost\n```"}
{"task_id": "Python/7", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # 1-based index\n    return topmost\n```"}
{"task_id": "Python/7", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x < a + g and b <= y < b + k:\n            topmost = i + 1  # assuming carpets are numbered from 1 to n\n    return topmost\n```"}
{"task_id": "Python/7", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # Teppiche sind 1-basiert\n    return topmost\n```"}
{"task_id": "Python/7", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1\n    return topmost\n```"}
{"task_id": "Python/7", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point):\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # assuming carpets are numbered from 1 to n\n    return topmost\n```"}
{"task_id": "Python/7", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1\n    return topmost\n```"}
{"task_id": "Python/7", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x < a + g and b <= y < b + k:\n            topmost = i + 1  # carpets are 1-indexed in the output\n    return topmost\n```"}
{"task_id": "Python/7", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point):\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1\n    return topmost\n```"}
{"task_id": "Python/7", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x < a + g and b <= y < b + k:\n            topmost = i + 1  # carpets are 1-indexed in the return value\n    return topmost\n```"}
{"task_id": "Python/7", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point):\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g and b <= y <= b + k:\n            topmost = i + 1  # assuming carpets are numbered from 1 to n\n    return topmost\n```"}
{"task_id": "Python/7", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_topmost_carpet(n, carpets, point):\n    x, y = point\n    topmost = -1\n    for i in range(n):\n        a, b, g, k = carpets[i]\n        if a <= x <= a + g - 1 and b <= y <= b + k - 1:\n            topmost = i + 1  # since carpets are 1-indexed in the output\n    return topmost\n```"}
{"task_id": "Python/8", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x-1][y-1] = val  # assuming 1-based to 0-based conversion\n    \n    # DP table: dp[k][i1][i2] represents the maximum value when two paths are at (i1, k-i1) and (i2, k-i2)\n    # Using a 2D array since k can be derived from i1 and i2 (i1 + j1 = i2 + j2 = k)\n    dp_prev = [[-1 for _ in range(N)] for __ in range(N)]\n    dp_prev[0][0] = grid[0][0]\n    \n    for step in range(1, 2*N - 1):\n        dp_current = [[-1 for _ in range(N)] for __ in range(N)]\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = step - i1\n                j2 = step - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                if grid[i1][j1] == 0 or grid[i2][j2] == 0:\n                    continue\n                max_val = -1\n                # Check all possible previous positions\n                for pi1 in [i1, i1-1]:\n                    for pi2 in [i2, i2-1]:\n                        if pi1 >= 0 and pi2 >= 0 and (step - 1 - pi1) >= 0 and (step - 1 - pi2) >= 0:\n                            if (step - 1 - pi1) < N and (step - 1 - pi2) < N:\n                                if dp_prev[pi1][pi2] != -1:\n                                    current_val = dp_prev[pi1][pi2]\n                                    if i1 == i2:\n                                        total = current_val + grid[i1][j1]\n                                    else:\n                                        total = current_val + grid[i1][j1] + grid[i2][j2]\n                                    if total > max_val:\n                                        max_val = total\n                if max_val != -1:\n                    dp_current[i1][i2] = max_val\n        dp_prev = dp_current\n    \n    return dp_prev[N-1][N-1] if dp_prev[N-1][N-1] != -1 else 0\n```"}
{"task_id": "Python/8", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x][y] = val\n    \n    # DP table: dp[i1][j1][i2][j2] represents the maximum value when two paths are at (i1,j1) and (i2,j2)\n    # Since i1 + j1 = i2 + j2, we can reduce the dimension to 3D using step s = i1 + j1 = i2 + j2\n    max_step = 2 * N - 1\n    dp = [[[ -1 for _ in range(N + 1)] for __ in range(N + 1)] for ___ in range(N + 1)]\n    dp[1][1][1] = grid[1][1]\n    \n    for s in range(3, 2 * N + 1):\n        for i1 in range(1, N + 1):\n            for i2 in range(1, N + 1):\n                j1 = s - i1\n                j2 = s - i2\n                if j1 < 1 or j1 > N or j2 < 1 or j2 > N:\n                    continue\n                current_max = -1\n                # Possible previous positions\n                for pi1 in [i1 - 1, i1]:\n                    for pi2 in [i2 - 1, i2]:\n                        pj1 = (s - 1) - pi1\n                        pj2 = (s - 1) - pi2\n                        if pj1 < 1 or pj1 > N or pj2 < 1 or pj2 > N:\n                            continue\n                        if dp[pi1][pi2][pj1] == -1:\n                            continue\n                        value = dp[pi1][pi2][pj1]\n                        if i1 == i2 and j1 == j2:\n                            value += grid[i1][j1]\n                        else:\n                            value += grid[i1][j1] + grid[i2][j2]\n                        if value > current_max:\n                            current_max = value\n                if current_max != -1:\n                    if i1 not in dp:\n                        dp[i1] = {}\n                    if i2 not in dp[i1]:\n                        dp[i1][i2] = {}\n                    dp[i1][i2][j1] = current_max\n    \n    return dp[N][N][N] if N > 0 else 0\n```"}
{"task_id": "Python/8", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x-1][y-1] = val\n    \n    # DP table: dp[k][i1][i2] represents the maximum value when two paths are at (i1, k-i1) and (i2, k-i2)\n    dp = [[[ -1 for _ in range(N) ] for __ in range(N)] for ___ in range(2*N - 1)]\n    \n    # Initialize the first step\n    dp[0][0][0] = grid[0][0]\n    \n    for k in range(1, 2*N - 1):\n        for i1 in range(max(0, k - (N - 1)), min(N, k + 1)):\n            for i2 in range(max(0, k - (N - 1)), min(N, k + 1)):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                \n                max_val = -1\n                # Possible previous positions\n                for pi1 in [i1, i1 - 1]:\n                    for pi2 in [i2, i2 - 1]:\n                        if pi1 >= 0 and pi2 >= 0 and (k-1) - pi1 >= 0 and (k-1) - pi2 >= 0:\n                            if dp[k-1][pi1][pi2] > max_val:\n                                max_val = dp[k-1][pi1][pi2]\n                \n                if max_val == -1:\n                    continue\n                \n                if i1 == i2:\n                    current = grid[i1][j1]\n                else:\n                    current = grid[i1][j1] + grid[i2][j2]\n                \n                dp[k][i1][i2] = max_val + current\n    \n    result = dp[2*N - 2][N-1][N-1]\n    return result if result != -1 else 0\n```"}
{"task_id": "Python/8", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break  # assuming the last tuple is (0,0,0)\n        grid[x][y] = val\n    \n    # DP table: dp[i1][j1][i2][j2] represents the max value when two paths are at (i1,j1) and (i2,j2)\n    dp = [[[[-1 for _ in range(N)] for _ in range(N)] for _ in range(N)] for _ in range(N)]\n    \n    # Base case: both paths start at (0,0)\n    dp[0][0][0][0] = grid[0][0]\n    \n    max_sum = 0\n    \n    for i1 in range(N):\n        for j1 in range(N):\n            for i2 in range(N):\n                for j2 in range(N):\n                    current = dp[i1][j1][i2][j2]\n                    if current == -1:\n                        continue\n                    # Update max_sum if any path reaches the end\n                    if (i1 == N-1 and j1 == N-1) or (i2 == N-1 and j2 == N-1):\n                        max_sum = max(max_sum, current)\n                        continue\n                    # Possible moves for path1 and path2\n                    # Path1 moves right or down\n                    for di1, dj1 in [(0, 1), (1, 0)]:\n                        new_i1 = i1 + di1\n                        new_j1 = j1 + dj1\n                        if new_i1 >= N or new_j1 >= N:\n                            continue\n                        # Path2 moves right or down\n                        for di2, dj2 in [(0, 1), (1, 0)]:\n                            new_i2 = i2 + di2\n                            new_j2 = j2 + dj2\n                            if new_i2 >= N or new_j2 >= N:\n                                continue\n                            # Calculate the new value\n                            if new_i1 == new_i2 and new_j1 == new_j2:\n                                added_value = grid[new_i1][new_j1]\n                            else:\n                                added_value = grid[new_i1][new_j1] + grid[new_i2][new_j2]\n                            # Update DP table\n                            if dp[new_i1][new_j1][new_i2][new_j2] < current + added_value:\n                                dp[new_i1][new_j1][new_i2][new_j2] = current + added_value\n    return max_sum\n```"}
{"task_id": "Python/8", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x-1][y-1] = val  # assuming 1-based to 0-based conversion\n    \n    # DP table: dp[k][i1][i2] represents the max value when two paths are at (i1, k-i1) and (i2, k-i2)\n    max_steps = 2 * N - 2\n    dp = [[[ -1 for _ in range(N)] for __ in range(N)] for ___ in range(max_steps + 1)]\n    dp[0][0][0] = grid[0][0]\n    \n    for k in range(1, max_steps + 1):\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                current_max = -1\n                # Check all possible previous positions\n                for pi1 in [i1, i1-1]:\n                    for pi2 in [i2, i2-1]:\n                        if pi1 >= 0 and pi2 >= 0 and (k-1) - pi1 >= 0 and (k-1) - pi2 >= 0:\n                            if (k-1) - pi1 < N and (k-1) - pi2 < N:\n                                if dp[k-1][pi1][pi2] > current_max:\n                                    current_max = dp[k-1][pi1][pi2]\n                if current_max == -1:\n                    continue\n                if i1 == i2:\n                    total = current_max + grid[i1][j1]\n                else:\n                    total = current_max + grid[i1][j1] + grid[i2][j2]\n                dp[k][i1][i2] = total\n    \n    result = dp[max_steps][N-1][N-1]\n    return result if result != -1 else 0\n```"}
{"task_id": "Python/8", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            break\n        grid[x][y] = val\n    \n    # DP table: dp[i1][j1][i2][j2] represents the max value when two paths are at (i1,j1) and (i2,j2)\n    # Since i1 + j1 = i2 + j2 = k, we can reduce the dimension to 3D: dp[k][i1][i2]\n    max_step = 2 * (N - 1)\n    dp = [[[ -1 for _ in range(N)] for __ in range(N)] for ___ in range(max_step + 1)]\n    dp[0][0][0] = grid[0][0]\n    \n    for k in range(1, max_step + 1):\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                current_max = -1\n                # Possible previous positions\n                for pi1 in [i1, i1 - 1]:\n                    pj1 = (k - 1) - pi1\n                    if pi1 < 0 or pj1 < 0 or pi1 >= N or pj1 >= N:\n                        continue\n                    for pi2 in [i2, i2 - 1]:\n                        pj2 = (k - 1) - pi2\n                        if pi2 < 0 or pj2 < 0 or pi2 >= N or pj2 >= N:\n                            continue\n                        if dp[k-1][pi1][pi2] == -1:\n                            continue\n                        value = dp[k-1][pi1][pi2]\n                        if i1 == i2 and j1 == j2:\n                            value += grid[i1][j1]\n                        else:\n                            value += grid[i1][j1] + grid[i2][j2]\n                        if value > current_max:\n                            current_max = value\n                dp[k][i1][i2] = current_max\n    \n    return dp[max_step][N-1][N-1]\n```"}
{"task_id": "Python/8", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x][y] = val\n    \n    # DP table: dp[k][i1][i2] represents the maximum value collected when two paths are at (i1, k-i1) and (i2, k-i2)\n    dp = [[[ -1 for _ in range(N + 1)] for __ in range(N + 1)] for ___ in range(2 * N + 1)]\n    dp[2][1][1] = grid[1][1]\n    \n    for k in range(3, 2 * N + 1):\n        for i1 in range(1, N + 1):\n            for i2 in range(1, N + 1):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 1 or j1 > N or j2 < 1 or j2 > N:\n                    continue\n                max_val = -1\n                # Possible previous positions\n                for a in [i1 - 1, i1]:\n                    for b in [i2 - 1, i2]:\n                        if a >= 1 and (k-1)-a >= 1 and b >= 1 and (k-1)-b >= 1:\n                            if dp[k-1][a][b] > max_val:\n                                max_val = dp[k-1][a][b]\n                if max_val == -1:\n                    continue\n                if i1 == i2:\n                    current = grid[i1][j1]\n                else:\n                    current = grid[i1][j1] + grid[i2][j2]\n                dp[k][i1][i2] = max_val + current\n    \n    return dp[2 * N][N][N]\n```"}
{"task_id": "Python/8", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            break\n        grid[x-1][y-1] = val  # assuming 1-based input coordinates\n    \n    # DP table: dp[i1][j1][i2][j2] represents the max value when path1 is at (i1,j1) and path2 at (i2,j2)\n    dp = [[[[-1 for _ in range(N)] for _ in range(N)] for _ in range(N)] for _ in range(N)]\n    \n    # Base case: both paths start at (0,0)\n    dp[0][0][0][0] = grid[0][0]\n    \n    max_sum = 0\n    \n    for i1 in range(N):\n        for j1 in range(N):\n            for i2 in range(N):\n                for j2 in range(N):\n                    current = dp[i1][j1][i2][j2]\n                    if current == -1:\n                        continue\n                    # Update max_sum if both paths reach the end\n                    if i1 == N-1 and j1 == N-1 and i2 == N-1 and j2 == N-1:\n                        max_sum = max(max_sum, current)\n                        continue\n                    # Possible moves for path1 and path2: right or down\n                    moves = [(0, 1), (1, 0)]\n                    for di1, dj1 in moves:\n                        new_i1 = i1 + di1\n                        new_j1 = j1 + dj1\n                        if new_i1 >= N or new_j1 >= N:\n                            continue\n                        for di2, dj2 in moves:\n                            new_i2 = i2 + di2\n                            new_j2 = j2 + dj2\n                            if new_i2 >= N or new_j2 >= N:\n                                continue\n                            # Calculate the value to add\n                            if new_i1 == new_i2 and new_j1 == new_j2:\n                                added_value = grid[new_i1][new_j1]\n                            else:\n                                added_value = grid[new_i1][new_j1] + grid[new_i2][new_j2]\n                            # Update DP table\n                            if dp[new_i1][new_j1][new_i2][new_j2] < current + added_value:\n                                dp[new_i1][new_j1][new_i2][new_j2] = current + added_value\n    return max_sum\n```"}
{"task_id": "Python/8", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            break\n        grid[x-1][y-1] = val  # assuming 1-based to 0-based conversion\n    \n    # DP table: dp[k][i1][i2] represents the max value when two paths are at (i1, k-i1) and (i2, k-i2)\n    # Using a 2D array since k can be derived from i1 and i2 (i1 + j1 = i2 + j2 = k)\n    max_step = 2 * (N - 1)\n    dp_prev = [[-1 for _ in range(N)] for __ in range(N)]\n    dp_prev[0][0] = grid[0][0]\n    \n    for step in range(1, max_step + 1):\n        dp_current = [[-1 for _ in range(N)] for __ in range(N)]\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = step - i1\n                j2 = step - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                current_max = -1\n                # Check all possible previous positions\n                for pi1 in [i1, i1 - 1]:\n                    for pi2 in [i2, i2 - 1]:\n                        if pi1 >= 0 and pi2 >= 0 and (step - 1 - pi1) >= 0 and (step - 1 - pi2) >= 0:\n                            if (step - 1 - pi1) < N and (step - 1 - pi2) < N:\n                                if dp_prev[pi1][pi2] > current_max:\n                                    current_max = dp_prev[pi1][pi2]\n                if current_max == -1:\n                    continue\n                if i1 == i2:\n                    total = current_max + grid[i1][j1]\n                else:\n                    total = current_max + grid[i1][j1] + grid[i2][j2]\n                dp_current[i1][i2] = total\n        dp_prev = dp_current\n    \n    return dp_prev[N-1][N-1] if dp_prev[N-1][N-1] != -1 else 0\n```"}
{"task_id": "Python/8", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x-1][y-1] = val  # assuming 1-based to 0-based conversion\n    \n    # DP table: dp[k][i1][i2] represents the maximum value when two paths are at (i1, k-i1) and (i2, k-i2)\n    # Since k = i1 + j1 = i2 + j2, we can use k to represent the sum of coordinates\n    max_k = 2 * (N - 1)\n    dp = [[[ -1 for _ in range(N)] for __ in range(N)] for ___ in range(max_k + 1)]\n    \n    # Initialize the starting point\n    dp[0][0][0] = grid[0][0]\n    \n    for k in range(1, max_k + 1):\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                current_max = -1\n                # Possible previous positions\n                for pi1 in [i1, i1 - 1]:\n                    for pi2 in [i2, i2 - 1]:\n                        if pi1 >= 0 and pi1 < N and (k-1 - pi1) >= 0 and (k-1 - pi1) < N and \\\n                           pi2 >= 0 and pi2 < N and (k-1 - pi2) >= 0 and (k-1 - pi2) < N:\n                            if dp[k-1][pi1][pi2] > current_max:\n                                current_max = dp[k-1][pi1][pi2]\n                if current_max == -1:\n                    continue\n                if i1 == i2 and j1 == j2:\n                    added_value = grid[i1][j1]\n                else:\n                    added_value = grid[i1][j1] + grid[i2][j2]\n                dp[k][i1][i2] = current_max + added_value\n    \n    return dp[max_k][N-1][N-1]\n```"}
{"task_id": "Python/8", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            break\n        grid[x][y] = val\n    \n    # The DP table will track the maximum value for two paths at positions (i1, j1) and (i2, j2)\n    # We use steps i1 + j1 = i2 + j2 = s to reduce the dimension\n    dp = [[[ -1 for _ in range(N)] for __ in range(N)] for ___ in range(N)]\n    dp[0][0][0] = grid[0][0]\n    \n    max_sum = 0\n    for s in range(2 * N - 1):\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = s - i1\n                j2 = s - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                if dp[i1][i2][s - i1 - i2] == -1:\n                    continue\n                current = dp[i1][i2][s - i1 - i2]\n                # Try moving both paths to the right, down, or combinations\n                # Possible moves: (right, right), (right, down), (down, right), (down, down)\n                for di1, dj1 in [(0, 1), (1, 0)]:\n                    new_i1 = i1 + di1\n                    new_j1 = j1 + dj1\n                    if new_i1 >= N or new_j1 >= N:\n                        continue\n                    for di2, dj2 in [(0, 1), (1, 0)]:\n                        new_i2 = i2 + di2\n                        new_j2 = j2 + dj2\n                        if new_i2 >= N or new_j2 >= N:\n                            continue\n                        new_s = new_i1 + new_j1\n                        if new_s != new_i2 + new_j2:\n                            continue  # Ensure both paths are at the same step\n                        if new_i1 == new_i2 and new_j1 == new_j2:\n                            added = grid[new_i1][new_j1]\n                        else:\n                            added = grid[new_i1][new_j1] + grid[new_i2][new_j2]\n                        if dp[new_i1][new_i2][new_s - new_i1 - new_i2] < current + added:\n                            dp[new_i1][new_i2][new_s - new_i1 - new_i2] = current + added\n                            if new_i1 == N - 1 and new_j1 == N - 1 and new_i2 == N - 1 and new_j2 == N - 1:\n                                if dp[new_i1][new_i2][new_s - new_i1 - new_i2] > max_sum:\n                                    max_sum = dp[new_i1][new_i2][new_s - new_i1 - new_i2]\n    return max_sum\n```"}
{"task_id": "Python/8", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x][y] = val\n    \n    # DP table: dp[k][i1][i2] represents the maximum value when two paths are at (i1, k-i1) and (i2, k-i2)\n    dp = [[[ -1 for _ in range(N + 1)] for __ in range(N + 1)] for ___ in range(2 * N + 1)]\n    dp[2][1][1] = grid[1][1]\n    \n    for k in range(3, 2 * N + 1):\n        for i1 in range(1, N + 1):\n            for i2 in range(1, N + 1):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 1 or j1 > N or j2 < 1 or j2 > N:\n                    continue\n                current_max = -1\n                # Possible previous positions\n                for pi1 in [i1 - 1, i1]:\n                    pj1 = (k - 1) - pi1\n                    if pj1 < 1 or pj1 > N or pi1 < 1 or pi1 > N:\n                        continue\n                    for pi2 in [i2 - 1, i2]:\n                        pj2 = (k - 1) - pi2\n                        if pj2 < 1 or pj2 > N or pi2 < 1 or pi2 > N:\n                            continue\n                        if dp[k-1][pi1][pi2] == -1:\n                            continue\n                        value = dp[k-1][pi1][pi2]\n                        if i1 == i2:\n                            value += grid[i1][j1]\n                        else:\n                            value += grid[i1][j1] + grid[i2][j2]\n                        if value > current_max:\n                            current_max = value\n                dp[k][i1][i2] = current_max if current_max != -1 else -1\n    \n    return dp[2 * N][N][N]\n```"}
{"task_id": "Python/8", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0:\n            break\n        grid[x][y] = val\n    \n    # DP table: dp[k][i1][i2] represents the maximum value when two paths are at (i1, k-i1) and (i2, k-i2)\n    max_steps = 2 * N - 1\n    dp = [[[ -1 for _ in range(N + 1)] for __ in range(N + 1)] for ___ in range(max_steps + 1)]\n    dp[1][1][1] = grid[1][1]\n    \n    for k in range(1, max_steps):\n        for i1 in range(1, N + 1):\n            for i2 in range(1, N + 1):\n                if dp[k][i1][i2] == -1:\n                    continue\n                current_val = dp[k][i1][i2]\n                j1 = k + 1 - i1\n                j2 = k + 1 - i2\n                \n                # Possible moves: right or down for both paths\n                moves = [(0, 1), (1, 0)]\n                for di1, dj1 in moves:\n                    new_i1 = i1 + di1\n                    new_j1 = j1 + dj1\n                    if new_i1 > N or new_j1 > N:\n                        continue\n                    for di2, dj2 in moves:\n                        new_i2 = i2 + di2\n                        new_j2 = j2 + dj2\n                        if new_i2 > N or new_j2 > N:\n                            continue\n                        new_k = new_i1 + new_j1 - 1\n                        if new_i1 == new_i2 and new_j1 == new_j2:\n                            added_val = grid[new_i1][new_j1]\n                        else:\n                            added_val = grid[new_i1][new_j1] + grid[new_i2][new_j2]\n                        if dp[new_k][new_i1][new_i2] < current_val + added_val:\n                            dp[new_k][new_i1][new_i2] = current_val + added_val\n    \n    return dp[max_steps][N][N]\n```"}
{"task_id": "Python/8", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Create the grid\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            continue\n        grid[x-1][y-1] = val  # assuming 1-based to 0-based conversion\n    \n    # Directions: right or down\n    directions = [(0, 1), (1, 0)]\n    \n    max_sum = 0\n    \n    from itertools import product\n    \n    # Generate all possible paths for two paths\n    # Each path is a sequence of moves (right or down) from (0,0) to (N-1, N-1)\n    # Total moves: 2*(N-1) steps per path\n    \n    # Helper to generate all paths\n    def generate_paths():\n        path_moves = []\n        # Each path has exactly 2N-2 steps with N-1 rights and N-1 downs\n        # Generate all combinations\n        from itertools import combinations\n        total_steps = 2 * (N - 1)\n        rights = N - 1\n        indices = list(range(total_steps))\n        for combo in combinations(indices, rights):\n            path = []\n            step = 0\n            x, y = 0, 0\n            for i in range(total_steps):\n                if i in combo:\n                    move = (0, 1)  # right\n                else:\n                    move = (1, 0)  # down\n                path.append(move)\n            path_moves.append(path)\n        return path_moves\n    \n    # Alternative approach: DFS for paths\n    paths = []\n    def dfs(x, y, path, current_path):\n        if x == N - 1 and y == N - 1:\n            paths.append(current_path.copy())\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if nx < N and ny < N:\n                current_path.append((dx, dy))\n                dfs(nx, ny, path, current_path)\n                current_path.pop()\n    \n    dfs(0, 0, [], [])\n    \n    if not paths:\n        return 0\n    \n    max_total = 0\n    \n    # Check all pairs of paths\n    for path1 in paths:\n        for path2 in paths:\n            visited = set()\n            total = 0\n            x1, y1 = 0, 0\n            x2, y2 = 0, 0\n            # Add starting points\n            if (x1, y1) not in visited:\n                visited.add((x1, y1))\n                total += grid[x1][y1]\n            if (x2, y2) not in visited:\n                visited.add((x2, y2))\n                total += grid[x2][y2]\n            # Follow path1\n            for dx, dy in path1:\n                x1 += dx\n                y1 += dy\n                if (x1, y1) not in visited:\n                    visited.add((x1, y1))\n                    total += grid[x1][y1]\n            # Follow path2\n            for dx, dy in path2:\n                x2 += dx\n                y2 += dy\n                if (x2, y2) not in visited:\n                    visited.add((x2, y2))\n                    total += grid[x2][y2]\n            if total > max_total:\n                max_total = total\n    return max_total\n```"}
{"task_id": "Python/8", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            break\n        grid[x][y] = val\n    \n    # DP table: dp[i1][j1][i2][j2] represents the max value when two paths are at (i1,j1) and (i2,j2)\n    # Since both paths move only right or down, i1 + j1 = i2 + j2 = k (step)\n    # We can optimize space by using k, i1, i2 (since j1 = k - i1, j2 = k - i2)\n    max_step = 2 * (N - 1)\n    dp = [[[ -1 for _ in range(N) ] for __ in range(N)] for ___ in range(max_step + 1)]\n    \n    # Base case: both paths start at (0,0)\n    dp[0][0][0] = grid[0][0]\n    \n    for k in range(1, max_step + 1):\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                current_max = -1\n                # Possible previous positions for path1: (i1-1, j1) or (i1, j1-1)\n                # Possible previous positions for path2: (i2-1, j2) or (i2, j2-1)\n                for pi1 in [i1, i1 - 1]:\n                    pj1 = (k - 1) - pi1\n                    if pi1 < 0 or pj1 < 0 or pi1 >= N or pj1 >= N:\n                        continue\n                    for pi2 in [i2, i2 - 1]:\n                        pj2 = (k - 1) - pi2\n                        if pi2 < 0 or pj2 < 0 or pi2 >= N or pj2 >= N:\n                            continue\n                        if dp[k-1][pi1][pi2] == -1:\n                            continue\n                        value = dp[k-1][pi1][pi2]\n                        if i1 == i2 and j1 == j2:\n                            value += grid[i1][j1]\n                        else:\n                            value += grid[i1][j1] + grid[i2][j2]\n                        if value > current_max:\n                            current_max = value\n                dp[k][i1][i2] = current_max if current_max != -1 else -1\n    \n    return dp[max_step][N-1][N-1]\n```"}
{"task_id": "Python/8", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\nfrom typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(N)] for _ in range(N)]\n    for x, y, val in grid_values:\n        if x == 0 and y == 0 and val == 0:\n            break\n        grid[x-1][y-1] = val  # assuming 1-based to 0-based conversion\n    \n    # DP table: dp[k][i1][i2] represents the maximum value when two paths are at (i1, k-i1) and (i2, k-i2)\n    dp = [[[ -1 for _ in range(N)] for __ in range(N)] for ___ in range(2*N -1)]\n    \n    # Initialize the first step (k=0, both paths at (0,0))\n    dp[0][0][0] = grid[0][0]\n    \n    for k in range(1, 2*N -1):\n        for i1 in range(N):\n            for i2 in range(N):\n                j1 = k - i1\n                j2 = k - i2\n                if j1 < 0 or j1 >= N or j2 < 0 or j2 >= N:\n                    continue\n                max_val = -1\n                # Check all possible previous positions\n                for pi1 in [i1, i1-1]:\n                    for pi2 in [i2, i2-1]:\n                        if pi1 >= 0 and pi2 >= 0 and (k-1) - pi1 >= 0 and (k-1) - pi2 >= 0:\n                            prev_j1 = (k-1) - pi1\n                            prev_j2 = (k-1) - pi2\n                            if prev_j1 < N and prev_j2 < N and dp[k-1][pi1][pi2] != -1:\n                                current_val = dp[k-1][pi1][pi2]\n                                if i1 == i2:\n                                    added_val = grid[i1][j1]\n                                else:\n                                    added_val = grid[i1][j1] + grid[i2][j2]\n                                if current_val + added_val > max_val:\n                                    max_val = current_val + added_val\n                if max_val != -1:\n                    dp[k][i1][i2] = max_val\n    \n    result = dp[2*N -2][N-1][N-1] if dp[2*N -2][N-1][N-1] != -1 else 0\n    return result\n```"}
{"task_id": "Python/9", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 333):\n        second = 2 * first\n        third = 3 * first\n        if third > 987:\n            continue\n        digits = set()\n        valid = True\n        for num in (first, second, third):\n            for d in str(num):\n                if d == '0' or d in digits:\n                    valid = False\n                    break\n                digits.add(d)\n            if not valid:\n                break\n        if valid and len(digits) == 9:\n            combinations.append((first, second, third))\n    return sorted(combinations)\n```"}
{"task_id": "Python/9", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 333):\n        second = 2 * first\n        third = 3 * first\n        if third > 999:\n            continue\n        digits = set(str(first) + str(second) + str(third))\n        if len(digits) == 9 and '0' not in digits:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 1000):\n        digits = str(first)\n        if len(set(digits)) != 3 or '0' in digits:\n            continue\n        second = first * 2\n        third = first * 3\n        if second >= 1000 or third >= 1000:\n            continue\n        second_digits = str(second)\n        third_digits = str(third)\n        all_digits = digits + second_digits + third_digits\n        if len(set(all_digits)) == 9 and '0' not in all_digits:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(1, 10):\n        second = first * 2\n        third = first * 3\n        if second < 10 and third < 10 and len({first, second, third}) == 3:\n            num1 = first * 100 + second * 10 + third\n            num2 = second * 100 + first * 10 + third\n            num3 = third * 100 + first * 10 + second\n            combinations.append((num1, num2, num3))\n    return sorted(combinations)\n```"}
{"task_id": "Python/9", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 333):\n        second = 2 * first\n        third = 3 * first\n        all_numbers = str(first) + str(second) + str(third)\n        if len(all_numbers) == 9 and len(set(all_numbers)) == 9 and '0' not in all_numbers:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 334):\n        second = first * 2\n        third = first * 3\n        if third > 999:\n            continue\n        digits = str(first) + str(second) + str(third)\n        if len(set(digits)) == 9 and '0' not in digits:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    from itertools import permutations\n\n    valid_combinations = []\n\n    for digits in permutations('123456789', 3):\n        first_num = int(''.join(digits))\n        second_num = 2 * first_num\n        third_num = 3 * first_num\n\n        all_digits = str(first_num) + str(second_num) + str(third_num)\n        if len(all_digits) == 9 and len(set(all_digits)) == 9 and '0' not in all_digits:\n            valid_combinations.append((first_num, second_num, third_num))\n\n    valid_combinations = sorted(list(set(valid_combinations)))\n    return valid_combinations\n```"}
{"task_id": "Python/9", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 333):\n        second = 2 * first\n        third = 3 * first\n        if third > 999:\n            continue\n        digits = set(str(first) + str(second) + str(third))\n        if len(digits) == 9 and '0' not in digits:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 334):\n        second = first * 2\n        third = first * 3\n        if third > 999:\n            continue\n        digits = str(first) + str(second) + str(third)\n        if len(set(digits)) == 9 and '0' not in digits:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 333):\n        second = first * 2\n        third = first * 3\n        if third > 999:\n            continue\n        combined = str(first) + str(second) + str(third)\n        if len(set(combined)) == 9 and '0' not in combined:\n            combinations.append((first, second, third))\n    return sorted(combinations)\n```"}
{"task_id": "Python/9", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(1, 10):\n        second = 2 * first\n        third = 3 * first\n        if second < 10 and third < 10 and len({first, second, third}) == 3:\n            combinations.append((first * 100 + second * 10 + third, \n                                 second * 100 + (2 * second) * 10 + (3 * second), \n                                 third * 100 + (2 * third) * 10 + (3 * third)))\n    valid_combinations = []\n    for first in range(1, 10):\n        second = 2 * first\n        third = 3 * first\n        if second < 10 and third < 10 and first != second and first != third and second != third:\n            valid_combinations.append((first * 100 + second * 10 + third, \n                                      second * 100 + (2 * second) * 10 + (3 * second), \n                                      third * 100 + (2 * third) * 10 + (3 * third)))\n    return sorted(valid_combinations)\n```"}
{"task_id": "Python/9", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    from itertools import permutations\n\n    valid_combinations = []\n    digits = set('123456789')\n\n    for num in range(123, 329):\n        num1 = num\n        num2 = 2 * num1\n        num3 = 3 * num1\n\n        combined = str(num1) + str(num2) + str(num3)\n        if len(combined) == 9 and len(set(combined)) == 9 and set(combined) == digits:\n            valid_combinations.append((num1, num2, num3))\n\n    return valid_combinations\n```"}
{"task_id": "Python/9", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(1, 10):\n        second = 2 * first\n        third = 3 * first\n        if second < 10 and third < 10 and len({first, second, third}) == 3:\n            combination = (first * 100 + second * 10 + third,\n                           second * 100 + first * 10 + third,\n                           third * 100 + first * 10 + second)\n            combinations.append(combination)\n    return sorted(combinations)\n```"}
{"task_id": "Python/9", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(100, 334):\n        second = first * 2\n        third = first * 3\n        if third > 999:\n            continue\n        digits = set(str(first) + str(second) + str(third))\n        if len(digits) == 9 and '0' not in digits:\n            combinations.append((first, second, third))\n    return combinations\n```"}
{"task_id": "Python/9", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for first in range(1, 10):\n        second = first * 2\n        third = first * 3\n        if second < 10 and third < 10:\n            digits = {first, second, third}\n            if len(digits) == 3:\n                num1 = first * 100 + second * 10 + third\n                num2 = second * 100 + first * 10 + third\n                num3 = third * 100 + first * 10 + second\n                # But the correct order is first, second, third\n                combinations.append((first * 100 + second * 10 + third, \n                                    second * 100 + first * 10 + third, \n                                    third * 100 + first * 10 + second))\n        else:\n            # Handle two-digit numbers\n            if second < 10 and third >= 10 and third < 100:\n                digits = {first, second, third // 10, third % 10}\n                if len(digits) == 4:\n                    combinations.append((first * 100 + second * 10 + third // 10, \n                                        second * 100 + first * 10 + third % 10, \n                                        third * 100 + first * 10 + second))\n            elif second >= 10 and second < 100 and third >= 100 and third < 1000:\n                digits = {first, second // 10, second % 10, third // 100, (third // 10) % 10, third % 10}\n                if len(digits) == 6:\n                    # This case is not possible since we need 3 numbers with 3 digits each and no repeats\n                    pass\n    # The above approach is flawed. Let's try a different approach:\n    combinations = []\n    for a in range(1, 10):\n        b = 2 * a\n        c = 3 * a\n        digits = set()\n        num1 = a\n        num2 = b\n        num3 = c\n        # Check if all numbers are single-digit\n        if b < 10 and c < 10:\n            digits = {a, b, c}\n            if len(digits) == 3:\n                combinations.append((a * 100 + b * 10 + c, b * 100 + a * 10 + c, c * 100 + a * 10 + b))\n        else:\n            # Handle cases where b or c are two-digit numbers\n            # This is getting complicated, perhaps better to generate all 3-digit combinations\n            pass\n    # The correct approach is to generate all 3-digit combinations with the given condition\n    # and ensure all digits are unique and from 1-9\n    combinations = []\n    for a in range(1, 10):\n        b = 2 * a\n        c = 3 * a\n        if b >= 10 or c >= 10:\n            continue\n        digits = {a, b, c}\n        if len(digits) == 3:\n            num1 = a * 100 + b * 10 + c\n            num2 = b * 100 + a * 10 + c\n            num3 = c * 100 + a * 10 + b\n            combinations.append((num1, num2, num3))\n    # After realizing the problem is about 3 separate numbers each with 3 digits:\n    # The correct interpretation is that each of the three numbers is a 3-digit number,\n    # with the second number being double the first, and the third triple the first,\n    # and all 9 digits in the combination are unique and from 1-9.\n    combinations = []\n    for first in range(123, 333):\n        second = first * 2\n        third = first * 3\n        if third > 987:\n            continue\n        digits = set()\n        num_str = str(first) + str(second) + str(third)\n        if '0' in num_str:\n            continue\n        digits = set(num_str)\n        if len(digits) == 9:\n            combinations.append((first, second, third))\n    return sorted(combinations)\n```"}
{"task_id": "Python/9", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\ndef find_number_combinations():\n    combinations = []\n    for num in range(123, 333):\n        num1 = num\n        num2 = 2 * num1\n        num3 = 3 * num1\n        if num3 > 987:\n            continue\n        digits = set()\n        temp = num1\n        while temp > 0:\n            digit = temp % 10\n            if digit == 0:\n                break\n            digits.add(digit)\n            temp = temp // 10\n        else:\n            temp = num2\n            while temp > 0:\n                digit = temp % 10\n                if digit == 0:\n                    break\n                digits.add(digit)\n                temp = temp // 10\n            else:\n                temp = num3\n                while temp > 0:\n                    digit = temp % 10\n                    if digit == 0:\n                        break\n                    digits.add(digit)\n                    temp = temp // 10\n                else:\n                    if len(digits) == 9:\n                        combinations.append((num1, num2, num3))\n    return combinations\n```"}
{"task_id": "Python/10", "language": "en", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "sq", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total = 0\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n        total += factorial\n    return total\n```"}
{"task_id": "Python/10", "language": "hy", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "bn", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "bg", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "zh", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total += current_factorial\n    return total\n```"}
{"task_id": "Python/10", "language": "fr", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "de", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "ha", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "hi", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total += current_factorial\n    return total\n```"}
{"task_id": "Python/10", "language": "hu", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "es", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total += current_factorial\n    return total\n```"}
{"task_id": "Python/10", "language": "arb", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "sw", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total_sum = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total_sum += current_factorial\n    return total_sum\n```"}
{"task_id": "Python/10", "language": "tr", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total += current_factorial\n    return total\n```"}
{"task_id": "Python/10", "language": "vi", "model_id": "deepseek-chat", "generated_text": "```python\ndef sum_of_factorials_optimized(n: int) -> int:\n    total = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        total += current_factorial\n    return total\n```"}
